-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
----/**/with profile_time
--
-- Euphoria 3.0 
--
-- A Euphoria Interpreter written 100% in Euphoria
--
-- usage:
--        ex eu.ex prog.ex     -- run a Euphoria program for DOS
--        exw eu.ex prog.exw   -- run a Euphoria program for Windows
--        exu eu.ex prog.exu   -- run a Euphoria program for Linux/FreeBSD

-- You can make this into a stand-alone .exe using the binder or the
-- Euphoria To C Translator. When translated/compiled it will run
-- much faster, but not as fast as the official RDS interpreter
-- which uses the same Euphoria-coded front-end, combined 
-- with a high-performance back-end carefully hand-coded in C.

without type_check -- FASTER
--PL The master hacked version.
-- Modified to run on 2.4 ($ removed).
--/**/include ../builtins/pmach.e   -- avoids machine_func/proc warnings (2, in opMF/opMP)

global constant TRUE = 1, FALSE = 0

global constant INTERPRET = TRUE,
                TRANSLATE = FALSE,
                BIND = FALSE
                
global constant EXTRA_CHECK = FALSE 

-- standard Euphoria includes
include misc.e
include wildcard.e

-- INTERPRETER front-end
--include global.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Global declarations 

global constant INTERPRETER_VERSION = "3.0.0"
global constant  TRANSLATOR_VERSION = "3.0.0"

global type boolean(integer x)
    return x = TRUE or x = FALSE
end type

global boolean mybsd -- set to true if very little RAM available (build fails)

-- operating system:
global constant ELINUX = platform() = LINUX,
                EWINDOWS = platform() = WIN32,
                EDOS = platform() = DOS32,
                EBSD = FALSE -- set manually - see also backend.ex

-- specific C compiler used (one may be TRUE)
global constant EWATCOM = TRUE,
                EBORLAND = FALSE,
                ELCC = FALSE,
                EDJGPP = FALSE 
                -- (assume GNU C for LINUX/FreeBSD)

global constant EGPM = 0,     -- GPM mouse support on Linux
                ENCURSES = 0  -- NCURSES 2-d positioning on Linux
                
global boolean w32 -- Windows option for BIND
--PL 20/11 w32 is not assigned a value (it's unused if BIND is false)
    w32=TRUE
                
global sequence version_name
if EDOS then
    if EDJGPP then
        version_name = "DOS32 built for DJGPP"
    else
        version_name = "DOS32"
    end if
elsif EWINDOWS then
    version_name = "WIN32"
elsif ELINUX then 
    version_name = "Linux"
end if

global integer PATH_SEPARATOR, SLASH
global sequence SLASH_CHARS
if ELINUX then
    PATH_SEPARATOR = ':' -- in PATH environment variable
    SLASH = '/'          -- preferred on Linux/FreeBSD
    SLASH_CHARS =  "/"   -- special chars allowed in a path
else
    PATH_SEPARATOR = ';'
    SLASH = '\\'
    SLASH_CHARS = "\\/:"
end if

-- common fields for all symbols, literal constants and temporaries 
global constant 
         S_OBJ = 1,   -- initialized for literal constants
                      -- NOVALUE for other temps 
                      -- run time object (vars)
                      -- must be first field in C
         S_NEXT = 2,  -- index of next temp, or next var, or 0
         S_MODE = 3,  -- M_NORMAL, M_TEMP or M_CONSTANT 
         S_SCOPE = 4, -- for temps at compile time: FREE or IN_USE, 
                      -- or DELETED (Translator-only) 
         S_USAGE = 5  -- for temps: type T_UNKNOWN or T_INTEGER 
                      -- for vars, read/written/to be deleted

-- extra fields for vars (and routines) only but not temps 
global constant 
         S_FILE_NO = 6,   -- file number where symbol is defined
         S_NAME = 7,      -- name string
         S_SAMEHASH = 8,  -- index of next symbol with same hash value
         S_TOKEN = 9,     -- token number to return to parser
         S_HASHVAL = 10,  -- hash value 
         S_NREFS = 11     -- number of references to this symbol 

         -- for vars only:  
global constant 
         S_VARNUM = 12,   -- local variable number 
         S_INITLEVEL = 13,-- nesting level where initialized or -1 
         S_VTYPE = 14     -- variable type or NULL 

         -- for routines only: 
global constant 
         S_CODE = 15,     -- IL code for proc/func/type 
         S_LINETAB = 16,  -- Line table for traceback
         S_FIRSTLINE = 17,-- global line number of start of routine
         S_TEMPS = 18,    -- pointer to linked list of temps, or 0
         S_OPCODE = 19,   -- opcode to emit (predefined subprograms)
         S_NUM_ARGS = 20, -- number of arguments
         S_EFFECT = 21,   -- side effects
         S_REFLIST = 22,  -- list of referenced symbols (for BIND)
         S_RESIDENT_TASK = 23, -- the task that's currently using this routine 
                               -- (at run-time) or 0 if none
         S_SAVED_PRIVATES = 24,-- private data of any suspended tasks 
                               -- executing this routine
         S_STACK_SPACE = 25 -- amount of stack space needed by this routine
                            -- (for private data)
         
-- extra fields for TRANSLATOR (for temps and vars/routines)
global constant 
         S_GTYPE = 26,    -- current global idea of what the worst-case type is
         S_OBJ_MIN = 27,  -- minimum integer value
         S_OBJ_MAX = 28,  -- maximum integer value
         S_SEQ_LEN = 29,  -- length of a sequence 
         S_SEQ_ELEM = 30, -- type of all elements of a sequence, or 
                          -- type returned by a function/type 
         S_TEMP_NAME = 31,-- for temps: number to use in the outputted C name
         S_ONE_REF = 32   -- TRUE if we see that a variable can only ever have 
                          -- 1 reference count

-- extra fields for TRANSLATOR (for vars/routines only) 
global constant   
         S_RI_TARGET = 33,   -- > 0 if targeted by a routine_id call or other
                             -- external call, e.g. call to a DLL
         S_LHS_SUBS2 = 34,   -- routine does double or more LHS subscripting
         S_GTYPE_NEW = 35,   -- new idea being formed of global type
         S_SEQ_LEN_NEW = 36, -- new idea being formed of length of a sequence
         S_SEQ_ELEM_NEW = 37,-- new type being formed on a pass
    
         S_OBJ_MIN_NEW = 38, -- new integer value
         S_OBJ_MAX_NEW = 39, -- new integer value
    
         S_ARG_TYPE = 40,    -- argument type info, stable and new versions
         S_ARG_TYPE_NEW = 41,     
    
         S_ARG_SEQ_ELEM = 42,
         S_ARG_SEQ_ELEM_NEW = 43,  
    
         S_ARG_MIN = 44,     -- argument min/max integers or NOVALUE or -NOVALUE
         S_ARG_MAX = 45,
         S_ARG_MIN_NEW = 46,
         S_ARG_MAX_NEW = 47,
    
         S_ARG_SEQ_LEN = 48,
         S_ARG_SEQ_LEN_NEW = 49

global constant SIZEOF_ROUTINE_ENTRY = 25 + 24 * TRANSLATE,
                SIZEOF_VAR_ENTRY     = 14 + 35 * TRANSLATE,
                SIZEOF_TEMP_ENTRY    =  5 + 27 * TRANSLATE
         
-- Permitted values for various symbol table fields

-- MODE values:
global constant 
         M_NORMAL   = 1,  -- all variables
         M_CONSTANT = 2,  -- literals and declared constants
         M_TEMP     = 3   -- temporaries

-- SCOPE values: 
global constant 
         SC_LOOP_VAR = 2,    -- "private" loop vars known within a single loop 
         SC_PRIVATE  = 3,    -- private within subprogram
         SC_GLOOP_VAR = 4,   -- "global" loop var 
         SC_LOCAL    = 5,    -- local to the file
         SC_GLOBAL   = 6,    -- global across all files 
         SC_PREDEF   = 7,    -- predefined symbol - could be overriden
         SC_KEYWORD  = 8,    -- a keyword
         SC_UNDEFINED = 9,   -- new undefined symbol 
         SC_MULTIPLY_DEFINED = 10  -- global symbol defined in 2 or more files

-- USAGE values          -- how symbol has been used (1,2 can be OR'd) 
global constant 
         U_UNUSED    = 0,     
         U_READ      = 1,
         U_WRITTEN   = 2,
         U_DELETED   = 99   -- we've decided to delete this symbol 

-- Does a routine have an effect other than just returning a value?
-- We use 30 bits of information (to keep it in integer range).
-- Bits 0..28 give a rough indication of which local/global vars execution of
-- a routine might directly or indirectly modify. This helps to optimize a rare 
-- situation when assigning to a multiply-subscripted sequence.
-- Bit 29 indicates all other side effects (I/O, task scheduling etc.)
global constant 
            E_PURE = 0,   -- routine has no side effects
            E_SIZE = 29,  -- number of bits for screening out vars
E_OTHER_EFFECT = power(2, E_SIZE),  -- routine has other effects, e.g. I/O
E_ALL_EFFECT = #3FFFFFFF -- all bits (0..29) are set, 
                             -- unspecified globals might be changed 
                             -- plus other effects
    
global constant FREE = 0, 
IN_USE = 1, 
DELETED = 2

-- result types
global constant T_INTEGER = 1,
                T_SEQUENCE = 3,
                T_ATOM = 4,
                T_UNKNOWN = 5
                
global constant MIN = 1,
                MAX = 2

global constant MAXINT = #3FFFFFFF,
                MININT = -MAXINT-1,   -- should be -ve
                MININT_VAL = MININT,  -- these are redundant ...
                MAXINT_VAL = MAXINT,
                MININT_DBL = MININT_VAL,
                MAXINT_DBL = MAXINT_VAL

global constant NOVALUE = -1.295837195871e307  
-- An unlikely number. If it occurs naturally, 
-- there will be a slight loss of optimization 
-- as we will not know the value of a variable at compile time.
-- (NaN could be used, but it's not 100% portable).

global sequence SymTab  -- the symbol table
SymTab = {}


--------- Global Types for Debugging -----------


global type symtab_entry(sequence x)
-- (could test all the fields)  
    return length(x) = SIZEOF_ROUTINE_ENTRY or 
           length(x) = SIZEOF_VAR_ENTRY
end type

global type symtab_index(integer x)
-- index of a normal symbol or temporary    
    if x = 0 then
        return TRUE -- NULL value
    end if
    if x < 0 or x > length(SymTab) then
        return FALSE
    end if
    return find(length(SymTab[x]), {SIZEOF_VAR_ENTRY, SIZEOF_ROUTINE_ENTRY,
                                    SIZEOF_TEMP_ENTRY})
end type

global type temp_index(integer x)
    return x >= 0 and x <= length(SymTab)
end type

-- token fields
global constant T_ID = 1,
                T_SYM = 2

global type token(sequence t)
-- scanner token
    return length(t) = 2 and integer(t[T_ID]) and symtab_index(t[T_SYM])
end type

global type file(integer f)
-- a file number
    return f >= -1 and f < 100 -- rough limit
end type

---------------- Global Variables ----------------------

global object eudir           -- path to Euphoria directory 
global sequence file_name     -- names of all the source files 
file_name = {}
global sequence file_name_entered -- interactively entered file name
file_name_entered = ""
global integer shroud_only   -- making an unbound .il file
shroud_only = FALSE
global integer current_file_no    -- current file number 
current_file_no = 1
global integer line_number  -- source line number within current file (16 bits)  
global integer gline_number  -- overall line number (32 bits) 
global symtab_index file_start_sym
global symtab_index TopLevelSub       -- s.t. index of top level procedure 
global symtab_index CurrentSub        -- s.t. index of current routine 
global integer num_routines      -- sequence number for routine_id lookups 
num_routines = 0
global integer Argc             -- (our) number of args to main 
global sequence Argv            -- (our) arguments to main 

-- With/Without Options
global integer OpWarning            -- compile-time warnings option 
global integer OpTrace              -- trace option 
global integer OpTypeCheck          -- type check option 
global integer OpProfileStatement   -- statement profile option currently on 
global integer OpProfileTime        -- time profile option currently on 

-- COMPILE only
global object dj_path, wat_path, bor_path
dj_path = 0         -- DJGPP directory or 0
wat_path = 0        -- WATCOM directory or 0
bor_path = 0        -- BORLAND directory or 0
global integer cfile_count, cfile_size 
cfile_count = 0
cfile_size = 0
global integer Initializing 
Initializing = FALSE

global sequence temp_name_type
temp_name_type = repeat({0, 0}, 4)  -- skip 1..4
global constant T_GTYPE = 1,
                T_GTYPE_NEW = 2

global integer Execute_id

global sequence Code       -- The IL Code we are currently working with
global sequence LineTable  -- the line table we are currently building

global sequence slist 
slist = {}
global constant SRC = 1,  -- line of source code
LINE = 2,  -- line number within file
LOCAL_FILE_NO = 3,  -- file number
OPTIONS = 4   -- options in effect

-- option bits:
global constant SOP_TRACE = #01,      -- statement trace
SOP_PROFILE_STATEMENT = #04, -- statement profile
SOP_PROFILE_TIME = #02    -- time profile


--include reswords.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- IL opcodes, scanner tokens etc.

global constant 
LESS       =  1,  -- keep relops consecutive LESS..GREATER, NOT 
GREATEREQ  =  2,
EQUALS     =  3,
NOTEQ      =  4,
LESSEQ     =  5,
GREATER    =  6,
NOT        =  7,
AND        =  8,
OR         =  9,
MINUS      = 10,
PLUS       = 11,
UMINUS     = 12,
MULTIPLY   = 13,
DIVIDE     = 14,
CONCAT     = 15,
ASSIGN_SUBS= 16,
GETS       = 17,
ASSIGN     = 18,
PRINT      = 19,
IF         = 20,
FOR        = 21,
ENDWHILE   = 22,
ELSE       = 23,
OR_BITS    = 24,  
RHS_SUBS   = 25,
XOR_BITS   = 26,  -- careful, same code as EOF
PROC       = 27,
RETURNF    = 28,
RETURNP    = 29,
PRIVATE_INIT_CHECK = 30,
RIGHT_BRACE_N = 31,  -- see also RIGHT_BRACE_2
REPEAT     = 32,
GETC       = 33,
RETURNT    = 34,
APPEND     = 35,
QPRINT     = 36,
OPEN       = 37,
PRINTF     = 38,
ENDFOR_GENERAL = 39,
IS_AN_OBJECT = 40,
SQRT       = 41,
LENGTH     = 42,
BADRETURNF = 43,
PUTS       = 44,
ASSIGN_SLICE = 45,
RHS_SLICE  = 46,
WHILE      = 47,
ENDFOR_INT_UP = 48,
ENDFOR_UP  = 49,
ENDFOR_DOWN = 50,
NOT_BITS    = 51,
ENDFOR_INT_DOWN = 52,
SPRINTF     = 53,  
ENDFOR_INT_UP1 = 54,
ENDFOR_INT_DOWN1 = 55,
AND_BITS = 56,
PREPEND = 57,
STARTLINE = 58,
CLEAR_SCREEN = 59,
POSITION = 60,
EXIT = 61,
RAND = 62,
FLOOR_DIV = 63,
TRACE = 64,
TYPE_CHECK = 65,
FLOOR_DIV2 = 66,
IS_AN_ATOM = 67,
IS_A_SEQUENCE = 68,
DATE = 69,
TIME = 70,
REMAINDER = 71,
POWER = 72,
ARCTAN = 73,
LOG = 74,
SPACE_USED = 75,
COMPARE = 76,
FIND = 77,
MATCH = 78,
GET_KEY = 79,
SIN = 80,
COS = 81,
TAN = 82,
FLOOR = 83,
ASSIGN_SUBS_CHECK = 84,
RIGHT_BRACE_2 = 85,
CLOSE = 86,
DISPLAY_VAR = 87,
ERASE_PRIVATE_NAMES = 88,
UPDATE_GLOBALS = 89,
ERASE_SYMBOL = 90,
GETENV = 91,
RHS_SUBS_CHECK = 92,
PLUS1 = 93,
IS_AN_INTEGER = 94,
LHS_SUBS = 95,
INTEGER_CHECK = 96,
SEQUENCE_CHECK = 97,
DIV2 = 98,
SYSTEM = 99,
COMMAND_LINE = 100,
ATOM_CHECK     = 101,
LESS_IFW       = 102,   -- keep relops consecutive LESS..GREATER, NOT
GREATEREQ_IFW  = 103,
EQUALS_IFW     = 104,
NOTEQ_IFW      = 105,
LESSEQ_IFW     = 106,
GREATER_IFW    = 107,
NOT_IFW        = 108,
GLOBAL_INIT_CHECK = 109,
NOP2           = 110,   -- Interpreter only
MACHINE_FUNC   = 111,
MACHINE_PROC   = 112,
ASSIGN_I       = 113,   -- keep these _I's together ... 
RHS_SUBS_I     = 114,
PLUS_I         = 115,
MINUS_I        = 116,
PLUS1_I        = 117,   -- ... they check for integer result
ASSIGN_SUBS_I  = 118,
LESS_IFW_I     = 119,   -- keep relop _I's consecutive LESS..GREATER
GREATEREQ_IFW_I = 120,
EQUALS_IFW_I   = 121,
NOTEQ_IFW_I    = 122,
LESSEQ_IFW_I   = 123,
GREATER_IFW_I  = 124,
FOR_I          = 125,
ABORT          = 126,
PEEK           = 127,
POKE           = 128,
CALL           = 129,
PIXEL          = 130,
GET_PIXEL      = 131,
MEM_COPY       = 132,
MEM_SET        = 133,
C_PROC         = 134,
C_FUNC         = 135,
ROUTINE_ID     = 136,
CALL_BACK_RETURN = 137,
CALL_PROC      = 138,
CALL_FUNC      = 139,
POKE4          = 140,
PEEK4S         = 141,
PEEK4U         = 142,
SC1_AND        = 143,
SC2_AND        = 144,
SC1_OR         = 145,
SC2_OR         = 146,
SC2_NULL       = 147,  -- no code address for this one
SC1_AND_IF     = 148,
SC1_OR_IF      = 149,
ASSIGN_SUBS2   = 150,  -- just for emit, not x.c
ASSIGN_OP_SUBS = 151,
ASSIGN_OP_SLICE= 152,
PROFILE        = 153,
XOR            = 154,
EQUAL          = 155,
SYSTEM_EXEC    = 156,
PLATFORM       = 157,
END_PARAM_CHECK= 158,
CONCAT_N       = 159,
NOPWHILE       = 160,  -- Translator only
NOP1           = 161,  -- Translator only
PLENGTH        = 162,
LHS_SUBS1      = 163,
PASSIGN_SUBS   = 164,
PASSIGN_SLICE  = 165,
PASSIGN_OP_SUBS= 166,
PASSIGN_OP_SLICE = 167,
LHS_SUBS1_COPY = 168,
TASK_CREATE = 169,
TASK_SCHEDULE = 170,
TASK_YIELD = 171,
TASK_SELF = 172,
TASK_SUSPEND = 173,
TASK_LIST = 174,
TASK_STATUS = 175,
TASK_CLOCK_STOP = 176,
TASK_CLOCK_START = 177,
MAX_OPCODE = 177

-- adding new opcodes possibly affects reswords.h (C-coded backend),
-- be_execute.c - optable[], localjumptab[]
-- be_runtime.c, redef.h, and maybe scanner.e, 
-- emit.e, keylist.h. Also, run makename.ex 

-- scanner codes

-- codes for characters that are simply returned to the parser 
-- without any processing <= -20
global constant
ILLEGAL_CHAR  = -20,
END_OF_FILE = -21,
DOLLAR = -22,
COLON = -23,
LEFT_BRACE = -24,
RIGHT_BRACE = -25,
LEFT_ROUND = -26,
RIGHT_ROUND = -27,
LEFT_SQUARE = -28,
RIGHT_SQUARE = -29,
COMMA = -30,
QUESTION_MARK = -31

-- codes for classes of characters that the scanner 
-- has to process in some way
global constant
NUMBER_SIGN = -11,
KEYWORD = -10,
BUILTIN = -9,
BLANK   = -8,
DIGIT   = -7,
NEWLINE = -6,
SINGLE_QUOTE = -5,
DOUBLE_QUOTE = -4,
DOT    = -3,
LETTER = -2,
BANG   = -1

-- other scanner tokens 
global constant VARIABLE = -100

global constant END_OF_FILE_CHAR = 26 -- use this char to indicate EOF

-- other keywords
global constant 
END       = 402,
TO        = 403,
BY        = 404,
PROCEDURE = 405,
FUNCTION  = 406,


THEN      = 409,
DO        = 410,
GLOBAL    = 411,
RETURN    = 412,
ELSIF     = 413,
OBJECT    = 414,
TYPE_DECL = 415,
CONSTANT  = 416,
INCLUDE   = 417,

WITH      = 419,
WITHOUT   = 420

global constant 
FUNC          = 501,
ATOM          = 502,
STRING        = 503,
TYPE          = 504,
QUALIFIED_VARIABLE = 515,
SLICE         = 516,
VARIABLE_DECL = 517,
PLUS_EQUALS   = 518,
MINUS_EQUALS  = 519,
MULTIPLY_EQUALS = 520,
DIVIDE_EQUALS = 521,
CONCAT_EQUALS = 522,
NAMESPACE     = 523,
QUALIFIED_FUNC = 524,
QUALIFIED_PROC = 525,
QUALIFIED_TYPE = 526


--include error.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Compile-time Error Handling

include machine.e

global constant STDIN = 0, STDERR = 2

integer Errors 
Errors = 0   -- number of errors detected during compile 

global integer TempErrFile
global sequence TempErrName
global object ThisLine        -- current line of source (or -1)
global integer bp             -- input line index of next character 

global sequence warning_list
warning_list = {}

global procedure screen_output(integer f, sequence msg)
-- output messages to the screen or a file    
    puts(f, msg)
end procedure

global procedure Warning(sequence msg)
-- add a warning message to the list
    sequence p
    
    if OpWarning then
        p = sprintf("Warning: %s\n", {msg})
        if find(p, warning_list) then
            return -- duplicate
        end if
        warning_list = append(warning_list, p)          
    end if
end procedure

global function ShowWarnings(integer errfile)
-- print the warnings to the screen (or ex.err)
    integer c
    
    for i = 1 to length(warning_list) do
        if errfile = 0 then
            screen_output(STDERR, warning_list[i])
            if remainder(i, 20) = 0 then
                puts(STDERR, "\nPress Enter to continue, q to quit\n\n")
                c = getc(0)
                if c = 'q' then
                    exit
                end if
            end if
        else
            puts(errfile, warning_list[i])
        end if
    end for
    return length(warning_list)
end function

global procedure Cleanup(integer status)
-- clean things up before quitting
    integer w
    
    w = ShowWarnings(0) 
    
    if not TRANSLATE
    and (BIND or EWINDOWS or ELINUX)
    and (w or Errors) then
        screen_output(STDERR, "\nPress Enter\n")
        if getc(0) then end if -- prompt
    end if
    
    abort(status)
end procedure

global procedure OpenErrFile()
-- open the error diagnostics file - normally "ex.err"
    TempErrFile = open(TempErrName, "w")
    if TempErrFile = -1 then
        if length(TempErrName) > 0 then
            screen_output(STDERR, "Can't create error message file: ")
            screen_output(STDERR, TempErrName)
            screen_output(STDERR, "\n")
        end if
        abort(1) --Cleanup(1)
    end if
end procedure

procedure ShowErr(integer f)
-- Show place where syntax error occurred  
    if length(file_name) = 0 then
        return
    end if
    if ThisLine[1] = END_OF_FILE_CHAR then
        screen_output(f, "<end-of-file>\n")
    else
        screen_output(f, ThisLine)
    end if
    
    for i = 1 to bp-2 do -- bp-1 points to last character read
        if ThisLine[i] = '\t' then
            screen_output(f, "\t")
        else
            screen_output(f, " ")
        end if
    end for
    screen_output(f, "^\n\n") 
end procedure

global procedure CompileErr(sequence msg)
-- Handle fatal compilation errors 
    sequence errmsg
    
    Errors += 1
    if length(file_name) then
        errmsg = sprintf("%.99s:%d\n%s\n", {file_name[current_file_no], 
                                            line_number, msg})
    else
        errmsg = msg
    end if
        -- try to open err file *before* displaying diagnostics on screen
    OpenErrFile() -- exits if error filename is ""
    screen_output(STDERR, errmsg)
    ShowErr(STDERR)
    
    puts(TempErrFile, errmsg) 
    
    ShowErr(TempErrFile) 
    
    if ShowWarnings(TempErrFile) then
    end if
    
    puts(TempErrFile, "\n")
    
    close(TempErrFile)
    Cleanup(1)
end procedure

procedure not_supported_compile(sequence feature)
-- report feature not supported
    CompileErr(sprintf("%s is not supported in Euphoria for %s", 
                       {feature, version_name}))
end procedure

global procedure InternalErr(sequence msg)
-- Handles internal compile-time errors
-- see RTInternal() for run-time internal errors
    if TRANSLATE then
        screen_output(STDERR, sprintf("Internal Error: %s\n", {msg}))
    else
        screen_output(STDERR, sprintf("Internal Error at %s:%d - %s\n", 
                                      {file_name[current_file_no], line_number, msg}))
    end if
    screen_output(STDERR, "\nPress Enter\n")
    if getc(0) then
    end if
    ?1/0
    --abort(1)
end procedure


--include keylist.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- KEYWORDS and BUILTIN ROUTINES

global constant 
    K_NAME = 1,      -- string
    K_SCOPE = 2,     -- keyword or predefined 
    K_TOKEN = 3,     -- token number returned to parser 
    K_OPCODE = 4,    -- opcode to emit (predefined subprograms) 
    K_NUM_ARGS = 5,  -- number of arguments (predefined subprograms) 
    K_EFFECT = 6     -- side effects 

global sequence keylist
-- N.B. order and number of keywords and builtins 
-- is assumed by scanner.e, euphoria\bin\keywords.e, and others
keylist = 
  {  
    -- KEYWORDS
   {"if",         SC_KEYWORD, IF, 0, 0, 0},
   {"end",    SC_KEYWORD, END, 0, 0, 0},
   {"then",   SC_KEYWORD, THEN, 0, 0, 0},
   {"procedure", SC_KEYWORD, PROCEDURE, 0, 0, 0},
   {"else",   SC_KEYWORD, ELSE, 0, 0, 0},
   {"for",    SC_KEYWORD, FOR, 0, 0, 0},
   {"return",     SC_KEYWORD, RETURN, 0, 0, 0},
   {"do",         SC_KEYWORD, DO, 0, 0, 0},
   {"elsif",      SC_KEYWORD, ELSIF, 0, 0, 0},
   {"while",      SC_KEYWORD, WHILE, 0, 0, 0},
   {"type",   SC_KEYWORD, TYPE_DECL, 0, 0, 0},
   {"constant",  SC_KEYWORD, CONSTANT, 0, 0, 0},
   {"to",         SC_KEYWORD, TO, 0, 0, 0},
   {"and",    SC_KEYWORD, AND, 0, 0, 0},
   {"or",         SC_KEYWORD, OR, 0, 0, 0},
   {"exit",   SC_KEYWORD, EXIT, 0, 0, 0},
   {"function",  SC_KEYWORD, FUNCTION, 0, 0, 0},
   {"global",     SC_KEYWORD, GLOBAL, 0, 0, 0},
   {"by",         SC_KEYWORD, BY, 0, 0, 0},
   {"not",    SC_KEYWORD, NOT, 0, 0, 0},
   {"include",   SC_KEYWORD, INCLUDE, 0, 0, 0},
   {"with",   SC_KEYWORD, WITH, 0, 0, 0},
   {"without",   SC_KEYWORD, WITHOUT, 0, 0, 0},
   {"xor",    SC_KEYWORD, XOR, 0, 0, 0},
    -- new ones must go at end to maintain compatibility with old shrouded code

    -- PREDEFINED SUBPROGRAMS and TYPEs 
   {"length",     SC_PREDEF, FUNC, LENGTH, 1, E_PURE},
   {"puts",   SC_PREDEF, PROC, PUTS, 2, E_OTHER_EFFECT},
   {"integer",   SC_PREDEF, TYPE, IS_AN_INTEGER, 1, E_PURE},
   {"sequence",  SC_PREDEF, TYPE, IS_A_SEQUENCE, 1, E_PURE},
   {"position",  SC_PREDEF, PROC, POSITION, 2, E_OTHER_EFFECT},
   {"object",     SC_PREDEF, TYPE, IS_AN_OBJECT, 1, E_PURE},
   {"append",     SC_PREDEF, FUNC, APPEND, 2, E_PURE},
   {"prepend",   SC_PREDEF, FUNC, PREPEND, 2, E_PURE},
   {"print",      SC_PREDEF, PROC, PRINT, 2, E_OTHER_EFFECT},
   {"printf",     SC_PREDEF, PROC, PRINTF, 3, E_OTHER_EFFECT},
   {"clear_screen", SC_PREDEF,PROC,CLEAR_SCREEN, 0, E_OTHER_EFFECT},
   {"floor",      SC_PREDEF, FUNC, FLOOR, 1, E_PURE},
   {"getc",   SC_PREDEF, FUNC, GETC, 1, E_OTHER_EFFECT},
   {"gets",   SC_PREDEF, FUNC, GETS, 1, E_OTHER_EFFECT},
   {"get_key",   SC_PREDEF, FUNC, GET_KEY, 0, E_PURE}, -- tiny effect, unimportant
   {"rand",   SC_PREDEF, FUNC, RAND, 1, E_PURE}, -- effect usually not important
   {"repeat",     SC_PREDEF, FUNC, REPEAT, 2, E_PURE},
   {"atom",   SC_PREDEF, TYPE, IS_AN_ATOM, 1, E_PURE},
   {"compare",   SC_PREDEF, FUNC, COMPARE, 2, E_PURE},
   {"find",   SC_PREDEF, FUNC, FIND, 2, E_PURE},
   {"match",      SC_PREDEF, FUNC, MATCH, 2, E_PURE},
   {"time",   SC_PREDEF, FUNC, TIME, 0, E_PURE},
   {"command_line",SC_PREDEF,FUNC,COMMAND_LINE, 0, E_PURE},
   {"open",   SC_PREDEF, FUNC, OPEN, 2, E_OTHER_EFFECT},
   {"close",      SC_PREDEF, PROC, CLOSE, 1, E_OTHER_EFFECT},
   {"trace",      SC_PREDEF, PROC, TRACE, 1, E_PURE},
   {"getenv",     SC_PREDEF, FUNC, GETENV, 1, E_PURE},
   {"sqrt",   SC_PREDEF, FUNC, SQRT, 1, E_PURE},
   {"sin",    SC_PREDEF, FUNC, SIN, 1, E_PURE},
   {"cos",    SC_PREDEF, FUNC, COS, 1, E_PURE},
   {"tan",    SC_PREDEF, FUNC, TAN, 1, E_PURE},
   {"log",    SC_PREDEF, FUNC, LOG, 1, E_PURE},
   {"system",     SC_PREDEF, PROC, SYSTEM, 2, E_OTHER_EFFECT},
   {"date",   SC_PREDEF, FUNC, DATE, 0, E_PURE}, 
   {"remainder", SC_PREDEF, FUNC, REMAINDER, 2, E_PURE},
   {"power",      SC_PREDEF, FUNC, POWER, 2, E_PURE},
   {"machine_func", SC_PREDEF, FUNC, MACHINE_FUNC, 2, E_OTHER_EFFECT},
   {"machine_proc", SC_PREDEF, PROC, MACHINE_PROC, 2, E_OTHER_EFFECT},
   {"abort",      SC_PREDEF, PROC, ABORT, 1, E_OTHER_EFFECT},
   {"peek",   SC_PREDEF, FUNC, PEEK, 1, E_PURE},
   {"poke",   SC_PREDEF, PROC, POKE, 2, E_OTHER_EFFECT},
   {"call",   SC_PREDEF, PROC, CALL, 1, E_OTHER_EFFECT},
   {"sprintf",   SC_PREDEF, FUNC, SPRINTF, 2, E_PURE},
   {"arctan",     SC_PREDEF, FUNC, ARCTAN, 1, E_PURE},
   {"and_bits",  SC_PREDEF, FUNC, AND_BITS, 2, E_PURE},
   {"or_bits",   SC_PREDEF, FUNC, OR_BITS, 2, E_PURE},
   {"xor_bits",  SC_PREDEF, FUNC, XOR_BITS, 2, E_PURE},
   {"not_bits",  SC_PREDEF, FUNC, NOT_BITS, 1, E_PURE},
   {"pixel",      SC_PREDEF, PROC, PIXEL, 2, E_OTHER_EFFECT},
   {"get_pixel", SC_PREDEF, FUNC, GET_PIXEL, 1, E_PURE},
   {"mem_copy",  SC_PREDEF, PROC, MEM_COPY, 3, E_OTHER_EFFECT},
   {"mem_set",   SC_PREDEF, PROC, MEM_SET, 3, E_OTHER_EFFECT},
   {"c_proc",     SC_PREDEF, PROC, C_PROC, 2,  E_ALL_EFFECT}, 
   {"c_func",     SC_PREDEF, FUNC, C_FUNC, 2, E_ALL_EFFECT},
   {"routine_id",SC_PREDEF, FUNC, ROUTINE_ID, 1, E_PURE},
   {"call_proc", SC_PREDEF, PROC, CALL_PROC, 2, E_ALL_EFFECT},
   {"call_func", SC_PREDEF, FUNC, CALL_FUNC, 2, E_ALL_EFFECT},
   {"poke4",      SC_PREDEF, PROC, POKE4, 2, E_OTHER_EFFECT},
   {"peek4s",     SC_PREDEF, FUNC, PEEK4S, 1, E_PURE},
   {"peek4u",     SC_PREDEF, FUNC, PEEK4U, 1, E_PURE},
   {"profile",   SC_PREDEF, PROC, PROFILE, 1, E_PURE},
   {"equal",      SC_PREDEF, FUNC, EQUAL, 2, E_PURE},
   {"system_exec",SC_PREDEF,FUNC, SYSTEM_EXEC, 2, E_OTHER_EFFECT},
   {"platform",  SC_PREDEF, FUNC, PLATFORM, 0, E_PURE},
   {"task_create", SC_PREDEF, FUNC, TASK_CREATE, 2, E_OTHER_EFFECT},
   {"task_schedule", SC_PREDEF, PROC, TASK_SCHEDULE, 2, E_OTHER_EFFECT},
   {"task_yield", SC_PREDEF, PROC, TASK_YIELD, 0, E_ALL_EFFECT},
   {"task_self", SC_PREDEF, FUNC, TASK_SELF,  0, E_PURE},
   {"task_suspend", SC_PREDEF, PROC, TASK_SUSPEND, 1, E_OTHER_EFFECT},
   {"task_list", SC_PREDEF, FUNC, TASK_LIST, 0, E_PURE},
   {"task_status", SC_PREDEF, FUNC, TASK_STATUS, 1, E_PURE},
   {"task_clock_stop", SC_PREDEF, PROC, TASK_CLOCK_STOP, 0, E_PURE},
   {"task_clock_start", SC_PREDEF, PROC, TASK_CLOCK_START, 0, E_PURE}
}
    -- new words must go at end to maintain compatibility 

if EXTRA_CHECK then
    -- for debugging storage leaks
    keylist = append(keylist, {"space_used", SC_PREDEF, FUNC, SPACE_USED, 
                               0, E_PURE})
end if
    
-- top level pseudo-procedure (assumed to be last on the list) 
keylist = append(keylist, {"_toplevel_", SC_PREDEF, PROC, 0, 0, E_ALL_EFFECT})


--include c_out.e    -- Translator output (leave in for now)
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Translator Routines for outputting C code

-- gtype values, TRANSLATOR:
global constant TYPE_NULL = 0,    -- initial value for ORing of types
TYPE_INTEGER = 1, -- definitely in Euphoria integer form
TYPE_DOUBLE = 2,  -- definitely in double form
TYPE_ATOM = 4,    -- a value stored as either an integer or a double
TYPE_SEQUENCE = 8,-- definitely a sequence 
TYPE_OBJECT = 16  -- could be unknown or anything 

global boolean emit_c_output
emit_c_output = FALSE

global file c_code, c_h

global integer main_name_num, init_name_num
main_name_num = 0
init_name_num = 0

--PL 1/3/07 target clash, appears unused...
global sequence novalue
--, target
novalue = {MININT, MAXINT}
--target = {0, 0}

global procedure c_putc(integer c)
-- output a byte of C source code 
    if emit_c_output then
        puts(c_code, c)
    end if
end procedure

global procedure c_hputs(sequence c_source)
-- output a string of C source code to the .h file 
    if emit_c_output then
        puts(c_h, c_source)    
    end if
end procedure

global procedure c_puts(sequence c_source)
-- output a string of C source code 
    if emit_c_output then
        puts(c_code, c_source)
    end if
end procedure

global procedure c_hprintf(sequence format, integer value)
-- output C source code to a .h file with (one) 4-byte formatted value
    if emit_c_output then
        printf(c_h, format, value)
    end if
end procedure

global procedure c_printf(sequence format, integer value)
-- output C source code with (one) 4-byte formatted value (should allow multiple values later)
    if emit_c_output then
        printf(c_code, format, value)
    end if
end procedure

constant CREATE_INF = "(1.0/sqrt(0.0))"
-- I don't think we need these currently. They can't happen at compile-time
-- because we don't fold f.p. operations
constant CREATE_NAN1 = "sqrt(-1.0)",
         CREATE_NAN2 = "((1.0/sqrt(0.0)) / (1.0/sqrt(0.0)))"

global procedure c_printf8(atom value)
-- output C source code with (one) 8-byte formatted value 
    sequence buff
    integer neg, p
    
    if emit_c_output then
        neg = 0
        buff = sprintf("%.16e", value)
        if length(buff) < 10 then
            -- funny f.p. value
            p = 1
            while p <= length(buff) do
                if buff[p] = '-' then
                    neg = 1

                elsif buff[p] = 'i' or buff[p] = 'I' then
                    -- inf 
                    buff = CREATE_INF
                    if neg then
                        buff = prepend(buff, '-')
                    end if
                    exit
                
                elsif buff[p] = 'n' or buff[p] = 'N' then
                    -- NaN - not needed currently 
                    if ELINUX then
                        buff = CREATE_NAN1
                        if neg then
                            buff = prepend(buff, '-')
                        end if
                    else
                        if sequence(wat_path) or sequence(bor_path) then
                            buff = CREATE_NAN2
                            if not neg then
                                buff = prepend(buff, '-')
                            end if
                        
                        else 
                            buff = CREATE_NAN1
                            if neg then
                                buff = prepend(buff, '-')
                            end if
                        end if
                        exit
                    end if
                end if
                p += 1
            end while
        end if
        puts(c_code, buff)
    end if
end procedure


global integer indent       -- long term indent with braces
indent = 0
global integer temp_indent  -- just for next statement
temp_indent = 0

global procedure adjust_indent_before(sequence stmt)
-- adjust indent before a statement 
    integer p, i
    boolean lb, rb
    
    if not emit_c_output then
        return
    end if
    
    p = 1
    lb = FALSE
    rb = FALSE
    while p <= length(stmt) and stmt[p] != '\n' do
        if stmt[p] = '}' then
            rb = TRUE
        elsif stmt[p] = '{' then
            lb = TRUE
        end if
        p += 1
    end while
    if rb and not lb then
        indent -= 4
    end if
    
    i = indent + temp_indent
    while i >= 4 do
        c_puts("    ")
        i -= 4
    end while
    while i > 0 do 
        c_putc(' ')
        i -= 1
    end while
    temp_indent = 0    
end procedure

global procedure adjust_indent_after(sequence stmt)
-- adjust indent after a statement 
    integer p
    
    if not emit_c_output then
        return
    end if
    
    p = 1
    while p <= length(stmt) and stmt[p] != '\n' do
        if stmt[p] = '{' then
            indent += 4
            return
        end if
        p += 1
    end while
    if length(stmt) >= 3 and equal("if ", stmt[1..3]) then
        temp_indent = 4
    elsif length(stmt) >= 5 and equal("else", stmt[1..4])
      and (stmt[5] = ' ' or stmt[5] = '\n') then
        temp_indent = 4
    end if
end procedure

--include symtab.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Symbol Table Routines

constant NBUCKETS = 2003  -- prime helps  
global sequence buckets   -- hash buckets
buckets = repeat(0, NBUCKETS)

global symtab_index object_type       -- s.t. index of object type 
global symtab_index atom_type         -- s.t. index of atom type 
global symtab_index sequence_type     -- s.t. index of sequence type 
global symtab_index integer_type      -- s.t. index of integer type 

--PL 20/11 unused (another e_routine is defined, and used, in execute.e)
--sequence e_routine     -- sequence of symbol table pointers for routine_id
--e_routine = {}

global symtab_index literal_init
literal_init = 0

sequence lastintval, lastintsym
lastintval = {}
lastintsym = {}

global integer last_sym
last_sym = 0
     
function hashfn(sequence name) 
-- hash function for symbol table
    integer len
    integer val -- max is 268,448,190+len

    len = length(name)
    val = name[len] * 256 + name[1]*2 + len
    if len >= 4 then
        val = val * 64 + name[2]
        val = val * 64 + name[3]
    elsif len >= 3 then
        val = val * 64 + name[2]
    end if
    return remainder(val, NBUCKETS) + 1
end function

global function NewEntry(sequence name, integer varnum, integer scope, 
          integer tokno, integer hashval, symtab_index samehash, 
          symtab_index type_sym)
-- Enter a symbol into the table at the next available position 
    sequence new

    if TRANSLATE then
        new = repeat(0, SIZEOF_ROUTINE_ENTRY)
    else
        new = repeat(0, SIZEOF_VAR_ENTRY)
    end if
    
    new[S_NEXT] = 0
    new[S_NAME] = name
    new[S_SCOPE] = scope
    new[S_MODE] = M_NORMAL
    new[S_USAGE] = U_UNUSED
    new[S_FILE_NO] = current_file_no


    if TRANSLATE then
        -- initialize extra fields for Translator
        new[S_GTYPE] = TYPE_OBJECT
        new[S_GTYPE_NEW] = TYPE_NULL
    
        new[S_SEQ_ELEM] = TYPE_OBJECT
        new[S_SEQ_ELEM_NEW] = TYPE_NULL -- starting point for ORing
    
        new[S_ARG_TYPE] = TYPE_OBJECT
        new[S_ARG_TYPE_NEW] = TYPE_NULL
    
        new[S_ARG_SEQ_ELEM] = TYPE_OBJECT
        new[S_ARG_SEQ_ELEM_NEW] = TYPE_NULL
    
        new[S_ARG_MIN] = NOVALUE
        new[S_ARG_MIN_NEW] = -NOVALUE
    
        new[S_ARG_SEQ_LEN] = NOVALUE
        new[S_ARG_SEQ_LEN_NEW] = -NOVALUE
    
        new[S_SEQ_LEN] = NOVALUE
        new[S_SEQ_LEN_NEW] = -NOVALUE -- no idea yet
    
        new[S_NREFS] = 0
        new[S_ONE_REF] = TRUE          -- assume TRUE until we find otherwise
        new[S_RI_TARGET] = 0

        new[S_OBJ_MIN] = MININT
        new[S_OBJ_MIN_NEW] = -NOVALUE -- no idea yet
    
        new[S_OBJ_MAX] = MAXINT
        new[S_OBJ_MAX_NEW] = -NOVALUE -- missing from C code? (not needed)
    end if
   
    new[S_TOKEN] = tokno
    new[S_VARNUM] = varnum
    new[S_INITLEVEL] = -1
    new[S_VTYPE] = type_sym
    new[S_HASHVAL] = hashval
    new[S_SAMEHASH] = samehash
    new[S_OBJ] = NOVALUE -- important 
    
    -- add new symbol to the end of the symbol table
    SymTab = append(SymTab, new)
    if last_sym then
        SymTab[last_sym][S_NEXT] = length(SymTab)
    end if
    last_sym = length(SymTab)
    return last_sym
end function

constant BLANK_ENTRY = repeat(0, SIZEOF_TEMP_ENTRY)

global function tmp_alloc()
-- return SymTab index for a new temporary var/literal constant
    symtab_index new
    
    SymTab = append(SymTab, BLANK_ENTRY)
    new = length(SymTab)
    SymTab[new][S_USAGE] = T_UNKNOWN
   
    if TRANSLATE then
        SymTab[new][S_GTYPE] = TYPE_OBJECT
        SymTab[new][S_OBJ_MIN] = MININT
        SymTab[new][S_OBJ_MAX] = MAXINT
        SymTab[new][S_SEQ_LEN] = NOVALUE
        SymTab[new][S_SEQ_ELEM] = TYPE_OBJECT  -- other fields set later
        if length(temp_name_type)+1 = 8087 then
            -- don't use _8087 - it conflicts with WATCOM
            temp_name_type = append(temp_name_type, {0, 0})
        end if
        temp_name_type = append(temp_name_type, {TYPE_OBJECT, TYPE_NULL})
        SymTab[new][S_TEMP_NAME] = length(temp_name_type)
    end if
   
    return new
end function

--PL 16/12 unused
--function PrivateName(sequence name, symtab_index proc)
---- does name match that of a private in the current active proc?
--  symtab_index s
--  
--  s = proc[S_NEXT] -- start at next entry
--  while s and s[S_SCOPE] <= SC_PRIVATE do
--  if equal(name, SymTab[s][S_NAME]) then
--      return TRUE
--  end if
--  s = SymTab[s][S_NEXT]
--  end while
--  return FALSE
--end function

global procedure DefinedYet(symtab_index sym)
-- make sure sym has not been defined yet, except possibly as
-- a predefined symbol, or a global in a previous file 
    if not find(SymTab[sym][S_SCOPE], 
                {SC_UNDEFINED, SC_MULTIPLY_DEFINED, SC_PREDEF}) then
        if SymTab[sym][S_FILE_NO] = current_file_no then
            CompileErr(sprintf("attempt to redefine %s", {SymTab[sym][S_NAME]}))
        end if
    end if
end procedure

global function name_ext(sequence s)
-- Returns the file name & extension part of a path.
-- Note: both forward slash and backslash are handled for all platforms. 
    integer i
    
    i = length(s)
    while i >= 1 and not find(s[i], "/\\:") do  
        i -= 1
    end while
    
--PL run on 2.4:
--  return s[i+1..$]
    return s[i+1..length(s)]
end function

constant SEARCH_LIMIT = 20 + 500 * (TRANSLATE or BIND)

global function NewStringSym(sequence s)
-- create a new temp that holds a string 
    symtab_index p, tp, prev
    integer search_count

    -- check if it exists already
    tp = literal_init
    prev = 0
    search_count = 0
    while tp != 0 do
        search_count += 1
        if search_count > SEARCH_LIMIT then  -- avoid n-squared algorithm
            exit
        end if
        if equal(s, SymTab[tp][S_OBJ]) then
            -- move it to first on list
            if tp != literal_init then
                SymTab[prev][S_NEXT] = SymTab[tp][S_NEXT]
                SymTab[tp][S_NEXT] = literal_init
                literal_init = tp
            end if
            return tp
        end if
        prev = tp
        tp = SymTab[tp][S_NEXT]
    end while
    
    p = tmp_alloc()
    SymTab[p][S_OBJ] = s
   
    if TRANSLATE then
        SymTab[p][S_MODE] = M_TEMP    -- override CONSTANT for compile
        SymTab[p][S_GTYPE] = TYPE_SEQUENCE
        SymTab[p][S_SEQ_LEN] = length(s)
        if SymTab[p][S_SEQ_LEN] > 0 then
            SymTab[p][S_SEQ_ELEM] = TYPE_INTEGER
        else 
            SymTab[p][S_SEQ_ELEM] = TYPE_NULL
        end if
        c_printf("int _%d;\n", SymTab[p][S_TEMP_NAME])
        c_hprintf("extern int _%d;\n", SymTab[p][S_TEMP_NAME])
    
    else
        SymTab[p][S_MODE] = M_CONSTANT
   
    end if
   
    SymTab[p][S_NEXT] = literal_init
    literal_init = p
    return p
end function

global function NewIntSym(integer int_val)
-- New integer symbol 
-- int_val must not be too big for a Euphoria int 
    symtab_index p
    integer x
    
    x = find(int_val, lastintval) 
    if x then
        return lastintsym[x]  -- saves space, helps Translator reduce code size
        
    else 
        p = tmp_alloc()
        SymTab[p][S_MODE] = M_CONSTANT
        SymTab[p][S_OBJ] = int_val
       
        if TRANSLATE then
            SymTab[p][S_OBJ_MIN] = int_val
            SymTab[p][S_OBJ_MAX] = int_val
            SymTab[p][S_GTYPE] = TYPE_INTEGER
        end if
       
        lastintval = prepend(lastintval, int_val)
        lastintsym = prepend(lastintsym, p)
        if length(lastintval) > SEARCH_LIMIT then
            lastintval = lastintval[1..floor(SEARCH_LIMIT/2)]
        end if
        return p
    end if
end function

global function NewDoubleSym(atom d)
-- allocate space for a new double literal value at compile-time 
    symtab_index p, tp, prev
    integer search_count
    
    -- check if it exists already
    tp = literal_init
    prev = 0
    search_count = 0
    while tp != 0 do
        search_count += 1
        if search_count > SEARCH_LIMIT then  -- avoid n-squared algorithm
            exit
        end if
        if equal(d, SymTab[tp][S_OBJ]) then
            -- found it
            if tp != literal_init then
            -- move it to first on list
                SymTab[prev][S_NEXT] = SymTab[tp][S_NEXT]
                SymTab[tp][S_NEXT] = literal_init
                literal_init = tp
            end if
            return tp
        end if
        prev = tp
        tp = SymTab[tp][S_NEXT]
    end while
    
    p = tmp_alloc()
    SymTab[p][S_MODE] = M_CONSTANT
    SymTab[p][S_OBJ] = d
   
    if TRANSLATE then
        SymTab[p][S_MODE] = M_TEMP  -- override CONSTANT for compile
        SymTab[p][S_GTYPE] = TYPE_DOUBLE
        c_printf("int _%d;\n", SymTab[p][S_TEMP_NAME])
        c_hprintf("extern int _%d;\n", SymTab[p][S_TEMP_NAME])
    end if
   
    SymTab[p][S_NEXT] = literal_init
    literal_init = p
    return p
end function

global integer temps_allocated   -- number of temps allocated for CurrentSub 
temps_allocated = 0

global function NewTempSym()
-- allocate a new temp and link it with the list of temps
-- for the current subprogram 
    symtab_index p, q
    
    p = SymTab[CurrentSub][S_TEMPS]
    while p != 0 and SymTab[p][S_SCOPE] != FREE do
        p = SymTab[p][S_NEXT]
    end while
    
    if p = 0 then
        -- no free temps available 
        temps_allocated += 1
        p = tmp_alloc()
        SymTab[p][S_MODE] = M_TEMP
        SymTab[p][S_NEXT] = SymTab[CurrentSub][S_TEMPS]
        SymTab[CurrentSub][S_TEMPS] = p
   
    elsif TRANSLATE then
    -- found a free temp - make another with same name, 
    -- add it to the list, and "delete" the first one 
    
        -- remove p from the list 
        SymTab[p][S_SCOPE] = DELETED
    
        q = tmp_alloc()
        SymTab[q][S_MODE] = M_TEMP
        SymTab[q][S_TEMP_NAME] = SymTab[p][S_TEMP_NAME]
        SymTab[q][S_NEXT] = SymTab[CurrentSub][S_TEMPS]
        SymTab[CurrentSub][S_TEMPS] = q
        p = q
   
    end if
   
    if TRANSLATE then
        SymTab[p][S_GTYPE] = TYPE_OBJECT
        SymTab[p][S_SEQ_ELEM] = TYPE_OBJECT
    end if
   
    SymTab[p][S_OBJ] = NOVALUE
    SymTab[p][S_USAGE] = T_UNKNOWN
    SymTab[p][S_SCOPE] = IN_USE
    return p
end function

global procedure InitSymTab()
-- Initialize the Symbol Table 
--PL 20/11 len is not used:
    integer hashval --, len
    --register symtab_index *bptr
    symtab_index s,st_index
    sequence kname
    
    for k = 1 to length(keylist) do 
        kname = keylist[k][K_NAME]
--PL 20/11 len is not used (it is set, but not used)
--      len = length(kname)
        hashval = hashfn(kname)
        st_index = NewEntry(kname,
                            0, 
                            keylist[k][K_SCOPE], 
                            keylist[k][K_TOKEN],
                            hashval, 0, 0)
        if find(keylist[k][K_TOKEN], {PROC, FUNC, TYPE}) then
            SymTab[st_index] = SymTab[st_index] & 
                               repeat(0, SIZEOF_ROUTINE_ENTRY - 
                                      length(SymTab[st_index]))         
            SymTab[st_index][S_NUM_ARGS] = keylist[k][K_NUM_ARGS]
            SymTab[st_index][S_OPCODE] = keylist[k][K_OPCODE]
            SymTab[st_index][S_EFFECT] = keylist[k][K_EFFECT]
            SymTab[st_index][S_REFLIST] = {}
        end if
        if keylist[k][K_TOKEN] = PROC then
            if equal(kname, "_toplevel_") then
                TopLevelSub = st_index
            end if
        elsif keylist[k][K_TOKEN] = TYPE then
            if equal(kname, "object") then
                object_type = st_index
            elsif equal(kname, "atom") then
                atom_type = st_index
            elsif equal(kname, "integer") then
                integer_type = st_index
            elsif equal(kname, "sequence") then
                sequence_type = st_index
            end if
        end if
        if buckets[hashval] = 0 then
            buckets[hashval] = st_index
        else 
            s = buckets[hashval]
            while SymTab[s][S_SAMEHASH] != 0 do 
                s = SymTab[s][S_SAMEHASH]
            end while
            SymTab[s][S_SAMEHASH] = st_index
        end if
    end for
    file_start_sym = length(SymTab)
end procedure

global procedure add_ref(token tok)
-- BIND only: add a reference to a symbol from the current routine
    symtab_index s
    
    s = tok[T_SYM]
    if s != CurrentSub -- ignore self-ref's
    and not find(s, SymTab[CurrentSub][S_REFLIST]) then
        -- new reference
        SymTab[s][S_NREFS] += 1
        SymTab[CurrentSub][S_REFLIST] &= s
    end if  
end procedure

global procedure MarkTargets(symtab_index s, integer attribute)
-- Note the possible targets of a routine id call 
    symtab_index p
    sequence sname
    sequence strng
    integer colon, h
    
    if (SymTab[s][S_MODE] = M_TEMP or
        SymTab[s][S_MODE] = M_CONSTANT)
    and sequence(SymTab[s][S_OBJ]) then
        -- hard-coded string
        strng = SymTab[s][S_OBJ] 
        colon = find(':', strng)
        if colon = 0 then
            sname = strng
        else 
--PL run on 2.4:
--          sname = strng[colon+1..$]    -- ignore namespace part
            sname = strng[colon+1..length(strng)] -- ignore namespace part
            while length(sname) and (sname[1] = ' ' or sname[1] = '\t') do
--PL run on 2.4:
--              sname = sname[2..$]
                sname = sname[2..length(sname)]
            end while   
        end if
    
        -- simple approach - mark all names in hash bucket that match, 
        -- ignoring GLOBAL/LOCAL 
        if length(sname) = 0 then
            return
        end if
        h = buckets[hashfn(sname)]
        while h do
            if equal(sname, SymTab[h][S_NAME]) then
                if attribute = S_NREFS then
                    if BIND then
                        add_ref({PROC, h})
                    end if
                else
                    SymTab[h][attribute] += 1
                end if
            end if
            h = SymTab[h][S_SAMEHASH]
        end while           
    else 
        -- mark all visible routines parsed so far 
        p = SymTab[TopLevelSub][S_NEXT]
        while p != 0 do
            if SymTab[p][S_FILE_NO] = current_file_no or
            SymTab[p][S_SCOPE] = SC_GLOBAL then
                SymTab[p][attribute] += 1
            end if
            p = SymTab[p][S_NEXT]
        end while
    end if
end procedure

global sequence dup_globals

global function keyfind(sequence word, integer file_no)
-- Uses hashing algorithm to try to match 'word' in the symbol
-- table. If not found, 'word' must be a new user-defined identifier. 
-- If file_no is not -1 then file_no must match and symbol must be a GLOBAL. 
    integer hashval, scope, defined
    symtab_index st_ptr
    token tok, gtok

    dup_globals = {}
    hashval = hashfn(word)
    st_ptr = buckets[hashval] 
    
    while st_ptr do
        if equal(word, SymTab[st_ptr][S_NAME]) then
        -- name matches 
        
            tok = {SymTab[st_ptr][S_TOKEN], st_ptr}
        
            if file_no = -1 then
            -- unqualified  
        
        -- Consider: S_PREDEF 
        
                scope = SymTab[st_ptr][S_SCOPE]
        
                if scope = SC_GLOBAL then
                    if current_file_no = SymTab[st_ptr][S_FILE_NO] then
                    -- found global in current file 
               
                        if BIND then
                            add_ref(tok)
                        end if
               
                        return tok
                    end if
                    -- found global in another file 
                    gtok = tok
                    dup_globals &= st_ptr               
                    -- continue looking for more globals with same name 
        
                elsif scope = SC_LOCAL then 
                    if current_file_no = SymTab[st_ptr][S_FILE_NO] then
                    -- found local in current file 
               
                        if BIND then
                            add_ref(tok)
                        end if
              
                        return tok
                    end if
        
                elsif scope = SC_PREDEF then
                    if length(dup_globals) = 0 then
               
                        if BIND then
                            add_ref(tok)
                        end if
               
                        return tok
                    end if
                    -- else a global has overridden this symbol 
        
                else 
               
                    if BIND then
                        add_ref(tok)
                    end if
               
                    return tok -- keyword, private
        
                end if
        
            else 
            -- qualified - must match global symbol in specified file 
                if file_no = SymTab[tok[T_SYM]][S_FILE_NO]
                and SymTab[tok[T_SYM]][S_SCOPE] = SC_GLOBAL then
               
                    if BIND then
                        add_ref(tok)
                    end if
               
                    return tok 
                end if
            end if
        
        -- otherwise keep looking 
        end if 
    
        st_ptr = SymTab[st_ptr][S_SAMEHASH]
    end while
    
    if length(dup_globals) = 1 then
    -- matched exactly one global
               
        if BIND then
            add_ref(gtok)
        end if
               
        return gtok
    end if
    
    -- couldn't find unique one 
    if length(dup_globals) = 0 then
        defined = SC_UNDEFINED
    else
        defined = SC_MULTIPLY_DEFINED
    end if
    tok = {VARIABLE, NewEntry(word, 0, defined, 
                              VARIABLE, hashval, buckets[hashval], 0)}
    buckets[hashval] = tok[T_SYM]
    return tok  -- no ref on newly declared symbol
end function


global procedure Hide(symtab_index s)
-- remove the visibility of a symbol
-- by deleting it from its hash chain 
    symtab_index prev, p

    p = buckets[SymTab[s][S_HASHVAL]]
    prev = 0
    while p != s and p != 0 do
        prev = p
        p = SymTab[p][S_SAMEHASH]
    end while
    if p = 0 then
        return -- already hidden 
    end if
    if prev = 0 then
        buckets[SymTab[s][S_HASHVAL]] = SymTab[s][S_SAMEHASH]
    else
        SymTab[prev][S_SAMEHASH] = SymTab[s][S_SAMEHASH]
    end if
end procedure

procedure LintCheck(symtab_index s)
-- do some lint-like checks on s 
    integer u, n
    sequence vtype, place, problem, filename
    
    u = SymTab[s][S_USAGE]
    filename = name_ext(file_name[current_file_no])
    
    if SymTab[s][S_SCOPE] = SC_LOCAL then
        if SymTab[s][S_MODE] = M_CONSTANT then
            vtype = "local constant"
        else
            vtype = "local variable"
        end if
        place = ""
    
    else  
        n = SymTab[CurrentSub][S_NUM_ARGS]
        if SymTab[s][S_VARNUM] < n then
            vtype = "parameter"
        else
            vtype = "private variable"
        end if
        place = SymTab[CurrentSub][S_NAME]
    
    end if
    
    problem = ""
    if u != or_bits(U_READ, U_WRITTEN) then
        if u = U_UNUSED
        or (u = U_WRITTEN and 
            (equal(vtype, "local constant") 
--           or equal(vtype, "parameter") -- this is rarely a real problem
            )) then
            problem = "not used" 
    
        elsif u = U_READ then
            problem = "never assigned a value"
    
        end if
    
        if length(problem) then
            if length(place) then
                Warning(sprintf("%s %s in %s() in %s is %s", 
                                {vtype, SymTab[s][S_NAME], 
                                 place, filename, problem}))
            else
                Warning(sprintf("%s %s in %s is %s", 
                                {vtype, SymTab[s][S_NAME], 
                                 filename, problem}))
            end if
        end if
    end if
end procedure

global procedure HideLocals()
-- hide the local symbols and "lint" check them
symtab_index s

    s = file_start_sym
    while s do 
        if SymTab[s][S_SCOPE] = SC_LOCAL
        and SymTab[s][S_FILE_NO] = current_file_no then
            Hide(s)
            if SymTab[s][S_TOKEN] = VARIABLE then
                LintCheck(s)
            end if
        end if
        s = SymTab[s][S_NEXT]
    end while
end procedure

global procedure ExitScope()
-- delete all the private scope entries for the current routine 
-- and "lint" check them
symtab_index s

    s = SymTab[CurrentSub][S_NEXT]
    while s and SymTab[s][S_SCOPE] = SC_PRIVATE do
        Hide(s) 
        LintCheck(s)
        s = SymTab[s][S_NEXT]
    end while 
end procedure


--include scanner.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Scanner (low-level parser)

include machine.e
include file.e

constant INCLUDE_LIMIT = 30   -- maximum depth of nested includes 
constant MAX_FILE = 256       -- maximum number of source files

-- Single-byte codes used by (legacy) binder/shrouder
-- update when keyword or builtin added 
-- see also euphoria\bin\keywords.e, keylist.h
constant NUM_KEYWORDS = 24 
constant NUM_BUILTINS = 64 
constant KEYWORD_BASE = 128  -- 129..152  must be one-byte values - no overlap
constant BUILTIN_BASE = 170  -- 171..234  N.B. can't use: 253,254,255
                 -- Note: we did not include the latest multitasking
                 -- builtins, since we now have a new method of
                 -- binding/shrouding that does not use single-byte
                 -- codes
-- global variables
global sequence main_path         -- path of main file being executed 
global integer src_file           -- the source file 
global sequence new_include_name  -- name of file to be included at end of line
global symtab_index new_include_space -- new namespace qualifier or NULL

boolean start_include   -- TRUE if we should start a new file at end of line
start_include = FALSE

global integer LastLineNumber  -- last global line number (avoid dups in line tab)
LastLineNumber = -1     

global integer AnyStatementProfile -- statement profile option was ever selected 
global integer AnyTimeProfile      -- time profile option was ever selected 

--PL 20/11 unused:
--global object shebang            -- #! line (if any) for Linux/FreeBSD
--shebang = 0

-- Local variables
sequence char_class  -- character classes, some are negative
sequence id_char     -- char that could be in an identifier
sequence IncludeStk  -- stack of include file info

-- IncludeStk entry 
constant FILE_NO = 1,           -- file number
LINE_NO = 2,            -- local line number
FILE_PTR = 3,           -- open file number 
FILE_START_SYM = 4, -- symbol before start of file
OP_WARNING = 5,     -- save/restore with/without options
OP_TRACE = 6,          
OP_TYPE_CHECK = 7,
OP_PROFILE_TIME = 8,
OP_PROFILE_STATEMENT = 9

-- list of source lines & execution counts 

global procedure InitLex()
-- initialize lexical analyzer 
    gline_number = 0
    line_number = 0
    IncludeStk = {}
    char_class = repeat(ILLEGAL_CHAR, 255)  -- we screen out the 0 character

    char_class['0'..'9'] = DIGIT
    char_class['a'..'z'] = LETTER
    char_class['A'..'Z'] = LETTER
    char_class[KEYWORD_BASE+1..KEYWORD_BASE+NUM_KEYWORDS] = KEYWORD
    char_class[BUILTIN_BASE+1..BUILTIN_BASE+NUM_BUILTINS] = BUILTIN

    char_class[' '] = BLANK
    char_class['\t'] = BLANK
    char_class['+'] = PLUS
    char_class['-'] = MINUS
    char_class['*'] = MULTIPLY
    char_class['/'] = DIVIDE
    char_class['='] = EQUALS
    char_class['<'] = LESS
    char_class['>'] = GREATER
    char_class['\''] = SINGLE_QUOTE
    char_class['"'] = DOUBLE_QUOTE
    char_class['.'] = DOT
    char_class[':'] = COLON
    char_class['\r'] = NEWLINE
    char_class['\n'] = NEWLINE
    char_class['!'] = BANG
    char_class['{'] = LEFT_BRACE
    char_class['}'] = RIGHT_BRACE
    char_class['('] = LEFT_ROUND
    char_class[')'] = RIGHT_ROUND
    char_class['['] = LEFT_SQUARE
    char_class[']'] = RIGHT_SQUARE
    char_class['$'] = DOLLAR
    char_class[','] = COMMA
    char_class['&'] = CONCAT
    char_class['?'] = QUESTION_MARK
    char_class['#'] = NUMBER_SIGN
    
    -- 26 character can't appear in a text file
    char_class[END_OF_FILE_CHAR] = END_OF_FILE 

    -- helps speed up scanner a bit
    id_char = repeat(FALSE, 255)
    for i = 1 to 255 do
        if i = '_' or find(char_class[i], {LETTER, DIGIT}) then
            id_char[i] = TRUE
        end if
    end for
end procedure

global procedure ResetTP()
-- turn off all trace/profile flags 
    OpTrace = FALSE
    OpProfileStatement = FALSE
    OpProfileTime = FALSE
    AnyStatementProfile = FALSE
    AnyTimeProfile = FALSE
end procedure

-- source line buffers
-- Storing lines of source in memory buffers saves space and 
-- helps old machines load huge programs more quickly
-- Anyway, the C-coded back-end wants it in this form.
constant SOURCE_CHUNK = 10000 -- size of one chunk (many lines) of source, in bytes
global sequence all_source  -- pointers to chunks
atom current_source  -- current place to store source lines
integer current_source_next -- next position to store lines into
all_source = {}
current_source_next = SOURCE_CHUNK -- forces the first allocation

function pack_source(object src)
-- store the source line (minus \n) in a big block of memory to
-- save time and space. The offset where the line is stored is returned.
    integer start
    
    if equal(src, 0) then
        return 0
    end if

    if length(src) >= SOURCE_CHUNK then
        src = src[1..80] -- enough for trace or profile display
    end if
    
    if current_source_next + length(src) >= SOURCE_CHUNK then
        -- we ran out of space, allocate another chunk
        current_source = allocate(SOURCE_CHUNK)
        if current_source = 0 then
            CompileErr("out of memory - turn off trace and profile")
        end if
        all_source = append(all_source, current_source)
        -- skip first byte, offset 0 means "no source"
        current_source_next = 1 
    end if
    
    start = current_source_next 
    poke(current_source+current_source_next, src)
    current_source_next += length(src)-1
    poke(current_source+current_source_next, 0) -- overwrite \n
    current_source_next += 1
    return start + SOURCE_CHUNK * (length(all_source)-1)
end function

global function fetch_line(integer start)
-- get the line of source stored at offset start (without \n)
    sequence line
    integer c, chunk
    atom p
    
    if start = 0 then
        return ""
    end if
    line = ""
    chunk = 1+floor(start / SOURCE_CHUNK)
    start = remainder(start, SOURCE_CHUNK)
    p = all_source[chunk] + start
    while TRUE do
        c = peek(p)
        if c = 0 then
            exit
        end if
        line &= c
        p += 1
    end while
    return line
end function

global procedure AppendSourceLine()
-- add source line to the list 
    sequence new, old
    integer options
    object src
    
    src = 0
    options = 0
    
    if TRANSLATE or OpTrace or OpProfileStatement or OpProfileTime then
        -- record the options and maybe keep the source line too
        src = ThisLine

        if ELINUX and TRANSLATE and mybsd then
            src = ""  -- save space, only 8Mb available!
        end if

        if OpTrace then
            options = SOP_TRACE
        end if
        if OpProfileTime then
            options = or_bits(options, SOP_PROFILE_TIME)
        end if
        if OpProfileStatement then
            options = or_bits(options, SOP_PROFILE_STATEMENT)
        end if
        if OpProfileStatement or OpProfileTime then
            src = {0,0,0,0} & src
        end if
    end if
    
    if length(slist) then
--PL run on 2.4:
--      old = slist[$-1]
        old = slist[length(slist)-1]
    
        if equal(src, old[SRC])
        and current_file_no = old[LOCAL_FILE_NO]
--PL run on 2.4:
--      and line_number = old[LINE]+1+slist[$] and  
        and line_number = old[LINE]+1+slist[length(slist)]
        and options = old[OPTIONS] then
            -- Just increment repetition count rather than storing new entry.
            -- This works well as long as we are not saving the source lines.
--PL run on 2.4:
--          slist[$] += 1  
            slist[length(slist)] += 1  
        else
            src = pack_source(src)
            new = {src, line_number, current_file_no, options}
--PL run on 2.4:
--          if slist[$] = 0 then
            if slist[length(slist)] = 0 then
--              slist[$] = new
                slist[length(slist)] = new
            else
                slist = append(slist, new)
            end if
            slist = append(slist, 0)
        end if
    else
        src = pack_source(src)
        slist = {{src, line_number, current_file_no, options}, 0}
    end if
end procedure

global function s_expand(sequence slist)
-- expand slist to full size if required
sequence new_slist
    
    new_slist = {}
    
    for i = 1 to length(slist) do
        if sequence(slist[i]) then
            new_slist = append(new_slist, slist[i])
        else
            for j = 1 to slist[i] do
                slist[i-1][LINE] += 1
                new_slist = append(new_slist, slist[i-1]) 
            end for
        end if
    end for
    return new_slist
end function

global procedure read_line()
-- read next line of source  
    integer n
    
    line_number += 1
    gline_number += 1
    
    ThisLine = gets(src_file)
    if atom(ThisLine) then
        ThisLine = {END_OF_FILE_CHAR}
    end if

    bp = 1
    n = length(ThisLine)
    if ThisLine[n] != '\n' then
        ThisLine = append(ThisLine, '\n') -- add missing \n (might happen at end of file)
    end if
    AppendSourceLine()
end procedure

procedure bad_zero()
-- don't allow 0 character in source file   
    CompileErr("illegal character (ASCII 0)")
end procedure

function getch()   
-- return next input character, 1 to 255
    integer c
    
    c = ThisLine[bp]
    if c = 0 then
        bad_zero()
    end if
    bp += 1
    return c   
end function

procedure ungetch() 
-- put input character back 
    bp -= 1               
end procedure

function path_open()
-- open an include file (new_include_name) according to the include path rules  
    integer absolute, try
    sequence full_path
    object inc_path
    sequence errbuff

    absolute = FALSE
    
    -- skip whitespace not necessary - String Token does it  
    
    -- check for leading backslash  
    absolute = find(new_include_name[1], SLASH_CHARS) or
               (not ELINUX and find(':', new_include_name))
    
    if absolute then
        -- open new_include_name exactly as it is  
        try = open(new_include_name, "r")
        if try = -1 then
            errbuff = sprintf("can't open %s", new_include_name)
            CompileErr(errbuff)
        end if
        return try
    end if
    
    -- relative path name - first try main_path  
    full_path = main_path & new_include_name
    try = open(full_path,  "r")
    
    if try = -1 then
        -- Search directories listed on EUINC environment var  
        inc_path = getenv("EUINC")
        if sequence(inc_path) and length(inc_path) > 0 then  
            inc_path = append(inc_path, PATH_SEPARATOR)
            full_path = ""
            for p = 1 to length(inc_path) do
                if inc_path[p] = PATH_SEPARATOR then
                    -- end of a directory. 
                    -- remove any trailing blanks and SLASH in directory
                    while length(full_path) and 
--PL run on 2.4:
--                  find(full_path[$], " \t" & SLASH_CHARS) do
                    find(full_path[length(full_path)], " \t" & SLASH_CHARS) do
--                      full_path = full_path[1..$-1]
                        full_path = full_path[1..length(full_path)-1]
                    end while
            
                    if length(full_path) then
                        full_path = full_path & SLASH & new_include_name
                        try = open(full_path, "r")
                        if try != -1 then
                            exit
                        end if
                        full_path = ""
                    end if
                else 
                    -- don't store leading blanks in directory
                    if length(full_path) or 
                    (inc_path[p] != ' ' and inc_path[p] != '\t') then
                        full_path &= inc_path[p]
                    end if
                end if
            end for
--PL run on 2.4:
--          inc_path = inc_path[1..$-1]
            inc_path = inc_path[1..length(inc_path)-1]
        end if
    end if
    
    if try = -1 then
        -- Finally, try EUDIR\INCLUDE  
        full_path = eudir & SLASH & "include" & SLASH & new_include_name
        try = open(full_path, "r")
    end if
    
    if try != -1 then
        -- successful  
        new_include_name = full_path
        return try
    end if
    
    if length(main_path) = 0 then
        main_path = "."
    end if  
--PL run on 2.4:
--  if find(main_path[$], SLASH_CHARS) then
    if find(main_path[length(main_path)], SLASH_CHARS) then
--      main_path = main_path[1..$-1]  -- looks better
        main_path = main_path[1..length(main_path)-1]   -- looks better
    end if
    
    if atom(inc_path) then
        errbuff = sprintf("can't find %s in %s\nor in %s%sinclude", 
                          {new_include_name, main_path, eudir, SLASH})
    else 
        errbuff = sprintf("can't find %s in %s\nor in %s\nor in %s%sinclude", 
                          {new_include_name, main_path, inc_path, eudir, SLASH})
    end if
    CompileErr(errbuff)
end function

function same_name(sequence a, sequence b)
-- return TRUE if two file names (or paths) are equal
    if ELINUX then
        return equal(a, b) -- case sensitive
    end if
    -- DOS/Windows
    if length(a) != length(b) then
        return FALSE
    end if
    for i = 1 to length(a) do
        if upper(a[i]) != upper(b[i]) then
            return FALSE
        end if
    end for
    return TRUE
end function

procedure IncludePush()
-- start reading from new source file with given name  
    integer new_file
    sequence new_name
    
    start_include = FALSE

--  new_file = path_open() -- sets new_include_name to full path 
    
    new_name = name_ext(new_include_name)
    for i = length(file_name) to 1 by -1 do
    -- compare file names first to reduce calls to dir() 
--PL 16/12 removed:
--  if same_name(new_name, name_ext(file_name[i])) and
--     equal(dir(new_include_name), dir(file_name[i])) then
        if same_name(new_name, name_ext(file_name[i])) then
            -- can assume we've included this file already
            -- (Thanks to Vincent Howell.)
            -- (currently, in a very rare case, it could be a 
            --  different file in another directory with the 
            --  same name, size and time-stamp down to the second)
            if new_include_space != 0 then
                SymTab[new_include_space][S_OBJ] = i -- but note any namespace
            end if
--      close(new_file)
            return -- ignore it  
        end if
    end for

    new_file = path_open() -- sets new_include_name to full path 
    
    if length(IncludeStk) >= INCLUDE_LIMIT then
        CompileErr("includes are nested too deeply")
    end if
    
    IncludeStk = append(IncludeStk, 
                        {current_file_no,
                         line_number,
                         src_file,
                         file_start_sym,
                         OpWarning,
                         OpTrace,
                         OpTypeCheck,
                         OpProfileTime,
                         OpProfileStatement})
    src_file = new_file
    file_start_sym = last_sym
    if current_file_no >= MAX_FILE then
        CompileErr("program includes too many files")
    end if
    file_name = append(file_name, new_include_name)
    current_file_no = length(file_name)
    if new_include_space != 0 then
        SymTab[new_include_space][S_OBJ] = current_file_no
    end if
    line_number = 0
end procedure


global function IncludePop()
-- stop reading from current source file and restore info for previous file
-- (if any)  
    sequence top
    
    HideLocals()
    
    close(src_file)
    
    if length(IncludeStk) = 0 then 
        return FALSE  -- the end  
    end if
    
--PL run on 2.4:
--  top = IncludeStk[$]
    top = IncludeStk[length(IncludeStk)]

    current_file_no    = top[FILE_NO]
    line_number        = top[LINE_NO]
    src_file           = top[FILE_PTR]
    file_start_sym     = top[FILE_START_SYM]
    OpWarning          = top[OP_WARNING]
    OpTrace            = top[OP_TRACE]
    OpTypeCheck        = top[OP_TYPE_CHECK]
    OpProfileTime      = top[OP_PROFILE_TIME]
    OpProfileStatement = top[OP_PROFILE_STATEMENT]

--PL run on 2.4:
--  IncludeStk = IncludeStk[1..$-1]
    IncludeStk = IncludeStk[1..length(IncludeStk)-1]
    return TRUE
end function


function MakeInt(sequence text)
-- make a non-negative integer out of a string of digits  
    integer num

    if length(text) > 9 then -- ensure no possibility of overflow  
        return -1            -- use f.p. calculations  
    end if
    
    num = text[1] - '0'
    for i = 2 to length(text) do 
        num = num * 10 + (text[i] - '0')
    end for

    return num
end function        


function EscapeChar(integer c)
-- the escape characters  
    if c = 'n' then
        return '\n'
    
    elsif c = '\\' then
        return '\\'
    
    elsif c = 't' then
        return '\t'
    
    elsif c = '"' then
        return '"'
    
    elsif c = '\''then
        return '\''
    
    elsif c = 'r' then
        return '\r'
    
    else 
        CompileErr("unknown escape character")
    
    end if
end function

            
function my_sscanf(sequence yytext)
-- Converts string to floating-point number
-- based on code in get.e
-- returns {} if number is badly formed
    integer e_sign, ndigits, e_mag
    atom mantissa
    integer c, i
    atom dec
    
    if length(yytext) < 2 then
        CompileErr("number not formed correctly")
    end if
    
    mantissa = 0.0
    ndigits = 0
    
    -- decimal integer or floating point
    
    yytext &= 0 -- end marker
    c = yytext[1]
    i = 2
    while c >= '0' and c <= '9' do
        ndigits += 1
        mantissa = mantissa * 10.0 + (c - '0')
        c = yytext[i]
        i += 1
    end while
    
    if c = '.' then
        -- get fraction
        c = yytext[i]
        i += 1
        dec = 10.0
        while c >= '0' and c <= '9' do
            ndigits += 1
            mantissa = mantissa + (c - '0') / dec
            dec = dec * 10.0
            c = yytext[i]
            i += 1
        end while
    end if
    
    if ndigits = 0 then
        return {}  -- no digits
    end if
    
    if c = 'e' or c = 'E' then
        -- get exponent sign
        e_sign = +1
        e_mag = 0
        c = yytext[i]
        i += 1
        if c = '-' then
            e_sign = -1
        elsif c != '+' then
            i -= 1
        end if
        -- get exponent magnitude 
        c = yytext[i]
        i += 1
        if c >= '0' and c <= '9' then
            e_mag = c - '0'
            c = yytext[i]
            i += 1
            while c >= '0' and c <= '9' do
                e_mag = e_mag*10 + (c-'0')
                c = yytext[i]                          
                i += 1
                if e_mag > 1000 then -- avoid int overflow. can only have 
                    exit             -- 200-digit mantissa to reduce mag
                end if
            end while
        else 
            return {} -- no exponent
        end if
        e_mag = e_sign * e_mag
        if e_mag > 308 then
            mantissa = mantissa * power(10.0, 308.0)
            e_mag = e_mag - 308
            while e_mag > 0 do
                mantissa = mantissa * 10.0 -- Could crash? No we'll get INF.
                e_mag -= 1
            end while
        else   
            mantissa = mantissa * power(10.0, e_mag)
        end if
    end if
    return mantissa
end function

global function Scanner()
-- The scanner main routine: returns a lexical token  
    integer ch, i, sp
    sequence yytext  -- temporary buffer for a token  
--PL 16/12
--  atom d
    object d
    token tok
    integer is_int, class
    sequence name

    while TRUE do
        ch = ThisLine[bp]  -- getch inlined (in all the "hot" spots)
        bp += 1
        while ch = ' ' or ch = '\t' do
            ch = ThisLine[bp]  -- getch inlined
            bp += 1
        end while
        if ch = 0 then
            bad_zero()
        end if
        
        class = char_class[ch]
        
        -- if/elsif cases have been sorted so most common ones come first
        if class = LETTER then 
            sp = bp
            ch = ThisLine[bp]  -- getch
            bp += 1 
            if ch = 0 then
                bad_zero()
            end if
            while id_char[ch] do
                ch = ThisLine[bp] -- getch
                bp += 1
                if ch = 0 then
                    bad_zero()
                end if
            end while
            yytext = ThisLine[sp-1..bp-2]
            bp -= 1  -- ungetch
            tok = keyfind(yytext, -1)
            if tok[T_ID] = NAMESPACE then
            -- skip whitespace
                ch = getch()
                while ch = ' ' or ch = '\t' do
                    ch = getch()
                end while
            
                if ch = ':' then
                    -- skip whitespace
                    ch = getch()
                    while ch = ' ' or ch = '\t' do
                        ch = getch()
                    end while
                    yytext = ""
                    while id_char[ch] do
                        yytext &= ch
                        ch = getch()
                    end while 
                    ungetch()
            
                    if length(yytext) = 0 then
                        CompileErr("an identifier is expected here")
                    end if  
            
            -- must look in chosen file.
            -- can't create a new variable in s.t.
            
                    tok = keyfind(yytext, SymTab[tok[T_SYM]][S_OBJ]) 

                    if tok[T_ID] = VARIABLE then
                        tok[T_ID] = QUALIFIED_VARIABLE
                    elsif tok[T_ID] = FUNC then
                        tok[T_ID] = QUALIFIED_FUNC
                    elsif tok[T_ID] = PROC then
                        tok[T_ID] = QUALIFIED_PROC
                    elsif tok[T_ID] = TYPE then
                        tok[T_ID] = QUALIFIED_TYPE
                    end if
                else
                    ungetch()
                end if
            end if
            return tok
        
        elsif class <= ILLEGAL_CHAR then
            return {class, 0}  -- brackets, punctuation, eof, illegal char etc.

        elsif class = NEWLINE then
            if start_include then
                IncludePush()
            end if
            read_line()
        
        elsif class = EQUALS then
            return {class, 0}  

        elsif class = DOT or class = DIGIT then
            if class = DOT then
                if getch() = '.' then
                    return {SLICE, 0}
                else
                    ungetch()
                end if
            end if
        
            is_int = TRUE
            yytext = {ch}
            if ch = '.' then
                is_int = FALSE
            end if
            ch = ThisLine[bp] -- getch
            if ch = 0 then
                bad_zero()
            end if
            bp += 1
            while char_class[ch] = DIGIT do 
                yytext &= ch
                ch = ThisLine[bp] -- getch
                if ch = 0 then
                    bad_zero()
                end if
                bp += 1
            end while
            if ch = '.' then
                ch = getch()
                if ch = '.' then
                    -- put back slice  
                    ungetch()
                else 
                    is_int = FALSE
                    if yytext[1] = '.' then
                        CompileErr("only one decimal point allowed")
                    else
                        yytext &= '.'
                    end if
                    if char_class[ch] = DIGIT then
                        yytext &= ch
                        ch = getch()
                        while char_class[ch] = DIGIT do
                            yytext &= ch
                            ch = getch()
                        end while
                    else 
                        CompileErr("fractional part of number is missing")
                    end if
                end if
            end if
        
            if ch = 'e' or ch = 'E' then
                is_int = FALSE
                yytext &= ch
                ch = getch()
                if ch = '-' or ch = '+' or char_class[ch] = DIGIT then
                    yytext &= ch
                else  
                    CompileErr("exponent not formed correctly")
                end if
                ch = getch()
                while char_class[ch] = DIGIT do
                    yytext &= ch
                    ch = getch()
                end while
            end if
        
            bp -= 1  --ungetch
        
            i = MakeInt(yytext)
            if is_int and i != -1 then
                return {ATOM, NewIntSym(i)}
            else 
            -- f.p. or large int  
                d = my_sscanf(yytext)
                if sequence(d) then
                    CompileErr("number not formed correctly")
                elsif is_int and d <= MAXINT_DBL then
                    return {ATOM, NewIntSym(d)}  -- 1 to 1.07 billion
                else 
                    return {ATOM, NewDoubleSym(d)}
                end if
            end if
    
        elsif class = MINUS then
            ch = ThisLine[bp] -- getch
            bp += 1
            if ch = '-' then 
            -- comment
                if start_include then
                    IncludePush()
                end if
                read_line()
            elsif ch = '=' then
                return {MINUS_EQUALS, 0}
            else 
                bp -= 1
                return {MINUS, 0}
            end if
        
        elsif class = DOUBLE_QUOTE then
            ch = ThisLine[bp]  -- getch
            bp += 1
            yytext = ""
            while ch != '\n' and ch != '\r' do -- can't be EOF
                if ch = '"' then 
                    exit
                elsif ch = '\\' then
                    yytext &= EscapeChar(getch())
                elsif ch = '\t' then
                    CompileErr("tab character found in string - use \\t instead")
                elsif ch = 0 then
                    bad_zero()
                else
                    yytext &= ch
                end if
                ch = ThisLine[bp]  -- getch
                bp += 1
            end while
            if ch = '\n' or ch = '\r' then
                CompileErr("end of line reached with no closing \"")
            end if
            return {STRING, NewStringSym(yytext)}

        elsif class = PLUS then
            ch = getch()
            if ch = '=' then
                return {PLUS_EQUALS, 0}
            else 
                ungetch()
                return {PLUS, 0}
            end if
        
        elsif class = CONCAT then
            ch = getch()
            if ch = '=' then
                return {CONCAT_EQUALS, 0}
            else 
                ungetch()
                return {CONCAT, 0}
            end if
    
        elsif class = NUMBER_SIGN then
            i = 0
            is_int = -1
            while i < MAXINT_VAL/32 do             
                ch = getch()
                if char_class[ch] = DIGIT then
                    i = i*16 + (ch-'0')
                    is_int = TRUE
                elsif ch >= 'A' and ch <= 'F' then   
                    i = i*16 + (ch-('A'-10))
                    is_int = TRUE
                else
                    exit 
                end if
            end while
        
            if is_int = -1 then
                if ch = '!' then
                    if line_number > 1 then
                        CompileErr(
            "#! may only be on the first line of a program")
                    end if
                    -- treat as a comment (Linux command interpreter line)
--PL 20/11 unused:
--          shebang = ThisLine
                    if start_include then
                        IncludePush()
                    end if
                    read_line()
                else
                    CompileErr("hex number not formed correctly")
                end if
        
            else
                if i >= MAXINT_VAL/32 then
                    d = i
                    is_int = FALSE
                    while TRUE do
                        ch = getch()  -- eventually END_OF_FILE_CHAR or new-line 
                        if char_class[ch] = DIGIT then
                            d = d*16 + (ch-'0')
                        elsif ch >= 'A' and ch <= 'F' then   
                            d = d*16 + (ch-('A'-10))
                        else
                            exit 
                        end if
                    end while
                end if
        
                ungetch()
                if is_int then
                    return {ATOM, NewIntSym(i)}
                else 
                    if d <= MAXINT_DBL then            -- d is always >= 0
                        return {ATOM, NewIntSym(d)} 
                    else
                        return {ATOM, NewDoubleSym(d)}
                    end if
                end if
            end if
        
        elsif class = MULTIPLY then
            ch = getch()
            if ch = '=' then
                return {MULTIPLY_EQUALS, 0}
            else 
                ungetch()
                return {MULTIPLY, 0}
            end if
        
        elsif class = DIVIDE then
            ch = getch()
            if ch = '=' then
                return {DIVIDE_EQUALS, 0}
            else 
                ungetch()
                return {DIVIDE, 0}
            end if
        
        elsif class = SINGLE_QUOTE then
            ch = getch()
            if ch = '\\' then 
                ch = EscapeChar(getch())
            elsif ch = '\t' then
                CompileErr("tab character found in string - use \\t instead")
            elsif ch = '\'' then
                CompileErr("single-quote character is empty")
            end if
            if getch() != '\'' then
                CompileErr("character constant is missing a closing '")
            end if
            return {ATOM, NewIntSym(ch)}

        elsif class = LESS then
            if getch() = '=' then
                return {LESSEQ, 0}
            else 
                ungetch()
                return {LESS, 0}
            end if

        elsif class = GREATER then
            if getch() = '=' then
                return {GREATEREQ, 0}
            else 
                ungetch()
                return {GREATER, 0}
            end if

        elsif class = BANG then
            if getch() = '=' then 
                return {NOTEQ, 0}
            else 
                ungetch()
                return {BANG, 0}
            end if       

        elsif class = KEYWORD then
            return {keylist[ch - KEYWORD_BASE][K_TOKEN], 0}

        elsif class = BUILTIN then
            name = keylist[ch - BUILTIN_BASE + NUM_KEYWORDS][K_NAME]
            return keyfind(name, -1)
        
        else
            InternalErr("Scanner()")  
    
        end if
    end while
end function

function NameSpace_declaration(symtab_index sym)
-- add a new namespace symbol to the symbol table.
-- Similar to adding a local constant. 
    integer h
    
    DefinedYet(sym)
    if find(SymTab[sym][S_SCOPE], {SC_GLOBAL, SC_PREDEF}) then
        -- override the global or predefined symbol 
        h = SymTab[sym][S_HASHVAL]
        -- create a new entry at beginning of this hash chain 
        sym = NewEntry(SymTab[sym][S_NAME], 0, 0, VARIABLE, h, buckets[h], 0) 
        buckets[h] = sym
    end if
    SymTab[sym][S_SCOPE] = SC_LOCAL
    SymTab[sym][S_MODE] = M_CONSTANT
    SymTab[sym][S_TOKEN] = NAMESPACE -- [S_OBJ] will get the file number referred-to
    if TRANSLATE then
        num_routines += 1 -- order of ns declaration relative to routines 
              -- is important
    end if
    return sym
end function

global function StringToken()
-- scans until blank, tab, end of line, or end of file. 
-- returns a raw string - leading whitespace ignored, 
-- comment chopped off.
-- no escape characters are processed 
    integer ch, m
    sequence gtext
    
    -- skip leading whitespace  
    ch = getch()
    while ch = ' ' or ch = '\t' do
        ch = getch()
    end while

    gtext = ""
    while not find(ch,  {' ', '\t', '\n', '\r', END_OF_FILE_CHAR}) do 
        gtext &= ch
        ch = getch()
    end while
    ungetch()
    m = match("--", gtext)
    if m then
        gtext = gtext[1..m-1]
        if ch = ' ' or ch = '\t' then
            read_line()
        end if
    end if
    return gtext
end function

global procedure IncludeScan()
-- Special scan for an include statement:
-- include filename as namespace
   
-- We need a special scan because include statements:
--    - have special rules regarding filename syntax
--    - must fit on one line by themselves (to avoid tricky issues)
--    - we don't want to introduce "as" as a new scanning keyword
 
    integer ch
    sequence gtext
    token s
    
    -- we have just seen the "include" keyword  
    
    -- skip leading whitespace  
    ch = getch()
    while ch = ' ' or ch = '\t' do
        ch = getch()
    end while

    -- scan required filename into gtext  
    gtext = ""
    
    if ch = '"' then
        -- quoted filename  
        ch = getch()
        while not find(ch, {'\n', '\r', '"', END_OF_FILE_CHAR}) do         
            if ch = '\\' then
                ch = EscapeChar(getch())
            end if
            gtext &= ch
            ch = getch()
        end while
        if ch != '"' then
            CompileErr("missing closing quote on file name")
        end if
    else 
        -- unquoted filename  
        while not find(ch, {' ', '\t', '\n', '\r', END_OF_FILE_CHAR}) do  
            gtext &= ch
            ch = getch()
        end while
        ungetch()
    end if
    
    if length(gtext) = 0 then
        CompileErr("file name is missing")
    end if
    
    -- record the new filename  
    new_include_name = gtext  
    
    -- skip whitespace  
    ch = getch()
    while ch = ' ' or ch = '\t' do
        ch = getch()
    end while   
    
    new_include_space = 0
    
    if ch = 'a' then
        -- scan optional "as" clause  
        ch = getch()
        if ch = 's' then
            ch = getch()
            if ch = ' ' or ch = '\t' then
        
                -- skip whitespace  
                ch = getch()
                while ch = ' ' or ch = '\t' do
                    ch = getch()
                end while
        
                -- scan namespace identifier  
                if char_class[ch] = LETTER then
                    gtext = {ch}
                    ch = getch()
                    while char_class[ch] = LETTER or
                    char_class[ch] = DIGIT or
                    ch = '_' do
                        gtext &= ch
                        ch = getch()
                    end while
            
                    ungetch()
                    s = keyfind(gtext, -1)
                    if not find(s[T_ID], {VARIABLE, FUNC, TYPE, PROC}) then
                        CompileErr("a new namespace identifier is expected here")
                    end if
                    new_include_space = NameSpace_declaration(s[T_SYM])
                else 
                    CompileErr("missing namespace qualifier")
                end if
            else 
                CompileErr("improper syntax for include-as")
            end if
        else 
            CompileErr("improper syntax for include-as")
        end if
    else 
        ungetch()
    end if
    
    start_include = TRUE -- let scanner know
end procedure

--include emit.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Routines to emit the IL opcode stream

global integer op_info1, op_info2
global integer optimized_while

global integer trace_called 
trace_called = FALSE

global integer last_routine_id
last_routine_id = 0

global integer max_params   -- maximum number of parameters in user routines 
max_params = 0

global integer last_max_params
last_max_params = 0

global integer previous_op  -- the previous opcode emitted
previous_op = -1  

global sequence current_sequence  -- stack needed by $ operation
current_sequence = {}

global boolean lhs_ptr   -- are we parsing multiple LHS subscripts?
lhs_ptr = FALSE

-- temps needed for LHS subscripting
global symtab_index lhs_subs1_copy_temp,
                    lhs_target_temp      

-- Code generation Stack 
sequence cg_stack -- expression stack 

boolean assignable   -- did previous op have a re-assignable result?
assignable = FALSE         

constant LEX_NUMBER = 1
constant LEX_NAME = 2

-- descriptive names for scanner tokens - keep up-to-date 
constant token_name = 
{ 
 {AND, "'and'"},
 {ATOM, "a number"},
 {BANG, "'!'"},
 {BY, "'by'"},
 {COLON, "':'"},
 {COMMA, "','"},
 {CONCAT, "'&'"},
 {CONSTANT, "'constant'"},
 {DIVIDE, "'/'"},
 {DO, "'do'"},
 {ELSE, "'else'"},
 {ELSIF, "'elsif'"},
 {END, "'end'"},
 {END_OF_FILE, "the end of file"},
 {EQUAL, "'='"},
 {EXIT, "'exit'"},
 {FOR, "'for'"},
 {FUNC, "a function"},
 {FUNCTION, "'function'"},
 {GLOBAL, "'global'"},
 {GREATER, "'>'"},
 {GREATEREQ, "'>='"},
 {IF,  "'if'"},
 {ILLEGAL_CHAR, "an illegal character"},
 {INCLUDE, "'include'"},
 {LEFT_BRACE, "'{'"},
 {LEFT_ROUND, "'('"},
 {LEFT_SQUARE, "'['"},
 {LESS, "'<'"},
 {LESSEQ, "'<='"},
 {MINUS, "'-'"},
 {MULTIPLY, "'*'"},
 {NAMESPACE, "a namespace qualifier"},
 {NEWLINE, "end-of-line"},
 {NOT, "'not'"},
 {NOTEQ, "'!='"},
 {OR, "'or'"},
 {PLUS, "'+'"},
 {PROC, "a procedure"},
 {PROCEDURE, "'procedure'"},
 {QUALIFIED_VARIABLE, "a variable"},
 {QUALIFIED_FUNC, "a function"},
 {QUALIFIED_PROC, "a procedure"},
 {QUALIFIED_TYPE, "a type"},
 {RIGHT_BRACE, "'}'"},
 {RIGHT_ROUND, "')'"},
 {RIGHT_SQUARE, "']'"},
 {RETURN, "'return'"},
 {SLICE, "a slice"},
 {STRING, "a character string"},
 {TO, "'to'"},
 {THEN, "'then'"},
 {TYPE, "a type"},
 {TYPE_DECL, "'type'"},
 {VARIABLE, "a variable"},
 {WITH, "'with'"},
 {WITHOUT, "'without'"},
 {WHILE, "'while'"},
 {'?', "'?'"}
} 


procedure Push(symtab_index x) 
-- Push element onto code gen stack 
    cg_stack = append(cg_stack, x)
end procedure

function Top() 
-- return top element on code gen stack 
--PL run on 2.4:
--  return cg_stack[$]
    return cg_stack[length(cg_stack)]
end function

function Pop()
-- Pop top element from code gen stack 
symtab_index t
integer lcgs

--PL run on 2.4:
--  t = cg_stack[$]
    lcgs=length(cg_stack)
    t = cg_stack[lcgs]
--  cg_stack = cg_stack[1..$-1]
    cg_stack = cg_stack[1..lcgs-1]
    if SymTab[t][S_MODE] = M_TEMP then
        SymTab[t][S_SCOPE] = FREE -- mark it as being free
                        -- n.b. we assume one copy of temp on stack 
                        -- temps are normally not Popped & Pushed back on stack
                        -- but see TempKeep() and TempFree() above 
    end if
    return t    
end function

procedure TempKeep(symtab_index x)
    if SymTab[x][S_MODE] = M_TEMP then
        SymTab[x][S_SCOPE] = IN_USE
    end if
end procedure

global procedure TempFree(symtab_index x)  
    if SymTab[x][S_MODE] = M_TEMP then
        SymTab[x][S_SCOPE] = FREE 
    end if
end procedure

procedure TempInteger(symtab_index x)  
    if SymTab[x][S_MODE] = M_TEMP then
        SymTab[x][S_USAGE] = T_INTEGER
    end if
end procedure


global function LexName(integer t)
-- returns token name given token number 
    integer i
    
    i = 1
    while i <= length(token_name) and t != token_name[i][LEX_NUMBER] do
        i += 1
    end while
    if i > length(token_name) then
        return "this ..." -- try to avoid this case 
    else
        return token_name[i][LEX_NAME]
    end if
end function

global procedure InitEmit()
-- initialize code emission 
    cg_stack = {}
end procedure

function IsInteger(symtab_index sym)
-- return TRUE if sym is known to be of integer type 
    integer mode
    symtab_index t, pt
    
    mode = SymTab[sym][S_MODE]
    if mode = M_NORMAL then
        t = SymTab[sym][S_VTYPE] 
        if t = integer_type then
            return TRUE
        end if
        if t then
            pt = SymTab[t][S_NEXT]
            if pt and SymTab[pt][S_VTYPE] = integer_type then
                return TRUE   -- usertype(integer x)
            end if
        end if
    
    elsif mode = M_CONSTANT then
        if integer(SymTab[sym][S_OBJ]) then  -- bug fixed: can't allow PLUS1_I op 
            return TRUE
        end if
    
    elsif mode = M_TEMP then
        if SymTab[sym][S_USAGE] = T_INTEGER then
            return TRUE
        end if
    end if
    
    return FALSE
end function

-- n.b. I don't enforce ATOM type unless type_check is on,
-- so it won't be proper to assume that a value is going
-- to be ATOM at run-time, based on type declarations or temp info. 
-- Therefore "IsAtom()" would be questionable except maybe for constants. 

procedure emit(integer val)
-- emit a value into the code stream 
    Code = append(Code, val)
end procedure

-- When looking at previous_op, make sure that there 
-- can be no jump around the previous op to the current op.
-- i.e. it is not always *really* the previous op executed 
-- - BE CAREFUL! Often there must be some expression (opnd)
-- prior to the current op.

global procedure emit_opnd(symtab_index opnd)
-- emit an operand into the IL  
    Push(opnd)
    previous_op = -1  -- N.B.
end procedure

global procedure emit_addr(atom x)
-- emit a long integer or an operand address into the IL
    Code = append(Code, x)
end procedure

procedure emit_opcode(integer op)
-- emit an opcode into the IL
    Code = append(Code, op)
end procedure

global procedure backpatch(integer index, integer val)
-- back patch a word of code 
    Code[index] = val
end procedure

sequence op_result  -- result types of operators
op_result = repeat(T_UNKNOWN, MAX_OPCODE)
-- the operation must *always* return this type, regardless of input
op_result[RIGHT_BRACE_N] = T_SEQUENCE
op_result[RIGHT_BRACE_2] = T_SEQUENCE
op_result[REPEAT] = T_SEQUENCE
op_result[APPEND] = T_SEQUENCE
op_result[RHS_SLICE] = T_SEQUENCE
op_result[CONCAT] = T_SEQUENCE
op_result[CONCAT_N] = T_SEQUENCE
op_result[PREPEND] = T_SEQUENCE
op_result[COMMAND_LINE] = T_SEQUENCE
op_result[SPRINTF] = T_SEQUENCE
op_result[ROUTINE_ID] = T_INTEGER
op_result[GETC] = T_INTEGER
op_result[OPEN] = T_INTEGER
op_result[LENGTH] = T_INTEGER   -- assume less than a billion
op_result[PLENGTH] = T_INTEGER  -- ""
op_result[IS_AN_OBJECT] = T_INTEGER
op_result[IS_AN_ATOM] = T_INTEGER
op_result[IS_A_SEQUENCE] = T_INTEGER
op_result[COMPARE] = T_INTEGER
op_result[EQUAL] = T_INTEGER
op_result[FIND] = T_INTEGER
op_result[MATCH]  = T_INTEGER
op_result[GET_KEY] = T_INTEGER
op_result[IS_AN_INTEGER] = T_INTEGER
op_result[ASSIGN_I] = T_INTEGER
op_result[RHS_SUBS_I] = T_INTEGER
op_result[PLUS_I] = T_INTEGER
op_result[MINUS_I] = T_INTEGER
op_result[PLUS1_I] = T_INTEGER
op_result[SYSTEM_EXEC] = T_INTEGER
op_result[TIME] = T_ATOM
op_result[TASK_STATUS] = T_INTEGER
op_result[TASK_SELF] = T_ATOM
op_result[TASK_CREATE] = T_ATOM
op_result[TASK_LIST] = T_SEQUENCE
op_result[PLATFORM] = T_INTEGER

procedure cont11ii(integer op, boolean ii)
-- if ii is TRUE then integer arg always produces integer result
    integer t, source, c
    
    emit_opcode(op)
    source = Pop()
    emit_addr(source)
    assignable = TRUE
    t = op_result[op]

     -- for PEEK should really check for IsAtom(source)
    if t = T_INTEGER or (ii and IsInteger(source)) then
        c = NewTempSym()
        TempInteger(c)
    else 
        c = NewTempSym() -- allocate *after* checking opnd type
    end if
    Push(c)
    emit_addr(c)
end procedure

procedure cont21d(integer op, integer a, integer b, boolean ii)    
    integer c, t
    
    assignable = TRUE
    t = op_result[op]
    if op = C_FUNC then
        emit_addr(CurrentSub)
    end if
    if t = T_INTEGER or (ii and IsInteger(a) and IsInteger(b)) then
        c = NewTempSym()
        TempInteger(c)
    else 
        c = NewTempSym() -- allocate *after* checking opnd types
    end if   
    Push(c)
    emit_addr(c)
end procedure
        
procedure cont21ii(integer op, boolean ii)
    integer a, b
    
    b = Pop()
    emit_opcode(op)
    a = Pop()
    emit_addr(a)
    emit_addr(b)
    cont21d(op, a, b, ii)
end procedure

function good_string(sequence elements)
-- are all elements suitable for a string?
    object obj
    symtab_index e
    sequence element_vals
    
    if TRANSLATE and length(elements) > 10000 then
        return -1 -- A huge string might upset the C compiler.
    end if
    element_vals = {}
    for i = 1 to length(elements) do
        e = elements[i]
        obj = SymTab[e][S_OBJ]
        if SymTab[e][S_MODE] = M_CONSTANT and
           integer(obj) and 
           (not TRANSLATE or 
            (obj >= 1 and obj <= 255)) then
            -- Non C chars are currently inconvenient in TRANSLATOR.
            element_vals = prepend(element_vals, obj)
        else
            return -1
        end if
    end for
    return element_vals
end function

global procedure emit_op(integer op)
-- Emit a postfix operator.
-- The cases have been sorted according to profile frequency.
-- About 60% of the time it's one of the first 6 cases.
-- You might get greater speed by converting the chain of elsif's 
-- to a single call_proc(), as in execute.e.
    symtab_index a, b, c, d, source, target, subsym
    symtab_index lhs_var
    integer ib, ic, n
    object obj
    sequence elements
    object element_vals
    
    -- 1 input, 0 outputs, can combine with previous op 
    if op = ASSIGN then
        source = Pop()
        target = Pop()
        if assignable then
            -- replace previous op (temp) target with ASSIGN target 
--PL run on 2.4:
--          Code = Code[1..$-1] -- drop previous target
            Code = Code[1..length(Code)-1] -- drop previous target
            op = previous_op -- keep same previous op 
            if IsInteger(target) then
                if previous_op = RHS_SUBS then
                    op = RHS_SUBS_I
                    backpatch(length(Code) - 2, op)

                elsif previous_op = PLUS1 then
                    op = PLUS1_I
                    backpatch(length(Code) - 2, op)
                
                elsif previous_op = PLUS or previous_op = MINUS then
--PL run on 2.4:
--                  if IsInteger(Code[$]) and
--                     IsInteger(Code[$-1]) then
                    if IsInteger(Code[length(Code)]) and
                       IsInteger(Code[length(Code)-1]) then
                        if previous_op = PLUS then
                            op = PLUS_I
                        else
                            op = MINUS_I
                        end if
                        backpatch(length(Code) - 2, op)
                    end if  
                
                else 
                    -- if target to-be-overwritten was integer then avoid
                    -- INTEGER_CHECK and ATOM_CHECK 
                    if IsInteger(source) then
                        op = ASSIGN_I -- fake to avoid subsequent check
                    end if
                end if
            end if
        
        else 
            if IsInteger(source) and IsInteger(target) then
                op = ASSIGN_I
            end if
            if SymTab[source][S_MODE] = M_CONSTANT and 
               SymTab[target][S_MODE] = M_CONSTANT then
                -- record: constant var=literal 
                -- for interpreter
                SymTab[target][S_OBJ] = SymTab[source][S_OBJ]
            end if          
            
            emit_opcode(op)
            emit_addr(source)
        
        end if
        
        assignable = FALSE
        emit_addr(target)

    elsif op = RHS_SUBS then
        b = Pop() -- subscript 
        c = Pop() -- sequence 
        target = NewTempSym() -- target 

        if SymTab[c][S_MODE] = M_NORMAL then
            if SymTab[c][S_VTYPE] != sequence_type and 
            SymTab[SymTab[SymTab[c][S_VTYPE]][S_NEXT]][S_VTYPE] != 
            sequence_type then
                op = RHS_SUBS_CHECK
            end if
        elsif SymTab[c][S_MODE] != M_CONSTANT or 
        not sequence(SymTab[c][S_OBJ]) then
            op = RHS_SUBS_CHECK
        end if
        emit_opcode(op)
        emit_addr(c)
        emit_addr(b)
        assignable = TRUE
        Push(target)
        emit_addr(target)
        current_sequence = append(current_sequence, target)
        
    elsif op = PROC then  -- procedure, function and type calls
        assignable = FALSE -- assume for now 
        subsym = op_info1
        n = SymTab[subsym][S_NUM_ARGS]
            
        if subsym = CurrentSub then
            -- calling ourself - parameter values may 
            -- get overwritten before we can use them 
            for i = length(cg_stack)-n+1 to length(cg_stack) do
                if SymTab[cg_stack[i]][S_SCOPE] = SC_PRIVATE and 
                   SymTab[cg_stack[i]][S_VARNUM] < i then
                    -- copy parameter to a temp 
                    emit_opcode(ASSIGN)
                    emit_addr(cg_stack[i])
                    cg_stack[i] = NewTempSym()
                    emit_addr(cg_stack[i])
                end if
            end for
        end if
        emit_opcode(op)
        emit_addr(subsym)
        for i = length(cg_stack)-n+1 to length(cg_stack) do 
            emit_addr(cg_stack[i])
            TempFree(cg_stack[i])
        end for
        
--PL run on 2.4:
--      cg_stack = cg_stack[1..$-n]
        cg_stack = cg_stack[1..length(cg_stack)-n]
        
        if SymTab[subsym][S_TOKEN] != PROC then
            assignable = TRUE
            c = NewTempSym() -- put final result in temp 
            Push(c)
            -- emit location to assign result to 
            emit_addr(c)
        end if

    -- 0 inputs, 0 outputs - note: parser may emit an extra word 
    elsif find(op, {NOP1, NOP2, NOPWHILE, PRIVATE_INIT_CHECK, GLOBAL_INIT_CHECK,
                    STARTLINE, CLEAR_SCREEN, EXIT, ENDWHILE, ELSE, 
                    ERASE_PRIVATE_NAMES, BADRETURNF, ERASE_SYMBOL, UPDATE_GLOBALS, 
                    DISPLAY_VAR, CALL_BACK_RETURN, END_PARAM_CHECK, 
                    TASK_YIELD, TASK_CLOCK_START, TASK_CLOCK_STOP}) then
        emit_opcode(op)
        assignable = FALSE
    
    -- 1 input, 0 outputs - special 
    elsif op = IF or op = WHILE then
        a = Pop()
        assignable = FALSE
        -- AND and OR will have been short-circuited:
        if previous_op >= LESS and previous_op <= NOT then
--PL run on 2.4:
--          Code = Code[1..$-1]
            Code = Code[1..length(Code)-1]
            if previous_op = NOT then
                op = NOT_IFW
                backpatch(length(Code) - 1, op)
            
            else 
--PL run on 2.4:
--              if IsInteger(Code[$-1]) and
--                 IsInteger(Code[$]) then 
                if IsInteger(Code[length(Code)-1]) and
                   IsInteger(Code[length(Code)]) then 
                    op = previous_op + LESS_IFW_I - LESS
                else
                    op = previous_op + LESS_IFW - LESS
                end if
                backpatch(length(Code) - 2, op)
            end if
        
        elsif op = WHILE and    
                -- need extra code in parser to optimize IF/ELSIF too 
        SymTab[a][S_MODE] = M_CONSTANT and
        integer(SymTab[a][S_OBJ]) and 
        not equal(SymTab[a][S_OBJ], 0) then
            optimized_while = TRUE   -- while TRUE ... emit nothing
        
        else 
            emit_opcode(op)
            emit_addr(a)       
         
        end if

    elsif op = INTEGER_CHECK then
        assignable = FALSE
        if previous_op = ASSIGN then 
--PL run on 2.4:
--          c = Code[$-1]
            c = Code[length(Code)-1]
            if not IsInteger(c) then
                emit_opcode(op)
                emit_addr(op_info1)
            end if
        elsif previous_op = -1 or 
        op_result[previous_op] != T_INTEGER then    -- includes ASSIGN_I
            emit_opcode(op)
            emit_addr(op_info1)
        end if

    elsif op = SEQUENCE_CHECK then
        assignable = FALSE
        if previous_op = ASSIGN then
--PL run on 2.4:
--          c = Code[$-1]
            c = Code[length(Code)-1]
            if SymTab[c][S_MODE] != M_CONSTANT or 
               not sequence(SymTab[c][S_OBJ]) then
                emit_opcode(op)
                emit_addr(op_info1)
            end if
        elsif previous_op = -1 or 
        op_result[previous_op] != T_SEQUENCE then
            emit_opcode(op)
            emit_addr(op_info1)
        end if

    elsif op = ATOM_CHECK then
        assignable = FALSE
        if previous_op = ASSIGN then
--PL run on 2.4:
--          c = Code[$-1]
            c = Code[length(Code)-1]
            if (SymTab[c][S_MODE] != M_CONSTANT or not atom(SymTab[c][S_OBJ])) 
               and not IsInteger(c) then
                emit_opcode(op)
                emit_addr(op_info1)
            end if
        elsif previous_op = -1 or 
        (op_result[previous_op] != T_INTEGER and
         op_result[previous_op] != T_ATOM) then
            emit_opcode(op)
            emit_addr(op_info1)
        end if

    elsif op = RIGHT_BRACE_N then -- form a sequence of n items
        n = op_info1
        -- could optimize if they are all constants with known values
        elements = {}
        for i = 1 to n do
            elements = append(elements, Pop())
        end for
        element_vals = good_string(elements)
        
        if sequence(element_vals) then
            c = NewStringSym(element_vals)  -- make a string literal
            assignable = FALSE
        else 
            if n = 2 then
                emit_opcode(RIGHT_BRACE_2) -- faster op for two items
            else 
                emit_opcode(op)
                emit(n)
            end if
            
            for i = 1 to n do
                emit_addr(elements[i])
            end for
            
            c = NewTempSym()
            emit_addr(c)
            assignable = TRUE
        end if
        Push(c)

    -- 3 inputs, 0 outputs 
    elsif op = ASSIGN_SUBS2 or -- can't change the op
    op = ASSIGN_SUBS or 
    op = PASSIGN_SUBS then  -- can't change the op
        b = Pop() -- rhs value 
        a = Pop() -- subscript
        c = Pop() -- sequence 
        if op = ASSIGN_SUBS then
            -- maybe change the op
            if (previous_op != LHS_SUBS) and 
            (SymTab[c][S_MODE] != M_NORMAL or 
             (SymTab[c][S_VTYPE] != sequence_type and 
              SymTab[SymTab[SymTab[c][S_VTYPE]][S_NEXT]][S_VTYPE] != 
              sequence_type)) then
                op = ASSIGN_SUBS_CHECK
            else 
                if IsInteger(b) then
                    op = ASSIGN_SUBS_I
                end if
            end if
            emit_opcode(op)
        
        elsif op = PASSIGN_SUBS then
            emit_opcode(PASSIGN_SUBS) -- always
            
        else 
            emit_opcode(ASSIGN_SUBS) -- always
        
        end if
        
        emit_addr(c) -- sequence
        emit_addr(a) -- subscript 
        emit_addr(b) -- rhs value
        assignable = FALSE

    elsif op = LHS_SUBS or op = LHS_SUBS1 or op = LHS_SUBS1_COPY then  
        -- left hand side multiple subscripts, one step
        a = Pop() -- subs
        lhs_var = Pop() -- sequence
        emit_opcode(op)
        emit_addr(lhs_var)
        emit_addr(a)
        if op = LHS_SUBS then
            TempKeep(lhs_var) -- should be lhs_target_temp
            emit_addr(lhs_target_temp)
            Push(lhs_target_temp)
            emit_addr(0) -- place holder 
        else    
            -- first LHS subscript 
            -- Note: LHS_SUBS1 might be patched later to LHS_SUBS1_COPY
            lhs_target_temp = NewTempSym() -- use same temp for all subscripts
            emit_addr(lhs_target_temp) -- target temp holds pointer to sequence
            Push(lhs_target_temp)
            lhs_subs1_copy_temp = NewTempSym() -- place to copy (may be ignored)
            emit_addr(lhs_subs1_copy_temp)
        end if
        current_sequence = append(current_sequence, lhs_target_temp)
        assignable = FALSE  -- need to update current_sequence like in RHS_SUBS
        
    -- 1 input, 1 output 
    elsif find(op, {RAND, PEEK, PEEK4S, PEEK4U, NOT_BITS, NOT, 
                    TASK_STATUS}) then
        cont11ii(op, TRUE)
            
    elsif op = UMINUS then
        -- check for constant folding 
        a = Pop()
        obj = SymTab[a][S_OBJ]
        if SymTab[a][S_MODE] = M_CONSTANT then
            if integer(obj) then
                if obj = MININT then
                    Push(NewDoubleSym(-MININT_VAL))
                else
                    Push(NewIntSym(-obj))
                end if
            elsif atom(obj) and obj != NOVALUE then
                -- N.B. a constant won't have its value set until
                -- the end of the  constant var=xxx, var=xxx, ...
                -- statement. Be careful in the future if we
                -- add any more constant folding besides unary minus. 
                Push(NewDoubleSym(-obj)) 
            else
                Push(a)
                cont11ii(op, FALSE)   
            end if 
       
        elsif TRANSLATE and SymTab[a][S_MODE] = M_TEMP and 
        SymTab[a][S_GTYPE] = TYPE_DOUBLE then
            Push(NewDoubleSym(-obj)) 
       
        else
            Push(a)
            cont11ii(op, FALSE)   
        end if
    
    elsif find(op, {IS_AN_INTEGER, IS_AN_ATOM, IS_A_SEQUENCE, IS_AN_OBJECT,
                    LENGTH, GETC, SQRT, SIN, COS, TAN, ARCTAN, LOG, GETS, 
                    GET_PIXEL, GETENV}) then
        cont11ii(op, FALSE)   
        
    -- special 1 input, 1 output - also emits CurrentSub 
    elsif op = ROUTINE_ID then
        emit_opcode(op)
        source = Pop()
        if TRANSLATE then
            emit_addr(num_routines-1)
            last_routine_id = num_routines
            last_max_params = max_params
            MarkTargets(source, S_RI_TARGET)
          
        else           
            emit_addr(CurrentSub)
            emit_addr(length(SymTab))
       
            if BIND then
                -- note reference to this routine
                MarkTargets(source, S_NREFS) 
            end if
       
        end if
        emit_addr(source)
        emit_addr(current_file_no)  -- necessary at top level
        assignable = TRUE
        c = NewTempSym()
        TempInteger(c) -- result will always be an integer
        Push(c)
        emit_addr(c)
            
    -- 1 input, 1 outputs with jump address that might be patched.
    -- Output value is not used by the next op, but same temp must
    -- be used by SC2 ops. 
    elsif op = SC1_OR or op = SC1_AND then
        emit_opcode(op)
        emit_addr(Pop())       
        c = NewTempSym()
        Push(c)
        emit_addr(c)
        assignable = FALSE
        -- jump address to follow 
        
    -- 2 inputs, 0 outputs 
    elsif find(op, {SYSTEM, PUTS, PRINT, QPRINT, POSITION, MACHINE_PROC,
                    C_PROC, PIXEL, POKE, POKE4, TASK_SCHEDULE}) then
        emit_opcode(op)
        b = Pop()
        emit_addr(Pop())
        emit_addr(b)
        if op = C_PROC then
            emit_addr(CurrentSub)
        end if
        assignable = FALSE
                
    -- 2 inputs, 1 output 
    elsif find(op, {EQUALS, LESS, GREATER, NOTEQ, LESSEQ, GREATEREQ,
                    AND, OR, XOR, REMAINDER, AND_BITS, OR_BITS, XOR_BITS}) then
        cont21ii(op, TRUE)  -- both integer args => integer result
        
    elsif op = PLUS then
        -- result could overflow int
        b = Pop()
        a = Pop()
        if SymTab[b][S_MODE] = M_CONSTANT and equal(SymTab[b][S_OBJ], 1) then 
            op = PLUS1
            emit_opcode(op)
            emit_addr(a)
            emit_addr(0)
            cont21d(op, a, b, FALSE)
        elsif SymTab[a][S_MODE] = M_CONSTANT and equal(SymTab[a][S_OBJ], 1) then
            op = PLUS1
            emit_opcode(op)
            emit_addr(b)
            emit_addr(0)
            cont21d(op, a, b, FALSE)
        else 
            Push(a)
            Push(b)
            cont21ii(op, FALSE)
        end if
        
    elsif op = MULTIPLY then
            -- result could overflow int
        b = Pop()
        a = Pop()
        if SymTab[b][S_MODE] = M_CONSTANT and equal(SymTab[b][S_OBJ], 2) then
            -- Note: x * 2.0 is just as fast as x + x when x is f.p. 
            op = PLUS
            emit_opcode(op)
            emit_addr(a)
            emit_addr(a)
            cont21d(op, a, b, FALSE)
            
        elsif SymTab[a][S_MODE] = M_CONSTANT and equal(SymTab[a][S_OBJ], 2) then
            op = PLUS
            emit_opcode(op)
            emit_addr(b)
            emit_addr(b)
            cont21d(op, a, b, FALSE)
            
        else 
            Push(a)
            Push(b)
            cont21ii(op, FALSE)
            
        end if
            
    elsif op = DIVIDE then
        b = Pop()
        if SymTab[b][S_MODE] = M_CONSTANT and equal(SymTab[b][S_OBJ], 2) then
            op = DIV2
            emit_opcode(op)
            emit_addr(Pop()) -- n.b. "a" hasn't been set
            a = 0
            emit_addr(0)
            cont21d(op, a, b, FALSE)  -- could have fractional result
        else 
            Push(b) 
            cont21ii(op, FALSE)
        end if
        
    elsif op = FLOOR then
        if previous_op = DIVIDE then
            op = FLOOR_DIV
            backpatch(length(Code) - 3, op)
            assignable = TRUE
        
        elsif previous_op = DIV2 then
            op = FLOOR_DIV2
            backpatch(length(Code) - 3, op)
            assignable = TRUE
--PL run on 2.4:
--          if IsInteger(Code[$-2]) then
            if IsInteger(Code[length(Code)-2]) then
                TempInteger(Top()) --mark temp as integer type
            end if
        else
            cont11ii(op, TRUE)
        end if
        -- TRUE for FLOOR  
        -- but not FLOOR_DIV (x/-1)

    -- 2 inputs, 1 output   
    elsif find(op, {MINUS, APPEND, PREPEND, COMPARE, EQUAL, FIND, MATCH,
                    SYSTEM_EXEC, CONCAT, REPEAT, MACHINE_FUNC, C_FUNC,
                    OPEN, SPRINTF, TASK_CREATE}) then
        cont21ii(op, FALSE)
        
    elsif op = SC2_NULL then  -- correct the stack - we aren't emitting anything
        c = Pop()
        TempKeep(c)
        b = Pop()  -- remove SC1's temp
        Push(c)
        assignable = FALSE
            
    -- Same temp must be used by SC2 ops and SC1 ops. 
    elsif op = SC2_AND or op = SC2_OR then
        emit_opcode(op)
        emit_addr(Pop())       
        c = Pop()
        TempKeep(c)
        emit_addr(c) -- target
        TempInteger(c)
        Push(c)
        assignable = FALSE
        
    -- 3 inputs, 0 outputs 
    elsif find(op, {MEM_COPY, MEM_SET, PRINTF}) then
        emit_opcode(op)
        c = Pop()
        b = Pop()
        emit_addr(Pop())
        emit_addr(b)
        emit_addr(c)
        assignable = FALSE

    -- 3 inputs, 1 output 
    elsif op = RHS_SLICE then -- rhs slice of a sequence a[i:j] 
        emit_opcode(op)
        c = Pop()
        b = Pop()
        emit_addr(Pop())
        emit_addr(b)
        emit_addr(c)
        c = NewTempSym()
        assignable = TRUE
        Push(c)
        emit_addr(c)

    -- n inputs, 1 output 
    elsif op = CONCAT_N then     -- concatenate 3 or more items
        n = op_info1  -- number of items to concatenate
        emit_opcode(CONCAT_N)
        emit(n)
        for i = 1 to n do 
            emit_addr(Pop())  -- reverse order
        end for
        c = NewTempSym()
        emit_addr(c)
        assignable = TRUE
        Push(c)
            
    elsif op = FOR then
        c = Pop() -- increment 
        TempKeep(c)
        ic = IsInteger(c)
        if SymTab[c][S_MODE] = M_NORMAL and 
        SymTab[c][S_SCOPE] != SC_LOOP_VAR and 
        SymTab[c][S_SCOPE] != SC_GLOOP_VAR then
        -- must make a copy in case var is modified 
            emit_opcode(ASSIGN)
            emit_addr(c)
            c = NewTempSym()
            emit_addr(c)
        end if
        b = Pop() -- limit 
        TempKeep(b)
        ib = IsInteger(b)
        if SymTab[b][S_MODE] = M_NORMAL and 
        SymTab[b][S_SCOPE] != SC_LOOP_VAR and 
        SymTab[b][S_SCOPE] != SC_GLOOP_VAR then
        -- must make a copy in case var is modified 
            emit_opcode(ASSIGN)
            emit_addr(b)
            b = NewTempSym()
            emit_addr(b)
        end if
        a = Pop() -- initial value 
        if IsInteger(a) and ib and ic then
            SymTab[op_info1][S_VTYPE] = integer_type
            op = FOR_I
        else            
            op = FOR
        end if
        emit_opcode(op)
        emit_addr(c)
        emit_addr(b)
        emit_addr(a)
        emit_addr(CurrentSub) -- in case recursion check is needed
        Push(b)
        Push(c)
        assignable = FALSE
        -- loop var, jump addr will follow 

    elsif op = ENDFOR_GENERAL or op = ENDFOR_INT_UP1 then  -- all ENDFORs  
        emit_opcode(op) -- will be patched at runtime 
        a = Pop() 
        emit_addr(op_info2) -- address of top of loop 
        emit_addr(Pop())    -- limit 
        emit_addr(op_info1) -- loop var 
        emit_addr(a)        -- increment - not always used - 
                            -- put it last - maybe different cache line 
        assignable = FALSE

    -- 3 inputs, 1 output 
    elsif op = ASSIGN_OP_SUBS or op = PASSIGN_OP_SUBS then   
        -- for x[i] op= expr 
        b = Pop()      -- rhs value, keep on stack 
        TempKeep(b)
        
        a = Pop()      -- subscript, keep on stack
        TempKeep(a)
        
        c = Pop()      -- lhs sequence, keep on stack
        TempKeep(c)
        
        emit_opcode(op)
        emit_addr(c)  
        emit_addr(a)    
        
        d = NewTempSym()
        emit_addr(d)   -- place to store result
        
        Push(c)
        Push(a)
        Push(d)
        Push(b)
        assignable = FALSE
            
    -- 4 inputs, 0 outputs 
    elsif op = ASSIGN_SLICE or op = PASSIGN_SLICE then
        emit_opcode(op)
        b = Pop() -- rhs value
        a = Pop() -- 2nd subs
        c = Pop() -- 1st subs 
        emit_addr(Pop()) -- sequence
        emit_addr(c)
        emit_addr(a)  
        emit_addr(b)
        assignable = FALSE

    -- 4 inputs, 1 output 
    elsif op = ASSIGN_OP_SLICE or op = PASSIGN_OP_SLICE then  
        -- for x[i..j] op= expr 
        emit_opcode(op)
            
        b = Pop()        -- rhs value not used
        TempKeep(b)
            
        a = Pop()        -- 2nd subs
        TempKeep(a)
            
        c = Pop()        -- 1st subs
        TempKeep(c)
        
        d = Pop()
        TempKeep(d)      -- sequence   
        
        emit_addr(d) 
        Push(d)
        
        emit_addr(c) 
        Push(c)
            
        emit_addr(a) 
        Push(a)
        
        c = NewTempSym()
        Push(c)
        emit_addr(c)     -- place to store result
        
        Push(b)
        assignable = FALSE
            
    -- special cases: 
    elsif op = CALL_PROC then
        emit_opcode(op)
        b = Pop()
        emit_addr(Pop())
        emit_addr(b)
        assignable = FALSE
            
    elsif op = CALL_FUNC then
        emit_opcode(op)
        b = Pop()
        emit_addr(Pop())
        emit_addr(b)
        assignable = TRUE
        c = NewTempSym() 
        Push(c)
        emit_addr(c)
            
    elsif op = RETURNP then
        emit_opcode(op)
        emit_addr(CurrentSub)
        assignable = FALSE

    elsif op = RETURNF then
        emit_opcode(op)
        emit_addr(CurrentSub)
        emit_addr(Pop())
        assignable = FALSE

    elsif op = RETURNT then
        emit_opcode(op)
        assignable = FALSE

    elsif find(op, {DATE, TIME, SPACE_USED, GET_KEY, TASK_LIST, 
                    COMMAND_LINE}) then
        emit_opcode(op)
        c = NewTempSym()
        assignable = TRUE
        if op = GET_KEY then  -- it's in op_result as integer
            TempInteger(c)
        end if
        Push(c)
        emit_addr(c)

    elsif find(op, {CLOSE, ABORT, CALL}) then
        emit_opcode(op)
        emit_addr(Pop())       
        assignable = FALSE
    
    elsif op = POWER then
        -- result could overflow int
        b = Pop()
        a = Pop()
        if SymTab[b][S_MODE] = M_CONSTANT and equal(SymTab[b][S_OBJ], 2) then 
            -- convert power(x,2) to x*x 
            op = MULTIPLY
            emit_opcode(op)
            emit_addr(a)
            emit_addr(a)
            cont21d(op, a, b, FALSE)
        else 
            Push(a)
            Push(b)
            cont21ii(op, FALSE)
        end if

    -- (doesn't need) 1 input, 0 outputs 
    elsif op = TYPE_CHECK then
        emit_opcode(op)
        c = Pop()       
        assignable = FALSE
        
    -- 0 inputs, 1 output, special op
    elsif op = DOLLAR then
        -- length of the current sequence (or pointer to current sequence)
        if lhs_ptr and length(current_sequence) = 1 then
            emit_opcode(PLENGTH)
        else
            emit_opcode(LENGTH) 
        end if
        
--PL run on 2.4:
--      emit_addr(current_sequence[$])
        emit_addr(current_sequence[length(current_sequence)])
        c = NewTempSym()
        TempInteger(c)
        Push(c)
        emit_addr(c)
        assignable = FALSE -- it wouldn't be assigned anyway
    
    -- 0 inputs, 1 output   
    elsif op = TASK_SELF then
        c = NewTempSym()
        TempInteger(c)
        Push(c)
        emit_opcode(op)
        emit_addr(c)
        assignable = TRUE
        
    -- 0 inputs, 1 output 
    elsif op = PLATFORM then
        if BIND and shroud_only then
            -- must check with backend/backendw/backendu for platform
            c = NewTempSym()
            TempInteger(c)
            Push(c)
            emit_opcode(op)
            emit_addr(c)
            assignable = TRUE
        
        else    
            -- front end knows platform
            if ELINUX then
                n = 3
        
            elsif BIND then
                n = 1 + w32  -- set platform value based on bind option, so
                             -- backendw.exe bind.il can serve DOS and Windows
        
            elsif EDOS then        
                n = 1
        
            elsif EWINDOWS then
                n = 2 
        
            end if
        
            Push(NewIntSym(n))
            assignable = FALSE
        end if
        
    -- 1 input, 0 outputs 
    elsif find(op, {PROFILE, TASK_SUSPEND}) then
        a = Pop()
        emit_opcode(op)
        emit_addr(a)       
        assignable = FALSE
        
    elsif op = TRACE then
        a = Pop()
        if OpTrace then
            -- only emit trace op in a "with trace" section
            emit_opcode(op)
            emit_addr(a)       
            if TRANSLATE then
                if not trace_called then
                    Warning("Statements have been inserted to trace execution of your program.")
                end if
                trace_called = TRUE
            end if          
        end if
        assignable = FALSE
        
    else
        InternalErr(sprintf("unknown opcode: %d", op))

    end if
    
    previous_op = op
end procedure

global procedure emit_assign_op(integer op)
-- emit the appropriate assignment operator 
    if op = PLUS_EQUALS then
        emit_op(PLUS)
    elsif op = MINUS_EQUALS then
        emit_op(MINUS)
    elsif op = MULTIPLY_EQUALS then 
        emit_op(MULTIPLY)
    elsif op = DIVIDE_EQUALS then 
        emit_op(DIVIDE)
    elsif op = CONCAT_EQUALS then
        emit_op(CONCAT)
    end if
end procedure

global procedure StartSourceLine(integer sl)
-- record code offset at start of new source statement, 
-- optionally emit start of line op 
-- sl is true if we want a STARTLINE emitted as well 
    integer line_span
    
    if gline_number = LastLineNumber then
        if length(LineTable) then
            return -- ignore duplicates 
        else
            sl = FALSE -- top-level new statement to execute on same line
        end if
    end if
    LastLineNumber = gline_number

    -- add new line table entry 
    line_span = gline_number - SymTab[CurrentSub][S_FIRSTLINE]
    while length(LineTable) < line_span do
        LineTable = append(LineTable, -1) -- filler
    end while
    LineTable = append(LineTable, length(Code))
    
    if sl and (TRANSLATE or (OpTrace or OpProfileStatement)) then
        -- control point for tracing and profiling 
        emit_op(STARTLINE)
        emit_addr(gline_number)
    end if
end procedure


--include parser.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Parser

constant UNDEFINED = -999
constant DEFAULT_SAMPLE_SIZE = 25000  -- for time profile

global integer max_stack_per_call  -- max stack required per (recursive) call 

global integer sample_size         -- profile_time sample size 
sample_size = 0

max_stack_per_call = 1

--*****************
-- Local variables 
--*****************
sequence branch_list
branch_list = {}

integer short_circuit     -- are we doing short-circuit code? 
                          -- > 0 means yes - if/elsif/while but not
                          -- in args, subscripts, slices, {,,}. 
short_circuit = 0
boolean short_circuit_B   -- are we in the skippable part of a short
short_circuit_B = FALSE   -- circuit expression? given short_circuit is TRUE.
                           
integer SC1_patch        -- place to patch jump address for SC1 ops 
integer SC1_type         -- OR or AND 
integer start_index      -- start of current top level command 

object backed_up_tok  -- place to back up a token 
integer FuncReturn    -- TRUE if a function return appeared 
integer param_num     -- number of parameters and private variables
                      -- in current procedure 
sequence elist        -- back-patch list for end if label 
sequence exit_list    -- stack of exits to back-patch 
integer loop_nest     -- current number of nested loops 
integer stmt_nest     -- nesting level of statement lists 
sequence init_stack   -- var init stack 

-- Expression statistics:
integer side_effect_calls -- number of calls to functions with side-effects
side_effect_calls = 0     -- on local/global variables

integer factors           -- number of factors parsed
factors = 0

integer lhs_subs_level    -- number of levels of subscripting of lhs var on RHS
lhs_subs_level = -1

symtab_index left_sym  -- var used on LHS of assignment
left_sym = 0

procedure EndLineTable()
-- put marker at end of current line number table 

    LineTable = append(LineTable, -2)
end procedure

procedure CreateTopLevel()
-- sets symbol table fields for the top level procedure 
    SymTab[TopLevelSub][S_NUM_ARGS] = 0
    SymTab[TopLevelSub][S_TEMPS] = 0
    SymTab[TopLevelSub][S_CODE] = {}
    SymTab[TopLevelSub][S_LINETAB] = {}
    SymTab[TopLevelSub][S_FIRSTLINE] = 1
    SymTab[TopLevelSub][S_REFLIST] = {}
    SymTab[TopLevelSub][S_NREFS] = 1
    SymTab[TopLevelSub][S_RESIDENT_TASK] = 1
    SymTab[TopLevelSub][S_SAVED_PRIVATES] = {}
end procedure

procedure EnterTopLevel()
-- prepare to put code into the top level procedure 
    if CurrentSub then
        EndLineTable()
        SymTab[CurrentSub][S_LINETAB] = LineTable
        SymTab[CurrentSub][S_CODE] = Code
    end if
    LineTable = SymTab[TopLevelSub][S_LINETAB]
    Code = SymTab[TopLevelSub][S_CODE]
    previous_op = -1
    CurrentSub = TopLevelSub
end procedure

procedure LeaveTopLevel()
-- prepare to resume compiling normal subprograms 
    LastLineNumber = -1
    SymTab[TopLevelSub][S_LINETAB] = LineTable
    SymTab[TopLevelSub][S_CODE] = Code
    LineTable = {}
    Code = {}
    previous_op = -1
end procedure

global procedure InitParser()
    elist = {}
    exit_list = {}
    init_stack = {}
    CurrentSub = 0
    CreateTopLevel()
    EnterTopLevel()
    backed_up_tok = UNDEFINED
    loop_nest = 0
    stmt_nest = 0
end procedure

procedure NotReached(integer tok, sequence keyword)
-- Issue warning about code that can't be executed 
    if not find(tok, {END, ELSE, ELSIF, END_OF_FILE}) then
        Warning(sprintf("%s:%d - statement after %s will never be executed", 
                        {name_ext(file_name[current_file_no]), line_number, keyword}))
    end if
end procedure

procedure InitCheck(symtab_index sym, integer ref)
-- emit INIT_CHECK opcode if we aren't sure if a var has been
-- initialized yet. ref is TRUE if this is a read of this var 
    if SymTab[sym][S_MODE] = M_NORMAL and 
       SymTab[sym][S_SCOPE] != SC_LOOP_VAR and 
       SymTab[sym][S_SCOPE] != SC_GLOOP_VAR then
        if (SymTab[sym][S_SCOPE] != SC_PRIVATE and 
           equal(SymTab[sym][S_OBJ], NOVALUE)) or 
           (SymTab[sym][S_SCOPE] = SC_PRIVATE and 
           SymTab[sym][S_VARNUM] >= SymTab[CurrentSub][S_NUM_ARGS]) then
            if SymTab[sym][S_INITLEVEL] = -1 then
                if ref then
                    if SymTab[sym][S_SCOPE] = SC_GLOBAL or 
                       SymTab[sym][S_SCOPE] = SC_LOCAL then
                        emit_op(GLOBAL_INIT_CHECK) -- will become NOP2
                    else
                        emit_op(PRIVATE_INIT_CHECK)
                    end if
                    emit_addr(sym)
                end if
                if short_circuit <= 0 or short_circuit_B = FALSE then
                    init_stack = append(init_stack, sym)
                    SymTab[sym][S_INITLEVEL] = stmt_nest
                end if
            end if
            -- else we know that it must be initialized at this point 
        end if
        -- else ignore parameters, already initialized global/locals 
    end if
    -- else .. ignore loop vars, constants 
end procedure

procedure InitDelete()
-- remove vars whose nesting level is 
-- now too high from the init stack 
    while length(init_stack)
--PL run on 2.4:
--  and SymTab[init_stack[$]][S_INITLEVEL] > stmt_nest do
    and SymTab[init_stack[length(init_stack)]][S_INITLEVEL] > stmt_nest do
--      SymTab[init_stack[$]][S_INITLEVEL] = -1
        SymTab[init_stack[length(init_stack)]][S_INITLEVEL] = -1
--      init_stack = init_stack[1..$-1]
        init_stack = init_stack[1..length(init_stack)-1]
    end while
end procedure

procedure emit_forward_addr() 
-- emit blank forward address and add this branch point to the list 
-- for later straightening 
    emit_addr(0)
    branch_list = append(branch_list, length(Code))
end procedure

procedure StraightenBranches()
-- Straighten branches within the current subprogram (or top-level)
    integer br 
    integer target
    
    if TRANSLATE then
        return -- do it in back-end
    end if
    for i = length(branch_list) to 1 by -1 do
        target = Code[branch_list[i]]
        if target <= length(Code) then
            br = Code[target]
            if br = ELSE or br = ENDWHILE or br = EXIT then
                backpatch(branch_list[i], Code[target+1])
            end if
        end if
    end for
    branch_list = {}
end procedure

procedure AppendEList(integer addr)
-- add address to list requiring back-patch at end of if statement 
    elist = append(elist, addr)
end procedure

procedure AppendXList(integer addr)
-- add exit location to list requiring back-patch at end of loop 
    exit_list = append(exit_list, addr)
end procedure

procedure PatchEList(integer base)
-- back-patch jump offsets for jumps to end of if-statement 
    integer elist_top
    
    elist_top = length(elist)
    while elist_top > base do
        backpatch(elist[elist_top], length(Code)+1)
        elist_top -= 1
    end while
    elist = elist[1..base]
end procedure

procedure PatchXList(integer base)
-- back-patch jump offsets for jumps to end of loop 
    integer exit_top
    
    exit_top = length(exit_list)
    while exit_top > base do
        backpatch(exit_list[exit_top], length(Code)+1)
        exit_top -= 1
    end while
    exit_list = exit_list[1..base] 
end procedure

procedure putback(token t) 
-- push a scanner token back onto the input stream    
    backed_up_tok = t
end procedure

function next_token() 
-- read next scanner token
    token t
    
    if atom(backed_up_tok) then
        t = Scanner() 
    else     
        t = backed_up_tok 
        backed_up_tok = UNDEFINED 
    end if 
    return t
end function

integer forward_expr

function Expr_list()
-- parse a (possibly empty) list of expressions 
    token tok
    integer n

    tok = next_token()
    putback(tok)
    if tok[T_ID] = RIGHT_BRACE then
        return 0
    else 
        n = 0
        short_circuit -= 1
        while TRUE do 
            call_proc(forward_expr, {})
            n += 1
            tok = next_token()
            if tok[T_ID] != COMMA then
                exit
            end if
        end while  
        short_circuit += 1
    end if
    putback(tok)
    return n
end function

procedure tok_match(integer tok)
-- match token or else syntax error 
    token t
    sequence expected, actual

    t = next_token()
    if t[T_ID] != tok then
        expected = LexName(tok)
        actual = LexName(t[T_ID])
        CompileErr(sprintf(
                   "Syntax error - expected to see possibly %s, not %s", 
                   {expected, actual}))
    end if
end procedure

procedure UndefinedVar(symtab_index s)
-- report a possibly undefined or multiply-defined symbol 
    symtab_index dup
    sequence errmsg
    
    if SymTab[s][S_SCOPE] = SC_UNDEFINED then
        CompileErr(sprintf("%s has not been declared", {SymTab[s][S_NAME]}))
    
    elsif SymTab[s][S_SCOPE] = SC_MULTIPLY_DEFINED then
        errmsg = sprintf("A namespace qualifier is needed to resolve %s.\n%s is defined as a global symbol in:\n", 
                         {SymTab[s][S_NAME], SymTab[s][S_NAME]})
        -- extended error message  
        for i = length(dup_globals) to 1 by -1 do
            dup = dup_globals[i]
            errmsg &= "    " & file_name[SymTab[dup][S_FILE_NO]] & "\n"
        end for
        
        CompileErr(errmsg)
    end if
end procedure

procedure WrongNumberArgs(symtab_index subsym, sequence only)
-- issue message for wrong number of arguments
    sequence plural

    if SymTab[subsym][S_NUM_ARGS] = 1 then
        plural = ""
    else
        plural = "s"
    end if
    CompileErr(sprintf("%s takes %s%d argument%s", 
                       {SymTab[subsym][S_NAME], only, 
                        SymTab[subsym][S_NUM_ARGS], plural}))
end procedure

procedure ParseArgs(symtab_index subsym)
-- parse arguments for a function, type or procedure call 
    integer n
    token tok

    n = SymTab[subsym][S_NUM_ARGS]
    short_circuit -= 1
    for i = 1 to n do
        call_proc(forward_expr, {})
        if i != n then 
            tok = next_token()
            if tok[T_ID] != COMMA then
                if tok[T_ID] = RIGHT_ROUND then
                    WrongNumberArgs(subsym, "")
                else 
                    putback(tok)
                    tok_match(COMMA)
                end if
            end if
        end if
    end for
    tok = next_token()
    short_circuit += 1
    if tok[T_ID] != RIGHT_ROUND then
        if tok[T_ID] = COMMA then
            WrongNumberArgs(subsym, "only ")
        else 
            putback(tok)
            tok_match(RIGHT_ROUND)
        end if
    end if
end procedure

procedure Factor()
-- parse a factor in an expression 
    token tok
    integer id, n, scope, opcode, e
    integer save_factors, save_lhs_subs_level
    symtab_index sym
    
    factors += 1
    tok = next_token()
    id = tok[T_ID]
    if id = VARIABLE or id = QUALIFIED_VARIABLE then
        sym = tok[T_SYM]
        UndefinedVar(sym)
            
        SymTab[sym][S_USAGE] = or_bits(SymTab[sym][S_USAGE], U_READ)

        InitCheck(sym, TRUE)
        emit_opnd(sym)

        if sym = left_sym then
            lhs_subs_level = 0 -- start counting subscripts
        end if
        
        short_circuit -= 1
        tok = next_token()
        current_sequence = append(current_sequence, sym)
        while tok[T_ID] = LEFT_SQUARE do
            if lhs_subs_level >= 0 then
                lhs_subs_level += 1
            end if
            save_factors = factors
            save_lhs_subs_level = lhs_subs_level
            call_proc(forward_expr, {})
            tok = next_token()
            if tok[T_ID] = SLICE then
                call_proc(forward_expr, {})
                emit_op(RHS_SLICE)
                tok_match(RIGHT_SQUARE)
                tok = next_token()
                exit
            else 
                putback(tok)
                tok_match(RIGHT_SQUARE)
--PL run on 2.4:
--              current_sequence = current_sequence[1..$-1]
                current_sequence = current_sequence[1..length(current_sequence)-1]
                emit_op(RHS_SUBS) -- current_sequence will be updated
            end if
            factors = save_factors
            lhs_subs_level = save_lhs_subs_level
            tok = next_token()
        end while
--PL run on 2.4:
--      current_sequence = current_sequence[1..$-1]
        current_sequence = current_sequence[1..length(current_sequence)-1]
        putback(tok)
        short_circuit += 1

    elsif id = DOLLAR then
        if length(current_sequence) then
            emit_op(DOLLAR)
        else
            CompileErr("'$' must only appear between '[' and ']'")
        end if
        
    elsif id = ATOM then
        emit_opnd(tok[T_SYM])

    elsif id = LEFT_BRACE then
        n = Expr_list()
        tok_match(RIGHT_BRACE)
        op_info1 = n
        emit_op(RIGHT_BRACE_N)

    elsif id = STRING then
        emit_opnd(tok[T_SYM])

    elsif id = LEFT_ROUND then
        call_proc(forward_expr, {})
        tok_match(RIGHT_ROUND)

    elsif find(id, {FUNC, TYPE, QUALIFIED_FUNC, QUALIFIED_TYPE}) then
        e = SymTab[tok[T_SYM]][S_EFFECT]
        if e then
            -- the routine we are calling has side-effects
            if e = E_ALL_EFFECT or tok[T_SYM] > left_sym then
                -- it can access the LHS var (it uses indirect calls or comes later)
                side_effect_calls = or_bits(side_effect_calls, e)
            end if
            
            SymTab[CurrentSub][S_EFFECT] = or_bits(SymTab[CurrentSub][S_EFFECT],
                                                   e)
            
            if short_circuit > 0 and short_circuit_B and
            find(id, {FUNC, QUALIFIED_FUNC}) then
                Warning(sprintf(
                "%.99s:%d - call to %s() might be short-circuited", 
                {file_name[current_file_no], line_number, 
                 SymTab[tok[T_SYM]][S_NAME]}))
            end if
        end if
        tok_match(LEFT_ROUND)
        scope = SymTab[tok[T_SYM]][S_SCOPE]
        opcode = SymTab[tok[T_SYM]][S_OPCODE]
        ParseArgs(tok[T_SYM])
        if scope = SC_PREDEF then
            emit_op(opcode)
        else 
            op_info1 = tok[T_SYM]
            emit_op(PROC)
            if not TRANSLATE then 
                if OpTrace then
                    emit_op(UPDATE_GLOBALS)
                end if
            end if      
        end if

    else 
        CompileErr(sprintf(
                   "Syntax error - expected to see an expression, not %s",
                   {LexName(id)}))
    end if
end procedure


procedure UFactor()
-- parse an optional unary op applied to a factor 
    token tok

    tok = next_token()
    
    if tok[T_ID] = MINUS then
        Factor()
        emit_op(UMINUS)
    
    elsif tok[T_ID] = NOT then
        Factor()
        emit_op(NOT)
    
    elsif tok[T_ID] = PLUS then
        Factor()
    
    else 
        putback(tok)
        Factor()
    
    end if
end procedure

function term()
-- parse a term in an expression 
    token tok
    
    UFactor()   
    tok = next_token() 
    while tok[T_ID] = MULTIPLY or tok[T_ID] = DIVIDE do
        UFactor() 
        emit_op(tok[T_ID]) 
        tok = next_token() 
    end while
    return tok
end function

function aexpr()   
-- Parse an arithmetic expression 
    token tok
    integer id
    
    tok = term()
    while tok[T_ID] = PLUS or tok[T_ID] = MINUS do
        id = tok[T_ID]
        tok = term()
        emit_op(id) 
    end while
    return tok
end function

function cexpr()   
-- Parse a concatenation expression 
    token tok
    integer concat_count
    
    tok = aexpr()
    concat_count = 0 
    while tok[T_ID] = CONCAT do
        tok = aexpr()
        concat_count += 1 
    end while
    
    if concat_count = 1 then
        emit_op(CONCAT)
    
    elsif concat_count > 1 then
        op_info1 = concat_count+1 
        emit_op(CONCAT_N) 
    end if      
    
    return tok
end function

-- Parse a relational expression 
function rexpr()   
    token tok
    integer id
    
    tok = cexpr()
    while tok[T_ID] <= GREATER and tok[T_ID] >= LESS do
        id = tok[T_ID]
        tok = cexpr()
        emit_op(id)
    end while
    return tok
end function

procedure Expr()
-- Parse a general expression 
-- Use either short circuit or full evaluation. 
    token tok
    integer id
    integer patch
    
    id = -1
    patch = 0
    while TRUE do 
        if id != -1 and id != XOR and short_circuit > 0 then
            if id = OR then
                emit_op(SC1_OR)
            else
                emit_op(SC1_AND)
            end if
            patch = length(Code)+1
            emit_forward_addr()
            short_circuit_B = TRUE
        end if
        
        tok = rexpr()
        
        if id != -1 then
            if id != XOR and short_circuit > 0 then
                if tok[T_ID] != THEN and tok[T_ID] != DO then
                    if id = OR then
                        emit_op(SC2_OR)
                    else
                        emit_op(SC2_AND)
                    end if
                else 
                    SC1_type = id -- if/while/elsif must patch
                    emit_op(SC2_NULL)
                end if
                if TRANSLATE then
                    emit_op(NOP1)   -- to get label here
                end if
                backpatch(patch, length(Code)+1)
            else 
                emit_op(id)
            end if
        end if
        id = tok[T_ID]
        if id != OR and id != AND and id != XOR then
            exit
        end if
    end while
    putback(tok)
    SC1_patch = patch -- extra line
end procedure

forward_expr = routine_id("Expr")

procedure TypeCheck(symtab_index var)
-- emit code to type-check a var (after it has been assigned-to) 
    symtab_index which_type

    which_type = SymTab[var][S_VTYPE]
    if TRANSLATE then
        if OpTypeCheck then
            if which_type != object_type then
                if SymTab[which_type][S_EFFECT] then
                    -- only call user-defined types that have side-effects
                    emit_opnd(var)
                    op_info1 = which_type
                    emit_op(PROC)
                    emit_op(TYPE_CHECK)
                end if
            end if
        end if      
    
    else
        if OpTypeCheck then
            if which_type != object_type then
                if which_type = integer_type then
                    op_info1 = var
                    emit_op(INTEGER_CHECK)
                
                elsif which_type = sequence_type then
                    op_info1 = var
                    emit_op(SEQUENCE_CHECK)
                
                elsif which_type = atom_type then
                    op_info1 = var
                    emit_op(ATOM_CHECK)
                
                else 
                    -- user-defined 
                    if SymTab[SymTab[which_type][S_NEXT]][S_VTYPE] = 
                       integer_type then
                        op_info1 = var
                        emit_op(INTEGER_CHECK) -- need integer conversion 
                    end if
                    emit_opnd(var)
                    op_info1 = which_type
                    emit_op(PROC)
                    emit_op(TYPE_CHECK)
                end if
            end if
        end if
    end if

    if TRANSLATE or not OpTypeCheck then
        op_info1 = var
        if which_type = sequence_type or
        SymTab[SymTab[which_type][S_NEXT]][S_VTYPE] = sequence_type then 
            -- check sequences anyway, so we can avoid it on subscripting etc. 
            emit_op(SEQUENCE_CHECK)
            
        elsif which_type = integer_type or
        SymTab[SymTab[which_type][S_NEXT]][S_VTYPE] = integer_type then
                 -- check integers too 
            emit_op(INTEGER_CHECK)
        end if
    end if
end procedure

procedure Assignment(token left_var) 
-- parse an assignment statement 
    token tok
    integer subs, slice, assign_op, subs1_patch
    boolean dangerous  -- tricky subscripted assignment

    left_sym = left_var[T_SYM]
    
    UndefinedVar(left_sym)
        
    if SymTab[left_sym][S_SCOPE] = SC_LOOP_VAR or 
       SymTab[left_sym][S_SCOPE] = SC_GLOOP_VAR then
        CompileErr("may not assign to a for-loop variable")
    
    elsif SymTab[left_sym][S_MODE] = M_CONSTANT then
        CompileErr("may not change the value of a constant")
    
    elsif SymTab[left_sym][S_SCOPE] = SC_LOCAL or 
    SymTab[left_sym][S_SCOPE] = SC_GLOBAL then
        -- this helps us to optimize things below
        SymTab[CurrentSub][S_EFFECT] = or_bits(SymTab[CurrentSub][S_EFFECT],
                                               power(2, remainder(left_sym, E_SIZE)))
    end if
    
    SymTab[left_sym][S_USAGE] = or_bits(SymTab[left_sym][S_USAGE], U_WRITTEN)
    
    tok = next_token()
    subs = 0
    slice = FALSE

    dangerous = FALSE
    side_effect_calls = 0
    
    -- Process LHS subscripts and slice
    emit_opnd(left_sym)
    current_sequence = append(current_sequence, left_sym)
    
    while tok[T_ID] = LEFT_SQUARE do
        if lhs_ptr then
            -- multiple lhs subscripts, evaluate first n-1 of them with this
--PL run on 2.4:
--          current_sequence = current_sequence[1..$-1]
            current_sequence = current_sequence[1..length(current_sequence)-1]
            if subs = 1 then
                -- first subscript of 2 or more
                subs1_patch = length(Code)+1
                emit_op(LHS_SUBS1) -- creates new current_sequence
                                   -- opcode might be patched (below)
            else    
                emit_op(LHS_SUBS) -- adds to current_sequence
            end if
        end if
        subs += 1
        if subs = 1 then
            InitCheck(left_sym, TRUE) 
        end if
        Expr() 
        tok = next_token()
        if tok[T_ID] = SLICE then
            Expr()
            slice = TRUE
            tok_match(RIGHT_SQUARE)
            tok = next_token()
            exit  -- no further subs or slices allowed 
        else 
            putback(tok)
            tok_match(RIGHT_SQUARE)
        end if
        tok = next_token()
        lhs_ptr = TRUE
    end while
    
    lhs_ptr = FALSE
    
    assign_op = tok[T_ID]
    if not find(assign_op, {EQUALS, PLUS_EQUALS, MINUS_EQUALS, MULTIPLY_EQUALS, 
                            DIVIDE_EQUALS, CONCAT_EQUALS}) then
        CompileErr("Syntax error - expected to see =, +=, -=, *=, /= or &=")
    end if
    
    if subs = 0 then
        -- not subscripted 
        if assign_op = EQUALS then
            Expr() -- RHS expression
            InitCheck(left_sym, FALSE)
        else 
            InitCheck(left_sym, TRUE)
            SymTab[left_sym][S_USAGE] = or_bits(SymTab[left_sym][S_USAGE], U_READ)
            emit_opnd(left_sym)
            Expr() -- RHS expression
            emit_assign_op(assign_op)
        end if
        emit_op(ASSIGN)
        TypeCheck(left_sym)

    else 
        -- subscripted 
        factors = 0
        lhs_subs_level = -1
        Expr() -- RHS expression
        
        if subs > 1 then
            if SymTab[left_sym][S_SCOPE] != SC_PRIVATE and
               and_bits(side_effect_calls, 
                        power(2, remainder(left_sym, E_SIZE))) then
                -- this var might be overwritten by a function call while
                -- we are executing this statement
                dangerous = TRUE
            end if
            
            if factors = 1 and 
               lhs_subs_level >= 0 and 
               lhs_subs_level < subs+slice then
                -- must avoid a possible circular reference
                dangerous = TRUE  
            end if
            
            if dangerous then
                -- Patch earlier op so it will copy lhs var to 
                -- a temp to avoid any problem.
                -- (This danger became greater when we implemented $ for 2.5,
                -- and had to interleave LHS subscripting with expression
                -- evaluation).
                backpatch(subs1_patch, LHS_SUBS1_COPY)
            end if
        end if
        
        if slice then 
            if assign_op != EQUALS then
                if subs = 1 then
                    emit_op(ASSIGN_OP_SLICE)
                else    
                    emit_op(PASSIGN_OP_SLICE)
                end if
                emit_assign_op(assign_op)
            end if
            if subs = 1 then
                emit_op(ASSIGN_SLICE)
            else    
                emit_op(PASSIGN_SLICE)
            end if
        else 
            if assign_op = EQUALS then
                if subs = 1 then
                    emit_op(ASSIGN_SUBS)
                else
                    emit_op(PASSIGN_SUBS)
                end if
            else 
                if subs = 1 then
                    emit_op(ASSIGN_OP_SUBS)
                else
                    emit_op(PASSIGN_OP_SUBS)
                end if
                emit_assign_op(assign_op)
                if subs = 1 then
                    emit_op(ASSIGN_SUBS2)
                else    
                    emit_op(PASSIGN_SUBS)
                end if
            end if
        end if
        
        if subs > 1 then
            if dangerous then
                -- copy temp back into lhs var
                emit_opnd(left_sym)
                emit_opnd(lhs_subs1_copy_temp) -- will be freed 
                emit_op(ASSIGN)
            else
                TempFree(lhs_subs1_copy_temp)
            end if
        end if
        
        if OpTypeCheck and SymTab[left_sym][S_VTYPE] != sequence_type then
            TypeCheck(left_sym)
        end if
    end if

--PL run on 2.4:
--  current_sequence = current_sequence[1..$-1]
    current_sequence = current_sequence[1..length(current_sequence)-1]
    
    if not TRANSLATE then
        if OpTrace then 
            emit_op(DISPLAY_VAR)
            emit_addr(left_sym)
        end if
    end if
end procedure

procedure Return_statement()
-- Parse a return statement 
    token tok
    
    if CurrentSub = TopLevelSub then
        CompileErr("return must be inside a procedure or function")
    end if
    if not TRANSLATE then    
        if OpTrace then
            emit_op(ERASE_PRIVATE_NAMES)
            emit_addr(CurrentSub)
        end if
    end if
    if SymTab[CurrentSub][S_TOKEN] != PROC then
        Expr()
        FuncReturn = TRUE
        emit_op(RETURNF)
    else 
        emit_op(RETURNP)
    end if
    tok = next_token()
    putback(tok)
    NotReached(tok[T_ID], "return")
end procedure

procedure Exit_statement()
-- Parse an exit statement 
    token tok
    
    if loop_nest = 0 then
        CompileErr("exit statement must be inside a loop")
    end if
    emit_op(EXIT)
    AppendXList(length(Code)+1)
    emit_forward_addr()     -- to be back-patched 
    tok = next_token()
    putback(tok)
    NotReached(tok[T_ID], "exit")
end procedure

integer forward_Statement_list 

procedure If_statement()
-- parse an if statement with optional elsif's and optional else 
    token tok
    integer prev_false 
    integer prev_false2
    integer elist_base

    elist_base = length(elist)
    short_circuit += 1
    short_circuit_B = FALSE
    SC1_type = 0
    Expr()
    emit_op(IF)
    prev_false = length(Code)+1
    prev_false2 = 0
    emit_forward_addr() -- to be patched 
    if SC1_type = OR then
        backpatch(SC1_patch-3, SC1_OR_IF)
        if TRANSLATE then
            emit_op(NOP1)  -- to get label here
        end if
        backpatch(SC1_patch, length(Code)+1)
    elsif SC1_type = AND then
        backpatch(SC1_patch-3, SC1_AND_IF)
        prev_false2 = SC1_patch
    end if
    short_circuit -= 1
    tok_match(THEN)
    call_proc(forward_Statement_list, {})
    tok = next_token()

    while tok[T_ID] = ELSIF do
        emit_op(ELSE)
        AppendEList(length(Code)+1)
        emit_forward_addr()  -- to be patched 
        if TRANSLATE then
            emit_op(NOP1)
        end if
        backpatch(prev_false, length(Code)+1)
        if prev_false2 != 0 then
            backpatch(prev_false2, length(Code)+1)
        end if
        StartSourceLine(TRUE)
        short_circuit += 1
        short_circuit_B = FALSE
        SC1_type = 0
        Expr()
        emit_op(IF)
        prev_false = length(Code)+1
        prev_false2 = 0
        emit_forward_addr() -- to be patched 
        if SC1_type = OR then
            backpatch(SC1_patch-3, SC1_OR_IF)
            if TRANSLATE then
                emit_op(NOP1)
            end if
            backpatch(SC1_patch, length(Code)+1)
        elsif SC1_type = AND then
            backpatch(SC1_patch-3, SC1_AND_IF)
            prev_false2 = SC1_patch
        end if
        short_circuit -= 1
        tok_match(THEN)
        call_proc(forward_Statement_list, {})
        tok = next_token()
    end while

    if tok[T_ID] = ELSE then 
        StartSourceLine(FALSE)
        emit_op(ELSE)
        AppendEList(length(Code)+1)
        emit_forward_addr() -- to be patched 
        if TRANSLATE then
            emit_op(NOP1)
        end if
        backpatch(prev_false, length(Code)+1)
        if prev_false2 != 0 then
            backpatch(prev_false2, length(Code)+1)
        end if
        call_proc(forward_Statement_list, {})

    else 
        putback(tok)
        if TRANSLATE then
            emit_op(NOP1)
        end if
        backpatch(prev_false, length(Code)+1)
        if prev_false2 != 0 then
            backpatch(prev_false2, length(Code)+1)
        end if
    end if
   
    tok_match(END) 
    tok_match(IF)
    
    if TRANSLATE then
        if length(elist) > elist_base then
            emit_op(NOP1)  -- to emit label here
        end if
    end if
    PatchEList(elist_base)
end procedure


procedure While_statement()
-- Parse a while loop 
    integer bp1 
    integer bp2
    integer exit_base

    if TRANSLATE then
        emit_op(NOPWHILE)
    end if
    bp1 = length(Code)+1
    short_circuit += 1
    short_circuit_B = FALSE
    SC1_type = 0
    Expr()
    tok_match(DO)
    optimized_while = FALSE
    emit_op(WHILE)
    short_circuit -= 1
    if not optimized_while then
        -- WHILE was emitted or combined into IFW op 
        bp2 = length(Code)+1
        emit_forward_addr() -- will be patched 
    else -- WHILE TRUE was optimized to nothing 
        bp2 = 0
    end if
    loop_nest += 1
    exit_base = length(exit_list)
    if SC1_type = OR then
        backpatch(SC1_patch-3, SC1_OR_IF)
        if TRANSLATE then
            emit_op(NOP1)
        end if
        backpatch(SC1_patch, length(Code)+1)
    elsif SC1_type = AND then
        backpatch(SC1_patch-3, SC1_AND_IF)
        AppendXList(SC1_patch)
    end if
    call_proc(forward_Statement_list, {})
    tok_match(END)
    tok_match(WHILE)
    StartSourceLine(TRUE)
    emit_op(ENDWHILE)
    loop_nest -= 1
    emit_addr(bp1)
    if TRANSLATE then
        emit_op(NOP1)
    end if
    if bp2 != 0 then
        backpatch(bp2, length(Code)+1)
    end if
    PatchXList(exit_base)
end procedure

function SetPrivateScope(symtab_index s, symtab_index type_sym, integer n)
-- establish private scope for variable s in SymTab 
-- (index may be changed - new value is returned) 
    integer hashval, scope
    symtab_index t
    
    scope = SymTab[s][S_SCOPE]
    
    if find(scope, {SC_PRIVATE, SC_LOOP_VAR}) then
        DefinedYet(s)
        return s

    elsif find(scope, {SC_UNDEFINED, SC_MULTIPLY_DEFINED}) then
        SymTab[s][S_SCOPE] = SC_PRIVATE
        SymTab[s][S_VARNUM] = n
        SymTab[s][S_VTYPE] = type_sym
        return s

    elsif find(scope, {SC_LOCAL, SC_GLOBAL, SC_PREDEF}) then
        hashval = SymTab[s][S_HASHVAL]
        t = buckets[hashval]
        buckets[hashval] = NewEntry(SymTab[s][S_NAME], n, SC_PRIVATE, 
                                    VARIABLE, hashval, t, type_sym)
        return buckets[hashval]
    else
        InternalErr("SetPS")
        
    end if
    
    return 0
end function

procedure For_statement()
-- Parse a for statement 
    integer bp1
    integer exit_base
    token tok, loop_var
    symtab_index loop_var_sym
    boolean def1
    
    loop_var = next_token()
    if not find(loop_var[T_ID], {VARIABLE, FUNC, TYPE, PROC}) then
        CompileErr("a loop variable name is expected here")
    end if

    if BIND then
        add_ref(loop_var)
    end if
   
    tok_match(EQUALS)
    Expr()
    tok_match(TO)
    loop_nest += 1
    exit_base = length(exit_list)    
    Expr()
    tok = next_token()
    if tok[T_ID] = BY then
        Expr()
        def1 = FALSE
    else 
        emit_opnd(NewIntSym(1))
        putback(tok)
        def1 = TRUE
    end if

    loop_var_sym = loop_var[T_SYM]
    if CurrentSub = TopLevelSub then
        DefinedYet(loop_var_sym)
        SymTab[loop_var_sym][S_SCOPE] = SC_GLOOP_VAR
        SymTab[loop_var_sym][S_VTYPE] = object_type
    else 
        loop_var_sym = SetPrivateScope(loop_var_sym, object_type, param_num)
        param_num += 1
        SymTab[loop_var_sym][S_SCOPE] = SC_LOOP_VAR
    end if
    SymTab[loop_var_sym][S_USAGE] = or_bits(SymTab[loop_var_sym][S_USAGE], 
                                            or_bits(U_READ, U_WRITTEN))

    op_info1 = loop_var_sym
    emit_op(FOR)
    emit_addr(loop_var_sym)
    tok_match(DO)
    bp1 = length(Code)+1
    emit_addr(0) -- will be patched - don't straighten 
    if not TRANSLATE then
        if OpTrace then
            emit_op(DISPLAY_VAR)
            emit_addr(loop_var_sym)
        end if
    end if
    call_proc(forward_Statement_list, {})
    tok_match(END)
    tok_match(FOR)
    StartSourceLine(TRUE)
    op_info1 = loop_var_sym
    op_info2 = bp1 + 1
    if def1 then
        emit_op(ENDFOR_INT_UP1) -- (loop var might not be integer)
    else
        emit_op(ENDFOR_GENERAL) -- will be set at runtime by FOR op 
    end if
    backpatch(bp1, length(Code)+1)
    PatchXList(exit_base)
    loop_nest -= 1
    if not TRANSLATE then
        if OpTrace then
            emit_op(ERASE_SYMBOL)
            emit_addr(loop_var_sym)
        end if
    end if  
    Hide(loop_var_sym)
end procedure

function CompileType(symtab_index type_ptr)
-- Translator only: set the compile type for a variable 
    integer t
    
    if SymTab[type_ptr][S_TOKEN] = OBJECT then
        return TYPE_OBJECT 
      
    elsif type_ptr = integer_type then
        return TYPE_INTEGER
      
    elsif type_ptr = atom_type then
        return TYPE_ATOM 
      
    elsif type_ptr = sequence_type then
        return TYPE_SEQUENCE 
      
    elsif type_ptr = object_type then
        return TYPE_OBJECT
      
    else 
        -- user defined - look at type of the parameter of the type
        t = SymTab[SymTab[type_ptr][S_NEXT]][S_VTYPE]
        if t = integer_type then
            return TYPE_INTEGER 
        elsif t = atom_type then
            return TYPE_ATOM
        elsif t = sequence_type then
            return TYPE_SEQUENCE 
        else    
            return TYPE_OBJECT
        end if
    end if    
end function

procedure Global_declaration(symtab_index type_ptr, integer is_global)
-- parse a command-level variable or constant declaration 
-- type_ptr is NULL if constant 
    token tok
    symtab_index sym
    integer h

    while TRUE do 
        tok = next_token()
        if not find(tok[T_ID], {VARIABLE, FUNC, TYPE, PROC}) then
            CompileErr("a name is expected here")
        end if
        sym = tok[T_SYM]
        DefinedYet(sym)
        if find(SymTab[sym][S_SCOPE], {SC_GLOBAL, SC_PREDEF}) then
            h = SymTab[sym][S_HASHVAL]
            -- create a new entry at beginning of this hash chain 
            sym = NewEntry(SymTab[sym][S_NAME], 0, 0, VARIABLE, h, buckets[h], 0) 
            buckets[h] = sym
            -- more fields set below: 
        end if
        if is_global then
            SymTab[sym][S_SCOPE] = SC_GLOBAL 
        else    
            SymTab[sym][S_SCOPE] = SC_LOCAL
        end if
        if type_ptr = 0 then
            -- CONSTANT 
            SymTab[sym][S_MODE] = M_CONSTANT 
            -- temporarily hide sym so it can't be used in defining itself 
            buckets[SymTab[sym][S_HASHVAL]] = SymTab[sym][S_SAMEHASH]
            tok_match(EQUALS)
            StartSourceLine(FALSE)
            emit_opnd(sym)
            Expr()  -- no new symbols can be defined in here 
            buckets[SymTab[sym][S_HASHVAL]] = sym
            SymTab[sym][S_USAGE] = U_WRITTEN     
           
            if TRANSLATE then
                SymTab[sym][S_GTYPE] = TYPE_OBJECT 
                SymTab[sym][S_OBJ] = NOVALUE     -- distinguish from literals
            end if
           
            emit_op(ASSIGN)
        else 
            -- variable 
            SymTab[sym][S_MODE] = M_NORMAL
            if SymTab[type_ptr][S_TOKEN] = OBJECT then
                SymTab[sym][S_VTYPE] = object_type
            else 
                SymTab[sym][S_VTYPE] = type_ptr
            end if
           
            if TRANSLATE then
                SymTab[sym][S_GTYPE] = CompileType(type_ptr)
            end if
       
        end if
        tok = next_token()
        if tok[T_ID] != COMMA then
            exit
        end if
    end while 
    putback(tok)
end procedure

procedure Private_declaration(symtab_index type_sym)
-- parse a private declaration of one or more variables 
    token tok
    symtab_index sym
        
    while TRUE do 
        tok = next_token()
        if not find(tok[T_ID], {VARIABLE, FUNC, TYPE, PROC, NAMESPACE}) then
            CompileErr("a variable name is expected here")
        end if
        sym = SetPrivateScope(tok[T_SYM], type_sym, param_num)
        param_num += 1
       
        if TRANSLATE then
            SymTab[sym][S_GTYPE] = CompileType(type_sym)
        end if
       
        tok = next_token()
        if tok[T_ID] != COMMA then
            exit
        end if
    end while 
    putback(tok)
end procedure


procedure Procedure_call(token tok)
-- parse a procedure call statement 
    integer n, scope, opcode
    token temp_tok
    symtab_index s
    
    tok_match(LEFT_ROUND)
    s = tok[T_SYM] 
    n = SymTab[s][S_NUM_ARGS]
    scope = SymTab[s][S_SCOPE]
    opcode = SymTab[s][S_OPCODE]
    if SymTab[s][S_EFFECT] then
        SymTab[CurrentSub][S_EFFECT] = or_bits(SymTab[CurrentSub][S_EFFECT],
                                               SymTab[s][S_EFFECT])
    end if
    ParseArgs(s)
    if scope = SC_PREDEF then
        emit_op(opcode)
        if opcode = ABORT then
            temp_tok = next_token()
            putback(temp_tok)
            NotReached(temp_tok[T_ID], "abort()")
        end if
    else 
        op_info1 = s
        emit_op(PROC)
        if not TRANSLATE then
            if OpTrace then
                emit_op(UPDATE_GLOBALS)
            end if
        end if  
    end if
end procedure

procedure Print_statement()
-- parse a '?' print statement 
    emit_opnd(NewIntSym(1)) -- stdout 
    Expr()
    emit_op(QPRINT)
    SymTab[CurrentSub][S_EFFECT] = or_bits(SymTab[CurrentSub][S_EFFECT],
                                           E_OTHER_EFFECT)
end procedure

procedure Statement_list()
-- Parse a list of statements 
    token tok
    integer id
    
    stmt_nest += 1
    while TRUE do 
        tok = next_token()
        id = tok[T_ID]
        
        if id = VARIABLE or id = QUALIFIED_VARIABLE then
            StartSourceLine(TRUE)
            Assignment(tok)
            
        elsif id = PROC or id = QUALIFIED_PROC then
            StartSourceLine(TRUE)
            Procedure_call(tok)
            
        elsif id = IF then
            StartSourceLine(TRUE)
            If_statement()
            
        elsif id = FOR then
            StartSourceLine(TRUE)
            For_statement()
            
        elsif id = RETURN then
            StartSourceLine(TRUE)
            Return_statement()
            
        elsif id = EXIT then
            StartSourceLine(TRUE)
            Exit_statement()
            
        elsif id = WHILE then
            StartSourceLine(TRUE)
            While_statement()
            
        elsif id = QUESTION_MARK then
            StartSourceLine(TRUE)
            Print_statement()

        else 
            putback(tok)
            stmt_nest -= 1
            InitDelete()
            return
        
        end if
    end while
end procedure

forward_Statement_list = routine_id("Statement_list")

procedure SubProg(integer prog_type, integer is_global)
-- parse a function, type or procedure 
-- global is 1 if it's global 
    integer h, pt
    symtab_index p, type_sym, sym
    token tok, prog_name

    LeaveTopLevel()

    prog_name = next_token()
    if not find(prog_name[T_ID], {VARIABLE, FUNC, TYPE, PROC}) then
        CompileErr("a name is expected here")
    end if
    p = prog_name[T_SYM] 

    DefinedYet(p)

    if prog_type = PROCEDURE then
        pt = PROC
    elsif prog_type = FUNCTION then
        pt = FUNC
    else        
        pt = TYPE
    end if
    
    if find(SymTab[p][S_SCOPE], {SC_PREDEF, SC_GLOBAL}) then
        -- redefine by creating new symbol table entry 
        if SymTab[p][S_SCOPE] = SC_PREDEF then  -- only warn about overriding predefined
            Warning(sprintf("built-in routine %s() redefined", 
                            {SymTab[p][S_NAME]}))
        end if
        h = SymTab[p][S_HASHVAL]
        sym = buckets[h]
        p = NewEntry(SymTab[p][S_NAME], 0, 0, pt, h, sym, 0) 
        buckets[h] = p
    end if
    CurrentSub = p
    temps_allocated = 0
    
    if is_global then
        SymTab[p][S_SCOPE] = SC_GLOBAL
    else
        SymTab[p][S_SCOPE] = SC_LOCAL
    end if
    
    SymTab[p][S_TOKEN] = pt
    
    if length(SymTab[p]) < SIZEOF_ROUTINE_ENTRY then
        -- expand var entry to routine entry
        SymTab[p] = SymTab[p] & repeat(0, SIZEOF_ROUTINE_ENTRY - 
                                       length(SymTab[p]))
    end if
    
    SymTab[p][S_CODE] = 0
    SymTab[p][S_LINETAB] = 0
    SymTab[p][S_EFFECT] = E_PURE
    SymTab[p][S_REFLIST] = {}
    SymTab[p][S_FIRSTLINE] = gline_number
    SymTab[p][S_TEMPS] = 0
    SymTab[p][S_RESIDENT_TASK] = 0
    SymTab[p][S_SAVED_PRIVATES] = {}
    
    StartSourceLine(FALSE)  
    tok_match(LEFT_ROUND)
    tok = next_token()
    param_num = 0
    while tok[T_ID] != RIGHT_ROUND do
        -- parse the parameter declarations
        if tok[T_ID] != TYPE and tok[T_ID] != QUALIFIED_TYPE then
            if tok[T_ID] = VARIABLE or tok[T_ID] = QUALIFIED_VARIABLE then
                UndefinedVar(tok[T_SYM])
            end if
            CompileErr("a type is expected here")            
        end if
        type_sym = tok[T_SYM]
        tok = next_token()
        if not find(tok[T_ID], {VARIABLE, FUNC, TYPE, PROC, NAMESPACE}) then
            CompileErr("a parameter name is expected here")
        end if
        sym = SetPrivateScope(tok[T_SYM], type_sym, param_num)
        param_num += 1
       
        if TRANSLATE then
            SymTab[sym][S_GTYPE] = CompileType(type_sym)
        end if
       
        SymTab[sym][S_USAGE] = U_WRITTEN     
        tok = next_token()
        if tok[T_ID] = COMMA then
            tok = next_token()
            if tok[T_ID] = RIGHT_ROUND then
                CompileErr("expected to see a parameter declaration, not ')'")
            end if
        elsif tok[T_ID] != RIGHT_ROUND then
            CompileErr("badly-formed list of parameters - expected ',' or ')'")
        end if
    end while

    SymTab[p][S_NUM_ARGS] = param_num
    if TRANSLATE then
        if param_num > max_params then
            max_params = param_num
        end if
        num_routines += 1
    end if
    if SymTab[p][S_TOKEN] = TYPE and param_num != 1 then
        CompileErr("types must have exactly one parameter")
    end if
    tok = next_token()
    -- parameters are numbered: 0, 1, ... num_args-1 
    -- other privates are numbered: num_args, num_args+1, ... 
    while tok[T_ID] = TYPE or tok[T_ID] = QUALIFIED_TYPE do
        -- parse the next private variable declaration
        Private_declaration(tok[T_SYM])
        tok = next_token()
    end while

    -- start of executable code for subprogram: 

    -- code to perform type checks on all the parameters 
    sym = SymTab[p][S_NEXT]
    for i = 1 to SymTab[p][S_NUM_ARGS] do
        TypeCheck(sym)
        sym = SymTab[sym][S_NEXT]
    end for

    if not TRANSLATE then
        if OpTrace then
            -- clear any private names from screen 
            emit_op(ERASE_PRIVATE_NAMES)
            emit_addr(p)
            -- display initial values of all the parameters 
            sym = SymTab[p][S_NEXT]
            for i = 1 to SymTab[p][S_NUM_ARGS] do
                emit_op(DISPLAY_VAR)
                emit_addr(sym)
                sym = SymTab[sym][S_NEXT]
            end for
            -- globals may have changed 
            emit_op(UPDATE_GLOBALS)
        end if
    end if
    putback(tok)

    FuncReturn = FALSE
    Statement_list()
    tok_match(END)
    ExitScope()
    tok_match(prog_type)
    if prog_type != PROCEDURE then
        if not FuncReturn then
            if prog_type = FUNCTION then
                CompileErr("no value returned from function")
            else
                CompileErr("type must return true / false value")
            end if
        end if
        emit_op(BADRETURNF) -- function/type shouldn't reach here 
    
    else 
        StartSourceLine(TRUE)
        if not TRANSLATE then
            if OpTrace then
                emit_op(ERASE_PRIVATE_NAMES)
                emit_addr(p)
            end if
        end if      
        emit_op(RETURNP)
        if TRANSLATE then
            emit_op(BADRETURNF) -- just to mark end of procedure
        end if  
    end if
    
    SymTab[p][S_STACK_SPACE] = temps_allocated + param_num
    if temps_allocated + param_num > max_stack_per_call then 
        max_stack_per_call = temps_allocated + param_num
    end if
    
    StraightenBranches()
    EnterTopLevel()
end procedure

global procedure InitGlobals()
-- initialize global variables 
    ResetTP()
    OpTypeCheck = TRUE
    OpWarning = TRUE
end procedure

sequence mix_msg
mix_msg = "can't mix profile and profile_time"

procedure SetWith(integer on_off)
-- set a with/without option 
    sequence option
    token tok
    
    option = StringToken()
    
    if equal(option, "type_check") then
        OpTypeCheck = on_off

    elsif equal(option, "profile") then
        if not TRANSLATE and not BIND then
            OpProfileStatement = on_off
            if OpProfileStatement then
                if AnyTimeProfile then
                    Warning(mix_msg)
                    OpProfileStatement = FALSE
                else
                    AnyStatementProfile = TRUE
                end if
            end if
        end if
    
    elsif equal(option, "profile_time") then
        if not TRANSLATE and not BIND then
            if not EDOS then
                if on_off then
                    not_supported_compile("profile_time")
                end if
            end if
            OpProfileTime = on_off
            if OpProfileTime then
                if AnyStatementProfile then
                    Warning(mix_msg)
                    OpProfileTime = FALSE
                end if
                tok = next_token()
                if tok[T_ID] = ATOM then
                    if integer(SymTab[tok[T_SYM]][S_OBJ]) then
                        sample_size = SymTab[tok[T_SYM]][S_OBJ]
                    else
                        sample_size = -1
                    end if
                    if sample_size < 1 and OpProfileTime then
                        CompileErr("sample size must be a positive integer")
                    end if
                else 
                    putback(tok)
                    sample_size = DEFAULT_SAMPLE_SIZE
                end if
                if OpProfileTime then
                    if EDOS then
                        AnyTimeProfile = TRUE
                    end if
                end if
            end if
        end if  
    
    elsif equal(option, "trace") then
        if not BIND then 
            OpTrace = on_off
        end if
    
    elsif equal(option, "warning") then
        OpWarning = on_off
    
    elsif on_off and option[1] >= '0' and option[1] <= '9' then
        -- Ignore numeric stamp - not supported anymore
    
    else 
        CompileErr("unknown with/without option")
    
    end if
end procedure

procedure ExecCommand()
-- execute a top-level command  
    if TRANSLATE then
        emit_op(RETURNT)
    end if
    StraightenBranches()  -- straighten top-level
end procedure

global procedure parser()
-- top level of the parser - command level 
    token tok
    integer id
    
    tok = next_token()
    while TRUE do  -- infinite loop until scanner aborts
        start_index = length(Code)+1
        id = tok[T_ID]
        if id = VARIABLE or id = QUALIFIED_VARIABLE then
            StartSourceLine(TRUE)
            Assignment(tok)
            ExecCommand()

        elsif id = PROCEDURE or id = FUNCTION or id = TYPE_DECL then
            SubProg(tok[T_ID], 0)

        elsif id = GLOBAL then
            tok = next_token()
            id = tok[T_ID]
            if id = TYPE then
                Global_declaration(tok[T_SYM], 1)
            elsif id = CONSTANT then
                Global_declaration(0, 1)
                ExecCommand()
            elsif id = PROCEDURE or id = FUNCTION or id = TYPE_DECL then
                SubProg(id, 1)
            else 
                if id = VARIABLE or id = QUALIFIED_VARIABLE then
                    UndefinedVar(tok[T_SYM])
                end if
                CompileErr(
"'global' must be followed by:\n     <a type>, 'constant', 'procedure', 'type' or 'function'")
            end if
                
        elsif id = TYPE or id = QUALIFIED_TYPE then
            Global_declaration(tok[T_SYM], 0)

        elsif id = CONSTANT then
            Global_declaration(0, 0)
            ExecCommand()

        elsif id = IF then
            StartSourceLine(TRUE)
            If_statement()
            ExecCommand()

        elsif id = FOR then
            StartSourceLine(TRUE)
            For_statement()
            ExecCommand()

        elsif id = WHILE then
            StartSourceLine(TRUE)
            While_statement()
            ExecCommand()

        elsif id = PROC or id = QUALIFIED_PROC then
            StartSourceLine(TRUE)
            Procedure_call(tok)
            ExecCommand()
            
        elsif id = FUNC or id = QUALIFIED_FUNC then
            CompileErr("function result must be assigned or used")
                
        elsif id = RETURN then
            Return_statement() -- will fail - not allowed at top level

        elsif id = EXIT then
            CompileErr("exit must be inside a loop")                 

        elsif id = INCLUDE then
            IncludeScan()

        elsif id = WITH then
            SetWith(TRUE)

        elsif id = WITHOUT then
            SetWith(FALSE)

        elsif id = END_OF_FILE then
            if IncludePop() then
                read_line()
            else
                exit -- all finished
            end if
        
        elsif id = QUESTION_MARK then
            StartSourceLine(TRUE)
            Print_statement()
            ExecCommand()
            
        elsif id = ILLEGAL_CHAR then
            CompileErr("illegal character")
        
        else 
            CompileErr("unknown command")

        end if
        
        tok = next_token()
    end while 
    
    emit_op(RETURNT)
    StraightenBranches()
    SymTab[TopLevelSub][S_CODE] = Code
    EndLineTable()
    SymTab[TopLevelSub][S_LINETAB] = LineTable
end procedure

-- INTERPRETER back-end, written in Euphoria
--include execute.e 
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- The Interpreter Back-End

-- This back-end is written in Euphoria. It uses the same front-end
-- as the official RDS Euphoria interpreter, and it executes the same IL
-- opcodes. Because it's written in Euphoria, this back-end is very 
-- simple. Much simpler than the back-end used in the official RDS interpreter. 

-- Using the Euphoria to C Translator, or the Binder, you can convert 
-- this 100% Euphoria-coded interpreter into a .exe. The Translator 
-- will boost its speed considerably, though it will still be slower 
-- than the official RDS interpreter. The official interpreter has a 
-- carefully hand-coded back-end written in C.

include dll.e
include file.e
----include global.e
--include opnames.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Names of the IL opcodes

global constant opnames = {
                           "LESS",
                           "GREATEREQ",
                           "EQUALS",
                           "NOTEQ",
                           "LESSEQ",
                           "GREATER",
                           "NOT",
                           "AND",
                           "OR",
                           "MINUS",
                           "PLUS",
                           "UMINUS",
                           "MULTIPLY",
                           "DIVIDE",
                           "CONCAT",
                           "ASSIGN_SUBS",
                           "GETS",
                           "ASSIGN",
                           "PRINT",
                           "IF",
                           "FOR",
                           "ENDWHILE",
                           "ELSE",
                           "OR_BITS",
                           "RHS_SUBS",
                           "XOR_BITS",
                           "PROC",
                           "RETURNF",
                           "RETURNP",
                           "PRIVATE_INIT_CHECK",
                           "RIGHT_BRACE_N",
                           "REPEAT",
                           "GETC",
                           "RETURNT",
                           "APPEND",
                           "QPRINT",
                           "OPEN",
                           "PRINTF",
                           "ENDFOR_GENERAL",
                           "IS_AN_OBJECT",
                           "SQRT",
                           "LENGTH",
                           "BADRETURNF",
                           "PUTS",
                           "ASSIGN_SLICE",
                           "RHS_SLICE",
                           "WHILE",
                           "ENDFOR_INT_UP",
                           "ENDFOR_UP",
                           "ENDFOR_DOWN",
                           "NOT_BITS",
                           "ENDFOR_INT_DOWN",
                           "SPRINTF",
                           "ENDFOR_INT_UP1",
                           "ENDFOR_INT_DOWN1",
                           "AND_BITS",
                           "PREPEND",
                           "STARTLINE",
                           "CLEAR_SCREEN",
                           "POSITION",
                           "EXIT",
                           "RAND",
                           "FLOOR_DIV",
                           "TRACE",
                           "TYPE_CHECK",
                           "FLOOR_DIV2",
                           "IS_AN_ATOM",
                           "IS_A_SEQUENCE",
                           "DATE",
                           "TIME",
                           "REMAINDER",
                           "POWER",
                           "ARCTAN",
                           "LOG",
                           "SPACE_USED",
                           "COMPARE",
                           "FIND",
                           "MATCH",
                           "GET_KEY",
                           "SIN",
                           "COS",
                           "TAN",
                           "FLOOR",
                           "ASSIGN_SUBS_CHECK",
                           "RIGHT_BRACE_2",
                           "CLOSE",
                           "DISPLAY_VAR",
                           "ERASE_PRIVATE_NAMES",
                           "UPDATE_GLOBALS",
                           "ERASE_SYMBOL",
                           "GETENV",
                           "RHS_SUBS_CHECK",
                           "PLUS1",
                           "IS_AN_INTEGER",
                           "LHS_SUBS",
                           "INTEGER_CHECK",
                           "SEQUENCE_CHECK",
                           "DIV2",
                           "SYSTEM",
                           "COMMAND_LINE",
                           "ATOM_CHECK",
                           "LESS_IFW",
                           "GREATEREQ_IFW",
                           "EQUALS_IFW",
                           "NOTEQ_IFW",
                           "LESSEQ_IFW",
                           "GREATER_IFW",
                           "NOT_IFW",
                           "GLOBAL_INIT_CHECK",
                           "NOP2",
                           "MACHINE_FUNC",
                           "MACHINE_PROC",
                           "ASSIGN_I",
                           "RHS_SUBS_I",
                           "PLUS_I",
                           "MINUS_I",
                           "PLUS1_I",
                           "ASSIGN_SUBS_I",
                           "LESS_IFW_I",
                           "GREATEREQ_IFW_I",
                           "EQUALS_IFW_I",
                           "NOTEQ_IFW_I",
                           "LESSEQ_IFW_I",
                           "GREATER_IFW_I",
                           "FOR_I",
                           "ABORT",
                           "PEEK",
                           "POKE",
                           "CALL",
                           "PIXEL",
                           "GET_PIXEL",
                           "MEM_COPY",
                           "MEM_SET",
                           "C_PROC",
                           "C_FUNC",
                           "ROUTINE_ID",
                           "CALL_BACK_RETURN",
                           "CALL_PROC",
                           "CALL_FUNC",
                           "POKE4",
                           "PEEK4S",
                           "PEEK4U",
                           "SC1_AND",
                           "SC2_AND",
                           "SC1_OR",
                           "SC2_OR",
                           "SC2_NULL",
                           "SC1_AND_IF",
                           "SC1_OR_IF",
                           "ASSIGN_SUBS2",
                           "ASSIGN_OP_SUBS",
                           "ASSIGN_OP_SLICE",
                           "PROFILE",
                           "XOR",
                           "EQUAL",
                           "SYSTEM_EXEC",
                           "PLATFORM",
                           "END_PARAM_CHECK",
                           "CONCAT_N",
                           "NOPWHILE",
                           "NOP1",
                           "PLENGTH",
                           "LHS_SUBS1",
                           "PASSIGN_SUBS",
                           "PASSIGN_SLICE",
                           "PASSIGN_OP_SUBS",
                           "PASSIGN_OP_SLICE",
                           "LHS_SUBS1_COPY",
                           "TASK_CREATE",
                           "TASK_SCHEDULE",
                           "TASK_YIELD",
                           "TASK_SELF",
                           "TASK_SUSPEND",
                           "TASK_LIST",
                           "TASK_STATUS",
                           "TASK_CLOCK_STOP",
                           "TASK_CLOCK_START"   -- 177
                          }

-- Note: In several places we omit checking for bad arguments to 
-- built-in routines. Those errors will be caught by the underlying 
-- interpreter or Euphoria run-time system, and an error will be raised 
-- against execute.e. To correct this would require a lot of 
-- extra code, and would slow things down. It is left as an exercise
-- for the reader. :-)
    
-- we handle these operations specially because they refer to routine ids
-- in the user program, not the interpreter itself. We can't just let 
-- Euphoria do the work.

constant M_CALL_BACK = 52,  
M_CRASH_ROUTINE = 66,
M_CRASH_MESSAGE = 37,
M_CRASH_FILE = 57,
M_TICK_RATE = 38
     
constant --C_MY_ROUTINE = 1,
C_USER_ROUTINE = 2,
C_NUM_ARGS = 3

object crash_msg
crash_msg = 0

sequence call_backs, call_back_code
symtab_index t_id, t_arglist, t_return_val, call_back_routine

sequence crash_list  -- list of routine id's to call if there's a fatal crash
crash_list = {}

integer crash_count
crash_count = 0

-- only need one set of temps for call-backs
t_id = tmp_alloc()
t_arglist = tmp_alloc()
t_return_val = tmp_alloc()

-- dummy call-back routine
call_back_routine = NewEntry("_call_back_", 0, 0, PROC, 0, 0, 0)
SymTab[call_back_routine] = SymTab[call_back_routine] & 
                            repeat(0, SIZEOF_ROUTINE_ENTRY - 
                                   length(SymTab[call_back_routine]))

SymTab[call_back_routine][S_SAVED_PRIVATES] = {}

call_back_code = {CALL_FUNC,
                  t_id,
                  t_arglist,
                  t_return_val,
                  CALL_BACK_RETURN
                 }

SymTab[call_back_routine][S_CODE] = call_back_code

integer TraceOn
TraceOn = FALSE

integer pc, a, b, c, d, target, len, keep_running
integer lhs_seq_index -- index of lhs sequence
sequence lhs_subs -- first n-1 LHS subscripts before final subscript or slice
sequence val

constant TASK_NEVER = 1e300
constant TASK_ID_MAX = 9e15 -- wrap to 0 after this (and avoid in-use ones)
boolean id_wrap             -- have task id's wrapped around? (very rare)
id_wrap = FALSE  

integer current_task  -- internal number of currently-executing task

sequence call_stack   -- active subroutine call stack
-- At each subroutine call we push two items: 
-- 1. the return pc value
-- 2. the current subroutine index

atom next_task_id     -- for multitasking
next_task_id = 1

atom clock_period
if EDOS then
    clock_period = 0.055  -- DOS default (can change)
else
    clock_period = 0.01   -- Windows/Linux/FreeBSD
end if

-- TCB fields
constant TASK_RID = 1,      -- routine id
TASK_TID = 2,       -- external task id
TASK_TYPE = 3,  -- type of task: T_REAL_TIME or T_TIME_SHARED
Task_STATUS = 4,    -- status: ST_ACTIVE, ST_SUSPENDED, ST_DEAD
TASK_START = 5, -- start time of current run
TASK_MIN_INC = 6,   -- time increment for min
TASK_MAX_INC = 7,   -- time increment for max 
TASK_MIN_TIME = 8, -- minimum activation time
                -- or number of executions remaining before sharing
TASK_MAX_TIME = 9, -- maximum activation time (determines task order)
TASK_RUNS_LEFT = 10,-- number of executions left in this burst
TASK_RUNS_MAX = 11,-- maximum number of executions in one burst
TASK_NEXT = 12, -- points to next task on list
TASK_ARGS = 13, -- args to call task procedure with at startup
TASK_PC = 14,       -- program counter for this task
TASK_CODE = 15, -- IL code for this task
TASK_STACK = 16 -- call stack for this task

-- status values
constant ST_ACTIVE = 0,
ST_SUSPENDED = 1,
ST_DEAD = 2

constant T_REAL_TIME = 1,
T_TIME_SHARE = 2
     
sequence tcb    -- task control block for real-time and time-shared tasks
tcb = {
       -- initial "top-level" task, tid=0
       {-1, 0, T_TIME_SHARE, ST_ACTIVE, 0,
        0, 0, 1, 1, 1, 1, 0, {}, 1, {}, {}} 
      }

integer rt_first, ts_first
rt_first = 0 -- unsorted list of active rt tasks
ts_first = 1 -- unsorted list of active ts tasks (initialized to initial task)

sequence e_routine -- list of routines with a routine id assigned to them
e_routine = {}

integer err_file
sequence err_file_name
err_file_name = "ex.err" 

procedure open_err_file()
-- open ex.err  

    err_file = open(err_file_name, "w")
    if err_file = -1 then
        puts(2, "Can't open " & err_file_name & '\n')
        abort(1)
    end if
end procedure

boolean screen_err_out

procedure both_puts(object s)
-- print to both screen and error file  
    if screen_err_out then
        puts(2, s)
    end if
    puts(err_file, s)
end procedure

procedure both_printf(sequence format, sequence items)
-- print to both screen and error file  
    if screen_err_out then
        printf(2, format, items)
    end if
    printf(err_file, format, items)
end procedure

function find_line(symtab_index sub, integer pc)
-- return the file name and line that matches pc in sub
    sequence linetab
    integer line, gline
    
    linetab = SymTab[sub][S_LINETAB]
    line = 1
    for i = 1 to length(linetab) do
        if linetab[i] >= pc or linetab[i] = -2 then
            line = i-1
            while line > 1 and linetab[line] = -1 do
                line -= 1
            end while
            exit
        end if
    end for
    gline = SymTab[sub][S_FIRSTLINE] + line - 1
    return {file_name[slist[gline][LOCAL_FILE_NO]], slist[gline][LINE]}
end function

procedure show_var(symtab_index x)
-- display a variable name and value
    
    puts(err_file, "    " & SymTab[x][S_NAME] & " = ")
    if equal(val[x], NOVALUE) then
        puts(err_file, "<no value>")
    else
        pretty_print(err_file, val[x], 
                     {1, 2, length(SymTab[x][S_NAME]) + 7, 78, "%d", "%.10g", 32, 127, 500})
    end if
    puts(err_file, '\n')
end procedure

-- saved private blocks
constant SP_TASK_NUMBER = 1,
SP_TID = 2,
SP_BLOCK = 3,
SP_NEXT = 4

procedure save_private_block(symtab_index routine, sequence block)
-- save block for resident task on the private list for this routine
-- reuse any empty spot 
-- save in last-in, first-out order
-- We use a linked list to mirror the C-coded backend
    sequence saved, saved_list, entry
    integer task, spot, tn
    
    task = SymTab[routine][S_RESIDENT_TASK]
    -- save it
    entry = {task, tcb[task][TASK_TID], block, 0}
    saved = SymTab[routine][S_SAVED_PRIVATES]
    
    if length(saved) = 0 then
        -- first time set up
        saved = {1, -- index of first item
                 {entry}} -- list of items
    else
        -- look for a free spot to put it
        saved_list = saved[2]
        spot = 0
        for i = 1 to length(saved_list) do
            tn = saved_list[i][SP_TASK_NUMBER]
            if tn = -1 or 
            saved_list[i][SP_TID] != tcb[tn][TASK_TID] then
          -- this spot was freed, or task died and was replaced
                spot = i
                exit
            end if
        end for
    
        entry[SP_NEXT] = saved[1] -- new entry points to previous first
        if spot = 0 then
            -- no unused spots, must grow
            saved_list = append(saved_list, entry)
            spot = length(saved_list)
        else
            saved_list[spot] = entry
        end if
    
        saved[1] = spot -- it becomes the first on the list
        saved[2] = saved_list
    end if
    
    SymTab[routine][S_SAVED_PRIVATES] = saved
end procedure

function load_private_block(symtab_index routine, integer task)
-- retrieve a private block and remove it from the list for this routine
-- (we know that the block must be there)
    sequence saved, saved_list, block
    integer p, prev_p, first
    
    saved = SymTab[routine][S_SAVED_PRIVATES]
    first = saved[1]
    p = first -- won't be 0
    prev_p = -1
    saved_list = saved[2]
    while TRUE do
        if saved_list[p][SP_TASK_NUMBER] = task then
            -- won't be for old dead task, must be current
            block = saved_list[p][SP_BLOCK]
            saved_list[p][SP_TASK_NUMBER] = -1 -- mark it as deleted
            if prev_p = -1 then
                first = saved_list[p][SP_NEXT]
            else    
                saved_list[prev_p][SP_NEXT] = saved_list[p][SP_NEXT]
            end if
            saved[1] = first
            saved[2] = saved_list
            SymTab[routine][S_SAVED_PRIVATES] = saved
            return block
        end if
        prev_p = p
        p = saved_list[p][SP_NEXT]
    end while
end function

procedure restore_privates(symtab_index this_routine)
-- kick out the current private data and
-- restore the private data for the current task
    symtab_index arg
    sequence private_block
    integer base
    
    if SymTab[this_routine][S_RESIDENT_TASK] != current_task then
    -- get new private data
    
        if SymTab[this_routine][S_RESIDENT_TASK] != 0 then 
        -- calling routine was taken over by another task
    
            -- save the other task's private data 

            -- private vars
            arg = SymTab[this_routine][S_NEXT]
            private_block = {}
            while arg != 0 and SymTab[arg][S_SCOPE] <= SC_PRIVATE do
                private_block = append(private_block, val[arg])   
                arg = SymTab[arg][S_NEXT]
            end while
    
            -- temps
            arg = SymTab[this_routine][S_TEMPS]
            while arg != 0 do
                private_block = append(private_block, val[arg])   
                arg = SymTab[arg][S_NEXT]
            end while

            save_private_block(this_routine, private_block)
        end if
    
        -- restore the current task's private data (must be there)
        private_block = load_private_block(this_routine, current_task)

        -- private vars
        base = 1
        arg = SymTab[this_routine][S_NEXT]
        while arg and SymTab[arg][S_SCOPE] <= SC_PRIVATE do
            val[arg] = private_block[base]
            base += 1
            arg = SymTab[arg][S_NEXT]
        end while
        
        -- temps
        arg = SymTab[this_routine][S_TEMPS]
        while arg != 0 do
            val[arg] = private_block[base]
            base += 1
            arg = SymTab[arg][S_NEXT]
        end while
    
        SymTab[this_routine][S_RESIDENT_TASK] = current_task
    end if
end procedure

procedure trace_back(sequence msg)
-- display the call stack and variables after a crash
    symtab_index sub, v
    integer levels, prev_file_no, task, dash_count
    sequence routine_name, title
    boolean show_message
    
--PL run on 2.4:
--  if atom(slist[$]) then
    if atom(slist[length(slist)]) then
        slist = s_expand(slist)
    end if
    
    -- display call stack for each task,
    -- current task first
    show_message = TRUE
    
    screen_err_out = atom(crash_msg)
    
    while TRUE do
        if length(tcb) > 1 then
        -- multiple tasks were used
        
            if current_task = 1 then
                routine_name = "initial task"
            else
                routine_name = SymTab[e_routine[1+tcb[current_task][TASK_RID]]][S_NAME]
            end if
    
            title = sprintf(" TASK ID %d: %s ", 
                            {tcb[current_task][TASK_TID], routine_name})
            dash_count = 60
            if length(title) < dash_count then
                dash_count = 52 - length(title)
            end if
            if dash_count < 1 then
                dash_count = 1
            end if
            both_puts(repeat('-', 22) & title & repeat('-', dash_count) & "\n")
        end if
    
        levels = 1
    
        while length(call_stack) > 0 do
--PL run on 2.4:
--          sub = call_stack[$]
            sub = call_stack[length(call_stack)]
        
            if levels = 1 then
                puts(2, '\n')
        
            elsif sub != call_back_routine then
                both_puts("... called from ")
                -- pc points to statement after the subroutine call
            end if
        
            if sub = call_back_routine then
                if crash_count > 0 then
                    both_puts("^^^ called to handle run-time crash\n")
                    exit
                else
                    both_puts("^^^ call-back from ")
                    if EWINDOWS then
                        both_puts("Windows\n")
                    else    
                        both_puts("external program\n")
                    end if
                end if
        
            else
                both_printf("%s:%d ", find_line(sub, pc)) 
    
                if not equal(SymTab[sub][S_NAME], "_toplevel_") then
                    if SymTab[sub][S_TOKEN] = PROC then
                        both_puts("in procedure ")
                    elsif SymTab[sub][S_TOKEN] = FUNC then
                        both_puts("in function ")
                    elsif SymTab[sub][S_TOKEN] = TYPE then
                        both_puts("in type ")
                    end if
        
                    both_printf("%s()", {SymTab[sub][S_NAME]})
                end if
        
                both_puts("\n")
        
                if show_message then
                    if sequence(crash_msg) then
                        clear_screen()
                        puts(2, crash_msg)
                    end if
                    both_puts(msg & '\n')
                    show_message = FALSE
                end if
    
                if length(call_stack) < 2 then
                    both_puts('\n')
                    exit
                end if
        
                -- display parameters and private vars
                v = SymTab[sub][S_NEXT]

                while v != 0 and 
                (SymTab[v][S_SCOPE] = SC_PRIVATE or 
                 SymTab[v][S_SCOPE] = SC_LOOP_VAR) do
                    show_var(v)
                    v = SymTab[v][S_NEXT]
                end while
        
                if length(SymTab[sub][S_SAVED_PRIVATES]) > 0 and
                SymTab[sub][S_SAVED_PRIVATES][1] != 0 then
                    SymTab[sub][S_RESIDENT_TASK] = 0
                    restore_privates(sub)
                end if
            end if
        
            puts(err_file, '\n')
        
        -- stacked pc points to next statement after the call (so subtract 1)
--PL run on 2.4:
--          pc = call_stack[$-1] - 1
            pc = call_stack[length(call_stack)-1] - 1
--          call_stack = call_stack[1..$-2]
            call_stack = call_stack[1..length(call_stack)-2]
            levels += 1
        end while
    
        tcb[current_task][Task_STATUS] = ST_DEAD -- mark as "deleted"
    
        -- choose next task to display
        task = current_task
        for i = 1 to length(tcb) do
            if tcb[i][Task_STATUS] != ST_DEAD and 
            length(tcb[i][TASK_STACK]) > 0 then
                current_task = i
                call_stack = tcb[i][TASK_STACK]
                pc = tcb[i][TASK_PC]
                Code = tcb[i][TASK_CODE]
                screen_err_out = FALSE  -- just show offending task on screen
                exit
            end if
        end for 
        if task = current_task then
            exit
        end if  
        both_puts("\n")
    end while
    
    puts(2, "\n--> see " & err_file_name & '\n')
    
    puts(err_file, "\n\nGlobal & Local Variables\n")
    prev_file_no = -1
    v = SymTab[TopLevelSub][S_NEXT]
    while v do
        if SymTab[v][S_TOKEN] = VARIABLE and 
        SymTab[v][S_MODE] = M_NORMAL and
        find(SymTab[v][S_SCOPE], {SC_LOCAL, SC_GLOBAL, SC_GLOOP_VAR}) then
            if SymTab[v][S_FILE_NO] != prev_file_no then
                prev_file_no = SymTab[v][S_FILE_NO]
                puts(err_file, "\n " & file_name[prev_file_no] & ":\n")
            end if
            show_var(v)
        end if
        v = SymTab[v][S_NEXT]
    end while
    puts(err_file, '\n')
    close(err_file)
end procedure

integer forward_general_callback
--PL 16/12
--, forward_machine_callback

procedure call_crash_routines()
-- call all the routines in the crash list  
    object quit
    
    if crash_count > 0 then
        return
    end if
    
    crash_count += 1
    
    -- call them in reverse order
    err_file_name = "ex_crash.err"
    
    for i = length(crash_list) to 1 by -1 do
        -- do callback to get addr
        quit = call_func(forward_general_callback, 
                         {{0, crash_list[i], 1}, {0}})
        if not equal(quit, 0) then
            return -- don't call the others
        end if
    end for
end procedure

procedure quit_after_error()
-- final termination    
    if EWINDOWS then
        puts(2, "\nPress Enter...\n")
        if getc(0) then
        end if
    end if
    abort(1)
end procedure

procedure RTFatalType(integer x)
-- handle a fatal run-time type-check error 
    sequence msg, v
    sequence vname

    open_err_file()
    a = Code[x]
    vname = SymTab[a][S_NAME]
    msg = sprintf("type_check error\n%s is ", {vname}) 
    v = sprint(val[a])
    if length(v) > 70 - length(vname) then
        v = v[1..70 - length(vname)]
--PL run on 2.4:
--      while length(v) and not find(v[$], ",}")  do
        while length(v) and not find(v[length(v)], ",}")  do
--          v = v[1..$-1]
            v = v[1..length(v)-1]
        end while
        v = v & " ..."
    end if
    trace_back(msg & v)
    call_crash_routines()
    quit_after_error()
end procedure

procedure RTFatal(sequence msg)
-- handle a fatal run-time error    
    open_err_file()
    trace_back(msg)
    call_crash_routines()
    quit_after_error()
end procedure

procedure RTInternal(sequence msg)
-- Internal errors in back-end
    puts(2, '\n' & msg & '\n')
    ? 1/0
end procedure

-- Multi-tasking operations


procedure wait(atom t)
-- wait for a while 
    atom t1, t2
    
    t1 = floor(t)
    if t1 >= 1 then
        sleep(t1)
        t -= t1
    end if
    
    t2 = time() + t
    while time() < t2 do
    end while
end procedure

boolean clock_stopped
clock_stopped = FALSE

procedure scheduler()
-- pick the next task to run
    atom earliest_time, start_time, now
    boolean ts_found
    sequence tp
    integer p, earliest_task
    
    -- first check the real-time tasks
    
    -- find the task with the earliest MAX_TIME
    earliest_task = rt_first
    
    if clock_stopped or earliest_task = 0 then
        -- no real-time tasks are active
        start_time = 1
        now = -1
    
    else
        -- choose a real-time task
        earliest_time = tcb[earliest_task][TASK_MAX_TIME]
    
        p = tcb[rt_first][TASK_NEXT]
        while p != 0 do
            tp = tcb[p]
            if tp[TASK_MAX_TIME] < earliest_time then
                earliest_task = p
                earliest_time = tp[TASK_MAX_TIME]
            end if
            p = tp[TASK_NEXT]
        end while
    
        -- when can we start? how many runs?
        now = time()
    
        start_time = tcb[earliest_task][TASK_MIN_TIME]
    
        if earliest_task = current_task and 
        tcb[current_task][TASK_RUNS_LEFT] > 0 then
        -- runs left - continue with the current task
        else
            if tcb[current_task][TASK_TYPE] = T_REAL_TIME then
                tcb[current_task][TASK_RUNS_LEFT] = 0
            end if
            tcb[earliest_task][TASK_RUNS_LEFT] = tcb[earliest_task][TASK_RUNS_MAX]
        end if
    end if
    
    if start_time > now then
    -- No real-time task is ready to run.
    -- Look for a time-share task.
    
        ts_found = FALSE
        p = ts_first
        while p != 0 do
            tp = tcb[p]
            if tp[TASK_RUNS_LEFT] > 0 then
                earliest_task = p
                ts_found = TRUE
                exit
            end if
            p = tp[TASK_NEXT]
        end while
    
        if not ts_found then
            -- all time-share tasks are at zero, recharge them all, 
            -- and choose one to run
            p = ts_first
            while p != 0 do
                tp = tcb[p]
                earliest_task = p
                tcb[p][TASK_RUNS_LEFT] = tp[TASK_RUNS_MAX]
                p = tp[TASK_NEXT]
            end while
        end if
        
        if earliest_task = 0 then
            -- no tasks are active - no task will ever run again
            -- RTFatal("no task to run") ??
            abort(0)
        end if
        
        if tcb[earliest_task][TASK_TYPE] = T_REAL_TIME then
            -- no time-sharing tasks, wait and run this real-time task
            wait(start_time - now)
        end if
       
    end if

    tcb[earliest_task][TASK_START] = time()
    
    if earliest_task = current_task then
        pc += 1  -- continue with current task
    else    
    -- switch to a new task
    
        -- save old task state
        tcb[current_task][TASK_CODE] = Code
        tcb[current_task][TASK_PC] = pc
        tcb[current_task][TASK_STACK] = call_stack
    
        -- load new task state
        Code = tcb[earliest_task][TASK_CODE]
        pc = tcb[earliest_task][TASK_PC]
        call_stack = tcb[earliest_task][TASK_STACK]
    
        current_task = earliest_task
    
        if tcb[current_task][TASK_PC] = 0 then
            -- first time we are running this task
            -- call its procedure, passing the args from task_create
            pc = 1
            val[t_id] = tcb[current_task][TASK_RID]
            val[t_arglist] = tcb[current_task][TASK_ARGS]
            Code = {CALL_PROC, t_id, t_arglist}
        else
            -- resuming after a task_yield()
            pc += 1
--PL run on 2.4:
--          restore_privates(call_stack[$])
            restore_privates(call_stack[length(call_stack)])
        end if
    end if
end procedure

function task_insert(integer first, integer task)
-- add a task to the appropriate list of tasks
    tcb[task][TASK_NEXT] = first
    return task
end function

function task_delete(integer first, integer task)
-- remove a task from a list of tasks (if it's there)
    integer p, prev_p
    
    prev_p = -1
    p = first
    while p != 0 do
        if p = task then
            if prev_p = -1 then
            -- it was first on list
                return tcb[p][TASK_NEXT]
            else
            -- skip around it
                tcb[prev_p][TASK_NEXT] = tcb[p][TASK_NEXT]
                return first
            end if
        end if
        prev_p = p
        p = tcb[p][TASK_NEXT]
    end while
    -- couldn't find it
    return first
end function

procedure opTASK_YIELD()
-- temporarily stop running this task, and give the scheduler a chance
-- to pick a new task
    atom now
    
    if tcb[current_task][Task_STATUS] = ST_ACTIVE then
        if tcb[current_task][TASK_RUNS_LEFT] > 0 then
            tcb[current_task][TASK_RUNS_LEFT] -= 1
        end if
        if tcb[current_task][TASK_TYPE] = T_REAL_TIME then
            now = time()
            if tcb[current_task][TASK_RUNS_MAX] > 1 and 
            tcb[current_task][TASK_START] = now then
                -- quick run of rapid-cycling task - clock hasn't even ticked
                if tcb[current_task][TASK_RUNS_LEFT] = 0 then
                    -- avoid excessive number of runs per clock period
                    now += clock_period
                    tcb[current_task][TASK_RUNS_LEFT] = tcb[current_task][TASK_RUNS_MAX]
                    tcb[current_task][TASK_MIN_TIME] = now + 
                                                       tcb[current_task][TASK_MIN_INC]
                    tcb[current_task][TASK_MAX_TIME] = now + 
                                                       tcb[current_task][TASK_MAX_INC]
                else
            -- let it run multiple times per tick
            
                end if
            else
                tcb[current_task][TASK_MIN_TIME] = now + 
                                                   tcb[current_task][TASK_MIN_INC]
                tcb[current_task][TASK_MAX_TIME] = now + 
                                                   tcb[current_task][TASK_MAX_INC]
            end if
        end if
    end if
    scheduler()
end procedure

procedure kill_task(integer task)
-- mark a task for deletion (task is the internal task number)
    if tcb[task][TASK_TYPE] = T_REAL_TIME then
        rt_first = task_delete(rt_first, task)
    else    
        ts_first = task_delete(ts_first, task)
    end if
    tcb[task][Task_STATUS] = ST_DEAD
    -- its tcb entry will be recycled later
end procedure

function which_task(atom tid)
-- find internal task number, given external task id
    
    for i = 1 to length(tcb) do
        if tcb[i][TASK_TID] = tid then
            return i
        end if
    end for
    RTFatal("invalid task id")
end function

procedure opTASK_STATUS()
-- return task status   
    integer r
    atom tid
    
    a = Code[pc+1]
    target = Code[pc+2]
    tid = val[a]
    r = -1
    for t = 1 to length(tcb) do
        if tcb[t][TASK_TID] = tid then
            if tcb[t][Task_STATUS] = ST_ACTIVE then
                r = 1
            elsif tcb[t][Task_STATUS] = ST_SUSPENDED then
                r = 0
            end if
            exit
        end if
    end for
    val[target] = r
    pc += 3
end procedure

procedure opTASK_LIST()
-- return list of active and suspended tasks    
    sequence list
    
    target = Code[pc+1]
    list = {}
    for i = 1 to length(tcb) do
        if tcb[i][Task_STATUS] != ST_DEAD then
            list = append(list, tcb[i][TASK_TID])
        end if
    end for
    val[target] = list
    pc += 2
end procedure

procedure opTASK_SELF()
-- return current task id   
    target = Code[pc+1]
    val[target] = tcb[current_task][TASK_TID]
    pc += 2
end procedure

atom save_clock
save_clock = -1

procedure opTASK_CLOCK_STOP()
-- stop the scheduler clock 
    if not clock_stopped then
        save_clock = time()
        clock_stopped = TRUE
    end if
    pc += 1
end procedure

procedure opTASK_CLOCK_START()
-- resume the scheduler clock   
    atom shift
    
    if clock_stopped then
        if save_clock >= 0 and save_clock < time() then
            shift = time() - save_clock
            for i = 1 to length(tcb) do
                tcb[i][TASK_MIN_TIME] += shift
                tcb[i][TASK_MAX_TIME] += shift
            end for
        end if
        clock_stopped = FALSE
    end if
    pc += 1
end procedure

procedure opTASK_SUSPEND()
-- suspend a task   
    integer task
    
    a = Code[pc+1]
    task = which_task(val[a])
    tcb[task][Task_STATUS] = ST_SUSPENDED
    tcb[task][TASK_MAX_TIME] = TASK_NEVER
    if tcb[task][TASK_TYPE] = T_REAL_TIME then
        rt_first = task_delete(rt_first, task)
    else    
        ts_first = task_delete(ts_first, task)
    end if
    pc += 2
end procedure
        
procedure opTASK_CREATE()
-- create a new task    
    symtab_index sub
    sequence new_entry
    boolean recycle
    
    a = Code[pc+1] -- routine id
    if val[a] < 0 or val[a] >= length(e_routine) then
        RTFatal("invalid routine id")
    end if
    sub = e_routine[val[a]+1]
    if SymTab[sub][S_TOKEN] != PROC then
        RTFatal("specify the routine id of a procedure, not a function or type")
    end if
    b = Code[pc+2] -- args
    
    -- initially it's suspended
    new_entry = {val[a], next_task_id, T_REAL_TIME, ST_SUSPENDED, 0, 
                 0, 0, 0, TASK_NEVER, 1, 1, 0, val[b], 0, {}, {}}
    
    recycle = FALSE
    for i = 1 to length(tcb) do
        if tcb[i][Task_STATUS] = ST_DEAD then
            -- this task is dead, recycle its entry 
            -- (but not its external task id)
            tcb[i] = new_entry
            recycle = TRUE
            exit
        end if
    end for
    
    if not recycle then
        -- expand
        tcb = append(tcb, new_entry)
    end if
    
    target = Code[pc+3]
    val[target] = next_task_id
    if not id_wrap and next_task_id < TASK_ID_MAX then
        next_task_id += 1
    else
        -- extremely rare
        id_wrap = TRUE -- id's have wrapped
--PL 9/1/9 error compiling (TASK_ID_MAX is 9e15!)
--      for i = 1 to TASK_ID_MAX do
        for i = 1 to length(tcb)+1 do   -- simple logic: n slots cannot hold n+1 values
            next_task_id = i
            for j = 1 to length(tcb) do
                if next_task_id = tcb[j][TASK_TID] then
                    next_task_id = 0
                    exit -- this id is still in use
                end if
            end for
            if next_task_id then
                exit -- found unused id for next time
            end if
        end for
        -- must have found one - couldn't have trillions of non-dead tasks!
    end if
    pc += 4
end procedure

procedure opTASK_SCHEDULE()
-- schedule a task by linking it into the real-time tcb queue,
-- or the time sharing tcb queue
    
    integer task
    atom now
    object s
    
    a = Code[pc+1]
    task = which_task(val[a])
    b = Code[pc+2]
    s = val[b]
    
    if atom(s) then
        -- time-sharing
        if s <= 0 then
            RTFatal("number of executions must be greater than 0")
        end if
        --tcb[task][TASK_RUNS_LEFT] = s  -- current execution count
        tcb[task][TASK_RUNS_MAX] = s   -- max execution count
        if tcb[task][TASK_TYPE] = T_REAL_TIME then
            rt_first = task_delete(rt_first, task)
        end if
        if tcb[task][TASK_TYPE] = T_REAL_TIME or
        tcb[task][Task_STATUS] = ST_SUSPENDED then
            ts_first = task_insert(ts_first, task)
        end if
        tcb[task][TASK_TYPE] = T_TIME_SHARE
    
    else
        -- real-time
        if length(s) != 2 then
            RTFatal("second argument must be {min-time, max-time}")
        end if
        if sequence(s[1]) or sequence(s[2]) then
            RTFatal("min and max times must be atoms")
        end if
        if s[1] < 0 or s[2] < 0 then
            RTFatal("min and max times must be greater than or equal to 0")
        end if
        if s[1] > s[2] then
            RTFatal("task min time must be <= task max time")
        end if
        tcb[task][TASK_MIN_INC] = s[1]
    
        if s[1] < clock_period/2 then
            -- allow multiple runs per clock period
            if s[1] > 1.0e-9 then
                tcb[task][TASK_RUNS_MAX] =  floor(clock_period / s[1])
            else
            -- avoid divide by zero or almost zero
                tcb[task][TASK_RUNS_MAX] =  1000000000 -- arbitrary, large
            end if
        else
            tcb[task][TASK_RUNS_MAX] = 1
        end if
        tcb[task][TASK_MAX_INC] = s[2]
        now = time()
        tcb[task][TASK_MIN_TIME] = now + s[1]
        tcb[task][TASK_MAX_TIME] = now + s[2]
    
        if tcb[task][TASK_TYPE] = T_TIME_SHARE then
            ts_first = task_delete(ts_first, task)
        end if
        if tcb[task][TASK_TYPE] = T_TIME_SHARE or
        tcb[task][Task_STATUS] = ST_SUSPENDED then
            rt_first = task_insert(rt_first, task)
        end if
        tcb[task][TASK_TYPE] = T_REAL_TIME
    end if
    tcb[task][Task_STATUS] = ST_ACTIVE
    pc += 3
end procedure


file trace_file
trace_file = -1

integer trace_line
trace_line = 0

procedure one_trace_line(sequence line)
-- write one fixed-width 79-char line to ctrace.out
    if ELINUX then
        printf(trace_file, "%-78.78s\n", {line})
    else
        printf(trace_file, "%-77.77s\r\n", {line})
    end if
end procedure

procedure opSTARTLINE()
-- Start of a line. Use for diagnostics.
    sequence line
    integer w
    
    if TraceOn then
        if trace_file = -1 then
            trace_file = open("ctrace.out", "wb")
            if trace_file = -1 then
                RTFatal("Couldn't open ctrace.out")
            end if
        end if

        a = Code[pc+1]
    
--PL run on 2.4:
--      if atom(slist[$]) then
        if atom(slist[length(slist)]) then
            slist = s_expand(slist)
        end if
        line = fetch_line(slist[a][SRC])
        line = sprintf("%s:%d\t%s",
                       {name_ext(file_name[slist[a][LOCAL_FILE_NO]]),
                        slist[a][LINE],
                        line})
        trace_line += 1
        if trace_line >= 500 then
            -- wrap around to start of file
            trace_line = 0
            one_trace_line("")
            one_trace_line("               ")
            flush(trace_file)
            if seek(trace_file, 0) then
            end if
        end if
    
        one_trace_line(line)
        one_trace_line("")
        one_trace_line("=== THE END ===")
        one_trace_line("")
        one_trace_line("")
        one_trace_line("")
        flush(trace_file)
        w = where(trace_file)
        if seek(trace_file, w-79*5) then -- back up 5 (fixed-width) lines
        end if
    end if
    pc += 2
end procedure
    
procedure opPROC()  
-- Normal subroutine call
    integer n, arg, sub, p
    sequence private_block
    
    -- make a procedure or function/type call
    sub = Code[pc+1] -- subroutine
    arg = SymTab[sub][S_NEXT] 
    n = SymTab[sub][S_NUM_ARGS]
    
    if SymTab[sub][S_RESIDENT_TASK] != 0 then
    -- save the parameters, privates and temps
    
        -- save and set the args
        private_block = repeat(0, SymTab[sub][S_STACK_SPACE])
        p = 1
        for i = 1 to n do
            private_block[p] = val[arg]
            p += 1
            val[arg] = val[Code[pc+1+i]]
            arg = SymTab[arg][S_NEXT]
        end for
    
        -- save privates
        while arg != 0 and SymTab[arg][S_SCOPE] <= SC_PRIVATE do
            private_block[p] = val[arg]
            p += 1
            val[arg] = NOVALUE  -- necessary?
            arg = SymTab[arg][S_NEXT]
        end while
    
        -- save temps
        arg = SymTab[sub][S_TEMPS]
        while arg != 0 do
            private_block[p] = val[arg]
            p += 1
            val[arg] = NOVALUE -- necessary?
            arg = SymTab[arg][S_NEXT]
        end while
    
        -- save this block of private data
        save_private_block(sub, private_block)
    else    
        -- routine is not in use, no need to save 
        -- just set the args 
        for i = 1 to n do
            val[arg] = val[Code[pc+1+i]]
            arg = SymTab[arg][S_NEXT]
        end for
    end if
    
    SymTab[sub][S_RESIDENT_TASK] = current_task
    
    pc = pc + 2 + n
    if SymTab[sub][S_TOKEN] != PROC then
        pc += 1
    end if
    
    call_stack = append(call_stack, pc) 
    call_stack = append(call_stack, sub)
    
    Code = SymTab[sub][S_CODE]
    pc = 1 
end procedure

integer result
result = 0
object result_val

procedure opRETURNP()   
-- return from procedure (or function)
    symtab_index arg, sub, caller
    
    sub = Code[pc+1]
    
    -- set up for caller
--PL run on 2.4:
--  pc = call_stack[$-1]
    pc = call_stack[length(call_stack)-1]
--  call_stack = call_stack[1..$-2]
    call_stack = call_stack[1..length(call_stack)-2]
    
    -- set sub privates to NOVALUE -- necessary? - we do it at routine entry
    arg = SymTab[sub][S_NEXT]
    while arg and SymTab[arg][S_SCOPE] <= SC_PRIVATE do
        val[arg] = NOVALUE
        arg = SymTab[arg][S_NEXT]
    end while

    SymTab[sub][S_RESIDENT_TASK] = 0
    
    if length(call_stack) then
--PL run on 2.4:
--      caller = call_stack[$]
        caller = call_stack[length(call_stack)]
        Code = SymTab[caller][S_CODE]
        restore_privates(caller)
        if result then
            val[Code[result]] = result_val
            result = 0
        end if
    else
        kill_task(current_task)
        scheduler()
    end if
end procedure

procedure opRETURNF()  
-- return from function
    result_val = val[Code[pc+2]]
--PL run on 2.4:
--  result = call_stack[$-1] - 1
    result = call_stack[length(call_stack)-1] - 1
    opRETURNP()
end procedure

procedure opCALL_BACK_RETURN()
-- force return from do_exec()
    keep_running = FALSE  
end procedure
        
procedure opBADRETURNF()  
-- shouldn't reach here
    RTFatal("attempt to exit a function without returning a value")  
end procedure

procedure opRETURNT()   
-- return from top-level "procedure"
    pc += 1
    if pc > length(Code) then
        keep_running = FALSE  -- we've reached the end of the code
    end if
end procedure
    
procedure opRHS_SUBS() 
-- subscript a sequence to get the value of the element
-- RHS_SUBS_CHECK, RHS_SUBS, RHS_SUBS_I
    object sub, x
    
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    x = val[a]
    sub = val[b]
    if atom(x) then
        RTFatal("attempt to subscript an atom\n(reading from it)")
    end if
    if sequence(sub) then
        RTFatal("subscript must be an atom\n(reading an element of a sequence)")
    end if
    sub = floor(sub)
    if sub < 1 or sub > length(x) then
        RTFatal(
    sprintf(
    "subscript value %d is out of bounds, reading from a sequence of length %d", 
    {sub, length(x)}))
    end if
    val[target] = x[sub]
    pc += 4
end procedure
    
procedure opIF()
    a = Code[pc+1]
    if val[a] = 0 then
        pc = Code[pc+2]
    else
        pc += 3
    end if
end procedure
        
procedure opINTEGER_CHECK()
    a = Code[pc+1]
    if not integer(val[a]) then
        RTFatalType(pc+1)
    end if
    pc += 2
end procedure
        
procedure opATOM_CHECK()
    a = Code[pc+1]
    if not atom(val[a]) then
        RTFatalType(pc+1)
    end if
    pc += 2
end procedure
          
procedure opSEQUENCE_CHECK()
    a = Code[pc+1]
    if not sequence(val[a]) then
        RTFatalType(pc+1)
    end if
    pc += 2
end procedure

procedure opASSIGN()  
-- ASSIGN, ASSIGN_I 
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = val[a]
    pc += 3
end procedure
        
procedure opELSE()  
-- ELSE, EXIT, ENDWHILE
    pc = Code[pc+1]
end procedure
        
procedure opRIGHT_BRACE_N()  
-- form a sequence of any length 
    sequence x
    
    len = Code[pc+1]
    x = {}
    for i = pc+len+1 to pc+2 by -1 do
        -- last one comes first
        x = append(x, val[Code[i]])
    end for
    target = Code[pc+len+2]
    val[target] = x
    pc += 3 + len
end procedure

procedure opRIGHT_BRACE_2()   
-- form a sequence of length 2 (slightly faster than above)
    target = Code[pc+3]
    -- the second one comes first
    val[target] = {val[Code[pc+2]], val[Code[pc+1]]}
    pc += 4
end procedure

procedure opPLUS1() 
--PLUS1, PLUS1_I
    a = Code[pc+1]
    -- [2] is not used
    target = Code[pc+3] 
    val[target] = val[a] + 1
    pc += 4
end procedure
    
procedure opGLOBAL_INIT_CHECK()  
-- GLOBAL_INIT_CHECK, PRIVATE_INIT_CHECK 
    a = Code[pc+1]
    if equal(val[a], NOVALUE) then
        RTFatal(SymTab[a][S_NAME] & " has not been initialized")
    end if
    pc += 2
end procedure
        
procedure opWHILE()     
-- sometimes emit.c optimizes this away
    a = Code[pc+1]
    if val[a] = 0 then
        pc = Code[pc+2]
    else
        pc += 3
    end if
end procedure

function var_subs(object x, sequence subs)
-- subscript x with the list of subscripts in subs
    object si
    
    if atom(x) then
        RTFatal("attempt to subscript an atom\n(reading from it)")
    end if
    for i = 1 to length(subs) do
        si = subs[i]
        if sequence(si) then
            RTFatal("A subscript must be an atom")
        end if
        si = floor(si)
        if si > length(x) or si < 1 then
            RTFatal(
        sprintf("subscript value %d is out of bounds, reading from a sequence of length %d",
                {si, length(x)}))
        end if
        x = x[subs[i]]
    end for
    return x
end function

procedure opLENGTH()
-- operand should be a sequence 
    a = Code[pc+1]
    target = Code[pc+2]
    if atom(val[a]) then
        RTFatal("length of an atom is not defined")
    end if
    val[target] = length(val[a])
    pc += 3
end procedure

-- Note: Multiple LHS subscripts, and $ within those subscripts,
-- is handled much more efficiently in the hand-coded C interpreter,
-- and in code translated to C, where C pointers can be used effectively.

procedure opPLENGTH()
-- Needed for some LHS uses of $. Operand should be a val index of a sequence,
-- with subscripts. 
    a = Code[pc+1]
    target = Code[pc+2]
    lhs_seq_index = val[a][1]
--PL run on 2.4:
--  lhs_subs = val[a][2..$]
    lhs_subs = val[a][2..length(val[a])]
    val[target] = length(var_subs(val[lhs_seq_index], lhs_subs))
    pc += 3
end procedure

procedure opLHS_SUBS() 
-- LHS = "Left Hand Side" of assignment
-- Handle one LHS subscript, when there are multiple LHS subscripts.
    
    a = Code[pc+1] -- base var sequence, or a temp that contains
           -- {base index, subs1, subs2... so far}
    b = Code[pc+2] -- subscript
    target = Code[pc+3] -- temp for storing result
    
    -- a is a "pointer" to the result of previous subscripting
    val[target] = append(val[a], val[b])
    pc += 5
end procedure

procedure opLHS_SUBS1() 
-- Handle first LHS subscript, when there are multiple LHS subscripts.
    a = Code[pc+1] -- base var sequence, or a temp that contains
           -- {base index, subs1, subs2... so far}
    b = Code[pc+2] -- subscript
    target = Code[pc+3] -- temp for storing result
    
    -- a is the base var
    val[target] = {a, val[b]}
    pc += 5
end procedure

procedure opLHS_SUBS1_COPY() 
-- Handle first LHS subscript, when there are multiple LHS subscripts.
-- In tricky situations (in the C-coded back-end) a copy of the sequence 
-- is made into a temp. 
    
    a = Code[pc+1] -- base var sequence
           
    b = Code[pc+2] -- subscript
    
    target = Code[pc+3] -- temp for storing result
    
    c = Code[pc+4] -- temp to hold base sequence while it's manipulated
    
    val[c] = val[a]
    
    -- a is the base var
    val[target] = {c, val[b]}
    
    pc += 5
end procedure

procedure lhs_check_subs(object seq, object subs)
-- see if seq[subs] = ... is legal  
    if atom(seq) then
        RTFatal("attempt to subscript an atom\n(assigning to it)")
    end if
    if sequence(subs) then
        RTFatal(
    sprintf(
    "subscript must be an atom\n(assigning to a sequence of length %d)",
    length(seq)))
    end if
    subs = floor(subs)
    if subs < 1 or subs > length(seq) then
        RTFatal(
    sprintf(
    "subscript value %d is out of bounds, assigning to a sequence of length %d",
    {subs, length(seq)}))
    end if
end procedure

procedure check_slice(object seq, object lower, object upper)
-- check for valid slice indexes
    atom len
    
    if sequence(lower) then
        RTFatal("slice lower index is not an atom")
    end if
    lower = floor(lower)
    if lower < 1 then
        RTFatal("slice lower index is less than 1")
    end if
    
    if sequence(upper) then
        RTFatal("slice upper index is not an atom")
    end if
    upper = floor(upper)
    if upper < 0 then
        RTFatal("slice upper index is less than 0")
    end if
    
    if atom(seq) then
        RTFatal("attempt to slice an atom")
    end if
    
    len = upper - lower + 1
    
    if len < 0 then
        RTFatal("slice length is less than 0")
    end if

    if lower > length(seq) + 1 or (len > 0 and lower > length(seq)) then
        RTFatal("slice starts past end of sequence")
    end if

    if upper > length(seq) then
        RTFatal("slice ends past end of sequence")
    end if
end procedure

procedure lhs_check_slice(object seq, object lower, object upper, object rhs)
-- check for a valid assignment to a slice
    atom len
    
    check_slice(seq, lower, upper)
    
    len = floor(upper) - floor(lower) + 1
    
    if sequence(rhs) and length(rhs) != len then
        RTFatal("lengths do not match on assignment to slice")
    end if
end procedure

function var_slice(object x, sequence subs, atom lower, atom upper)
-- slice x after subscripting a variable number of times
    if atom(x) then
        RTFatal("attempt to subscript an atom\n(reading from it)")
    end if
    for i = 1 to length(subs) do
        if sequence(subs[i]) then
            RTFatal("subscript must be an atom")
        end if
--PL 16/12
--  subs = floor(subs)
        subs[i] = floor(subs[i])
        if subs[i] > length(x) or subs[i] < 1 then
            RTFatal(
        sprintf("subscript value %d is out of bounds, reading from a sequence of length %d",
                {subs[i], length(x)}))
        end if
        x = x[subs[i]] 
    end for
    check_slice(x, lower, upper)
    return x[lower..upper]
end function

function assign_subs(sequence x, sequence subs, object rhs_val)
-- assign a value to a subscripted sequence (any number of subscripts >= 1)
    lhs_check_subs(x, subs[1])
    if length(subs) = 1 then
        x[subs[1]] = rhs_val
    else
--PL run on 2.4:
--      x[subs[1]] = assign_subs(x[subs[1]], subs[2..$], rhs_val)
        x[subs[1]] = assign_subs(x[subs[1]], subs[2..length(subs)], rhs_val)
    end if
    return x
end function            

function assign_slice(sequence x, sequence subs, atom lower, atom upper, object rhs_val)
-- assign a value to a subscripted/sliced sequence 
-- (any number of subscripts >= 1, then one slice)
    -- should check slice too
    lhs_check_subs(x, subs[1])
    if length(subs) = 1 then
        lhs_check_slice(x[subs[1]],lower,upper,rhs_val)
        x[subs[1]][lower..upper] = rhs_val
    else
--PL run on 2.4:
--      x[subs[1]] = assign_slice(x[subs[1]], subs[2..$], lower, upper, rhs_val)
        x[subs[1]] = assign_slice(x[subs[1]], subs[2..length(subs)], lower, upper, rhs_val)
    end if
    return x
end function            

procedure opASSIGN_SUBS() -- also ASSIGN_SUBS_CHECK, ASSIGN_SUBS_I
-- LHS single subscript and assignment
    object x, subs
    
    a = Code[pc+1]  -- the sequence
    b = Code[pc+2]  -- the subscript
    if sequence(val[b]) then
        RTFatal("subscript must be an atom\n(assigning to subscript of a sequence)")        
    end if
    c = Code[pc+3]  -- the RHS value
    x = val[a] -- avoid lingering ref count on val[a]
    lhs_check_subs(x, val[b])
    x = val[c]
    subs = val[b]
    val[a][subs] = x  -- single LHS subscript
    pc += 4
end procedure

procedure opPASSIGN_SUBS()
-- final LHS subscript and assignment after a series of subscripts
    a = Code[pc+1]
    b = Code[pc+2]  -- subscript
    if sequence(val[b]) then
        RTFatal("subscript must be an atom\n(assigning to subscript of a sequence)")        
    end if
    c = Code[pc+3]  -- RHS value
    
    -- multiple LHS subscript case
    lhs_seq_index = val[a][1]
--PL run on 2.4:
--  lhs_subs = val[a][2..$]  
    lhs_subs = val[a][2..length(val[a])] 
    val[lhs_seq_index] = assign_subs(val[lhs_seq_index], 
                                     lhs_subs & val[b], 
                                     val[c])
    pc += 4
end procedure

procedure opASSIGN_OP_SUBS()  
-- var[subs] op= expr
    object x
    
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    -- var with one subscript
    lhs_subs = {}
    x = val[a]
    val[target] = var_subs(x, lhs_subs & val[b])
    pc += 4
end procedure

procedure opPASSIGN_OP_SUBS()  
-- var[subs] ... [subs] op= expr
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    -- temp with multiple subscripts
    lhs_seq_index = val[a][1]
--PL run on 2.4:
--  lhs_subs = val[a][2..$]  
    lhs_subs = val[a][2..length(val[a])] 
    Code[pc+9] = Code[pc+1] -- patch upcoming op
    val[target] = var_subs(val[lhs_seq_index], lhs_subs & val[b])
    pc += 4
end procedure

procedure opASSIGN_OP_SLICE()  
-- var[i..j] op= expr
    object x

    a = Code[pc+1]
    x = val[a]
    b = Code[pc+2]
    if floor(val[b]) > length(x) or floor(val[b]) < 1 then
        RTFatal(
    sprintf("subscript value %d is out of bounds, reading from a sequence of length %d",
            {val[b], length(x)}))
    end if
    c = Code[pc+3]
    target = Code[pc+4]
    val[target] = var_slice(x, {}, val[b], val[c])
    pc += 5
end procedure

procedure opPASSIGN_OP_SLICE()
-- var[subs] ... [i..j] op= expr
    object x

    a = Code[pc+1]
    x = val[a]
    b = Code[pc+2]
    c = Code[pc+3]
    target = Code[pc+4]
    lhs_seq_index = x[1]
--PL run on 2.4:
--  lhs_subs = x[2..$]
    lhs_subs = x[2..length(x)]
    Code[pc+10] = Code[pc+1]
    val[target] = var_slice(val[lhs_seq_index], lhs_subs, val[b], val[c])
    pc += 5
end procedure
        
procedure opASSIGN_SLICE()   
-- var[i..j] = expr
    object x
    
    a = Code[pc+1]  -- sequence
    b = Code[pc+2]  -- 1st index
    c = Code[pc+3]  -- 2nd index
    d = Code[pc+4]  -- rhs value to assign
    
    x = val[a] -- avoid lingering ref count on val[a]
    lhs_check_slice(x, val[b], val[c], val[d])
    x = val[d]
    val[a][val[b]..val[c]] = x
    pc += 5
end procedure

procedure opPASSIGN_SLICE()   
-- var[x] ... [i..j] = expr
    a = Code[pc+1]  -- sequence
    b = Code[pc+2]  -- 1st index
    c = Code[pc+3]  -- 2nd index
    d = Code[pc+4]  -- rhs value to assign
    
    lhs_seq_index = val[a][1]
--PL run on 2.4:
--  lhs_subs = val[a][2..$]  
    lhs_subs = val[a][2..length(val[a])] 
    val[lhs_seq_index] = assign_slice(val[lhs_seq_index],
                                      lhs_subs,
                                      val[b], val[c], val[d])
    pc += 5
end procedure

procedure opRHS_SLICE() 
-- rhs slice of a sequence a[i..j] 
    object x
    
    a = Code[pc+1]  -- sequence
    b = Code[pc+2]  -- 1st index
    c = Code[pc+3]  -- 2nd index
    target = Code[pc+4]  
    x = val[a]
    check_slice(x, val[b], val[c])
    val[target] = x[val[b]..val[c]]
    pc += 5
end procedure

procedure opTYPE_CHECK() 
-- type check for a user-defined type
-- this always follows a type-call
    if val[Code[pc-1]] = 0 then
        RTFatalType(pc-2)
    end if
    pc += 1
end procedure
        
procedure opIS_AN_INTEGER()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = integer(val[a])
    pc += 3
end procedure

procedure opIS_AN_ATOM()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = atom(val[a])
    pc += 3
end procedure
        
procedure opIS_A_SEQUENCE() 
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = sequence(val[a])
    pc += 3
end procedure
        
procedure opIS_AN_OBJECT()
    target = Code[pc+2]
    val[target] = 1
    pc += 3
end procedure
        
    
    -- ---------- start of unary ops ----------------- 

procedure opSQRT() 
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = sqrt(val[a])
    pc += 3
end procedure

procedure opSIN()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = sin(val[a])
    pc += 3
end procedure

procedure opCOS()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = cos(val[a])
    pc += 3
end procedure

procedure opTAN()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = tan(val[a])
    pc += 3
end procedure

procedure opARCTAN()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = arctan(val[a])
    pc += 3
end procedure

procedure opLOG()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = log(val[a])
    pc += 3
end procedure

procedure opNOT_BITS()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = not_bits(val[a])
    pc += 3
end procedure

procedure opFLOOR()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = floor(val[a])
    pc += 3
end procedure

procedure opNOT_IFW()
    a = Code[pc+1]
    if val[a] = 0 then
        pc += 3
    else
        pc = Code[pc+2]
    end if
end procedure
        
procedure opNOT()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = not val[a]
    pc += 3
end procedure
        
procedure opUMINUS()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = -val[a]
    pc += 3
end procedure
        
procedure opRAND()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = rand(val[a])
    pc += 3
end procedure
        
procedure opDIV2()  
-- like unary op, but pc+=4
    a = Code[pc+1]
    -- Code[pc+2] not used
    target = Code[pc+3]
    val[target] = val[a] / 2
    pc += 4 
end procedure
        
procedure opFLOOR_DIV2()
    a = Code[pc+1]
    -- Code[pc+2] not used
    target = Code[pc+3]
    val[target] = floor(val[a] / 2)
    pc += 4 
end procedure
        
    ----------- start of binary ops ----------
        
procedure opGREATER_IFW()
    a = Code[pc+1]
    b = Code[pc+2]
    if val[a] > val[b] then
        pc += 4
    else
        pc = Code[pc+3]
    end if
end procedure
    
procedure opNOTEQ_IFW()
    a = Code[pc+1]
    b = Code[pc+2]
    if val[a] != val[b] then
        pc += 4
    else
        pc = Code[pc+3]
    end if
end procedure
    
procedure opLESSEQ_IFW()
    a = Code[pc+1]
    b = Code[pc+2]
    if val[a] <= val[b] then
        pc += 4
    else
        pc = Code[pc+3]
    end if
end procedure
    
procedure opGREATEREQ_IFW()
    a = Code[pc+1]
    b = Code[pc+2]
    if val[a] >= val[b] then
        pc += 4
    else
        pc = Code[pc+3]
    end if
end procedure
    
procedure opEQUALS_IFW()
    a = Code[pc+1]
    b = Code[pc+2]
    if val[a] = val[b] then
        pc += 4
    else
        pc = Code[pc+3]
    end if
end procedure
    
procedure opLESS_IFW()
    a = Code[pc+1]
    b = Code[pc+2]
    if val[a] < val[b] then
        pc += 4
    else
        pc = Code[pc+3]
    end if
end procedure
        
    -- other binary ops
    
procedure opMULTIPLY()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] * val[b]
    pc += 4
end procedure
        
procedure opPLUS() 
-- PLUS, PLUS_I
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] + val[b]
    pc += 4
end procedure
    
procedure opMINUS() 
-- MINUS, MINUS_I
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] - val[b]
    pc += 4
end procedure
        
procedure opOR()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] or val[b]
    pc += 4
end procedure
    
procedure opXOR()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] xor val[b]
    pc += 4
end procedure
    
procedure opAND()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] and val[b]
    pc += 4
end procedure
        
procedure opDIVIDE()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    if equal(val[b], 0) then
        RTFatal("attempt to divide by 0")
    end if
    val[target] = val[a] / val[b]
    pc += 4
end procedure

procedure opREMAINDER()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    if equal(val[b], 0) then
        RTFatal("Can't get remainder of a number divided by 0")
    end if
    val[target] = remainder(val[a], val[b])
    pc += 4
end procedure
        
procedure opFLOOR_DIV()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    if equal(val[b], 0) then
        RTFatal("attempt to divide by 0")
    end if
    val[target] = floor(val[a] / val[b])
    pc += 4
end procedure
        
procedure opAND_BITS()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = and_bits(val[a], val[b])
    pc += 4
end procedure
    
procedure opOR_BITS()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = or_bits(val[a], val[b])
    pc += 4
end procedure
    
procedure opXOR_BITS()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = xor_bits(val[a], val[b])
    pc += 4
end procedure
        
procedure opPOWER()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = power(val[a], val[b])
    pc += 4
end procedure
        
procedure opLESS()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] < val[b]
    pc += 4
end procedure
    
procedure opGREATER()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] > val[b]
    pc += 4
end procedure
    
procedure opEQUALS()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] = val[b]
    pc += 4
end procedure
    
procedure opNOTEQ()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] != val[b]
    pc += 4
end procedure
    
procedure opLESSEQ()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] <= val[b]
    pc += 4
end procedure
    
procedure opGREATEREQ()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] >= val[b]
    pc += 4
end procedure
        
-- short-circuit ops 

procedure opSC1_AND()
    a = Code[pc+1]
    b = Code[pc+2]
    if atom(val[a]) then
        if val[a] = 0 then
            val[b] = 0
            pc = Code[pc+3]
            return
        end if
    else
        RTFatal("true/false condition must be an ATOM")
    end if
    pc += 4
end procedure

procedure opSC1_AND_IF() 
-- no need to store 0   
    a = Code[pc+1]
    b = Code[pc+2]
    if atom(val[a]) then
        if val[a] = 0 then
            pc = Code[pc+3]
            return
        end if
    else
        RTFatal("true/false condition must be an ATOM")
    end if
    pc += 4
end procedure

procedure opSC1_OR()
    a = Code[pc+1]
    b = Code[pc+2]
    if atom(val[a]) then
        if val[a] != 0 then
            val[b] = 1
            pc = Code[pc+3]
            return
        end if
    else
        RTFatal("true/false condition must be an ATOM")
    end if
    pc += 4
end procedure
        
procedure opSC1_OR_IF()
-- no need to store 1
    a = Code[pc+1]
    b = Code[pc+2]
    if atom(val[a]) then
        if val[a] != 0 then
            val[b] = 1
            pc = Code[pc+3]
            return
        end if
    else
        RTFatal("true/false condition must be an ATOM")
    end if
    pc += 4
end procedure
        
procedure opSC2_OR() 
-- SC2_OR,  SC2_AND 
-- short-circuit op
    a = Code[pc+1]
    b = Code[pc+2]
    if atom(val[a]) then
        val[b] = val[a] 
    else
        RTFatal("true/false condition must be an ATOM")
    end if
    pc += 3
end procedure

-- for loops 
        
procedure opFOR()  
-- FOR, FOR_I 
-- enter into a for loop    
    integer increment, limit, initial, loopvar, jump
    
    increment = Code[pc+1]
    limit = Code[pc+2]
    initial = Code[pc+3]
    -- ignore current_sub = Code[pc+4] - we don't patch the ENDFOR
    -- so recursion is not a problem
    loopvar = Code[pc+5]
    jump = Code[pc+6]
    
    if sequence(val[initial]) then
        RTFatal("for-loop variable is not an atom")
    end if
    if sequence(val[limit]) then
        RTFatal("for-loop limit is not an atom")
    end if
    if sequence(val[increment]) then
        RTFatal("for-loop increment is not an atom")
    end if
    
    pc += 7 -- to enter into the loop
    
    if val[increment] >= 0 then
        -- going up
        if val[initial] > val[limit] then
            pc = jump -- quit immediately, 0 iterations
        end if
    else
        -- going down
        if val[initial] < val[limit] then
            pc = jump -- quit immediately, 0 iterations
        end if
    end if

    val[loopvar] = val[initial] -- initialize loop var
    
end procedure

procedure opENDFOR_GENERAL() 
-- ENDFOR_INT_UP, ENDFOR_UP, ENDFOR_INT_DOWN1,
-- ENDFOR_INT_DOWN, ENDFOR_DOWN, ENDFOR_GENERAL
-- end of for loop: drop out of the loop, or go back to the top
    integer loopvar
    atom increment, limit, next
    
    limit = val[Code[pc+2]]
    increment = val[Code[pc+4]]
    loopvar = Code[pc+3]
    next = val[loopvar] + increment
    
    if increment >= 0 then
        -- up loop
        if next > limit then
            pc += 5 -- exit loop
        else
            val[loopvar] = next
            pc = Code[pc+1] -- loop again
        end if
    else    
        -- down loop
        if next < limit then
            pc += 5 -- exit loop
        else
            val[loopvar] = next
            pc = Code[pc+1] -- loop again
        end if
    end if
end procedure

procedure opENDFOR_INT_UP1() 
-- ENDFOR_INT_UP1
-- faster: end of for loop with known +1 increment
-- exit or go back to the top
-- (loop var might not be integer, but that doesn't matter here)
    integer loopvar
    atom limit, next
    
    limit = val[Code[pc+2]]
    loopvar = Code[pc+3]
    next = val[loopvar] + 1
    
    -- up loop
    if next > limit then
        pc += 5 -- exit loop
    else
        val[loopvar] = next
        pc = Code[pc+1] -- loop again
    end if
end procedure

function RTLookup(sequence name, integer fileno, symtab_index proc, integer stlen)
-- Look up a name (routine or var) in the symbol table at runtime.
-- The name must have been defined earlier in the source than
-- where we are currently executing. The name may be a simple "name"
-- or "ns:name". Speed is not too critical. This lookup is only used 
-- in interactive trace mode, and in looking up routine id's, 
-- which should normally only be done once for an indirectly-callable 
-- routine.
    symtab_index s, global_found
    sequence ns
    integer colon
    integer ns_file

    colon = find(':', name)
    
    if colon then
        -- look up "ns : name"
        ns = name[1..colon-1]
--PL run on 2.4:
--      name = name[colon+1..$]
        name = name[colon+1..length(name)]
    
    -- trim off any trailing whitespace from ns
--PL run on 2.4:
--      while length(ns) and (ns[$] = ' ' or ns[$] = '\t') do
        while length(ns) and (ns[length(ns)] = ' ' or ns[length(ns)] = '\t') do
--          ns = ns[1..$-1]
            ns = ns[1..length(ns)-1]
        end while
    
        -- trim off any leading whitespace from ns
        while length(ns) and (ns[1] = ' ' or ns[1] = '\t') do
--PL run on 2.4:
--          ns = ns[2..$]
            ns = ns[2..length(ns)]
        end while
    
        if length(ns) = 0 then
            return 0 -- bad syntax
        end if

        -- step 1: look up NAMESPACE symbol 
        s = SymTab[TopLevelSub][S_NEXT]
        while s != 0 and s <= stlen do
            if fileno = SymTab[s][S_FILE_NO] and 
            SymTab[s][S_TOKEN] = NAMESPACE and 
            equal(ns, SymTab[s][S_NAME]) then
                exit
            end if
            s = SymTab[s][S_NEXT]
        end while
    
        if s = 0 then
            return 0 -- couldn't find ns
        end if
    
        ns_file = SymTab[s][S_OBJ]
    
        -- trim off any leading whitespace from name
        while length(name) and (name[1] = ' ' or name[1] = '\t') do
--PL run on 2.4:
--          name = name[2..$]
            name = name[2..length(name)]
        end while
    
        -- step 2: find global name in ns file 
        s = SymTab[TopLevelSub][S_NEXT]
        while s != 0 and s <= stlen do
            if SymTab[s][S_FILE_NO] = ns_file and 
            SymTab[s][S_SCOPE] = SC_GLOBAL and 
            equal(name, SymTab[s][S_NAME]) then
                return s
            end if
            s = SymTab[s][S_NEXT]
        end while
    
        return 0 -- couldn't find name in ns file
    
    else 
        -- look up simple unqualified routine name

        if proc != TopLevelSub then  
            -- inside a routine - check PRIVATEs and LOOP_VARs
            s = SymTab[proc][S_NEXT]
            while s and (SymTab[s][S_SCOPE] = SC_PRIVATE or 
                         SymTab[s][S_SCOPE] = SC_LOOP_VAR) do
                if equal(name, SymTab[s][S_NAME]) then
                    return s           
                end if
                s = SymTab[s][S_NEXT]
            end while
        end if

        -- try to match a LOCAL or GLOBAL routine in the same source file
        s = SymTab[TopLevelSub][S_NEXT]
        while s != 0 and s <= stlen do
            if SymTab[s][S_FILE_NO] = fileno and 
            (SymTab[s][S_SCOPE] = SC_LOCAL or 
             SymTab[s][S_SCOPE] = SC_GLOBAL or 
             (proc = TopLevelSub and SymTab[s][S_SCOPE] = SC_GLOOP_VAR)) and
            equal(name, SymTab[s][S_NAME]) then  
            -- shouldn't really be able to see GLOOP_VARs unless we are
            -- currently inside the loop - only affects interactive var display
                return s
            end if
            s = SymTab[s][S_NEXT]
        end while 
    
        -- try to match a single earlier GLOBAL symbol
        global_found = FALSE
        s = SymTab[TopLevelSub][S_NEXT]
        while s != 0 and s <= stlen do
            if SymTab[s][S_SCOPE] = SC_GLOBAL and 
            equal(name, SymTab[s][S_NAME]) then
                if not global_found then
                    global_found = s
                else
                    return 0 -- 2nd global with same name
                end if
            end if
            s = SymTab[s][S_NEXT]
        end while 
        return global_found
    
    end if
end function

procedure opCALL_PROC() 
-- CALL_PROC, CALL_FUNC - call via routine id
    integer cf, n, arg, p
    symtab_index sub
    sequence private_block
    
    cf = Code[pc] = CALL_FUNC
    
    a = Code[pc+1]  -- routine id
    if val[a] < 0 or val[a] >= length(e_routine) then
        RTFatal("invalid routine id")
    end if
    
    sub = e_routine[val[a]+1]
    b = Code[pc+2]  -- argument list
    
    if cf then
        if SymTab[sub][S_TOKEN] = PROC then
            RTFatal(sprintf("%s() does not return a value", SymTab[sub][S_NAME]))
        end if
    else
        if SymTab[sub][S_TOKEN] != PROC then
            RTFatal(sprintf("the value returned by %s() must be assigned or used",
                            SymTab[sub][S_NAME]))
        end if
    end if
    if atom(val[b]) then
        RTFatal("argument list must be a sequence")
    end if
    
    if SymTab[sub][S_NUM_ARGS] != length(val[b]) then
        RTFatal(sprintf("call to %s() via routine-id should pass %d arguments, not %d",
                        {SymTab[sub][S_NAME], SymTab[sub][S_NUM_ARGS], length(val[b])}))
         
    end if
    
    n = SymTab[sub][S_NUM_ARGS]
    arg = SymTab[sub][S_NEXT]
    
    if SymTab[sub][S_RESIDENT_TASK] != 0 then
    -- save the parameters, privates and temps
    
        -- save and set the args
        private_block = repeat(0, SymTab[sub][S_STACK_SPACE])
        p = 1
        for i = 1 to n do
            private_block[p] = val[arg]
            p += 1
            val[arg] = val[b][i]
            arg = SymTab[arg][S_NEXT]
        end for
    
        -- save the privates
        while arg != 0 and SymTab[arg][S_SCOPE] <= SC_PRIVATE do
            private_block[p] = val[arg]
            p += 1
            val[arg] = NOVALUE -- necessary?
            arg = SymTab[arg][S_NEXT]
        end while
    
        -- save temps
        arg = SymTab[sub][S_TEMPS]
        while arg != 0 do
            private_block[p] = val[arg]
            p += 1
            val[arg] = NOVALUE -- necessary?
            arg = SymTab[arg][S_NEXT]
        end while
    
        -- save this block of private data
        save_private_block(sub, private_block)
    else
        -- routine is not in use, no need to save 
        -- just set the args 
        for i = 1 to n do
            val[arg] = val[b][i]
            arg = SymTab[arg][S_NEXT]
        end for
    end if
    
    SymTab[sub][S_RESIDENT_TASK] = current_task
    
    pc += 3 + cf
    
    call_stack = append(call_stack, pc) 
    call_stack = append(call_stack, sub)
    
    Code = SymTab[sub][S_CODE]
    pc = 1
end procedure
          
procedure opROUTINE_ID()
-- get the routine id for a routine name    
-- routine id's start at 0 (for compatibility with C-coded back-end)
    integer sub, fn, p, stlen
    object name
    
    sub = Code[pc+1]   -- CurrentSub
    stlen = Code[pc+2]  -- s.t. length
    name = val[Code[pc+3]]  -- routine name sequence
    fn = Code[pc+4]    -- file number
    target = Code[pc+5]
    pc += 6
    if atom(name) then
        val[target] = -1
        return
    end if
    p = RTLookup(name, fn, sub, stlen)
    if p = 0 or not find(SymTab[p][S_TOKEN], {PROC, FUNC, TYPE}) then
        val[target] = -1  -- name is not a routine
        return
    end if
    for i = 1 to length(e_routine) do
        if e_routine[i] = p then
            val[target] = i - 1  -- routine was already assigned an id
            return
        end if
    end for 
    e_routine = append(e_routine, p)
    val[target] = length(e_routine) - 1
end procedure
        
procedure opAPPEND()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = append(val[a], val[b])
    pc += 4
end procedure

procedure opPREPEND() 
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = prepend(val[a], val[b])
    pc += 4
end procedure

procedure opCONCAT()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = val[a] & val[b]
    pc += 4
end procedure
        
procedure opCONCAT_N()
-- concatenate 3 or more items
    integer n
    object x
    
    n = Code[pc+1] -- number of items
    -- operands are in reverse order
    x = val[Code[pc+2]] -- last one
    for i = pc+3 to pc+n+1 do
        x = val[Code[i]] & x
    end for
    target = Code[pc+n+2]
    val[target] = x
    pc += n+3
end procedure
        
procedure opREPEAT()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    if not atom(val[b]) then
        RTFatal("repetition count must be an atom")
    end if
    if val[b] < 0 then
        RTFatal("repetition count must not be negative")
    end if
    if val[b] > 1073741823 then
        RTFatal("repetition count is too large")
    end if
    val[target] = repeat(val[a], val[b])
    pc += 4
end procedure

procedure opDATE()
    target = Code[pc+1]
    val[target] = date()
    pc += 2
end procedure

procedure opTIME()
    target = Code[pc+1]
    val[target] = time()
    pc += 2
end procedure

procedure opSPACE_USED() -- RDS DEBUG only
    pc += 2
end procedure

procedure opNOP2()   
-- space filler
    pc+= 2
end procedure

procedure opPOSITION()
    a = Code[pc+1]
    b = Code[pc+2]
    position(val[a], val[b])  -- error checks
    pc += 3
end procedure
        
procedure opEQUAL()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = equal(val[a], val[b])
    pc += 4
end procedure
        
procedure opCOMPARE()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = compare(val[a], val[b])
    pc += 4
end procedure

procedure opFIND()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    if not sequence(val[b]) then
        RTFatal("second argument of find() must be a sequence")
    end if
    val[target] = find(val[a], val[b])
    pc += 4
end procedure

procedure opMATCH()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    if not sequence(val[a]) then
        RTFatal("first argument of match() must be a sequence")
    end if
    if not sequence(val[b]) then
        RTFatal("second argument of match() must be a sequence")
    end if
    if length(val[a]) = 0 then
        RTFatal("first argument of match() must be a non-empty sequence")
    end if
    val[target] = match(val[a], val[b])
    pc += 4
end procedure

procedure opPEEK4U()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = peek4u(val[a])
    pc += 3
end procedure
    
procedure opPEEK4S()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = peek4s(val[a])
    pc += 3
end procedure
    
procedure opPEEK()
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = peek(val[a])
    pc += 3
end procedure

procedure opPOKE()
    a = Code[pc+1]
    b = Code[pc+2]
    poke(val[a], val[b])
    pc += 3
end procedure
    
procedure opPOKE4()
    a = Code[pc+1]
    b = Code[pc+2]
    poke4(val[a], val[b])
    pc += 3
end procedure

procedure opMEM_COPY()
    a = Code[pc+1]
    b = Code[pc+2]
    c = Code[pc+3]
    mem_copy(val[a], val[b], val[c])
    pc += 4
end procedure
        
procedure opMEM_SET()
    a = Code[pc+1]
    b = Code[pc+2]
    c = Code[pc+3]
    mem_set(val[a], val[b], val[c])
    pc += 4
end procedure
        
procedure opPIXEL()
    a = Code[pc+1]
    b = Code[pc+2]
--PL 16/12
--  pixel(val[a], val[b])
    pc += 3
end procedure
        
procedure opGET_PIXEL()
    a = Code[pc+1]
    target = Code[pc+2]
--PL 16/12
--  val[target] = get_pixel(val[a])
    pc += 3
end procedure
      
procedure opCALL()
    a = Code[pc+1]
    call(val[a])
    pc += 2
end procedure

procedure opSYSTEM()
    a = Code[pc+1]
    b = Code[pc+2]
    if atom(val[a]) then
        RTFatal("first argument of system() must be a sequence")
    end if
    if sequence(val[b]) then
        RTFatal("second argument of system() must be an atom")
    end if
    system(val[a], val[b])
    pc += 3
end procedure
        
procedure opSYSTEM_EXEC()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    if atom(val[a]) then
        RTFatal("first argument of system() must be a sequence")
    end if
    if sequence(val[b]) then
        RTFatal("second argument of system() must be an atom")
    end if
    val[target] = system_exec(val[a], val[b])
    pc += 4
end procedure
        
-- I/O routines

procedure opOPEN()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    
    if atom(val[b]) or length(val[b]) > 2 then
        RTFatal("invalid open mode")
    end if     
    if atom(val[a]) then
        RTFatal("device or file name must be a sequence")
    end if         
    val[target] = open(val[a], val[b])
    pc += 4
end procedure

procedure opCLOSE()
    a = Code[pc+1]
    close(val[a])
    pc += 2
end procedure
          
procedure opABORT()
    abort(val[Code[pc+1]])
end procedure

procedure opGETC()  -- read a character from a file 
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = getc(val[a])
    pc += 3
end procedure
 
procedure opGETS()  
-- read a line from a file
    a = Code[pc+1]
    target = Code[pc+2]
    val[target] = gets(val[a])
    pc += 3
end procedure

procedure opGET_KEY() 
-- read an immediate key (if any) from the keyboard 
-- or return -1 
    target = Code[pc+1]
    val[target] = get_key()
    pc += 2
end procedure

procedure opCLEAR_SCREEN()
    clear_screen()
    pc += 1
end procedure

procedure opPUTS()
    a = Code[pc+1]
    b = Code[pc+2]
    puts(val[a], val[b])
    pc += 3
end procedure

procedure opQPRINT()
-- Code[pc+1] not used
    a = Code[pc+2]
    ? val[a]
    pc += 3
end procedure
    
procedure opPRINT()
    a = Code[pc+1]
    b = Code[pc+2]
    print(val[a], val[b])
    pc += 3
end procedure

procedure opPRINTF()
    -- printf 
    a = Code[pc+1]
    b = Code[pc+2]
    c = Code[pc+3]
    printf(val[a], val[b], val[c])
    pc += 4
end procedure

procedure opSPRINTF()
    a = Code[pc+1]
    b = Code[pc+2]
    target = Code[pc+3]
    val[target] = sprintf(val[a], val[b])
    pc += 4
end procedure

procedure opCOMMAND_LINE()
    sequence cmd
    
    target = Code[pc+1]
    cmd = command_line()
    -- drop second word for better compatibility
    if length(cmd) > 2 then
--PL run on 2.4:
--      cmd = {cmd[1]} & cmd[3..$]
        cmd = {cmd[1]} & cmd[3..length(cmd)]
    end if
    val[target] = cmd
    pc += 2
end procedure

procedure opGETENV()
    a = Code[pc+1]
    target = Code[pc+2]
    if atom(val[a]) then
        RTFatal("argument to getenv must be a sequence")
    end if
    val[target] = getenv(val[a])
    pc += 3
end procedure

procedure opC_PROC()
    symtab_index sub
    
    a = Code[pc+1]
    b = Code[pc+2]
    sub = Code[pc+3]
    c_proc(val[a], val[b])  -- callback could happen here
    restore_privates(sub)
    pc += 4
end procedure
      
procedure opC_FUNC()
    integer target
    symtab_index sub
    object temp
    
    a = Code[pc+1]
    b = Code[pc+2]
    sub = Code[pc+3]
    target = Code[pc+4]
    temp = c_func(val[a], val[b])  -- callback could happen here
    restore_privates(sub)
    val[target] = temp
    pc += 5
end procedure

procedure opTRACE()
    TraceOn = val[Code[pc+1]]
    pc += 2  -- turn on/off tracing
end procedure
        
-- other tracing/profiling ops - ignored
procedure opPROFILE() 
-- PROFILE, DISPLAY_VAR, ERASE_PRIVATE_NAMES, ERASE_SYMBOL
-- ops not implemented, ignore
    pc += 2
end procedure
        
procedure opUPDATE_GLOBALS()
-- for interactive trace
-- not implemented, ignore
    pc += 1
end procedure

sequence operation 

procedure do_exec()
-- execute IL code, starting at pc 
    integer op

    keep_running = TRUE
    while keep_running do 
        op = Code[pc]
        call_proc(operation[op], {}) -- opcodes start at 1
    end while
    keep_running = TRUE -- so higher-level do_exec() will keep running
end procedure

--            Call-backs
--
-- This uses Intel machine code developed by Matthew Lewis.
-- It allows an "infinite" number of call-back routines to be
-- created dynamically.
--
-- Note: If you happen to port Euphoria to a non-Intel machine,
-- or a system with a different calling convention,
-- Matt's machine-code call-backs won't work, but you
-- can easily create call-back routines in Euphoria, something like:
--
--    function callback_001(atom a, atom b, atom c, atom d)
--        return general_callback(call_backs[1], {a,b,c,d})
--    end function
--
-- You can get the address of the above routine using:
--
--    addr = call_back(routine_id("call_back_001"))
--
-- By creating call_back_001, call_back_002 ... you can create
-- as many call-back routines as you like, in a portable way.
-- The only problem is that you can't dynamically create new
-- call_back routines at run-time with this method. Most programs that
-- use call-backs only need a small number of them (less than 10). 
-- 4-argument call-backs are quite common in Windows, so you might
-- need several of them on that system.


function general_callback(sequence routine, sequence args)
-- call the user's function from an external source 
-- (interface for Euphoria-coded call-backs)

    val[t_id] = routine[C_USER_ROUTINE]
    val[t_arglist] = args
    
    SymTab[call_back_routine][S_RESIDENT_TASK] = current_task
    
    -- create a stack frame
    call_stack = append(call_stack, pc)
    call_stack = append(call_stack, call_back_routine)

    Code = call_back_code 
    pc = 1 
     
    do_exec()
    
    -- remove the stack frame
--PL run on 2.4:
--  pc = call_stack[$-1]
    pc = call_stack[length(call_stack)-1]
--  call_stack = call_stack[1..$-2]
    call_stack = call_stack[1..length(call_stack)-2]
    
    -- restore
--  Code = SymTab[call_stack[$]][S_CODE]
    Code = SymTab[call_stack[length(call_stack)]][S_CODE]
    
    return val[t_return_val]
end function

forward_general_callback = routine_id("general_callback")

function machine_callback(atom cbx, atom ptr)
-- call the user's function from an external source 
-- (interface for machine-coded call-backs)
    sequence routine, args
    
    routine = call_backs[cbx]
    args = peek4u(ptr & call_backs[cbx][C_NUM_ARGS])
    
    return general_callback(routine, args)
end function

call_backs = {}

constant cb_std = {
                   #89,#E0,             --    0: mov eax, esp
                   #83,#C0,#04,         --    2: add eax, 4
                   #50,                 --    5: push eax
                   #68,#00,#00,#00,#00, --    6: push dword rid (7)
                   #FF,#15,#00,#00,#00,#00,--     B: call near dword ptr [pfunc] (13)
                   #C2,#00,#00,         --   11: ret bytes (18)
                   #00,#00,#00,#00},        --   14: function pointer (20)

cb_cdecl= {
           #89,#E0,             --    0: mov eax, esp
           #83,#C0,#04,         --    2: add eax, 4
           #50,                 --    5: push eax
           #68,#00,#00,#00,#00, --    6: push dword rid (7)
           #FF,#15,#00,#00,#00,#00,--     B: call near dword ptr [pfunc] (13)
           #83, #C4, #08,           --   11: sub esp, 8
           #C3,#00,#00,         --   14: ret bytes 
           #00,#00,#00,#00} --   17: function pointer (23)


procedure do_callback(integer b)
-- handle callback()
    symtab_index r
    atom asm
    integer id, convention
    object x
    
    -- val[b] is:  routine id or {'+', routine_id}
    x = val[b]
    if atom(x) then
        id = x
        convention = 0
    else
        id = x[2]
        convention = x[1]
    end if
    
    if id < 0 or id >= length(e_routine) then
        RTFatal("Invalid routine id")
    end if
    
    r = e_routine[id+1]

    if platform() = WIN32 and convention = 0 then
        -- stdcall
        asm = allocate( length(cb_std) )
        poke( asm, cb_std ) 
        poke4( asm + 7, length(call_backs) + 1 )
        poke4( asm + 13, asm + 20 )
        poke( asm + 18, SymTab[r][S_NUM_ARGS] * 4 )
        poke4( asm + 20, call_back( routine_id("machine_callback") ) )
    
    else
        -- cdecl
        asm = allocate( length(cb_cdecl) )  
        poke( asm, cb_cdecl )
        poke4( asm + 7, length(call_backs) + 1 )
        poke4( asm + 13, asm + 23 )
        poke4( asm + 23, call_back( '+' & routine_id("machine_callback") ) )
    end if

    val[target] = asm
    call_backs = append( call_backs, { r, id, SymTab[r][S_NUM_ARGS] })
end procedure        

procedure do_crash_routine(integer b)
-- add a crash routine to the list
    object x
    
    x = val[b]
    if atom(x) and x >= 0 and x < length(e_routine) then
        crash_list = append(crash_list, x)
    else
        RTFatal("crash routine requires a valid routine id")
    end if
end procedure

procedure opMACHINE_FUNC()
    a = Code[pc+1]
    b = Code[pc+2] 
    target = Code[pc+3]
    pc += 4
    -- handle CALL_BACK specially
    if val[a] = M_CALL_BACK then
        -- routine id's must be handled at our level
        do_callback(b)  
    else
        val[target] = machine_func(val[a], val[b])
    end if
end procedure

procedure opMACHINE_PROC()
    object v
    
    a = Code[pc+1]
    b = Code[pc+2]
    v = val[a]
    -- some things must be handled at our level, not a lower level
    if v = M_CRASH_ROUTINE then
        -- routine id's must be handled at our level
        do_crash_routine(b) 
    
    elsif v = M_CRASH_MESSAGE then
        crash_msg = val[b]
    
    elsif v = M_CRASH_FILE and sequence(val[b]) then
        err_file_name = val[b]  
    
    elsif EDOS and v = M_TICK_RATE and val[b] > 18 and val[b] < 10000 then
        clock_period = 1 / val[b]
        machine_proc(v, val[b]) 
    
    else
        machine_proc(v, val[b]) 
    end if
    pc += 3
end procedure
     
global procedure InitBackEnd()--integer ignore)
-- initialize Interpreter
-- Some ops are treated exactly the same as other ops.
-- In the hand-coded C back-end, they might be treated differently
-- for extra performance.
    sequence name
    
    -- set up val
    val = repeat(0, length(SymTab))
    for i = 1 to length(SymTab) do
        val[i] = SymTab[i][S_OBJ] -- might be NOVALUE
    end for
    
    -- set up operations
    operation = repeat(-1, length(opnames))
    
    for i = 1 to length(opnames) do
        name = opnames[i]
        -- some similar ops are handled by a common routine
        if find(name, {"RHS_SUBS_CHECK", "RHS_SUBS_I"}) then
            name = "RHS_SUBS"
        elsif find(name, {"ASSIGN_SUBS_CHECK", "ASSIGN_SUBS_I"}) then
            name = "ASSIGN_SUBS"
        elsif equal(name, "ASSIGN_I") then
            name = "ASSIGN"
        elsif find(name, {"EXIT", "ENDWHILE"}) then
            name = "ELSE"
        elsif equal(name, "PLUS1_I") then
            name = "PLUS1"      
        elsif equal(name, "PRIVATE_INIT_CHECK") then
            name = "GLOBAL_INIT_CHECK"
        elsif equal(name, "PLUS_I") then
            name = "PLUS"
        elsif equal(name, "MINUS_I") then
            name = "MINUS"
        elsif equal(name, "FOR_I") then
            name = "FOR"
        elsif find(name, {"ENDFOR_UP", "ENDFOR_DOWN", 
                          "ENDFOR_INT_UP", "ENDFOR_INT_DOWN",
                          "ENDFOR_INT_DOWN1"}) then
            name = "ENDFOR_GENERAL"
        elsif equal(name, "CALL_FUNC") then
            name = "CALL_PROC"
        elsif find(name, {"DISPLAY_VAR", "ERASE_PRIVATE_NAMES", 
                          "ERASE_SYMBOL"}) then
            name = "PROFILE"
        elsif equal(name, "SC2_AND") then
            name = "SC2_OR"
        elsif find(name, {"SC2_NULL", "ASSIGN_SUBS2", "PLATFORM",
                          "END_PARAM_CHECK", "NOPWHILE", "NOP1"}) then 
            -- never emitted
            name = "NOP2" 
        elsif equal(name, "GREATER_IFW_I") then
            name = "GREATER_IFW"
        elsif equal(name, "LESS_IFW_I") then
            name = "LESS_IFW"
        elsif equal(name, "EQUALS_IFW_I") then
            name = "EQUALS_IFW"
        elsif equal(name, "NOTEQ_IFW_I") then
            name = "NOTEQ_IFW"
        elsif equal(name, "GREATEREQ_IFW_I") then
            name = "GREATEREQ_IFW"
        elsif equal(name, "LESSEQ_IFW_I") then
            name = "LESSEQ_IFW"
        end if
    
        operation[i] = routine_id("op" & name)
        if operation[i] = -1 then
            RTInternal("no routine id for op" & name)
        end if
    end for
end procedure

global procedure Execute(symtab_index proc, integer start_index)
-- top level executor 
    current_task = 1
    call_stack = {proc}
    pc = start_index
    do_exec()
end procedure

Execute_id = routine_id("Execute")

without warning
global procedure BackEnd()--atom ignore)
-- The Interpreter back end
    Execute(TopLevelSub, 1)
end procedure

-- dummy routines, not used
global procedure OutputIL()
end procedure

global function extract_options(sequence s)
-- dummy routine, not used by interpreter
    return s
end function

   
-- main program:
--include main.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- Euphoria 3.0
-- Front End - main routine 

include file.e
--include get.e
--include pathopen.e
-- (c) Copyright 2006 Rapid Deployment Software - See License.txt
--
-- open a file by searching the user's PATH

global function e_path_open(sequence name, sequence mode)
-- follow the search path, if necessary to open the main file
    integer src_file
    object path
    sequence full_name
    integer p
       
    -- try opening directly
    src_file = open(name, mode)
    if src_file != -1 then
        return src_file        
    end if
    
    -- make sure that name is a simple name without '\' in it
    for i = 1 to length(SLASH_CHARS) do
        if find(SLASH_CHARS[i], name) then
            return -1
        end if
    end for
    
    path = getenv("PATH")
    if atom(path) then
        return -1
    end if
    
    full_name = ""
    p = 1
    path &= PATH_SEPARATOR -- add end marker
    
    while p <= length(path) do
        if (length(full_name) = 0 and path[p] = ' ') or path[p] = '\t' then
            -- skip

        elsif path[p] = PATH_SEPARATOR then
            -- end of a directory
            if length(full_name) then
--PL run on 2.4:
--              while length(full_name) and full_name[$] = ' ' do
                while length(full_name) and full_name[length(full_name)] = ' ' do
--                  full_name = full_name[1..$-1]
                    full_name = full_name[1..length(full_name)-1]
                end while
                src_file = open(full_name & SLASH & name, mode)
                if src_file != -1 then
                    file_name[1] = full_name & SLASH & name          
                    return src_file
                else 
                    full_name = ""
                end if
            end if
        else 
            full_name &= path[p] -- build up the directory name
        end if
        
        p += 1
    end while
    return -1
end function


function ProcessOptions()
-- record command line options, return source file number
integer src_file
boolean dot_found
sequence src_name, raw_name
    
    if Argc >= 3 then
        src_name = Argv[3]
    else 
        if 1 then
        --  src_name = "C:\\Program Files\\Phix\\bench\\b03fori.exw"
            src_name = "C:\\Program Files (x86)\\Phix\\bench\\arwen.ew"
        else
            if INTERPRET and not BIND then
                screen_output(STDERR, "Euphoria Interpreter " & 
                              INTERPRETER_VERSION & " ")
       
            elsif TRANSLATE then
                screen_output(STDERR, "Euphoria to C Translator " & 
                              TRANSLATOR_VERSION & " ")
            elsif BIND then
                screen_output(STDERR, "Euphoria Binder " & 
                              INTERPRETER_VERSION & " ")
            end if

            if ELINUX then
                if BIND then
                    screen_output(STDERR, "for Linux/FreeBSD.\n")
                else    
                    if EBSD then
                        screen_output(STDERR, "for FreeBSD.\n")
                    else
                        screen_output(STDERR, "for Linux.\n")
                    end if
                end if
            
            else
                if BIND then
                    screen_output(STDERR, "for DOS/Windows.\n")
                elsif EWINDOWS then
                    screen_output(STDERR, "for 32-bit Windows.\n")
                else
                    screen_output(STDERR, "for 32-bit DOS.\n")
                end if
            end if

            screen_output(STDERR, "Copyright (c) Rapid Deployment Software 2006 \n")

            screen_output(STDERR, 
                          "See http://www.RapidEuphoria.com/License.txt \n")

            if BIND then
                screen_output(STDERR, "\nfile name to bind/shroud? ")
        
            elsif INTERPRET then
                screen_output(STDERR, "\nfile name to execute? ")

            elsif TRANSLATE then
                screen_output(STDERR, "\nfile name to translate to C? ")
        
            end if

            src_name = gets(STDIN)
        
            screen_output(STDERR, "\n")
    
            -- remove leading blanks
            while length(src_name) and find(src_name[1], " \t\n") do
--PL run on 2.4:
--              src_name = src_name[2..$]
                src_name = src_name[2..length(src_name)]
            end while
        
            if length(src_name) = 0 then
                Cleanup(1)
            end if
        
            -- remove trailing blanks
--PL run on 2.4:
--          while length(src_name) and find(src_name[$], " \t\n") do
            while length(src_name) and find(src_name[length(src_name)], " \t\n") do
--          src_name = src_name[1..$-1]
                src_name = src_name[1..length(src_name)-1]
            end while
        
            -- add src_name as 2nd arg for command_line()
            Argc = 2
            Argv = {Argv[1], src_name}
        
            file_name_entered = src_name -- passed to back-end for command_line()
        
        -- .ex or .exw might be added to src_name below
        end if
    end if
    
    -- check src_name for '.' */
    dot_found = FALSE
    for p = 1 to length(src_name) do
        if src_name[p] = '.' then
            dot_found = TRUE
        elsif find(src_name[p], SLASH_CHARS) then
            dot_found = FALSE
        end if
    end for 
    
    raw_name = src_name
    
    if not dot_found then
        -- no dot found */
        if ELINUX then
            src_name &= ".exu"
        
        elsif BIND then
            if w32 then
                src_name &= ".exw"
            else    
                src_name &= ".ex"
            end if
        
        else    
            if EWINDOWS then
                src_name &= ".exw"
            else
                src_name &= ".ex"
            end if
        end if
    end if

    file_name = append(file_name, src_name)
    src_file = e_path_open(src_name, "r")

    if ELINUX then
        if src_file = -1 then
            -- do this especially so #! will work on Linux without .exu extension 
            src_file = open(raw_name, "r")      
            if src_file != -1 then
                src_name = raw_name
            end if
        end if
    end if  
    return src_file
end function

function full_path(sequence filename)
-- return the full path for a file
    integer p
    p = length(filename)
    while p >= 1 do
        if find(filename[p], SLASH_CHARS) then
            return filename[1..p]
        end if
        p -= 1
    end while
    return '.' & SLASH  
end function

procedure main()
-- Main routine 
    integer argc
    sequence argv
    
    -- we have our own, possibly different, idea of argc and argv
    argv = command_line()

    if BIND then
        argv = extract_options(argv)
    end if

    argc = length(argv)  

    Argv = argv
    Argc = argc
    
    eudir = getenv("EUDIR")
    if atom(eudir) then
        if ELINUX then
            -- should check search PATH for euphoria/bin ?
            eudir = getenv("HOME")
            if atom(eudir) then
                eudir = "euphoria"  
            else 
                eudir = eudir & "/euphoria"
            end if
        else
            eudir = "\\EUPHORIA"
        end if

    else
        -- This is a special RDS hack because the RapidEuphoria shared 
        -- host machine does not provide enough memory to complete a
        -- normal build.
        mybsd = match("/usr231/home/r/h/rhc", eudir) > 0 --RapidEuphoria.com

    end if
    TempErrName = "ex.err"           

    if TRANSLATE then
        InitBackEnd()--0)
    end if
    
    src_file = ProcessOptions()

    if src_file = -1 then
        -- too early for normal error processing
        screen_output(STDERR, sprintf("Can't open %s\n", {file_name[1]}))
        if BIND or EWINDOWS or ELINUX then
            screen_output(STDERR, "\nPress Enter\n")
            if getc(0) then
            end if
        end if
        Cleanup(1)
    end if
    
    main_path = full_path(file_name[1])  

    if TRANSLATE then
        InitBackEnd()--1)
    end if

    InitGlobals()

    InitSymTab()
    InitEmit()
    InitParser()
    InitLex()
    read_line()
    parser()

    -- we've parsed successfully
    -- now run the appropriate back-end 
    if TRANSLATE then
        BackEnd()--0) -- translate IL to C
    
    elsif BIND then
        OutputIL()
    
    elsif INTERPRET then
        InitBackEnd()--0)
        BackEnd()--0) -- execute IL using Euphoria-coded back-end
    end if

    Cleanup(0) -- does warnings
end procedure

main()

