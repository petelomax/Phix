<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Callbacks</h1>
      <div id="mainSection">
        Callbacks are used by the application to receive notifications from the system that the user or the system itself has interacted with the user interface of the application. 
        <br>
        <br>
        On the other hand attributes are used by the application to communicate with the user interface system.
        <br>
        <br>
        Even though callbacks have different purposes from attributes, they are also associated to an element by means of an name. 
        <br>
        <br>
        The <b>OLD</b> method to associate a function to a callback, the application must employ the <a href="IupSetAttribute.htm">IupSetAttribute</a> function, 
        linking the action to a name (passed as a string). <br>
        From this point on, this name will refer to a callback. By means of function <a href="IupSetGlobalFunction.htm">IupSetFunction</a> (follow that link for an
        explanation of why the following call to it is syntax-coloured red), the user connects this name to the callback. For example: 
<!--eucode>
function myButton_action(Ihandle self)
...
IupSetAttribute(myButton, "ACTION", "my_button_action");
IupSetFunction("my_button_action", Icallback("myButton_action")
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">function</font><font color="#000000"> myButton_action</font><font color="#0000FF">(</font><font color="#5E005E">Ihandle</font><font color="#000000"> self</font><font color="#0000FF">)
...
</font><font color="#5E005E">IupSetAttribute</font><font color="#0000FF">(</font><font color="#000000">myButton</font><font color="#0000FF">,</font><font color="#008000"> "ACTION"</font><font color="#0000FF">,</font><font color="#008000"> "my_button_action"</font><font color="#0000FF">);
</font><font color="#FF0000">IupSetFunction</font><font color="#0000FF">(</font><font color="#008000">"my_button_action"</font><font color="#0000FF">,</font><font color="#5E005E"> Icallback</font><font color="#800000">(</font><font color="#008000">"myButton_action"</font><font color="#800000">)</font>
</pre>
        In the <b>NEW</b> method, the application does not needs a global name, it directly sets the callback using the attribute name using 
        <a href="IupSetCallback.htm">IupSetCallback</a>. For example:
<!--eucode>
function myButton_action(Ihandle self)
...
IupSetCallback(myButton, "ACTION", Icallback("myButton_action"))
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">function</font><font color="#000000"> myButton_action</font><font color="#0000FF">(</font><font color="#5E005E">Ihandle</font><font color="#000000"> self</font><font color="#0000FF">)
...
</font><font color="#5E005E">IupSetCallback</font><font color="#0000FF">(</font><font color="#000000">myButton</font><font color="#0000FF">,</font><font color="#008000"> "ACTION"</font><font color="#0000FF">,</font><font color="#5E005E"> Icallback</font><font color="#800000">(</font><font color="#008000">"myButton_action"</font><font color="#800000">)</font><font color="#0000FF">)</font>
</pre>
        The new method is more efficient and more secure, because there is no risk of a name conflict. <br>
        Generally you should replace <a href="IupSetGlobalFunction.htm">IupSetFunction</a> by <a href="IupSetCallback.htm">IupSetCallback</a>.
        <br>
        <br>
        Although enabled in old versions, callbacks do NOT have inheritance like attributes.
        <br>
        <br>
        All callbacks receive at least the element which activated the action as a parameter (self). 
        <br>
        <a name=IUP_DEFAULT></a>
        <a name=IUP_CLOSE></a>
        <a name=IUP_IGNORE></a>
        <a name=IUP_CONTINUE></a>
        <br>
        The callbacks implemented in the application must return one of the following values:
        <ul>
        <li>IUP_DEFAULT: Proceeds normally with user interaction. In case other return values do not apply, the callback should return this value. </li>
        <li>IUP_CLOSE: Call <a href="IupExitLoop.htm">IupExitLoop</a> after return. 
                        Depending on the state of the application it will close all windows and exit the application. Applies only to some actions. </li>
        <li>IUP_IGNORE: Makes the native system ignore that callback action. Applies only to some actions. </li>
        <li>IUP_CONTINUE: Makes the element to ignore the callback and pass the treatment of the execution to the parent element. Applies only to some actions. </li>
        </ul>
        Only some callbacks support the last 3 return values. Check each callback documentation. When nothing is documented then only IUP_DEFAULT is supported.
        <br>
        <br>
        Note: Avoid using IUP_IGNORE (and IUP_CLOSE) unless it is specifically documented for that callback. <br>
        For example, it is and always was the documented behaviour for an IDLE_ACTION callback to be removed when it returns IUP_IGNORE.<br>
        It was not originally documented, but has since been noted, that if an <a href="IupButton.htm">IupButton</a> ACTION callback returns IUP_IGNORE, 
        it likewise removes the callback, and in that way effectively disables the button.
        <br>
        <br>
        An important detail when using callbacks is that they are only called when the user actually executes an action over an element. <br>
        A callback is not called when the programmer sets a value via <a href="IupSetAttribute.htm">IupSetAttribute</a>.<br>
        For instance: when the programmer changes a selected item on a list, no callback is invoked.
        <br>
        <br>
        The order of callback calling is system dependent. <br>
        For instance, the <a href="callbacks.htm#RESIZE_CB">RESIZE_CB</a> and the SHOW_CB are called in different order in Win32 and in X-Windows when the dialog is shown for the first time.
        <br>
        <br>
        As well as its normal duty of verifying parameters, the <a href="Icallback.htm">cbfunc</a> type can be used to declare variables suitable for storing callbacks.<br>
        The C header file "iupcbs.h" lists some 50 different typedefs for callbacks (IFxxx/sIFxxx/dIFxxx). <br>
        In Phix you can always get by with "atom" for each parameter, if need be.
        <br>
        <br>
        The following callbacks are common to several controls/interface elements:
       <br>
       <br>
       <table>
        <col style="width: 5%"/>
        <tr>
         <td valign=top>
          ACTION
         </td>
         <td>
            While common to several elements, the callback parameters vary - see specific elements for details.
            <br>
              <a name=BUTTON_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          BUTTON_CB
         </td>
         <td>
            Action generated when any mouse button is pressed or released.
            <br>
            <br>
            function button_cb(Ihandle ih, integer button, integer pressed, integer x, integer y, atom pStatus)<br>
            ih: identifies the element that activated the event.<br>
            button: identifies the activated mouse button:<br>
            <br>
            IUP_BUTTON1 - left mouse button (button 1);<br>
            IUP_BUTTON2 - middle mouse button (button 2);<br>
            IUP_BUTTON3 - right mouse button (button 3).<br>
            <br>
            pressed: indicates the state of the button:<br>
            <br>
            0 - mouse button was released;<br>
            1 - mouse button was pressed.<br>
            <br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of the mouse buttons and some keyboard keys at the moment the event is generated (a char*). <br>
            <br>
            Use the following routines on pStatus:
            <br>
            iup_isshift(pStatus)<br>
            iup_iscontrol(pStatus)<br>
            iup_isbutton1(pStatus)<br>
            iup_isbutton2(pStatus)<br>
            iup_isbutton3(pStatus)<br>
            iup_isbutton4(pStatus)<br>
            iup_isbutton5(pStatus)<br>
            iup_isdouble(pStatus)<br>
            iup_isalt(pStatus)<br>
            iup_issys(pStatus)<br>
            <br>
            They return 1 if the respective key or button is pressed, and 0 otherwise.
            <br>
            <br>
            Returns: IUP_CLOSE will be processed. On some controls if IUP_IGNORE is returned the action is ignored (this is system dependent).
            <br>
            <br>
            Notes<br>
            This callback can be used to customize a button behavior. For a standard button behavior use the ACTION callback of the <a href="IupButton.htm">IupButton</a>.
            <br>
            <br>
            For a single click the callback is called twice, one for pressed=1 and one for pressed=0. <br>
            The ACTION callback is only invoked after both calls.<br>
            In Windows, if a dialog is shown or popup in any situation there could be unpredictable results because the native system still has processing to be done even after the callback is called.
            <br>
            <br>
            A double click is preceded by two single clicks, one for pressed=1 and one for pressed=0, and followed by a pressed=0, all three without the double click flag set. <br>
            In GTK, it is preceded by an additional two single clicks sequence. For example, for one double click all the following calls are made:
 <pre>
BUTTON_CB(but=1 (1), x=154, y=83 [  1       ])
BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])
    BUTTON_CB(but=1 (1), x=154, y=83 [  1       ])     (in GTK only)
    BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])     (in GTK only)
BUTTON_CB(but=1 (1), x=154, y=83 [  1  D    ])
BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])
 </pre>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupButton.htm">IupButton</a>, <a href="IupText.htm">IupText</a>, 
                     <a href="IupList.htm">IupList</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>
            <br>
              <a name=CLOSE_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          CLOSE_CB
         </td>
         <td>
            Called just before a dialog is closed when the user clicks the close button of the title bar or an equivalent action.
            <br>
            <br>
            function close_cb(Ihandle ih)<br>
            ih: identifies the element that activated the event.
            <br>
            <br>
            Returns: if IUP_IGNORE, it prevents the dialog from being closed. 
            If you destroy the dialog in this callback, you must return IUP_IGNORE. IUP_CLOSE will be processed.
            <br>
            <br>
            Affects: <a href="IupDialog.htm">IupDialog</a>
            <br>
              <a name=DESTROY_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          DESTROY_CB
         </td>
         <td>
            Called right before an element is destroyed.
            <br>
            <br>
            function destroy_cb(Ihandle ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            If the dialog is visible then it is hidden before it is destroyed. The callback will be called right after it is hidden.
            <br>
            <br>
            The callback will be called before all other destroy procedures - for instance, if the element has children then it is called before the children are destroyed. 
            <br>
            <br>
            For language binding implementations use the callback name "LDESTROY_CB" to release memory allocated by the binding for the element. 
            Also the callback will be called before the language callback.
            <br>
            <br>
            Affects: All
            <br>
              <a name=ENTERWINDOW_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          ENTERWINDOW_CB
         </td>
         <td>
            Action generated when the mouse enters the native element. 
            <br>
            <br>
            function enterwindow_cb(Ihandle ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Notes<br>
            When the cursor is moved from one element to another, the call order in all platforms will be first the 
            <a href="callbacks.htm#LEAVEWINDOW_CB">LEAVEWINDOW_CB</a> callback of the old control followed by the 
            ENTERWINDOW_CB callback of the new control.
            <br>
            <br>
            Affects: All controls with user interaction.
            <br>
            <br>
            See Also: <a href="callbacks.htm#LEAVEWINDOW_CB">LEAVEWINDOW_CB</a>
            <br>
              <a name=GETFOCUS_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          GETFOCUS_CB
         </td>
         <td>
            Action generated when an element is given keyboard focus. <br>
            This callback is called after the <a href="callbacks.htm#KILLFOCUS_CB">KILLFOCUS_CB</a> of the element that loosed the focus. <br>
            The <a href="IupGetFocus.htm">IupGetFocus</a> function during the callback returns the element that lost the focus.
            <br>
            function getfocus_cb(Ihandle ih)
            <br>
            <br>
            ih: identifier of the element that received keyboard focus.
            <br>
            <br>
            Affects: All elements with user interaction, except menus.
            <br>
            <br>
            See Also: <a href="callbacks.htm#KILLFOCUS_CB">KILLFOCUS_CB</a>, <a href="IupGetFocus.htm">IupGetFocus</a>, <a href="IupSetFocus.htm">IupSetFocus</a> 
            <br>
              <a name=HELP_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          HELP_CB
         </td>
         <td>
            Action generated when the user presses F1 at a control. <br>
            In Motif is also activated by the Help button in some workstations keyboard.
            <br>
            <br>
            function help_cb(Ihandle ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Returns: IUP_CLOSE will be processed.
            <br>
            <br>
            Affects: All elements with user interaction.
            <br>
              <a name=IDLE_ACTION></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          IDLE_ACTION
         </td>
         <td>
            Predefined IUP action, generated when there are no events or messages to be processed. Often used to perform background operations.
            <br>
            <br>
            function idle_action()<br>
            Returns: if IUP_CLOSE is returned the current loop will be closed and the callback will be removed. <br>
            If IUP_IGNORE is returned the callback is removed and normal processing continues.
            <br>
            <br>
            Notes<br>
            The Idle callback will be called whenever there are no messages left to be processed. <br>
            But this occurs more frequent than expected, for example if you move the mouse over the application the idle callback will be called
            many times because the mouse move message is processed so fast that the Idle will be called before another mouse move message is schedule to processing.
            <br>
            <br>
            So this callback changes the message loop to a more CPU consuming one. <br>
            It is important it be set NULL when not used, otherwise the application consumes CPU even if the callback is doing nothing.
            <br>
            <br>
            It can only be set using <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>(name, func).
            <br>
            <br>
            Long Time Operations<br>
            If you create a loop or an operation that takes a long time to complete inside a callback of your application then 
            the user interface message loop processing is interrupted until the callback returns, so the user can not click on 
            any control of the application. But there are ways to handle that:
            <br>
            <br>
            call <a href="IupLoopStep.htm">IupLoopStep</a> or <a href="IupFlush.htm">IupFlush</a> inside the application callback when it is performing long time operations. <br>
            This will allow the user to click on a cancel button for instance, because the user interface message loop will be processed.
            <br>
            <br>
            split the operation in several parts that are processed by the Idle function when no messages are left to be processed for the user interface message loop. <br>
            This will make a heavy use of the CPU, even if the callback is doing nothing. 
            <br>
            <br>
            split the operation in several parts but use a Timer to process each part. <br>
            If you just want to do something simple as a background redraw of an <a href="IupCanvas.htm">IupCanvas</a>, 
            then a better idea is to handle the "idle" state yourself. <br>
            For example, register a timer for a small time like 500ms, and reset the timer in all the mouse and keyboard callbacks of the <a href="IupCanvas.htm">IupCanvas</a>. <br>
            If the timer is trigged then you are in idle state. If the <a href="IupCanvas.htm">IupCanvas</a> loses its focus then stop the timer.
            <br>
            <br>
            See Also: <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>, <a href="IupTimer.htm">IupTimer</a>.
            <br>
              <a name=K_ANY></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          K_ANY
         </td>
         <td>
            Action generated when a keyboard event occurs.
            <br>
            <br>
            function key_cb(Ihandle ih, atom c)
            <br>
            <br>
            ih: the element that activated the event.<br>
            c: the typed key. Possible values are listed below.
            <br>
            <br>
            IUP defines several hundred key constants, most of which are available in pGUI:<br>
            K_ESC, K_CR (or '\r'), K_LF (or '\n'), K_BS (or '\b'), K_TAB (or '\t'), K_INS, K_DEL, 
            K_HOME, K_UP, K_PGUP, K_LEFT, K_MIDDLE, K_RIGHT, K_END, K_DOWN, K_PGDN, K_PAUSE, K_Print, K_Menu, 
            K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8, K_F9, K_F10, K_F11, K_F12,
            K_LSHIFT, K_RSHIFT, K_LCTRL, K_RCTRL, K_LALT, K_RALT, K_SCROLL, K_NUM, and K_CAPS.
            <br>
            <br>
            Other standard key identifiers include:<br>
            K_SP (' '), K_exclam ('!'), K_quotedbl ('\"'), K_numbersign ('#'), K_dollar ('$'), K_percent ('%'),
            K_ampersand ('&'), K_apostrophe '\'', K_parentleft ('('), K_parentright (')'), K_asterisk ('*'), K_plus ('+'),
            K_comma (','), K_minus ('-'), K_period ('.'), K_slash ('/'), K_0..K_9 ('0'..'9'), K_colon (':'), K_semicolon (';'),
            K_less ('&lt;'), K_equal ('='), K_greater ('&gt;'), K_question ('?'), K_at ('@'), K_A..K_Z ('A'..'Z'), K_a..K_z ('a'..'z'),
            K_bracketleft ('['), K_backslash ('\\'), K_bracketright (']'), K_circum ('^'), K_underscore ('_'), K_grave ('`'),
            K_braceleft ('{'), K_bar ('|'), K_braceright ('}'), and K_tilde ('~'). My preference and recommendation is to use the literal
            values instead of the constant names for 'plain' keystrokes, since for example I <i>cannot</i> get '!' wrong, however I could 
            very easily mis-spell K_exclam as K_exclaim, or K_parentleft as K_parenthleft or K_leftparenth, K_period as K_dot, K_greater 
            as K_gt, ... sure the syntax colouring/compiler would catch it, but there is little benefit in you or me sitting there going 
            "OK, how <i>do</i> you spell it then?". In contrast, the modified keystrokes as listed below are usually much easier, for
            instance using <code>K_cA</code> beats <code>iup_XkeyCtrl('A')</code> hands down.
            <br>
            <br>
            The following are deprecated/untested:<br>
            K_acute ('´', #B4), K_ccedilla ('ç', #E7), and K_diaeresis ('¨', #A8). While those are valid for UTF-32, Windows-1252, and
            ISO 8859-1, the same cannot be said for UTF-8, and quite possibly several legacy 8-bit code pages, hence the exclusion.
            <br>
            <br>
            For some keys, change the prefix to K_c*, K_m*, K_s*, and K_y* to add the respective modifier (Control, Alt, Shift, and Sys).<br>
            Sys in Windows is the Windows key and in Mac is the Apple key.<br>
            Modifier prefixes are always applied in the above order, for instance &lt;Ctrl Shift C&gt; is K_csC, not K_scC.
            <br>
            <br>
            Note that some keys have not yet made it into pGUI. Only keys that make sense and I get round to testing will (ever) be added: 
            for instance K_sexclam (heh) makes no sense because you cannot (on my keyboard anyhow) get a '!' without the shift key being 
            down, and the same for K_sPrint, K_sSCROLL, and K_sPAUSE. (Apart from a general reluctance to add rafts of untested things, I
            am also trying to keep the documentation in step with the implementation.) The following keys do however exist:
            <br>
            <br>
            Ctrl:<br>
            K_cSP,
            K_cPlus,
            K_cMinus,
            K_cEqual,
            K_cA,
            K_cB,
            K_cC,
            K_cD,
            K_cE,
            K_cF,
            K_cG,
            K_cH,
            K_cI,
            K_cJ,
            K_cK,
            K_cL,
            K_cM,
            K_cN,
            K_cO,
            K_cP,
            K_cQ,
            K_cR,
            K_cS,
            K_cT,
            K_cU,
            K_cV,
            K_cW,
            K_cX,
            K_cY,
            K_cZ,
            K_cPGUP,
            K_cPGDN,
            K_cHOME,
            K_cEND,
            K_cF1,
            K_cF2,
            K_cF3,
            K_cF4,
            K_cF5,
            K_cF6,
            K_cF7,
            K_cF8,
            K_cF9,
            K_cF10,
            K_cF11,
            K_cF12
            <br>
            <br>
            Alt:<br>
            K_mA,
            K_mB,
            K_mC,
            K_mD,
            K_mE,
            K_mF,
            K_mG,
            K_mH,
            K_mI,
            K_mJ,
            K_mK,
            K_mL,
            K_mM,
            K_mN,
            K_mO,
            K_mP,
            K_mQ,
            K_mR,
            K_mS,
            K_mT,
            K_mU,
            K_mV,
            K_mW,
            K_mX,
            K_mY,
            K_mZ
            <br>
            <br>
            Shift:<br>
            K_sSP
            <br>
            <br>
            Ctrl Shift:<br>
            K_csSP,
            K_csA,
            K_csB,
            K_csC,
            K_csD,
            K_csE,
            K_csF,
            K_csG,
            K_csH,
            K_csI,
            K_csJ,
            K_csK,
            K_csL,
            K_csM,
            K_csN,
            K_csO,
            K_csP,
            K_csQ,
            K_csR,
            K_csS,
            K_csT,
            K_csU,
            K_csV,
            K_csW,
            K_csX,
            K_csY,
            K_csZ,
            <br>
            <br>
            Alt Shift:<br>
            K_msA,
            K_msB,
            K_msC,
            K_msD,
            K_msE,
            K_msF,
            K_msG,
            K_msH,
            K_msI,
            K_msJ,
            K_msK,
            K_msL,
            K_msM,
            K_msN,
            K_msO,
            K_msP,
            K_msQ,
            K_msR,
            K_msS,
            K_msT,
            K_msU,
            K_msV,
            K_msW,
            K_msX,
            K_msY,
            K_msZ
            <br>
            <br>
            Further keys will be added as needed and when time allows for adequate testing. In the short term, it should not prove difficult
            to add any missing ones that you need to pGUI.e, where you will find several potential but untested candidates commented out,
            maybe including the one you are after.
            <br>
            <br>
            To obtain a key code for a generic combination you can also start with a base key and combine it repeated times using 
            iup_XkeyCtrl(key), iup_XkeyAlt(key), iup_XkeyShift(key), and iup_XkeySys(key).
            For instance <code>constant control_shift_c = iup_XkeyCtrl(iup_XkeyShift('C'))</code>. Note that, depending on the 
            driver/firmware for your particular keyboard, iup_XkeyShift('c') might have use when caps lock is on, (now there&rsquo;s 
            a way to confuse your users) but you are unlikely to get very far with iup_XkeyCtrl(iup_XkeyShift('c')). In general,
            pGUI/IUP cannot guarantee the behaviour of various combinations of Caps Lock, Shift, and other key modifiers with
            regard to the case/capitalisation of alphabetic base keys, since that is system/driver/hardware dependent, instead
            the prudent programmer will ensure that eg 'c' and 'C' are both tested for.<br>
            The function iup_XkeyBase() can be used to obtain the raw keystroke less any modifiers.<br>
<!-- DEV: (full search rqd, index all of these) -->
<!--        The functions iupCtrl, iupAlt, iupShift, iupSys, and iupBase are simple aliases of the above functions.<br> -->
            Also, the global attribute "MODKEYSTATE" can be used to detect the combination of two or more modifiers.
            <br>
            <br>
            Literal string versions of these names may be used to assign callbacks, eg "K_cC", for &lt;Ctrl C&gt;, <i>with</i> the quotes, see below.
            <br>
            <br>
            The above keys are also used in <a href="callbacks.htm#KEYPRESS_CB">KEYPRESS_CB</a> callbacks.
            <br>
            <br>
            The iup_isprint(key) function returns true if a key can be directly used as a printable character.<br>
<!--            The iup_isXkey(key) macro informs if a given key is an extended code.<br> -->
            The iup_isShiftXkey(key) function returns true if a given key is an extended code using the Shift modifier.<br>
            The iup_isCtrlXkey(key) function returns true for the Ctrl modifier.<br>
            The iup_isAltXkey(key) function returns true for the Alt modifier.<br>
            The iup_isSysXkey(key) function returns true for the Sys modifier.
            <br>
            <br>
            Note: GTK in Windows does not generate the Win modifier key, the K_Print and the K_Pause keys (up to GTK version 2.8.18).
            <br>
            <br>
            Returns: <br>
            If IUP_IGNORE is returned the key is ignored and not processed by the control and not propagated. <br>
            If IUP_CONTINUE is returned the key is processed and the event propagated to the parent of the element receiving it. (default behavior)<br>
            If IUP_DEFAULT is returned the key is processed but it is not propagated. <br>
            IUP_CLOSE will be processed. 
            <br>
            <br>
            Notes<br>
            Keyboard callbacks depend on the keyboard usage of the control with the focus. <br>
            So if you return IUP_IGNORE the control will usually not process the key. <br>
            But be aware that sometimes the control processes the key in another event so even when returning IUP_IGNORE the key can still get processed, although it will not be propagated.
            <br>
            <br>
            IMPORTANT: The callbacks "K_*" of the dialog or native containers depend on the IUP_CONTINUE return value to work while the control is in focus.
            <br>
            <br>
            If the callback does not exist it is automatically propagated to the parent of the element.
            <br>
            <br>
            K_* callbacks<br>
            All defined keys are also callbacks of any element, called when the respective key is activated. <br>
            For example: "K_cC" is also a callback activated when the user press Ctrl+C, when the focus is at the element or at a children with focus. <br>
            This is the way an application can create shortcut keys, also called hot keys.
            <br>
            <br>
            Affects: All elements with keyboard interaction.
            <br>
              <a name=KEYPRESS_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          KEYPRESS_CB
         </td>
         <td>
            Action generated when a key is pressed or released. <br>
            If the key is pressed and held several calls will occur. <br>
            It is called after the callback K_ANY is processed.
            <br>
            <br>
            function keypress_cb(Ihandle ih, integer c, <a href="integer.htm#bool">bool</a> press)
            <br>
            <br>
            ih: identifier of the element that activated the event.<br>
            c: identifier of typed key. See K_ANY above for possible values.<br>
            press: 1(true) when the key is pressed, 0(false) when the key is released.
            <br>
            <br>
            Returns: If IUP_IGNORE is returned the key is ignored by the system. IUP_CLOSE will be processed.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>
            <br>
              <a name=KILLFOCUS_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          KILLFOCUS_CB
         </td>
         <td>
            Action generated when an element loses keyboard focus. <br>
            This callback is called before the <a href="callbacks.htm#GETFOCUS_CB">GETFOCUS_CB</a> of the element that gets the focus.
            <br>
            <br>
            function killfocus_cb(Ihandle ih)
            <br>
            <br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Affects: All elements with user interaction, except menus.
            <br>
            <br>
            In Windows, there are restrictions when using this callback. <br>
            From MSDN on WM_KILLFOCUS: <br>
            “While processing this message, do not make any function calls that display or activate a window. <br>
            &nbsp;This causes the thread to yield control and can cause the application to stop responding to messages.” 
            <br>
            <br>
            See Also: <a href="callbacks.htm#GETFOCUS_CB">GETFOCUS_CB</a>, <a href="IupGetFocus.htm">IupGetFocus</a>, <a href="IupSetFocus.htm">IupSetFocus</a> 
            <br>
              <a name=LEAVEWINDOW_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          LEAVEWINDOW_CB
         </td>
         <td>
            Action generated when the mouse leaves the native element.
            <br>
            <br>
            function leavewindow_cb(Ihandle ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Notes<br>
            When the cursor is moved from one element to another, the call order in all platforms will be first the LEAVEWINDOW_CB callback 
            of the old control followed by the <a href="callbacks.htm#ENTERWINDOW_CB">ENTERWINDOW_CB</a> callback of the new control.
            <br>
            <br>
            Affects: All controls with user interaction.
            <br>
            <br>
            See Also: <a href="callbacks.htm#ENTERWINDOW_CB">ENTERWINDOW_CB</a>
            <br>
              <a name=MAP_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          MAP_CB
         </td>
         <td>
            Called right after an element is mapped and its attributes updated in <a href="IupMap.htm">IupMap</a>().
            <br>
            <br>
            When the element is a dialog, it is called after the layout is updated. 
            For all other elements it is called before the layout is updated, so the element current size will still be 0x0 during MAP_CB (since 3.14).
            <br>
            <br>
            function map_cb(Ihandle ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Affects: All elements that have a native representation.
            <br>
              <a name=MOTION_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          MOTION_CB
         </td>
         <td>
            Action generated when the mouse moves.
            <br>
            <br>
            function motion_cb(Ihandle ih, integer x, integer y, atom pStatus)<br>
            ih: identifier of the element that activated the event.<br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of mouse buttons and certain keyboard keys at the moment the event was generated (a char*).
            <br>
            <br>
            Use the same routines for pStatus as <a href="callbacks.htm#BUTTON_CB">BUTTON_CB</a>.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>,
                     <a href="IupList.htm">IupList</a>, <a href="IupMatrix.htm">IupMatrix</a>, 
                     <a href="IupText.htm">IupText</a>, <a href="IupTree.htm">IupTree</a>
            <br>
              <a name=RESIZE_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          RESIZE_CB
         </td>
         <td>
            Action generated when the canvas or dialog size is changed.
            <br>
            <br>
            function resize_cb(Ihandle ih, integer width, integer height)
            <br>
            <br>
            ih: identifier of the element that activated the event.<br>
            width: the width of the internal element size in pixels not considering the decorations (client size)<br>
            height: the height of the internal element size in pixels not considering the decorations (client size)
            <br>
            <br>
            For the dialog, this action is also generated when the dialog is mapped, after the map and before the show.
            <br>
            <br>
            When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the canvas scrollbar is hidden/shown after changing the DX or DY attributes from inside the callback, 
            the size of the drawing area will immediately change, so the parameters with and height will be invalid. <br>
            To update the parameters consult the DRAWSIZE attribute. Also activate the drawing toolkit only after updating the DX or DY attributes.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>, <a href="IupDialog.htm">IupDialog</a>
            <br>
              <a name=SCROLL_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          SCROLL_CB
         </td>
         <td>
            Called when some manipulation is made to the scrollbar. <br>
            The canvas is automatically redrawn only if this callback is NOT defined.
            <br>
            <br>
            (GTK 2.8) Also the POSX and POSY values will not be correctly updated for older GTK versions.
            <br>
            <br>
            In Ubuntu, when liboverlay-scrollbar is enabled (the new tiny auto-hide scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
            <br>
            <br>
            Callback<br>
            function scroll_cb(Ihandle ih, integer op, atom /*posx*/, atom /*posy*/)<br>
            ih: identifier of the element that activated the event.<br>
            op: indicates the operation performed on the scrollbar:
            <br>
            <br>
            If the manipulation was made on the vertical scrollbar, it can have the following values:
            <br>
            <br>
            IUP_SBUP - line up<br>
            IUP_SBDN - line down<br>
            IUP_SBPGUP - page up<br>
            IUP_SBPGDN - page down<br>
            IUP_SBPOSV - vertical positioning<br>
            IUP_SBDRAGV - vertical drag 
            <br>
            <br>
            If it was on the horizontal scrollbar, the following values are valid:
            <br>
            <br>
            IUP_SBLEFT - column left<br>
            IUP_SBRIGHT - column right<br>
            IUP_SBPGLEFT - page left<br>
            IUP_SBPGRIGHT - page right<br>
            IUP_SBPOSH - horizontal positioning<br>
            IUP_SBDRAGH - horizontal drag
            <br>
            <br>
            Notes<br>
            IUP_SBDRAGH and IUP_SBDRAGV are not supported in GTK.<br>
            posx, posy: require messy conversion on 32-bit, and are unreliable on 64-bit - use IupGetDouble(ih,"POSX"|"POSY") instead.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>, <a href="common.htm#SCROLLBAR">SCROLLBAR</a>
            <br>
              <a name=UNMAP_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          UNMAP_CB
         </td>
         <td>
            Called right before an element is unmapped.
            <br>
            <br>
            function unmap_cb(Ihandle ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Affects: All elements that have a native representation.
              <a name=WHEEL_CB></a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          WHEEL_CB
         </td>
         <td>
            Action generated when the mouse wheel is rotated.<br>
            If this callback is not defined the wheel will automatically scroll the canvas in the vertical direction by some lines, 
            the SCROLL_CB callback if defined will be called with the IUP_SBDRAGV operation.
            <br>
            <br>
            function wheel_cb(Ihandle ih, atom delta, integer x, integer y, atom pStatus)<br>
            ih: identifier of the element that activated the event.<br>
            delta: the amount the wheel was rotated in notches.<br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of mouse buttons and certain keyboard keys at the moment the event was generated (a char*).
            <br>
            <br>
            Use the same routines for pStatus as <a href="callbacks.htm#BUTTON_CB">BUTTON_CB</a>.
            <br>
            <br>
            Notes: In Motif and GTK delta is always 1 or -1. In Windows is some situations delta can reach the value of two. 
            In the future with more precise wheels this increment can be changed.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>
         </td>
        </tr>
       </table>
       <br>
        &nbsp;
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
