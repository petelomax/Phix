<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">ba_scale</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td valign=top>
          <b>Definition:</b>
         </td>
         <td>
            sequence prev = ba_scale(object decs=-1, integer mode=-1)
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Description:</b>
         </td>
         <td>
            Specify the number of decimals and mode for bigatom operation.
            <br>
            <br>
            If mode is zero, decs specifies the number of decimal places after the decimal point.
            <br>
            If mode is not zero (the default), decs specifies the precision (total number of digits) required.
            <br>
            <br>
            The initial default for scale is 25. (When I say scale, I sometimes mean SCALE, the (private)
            variable in bigatom.e where the decs parameter above gets permanently stored. Likewise I may
            say mode when I really mean SC_MODE, which I tend to imagine is somehow less confusing...)
            <br>
            <br>
            For both parameters a value of -1 leaves previous settings unchanged.
            <br>
            <br>
            Returns a sequence with the previous values: {scale, mode}
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Comments:</b>
         </td>
         <td>
            The scale is not necessarily rigorously applied; I have seen accurate 100-digit results 
            after (accidentally) leaving the default of 25, but it cannot be advisable to do so. In
            other words it guarantees a minimum accuracy, rather than the maximum possible accuracy.
            There is also a fair chance that I have badly mis-translated some of the scale comments.
            <br>
            <br>
            Obviously some calculations may require intermediate values with a much greater accuracy
            than the requirement for the final result, in order for the latter to be correct. A small 
            number of places inside bigatom.e temporarily increase the scale to ensure accuracy (ba_log, 
            ba_exp, and ba_root), and there may be places where your code ought to do the same. One of
            the examples given for the <a href="accuracy.htm">limitations of atoms</a>, specifically
            1e300+1-1e300 vs 1e300-1e300+1, quite clearly demonstrates that there can be no general 
            guidelines for the accuracy requirements of intermediates, but instead it depends entirely 
            on the specific calculation being performed, both the formula and the values.
            <br>
            <br>
            The library has been tested to a million decimal places (against a downloaded copy of euler&rsquo;s
            number to one million places), though obviously the more decimal places required the longer 
            each calculation will take.
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Example:</b>
         </td>
         <td>
<!--eucode>
include bigatom.e
sequence prev = ba_scale(100000)
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">include</font><font color="#000000"> bigatom.e
</font><font color="#004080">sequence</font><font color="#000000"> prev</font><font color="#0000FF"> =</font><font color="#000000"> ba_scale</font><font color="#0000FF">(</font><font color="#000000">100000</font><font color="#0000FF">)</font>
</pre>
         </td>
        </tr>
       </table>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
