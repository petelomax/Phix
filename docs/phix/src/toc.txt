--
-- toc.txt
-- =======
--
--  This is the master "table of contents" file for phix.chm, and populates both the
--  traditional contents tab and the fancy new "middle" contents auto-tree thing (for
--  want of anything better to call it, the idea being cribbed from the MSDN site).
--  Obviously comments and blank lines are allowed, and are ignored.
--  See also index.txt
--
--  Indentation is critical. It is illegal to increase indentation by >1 in any one line.
--  Each line (eg "example") means read from /src (eg "docs/phix/src/example.htm") and
--  write to /html (eg "docs/phix/html/example.htm") with the exception of the very first
--  line ("phix") which does not go into /html but to docs/phix/phix.htm. Descriptions 
--  are taken from the <h1 class="title"> which should be in line 7 of the src file.
--  Copy mt.htm to any new file as the starting point. Edita\Tools\Htmlise eucode and
--  Edita\Tools\Re-indent source can/should be used liberally on any content files.
--
--  Run makephix.exw to process this file, index.txt, and everything in docs/phix/src, 
--                              and then create phix.hhc, phix.hhk, and finally phix.chm.
--
phix
 example
-- quicksort
 installation
 licence
--? command line switches
language
 atoms
  numberbases
  accuracy
 sequences
  strings
 phixvscl
 comments
  perrec
 expressions
  relops
  logicops
  arithops
  seqops
  subscripts
  slices
  concatenation
  seqformation
  otherseqops
  precedence
 declarations
  procedures
  functions
  types
  variables
  constants
  scope
  usingtypes
 statements
  assignment
   assignop
   explicitdiscard
   multiassign
  callproc
  if
--switch!
--ifdef!
  while
  shortcircuit
  for
  return
  exit
  specialtop
   include
   with
   format
  debugging
--===
--  semicolons
-- directives
--  format statement (see below) {format}
--  include (and relative directory support) {include}
--  autoincludes
--  with {with,without}
--  preprocessing
--  inlineassembly
-- debugging
--  trace screen {trace}
--  trace file
--  profiling {profile,profile_time}
--
--===
library
 predeftypes
  atom
  integer
  sequence
  string
  object
 seqmanip
  length
  repeat
  reverse
  append
  prepend
  flatten
  join
  columnize
  tagset
  shuffle
  substitute
 srchsort
  compare
  equal
  min
  max
  find
  match
  sort
  custom_sort
 patmat
  lower
  upper
  wildcard_match
  wildcard_file
 math
  abs
  sum
  sqrt
  rand
  sin
  arcsin
  cos
  arccos
  tan
  arctan
  log
  floor
  remainder
  power
  PI
  factors
  prime_factors
 bitlog
  and_bits
  or_bits
  xor_bits
  not_bits
 fileio
  open
  close
  flush
  lock_file
  unlock_file
  print
  qu
  sprint
  printf
  sprintf
  puts
  getc
  gets
  get_bytes
  get_text
  prompt_string
  get_key
  wait_key
  get
  prompt_number
  value
  seek
  where
  current_dir
  chdir
  dir
  walk_dir
  allow_break
  check_break
 database
  db_create
  db_open
  db_select
  db_close
  db_create_table
  db_select_table
  db_delete_table
  db_table_list
  db_table_size
  db_find_key
  db_record_key
  db_record_data
  db_insert
  db_delete_record
  db_replace_data
  db_compress
  db_dump
  db_fatal_id
 opsystem
  time
  date
  command_line
  getenv
  system
   sysproc
   system_open
  system_exec
   sysexec
   system_wait
   set_system_doevents
  abort
  sleep
  platform
  machine_bits
  include_paths
 debug
  trace
  profile
 graphics
  clear_screen
  position
  get_position
  video_config
  scroll
  wrap
  text_color
  bk_color
  read_bitmap
  save_bitmap
  cursor
  text_rows
  get_screen_char
  put_screen_char
  save_text_image
  display_text_image
  free_console
 machine
  peek
  poke
  mem_copy
  mem_set
  call
  allocate
  free
  allocate_string
  register_block
  unregister_block
  int_to_bytes
  bytes_to_int
  int_to_bits
  bits_to_int
  atom_to_float64
  atom_to_float32
  float64_to_atom
  float32_to_atom
  set_rand
  crash_file
  crash_message
 dcall
  routine_id
  call_proc
  call_func
 cffi
  open_dll
  define_c_proc
  define_c_func
  define_c_var
  c_proc
  c_func
  call_back
  message_box
  instance
 mtask
  task_create
  task_schedule
  task_yield
  task_self
  task_suspend
  task_status
  task_clock_start
  task_clock_stop
  task_list
 mthread
  init_cs
  delete_cs
  enter_cs
  try_cs
  leave_cs
  create_thread
  suspend_thread
  resume_thread
  exit_thread
  get_thread_exitcode
  wait_thread
 eucompat
  cpath
  get_proper_path
otherlibs
 arwen
  arwen.Introduction
  arwen.Events
  arwen.Create
   arwen.Windows
   arwen.Buttons
   arwen.Markboxes
   arwen.Groups
   arwen.Editable
   arwen.Labels
   arwen.Toolbars
   arwen.Statusbars
   arwen.Scrollbars
   arwen.Trackbars
   arwen.Progressbars
   arwen.Menus
   arwen.Listcontrols
   arwen.Tabcontrols
   arwen.Hypertext
  arwen.Destroy
  arwen.Tabbing
  arwen.Accelerator
  arwen.Mouse
  arwen.Clipboard
  arwen.Dib_bitmap
   arwen.DibSections
  arwen.Icon_cursor
  arwen.Timers
  arwen.Comm_dlg
  arwen.Window_msg
  arwen.Structures
 bigatom
  bigatom_type
  ba_new
  scale
  ba_sprintf
  ba_round
rectools
 wrectools
internals
 lowlevel
 pGetPool
 pFreePool
 pStoreMint
 pStoreFlt
glossary
 glossary
<EOF>
delete_routine, delete
-- permute() and factorial() are now in builtins/auto-includes.
abs, sign, max, min (note: in Phix, min/max(a,b) is equivalent to min/max({a,b}), but implemented more efficiently)

slice, vslice [not yet done] 
insert, splice [see pseqc.e]
>walk_dir, optional 4th parameter
wildcard_file removed/deprecated?
sort_columns
create_directory, remove_directory
create_file, delete_file
curdir, optional parameter
file_exists
copy_file, rename_file, move_file, file_length
checksum
STDIN/STDOUT/STDERR/SCREEN/EOF
large_of, smaller_of
mod (as remainder but round away from 0)
trunc, frac, ceil, round
atan2, rad2deg, deg2rad, exp, fib, cosh, sinh, tanh, arcsinh, arccosh, arctanh
sum, product, 
>or_all
shift_bits, rotate_bits, gcd, approx, powof2, is_even, is_even_obj, 
QUARTPI, HALFPI, TWOPI, PISQR, INVSQ2PI, PHI, E, LN2, INVLN2, LN10, INVLN10, SQRT2, HALFSQRT2, SQRT3, 
DEGREES_TO_RADIANS, RADIANS_TO_DEGREES, EULER_GAMMA, SQRTE, PINF, MINF, SQRT5, 
rand_range, rnd, rnd_1, chance, roll, sample, 
get_pid, uname, 
>setenv, unsetenv, 
ifdef, elsedef
include_paths
>ppp
smallest, largest, small?, range, stdev, avedev, sum, count, average, geomean, harmean, movarg, emovarg, median, 
raw_frequency, mode, central_moment, sum_central_moments, skewness, kurtosis,
task_*,
>TRUE, FALSE, boolean
>iff (DOH, that would be better than a ternary operator...) [NB should NOT be implemented in hll!]
  iif - identical to iff. Use whichever you prefer.
>to_number (note that unlike the OpenEphoria routine, numbers in any base can be converted. @<octal> and !<binary> are supported for compatibility)
>set_decimal_mark()
>to_integer
>find, optional parameter
match_any, match_all, rmatch, find_each, find_all, find_any, find_nested, rfind, find_replace, match_replace, begins, ends, 
>lookup, vlookup [done?]
fetch, store
valid_index, rotate, 
>columnize [done]
apply, mapping, shuffle, linear, repeat_pattern, pad_head, pad_tail, add_item, remove_item, mid, patch, remove_all, retain_all, 
>filter (nice quiksort example) [should work as-is..]
>head, tail, slice, vslice (am I not repeating myself here?), remove, replace, replace_all(erm, deprecated/match_replace), 
binary_search, 
extract, project, split, split_any, join, breakup, flatten, pivot, 
>(ish) build_list, transform, transmute
sim_index, remove_subseq, remove_dups, combine, minsize, 
deserialize, serialize (and deserialise, serialise)
dump, load
sort_columns, merge, insertion_sort, 
set_lang_path, get_lang_path, lang_load, set_def_lang, get_def_lang, translate, trsprintf, 
datetime, 
set/get_encoding_properties (for upper/lower)
proper, 
keyvalues, 
escape, quote, dequote, format
is_match (wildcard.e)
db_get_recid, db_replace_recid, db_fetch_record, db_record_recid, db_cache_clear, db_set_caching
calc_primes, next_prime, primt_list, 
flags_to_string (see also my routine)
hash, map, calc_hash, threshold?, type_of?, rehash, new[map], new_extra?, compare[map], has, get, nested_get, put, nested_put, 
remove, clear, size, statistics, keys, values, pairs, optimise, load_map, save_map, SM_TEXT/SM_RAW, copy[map], new_from_kvpairs,
new_from_string, for_each, 
stack, new[stack], is_empty, size, at, push, top, pop, last, peek_top, peek_end, swap, dup, set, clear,
set, map, operation, sequence_to_set, cardinal, belongs_to, add_to, remove_from, is_subset, embedding, embed_union, subsets, intersection, union, delta, difference, product, 
define_map, sequences_to_map, image, range, direct_map, restrict, change_target, combine_maps, compose_map, diagram_commutes, is_injective, is_surjective, is_bijective,
fiber_over, reverse_map, section, product_map, amalgamated_sum, fiber_product, define_operation, is_symmetric, is_associative, all_left_units, all_right_units, has_unit,
is_unit, has_inverse, distributes_over, 
socket, create, close, shutdown, select, send, receive, get_option, set_option, connect, bind, listen, accept, send_to, receive_from, service_by_name, service_by_port,
is_inetaddr, parse_ip_address, parse_url, host_by_name, host_by_addr, get_sendheader, set_sendheader_default, set_sendheader, set_sendheader_useragent_msie,
parse_recvheader, get_recvheader, get_http, get_http_use_cookie, get_url, parse_querystring, parse, encode, decode, 
C_HANDLE, C_HWND, C_WPARAM, C_LPARAM, C_HRESULT
crash, crash_message, crash_file, warning_file, warning, crash_routine,
ram_space, malloc, free[p], valid,
allocate_data, allocate_pointer_array, free_pointer_array, allocate_string_pointer_array, 
valid_memory_protection_constant, page_aligned_address, is_DEP_supported, is_using_DEP, DEP_on, allocate_code, std_library_address, allocate_protect,
poke_string, poke_wstring, allocate_wstring, peek_wstring, free_code, deallocate, 
>peek2s, peek2u, poke2
check_calls, safe_address, check_all_blocks, prepare_block, BORDER_SPACE, trailer, bordered_address,
dep_works, show_block, info, memory_used, allocations, PAGE_EXECUTE etctest_read, test_write, test_exec,
mmap, munmap, [unix only?]
platform_name, version, version_major, version_minor, version_patch, version_revision, version_type, version_string, version_string_short, version_string_long
euphoria_copyright, pcre_copyright?, all_copyrights, 
SyntaxColor,
sound
poke_long, peek_longu, peek_longs, sizeof, poke8m, poke8u, poke8s, poke_pointer, peek_pointer, 

<   negativeindexes
<   varlensliceasgn
----  parameterdefaults
--  enum {enum}
-- values
----  numberbases
--  strings
<library routines (done, ish)
  by application area
   predefined types
   sequence manipulation
   searching and sorting
   pattern matching
   math
   bitwise {and_bits,or_bits,xor_bits,not_bits}
   fileio {open,getc,puts,close}
   os {system,system_exec,sysproc}
   debugging
   machinelevel
   dynamiccalls
   callingCfunctions {open_dll,c_func,c_proc,define_c_func,define_c_func,define_c_var}
  alphabetical (see index?)
  database
  arwen
  edita?
 glossary
 omerrata
 recommended tools and add-ons (HTML Help Workshop, Greenfish, virustotal, mini.chm, agent ransack, process monitor, dependency walker, OllyDbg, FDBG, FASM, 7-zip, CCleaner ..)

<multiple assignment -- (see also ("Simulating implicit sequence ops") in totdo.txt)
unicode support
threads
Compatibility with RDSEu/OpenEuphoria
named parameters


Incompatibilites with RDS Eu/OpenEuphoria

Attempting to acheive 100% compatibility is a fool&rsquo;s errand. It would mean that no new features could be added to Phix, 
and slavish reproduction of every wart, gotcha, and bug in OpenEuphoria. It is somewhere in the high 99% area, and
that is good enough for me. Obviously the compiler generates warning messages wherever possible, do not ignore them.

1.  Phix permits direct comparison, for example
        if name="pete" then
    is legal, whereas on RDS Eu/OpenEuphoria you must code
        if equal(name,"pete") then
    and the same goes for <,<=,... needing to be compare(,)<0, <=0, ...
2.  Phix does NOT support implicit sequence operations, for example instead of:
        s += {1,2,3}
    you must code
        s = sq_add(s,{1,2,3})
    You simply cannot have both direct comparison and implicit seqence ops in a
    viable/unambiguous language, and it is quite abundantly clear that comparison 
    occurs far more often than sequence maths. One day, perhaps, Phix will have 
    explicit infix sequence ops, eg s @+= {1,2,3}, but it does not have them yet.
    In some cases the Phix compiler will automatically assume an sq_xxx operation,
    when it knows with absolute certainty that such is needed, and issue a warning
    to that effect, If you get 
        s += {1,2,3}
          ^ warning: sq_add() assumed
    You should replace it with
--/**/  s = sq_add(s,{1,2,3})   --/* -- Phix
        s += {1,2,3}            --*/ -- RDS
    that is, if you are gunning for source code compatible with both compilers.
3.  Variable length slice substitution, for example
        s = "food"
        s[2..3] = "e"
    sets s to "fed", whereas on RDS Eu/OpenEuphoria you must code
        s = s[1..1]&"e"&s[4..4]
    to achieve the same effect. 
    Note there can be significant performance issues if this is used thousands of times 
    on very long strings/sequences, see below, but certainly for a single substitution 
    it is not only rather neat and concise, but also significantly faster.
    (Instead of performing thousands of in-situ variable length slice replacements,
     create thousands of pieces and reassemble them just once at the end, which means 
     that elements towards the end are moved just twice rather than thousands of times, 
     and therefore you can sometimes achieve the same result much more quickly. That
     general rule applies both to s[i..j]=z and even more to s=s[1..i-1]&z&s[j+1..$].)
4.  Negative indexes, for example if s is "file.exw"
        ext = s[-4..-1]
    sets ext to ".exw". Admittedly not a significant gain over the RDS Eu/OpenEuphoria
        ext = s[$-3..$]
    which also works just fine on Phix, but I know which I prefer.
5.  Nested $ do not always work as you might perhaps hope on Phix, eg
        lines[rand($)]
    is simply equivalent to
        lines[rand(-1)]
    (because Phix trivially implements "$" as "-1", and it crashes) rather than
        lines[rand(length(lines))]
    which is the way such code behaves on RDS Eu/OpenEuphoria (the latter works in the
    way you probably wanted on both Phix and RDS/Open Eu). In practice this has not yet
    been observed in any real-world code (flw).
5.  Multiple [nested/subscripted] assignments are fully supported in Phix, for example
        {this,{that,theother[j]}} = table[i]
    I understand work on a similar feature in OpenEuphoria is in progress, however I personally
    doubt that full support for nested, subscripted, or @= forms of multiple assignments will 
    be available any time soon. Meanwhile, if you want compatibility, use longhand.
6.  Phix does not support "with label" on if/for/while/switch constructs or the goto statement. 
    For the extremely rare cases where a jump is genuinely needed, I suggest using #ilASM{jmp :label}.
7.  Phix does not support the loop construct, or the continue and retry statements.
8.  Phix only implements the bare basic preprocessor directives (see ptok.e), preferring instead
    to rely on hll tests on platform() and machine_bits() being intelligently optimised away by
    the compiler. Which leads us directly to (point 8):
9.  Phix supports neither RDS Eu nor OpenEuphoria std/ includes. Like-for-like replacements are
    installed as part of the standard distribution, however there are inevitably some omisions 
    and in the compatibility sense they should be considered a work-in-progress. This is really
    no different from OpenEuphoria not liking RDS Eu includes (which is why the std/ directory
    was created in the first place) or RDS Eu throwing errors when fed OpenEuphoria files.
10. Automatic includes. If you want to use sort() you no longer have to remember to "include
    sort.e" somewhere earlier in the file, instead the compiler knows (see psym.e/syminit())
    where to find such things.
11. Limited parameter defaults. Currently Phix only supports literal constants, plain constant
    and variable names, and length() and command_line(). It does not support general expressions,
    no maths, comparisons, subscripting/slicing, concatenation, non-entirely-constant-literal
    sequence creation (such as {1,0,v}), or any other function call other than the two mentioned 
    above. See pmain.e/getOneDefault() for more details - with 20/20 hindsight I would have made
    it call increaseScope(), add parameter symtab entries, and emit opTchk code earlier, but as
    things stand it covers all my needs, and I have no immediate plans to remodel that code.
12. Unicode (UTF8) source files are properly supported by the Phix compiler. By the time you
    read this, the same may or may not be true for the lastest version of OpenEuphoria.
13. sprintf("%016x",-1) produces "FFFFFFFFFFFFFFFF" not "00000000FFFFFFFF".
14. printf(1,"%s\n","Pete") displays "Pete", not "P" (via a simple mini-fudge).
15. 32-bit integer callback parameters are signed, so -1 is -1 not 4294967295 (#FFFFFFFF).
16. Phix does not support a preprocessor. One of Euphoria&rsquo;s (sic) purported strengths is that
    it can be used as a sophisticated batch file, so quite why a preprocessor is somehow better
    that that has always eluded me. In particular the Euphoria approach mandates that only the
    top level file can be suject to preprocessing, and that irks me. Perhaps if any required 
    preprocessing was specified in the source file much like a !# line, I might be a little 
    less derisory, but probably no more enthusiastic.
17. Phix is properly self-hosted, requiring no other tools to be installed, and rebuilds itself
    in a matter of seconds - 12 at the last count, although if I add the Phix directory to the 
    exclusion list of my AntiVirus (temporarily, of course) it completes in less than 6 seconds.
    Oh, I should qualify that is just the executable that I can run, not the full installer that 
    I can upload, because takes another 5 seconds, and building a linux version as well might
    well double all of that.
18: Regular expressions. Personally I detest them. Maybe one day I&rsquo;ll wrap pcre.dll and see how
    far that gets me. Maybe.
19: Overriding builtins. I have noticed a few things which seem to be a bit off with this, maybe that
    is more of a concern when playing around in builtins/VM, but I have some suspicions there are a
    few glitches that deserve a more thorough investigation when time warrants. For now, I am just
    going to say if you write, for example, your own open() routine, don't blame me if it goes wrong.
    If two sub-libraries have their own init(), the name clash is resolved quite well, but I am not
    entirely convinced that all is well when a name clash crosses the builtin/user defined divide.
    Like I said, some further experimention and testing is due, and btw volunteers are welcome.
    Update: if you define your own equal(), I believe pmain.e tries to stuff it into symtab[T_equal],
    where T_equal is as per psym.e (the newEmit/AutoAsm one). It should create a brand new entry, or
    all the tests of <=T_Asm need to be replaced with and_bits(symtabN[S_State],??) or somesuch. It
    seems to go even "more wrong" in the absence of "global", contrary to my expectations.
==:> I have decided: I **//AM//** going to ban overrides once and for all!!!

favourites
===========
I have probably given this list before, but the things I am proudest of, in order, are:
1) multiple assignment, eg {type,size,{scale,idx,base,offset}} = get_operand(P_MEM)
2) improved include system, eg include ..\arwen\arwen.ew -- just works, w/o EUINC|eu.cfg etc
3) additional compile-time type checking 
4) mixed "and/or" require explicit parenthesis
5) use of =,< etc instead of equal,compare
6) short circuit in all expressions
7) variable length slice assignment, eg s[i..j] = "", instead of s = s[1..i-1]&s[j+1..$]
8) passing strings directly to c_func
9) optional and named parameters
10) inline assembly (x86) 
11) nested block comments
12) negative subscripts
13) forward calls, with pukka error messages are fine, but end up fairly low down on this list
14) sleep for a fraction of a second

The biggest flaws of OpenEuphoria are forward variable references, ifdef, implicit discard of
function results, some error messages have gone right cryptic, and preprocessing, but that is 
just my opinion and I am sure others will leap to their defence.

The biggest challenge is to make debugging, and to that end understanding what is really going 
on in a complex program, simpler, simpler, and simpler still.

Overall state:
p.exw       -- bit messy, but ok
p2asm.e     -- fine, quite straightforward to modify/maintain
pdebug.e    -- being rewritten...
pdiag.e     -- being rewritten...
pemit.e     -- being rewritten, very very very messy right now...
perror.ew   -- fine
pglobals.e  -- fine
pilx86.e    -- bit messy but generally ok. proper register allocation needed.
plist.e     -- fine
pltype.e    -- deeply scary, but it works
pmain.e     -- fine, needs the odd restructure here and there (default params mainly)
pmsgs.e     -- fine, I think
pops.e      -- fine
profile.e   -- fine
psched.e    -- dead, should probably be removed and pilx86.e cleaned up
psym.e      -- bit messy, mainly fine except for increase/dropScope non-intuitive
ptok.e      -- fine
pttree.e    -- fine

>
Native 8-bit strings 
Named parameters, eg message_box(title:="title", text:="text", style:=MB_OK) works the same as message_box("text","title",MB_OK) 
No implicit sequence ops 
include file handling is a bit more intuitive, has relative directory handling, and it also does automatic includes, eg if you forget to include msgbox.e before using it, it will find it for you. 
Direct comparison (eg if name="pete" then) 
Negative indexes (as well as $) 
Variable length slice assignment (eg s="food" s[2..3]="e"; s is now "fed") 
Short circuit evaluation of all expressions (4.0 may now be the same?) 
Automatic pass by reference optimisations (for an example see bench.exw) 
inline assembly (x86) 
Additional compile-time type checking 
Automatic internal memory leak checking 
Self-hosted, no need for Watcon/Borland/gcc. 
No DOS or Linux versions. 
No floating point for loops 
There are plenty of things in 4.0 that have not made it into Phix. 
<

printfs third argument is now optional. printf(1, "Hello\n", {}) is no longer needed, 
it can be shortened to printf(1, "Hello\n")

DONE: (needs documenting)

DEV/SUG:
code before data/data before code
format []   -- specifies per/multi-target settings
[PE32]
[PE64]
-- allows you to specify per-target settings, different icons, version strings [+?], manifest,
--  while still being true cross-platform single source. ?A format[] can legally follow after
--  a specific format statement ie/as intended for explicit cross compilation. A multi-target
--  format statement can occur anywhere in the code, unlike a specific target format, which
--  must occur at the very start of the main source (or match existing settings?). An error 
--  occurs if more than one multi-target statement is encountered?. (??over-complicated??)



deal with top-level namespace: [DOC] [REWRITE THIS!]
====================================
  namespace <identifier>
    if "namespace" is the very first token in the file (after skipping any whitespace and comments) then
    it applies to any include statement targetting this file. For example an "include myfile.e" statement
    behaves as "include myfile.e as myfile" when myfile.e starts with "namespace myfile". Within the file 
    itself, it introduces a local namespace allowing explicit local references, with a big fat gotcha.
    
    Local namespaces cannot safely be used on implicit forward calls.
(surely to god we can make the compiler issue an error!!):
Note that attempts to use a local namespace qualifier on an implicit forward call trigger a compilation error,
which can be resolved by adding an explicit forward declaration for the routine earlier on.

    Technical note: Namespace resolution of implicit forward calls is, at best, somewhat patchy. The very
    nature of "implicit" can transform a fully qualified reference from a binding contract with the compiler,
    to do exactly what you mean, into a (not entirely without merit) rather more wooly statement of intent.
    In other words, the compiler is /NOT/ obliged to honor an explicit qualifier on an implicit statement.
    When running your evil empire you demand a "blue thingymabob", and one of your minions returns with a 
    blue clothes peg, you don&rsquo;t really have the moral right to complain that it isn&rsquo;t one of those spikes
    for removing stones from a horse&rsquo;s hoof with a blue handle. Of course we are only talking about using
    a <b>local namespace</b> to explicitly resolve a forward call: it does not work as you might hope.

    A reference such as local:close(fn) might, not entirely unreasonably, since namespaces apply equally to
    (auto)includes as well as the target file, resolve to the standard builtin global, <i>before</i> the 
    compiler encounters a local redefinition. No error or warning will be issued, except (perhaps) for an 
    unused warning if the latter is not referenced again. Obviously, you /do/ get an error if "local" has
    not been defined or it applies to a different file and there is/was no "close" therein. In some cases 
    an explicit forward definition of the routine is required/can help. The use of implicit forward calls, 
    especially in library or utility routines, should really be considered an accident waiting to happen, 
    whether (locally) namespace-qualified or not.
    
    Another, perhaps simpler, way to view this is that namespaces only work properly after the routine has
    actually been defined (or after an explicit forward definition), but not before, "locally", that is.
    The use of external (legacy) namespaces is in no way affected by any of this.

    In the following example, I shall use "open" and "close", however in general I would strongly discourage 
    overriding builtin names (as it potentially leads to confusion during subsequent maintenance); a better 
    example might be a library component writer wanting to be absolutely explicit that their local routines 
    are being (or should be) invoked.
    
        namespace local
        
        --forward procedure close(integer fn) -- (see notes below)

        function open(string name, string mode)
        integer k = length(name&mode)
            local:close(k)
            ?name
            return 0
        end function

        procedure close(integer fn)
            if fn>1 then
                {} = local:open(repeat('x',fn-1),"")
            end if
            ?fn
        end procedure

        {} = local:open("123","")

    Without the explicit forward definition of close, an auto-include occurs between the two routine 
    definitions, [fileio:close quietly does nothing] and the output is:

        123

    rather than the expected (trace it if you are unsure):

        1
        x
        2
        xx
        3
        123

    which is what you get once the explicit forward definition is uncommented. In fact, with the latter
    the "local:" qualifier is no longer necessary, but does show the intent more clearly. Note that such
    local namespaces can refer to all global and non-global file-level identifiers in the current file, 
    (but not parameters or local variables) whereas namespaces for other files can only refer to globals.
    Of course, you can easily make the above code go wrong in exactly the same way without any namespaces,
    it really is the implicit call that is dodgy, and not made any better or worse by using a namespace.
    
    Use p -lint to get warnings for implicit forward calls and auto-included builtins.

    Technically speaking, "namespace local" acts identically to an "include <thisfile> as local" statement, 
    except for the effect on external include statements when it is the first statement in the source file.

Performance Considerations: Variable Length Slice Assignment
=============================================================
The last thing I want is to leave you with the impression there is something 
wrong with variable length slice assignment: let me assure you that if you are
performing a single substitution, it <b><i>is</i></b> the very fastest method
possible. However, if you are performing thousands of substitutions on the same
piece of text (or whatever), there may be a much faster way. The statement

    s[j..k] = rep

is certainly easier to type, will never be slower, and (if enough space exists for 
an insitu replacement) can even exhibit exponentially better performance than:

    s = s[1..j-1]&rep&s[k+1..$]

However, if you are performing many thousands of substitutions on a single string, 
there may be even faster ways. Consider the following code:
    
    for i=length(tags) to 1 by -1 do
        {openidx,closeidx,rep} = tags[i]
        text[openidx..closeidx] = rep           -- <-- profile says 99.97%!!
    end for
    return text

vs:

    chunks = {}
    endtxt = length(text)
    for i=length(tags) to 1 by -1 do
        {openidx,closeidx,rep} = tags[i]
        chunks = append(chunks,rep&text[closeidx+1..endtxt])
        endtxt = openidx-1
    end for
    res = text[1..endtxt]
    for i=length(chunks) to 1 by -1 do
        res &= chunks[i]
    end for
    return res

Suppose there are thousands of tags (any kind of search/replace) and in most cases 
the replacement is a different length to whatever it is overwriting. In the first
code fragment, the last character of text will be moved thousands of times, whereas
in the second, each character is moved just twice. To put it another way, if you get
a high cost on a variable length slice assignment, the problem is unlikely to be the
way the builtin feature is implemented, but more probably the algorithm being used.
The above change came from a real program, and made it run about 20 times faster.

Of course if the performance hit is marginal, then by all means stick with the much 
clearer but ever-so-slightly-slower code, and obviously never bother with this kind
of optimisation until you actually see a big fat ugly percentage in a profile report.

Note that OpenEuphoria does not support variable length slice assignment, so if you
want code that runs on both you have to stick with the s[1..j-1]&rep&s[k+1..$] form,
other than that, the benefits of the second algorithm apply equally to both.

Optional semicolons
===================
All statements in Phix can optionally be terminated with a semicolon (;).
It is entirely a matter of personal choice, however in one case I had

            frealposn -= fend
>           frealposn = c_func(xSetFilePointer,{...}) -- known error here

where I had put the '>' in as a marker for something that needed fixing, as it 
could quickly be located in Edita by pressing F4, but then forgot all about it. 
The net result was a tricky bug that took me over 3 days to track down, not 
least because every time I wandered past that bit of code the "oh yeah, must 
do something about that (problem with files over 4GB) sometime - but I know 
that is not relevant right now since the file is nowhere near 4GB and besides 
that same (wrong setFilePointer) code [albeit without the '>'] works just fine 
in version-1 of this program" totally overwhelmed my puny human brain for some 
reason. A-A-A-Anyways, if only I had coded:

            frealposn -= fend;
>           frealposn = c_func(xSetFilePointer,{...})

Then a straightforward compilation error would have saved me those 3 days.

25/06/2010  Finally finished defaulted and named parameters.
            [DEV][DOC]:

            Defaulted Parameters
            ====================
            
            Specifying a default for a parameter makes it optional, eg:
            
                procedure p(integer i=37)

            which can be called using p() or p(5). Any non-defaulted parameters
            must be grouped together first (/on the left) and must always be 
            present on every call statement to the routine.
            
            The following default expressions are permitted:
            
                * (signed) literal integers
                * (signed) literal floats
                * literal strings
                * entirely-constant-only sequences
                * any single variable or constant name, including earlier params
                * length(<ditto>)
                * command_line()
            
            No operators of any kind are currently permitted, and the length()
            and command_line() are the only functions currently supported. While
            that may seem a bit harsh, there are sound reasons for keeping it as
            simple <sound of me choking here> and hence as bug-free as possible.

            That list was devised from analysing the std/ directory, and will
            be extended only when necessary. There was just the one case that is
            not supported, though easily worked round: regex.e uses the function 
            get_ovector_size() as a default - it is probably more readable and 
            debuggable after a simple and fairly obvious change.

        <aside>
            There is no way to determine how many parameters some external C or asm code
            has pushed onto the stack before invoking a call_back. Should you specify
            optional parameters on a call_back routine, the compiler will always assume
            the *maximum* number of parameters have been passed. Admittedly this is
            somewhat arbitrary, but either way it must make some kind of fixed assumption. 

            The recommendation (which may one day become enforced) is to provide some
            fixed-number-of-parameters-call-back-wrapper(s) for any routine with optional 
            parameters, eg:

            function somefunc(object a, object b=0)
                ...
            end function

            function CB_somefunc1(object a)
                return somefunc(a)
            end function

            function CB_somefunc2(object a, object b)
                return somefunc(a,b)
            end function

            and use either routine_id("CB_somefunc1") or routine_id("CB_somefunc2") as
            the parameter to call_back(), but never call_back(routine_id("somefunc")).

        </aside>

            If any routine has more than one defaulted parameter, is is usually
            a prime candidate for using named parameters, described next.


            Named Parameters
            ================

            Named Parameters allow values to be passed in any order, as long
            as all those needing to be present are specified somewhere. They
            are particularly useful in combination with multiple defaulted
            parameters.

            In the most verbose form, named parameters operate in a similar
            manner to namespaces. In the following paragraphs I use the term
            "paramspace" instead, to minimise any potential confusion.
            
                procedure someproc(object a, integer b)
                    ...
                end procedure
            
                someproc(someproc:b=5, someproc:a="thing")

            However, you may be pleased to learn/before you panic, there can
            be one and only one valid paramspace, hence we can omit it:
            
                someproc(:b=5, :a="thing")
            
            A minor syntactic tweak allows the more elegant (and recommended):
            
                someproc(b:=5, a:="thing")

            You should read the ":=" operator as "explicit assignment", not
            that it or the corresponding "==" (explicit test for equality)
            are widely implemented. Of course the "=" operator can stand for
            either, depending on context, however someproc(b=5,a="thing") is
            only ever going to pass two boolean 0/1 values, unless it causes
            a compilation error because there are no other a and b in scope,
            or perhaps a type error storing an integer in a sequence, etc.

            Technically, paramspaces are actually the inverse of namespaces; 
            the latter serve to disambiguate between multiple conflicting 
            globals already in scope, whereas the former serve to activate  
            an otherwise unavailable scope where the variable can be found.
            So namespaces solve the "too many" problem whereas paramspaces
            solve the "not any" problem.

            There seemed no particular reason to implement fully qualified
            namespace prefixes on defaulted parameter verbose paramspaces,
            however namespaces are perfectly valid elsewhere, eg/ie
            
                liba:proc(liba:proc:b=libb:func())

            is invalid (you may be relieved to hear!) but
            
                liba:proc(proc:b=libb:func())
                liba:proc(:b=libb:func())
                liba:proc(b:=libb:func())
            
            are fine, and can only be exactly what you meant anyway.

            Likewise there seemed no reason to interfere with the compiler&rsquo;s
            special treatment of routine_id(<literal string>); hence such as
            routine_id(:s="blah") and/or routine_id(routine_id:s="blah") is
            specifically NOT supported; the literal constant string would 
            not be resolved at compile-time as it would in the otherwise 
            equivalent routine_id("blah"). The program would work just fine,
            but the routine_id would be resolved at run-time rather than at
            compile-time.
            
            The use of named parameters on builtins/sources, or when calling 
            third party library code, is not generally advised anyway, since 
            names may change between releases. Unless of course the names are
            expressly part of the published interface.


            Remember:
            =========

            You need the ':' (and the actual parameter name).

            It is, of course, a leading ':' or a ':=' operator which serves
            to distinguish a paramspace / named parameter from a namespace.


            Example:
            ========
            
                function findit(object what, sequence table,
                                integer fromidx=1, integer toidx=length(table), 
                                integer direction=1, integer step=1)

            can be called using
            
                findit(x,xtable)
                findit(x,xtable,step:=2)
                findit(table:=xtable, step:=2, what:=x)
            
            In particular, the middle example is, I hope, much better than say 
            "findit(x,table,,,,2)", which Phix does not support and I have no 
            intention of ever implementing.

DEV/SUG: (this would be bloody messy!)
Optional multiple assignment
  {[a,b]} = c
or:
  {a,[b,c]} = d
but not:
  {a,[b,[c]]} = d
When pmain.e/

SUG:
<blockquote>
A "hash-include" instructs the compiler to make a best judgement call over actually including
the file, and (strongly) implies backend/runtime #ilASM content, eg:

    #include builtins\VM\pHeap.e

When compiling (-c specified on the command line) this behaves as a normal include, however 
when interpreting the compiler can elect to ignore the statement and use the copy of pHeap.e
which is already loaded as part of p.exe (or whatever) with obvious performance improvements.
Note that you cannot specify a namespace on a hash-include, and the compiler is at liberty to 
emit rather more cryptic than usual error messages and warnings when processing this statement, 
for example if it cannot tally the given filename with the set of pointers (entry points) that 
should all be non-null to safely skip it. Application code would not normally use this.
</blockquote>

Inline Assembly
===============
If you are new to programming you should definitely skip this section.
Ideally, all the inline assembly you should ever need has already been written.
For example, when you code a+b or length(s), there is a bit of code, somewhere, that actually
does the addition, or retrieves the length, and that will often be inline assembly. Obviously 
some trivial things like those just mentioned can often be converted directly to machine code, 
but more complicated stuff like s[i][j][k..l]:=t always invokes a standard routine. At times 
that will be hair-raisingly complicated stuff, and in fact almost always is, to most people. 
But it is just code, and with a little bit of patience, application, and determination, you 
too can be a low-level coding god (or godess).

The first thing to accept is that the Phix inline assembler is quite deliberately incomplete.
There is no point whatsoever trying to implement all of eg http://ref.x86asm.net/index.html
at least, that is, not without proper detailed testing of each and every new instruction.
A better idea is to make it as easy as possible to fill in the gaps as and when needed.

The assembler (pilasm.e) is littered with ?9/0 to guide you quickly to the place where more
code needs to be added. The assembler (pilasm.e) is deliberately completely separate from 
the disassembler (p2asm.e) because that way they validate each other and the chances of the
same mistake ocurring in both is greatly diminished. Again there are places the disassembler
could suffer improvement, most noticeably size qualifiers, and while generally speaking it
is miles ahead of the assembler, there must still be hundreds of unsupported instructions.

If you are completely new to assembly, then I should point you in the direction of FASM; for 
your convenience the standard distribution includes docs/fasm.txt as a general reference.

If you already have some assembly experience, you should accept that FASM/OllyDbg/FDBG as 
well as x86asm.net or similar are almost mandatory requirements to getting anything useful 
done. There are many thousands of lines of example/working/tested code in builtins\\VM\\*.*
and a quite helpful little community on the flatassembler message board.

If you were expecting me to explain what mov/lea/add/fyl2x/lgdt/psllw/stmxcsr/pmulhrsw
or whatever do, be sadly mistaken. See docs/fasm.txt, or your favourite search engine.

What I will do, however, is give a few quick examples and explain Phix-specific aspects.

    #ilASM{
        [32]
            mov eax,[a]
            add eax,[b]
            mov [c],eax
        [64]
            mov rax,[a]
            add rax,[b]
            mov [c],rax
        []
          }

That code snippet, albeit with woefully inadequate error checking, adds two integers
and stores the result. The "[32]" is an assembler directive that introduces code to
use on 32-bit target architectures, and "[64]" introduces the equivalent for 64-bit
architectures. Similar directives include PE32, PE64, ELF32, and ELF64. The final
"[]", in this case optional, is the directive meaning "all".

It should be clear that on a 32-bit architecture we mov eax,[a], whereas on a 64-bit
architecture we mov rax,[a]. Only one or the other instruction is generated. Labels
are subject to exactly the same processing, for example:

    #ilASM{
        [32]
          ::start
            mov eax,[a]
          ::error
            jmp :start
            jmp :error
        [64]
          ::start
            mov rax,[a]
            jmp :start
--          jmp :error
        []
          }

The "start" are different labels and no "already defined" error is generated, which
would be the case under overlapping guards. Likewise, as far as the 64-bit code is
concerned, there is simply no label named "error". You can of course declare labels
under [], which makes then available to everything. For my personal sanity, when I 
have a label Xxxx in 32-bit code, I make the equivalent in the 64-bit code Xxxx64.

Inline assembly can freely reference/modify normal hll variables ("[a]","[b]", etc)
however you should be aware that in many cases the hll-part of the compiler may use
constant propagation, and if you are not careful it will ignore your efforts to set
"[c]" using inline assembly, but treat it as the only constant it gets in hll code.
If, for example, you declare "integer c=0" with no other hll code setting the value
of c, your inline assembly may set the desired value in [c], only for the compiler
to bluntly not even read [c] but instead just use a literal "0" everywhere. Should
that be, for example, an "if c then", then the entire conditional branch may well 
be quietly optimised away. This behaviour can be avoided either by /never/ setting 
c in hll code or by setting it to a range of dummy values somewhere/how, to force 
the compiler to load it.

Refer to builtins\\VM\\pHeap.e for the low-level details about Phix hll variables.
Also, ::pGetMem in that file contains a summary of the various calling conventions.

labels,


At heart, Phix takes the terms "reinvent the wheel" and "not invented here" to a
whole new level.


==================================
Back to BRyan&rsquo;s topic:
BRyan said...

I think that there would be more contributions to Euphoria if some knowledgeable person

would document in "complete detailed" how to add a built-in "euphoria coded" function to the

source code.

This is one of the biggest stumbling blocks for the average user to contribute ideas.

The only documentation for adding to the source is still in a 2.x document which was

included by Rob years ago.

It&rsquo;s true that the documentation hasn&rsquo;t kept completely up with the code, and that&rsquo;s unfortunate. 
Largely from memory, here&rsquo;s what&rsquo;s required (maybe we can flesh this out and get it into the docs, or at least on the wiki):
* Add the new name to reswords.e, opnames.e, opnames.h, keylist.e, redef.e, include/euphoria/keywords.e 
* shift.e: add it into op_info, with metadata about the opcode for your built-in 
* Add a new case in emit.e, or add the handling for it to an existing, compatible case (i.e., functions with the same sort of parameters) 
* be_execute.c:
    add to appropriate place in code_set_pointers() 
    add to localjumptab 
    add case for execution to do_exec(), which may simply be a call to an implementation in be_runtime.c (which translated code could use, as well) 
* compile.e
    add handler for translating 
    put call to handler in init_opcodes() 
* execute.e
    add wrapper for execution 
    put call to wrapper in do_exec() 
* dis.e: add handler for your new function (it can probably use one of the generic formatters, unary, punary, binary, pbinary, etc) 
* Add documentation for your new routine in appropriate place (either a related std library file or a separate documentation file) 

Adding a keyword or other new language feature requires changes to parsing and possibly scanning, inlining and forward referencing, 
potentially in addition to all of the above. This is typically more difficult than adding a built-in routine. Machine procs/funcs are a bit simpler.

Matt

Technical issues using a 32-bit version of Phix to generate 64-bit applications.
===============================================================================
Of course it is paramount that a 32-bit version of Phix can create a 64-bit version of Phix (and vice versa),
so the source code of Phix itself carefully avoids anything that might cause problems. In particular, the 32bit
version of Phix uses 64bit floats with 53 bits of precision whereas the 64bit version uses 80bit floats, with 
64 bits of precision. As an example, the 32-bit version of Phix will treat the constant #80000000000000001 as 
if it were #80000000000000000


Consider this: /Is it a bug in the compiler?
<eucode>
        ifdef LINUX then
            extra_paths = getenv("HOME")
        elsifdef WIN32 then
            extra_paths = getenv("HOMEDRIVE") & getenv("HOMEPATH")
        end ifdef       
            
        if sequence(extra_paths) then
            search_list = append(search_list, extra_paths & SLASH)
        end if              
</eucode>
(I am not a fan of ifdef, btw, and only support the basics of it for compatibility with OpenEuphoria. If you 
 want to see some documentation for ifdef, go chew on the OpenEuphoria manual, sprinked with a pinch of salt.)
The (windows) compiler spits out probable logic error on the sequence(extra_paths) expression. Technically you
could argue it is a bug because the statement is valid on linux, but I assume you would get no such error there,
and in any case it highlights a subtly different problem: quite clearly you should not append any of {-1,"xxx"}, 
{"xxx",-1}, or {-1,-1} to search_list.


False positives (see also rectools) [DONE]
The Avast "EVO-GEN" heuristic has and still causes me some quite serious grief. If there is an executable file and it 
suddenly changes, I dunno, perhaps because you edited the source and recompiled it, then IT&rsquo;S A VIRUS (kinda like that
bloke who digs face-sized holes in the middle of the park so he can shout at the earthworms). Utterly ridiculous, of
course, but given the task they face with the state of the internet being what it is, you can&rsquo;t really blame them. All
you can do is submit yet another false positive report, and (very) slowly but surely things do get (a little) better.
Please be reasonable in your actions and expectations: do not post duplicates or otherwise harass anyone, and try to
limit new problems to a maximum of one a week or month. If there is a forum for your AV product, use it.

--DEV doc
--  Coding gotcha: Should you try something (at the top-level) like
--
--      #ilASM{:%Global}
--      sequence s = {1,2,3}  -- or any other known-at-compile-time-constant
--          <maul s>
--      #ilASM{ ret}
--
--  The compiler will apply "assignment on declaration" to s and assign it only once at compile-time,
--  and therefore most likely fail in some way on the second call to :%Global. Instead, separate any
--  variable declarations and initialisation cleanly, that is when you are effectively using #ilASM 
--  to interrupt the normal control flow of top-level statements:
--
--      sequence s
--      #ilASM{:%Global}
--          s = {1,2,3}
--          <maul s>
--      #ilASM{ ret}
--
--  Of course if you put the "= {1,2,3}" before :%Global, you should not be the least bit surprised
--  at the results.
--

A quick search of Phix\test\ (esp t46ltype) reveals dozens of "-- Added dd/mm/yy" 5-20 line snippets.
Should your code modifications break anything not already covered by the test set, you should add a
similar entry, even if you fix or back out your changes, especially if it took more than a moment to
determine precisely what the problem was.

Code Reviews
============
To review any of my code, simply open it in an editor of your choice, insert at the top something
like "CODE REVIEW &lt;name dd/mm/yy&gt;" and precede any notes with --&lt;name [date]&gt;, optionally close
them with --&lt;/name&gt;, and post the updated file back to me. Ideally place the &rsquo;--&lt;&rsquo;
in column 1.



Rules of thumb
Every good work of software starts by scratching a developers personal itch. 
Good programmers know what to write. Great ones know what to rewrite (and reuse). 
Plan to throw one away; you will, anyhow 
If you have the right attitude, interesting problems will find you. 
When you lose interest in a program, your last duty of call to it is to hand it off to a competent successor 
Treating your users as co-developers is your least-hassle route to rapid code improvement and effective debugging 
Release early. Release often. And listen to your customers. 
Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone. 
Smart data structures and dumb code works a lot better than the other way round. 
If you treat your beta-testers as if theyre your most valuable resource, they will respond by becomming your most valuable resource. 
The next best thing to having good ideas is recognizing good ideas from your users. Sometimes the latter is better. 
Often, the most striking and innovative solutions come from realizing that your concept of the problem was wrong. 
Perfection (in design) is achieved not when there is nothing more to add, but rather when there is nothing more to take away. 
Any tool should be useful in the expected way, but a truly great tool lends itself to uses you never expected. 
When writing gateway software of any kind, take pains to disturb the data stream as little as possible - and never throw away information unless the recipient forces you to! 
When your language is nowhere near Turing-complete, syntactic sugar can be your friend. 
A security system is only as secure as its secret. Beware of pseudo-secrets. 
To solve an interesting problem, start by finding a problem that is interesting to you. 
Provided the development coordinator has a medium at least as good as the Internet, and knows how to lead without coercion, many heads are inevitably better than one.

Abstraction is a wonderful thing - but it should be "skip details" not "tie both hands behind their back, chop the legs off at the knees, and make them deaf and blind".

I have added Listdir.bat and Listdir.reg to generate directory listings, originally taken from https://support.microsoft.com/en-us/kb/321379 but adjusted 
to use the Phix directory instead of %windir%, which hopefully avoids some additional permission denied errors. If you merge the .reg file then a new option
should be available on the right click drop-down in Explorer. Use Ctrl A to select all and Ctrl C to copy, then paste it somewhere more permanent.

Despite my own fondness for inline assembly, it is used quite sparingly within the sources of Phix:
p.exw for "SetBatchMode" and "interpret"
pEmit2.e for a few raw addresses/refs, rebuild_callback, and copying the optable
psym.e for s5thunk (a type-safe hack for setting/swapping s5)
Otherwise #ilASM is used extensively in builtins\, especially builtins\VM\, as obviuously at some
point you need a low-level runtime, for things like append(), and a few hundred others.
There are probably a misrepresentative number of uses of #ilASM in \test and \demo, but
even so, apart from Arwen32dib and pCom, I can only count 7 demos that use #ilASM, which
implies there must be 120 demos that do not. In fact I just had a double-take moment there as I 
quickly looked again at demo\arwendemo\mandel.exw [which admittedly did once use it for a while].

Memory leak checking
====================
There is an experimental (ie unfinished) memory leak checker built into the interpreter.
At the top of p.exw, you should find the constant MCHK = 0|1. This flag directly controls 
whether, later on in the same file, it creates a new stack/heap, calls :%RunCleanup, then
restores the original stack/heap and finally invokes check_heap(), which can be found in 
builtins\VM\pMemChk.e and creates C:\Program Files (x86)\Phix\memchk.txt before blurting
out a copy of that file on screen if the number of errors detected is not 0.

At the moment this only occurs for interpreted programs, and only if there is no trace or
profile occurring. Compiled programs would need to do the inverse, ie run the app, cleanup, 
then create a new stack/heap for check_heap. Since trace/profile are part of p.exe yet get
invoked from within the running app, ending up with a clean empty stack/heap is unlikely,
which is why I originally disabled the check when such occur. I may be wrong and it may all
be perfectly fine anyway, but I simply have not bothered to try it.

Further, builtins\VM\pcfuncN.e has to invoke builtins\VM\pStack.e\:%SetCCleanup to stop any
call_backs etc from being recorded as memory leaks, and there is quite a bit of fiddly code
in builtins\VM\pStack.e affecting the behaviour of :%opAbort.

Currently, when MCHK=1, interpretive self-hosting is quite broken (eg/ie "p p -test"), and
I would hazard a guess that is mainly down to the new code in pStack.e - actually, I take
that back, I now see that "p p -test" is (slightly less, but still) broken when MCHK=0...

As noted in the definition of MCHK, it is not yet possible to skip checks on :%pAlloc items
that have not been :%pFree's, ie/eg a constant x = allocate(n) will be reported as a memory
leak unless you explicitly free(x) somewhere, and specifically the l_MyAllocate() calls in
win32lib\w32support.e, and the whole of win32lib in general have not yet been addressed and
are unlikely to be any time soon. However all the demos for arwen and tinewg as included in
the package, along with edita and phix itself have been tested, but almost all other legacy
code run under MCHK=1 will most likely report errors.

Generally speaking, with the above mentioned exception of l_MyAllocate, most leaks reported
in memchk.txt are quite trivial to resolve. As an example, arwen.ew now has free(LVI/LV/lf/
TVI/TVIS) at the end of WinMain(), as fairly obviously the five lines where those items were
allocated were reported as culprits in said error log. Another example is arwen32dib, which
now needs a freeDib() call at the end of every application (and before any abort calls). In
time that may be replaced with something more like the pcfuncN.e\:%SetCCleanup method.

Enabling/disabling the memory leak checking could hardly be simpler: just change the MCHK
setting and run "p -cp".


Error trapping:
It is not simply a matter of scouring the (builtins/VM) sources and making sure that all
possible errors are trapped. In one instance I hit an int3 in pHeap.e/mergeone, caused by
the pRoot getting clobbered (to 0), and I added mov al,e32hc/jmp :!iDiag - however the
heap corruption was being detected within an opRetf, so the line number was meaningless
anyway, and it turned out the int3 was easier (natural in fact) to trap in fdbg.

In that particular case the debugging method was non-trival. Attempts to reduce the 
offending program to something nice and small failed (it quickly reached the point where
deleting one more line of a 3344-line program made the problem vanish). Plus, every time
I ran the program it allocated the heap somewhere new. I not only had to find pGtcb (at
#00402F18 in my case) and multiply that by 4 to look at the global pool header, but also
look at pNextcb: only then could I predict where the memory corruption was going to 
occur (I made several dry runs to figure that one out). Finally I re-ran it, trapping
earlier and earlier until I found a pre-corruption spot, then single-stepped it to
find the exact point of corruption, at which point the (length>maxlen) error became 
all too obvious.

I guess the point I am trying to make is that fancy (human readable) error handling
should only be attempted when it is a problem that must be fixed in the user code,
and any bugs in the backend should be left "raw".   --DEV is this e30?

By all means should you find suspect error handling in the backend code, you are more
than welcome to try and reproduce/trigger the problem you think it will/should cause,
and of course only if you succeed, and not before, is it time to try a fix. Once done
you should, if both practical and suitably short, add something to test\terror.

The following is a complete list of the run-time errors. I would very much hope that you 
would only very rarely feel the need to refer to this page. Two errors in particular,
e30ume and e32hc, indicate problems that need to be addressed in the backend. Generally
speaking, errors in hll code (your application or p.exw) should generate human-readable
messages, whereas errors in the low-level VM/runtime usually end up easier to debug if
that are left "raw", besides they don't really have a source line number in the same way 
that hll application code does (and/or it wouldn't help if they did).


SUG:
lambda()
In Phix, a lambda is simply an un-named and un-typed function. For example:
 ... ,lambda((integer x, integer y) return factorial(x-y)), ...
is equivalent to:
 function tmp895(integer x, integer y) return factorial(x-y) end function
 ... ,routine_id("tmp895"), ... 
Now you probably got what I meant when I said un-named. By un-typed I mean that there
is no official way to determine the number and type of parameters or the result. It 
is the programmer, not the compiler, who must ensure application to the correct number
and type of parameters, and the result is stored in an appropriately typed variable,
that is to avoid run-time errors.

There is (currently) no support for named parameters and the like on lambdas, but
routine_id (builtins\VM\prtnidN.e) and pmain.e\ParamList()\rest_must_be_named show
the basics, with the latter probably needing a hybrid symidx/string approach to
cover both interpretation (before and after trace, ouch) and compilation.

To avoid confusion, it is illegal to declare an identifier named lambdaNNN, where
NNN is any decimal integer. Of course simply adding an underscore or a trailing letter 
or whatever will make it perfectly legal. In the above example, the compiler would
of course internally generate lambda895 rather than tmp895.

The point of a lambda is to ease the declaration, rather than the use. A lambda can 
be stored in an integer (suggested names: rid, r_id) and applied using call_func().
Currying and the like would be performed explicitly, eg s = {rid1, 3.5, rid2}, and
it is entirely up to the programmer to use that appropriately.

--map(lambda x: 2*x , filter( lambda x:x%2==0, range(9) ) )
map(lambda((x) return 2*x), filter(lambda((x):return remainder(x,2)=0), tagset0(8)))

