<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Multiple Assignment</h1>
      <div id="mainSection">
        Sometimes it can be convenient to make several assignments in one statement, for example
<!--eucode>
    {a,b,c} = somefunc()
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">c</font><font color="#0000FF">} =</font><font color="#000000"> somefunc</font><font color="#0000FF">()</font>
</pre>
        is (functionally) the same as
<!--eucode>
    tmp = somefunc()
    c = tmp[3]
    b = tmp[2]
    a = tmp[1]
</eucode-->
<pre>
<font color="#000000">    tmp</font><font color="#0000FF"> =</font><font color="#000000"> somefunc</font><font color="#0000FF">()</font>
<font color="#000000">    c</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">3</font><font color="#0000FF">]</font>
<font color="#000000">    b</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">2</font><font color="#0000FF">]</font>
<font color="#000000">    a</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">1</font><font color="#0000FF">]</font>
</pre>
<!--
        Alternatively you may want to initialise several items to the same thing, eg
 <x!x--eucode>
    {names,dates,sizes} @= {}
 </eucode--x>
 <pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">names</font><font color="#0000FF">,</font><font color="#000000">dates</font><font color="#0000FF">,</font><font color="#000000">sizes</font><font color="#0000FF">} @= {}</font>
 </pre>
        which is functionally the same as
 <x!x--eucode>
    sizes = {}
    dates = {}
    names = {}
 </eucode--x>
 <pre>
<font color="#000000">    sizes</font><font color="#0000FF"> = {}
</font><font color="#000000">    dates</font><font color="#0000FF"> = {}
</font><font color="#000000">    names</font><font color="#0000FF"> = {}</font>
 </pre>
-->
        Like everywhere else, instead of the plainer "=" you can use ":=", which is normally pronounced "becomes equal to".<br>
        <!--, whereas "@=" is normally pronounced "all become equal to".-->
        The comparison form of "=", "==", which is normally pronounced "is equal to", is not used anywhere else on this page.
       <br>
       <br>
<!--        You can also nest (to any level) and combine the two types of multiple assignment: -->
        You can also nest multiple assignment to any level:
<!--eucode>
    {{a,b},{c,d}} := {{1,2},{3,4}}      -- (becomes equal to)
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#800000">{</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#800000">}</font><font color="#0000FF">} := {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}     </font><font color="#000080"><i> -- (becomes equal to)</i></font>
</pre>
        is functionally equivalent to
<!--eucode>
    {c,d} := {3,4}
    {a,b} := {1,2}
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#0000FF">} := {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#0000FF">}
    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">} := {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">}</font>
</pre>
        which in turn is functionally equivalent (as are '=' and ':=' in this context) to
<!--eucode>
    d = 4
    c = 3
    b = 2
    a = 1
</eucode-->
<pre>
<font color="#000000">    d</font><font color="#0000FF"> =</font><font color="#000000"> 4
    c</font><font color="#0000FF"> =</font><font color="#000000"> 3
    b</font><font color="#0000FF"> =</font><font color="#000000"> 2
    a</font><font color="#0000FF"> =</font><font color="#000000"> 1</font>
</pre>
<!--
        whereas
 <x!x--eucode>
    {{a,b},{c,d}} @= {{1,2},{3,4}}      -- (all become equal to)
 </eucode--x>
 <pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#800000">{</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#800000">}</font><font color="#0000FF">} @= {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}     </font><font color="#000080"><i> -- (all become equal to)</i></font>
 </pre>
        is functionally equivalent to (any nested multiple assignments are always the plainer "="/":=")
 <x!x--eucode>
    {c,d} = {{1,2},{3,4}}
    {a,b} = {{1,2},{3,4}}
 </eucode--x>
 <pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#0000FF">} = {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}
    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">} = {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}</font>
 </pre>
        which is the same as
 <x!x--eucode>
    d = {3,4}
    c = {1,2}
    b = {3,4}
    a = {1,2}
 </eucode--x>
 <pre>
<font color="#000000">    d</font><font color="#0000FF"> = {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#0000FF">}
</font><font color="#000000">    c</font><font color="#0000FF"> = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">}
</font><font color="#000000">    b</font><font color="#0000FF"> = {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#0000FF">}
</font><font color="#000000">    a</font><font color="#0000FF"> = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">}</font>
 </pre>
-->
        Subscripts and slices are also permitted (nb only subscripts not slices not under <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a>); if s is {1,2,3,4} then
<!--eucode>
    {s[1],s[2..$]} = {s[$],s[1..$-1]}
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">1</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">2</font><font color="#0000FF">..</font><font color="#000000">$</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">$</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">1</font><font color="#0000FF">..</font><font color="#000000">$</font><font color="#0000FF">-</font><font color="#000000">1</font><font color="#800000">]</font><font color="#0000FF">}</font>
</pre>
        leaves s as {4,1,2,3}. It would require named temporary variables to achieve the same
        thing using multiple statements, whereas the above form uses unnamed temps, which, 
        obviously enough, need not (and indeed cannot) be declared. However see performance 
        notes below (multiple assignment is designed for comfort and convenience not speed).
       <br>
       <br>
        As well as the syntax previously shown in <a href="variables.htm">Variables</a> and <a href="constants.htm">Constants</a>,
        you can also declare variables as part of (/mid-) multiple assignment, eg
<!--eucode>
    {string name, integer id} = lookup()
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#004080">string</font><font color="#000000"> name</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> id</font><font color="#0000FF">} =</font><font color="#000000"> lookup</font><font color="#0000FF">()</font>
</pre>
        however sub-types do /NOT/ propagate/carry-over-commas as you might expect, eg:
<!--eucode>
    {a, string b, c} = lookup()
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#004080"> string</font><font color="#000000"> b</font><font color="#0000FF">,</font><font color="#000000"> c</font><font color="#0000FF">} =</font><font color="#000000"> lookup</font><font color="#0000FF">()</font>
</pre>
        will terminate in error if b already exists, or if a <i>/<b>or c</b>/</i> does not already exist. 
        Use "string b, string c" instead, along with whatever you might need to do for a.
        While string {a, b, c} propagates the type, and declares three new variables of type string, 
        that does <i>/not/</i> happen for types inside the {}, except when the type immediately 
        precedes an opening/nested '{'. Admittedly this is a simple practical choice/implementation 
        detail (see pmain.e/GetMultiAssignSet()) that it may be possible to improve upon, but there 
        are four competing use cases for that routine, hence the simplest solution won (being reset 
        after every comma). Also, constructs such as string {a, integer b, c} are treated as nonsense 
        and trigger an error, but obviously you can simply move the "string" inside the {}, in that 
        particular case twice.
        <br>
        <br>
        Also note that "mid-lhs" declarations are not supported by <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a>,
        in other words you cannot mix new declarations and pre-existing variables on the left hand side,
        instead they have to be all new or all pre-existing. It is of course trivial to change (say)
        <code>{a, string b, c} = <i>expr</i></code> by splitting it into two statements: <code>string b; {a,b,c} = <i>expr</i></code>,
        which will make it p2js-compatible. Since JavaScript is a <i><a href="glossary.htm#typeless">typeless</a></i> language it 
        really couldn&rsquo;t care much less about (the types in) say <code>{integer i, string b} = <i>expr</i></code>, but (unlike 
        Phix) it does <i>not</i> allow say <code>[a, let b]</code> syntax or anything similar (that I could find), although 
        <code>let [a, b]</code> is fine.
       <br>
       <br>
        Use '{}' (or '?') to omit elements
<!--eucode>
    {a,{},c} = {1,2,3}
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#800000">{}</font><font color="#0000FF">,</font><font color="#000000">c</font><font color="#0000FF">} = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">,</font><font color="#000000">3</font><font color="#0000FF">}</font>
</pre>
        is functionally the same as
<!--eucode>
    c = 3
    a = 1
</eucode-->
<pre>
<font color="#000000">    c</font><font color="#0000FF"> =</font><font color="#000000"> 3
    a</font><font color="#0000FF"> =</font><font color="#000000"> 1</font>
</pre>
        and ditto for "{a,?,c} = {1,2,3}".
       <br>
       <br>
        You can also omit everything:
<!--eucode>
    {} = f()
</eucode-->
<pre>
<font color="#0000FF">    {} =</font><font color="#000000"> f</font><font color="#0000FF">()</font>
</pre>
        which explicitly discards the result of the function call. Alternatively if you prefer
        <code>{?} = f()</code>
        has exactly the same effect (however
        <code>? = f()</code> is not legal syntax). Note that Euphoria (imnsho wrongly) allows /implicit/ discarding of function results, 
        which Phix does not, whereas, cmiiw, Euphoria does not support any of the subscripting, nesting, "{}=", ":=", or "==" forms 
<!--"@=", -->
        of (multiple) assignment that Phix does.
       <br>
       <br>
        Like all powerful programming constructs, multiple assigment can be used to make things easier, but it can 
        also be abused to make things much more difficult than they need to be.
       <br>
       <br>
        <h2>How NOT to use multiple assigment</h2>
        You may be wondering why I appear to have written the equivalents "backwards".
        Any subscripts on the lhs are pushed onto opstack (in pmain.e) from left to right, hence the assignments are 
        always performed from right to left to pick up any subscripts from the top of the stack, in the right order. 
        (Actually, there is an exception to that rule, as explained in the <a href="#tech" onclick="opentech()">technicalia</a> section below.)
        Of course relying on such subtleties would constitute very bad practice, and in reality that is a fairly
        trivial implementation detail that could fairly easily be changed, if it ever proves necessary that is.
       <br>
       <br>
        One case where this may trip you is:
<!--eucode>
    {main,mainHwnd} = {create(Window,...),getHwnd(main)} -- error!
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">main</font><font color="#0000FF">,</font><font color="#000000">mainHwnd</font><font color="#0000FF">} = {</font><font color="#800000">create(</font><font color="#000000">Window</font><font color="#0000FF">,...</font><font color="#800000">)</font><font color="#0000FF">,</font><font color="#7060A8">getHwnd</font><font color="#800000">(</font><font color="#000000">main</font><font color="#800000">)</font><font color="#0000FF">}</font><font color="#000080"><i> -- error!</i></font>
</pre>
        Obviously you could rewrite that statement the other way round, but to quote Brian Kernighan:
        <blockquote>
            &ldquo;Debugging is twice as hard as writing the code in the first place. Therefore if you write the code 
            as cleverly as possible, you are, by definition, not smart enough to debug it.&rdquo;
        </blockquote>
        <b>Update</b>: actually, you <i>cannot</i> write that "the other way round". Further illustrating the 
        "not smart enough" point, I failed to spot that the rhs is constructed in its entireity before any assignments 
        on the lhs, hence main would be unassigned whichever way round things were done [ie, as mentioned elsewhere, 
        you should <b><i>never</i></b> try to both modify and reference the same variable in a single statement, in 
        <i>any</i> programming language].
       <br>
       <br>
<!--
        At this point it is worth noting that using all of these features together in
        one statement could easily create completely unreadable code; ideally they
        should be used wisely to make code clearer rather than harder to understand.
        I should also warn you that I am just about to push the boundaries of what is 
        and is not possible with multiple assignment, and I trust it is understood
        that any "bad/ugly/confusing" stuff should be avoided at all costs.
       <br>
       <br>
        The first example of such things that springs to mind is the slightly dodgy:
-->
        Another example is:
<!--eucode>
    {idx, s[idx]} = <something>
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">idx</font><font color="#0000FF">,</font><font color="#000000"> s</font><font color="#800000">[</font><font color="#000000">idx</font><font color="#800000">]</font><font color="#0000FF">} = &lt;</font><font color="#000000">something</font><font color="#0000FF">&gt;</font>
</pre>
        Clearly someone could read that and assume it is setting a new idx and then using that new idx to index s, 
        but it uses the old value, again because of the right-to-left ordering (or nor, as per update above), and 
        in fact it is technically undefined behaviour, because the compiler is at liberty to save either the address
        or content of idx before it stores it, that is according to the language specification (which in this case 
        is that very sentence you just read).<br>
        Avoid, ie use appropriately named temps (enjoying the extra clarity they provide) and split such things 
        into several separate and simpler statements.
       <br>
       <br>
        Certainly the lhs should never rely on something having "already happened" on 
        the rhs, or otherwise attempt to modify something twice in a single statement,
        except for "static" subscripts. As an example to clarify that last point, if
        you try to make various substitutions in say "The [noun] [verb] the [object]",
        all in a single statement and possibly in any order, and further the lengths 
        and positions all change several times mid-statement, expect problems! Do them
        one at a time, and figure out where things are, after, rather than before they
        have moved(!!), and it should all be plain sailing.
       <blockquote>
    &lt;aside&gt;
        <br>
        <br>
        OK, to further clarify that, consider this longhand version:
<!--eucode>
            --       --1--  --2--         ---3---
            s = "The [noun] [verb] on the [object]"
            --   123456789012345678901234567890123
            s[26..33] = "mat"   -- 3
            s[12..17] = "sat"   -- 2
            s[5..10] = "cat"    -- 1
</eucode-->
<pre>
<font color="#000080"><i>            --       --1--  --2--         ---3---</i></font>
<font color="#000000">            s</font><font color="#0000FF"> =</font><font color="#008000"> "The [noun] [verb] on the [object]"</font>
<font color="#000080"><i>            --   123456789012345678901234567890123</i></font>
<font color="#000000">            s</font><font color="#0000FF">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#0000FF">] =</font><font color="#008000"> "mat"  </font><font color="#000080"><i> -- 3</i></font>
<font color="#000000">            s</font><font color="#0000FF">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#0000FF">] =</font><font color="#008000"> "sat"  </font><font color="#000080"><i> -- 2</i></font>
<font color="#000000">            s</font><font color="#0000FF">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#0000FF">] =</font><font color="#008000"> "cat"   </font><font color="#000080"><i> -- 1</i></font>
</pre>
        which is fine, but you should <i>really</i> avoid this nastiness:
<!--eucode>
            {s[26..33],s[12..17],s[5..10]} = {"mat","sat","cat"}
</eucode-->
<pre>
<font color="#0000FF">            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">}</font>
</pre>
        or this nasty mess:
<!--eucode>
            {s[5..10],s[12..17],s[26..33]} = {"cat","sat","mat"}
</eucode-->
<pre>
<font color="#0000FF">            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">}</font>
</pre>
        I bet that intuitively, if told one of them does not work most people would 
        assume the first works but the second does not, when in fact it is the other 
        way round. Few people would (immediately) understand what I have done with 
        the indexes to get (/force) these alternatives to work:
<!--eucode>
            {s[20..27],s[9..14],s[5..10]} = {"mat","sat","cat"}
            {s[20..27],s[5..10],s[12..17]} = {"mat","cat","sat"}
            {s[9..14],s[23..30],s[5..10]} = {"sat","mat","cat"}
            {s[9..14],s[5..10],s[26..33]} = {"sat","cat","mat"}
            {s[5..10],s[23..30],s[12..17]} = {"cat","mat","sat"}
</eucode-->
<pre>
<font color="#0000FF">            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">20</font><font color="#0000FF">..</font><font color="#000000">27</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">9</font><font color="#0000FF">..</font><font color="#000000">14</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">20</font><font color="#0000FF">..</font><font color="#000000">27</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">9</font><font color="#0000FF">..</font><font color="#000000">14</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">23</font><font color="#0000FF">..</font><font color="#000000">30</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">9</font><font color="#0000FF">..</font><font color="#000000">14</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">23</font><font color="#0000FF">..</font><font color="#000000">30</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">}</font>
</pre>
        Notice how "mat" goes to s[20..27], s[23..30] or s[26..33].
        Of course in a real world program, we would not normally use fixed literal integers but the results from 
        <a href="find.htm">find</a>() or <a href="match.htm">match</a>(), and dynamically apply adjustments to those results. 
        Technically it can be made to work, but regardless this sort of stuff is truly horrid, so (except perhaps when 
        participating in a code obfuscation contest) <i>don&rsquo;t do it!</i>
        <br>
        <br>
    &lt;/aside&gt;
       </blockquote>

        Another example occured when writing the
       <a href="javascript:ExternalLink('ext338');" id="ext338" 
          style="color:#9B5565">http://rosettacode.org/wiki/Reduced_row_echelon_form#Phix</a> entry. I tried to replace
<!--eucode>
sequence temp
        temp = M[i]
        M[i] = M[r]
        M[r] = sq_div(temp,temp[lead])
</eucode-->
<pre>
<font color="#004080">sequence</font><font color="#000000"> temp
        temp</font><font color="#0000FF"> =</font><font color="#000000"> M</font><font color="#0000FF">[</font><font color="#000000">i</font><font color="#0000FF">]</font>
<font color="#000000">        M</font><font color="#0000FF">[</font><font color="#000000">i</font><font color="#0000FF">] =</font><font color="#000000"> M</font><font color="#0000FF">[</font><font color="#000000">r</font><font color="#0000FF">]</font>
<font color="#000000">        M</font><font color="#0000FF">[</font><font color="#000000">r</font><font color="#0000FF">] =</font><font color="#7060A8"> sq_div</font><font color="#0000FF">(</font><font color="#000000">temp</font><font color="#0000FF">,</font><font color="#000000">temp</font><font color="#800000">[</font><font color="#000000">lead</font><font color="#800000">]</font><font color="#0000FF">)</font>
</pre>
        with
<!--eucode>
        {M[i],M[r]} = {M[r],sq_div(M[i],M[i][lead])
</eucode-->
<pre>
<font color="#0000FF">        {</font><font color="#000000">M</font><font color="#800000">[</font><font color="#000000">i</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">M</font><font color="#800000">[</font><font color="#000000">r</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#000000">M</font><font color="#800000">[</font><font color="#000000">r</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#7060A8">sq_div</font><font color="#800000">(</font><font color="#000000">M</font><font color="#800080">[</font><font color="#000000">i</font><font color="#800080">]</font><font color="#0000FF">,</font><font color="#000000">M</font><font color="#800080">[</font><font color="#000000">i</font><font color="#800080">][</font><font color="#000000">lead</font><font color="#800080">]</font><font color="#800000">)</font>
</pre>
        It failed miserably when i=r, for the same "right to left" reasons (there is
        nothing wrong with the rhs per se, but the lhs overwrites in the wrong order).
        If it was my code to maintain, I would probably leave the top version in, but
        after some consideration I decided that a fixed version of the one-liner, with 
        an appropriate comment, was probably the more useful thing in that particular
        instance.
       <br>
       <br>
        The "{s[1],s[2..$]} = {s[$],s[1..$-1]}" example already given is perhaps the
        most complex thing that can be considered "static" subscripts. No s[i] is
        updated twice and there is no confusion or dependency on any destination, 
        though admittedly it relies on all "gathering" occuring before any update, 
        which is a general rule for all forms of assignment anyway. (And I should
        quickly remind you, again, to check out the performance notes below before 
        considering using such a statement.)
       <br>
       <br>
       <h2>Performance notes</h2>
        Multiple assignment is ideally suited to function results and table entries.
        If you are using {} or & on the rhs (at the top level) of a multiple assigmnent
        statement, then a longhand version would almost certainly be slightly faster, 
        due to the creation and subscripting of the temporary sequence being absent, 
        though obviously any such overhead is insignificant except in the most 
        crititical of inner loops, and as always there is no point pre-emptively 
        optimising anything unless profiling shows it really is expending some real 
        effort and time there.
       <br>
       <br>
        The "{s[1],s[2..$]} = {s[$],s[1..$-1]}" example given above obviously creates 
        an entirely new copy of s in a new temporary sequence, then copies it all back, 
        whereas "z = s[$], s = s[1..$-1], s = prepend(s,z)" can do things "in situ",
        and therefore exhibit exponetially better performance on very long sequences.
        Also worth noting is that "{s} = {append(s,stuff)}" will thwart optimisations
        that can get applied to the simpler "s = append(s,stuff)". Other cases exist.
       <br>
       <br>
        This is the reason I have used "functionally" quite excessively in this section,
        because the actual code emitted may be quite different, though it will achieve
        the same results. The compiler makes some attempts to avoid any such overheads, 
        but (as just shown) there are limits to what it can reasonably do. You may like
        to compare the list.asm from "p -d -nodiag t57" with and without the test flag
        "testemitONis0" being set.
       <br>
       <br>
        Another common idiom worth mentioning is the simple swap (see also the <a href="#tech" onclick="opentech()">technicalia</a> dropdown below):
<!--eucode>
    {a,b} = {b,a}
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">} = {</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">a</font><font color="#0000FF">}</font>
</pre>
<!--
        which, as you probably already know and ignoring any (integer-only) xor tricks,
        has no longhand equivalent that does not use a (named) temporary variable. But
 <x!x--eucode>
    tmp := b
    b := a
    a := tmp
 </eucode--x>
 <pre>
<font color="#000000">    tmp</font><font color="#0000FF"> :=</font><font color="#000000"> b
    b</font><font color="#0000FF"> :=</font><font color="#000000"> a
    a</font><font color="#0000FF"> :=</font><font color="#000000"> tmp</font>
 </pre>
        is noticeably faster (in a pointless benchmark) than the code the one-liner generates:
 <x!x--eucode>
    tmp = {b,a}
    b = tmp[2]
    a = tmp[1]
 </eucode--x>
 <pre>
<font color="#000000">    tmp</font><font color="#0000FF"> = {</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">a</font><font color="#0000FF">}</font>
<font color="#000000">    b</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">2</font><font color="#0000FF">]</font>
<font color="#000000">    a</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">1</font><font color="#0000FF">]</font>
 </pre>
-->
        As of version 1.0.0 the compiler tries very hard to optimise away any potential performance overheads,
        by not actually creating a temporary sequence, or subseuently subscripting it, but if in any doubt, test.
        <br>
        <br>
        It would also be quite wrong to believe that additional variables always introduce unnecessary overhead. <br>
        In fact the compiler often has to introduce an unnamed temporary which has /exactly/ the same costs as a named variable. <br>
        <small>(OK, except for your program being a few bytes larger because somewhere it has "your_temp_name" instead of -1.)</small><br>
        Apart from the disadvantage of having to declare s (oh the humanity), the advantage to say
<!--eucode>
    s = f(...)
    {...} = s
</eucode-->
<pre>
<font color="#000000">    s</font><font color="#0000FF"> =</font><font color="#000000"> f</font><font color="#0000FF">(...)
    {...} =</font><font color="#000000"> s</font>
</pre>
        is that an ex.err may contain some extra valuable and time saving information, even moreso if you give it a decent name.<br>
        It would not normally be any slower (or faster) than the one-line version.<br>
        In some cases, however, you may need to explicitly deassign ("s:={}") to avoid some hidden refcounting issue that 
        the one-liner does not exhibit: the compiler aggressively trashes unnamed temps in a way that it obviously will not 
        attempt on named variables, so adding one may trigger a refcount issue.<br>
        Conversely sometimes such an explicit deassign may circumvent a compiler refcount issue (/bug), which is 
        effectively/technically "unfixable" when using an unnamed temp, except perhaps by reporting it and waiting.
       <br>
       <br>
       <h2>Deprecated</h2>
        Prior to version 1.0.1 an "all-equal" or "@=" form of assignment was supported, however it was not p2js-compatible
        and not very widely used, and to be frank rather ugly, so it now produces a p2js violation (compilation error) under 
        with js and a warning when not, and may be removed completely in a future release. 
        The <a href="#tech" onclick="opentech()">technicalia</a> dropdown below has also been significantly simplified.
       <br>
       <br>
       <table>
        <col style="width: 8%"/>
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="variables.htm">variables</a>,
          <a href="constants.htm">constants</a><br>
          <a name=tech></a>
         </td>
        </tr>
        <tr id="Technicalia" style="display:none;">
         <td>
          <a href="glossary.htm#technicalia">
           <b>Technicalia</b>
          </a>
         </td>
         <td>
<!--
            There is a minor implementation caveat with "all equal": at least one of the protagonists must be a plain named variable (or the rhs a constant):
            <br>
            <br>
 <x!x--eucode>
    {a[i],b[j]} @= f()
 </eucode--x>
 <pre>
<font color="#0000FF">    {</font><font color="#000000">a</font><font color="#800000">[</font><font color="#000000">i</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#800000">[</font><font color="#000000">j</font><font color="#800000">]</font><font color="#0000FF">} @=</font><font color="#000000"> f</font><font color="#0000FF">()</font>
 </pre>
          <br>
            triggers the error "sorry, construct requires at least one plain var".
            The trouble is that the result of f() ends up in an un-named temporary, and moving 
            anything out of an un-named temporary (as a generally applied optimisation) avoids 
            an unnecessary incref by h4-ing the temp, leading to failure on the second attempt 
            to use the un-named temporary.
          <br>
          <br>
            In a statement such as
          <code>{a[i],b,c[k]} @= f()</code>, the compiler performs 
            the
          <code>b=f()</code> first, and uses b instead of the unnamed temp for the 
            remaining assignments. However when nothing with a name is available, then you 
            get the above error. Using additional un-named temps would not help; adding 
            "don't apply that optimisation" flags would get real messy real quick. There are
            (thankfully) no other language constructs that lead to this kind of error.
          <br>
          <br>
            Should this get really irksome, we /could/ (possibly) enhance the compiler to
            automatically perform
          <code>a[i] = b[j]</code> to complete the operation, but 
            unless we /really/ have to, I&rsquo;d prefer to avoid such complications. Bearing in 
            mind that we might have to repeat that trick for several terms, the difficulty 
            of adequate testing, the probability of adding further bugs, that it does not
            add any performance overhead, and that it potentially makes debugging easier, 
            it just seems better all round to force the programmer to use a named variable 
            to store the result of f() (or any other rhs expression).
          <br>
          <br>
-->
            There is also an implementation detail (by comparison utterly trivial) for normal multiple assignment that I feel 
            I should at least document. Should the rhs be a plain variable, and further should it be assigned on the left, the 
            compiler automatically uses a temporary variable to avoid out-of-order operations (on the rhs, with that right-to-left 
            thing) yielding unexpected results, eg/ie:
            <br>
            <br>
<!--eucode>
    {a,b,c} = b
</eucode-->
<pre>
<font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">c</font><font color="#0000FF">} =</font><font color="#000000"> b</font>
</pre>
          <br>
            is equivalent to/implemented as
            <br>
            <br>
<!--eucode>
    c = b[3]
    tmp = b
    b = tmp[2]
    a = tmp[1]
</eucode-->
<pre>
<font color="#000000">    c</font><font color="#0000FF"> =</font><font color="#000000"> b</font><font color="#0000FF">[</font><font color="#000000">3</font><font color="#0000FF">]</font>
<font color="#000000">    tmp</font><font color="#0000FF"> =</font><font color="#000000"> b
    b</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">2</font><font color="#0000FF">]</font>
<font color="#000000">    a</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">1</font><font color="#0000FF">]</font>
</pre>
          <br>
<!--
            (because tmp is always subscripted, it is not subject to the same optimisation 
            trouble that we just saw in the "all equal" case above.) 
-->
            Obviously the compiler tries (hard) to avoid using a un-named temp unless it has no choice.
          <br>
          <br>
            Also note that in a silly statement such as <code>{a,b,b,a} = {1,2,3,4}</code> the result is formally undefined. Almost certainly
            a will be either 1 or 4 and b will end up either 2 or 3, but any implementation that yields any of the four possible results, or
            in fact anything else, is at least technically <i>adhereing to the language specification</i>. There is certainly no guarantee that
            whatever result it gives on desktop/Phix would be matched by <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a>, nor have 
            I bothered to check what if anything the official ECMAScript specifications have to say on such matters, and it would not surprise
            me in the least should it get different results on different browsers.
          <br>
          <br>
            <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a>: implements multiple assignment as Array destructuring. While the latter
            supports subscripts, in JavaScript slices are performed using s.s[p]lice() and hence slices on the lhs are not permitted/supported, 
            (eg <small><code>{s[i..j]} = x</code></small>), which is thankfully a pretty rare and slightly odd thing to do anyway. Also, JavaScript
            uses String.codePointAt() rather than s[idx] to extract a single (unicode) character, which I can handle, but replacing a character in 
            say <code>s[idx] = ch</code> is performed via <code>s = s.substring(0,idx-1) + String.fromCodePoint(ch) + s.substring(idx);</code>,
            which is certainly not part of <i>Array</i> destructuring and is therefore not and never will be supported (for strings, that is, it
            works fine for replacing individual elements of dword-sequences but you cannot set a character of a string, or a slice of anything, 
            in the lhs of a multiple assignment statement under pwa/p2js).
<!-- (for some reason I was thinking that lhs subscripts were not permitted...)
            <br>
            On reviewing this documentation several years after it was first written, I feel compelled to remark on the number of problems and caveats
            that allowing subscripts in multiple assignments introduces, so maybe that is not such a bad thing, then again a little subscript here and
            there when slapping out a quick n&rsquo; dirty can be mightly handy.
-->
          <br>
          <br>
         </td>
        </tr>
       </table>
       <img id="Timg" src="images/sprites/tech.open.png" title="Expand/Shrink" alt="Expand/Shrink" style="display:block;clear:both;" onload="setStartT(this);" onclick="changeImageT(this);" />
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
