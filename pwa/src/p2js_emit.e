--
-- pwa\src\p2js_basics.e
-- ======================
--
--  implements generate_source(sequence ast, integer lang, bool bHtml)
--
constant html_headerf = """
<!DOCTYPE html>
<html lang="en" >
 <head>
  <meta charset='utf-8'/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>%%s</title>%s
 </head>
 <body style="font-family: monospace;">
  <script src="p2js.js"></script>%%s%s
  <script>
""",
        html_headerp = sprintf(html_headerf,{"",""}),
        html_headerg = sprintf(html_headerf,
{'\n'&`  <link type="text/css" rel="stylesheet" media="screen" href="pGUI.css" />`,
 "%%s\n"&`  <script src="pGUI.js"></script>`}),
        use_strict = """
"use strict";
// auto-generated by pwa/p2js.
""",
        html_footer = """
  </script>
 </body>
</html>
""",
    MASSS = MASS&"",
    xpjs = columnize({{"{",             `["sequence",`},
                      {"}",             "]"},
                      {MASSS,           "[,"},
                      {" then",         " {"},
                      {" do",           " {"},
                      {"elsif ",        "} else if "},
                      {"else",          "} else {"},
                      {"end if",        "}"},
                      {"end for",       "}"},
                      {"end while",     "}"},
                      {"exit",          "break;"},
                      {"break",         "break;"},
                      {"fallthrough",   "/*fallthrough*/"},
                      {"end switch",    "}"},
                      {"function",      "function"},
                      {"end function",  "}"},
                      {"procedure",     "function"},
                      {"end procedure", "}"},
                      {"type",          "function"},
                      {"end type",      "}"},
                      {"and",           "&&"},
                      {"or",            "||"}}),
    nl = '\n'

bool bGUI = false
integer initp = 0,
        wasext = 0,
        tokline = 0
string output = "", oneline = ""

function xl(string s)
--  if not is_phix() then
    if is_js() then
--  or is_html() then
        integer xdx = find(s,xpjs[PHIX])
        s = xpjs[JSS][xdx]
    elsif s=MASSS and is_phix() then
        s = "{"
    elsif wasext!=PHIX then
        if s="||" then s = "or" end if
        if s="&&" then s = "and" end if
    end if
    return s
end function

function sp(integer nodetype)
    return " " & tok_name(nodetype) & " "
end function

function xlsp(integer nodetype)
    return " " & xl(tok_name(nodetype)) & " "
end function

--integer prevline = 0

procedure flush_oneline()
    if length(oneline) then
        if oneline[$]!=nl then
            oneline &= nl
        end if
--NO:
--      if tokline>prevline+1 then
--          oneline &= nl
--          prevline = tokline
--      end if
        output &= oneline
        oneline = ""
    end if
end procedure

--bool filter_comments = false

procedure dent(object s, integer indent)
    flush_oneline()
--  if filter_comments then s = substitute_all(s,{"/*","*/"},{"/!*","*!/"}) end if
    oneline = repeat(' ',indent) & s
end procedure

integer prevline
procedure softdent(object s, integer indent)
    -- prevline must be set before call...
--  if filter_comments then s = substitute_all(s,{"/*","*/"},{"/!*","*!/"}) end if
    if length(oneline) then
        if tokline=prevline
--      and (length(oneline)=0 or not find(oneline[$],"};")) then
        and (length(oneline)=0 or oneline[$]!='}') then
            if oneline[$]!=' ' then oneline &= ' ' end if
            oneline &= s
            return
        end if
        oneline &= nl
--erm, certainly not mid-statement...
--      if tokline>prevline+1 then
--          oneline &= nl
--      end if
        output &= oneline
        oneline = ""
    end if
    oneline = repeat(' ',indent) & s
    prevline = tokline
end procedure

procedure cdent(string comment, integer nodetype, line, col)
    -- Output a line or block comment, which may or may not
    -- have some preceding code on the same line. Note this 
    -- must cope with both standalone & /*inline*/ comments
    if is_phix() then
        if nodetype=COMMENT then
            if comment[1..2] = "//" then
                comment[1..2] = "--"
            end if
        end if
    else
        if nodetype=COMMENT then
            if comment[1..2] = "--" then
                comment[1..2] = "//"
            end if
        elsif comment[1..4] = "--/*" then
            comment[1..4] = "/*"
            if comment[-4..-1]="--*/" then
                -- ("--/**/" is a valid/common not-RDS thing...)
                comment[-4..-1] = "*/"
            end if
        end if      
--      if filter_comments then comment = substitute_all(comment,{"/*","*/"},{"/!*","*!/"}) end if
    end if
    if line>tokline then
        oneline &= nl
        oneline &= repeat(' ',max(0,col))
        if nodetype=BLK_CMT then
            output &= oneline
            output &= comment
            output &= nl
            tokline = line+1
            oneline = ""
        else
            tokline = line
        end if
    elsif nodetype=COMMENT then
        oneline &= repeat(' ',max(length(oneline)>0,col-length(oneline)))
    else
        oneline &= ' '
        oneline &= comment
        oneline &= ' '
    end if      
    if nodetype=COMMENT then
        output &= oneline
        output &= comment
        output &= nl
        oneline = ""
        tokline = line+1
    end if
end procedure

function ident(sequence tok)
    if find(tok[TOKTYPE],{LETTER,DIGIT}) then
        integer {?,tokstart,tokfinish} = tok
        return src[tokstart..tokfinish]
    end if
    return ""
end function

function get_name(sequence tok)
    integer {toktype, tokstart, tokfinish, line} = tok
    tokline = line
    return src[tokstart..tokfinish]
end function

function equable(sequence expr)
    -- can we use "===" instead of "equal()"?
    -- (obvs the former will be faster, when it's valid)
    object toktype = expr[1]
    if integer(toktype) then
        if find(toktype,{DIGIT,'\'','"','#','-',T_not}) then return true end if
        if toktype=LETTER then
            integer ttidx = expr[TOKTTIDX]
            if ttidx<=T_WEB then
                toktype = T_toktypes[find(ttidx,T_reserved)]
                if find(toktype,{TYPI,TYP2,TYPN,TYPS}) then
--DEV have not actually found any needed yet, some/all of these may need to go under "PROC"..
--              or (toktype=TYPF and find(ttidx,{T_and_bits,T_compare,T_equal,T_find,
--                  T_getd_index,T_IupGetInt,T_machine_bits,T_machine_word,T_match,
--                  T_mod,T_platform})) then
--              or (toktype=TYPF and find(ttidx,{})) then
                    return true
                end if
            elsif find(expr[TOKALTYPE],{TYPI,TYP2,TYPN,TYPS}) then
                return true
            end if
        end if
    elsif toktype="PROC"
--    and find(expr[2][1][TOKTTIDX],{T_abs,T_floor,T_length,T_remainder,T_sign}) then
      and find(expr[2][1][TOKTTIDX],{T_floor,T_sign}) then
        return true 
    end if
    return false
end function

bool need_let = false -- for eg {string s, integer i} = <blah>

--SUG:
--function emit_expr(sequence expr, integer p=0)
function emit_expr(sequence expr, integer p, pandtype=0)
--trace(1)
--  if p=PANDO then p += 1 end if
    string res
    object nodetype = expr[1]
    if integer(nodetype) then
        if nodetype=DIGIT
        or nodetype=LETTER
        or nodetype=COMMENT
        or nodetype=BLK_CMT
        or nodetype='"'
        or nodetype='\''
        or nodetype='`'
        or nodetype='#' then
            integer {?,tokstart,tokfinish,line} = expr
            tokline = line
            if nodetype=LETTER and expr[TOKTTIDX]=T_NULL then
                res = "null" -- (not "NULL")
            else
                res = src[tokstart..tokfinish]
                if nodetype=DIGIT then
                    res = substitute(res,"_","")
                    while length(res)>1 and res[1]='0' and find(res[1],"01234567") do
                        res = res[2..$]
                    end while
                end if
            end if
            if nodetype='\'' then
                if is_phix() then
--                  if length(res)>3 then
                    if find('\\',res)
                    or find('`',res) then
                        if find('"',res) then ?9/0 end if
                        res[1] = '"'
                        res[$] = '"'
                    else
                        res[1] = '`'
                        res[$] = '`'
                    end if
                else
                    integer ch = res[2]
                    if length(res)!=3 then
                        if length(res)!=4 or ch!='\\' then ?9/0 end if
                        ch = res[3]
                        if not find(ch,`"'`) then
                            ch = "\r\n\t\\"[find(ch,"rnt\\")]
                        end if
                    end if
                    res = sprintf("0X%x",ch)
                end if
            elsif nodetype='`' and res[1]='"' then
                res[1] = '`'
                res[$] = '`'
            elsif nodetype='#' then
                if is_phix() then
                    if res[1..2]="0X" then
                        res = sprintf(`'%c'`,to_number(res))
                    end if
                else
                    res = sprintf("0x%x",to_number(res))
                end if
            end if
--if nodetype='`' then ?res end if
        elsif nodetype='{'
           or nodetype=MASS then
            expr = expr[2]
            for i=1 to length(expr) do
                if expr[i][1]=BLK_CMT then
                    integer {?,tokstart,tokfinish,line} = expr[i]
                    tokline = line
--SUG: do it here instead of ibctypes below... 
                    expr[i] = src[tokstart..tokfinish] & " "
                else
                    expr[i] = emit_expr(expr[i],0) & iff(i<length(expr)?", ":"")
                end if
            end for
--          res = xl(nodetype&"") & join(expr,",") & xl(nodetype+2&"")
--          res = xl("{")
            res = xl(nodetype&"")
--          if is_phix() and nodetype='{' then
--              if expr[1]!=`"sequence"` then ?9/0 end if
--?expr
            if is_phix() and length(expr) 
            and find(expr[1],{`"sequence"`,`"sequence", `}) then
                expr = expr[2..$]
            end if
            if length(expr) then
--              res &= join(expr,",") & xl("}")
                res &= join(expr,"") & xl("}")
            else
                if not is_phix() then
                    -- ie `["sequence"]`, not `["sequence",]`
                    --     and ditto `[]` not `[,]`.
                    if res[$]!=',' then ?9/0 end if -- sanity
                    res = res[1..$-1]
                end if
                res &= xl("}")
            end if
        elsif nodetype='?' then     -- (as in {a,?,c} = abc)
            res = iff(is_phix()?"?":"")
        elsif nodetype='[' then
            expr = expr[2]
            if length(expr)!=2 then ?9/0 end if -- (placeholder...?)
            string e1 = emit_expr(expr[1],0)
            expr = expr[2]
            if expr[TOKTYPE]=ELLIPSE then
--  expr = {{4,335,335,13,12,16388},{199,{{4,337,338,13,1,16448},{4,341,342,13,1,16452}}}}
--              if length(expr[2])!=2 then ?9/0 end if
                expr = expr[2]
                if length(expr)!=2 then ?9/0 end if
                string ss = emit_expr(expr[1],0),
                       se = emit_expr(expr[2],0)
                if is_phix() then
                    res = e1 & "[" & ss & ".." & se & "]"
                else
                    res = "$subss("&e1 & "," & ss & "," & se & ")"
                end if
            else
--              for i=1 to length(expr) do
--                  expr[i] = emit_expr(expr[i],0)
--              end for
                string e2 = emit_expr(expr,0)
--          if is_phix() and length(expr) 
--          and find(expr[1],{`"sequence"`,`"sequence", `}) then
--              expr = expr[2..$]
--          end if
--          res = expr[1] & xl("[") & join(expr[2..$],"][") & xl("]")
                if is_phix() then
--                  res = expr[1] & "[" & join(expr[2..$],"][") & "]"
                    res = e1 & "[" & e2 & "]"
                else
--              if length(expr)!=2 then ?9/0 end if -- (placeholder...?)
--              if expr[2][TOKTYPE]=ELLIPSE then
--                  ?9/0
--                  res = "$subse(" & expr[1] & "," & expr[2] & ")"
--              else
--                  res = "$subse(" & expr[1] & "," & expr[2] & ")"
                    res = "$subse(" & e1 & "," & e2 & ")"
--              end if
                end if
            end if
--      elsif nodetype=TWIDDLE then
        elsif nodetype='~' then
            res = "length"
--      elsif nodetype='[' then
--  expr = {91'[',{{4,371,376,13,59';',5172}}}

        elsif nodetype='$' then
            res = iff(is_phix()?"$":"-1")
        else
            -- (note p2js_parse contains a different
            --  & non-embedded precedence() function.)
            if is_phix() then
                if nodetype=EEE then nodetype = EEQ end if -- "===" => "=="
                if nodetype=NEE then nodetype = NE end if -- "!==" => "!="
            else
                if nodetype=NE then nodetype = NEE end if -- "!=" => "!=="
            end if
            integer thisp = find(nodetype,mstoktypes)
            if thisp=0 then
                if find(nodetype,{T_and,T_or,T_xor}) then
--                  if nodetype=T_xor and not is_phix() then ?9/0 end if --DEV violation...
                    thisp = PANDO
                elsif nodetype=T_not then
                    thisp = PUNY
                else
                    ?{"warning, precedence of 0 for",nodetype,nodetype&", line",tokline}
                end if
--          elsif is_js() and find(nodetype,{ANDBIT,ORBIT}) then
            elsif wasext!=PHIX and find(nodetype,{ANDBIT,ORBIT}) then
                thisp = PANDO
--          elsif is_js() and find(nodetype,{'&','|'}) then --DEV'|' missing/untested
            elsif wasext!=PHIX and find(nodetype,{'&','|'}) then --DEV'|' missing/untested
                thisp = PBITS
            else
                thisp = msprec[thisp]
            end if
--          res = emit_expr(expr[2][1],thisp+1)
            res = emit_expr(expr[2][1],thisp,nodetype)
            if find(nodetype,{'-','+',T_not})
            and length(expr[2])=1 then
                string op = tok_name(nodetype)
                if nodetype=T_not then
                    if is_phix() then
                        op &= " "
                    else
                        op = "!"
                    end if
                end if
                res = op & res
-- did not help (t04unary), though I wouldn't be against this:
--              if not is_phix() and thisp=PUNY and p!=12 then
--                  res = "(" & res & ")"
--              end if
            elsif nodetype='&' and is_js() then
--              res = "$conCat(" & res & ", " & emit_expr(expr[2][2],thisp+1) & ")"
                res = "$conCat(" & res & ", " & emit_expr(expr[2][2],thisp) & ")"
            elsif nodetype=T_xor and is_js() then
                res = "xor(" & res & ", " & emit_expr(expr[2][2],thisp) & ")"
            else
                if not is_phix() then
                    if nodetype='=' then
--                      nodetype = iff(is_js() or is_html()?EEE:EEQ)
                        nodetype = iff(is_js()?EEE:EEQ)
                    end if
                end if
                string op = iff(thisp=PANDO?xlsp(nodetype):tok_name(nodetype)),
                       rhs = emit_expr(expr[2][2],thisp)
                if (op="===" or op="!==")
                and not equable(expr[2][1])
                and not equable(expr[2][2]) then
                    res = iff(op="!=="?"!":"") & "equal(" & res & "," & rhs & ")"
--?res
--?expr[2]
                elsif not is_phix()
                  and find(op,{"<","<=",">=",">"}) then
                    res = "compare(" & res & "," & rhs & ")" & op & "0"
                else
                    res = res & op & rhs
                end if
--          end if
--      end if
                if thisp<p 
--              or (thisp>=p and (thisp=PBITS or thisp=PSHFT or thisp=PCOMP or thisp=PUNY))
                or (thisp>=p and p!=0 and find(thisp,{PBITS,PSHFT,PCOMP,PUNY}))
                or (thisp=p and thisp=PANDO and nodetype!=pandtype) then
                    res = "(" & res & ")"
                end if
--?{res,thisp,p}
                p = 0
            end if
        end if
    elsif nodetype="PROC" then
        -- a function or procedure call...
        expr = expr[2]
        if is_phix() and expr[1][TOKTTIDX]=T_conCat then
--  expr = {`PROC`,{{4,188,194,9,4,1952},{4,196,196,9,12,5656},{4,199,199,9,15,5660}}}
--          res = emit_expr(expr[2],PAMPS+1) & "&" & emit_expr(expr[3],PAMPS+1)
            res = emit_expr(expr[2],PAMPS) & "&" & emit_expr(expr[3],PAMPS)
            if p!=0 then
                res = "(" & res & ")"
                p = 0
            end if
        else
            string fname = emit_expr(expr[1],0)
            if fname="iff" and not is_phix() then
                res = "(" & emit_expr(expr[2],12) & " ? " &
                            emit_expr(expr[3],0) & " : " &
                            emit_expr(expr[4],0) & ")"
            else
                res = fname & "("
                expr = expr[2..$]
                for i=1 to length(expr) do
                    expr[i] = emit_expr(expr[i],0)
                    if i=1
                    and fname="Icallback" then
                        if is_phix() then
                            if expr[1][1]!='"' then
                                expr[1] = '"'&expr[1]&'"'
                            end if
                        else
                            if expr[1][1]=='"' then
                                expr[1] = expr[1][2..-2]
                            end if
                        end if
                    end if
                end for
                res &= join(expr,",") & ")"
            end if
        end if
    elsif nodetype="vardef" then
--{`{"vardef",{{4,10594,10599,239,9,476},"si",{}}}`,{"vardef",{{4,10594,10599,239,9,476},"si",{}}}}
--{`{"vardef",{{4,10605,10611,239,20,300},"ctype",{}}}`,{"vardef",{{4,10605,10611,239,20,300},"ctype",{}}}}
if p=12 then ?9/0 end if -- erm??
        res = emit_expr(expr[2][1],0)
        if is_js() then
            res = "/*" & res & "*/"
        end if
if string(expr[2][2]) then
    ?"I thought we'd got rid of this... (emit_expr)"
        res &= " " & expr[2][2]
else
        res &= " " & get_name(expr[2][2])
end if
        need_let = true
    else
--DEV violation?
        res = sprint(expr)
?{res,expr}
    end if
    if p=12 then
        res = "(" & res & ")"
    end if
--  if filter_comments then
--      res = substitute_all(res,{"/*","*/"},{"/!*","*!/"})
--  end if
    return res
end function

--DEV this deserves a complete rewrite/rethink, unit testing, and (probably) a decent write-up in parse_tree.htm
procedure do_args(sequence args)
    if length(args)!=2 then ?9/0 end if
    if args[1]!="vardef" then ?9/0 end if               
    args = args[2]
--                  if length(args)!=3 then ?9/0 end if -- placeholder?
--  if args[1][1]!=LETTER then ?9/0 end if -- placeholder?
    string typeid = emit_expr(args[1],0)
--  if not is_phix() then typeid = "/*" & typeid & "*/" end if
    if is_phix() then
        if typeid[1..2]="/*" then
            if typeid[-2..-1]!="*/" then ?9/0 end if
            typeid = typeid[3..-3]
        end if
    else
        if typeid[1..2]!="/*" then
            if typeid[-2..-1]="*/" then ?9/0 end if
--          if filter_comments then
--              typeid = "/!*" & typeid & "*!/"
--          else
                typeid = "/*" & typeid & "*/"
--          end if
        end if
    end if
    typeid &= " "
    integer adx = 2
    string cs = ""
    while true do
        sequence aan = args[adx]
        if not string(aan) then
--          integer {toktype, tokstart, tokfinish, line, col} = args[adx]
            integer {toktype, tokstart, tokfinish, line} = aan
            tokline = line
--          if args[adx][1]=BLK_CMT then
            if toktype=BLK_CMT then
--              integer {toktype, tokstart, tokfinish, line, col} = args[adx]
                aan = src[tokstart..tokfinish]
                if find(aan,{"/*integer*/","/*atom*/","/*string*/"}) then   --DEV more...
                    if length(typeid) then ?9/0 end if
                    typeid = aan
                    if is_phix() then
                        if typeid[1..2]="/*" then
                            if typeid[-2..-1]!="*/" then ?9/0 end if
                            typeid = typeid[3..-3]
                        end if                  
                    end if                  
                    typeid &= " "
                    adx += 1
                    aan = get_name(args[adx])
                    if args[adx][1]=BLK_CMT then
                        adx += 1
                    end if
--              end if
                else
                    adx += 1
--DEV erm...
--                  if args[adx]="" then
--                  if args[adx]=""
                    if (string(args[adx]) and length(args[adx])=0)
                    or args[adx][1]=',' then
--                      args[adx] = aan
--                  elsif wasext!=PHIX and aan!=args[adx] then
--                      ?9/0
                    elsif not string(args[adx]) then
                        adx -= 1
--                      args[adx] = aan
--                      args[adx] = "/*" & aan & "*/"
                    end if
                end if  
            elsif toktype=LETTER then
--              args[adx] = get_name(args[adx])
                aan = get_name(args[adx])
            else
                ?9/0
            end if
        end if
        oneline &= cs & typeid & aan
        typeid = ""
        adx += 1
        if args[adx]!={} then
            oneline &= "=" & emit_expr(args[adx],0)
        end if
        adx += 1
        if adx>length(args) then exit end if
        cs = ", "
    end while
end procedure

function is_sequence(sequence node)
    integer {toktype, tokstart, tokfinish, line} = node
    tokline = line
    return toktype='"' and src[tokstart..tokfinish]=`"sequence"`
end function

procedure emit_exprn(string prev, sequence expr, integer indent)
--printf(1,"emit_exprn(%s,%v,%d)\n",{prev,expr,indent})
--if prev=`["sequence",` then trace(1) end if
    if length(expr) and expr[1]='{' then
--      prevline = tokline
--      oneline &= xl("{")
--GAH: we neek a tokline on the "{"...
--      prev = 
        integer nindent = indent
--      integer nindent = indent+length(prev)
        if length(prev) then
--      softdent(xl("{"),indent)
--          prevline = tokline
            softdent(prev,indent-1)
--          softdent(prev,indent)
--      indent = length(oneline)
--          nindent += 1
--?oneline
--          nindent = length(oneline)
        end if
        prevline = tokline
        prev = xl("{")
--      if length(prev) then indent += 1 end if
--?{"indent",indent}
        expr = expr[2]
        if length(expr) then
            string cs = ""
--          if length(prev) then indent += 1 end if
            if is_phix() and length(expr)
            and is_sequence(expr[1]) then
                expr = expr[2..$]
            end if
            for i=1 to length(expr) do
--              prevline = tokline
--?{"prevline",prevline}
--              emit_exprn(emit_expr(expr[i],0),indent)
--              emit_exprn(expr[i],indent)
--              emit_exprn(prev,expr[i],indent+1)
                emit_exprn(prev,expr[i],nindent)
                if length(prev) then
--                  nindent += length(prev)+1
                    nindent += length(prev)
                end if
--              emit_exprn(prev,expr[i],indent) -- NO!!
                prev = ""
                if i<length(expr) then
                    prevline = tokline
                    oneline &= ","
                end if
            end for
        else
            if not is_phix() then
                -- ie `["sequence"]`, not `["sequence",]`
                --     and ditto `[]` not `[,]`.
                if prev[$]!=',' then ?9/0 end if -- sanity
                prev = prev[1..$-1]
            end if
            oneline &= prev
        end if
        oneline &= xl("}")
--  elsif length(prev)=0 then
--      softdent(prev & emit_expr(expr,0),indent+1)
    else
--      oneline &= emit_expr(expr,0)
        prevline = tokline
--      softdent(prev & emit_expr(expr,0),indent-1)
--      softdent(prev & emit_expr(expr,0),indent)
        prev &= emit_expr(expr,0)
        softdent(prev,indent)
    end if
end procedure

-- probably a better way...
constant {ibctypes,ibtypes} = columnize({{"/*atom*/","atom"},
                                         {"/*integer*/","integer"},
                                         {"/*string*/","string"},
                                         {"/*sequence*/","sequence"},
--                                       {`{"sequence",`,"{"},
                                         {"/*object*/","object"}})
--                                       {"/*object*/","object"},
--                                       {"/*Ihandle*/","Ihandle"},
--                                       {"/*Ihandln*/","Ihandln"}})

procedure emit(sequence nodes, integer indent=0)
    integer toktype, tokstart, tokfinish, line, col, wastokline
    for i=1 to length(nodes) do
        sequence node = nodes[i]
        object nodetype = node[1]
        if integer(nodetype) then
            if nodetype=COMMENT
            or nodetype=BLK_CMT then
                {toktype, tokstart, tokfinish, line, col} = node
--DEV testme:
                string cmt = src[tokstart..tokfinish]
                if is_phix() and cmt="/*include pGUI.e*/" then
                    cmt = cmt[3..-3]
                    bGUI = true
                end if
                cdent(cmt,nodetype,line,col)
            elsif nodetype=T_global
               or nodetype=T_forward then
--trace(1)
--DEV (minor) couldn't get the lines to help
                line = node[2][1][TOKLINE]
--              if line>tokline+1 then dent("\n",0) end if
                if line>tokline then dent("\n",0) end if
                nodetype = tok_name(nodetype)
                if not is_phix() then
                    nodetype = "/*"&nodetype&"*/"
                end if
--DEV/SUG defer...
--              prevline = tokline
--              tokline = line
                dent(nodetype & ' ',0)
                tokline = line
            elsif nodetype=T_if then
--trace(1)
--{1104,{{161,{{"PROC",{{4,600,607,20,3,3212}}},
--             {4,612,614,20,15,5080}}},
--       {1624,{{"PROC",{{4,625,635,21,4,3820}}},{61,{{4,643,645,22,4,5112},{"PROC",{{4,649,658,22,10,2208},{4,660,662,22,21,5112}}}}},{"PROC",{{4,669,676,23,4,2140}}}}}}}
--"if (platform()!=WEB)"
--?node
                -- {T_if,{expr,{T_then,block}[,{T_elsif,expr},{T_then,block}][,{T_else,block}]}}
                node = node[2]
                sequence condition = node[1]
--/!*
                bool bCommentOut = false
--              if is_js() or is_html() then
                if is_js() then
                    object op = condition[1]
                    if find(op,{NE,'=',EEQ})
                    and condition[2][1][1]="PROC"
                    and condition[2][1][2][1][TOKTYPE]=LETTER
                    and condition[2][1][2][1][TOKTTIDX]=T_platform
                    and condition[2][2][TOKTYPE]=LETTER then
                        integer ptdx = condition[2][2][TOKTTIDX]
                        bCommentOut = iff(op=NE?ptdx=T_WEB:ptdx!=T_WEB)
                    end if
                end if
--*!/
                string expr = emit_expr(condition,initp)
--DEV weak, as above we c/should test for NE(=161)/'='/EEQ and T_platform(=3212) and T_WEB (=5080).
--              bool bCommentOut = (is_js() and expr="(platform()!=WEB)")
                string ift = iff(bCommentOut?"/*if ":"if ")
                dent(ift & expr,indent)
--?oneline
                wastokline = tokline
--if tokline=89 then trace(1) end if
                while true do
                    if node[2][1]!=T_then then ?9/0 end if
                    oneline &= xl(" then")
--                  prevline = line
                    prevline = tokline
                    emit(node[2][2],indent+4)
                    node = node[3..$]
                    if length(node)=0 or node[1][1]!=T_elsif then exit end if
--                  dent(xl("elsif ") & emit_expr(node[1][1],initp),indent)
--                  dent(xl("elsif ") & emit_expr(node[1][2][1],initp),indent)
                    prevline = wastokline
                    softdent(xl("elsif ") & emit_expr(node[1][2][1],initp),indent)
                end while
                if length(node) then
                    if length(node)!=1 then ?9/0 end if
                    if node[1][1]!=T_else then ?9/0 end if
--                  dent(xl("else"),indent)
                    prevline = wastokline
                    softdent(xl("else"),indent)
                    emit(node[1][2],indent+4)
                end if
                prevline = wastokline
--trace(1)
                softdent(xl("end if"),indent)
                if bCommentOut then oneline &= "*/" end if

            elsif nodetype=T_for then
                sequence {ctrl,lim,step,block} = node[2]
                -- (I'm not enamoured of this structure...)
                -- (I'm missing the requirement for let or no let...)
--/*
--  >for:{T_for,{{"vardef",{{4,727,729,27,0,T_for},
--                          "a",
--                          {3,733,733,27,6}}},
--               {3,738,738,27,11},
--               {},
--               {T_block,block}}}
--*/
                if ctrl[1]!="vardef" then ?9/0 end if
                ctrl = ctrl[2]
                -- ctrl is now (/shd be) {T_for,ctrl,expr} as in "for i=1".
                if ctrl[1][TOKTYPE]!=LETTER or ctrl[1][TOKTTIDX]!=T_for then ?9/0 end if
                line = ctrl[1][TOKLINE]
if string(ctrl[2]) then
    ?"I thought we'd got rid of this... (emit/T_for/vardef/string)"
else
    ctrl[2] = get_name(ctrl[2])
end if
                string c2 = ctrl[2],
                       c3 = emit_expr(ctrl[3],0)
                if lim[1]=LE and ident(lim[2][1])=c2 then
                    lim = lim[2][2]
                end if
                string l2 = emit_expr(lim,0)
                if is_phix() then
--  ctrl = {{4,281,283,11,0,984},`n`,{3,292,292,11,11}}
                    dent("for " & c2 & "=" & c3,indent)
--  lim = {167,{{4,295,295,11,14,5176},{3,298,302,11,17}}}
--                  oneline &= " to " & emit_expr(lim,0)
                    oneline &= " to " & l2
                    if step!={} then
--  step = {131,{{4,305,305,11,24,5176},{3,308,308,11,27}}}                     
--?9/0
                        if step[1]=PLUSEQ and ident(step[2][1])==c2 then
                            if ident(step[2][2])!="1" then
                                ?9/0 -- placeholder
                            end if
                        else
                            ?9/0 -- placeholder
--(probably, above too)
--                          oneline &= " by " & emit_expr(step,0)
                        end if
                    end if
                    oneline &= " do"
                else
                    string cmpop = iff(length(step)=2 and step[1]='-' ? ">=" : "<=")
                    if lim[1]=DIGIT then
                        dent("for (let " & c2 & "=" & c3 & "; ",indent)
                        oneline &= c2 & cmpop & l2 & "; "
                    else
                        dent("for (let " & c2 & "=" & c3 & ", " & c2 & "$lim=" & l2 & "; ",indent)
                        oneline &= c2 & cmpop & c2 & "$lim; "
                    end if
                    if step={}
-- (maybe yet..)
                    or (step[1]=PLUSEQ and ident(step[2][1])==c2 and ident(step[2][2])="1") then
--                  or (step[1]=PLUSEQ and ident(step[2][1])==ctrl[2]) then
                        oneline &= c2 & "+=1) {"
--                      oneline &= c2 & "+=" & ident(step[2][2]) & ") {"
                    elsif step[1]=DIGIT then
                        oneline &= c2 & "+=" & ident(step) & ") {"
--                  elsif step[1]='-' and length(step[2])=1 and step[2][1][TOKTYPE]=DIGIT then
                    elsif step[1]='-' then
--                      if length(step[2])=1 and step[2][1][TOKTYPE]=DIGIT then
                        if length(step[2])=1 then
--  step = {45'-',{{3,3806,3806,125'}',33'!'}}}
--                          oneline &= c2 & "-=" & ident(step[2][1]) & ") {"
                            oneline &= c2 & "-=" & emit_expr(step[2][1],0) & ") {"
                        else
                            ?9/0 -- placeholder
                        end if
                    else
--{42'*',{{4,659,659,25,25,5256},{3,661,661,25,27}}}
                        oneline &= c2 & "+=" & emit_expr(step,0) & ") {"
--                      ?9/0 -- placeholder
                    end if
                end if
                wastokline = tokline
                if block[1]!=T_block then ?9/0 end if
                emit(block[2],indent+4)
--              dent(xl("end for"),indent)
                prevline = wastokline
                softdent(xl("end for"),indent)
            elsif nodetype=T_function
               or nodetype=T_procedure
               or nodetype=T_type then
                sequence {name,args,body} = node[2]
                -- (I'm not enamoured of this structure either...)
--/*
-->functn:{1052,{{4,1340,1343,45,9,5116},
--               {T_args,{{"vardef",{{4,1345,1351,45,14,300},
--               {ARGS,{{"vardef",{{4,1345,1351,45,14,300},
--                                   "x",
--                                   {}}
--                       }}
--               },
--               {T_block,{{1496,{{43,{{4,1363,1363,45,32,5120},
--                                     {3,1367,1367,45,36}}
--                               }}
--                        }}
--               }}
--*/
                if name[1]!=LETTER then ?9/0 end if
                prevline = tokline
                name = emit_expr(name,0)
--              bool jst = is_js() and nodetype=T_type
                string fp = xl(tok_name(nodetype))
--                     oc = iff(jst?"/*":""),
--                     cc = iff(jst?"*/":"")
--              if find(oneline,{"/*global*/","global"}) then
--                  fp = oneline
--              dent(fp & " " & name & "(",indent)
--              softdent(oc & fp & " " & name & "(",indent)
                softdent(fp & " " & name & "(",indent)
--              filter_comments = jst
                wastokline = tokline
                prevline = wastokline
--              if args[1]!=T_args then ?9/0 end if
                if args[1]!=ARGS then ?9/0 end if
--DEV eg integer a,b
--function pname_action_cb(Ihandle /*pname*/, atom /*pText*/, integer /*item*/, /*state*/)
--  args[1] = {`vardef`,{{4,7732,7738,210,25,332},                          T_Ihandle
--                       {6,7740,7748,210,33'!',210},`/*pname*/`,{}}}
--  args[2] = {`vardef`,{{4,7751,7754,210,44',',140},                       T_atom
--                       {6,7756,7764,210,49'1',210},`/*pText*/`,{}}}
--  args[3] = {`vardef`,{{4,7767,7773,210,60'<',300},                       T_integer
--                       {6,7775,7782,210,68'D',210},`/*item*/`,{},
--                       {6,7785,7793,210,78'N',210},``,{}}}
                args = args[2]
--phix->js:
--function multitext_valuechanged_cb(Ihandle /*multitext*/)
--{{"vardef",{{4,188,194,7,35,332},{6,196,208,7,43,7},"",{}}}}
--js->phix:
--function multitext_valuechanged_cb(/*Ihandle*/ /*multitext*/) {
--{{"vardef",{{6,219,229,9,35,9},{6,219,229,9,35,9},{6,231,243,9,47,9},"",{}}}}
--{{"vardef",{{6,219,229,9,35,9},{6,231,243,9,47,9},"",{}}}}
--?args
--trace(1)
                for j=1 to length(args) do
                    if j>1 then oneline &= ", " end if
                    do_args(args[j])
                end for
                oneline &= ")"
--DEV forward function expr(integer p, skip=0)
if body={} then
                if not is_phix() then   
--if filter_comments then ?9/0 end if --???!!!
                    oneline = "/*" & substitute_all(oneline,{"/*","*/"},{"/!*","*!/"}) & "*/"
                end if
else
                if not is_phix() then oneline &= " {" end if
                if body[1]!=T_block then ?9/0 end if
if name="main_menu" then trace(1) end if
                emit(body[2],indent+4)
                prevline = wastokline
--              filter_comments = false
--              softdent(xl("end " & fp) & cc,indent)
                softdent(xl("end " & fp),indent)
end if
            elsif nodetype=T_return then
-->return:{1496,{{43,{{4,1440,1440,47,32,5176},{3,1444,1444,47,36}}}}}?
--DEV no line...
--trace(1)
                prevline = tokline
                string ret = "return"
                if length(node)>1 then
                    object n2 = node[2]
                    if integer(n2) then
                        tokline = n2
                    else
                        ret &= " " & emit_expr(n2[1],0)
                    end if
                end if
                softdent(ret,indent)
                if is_js() then oneline &= ";" end if
            elsif nodetype=T_exit
               or nodetype=T_break
               or nodetype=T_fallthrough then
                prevline = tokline
                tokline = node[2]               
                softdent(xl(tok_name(nodetype)),indent)
--              if is_js() then oneline &= ";" end if
            elsif nodetype=T_include then
                if node[2][1]="pGUI.e" then
                    bGUI = true
                else
                    restore_source(node[2][2])
                    if length(node[2][1]) then
--DEV phix only?...
--                  if match("pGUI.e",node[2]) then
--                  if match("pGUI.e",node[2][1]) then
--                      bGUI = true
--                  end if
                        string incline = tok_name(nodetype) & " " & node[2][1] 
                        if not is_phix() then
                            incline = "/*" & incline & "*/"
                        end if
                        tokline = node[2][3]
                        dent(incline,0)
                        flush_oneline()
                    end if
                end if
            elsif nodetype=T_without
               or nodetype=T_with then
                string withline = tok_name(nodetype) & " " & node[2][1] 
                if not is_phix() then
                    withline = "/*" & withline & "*/"
                end if
--              prevline = tokline
                tokline = node[2][2]
                dent(withline,0)
--              flush_oneline()
            elsif nodetype='='
               or nodetype=BEQ
               or nodetype=PLUSEQ
               or nodetype=MNUSEQ
               or nodetype=MULTEQ
               or nodetype=DIVDEQ then
-->&=:{135,{{4,7621,7627,212,38,8292},{34,7632,7639,212,49}}}?
-->+=:{131,{{4,231,236,11,8,5172},{3,241,241,11,18}}}?
-->-=:{133,{{4,6036,6036,164,4,5152},{3,6041,6041,164,9}}}?
--/*
--"=:""{61,{{4,643,645,22,4,5112},{"PROC",{{4,649,658,22,10,2208},{4,660,662,22,21,5112}}}}}?"
--*/
                if length(node)!=2 then ?9/0 end if
                node = node[2]
                if length(node)!=2 then ?9/0 end if
                if not is_phix() and nodetype==BEQ then nodetype := '=' end if
--              dent(emit_expr(node[1],0) & sp(nodetype) & emit_expr(node[2],0),indent)
                prevline = tokline
                softdent(emit_expr(node[1],0) & sp(nodetype) & emit_expr(node[2],0),indent)
                if not is_phix() then oneline &= ";" end if
-->while:{T_while,{{T_and,{{60,{{4,2243,2243,69,22,5128},
--                              {"PROC",{{4,2245,2250,69,24,3100},
--                                       {4,2252,2255,69,31,5592}}}}},
--                         {169,{{91,{{4,2262,2265,69,41,5592},
--                                    {43,{{4,2267,2267,69,46,5128},
--                                         {3,2269,2269,69,48}}}}},
--                               {39,2273,2275,69,52}}}}},
--                 {T_block,{{131,{{4,2300,2300,70,20,5128},{3,2305,2305,70,25}}}}}}}?
-->while:{T_while,{{4,3417,3420,105,10,5012},
--                 {T_block,{{1088,...}}}}}?
-->while:{T_while,{{4,5781,5784,156,10,5012},
--                 {T_block,{{5,...}}}}}}?
-->while:{T_while,{{T_and,{{167,{{4,6501,6501,179,10,5152},{4,6504,6505,179,13,5832}}},
--                         {161,{{4,6511,6512,179,20,5156},{45,{{3,6516,6516,179,25}}}}}}},
--                 {T_block,{{61,...}}}}?
            elsif nodetype=AMPSEQ then
                if length(node)!=2 then ?9/0 end if
                node = node[2]
                if length(node)!=2 then ?9/0 end if            
                prevline = tokline
                string lhs = emit_expr(node[1],0)
                if is_phix() then
                    softdent(lhs & " = " & lhs & " & " & emit_expr(node[2],0),indent)
                else
                    softdent(lhs & " = $conCat(" & lhs & ", " & emit_expr(node[2],0) & ");",indent)
                end if
            elsif nodetype=T_while then
                node = node[2]
                sequence condition = node[1]
                string expr = emit_expr(condition,initp)
                wastokline = tokline
                dent("while " & expr & xl(" do"),indent)
                if node[2][1]!=T_block then ?9/0 end if
                emit(node[2][2],indent+4)
                prevline = wastokline
                softdent(xl("end while"),indent)
            elsif nodetype=T_switch then
-->switch:{1544,{{4,6842,6848,191,15,5244},
--               {T_case,{{4,6867,6869,192,17,5964}}},
--               {T_block,{{131,{{4,6888,6891,193,16,5172},
--                               {61,...}}},
--                         {61,...}}},
--               {T_case,{{4,6955,6959,195,17,6068}}},
--               {T_block,{{596},{5,6984,7016,197,0}}},
--               {T_case,{{39,7035,7037,198,17},{39,7040,7042,198,22}}},
--               {T_block,{{5,7045,7078,199,0},{1088,{,{1608,{,{1088,{{1608,{,,{1088,{,,,{1608,{{"MASS",{,{"PROC",{,{43,{{4,7638,7638,211,72,5152},{3,7640,7640,211,74}}}}}}},{1480}}}}},{"PROC",{{4,7733,7744,214,24,5932}}},{6,7748,8286,215,0,226},{596}}},{788,{{520,{{61,{{4,8344,8350,228,26,5244},{39,8352,8354,228,34}}},{61,{{4,8360,8361,228,42,5828},{39,8363,8365,228,45}}}}}}},{1608,{{5,8372,8413,229,0},{"PROC",{{4,8439,8451,230,24,5756},{4,8453,8453,230,38,5152},{3,8455,8455,230,40}}},{596}}}}}}}}},
--                         {924},{5,8566,8589,235,0}}},
--               {T_case,{{39,8608,8610,236,17},{39,8612,8614,236,21},{39,8616,8618,236,25},{39,8620,8622,236,29},{39,8624,8626,236,33},{39,8628,8630,236,37},{39,8632,8634,236,41},{39,8636,8638,236,45},{39,8640,8642,236,49},{39,8644,8646,236,53},{39,8648,8650,236,57},{39,8652,8654,236,61},{39,8656,8658,236,65},{39,8660,8663,236,69},{39,8665,8667,236,74},{39,8669,8671,236,78},{39,8673,8675,236,82}}},
--               {T_block,{{1788,{{520,{{60,{{4,8700,8700,237,22,5152},{4,8702,8703,237,24,5832}}},{62,{{91,{{4,8776,8782,239,22,5948},{91,{{4,8784,8787,239,30,5592},{43,{{4,8789,8789,239,35,5152},{3,8791,8791,239,37}}}}}}},{4,8795,8800,239,41,5368}}}}},
--               {T_block,{{"vardef",{{4,8825,8831,240,20,300},"sdx",{"PROC",{{4,8839,8842,240,34,1992},{91,{{4,8844,8847,240,39,5592},{43,{{199,{{4,8849,8856,240,44,5224},{4,8859,8859,240,54,5152}}},{3,8861,8861,240,56}}}}},{4,8864,8871,240,59,6120}}}}},{1088,{{61,{{4,8897,8899,241,23,6088},{3,8901,8901,241,27}}},{1608,{{828}}}}},{5,8940,8987,242,20},{61,{{4,9009,9015,243,20,5244},{91,{{4,9019,9028,243,30,6156},{4,9030,9032,243,41,6088}}}}},{131,{{4,9055,9055,244,20,5152},{3,9060,9060,244,25}}}}}}},{5,9088,9126,246,0},{5,9128,9207,247,0},{5,9209,9228,248,0},{5,9230,9265,249,0},{5,9267,9300,250,0},{5,9302,9371,251,0},{5,9373,9409,252,0},{5,9411,9420,253,0},{5,9422,9429,254,0},{5,9431,9493,255,0},{5,9495,9531,256,0},{5,9533,9599,257,0},{5,9601,9636,258,0},{5,9638,9659,259,0},{924},{5,9689,9712,261,0}}},
--               {T_case,{{39,9731,9733,262,17},{39,9735,9737,262,21},{39,9739,9741,262,25},{39,9743,9745,262,29},{39,9747,9749,262,33},{39,9751,9753,262,37}}},
--               {T_block,{{"PROC",{{4,9772,9780,263,16,5432}}},{596},{5,9806,9829,265,0}}},
--               {T_case,{{39,9848,9850,266,17}}},
--               {T_block,{{5,9853,9883,267,0},{5,9885,9918,268,0},{5,9920,9944,269,0},{5,9946,9967,270,0},{131,{{4,9985,9985,271,16,5152},{3,9990,9990,271,21}}},{61,{{4,10008,10009,272,16,5156},{91,{{4,10013,10016,272,21,5592},{4,10018,10018,272,26,5152}}}}},{1088,{{61,{{4,10040,10041,273,19,5156},{39,10043,10045,273,22}}},{1608,{{1088,{{1308,{{1308,{{1300,{{"PROC",{{4,10079,10082,274,27,6164}}}}},{62,{{43,{{4,10129,10129,275,23,5152},{3,10131,10131,275,25}}},{4,10133,10134,275,27,5832}}}}},{161,{{91,{{4,10160,10163,276,23,5592},{43,{{199,{{4,10165,10165,276,28,5152},{4,10168,10168,276,31,5152}}},{3,10170,10170,276,33}}}}},{34,10174,10182,276,37}}}}},{1608,{{"MASS",{{201,{}},{"PROC",{{4,10218,10226,277,29,5540},{34,10228,10241,277,39}}}}},{1480}}}}},{131,{{4,10322,10322,280,20,5152},{3,10327,10327,280,25}}},{131,{{4,10349,10356,281,20,5224},{3,10361,10361,281,32}}},{61,{{4,10383,10389,282,20,5244},{4,10393,10398,282,30,6048}}},{"PROC",{{4,10420,10428,283,20,5456}}}}},{776,{{1788,{{"PROC",{{4,10479,10482,285,26,1992},{"PROC",{{4,10484,10488,285,31,6184},{4,10490,10491,285,37,5156}}},{34,10494,10512,285,41}}},
--                  {T_block,{{131,{{4,10542,10542,286,24,5152},{3,10547,10547,286,29}}},{61,{{4,10573,10574,287,24,5156},{91,{{4,10578,10581,287,29,5592},{4,10583,10583,287,34,5152}}}}}}}}},{133,{{4,10636,10636,289,20,5152},{3,10641,10641,289,25}}},{1088,{{1308,{{167,{{4,10666,10666,290,23,5152},{4,10669,10676,290,26,5224}}},{"PROC",{{4,10787,10790,292,23,1992},{91,{{4,10792,10798,292,28,5948},{4,10800,10801,292,36,5156}}},{123,{{39,10805,10807,292,41},{39,10809,10812,292,45},{39,10814,10816,292,50},{39,10818,10820,292,54},{4,10822,10826,292,58,6208},{4,10828,10833,292,64,6048}}}}}}},{1608,{{"MASS",{{201,{}},{"PROC",{{4,10871,10879,293,29,5540},{34,10881,10894,293,39},{43,{{4,10896,10896,293,54,5152},{3,10898,10898,293,56}}}}}}},{1480}}}}},{"PROC",{{4,10979,10987,296,20,5432}}}}}}},{5,11014,11037,298,0}}},
--               {T_case,{{39,11056,11059,299,17}}},
--               {T_block,{{1088,{{"PROC",{{4,11081,11087,300,19,5720}}},{1608,{{5,11116,11159,301,20},{5,11181,11211,302,20},{5,11233,11259,303,20},{5,11281,11308,304,20},{5,11330,11359,305,20},{131,{{4,11381,11381,306,20,5152},{3,11386,11386,306,25}}},{61,{{4,11408,11409,307,20,5156},{91,{{4,11413,11416,307,25,5592},{4,11418,11418,307,30,5152}}}}},{5,11432,11440,307,44},{1088,{{61,{{4,11465,11466,308,23,5156},{39,11468,11471,308,26}}},{1608,{{131,{{4,11502,11502,309,24,5152},{3,11507,11507,309,29}}},{61,{{4,11533,11534,310,24,5156},{91,{{4,11538,11541,310,29,5592},{4,11543,11543,310,34,5152}}}}},{5,11553,11561,310,44}}},{788,{{61,{{4,11589,11590,311,26,5156},{39,11592,11595,311,29}}}}},{1608,{{"MASS",{{201,{}},{"PROC",{{4,11631,11639,312,29,5540},{34,11641,11649,312,39}}}}},{1480}}}}},{131,{{4,11730,11730,315,20,5152},{3,11735,11735,315,25}}},{1088,{{1308,{{61,{{91,{{4,11760,11766,316,23,5948},{4,11768,11769,316,31,5156}}},{4,11772,11774,316,35,5964}}},{161,{{91,{{4,11799,11802,317,23,5592},{4,11804,11804,317,28,5152}}},{39,11808,11811,317,32}}}}},{1608,{{5,11820,11828,317,44},{"MASS",{{201,{}},{"PROC",{{4,11859,11867,318,29,5540},{96,11869,11880,318,39,318}}}}},{1480}}}}},{"PROC",{{4,11961,11969,321,20,5432}}},{596}}}}},{5,12022,12060,324,0},{924},{5,12090,12118,326,0}}},
--               {T_case,{{39,12137,12139,327,17},{39,12142,12144,327,22}}},
--               {T_block,{{"vardef",{{4,12163,12169,328,16,300},"cq",{4,12176,12177,328,29,5156},"startline",{4,12192,12195,328,45,5172},"midlinestart",{4,12213,12221,328,66,5196}}},{1788,{{4,12245,12248,329,22,5012},
--                  {T_block,{{131,{{4,12273,12273,330,20,5152},{3,12278,12278,330,25}}},{61,{{4,12300,12301,331,20,5156},{91,{{4,12305,12308,331,25,5592},{4,12310,12310,331,30,5152}}}}},{1088,{{520,{{61,{{4,12336,12337,332,23,5156},{39,12339,12342,332,26}}},{161,{{4,12348,12349,332,35,6216},{39,12352,12354,332,39}}}}},{1608,{{131,{{4,12385,12385,333,24,5152},{3,12390,12390,333,29}}},{61,{{4,12416,12417,334,24,5156},{91,{{4,12421,12424,334,29,5592},{4,12426,12426,334,34,5152}}}}}}},{788,{{61,{{4,12455,12456,335,26,5156},{4,12458,12459,335,29,6216}}}}},{1608,{{1088,{{520,{{520,{{61,{{4,12493,12493,336,27,5152},{43,{{4,12495,12502,336,29,5224},{3,12504,12504,336,38}}}}},{60,{{4,12669,12669,340,28,5152},{4,12671,12672,340,30,5832}}}}},{61,{{91,{{4,12702,12705,341,28,5592},{43,{{4,12707,12707,341,33,5152},{3,12709,12709,341,35}}}}},{4,12712,12713,341,38,6216}}}}},{1608,{{5,12748,12773,342,28},{"vardef",{{4,12803,12809,343,28,300},"cqc",{3,12817,12817,343,42}}},{5,12820,12849,343,45},{131,{{4,12879,12879,344,28,5152},{3,12884,12884,344,33}}},{1788,{{4,12920,12923,345,34,5012},
--                  {T_block,{{131,{{4,12960,12960,346,32,5152},{3,12965,12965,346,37}}},{1088,{{62,{{4,13002,13002,347,35,5152},{4,13004,13005,347,37,5832}}},{1608,{{61,{{4,13048,13051,348,36,5172},{4,13055,13063,348,43,5792}}},{"MASS",{{201,{}},{"PROC",{{4,13106,13114,349,41,5540},{34,13116,13138,349,51},{43,{{4,13140,13147,349,75,5224},{3,13149,13149,349,84}}}}}}},{1480}}}}},{61,{{4,13266,13267,352,32,5156},{91,{{4,13271,13274,352,37,5592},{4,13276,13276,352,42,5152}}}}},{1088,{{61,{{4,13314,13315,353,35,5156},{4,13317,13318,353,38,6216}}},{1608,{{131,{{4,13361,13363,354,36,6268},{3,13368,13368,354,43}}},{1088,{{61,{{4,13409,13411,355,39,6268},{3,13413,13413,355,43}}},{1608,{{828}}}}}}},{776,{{61,{{4,13505,13507,357,36,6268},{3,13511,13511,357,42}}},{131,{{4,13549,13549,358,36,5152},{61,{{4,13555,13556,358,42,5156},{39,13558,13561,358,45}}}}},{5,13564,13573,359,0},{5,13575,13627,360,0},{1088,{{61,{{4,13668,13669,361,39,5156},{39,13671,13674,361,42}}},{1608,{{131,{{4,13721,13724,362,40,5172},{3,13729,13729,362,48}}},{61,{{4,13771,13782,363,40,6260},{43,{{4,13786,13786,363,55,5152},{3,13788,13788,363,57}}}}}}}}}}}}}}}}},{131,{{4,13938,13945,367,28,5224},{3,13950,13950,367,40}}},{"SASS",{{91,{{4,13980,13983,368,28,5592},{4,13985,13992,368,33,5224}}},{61,{{39,13997,13999,368,45}}}}},{133,{{4,14029,14029,369,28,5152},{3,14034,14034,369,33}}},{5,14036,14050,369,35},{"SASS",{{91,{{4,14080,14083,370,28,5592},{4,14085,14085,370,33,5152}}},{61,{{39,14090,14092,370,38}}}}},{61,{{4,14122,14128,371,28,5244},{39,14132,14134,371,38}}},{5,14136,14202,372,0}}}}},{828}}}}},{1088,{{61,{{4,14314,14320,376,23,5244},{39,14322,14324,376,31}}},{1608,{{1088,{{61,{{4,14358,14358,377,27,5152},{4,14360,14361,377,29,5832}}},{1608,{{61,{{4,14396,14399,378,28,5172},{4,14403,14411,378,35,5792}}},{"MASS",{{201,{}},{"PROC",{{4,14446,14454,379,33,5540},{34,14456,14478,379,43},{4,14480,14487,379,67,5224}}}}},{1480}}}}},{5,14556,14564,382,0},{5,14566,14606,383,0},{1088,{{61,{{4,14635,14636,384,27,5156},{39,14638,14641,384,30}}},{1608,{{131,{{4,14676,14679,385,28,5172},{3,14684,14684,385,36}}},{61,{{4,14714,14725,386,28,6260},{43,{{4,14729,14729,386,43,5152},{3,14731,14731,386,45}}}}}}}}}}},{788,{{61,{{91,{{4,14790,14796,388,26,5948},{4,14798,14799,388,34,5156}}},{4,14802,14804,388,38,5964}}}}},{1608,{{"MASS",{{201,{}},{"PROC",{{4,14840,14848,389,29,5540},{34,14850,14872,389,39}}}}},{1480}}}}}}}}},{1088,{{61,{{4,14978,14984,393,19,5244},{39,14986,14988,393,27}}},{1608,{{5,14995,15012,394,0},{5,15014,15067,395,0},{5,15069,15147,396,0},{"PROC",{{4,15169,15175,397,20,5272},{123,{{39,15178,15180,397,29},{4,15182,15189,397,33,5224},{4,15191,15191,397,42,5152},{4,15193,15201,397,44,5792},{45,{{4,15203,15210,397,54,5224},{4,15212,15220,397,63,5196}}},{4,15222,15225,397,73,5172}}}}},{1088,{{61,{{4,15252,15253,398,23,6216},{39,15255,15257,398,26}}},{1608,{{131,{{4,15264,15264,398,35,5152},{3,15269,15269,398,40}}}}}}},{5,15278,15291,398,49}}},{776,{{"PROC",{{4,15334,15342,400,20,5432}}}}}}},{61,{{4,15385,15393,402,16,5196},{4,15397,15408,402,28,6260}}}}},
--               {T_case,{{4,15427,15431,403,17,6208}}},
--               {T_block,{{1788,{{4,15456,15459,404,22,5012},{T_block,{{131,{{4,15484,15484,405,20,5152},{3,15489,15489,405,25}}},{61,{{4,15511,15512,406,20,5156},{91,{{4,15516,15519,406,25,5592},{4,15521,15521,406,30,5152}}}}},{61,{{4,15544,15550,407,20,5244},{91,{{4,15554,15560,407,30,5948},{4,15562,15563,407,38,5156}}}}},{1088,{{161,{{4,15589,15595,408,23,5244},{4,15598,15602,408,32,6208}}},{1608,{{5,15609,15634,409,0},{1088,{{520,{{520,{{61,{{4,15663,15664,410,27,5156},{39,15666,15668,410,30}}},{61,{{4,15674,15674,410,38,5152},{43,{{4,15676,15683,410,40,5224},{3,15685,15685,410,49}}}}}}},{61,{{91,{{4,15691,15694,410,55,5592},{4,15696,15703,410,60,5224}}},{39,15706,15708,410,70}}}}},{1608,{{5,15743,15765,411,28},{1788,{{4,15801,15804,412,34,5012},{T_block,{{131,{{4,15841,15841,413,32,5152},{3,15846,15846,413,37}}},{61,{{4,15880,15881,414,32,5156},{91,{{4,15885,15888,414,37,5592},{4,15890,15890,414,42,5152}}}}},{1088,{{1300,{{"PROC",{{4,15932,15935,415,39,1992},{4,15937,15938,415,44,5156},{34,15940,15944,415,47}}}}},{1608,{{828}}}}}}}}},{133,{{4,16030,16030,417,28,5152},{3,16035,16035,417,33}}},{1088,{{60,{{4,16068,16068,418,31,5152},{43,{{4,16070,16077,418,33,5224},{3,16079,16079,418,42}}}}},{1608,{{"MASS",{{201,{}},{"PROC",{{4,16123,16131,419,37,5540},{34,16133,16146,419,47}}}}},{1480}}}}},{5,16223,16266,422,0},{61,{{4,16296,16302,423,28,5244},{39,16306,16308,423,38}}},{5,16312,16326,423,44},{"PROC",{{4,16356,16364,424,28,5432}}},{596}}}}},{968,{{"vardef",{{4,16457,16459,427,24,968},"x",{3,16463,16463,427,30}}},{3,16468,16468,427,35},{},{T_block,{{"vardef",{{4,16501,16507,428,28,300},"xc",{91,{{34,16514,16517,428,41},{4,16519,16519,428,46,6272}}}}},{1088,{{520,{{61,{{"PROC",{{4,16553,16557,429,31,6296},{4,16559,16560,429,37,5156}}},{4,16563,16564,429,41,6280}}},{1308,{{61,{{4,16571,16571,429,49,6272},{3,16573,16573,429,51}}},{161,{{91,{{4,16578,16581,429,56,5592},{43,{{4,16583,16583,429,61,5152},{3,16585,16585,429,63}}}}},{39,16589,16591,429,67}}}}}}},{1608,{{"vardef",{{4,16631,16637,430,32,300},"i0",{4,16644,16644,430,45,5152}}},{1788,{{4,16684,16687,431,38,5012},{T_block,{{131,{{4,16728,16728,432,36,5152},{3,16733,16733,432,41}}},{61,{{4,16771,16772,433,36,5156},{91,{{4,16776,16779,433,41,5592},{4,16781,16781,433,46,5152}}}}},{61,{{4,16820,16826,434,36,5244},{91,{{4,16830,16836,434,46,5948},{4,16838,16839,434,54,5156}}}}},{1088,{{520,{{161,{{4,16881,16887,435,39,5244},{4,16890,16894,435,48,6208}}},{1308,{{161,{{4,16938,16938,436,42,5152},{43,{{4,16941,16942,436,45,6304},{3,16944,16944,436,48}}}}},{1300,{{"PROC",{{4,16954,16957,436,58,1992},{4,16959,16960,436,63,5156},{34,16962,16965,436,66}}}}}}}}},{1608,{{1088,{{61,{{4,17017,17017,437,43,5152},{43,{{4,17019,17020,437,45,6304},{3,17022,17022,437,48}}}}},{1608,{{5,17073,17090,438,44},{"MASS",{{201,{}},{"PROC",{{4,17141,17149,439,49,5540},{34,17151,17166,439,59}}}}},{1480}}}}},{828}}}}}}}}}}}}}}}}},{828}}}}}}}}},{133,{{4,17562,17562,450,16,5152},{3,17567,17567,450,21}}},{61,{{4,17585,17591,451,16,5244},{4,17595,17599,451,26,6208}}},{"PROC",{{4,17617,17625,452,16,5432}}}}},
--               {T_case,{{4,17646,17651,453,17,6048}}},
--               {T_block,{{1788,{{4,17676,17679,454,22,5012},{T_block,{{131,{{4,17704,17704,455,20,5152},{3,17709,17709,455,25}}},{61,{{4,17731,17732,456,20,5156},{91,{{4,17736,17739,456,25,5592},{4,17741,17741,456,30,5152}}}}},{61,{{4,17764,17770,457,20,5244},{91,{{4,17774,17780,457,30,5948},{4,17782,17783,457,38,5156}}}}},{5,17786,17859,458,0},{1088,{{520,{{520,{{161,{{4,17884,17890,459,23,5244},{4,17893,17898,459,32,6048}}},{161,{{4,17904,17910,459,43,5244},{4,17913,17917,459,52,6208}}}}},{1308,{{161,{{4,17924,17930,459,63,5244},{39,17933,17935,459,72}}},{1300,{{"PROC",{{4,17944,17948,459,83,6020}}}}}}}}},{1608,{{828}}}}}}}}},{61,{{4,18012,18018,461,16,5244},{4,18022,18027,461,26,6048}}},{133,{{4,18045,18045,462,16,5152},{3,18050,18050,462,21}}},{"PROC",{{4,18068,18076,463,16,5456}}}}},{752,{}},{T_block,{{5,18101,18122,464,21},{"MASS",{{201,{}},{"PROC",{{4,18145,18153,465,21,5540},{34,18155,18168,465,31}}}}},{1480}}}}}?
                node = node[2]
--              sequence ctrl = node[1]
--              string expr = emit_expr(ctrl,initp)
--              dent("switch " & expr & xl(" do"),indent)
                dent("switch " & emit_expr(node[1],initp) & xl(" do"),indent)
                bool bBreak = true
                for j=2 to length(node) by 2 do
                    if j>2 and is_js() and bBreak then
                        dent("break;",indent+8)
                    end if
                    sequence nj = node[j]
                    if nj[1]=T_case then
                        nj = nj[2]
                        if length(nj)=1 and nj[1][TOKTYPE]=LETTER and nj[1][TOKTTIDX]=T_else then
                            dent("default: ",indent+4)
                        else
                            dent("case ",indent+4)
                            string cs = ""
                            for k=1 to length(nj) do
                                oneline &= cs & emit_expr(nj[k],0)
                                cs = ", "
                            end for
                            oneline &= ":"
                        end if
                    elsif find(nj[1],{T_default,T_else}) then
                        dent("default: ",indent+4)
                    else
                        ?9/0
                    end if
                    nj = node[j+1]
                    if nj[1]!=T_block then ?9/0 end if
--                  if length(node[j+1][2])=1 then
--                      prevline = line
--                      softdent(
                    nj = nj[2]
                    emit(nj,indent+8)
                    bBreak = true
                    for k=length(nj) to 1 by -1 do
                        nodetype = nj[k][1]
                        if nodetype!=COMMENT
                        and nodetype!=BLK_CMT then
                            bBreak = (nodetype!=T_break and nodetype!=T_fallthrough)
                            exit
                        end if
                    end for
                end for
                dent(xl("end switch"),indent)
            elsif nodetype=T_enum then
-- >enum:{796,{{61,{{4,475,477,13,5,5504},
--                  {3,481,481,13,11}}},
--             {4,489,492,14,5,5524},
--             {4,500,503,15,5,5544},
--             {4,511,516,16,5,5572},
--             {5,522,550,16,16},
--             {4,557,561,17,5,5596}}}?
--trace(1)
                if indent!=0 then ?9/0 end if -- sanity check
                string e = iff(is_phix()?"constant ":"const ")
                dent(e,0)
                indent = length(e)
                node = node[2]
                integer eno = 0, l = length(node)
                for ei=1 to l do
                    sequence ni = node[ei]
                    toktype = ni[TOKTYPE]
                    if toktype=COMMENT
                    or toktype=BLK_CMT then
                        if ei=l then ?9/0 end if
--                      e = emit_expr(ni,0)
                        {toktype, tokstart, tokfinish, line, col} = ni
                        cdent(src[tokstart..tokfinish],toktype,line,col)
                    else
                        if toktype=LETTER then
                            eno += 1
                            e = emit_expr(ni,0) & " = " & sprint(eno)
                        elsif toktype='=' then
                            ni = ni[2]
                            if length(ni)!=2 then ?9/0 end if
                            if ni[1][TOKTYPE]!=LETTER then ?9/0 end if
                            integer n2t = ni[2][TOKTYPE]
                            if n2t=DIGIT then
                                e = emit_expr(ni[2],0)
                                eno = to_number(e)
                            elsif n2t='$' then
                                if ei=1 then ?9/0 end if
                                e = sprint(eno)
                            else
                                ?9/0
                            end if
                            e = emit_expr(ni[1],0) & " = " & e
                        else
                            ?9/0    
                        end if
                        if ei=1 then prevline = tokline end if
                        if ei<l then e &= ',' end if
                        softdent(e,indent)
                        prevline = tokline
                    end if
                end for
                indent = 0
            else    
                ?{"warning: unknown nodetype:",nodetype,tok_name(nodetype)}
                dent(">" & tok_name(nodetype) & ":" & sprint(node) & "?",0)
                flush_oneline()
            end if
        elsif string(nodetype) then
            if nodetype="?" then
                prevline = tokline
                string e = emit_expr(node[2][1],0)
                if is_phix() then
                    softdent(nodetype & e,indent)
                elsif e="9/0" then
--(untried)         softdent("Qu(" & e & ");",indent)
                    softdent(`crash("9/0");`,indent)
                else
--DEV violation
-- also, test eg integer {a,?,c} = "abc"  <==> [,a,,c] = oh, erm...!
                    softdent("print(1, " & e & ");",indent)
--                  ?"warning: ?" & e & " not supported"
--?e
                end if
--              ?(t)??:{"?",{{47,{{3,2338,2338,73,36},
--                                {3,2340,2340,73,38}}}}
--                     }?
--DEV not js??? violation? qu()?
            elsif nodetype="PROC" then
                -- a procedure call...
                prevline = tokline
                softdent(emit_expr(node,0),indent)
                if not is_phix() then oneline &= ";" end if
            elsif nodetype="vardef" then
--/*
?(s)vardef:{"vardef",{{4,426,432,15,0,340},"dlg",{"PROC",{{4,440,448,15,14,2232},{"PROC",{{4,450,457,15,24,2436},{96,459,466,15,33,15},{34,468,505,15,42}}},{34,508,520,15,82}}}}}?
                            T_Ihandln   ^                           IupDialog^                  Iup
--*/
                if length(node)!=2 then ?9/0 end if
                node = node[2]
--              if length(node)!=3 then ?9/0 end if
                prevline = tokline
                string vartype = emit_expr(node[1],0)
--?vartype
                integer v = 2
                if is_phix() then
                    if vartype="let" then
--  node = {{4,66'B',68'D',4,0,1280},{6,70'F',80'P',4,4,4},`dlg`,{},`lbl`,{},`btn`,{},`vbox`,{}}
                        integer n21 = node[2][TOKTYPE]
                        if n21=BLK_CMT then
                            {toktype, tokstart, tokfinish, line, col} = node[2]
                            vartype = src[tokstart+2..tokfinish-2] & " "
                            v = 3
                        elsif n21=T_block then
--  node[2][1] = 576 (T_block)
--  node[2][2][1] = {123'{',{{4,309,309,14,17,5136},{4,323,323,14,31,5140}}}
--  node[2][2][2] = {91'[',{{4,328,328,14,36'$',5136},{4,330,330,14,38'&',5140}}}
--                          node = node[2]
--  node[1] = {4,292,294,14,0,1264}
--  node[2][1] = 576
--  node[2][2][1] = {123'{',{{4,309,309,14,17,5128},{4,323,323,14,31,5132}}}
--  node[2][2][2] = {91'[',{{4,328,328,14,36'$',5128},{4,330,330,14,38'&',5132}}}
--  node[1] = {4,292,294,14,0,1264}
--  node[2][1] = 576
--  node[2][2][1] = {123'{',{{6,298,307,14,6,14},{4,309,309,14,17,5128},{6,311,321,14,19,14},{4,323,323,14,31,5132}}}
--  node[2][2][2] = {91'[',{{4,328,328,14,36'$',5128},{4,330,330,14,38'&',5132}}}
                            if node[2][2][1][TOKTYPE]!='{' then ?9/0 end if
                            vartype = ""
--                          vartype &= " " & emit_expr(node[1],0)
----                            node = node[2]
                        else
                            ?9/0  -- DEV violation
                        end if
                    else
                        if vartype="const" then
                            vartype = "constant "
                        else
                            vartype &= " "
                        end if
                    end if
--                  if length(vartype) then
--                      softdent(vartype & " ", indent)
--                  end if
                    softdent(vartype, indent)
                elsif vartype="let" then
                    softdent("let ",indent)
                elsif find(vartype,{"const","constant"}) then
--                  softdent(iff(is_phix()?"constant ":"const "),indent)
                    softdent("const ",indent)
                else
                    softdent("let /*"&vartype&"*/ ",indent)
                end if
                prevline = tokline
                integer nindent = length(oneline)
                while v<=length(node) do
                    if string(node[v]) then
?"I thought we'd got rid of this (emit()/vardef string)"
                        prevline = tokline
--                      softdent(node[v] & iff(node[v+1]={}?"":" = " & emit_expr(node[v+1],0)), nindent)
                        softdent(node[v] & iff(node[v+1]={}?"":" = "), nindent)
--                      emit_exprn(node[v+1],length(oneline))
                        if node[v+1]!={} then
                            emit_exprn("",node[v+1],length(oneline))
                        end if
                        v += 2
                        if v<length(node) then
                            oneline &= ", "
                        end if
                    else
                        integer nvtype = node[v][TOKTYPE]
                        if nvtype=LETTER then
                            prevline = tokline
--                          softdent(get_name(node[v]) & iff(node[v+1]={}?"":" = "), nindent)
                            softdent(get_name(node[v]), nindent)
--                          emit_exprn(node[v+1],length(oneline))
                            if node[v+1]!={} then
                                oneline &= " = "
                                emit_exprn("",node[v+1],length(oneline))
                            end if
                            v += 2
                            if v<length(node) then
                                oneline &= ", "
                            end if
                        elsif nvtype=BLK_CMT
                           or nvtype=COMMENT then
                            {toktype, tokstart, tokfinish, line, col} = node[v]
--                          oneline &= src[tokstart..tokfinish] & " "
                            cdent(src[tokstart..tokfinish],toktype,line,col)
                            v += 1
--/*
    node[1..7] = {{4,2915,2922,75'K',0,392},`projects`,{123'{',{}},{5,2939,2968,75'K',24},`files`,{123'{',{}},{5,2994,3008,76'L',24}}
    node[8..15] = {`filed`,{123'{',{}},{5,3034,3054,77'M',24},`incexc`,{123'{',{}},{5,3080,3118,78'N',24},`outputs`,{123'{',{}}}
    node[16..19] = {{5,3144,3162,79'O',24},{5,3164,3214,80'P',0},`clears`,{123'{',{}}}
    nodetype = `vardef`

            string {lt,li} = apply(split(lines[i],":",true,2),trim)
    node[1] = {4,4657,4662,127,12,24}
    node[2][1] = 576
    node[2][2][1] = {123'{',{{4,4665,4666,127,20,6000},{4,4668,4669,127,23,6004}}}
    node[2][2][2][1] = `PROC`
    node[2][2][2][2][1] = {4,4674,4678,127,29,1880}
    node[2][2][2][2][2][1] = `PROC`
    node[2][2][2][2][2][2][1..2] = {{4,4680,4684,127,35'#',3312},{91'[',{{4,4686,4690,127,41')',5988},{4,4692,4692,127,47'/',5992}}}}
    node[2][2][2][2][2][2][3..5] = {{34'"',4695,4697,127,50'2'},{4,4699,4702,127,54'6',5012},{3,4704,4704,127,59';'}}
    node[2][2][2][2][3] = {4,4707,4710,127,62'>',6016}
    nodetype = `vardef`

--*/
                        elsif nvtype=T_block then
                            oneline &= emit_expr(node[v][2][1],0)
                            if is_phix() then
                                oneline = substitute_all(oneline,ibctypes,ibtypes)
                            else
                                oneline = substitute(oneline,`["sequence",`,`[,`)
                            end if
                            if node[v][2][2]!={} then
                                oneline &= " = " & emit_expr(node[v][2][2],0)
                            end if
                            v += 1
                        else
                            ?9/0
                        end if
--                      v += 1
                    end if
                end while
                if not is_phix() then oneline &= ";" end if
            elsif nodetype="SASS" then
--?(s)SASS:{"SASS",{{91,{{4,5007,5013,136,16,5656},         '['
--                       {4,5015,5017,136,24,5732}}},
--                  {61,{{4,5022,5023,136,31,5884}}}}}?     '='
--?(s)SASS:{"SASS",{{91,{{4,5123,5128,139,16,5676},
--                       {4,5130,5132,139,23,5732}}},
--                  {61,{{91,{{123,{{4,5138,5141,139,31,5012},
--                                  {4,5143,5147,139,36,4016}}},
--                            {"PROC",{{4,5150,5153,139,43,2016},
--                                     {"PROC",{{4,5155,5159,139,48,5912},
--                                              {4,5161,5162,139,54,5884}}},
--                                     {123,{{34,5166,5168,139,59},
--                                           {34,5170,5172,139,63}}}
--                                    }
--                           }}
--                      }}
--                   }}}?
--?node
--/*
grid[2][2] = 4
grid[1][1..1] = {1} -- nb vlsa!
{"SASS",{{91'[',{{91'[',{{4,536,539,26,12,16520},
                         {3,541,541,26,5}}},
                 {3,544,544,26,8}}},
         {61'=',{{3,549,549,26,13}}}}}
{"SASS",{{91'[',{{91'[',{{4,551,554,27,12,16520},
                         {3,556,556,27,5}}},
                 {199,{{3,559,559,27,8},{3,562,562,27,11}}}}},  -- ELLIPSE
         {61'=',{{123'{',{{3,568,568,27,17}}}}}}}
--wrong:
$subse(grid,2)[2] = 4;
$subse(grid,1)[1..1] = ["sequence",1]; // nb vlsa!
--right:
$repe(grid,2,4,["sequence",2])
$repss(grid,1,1,["sequence",1],["sequence",1])
--*/
                if length(node)!=2 then ?9/0 end if
                node = node[2]
                if node[1][1]!='[' then ?9/0 end if
                integer aop = node[2][1],
                        aoidx = find(aop,{'=',BEQ,PLUSEQ,MNUSEQ,DIVDEQ,MULTEQ,AMPSEQ})
                if aoidx=0 then ?9/0 end if
                if length(node[1][2])!=2 then ?9/0 end if
                if length(node[2][2])!=1 then ?9/0 end if
--  node = {{91'[',{{4,5007,5013,136,16,5656},{4,5015,5017,136,24,5732}}},{61'=',{{4,5022,5023,136,31,5884}}}}
                sequence idx = node[1][2][2]
                bool bBadOp = (idx[1]=ELLIPSE and aoidx>2)
--              if idx[1]=ELLIPSE and aoidx>2 then ?9/0 end if
                string rhs = emit_expr(node[2][2][1],0)
                node = node[1][2][1]
                if is_phix() then
                    dent(emit_expr(node,0)&"["&emit_expr(idx,0)&"] " & tok_name(aop) & " "&rhs,indent)
                else
                    if aop=BEQ then aop = '=' end if
                    sequence idii = {}
                    while node[1]='[' do
                        idii = append(idii,emit_expr(node[2][2],0))
                        node = node[2][1]
                    end while
                    string id = emit_expr(node,0),
                           idiis = iff(length(idii)?`,["sequence",` & join(idii,",") & `]`:"")
                    if idx[1]=ELLIPSE then
                        if aoidx>2 then ?9/0 end if -- expressly forbid s[i..j] +=/-= etc (esp &=)
                        dent(id & " = $repss(" & id & "," & emit_expr(idx[2][1],0) & "," & emit_expr(idx[2][2],0),indent)
                    else
                        dent(id & " = $repe(" & id & "," & emit_expr(idx,0),indent)
                    end if
                    if aoidx>2 then
                        string mop = iff(aop=AMPSEQ?",":{"+","-","/","*"}[aoidx-2]),
                               mid = "$subse(" & id & "," & emit_expr(idx,0) & idiis & ")" &mop & rhs
                        if aop=AMPSEQ then
                            oneline &= ",$conCat(" & mid & ")"
                        else
                            oneline &= "," & mid
                        end if
                    else
                        oneline &= "," & rhs
                    end if -- placeholder for more code (eg s[i] += 1 ==> %repe(s,1,$subse(s,i)+1)...?)
                    if length(idii) then
                        oneline &= idiis
                    end if
                    oneline &= ");"
                end if
                if bBadOp then puts(1,oneline & "\n^^^?????") flush_oneline() dent("^^??????",0) end if
            elsif nodetype="MASS" then
--?(s)MASS:{"MASS",{{576,{}},{"PROC",{{4,158,165,7,5,4004}}}}}?
                if length(node)!=2 then ?9/0 end if
                node = node[2]
                if node[1][1]!=MASS then ?9/0 end if
--              if node[1][2]!={} then ?9/0 end if -- placeholder
                need_let = false
                string lhs = emit_expr(node[1],0)
-- missed the specific case, but probably still wanted...
--              if not is_phix() then lhs = substitute(lhs,`["sequence",`,`[,`) end if
                if is_js() and need_let then
                    lhs = "let " & lhs
                end if
                dent(lhs & " = " & emit_expr(node[2],0),indent)
                if not is_phix() then oneline &= ";" end if
            else
                ?{"warning: unknown nodetype:",nodetype}
                dent("?(s)" & nodetype & ":" & sprint(node) & "?",0)
                flush_oneline()
            end if
        else
            ?9/0
        end if
--      prevline = line
        prevline = tokline
    end for
end procedure

global function generate_source(sequence ast, integer oxt, src_offset, bool pGUI)
    wasext = ext    -- save input language
    ext = oxt       -- set output language, so we can use is_phix() etc.
    initp = iff(is_phix()?0:12)
--?initp
    output = ""
    tokline = src_offset+1
    bGUI = false
--trace(1)
    emit(ast[2])
    flush_oneline()
--erm, we may well need to stitch several sources together...
    if is_html() then
--?1
        string header = iff(bGUI or pGUI?html_headerg:html_headerp),
               aincs = ""
        sequence ai = get_autoincludes()
        for i=1 to length(ai) do
            if ai[i]!="==" then
                string js = "builtins/"&substitute(ai[i],".e",".js")
                aincs &= sprintf("\n   <script src=\"%s\"></script>",{js})
            end if
        end for
--?aincs
        output = sprintf(header,{get_file_name(current_file),aincs}) & use_strict & output & html_footer
    elsif is_phix()
      and pGUI and not bGUI then
        output = "include pGUI.e\n" & output
    end if
    ext = wasext    -- restore input language
    return output
end function

--/*
{`program`,
 {{5,1,2,1,0}, {5,4,22,2,0}, {5,24,42'*',3,0}, {5,44',',45'-',4,0},
  {5,47'/',148,5,0}, {5,150,151,6,0}, 
  {1192, `primes.e`}, T_include
  {1064, {{4,172,177,10,0,1064}}}, T_global
  {`vardef`,
   {{4,179,185,10,7,300}, {4,187,195,10,15,5160}, {3,199,199,10,27},
    {4,202,208,10,30,5184}, {3,212,212,10,40'('}, {4,215,222,10,43'+',5212},
    {3,226,226,10,54'6'}, {4,237,238,11,8,5224}, {}}}, {5,240,269,11,11},
  {968,
   {{`vardef`,
     {{4,271,273,12,0,968}, {4,275,275,12,4,5228}, {3,277,277,12,6}}},
    {3,282,286,12,11}, {},
    {576,
     {{61'=',
       {{4,295,296,13,4,5224},
        {43'+',
         {{`PROC`,
           {{4,300,302,13,9,3408},
            {`PROC`, {{4,304,310,13,13,2016}, {4,312,312,13,21,5228}}}}},
          {161, {{4,317,317,13,26,5228}, {3,320,320,13,29}}}}}}},
      {1088,
       {{61'=', {{4,330,331,14,7,5224}, {4,333,333,14,10,5228}}},
        {1608, {{131, {{4,348,354,15,8,5184}, {3,359,359,15,19}}}}},
        {788, {{60'<', {{4,371,372,16,10,5224}, {4,374,374,16,13,5228}}}}},
        {1608, {{131, {{4,389,397,17,8,5160}, {3,402,402,17,21}}}}},
        {776, {{131, {{4,421,428,19,8,5212}, {3,433,433,19,20}}}}}}}}}}},
  {`PROC`,
   {{4,454,459,22,0,3260}, {3,461,461,22,7}, {34'\"',463,503,22,9},
    {123'{',
     {{4,506,514,22,52'4',5160}, {4,517,523,22,63'?',5184},
      {4,526,533,22,72'H',5212}}}}},
  {`MASS`, {{201, {}}, {`PROC`, {{4,542,549,23,5,4036}}}}},
  {5,553,596,24,0}, {5,598,599,25,0}}}
"can this happen anymore?? (treeify)"
--*/
