// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// timedate.e
// ==========
//
//  Inspired by but with very little connection to the OpenEuphoiria std\datetime.e
//  Also influenced by Python, and (some of!) the C# DateTime object.
//
//  Incorporates additional timezone and daylight savings handling.
//
//DEV/SUG:
//> atom diff = timediff(timedate t1, timedate t2)
//      the result is a value in seconds, compatible/comparable with a result from timedelta.
//> string res = format_timedelta(atom td) -- ?[, string fmt=??, integer flags=??]?
//      returns a string representation of a timedelta, eg "127 days, 4 hours, 15 minutes and 10 seconds".
//? isleapyear [or link to], isdaylightsavingtime
//x> integer c = time_cmp(timedate t1, timedate t2)
//x     returns -1, 0, 1 in a similar fashion to compare [is compare not good enough?   ** OF COURSE IT IS! **, also <, <=, >, >=, =, !=...]
 /* worth testing:
--/ Define two dates.
--DateTime date1 = new DateTime(2016, 1, 10, 11, 20, 30);
--DateTime date2 = new DateTime(2016, 2, 20, 12, 25, 35);
--
--hxxps://msdn.microsoft.com/$en-us/library/system.datetime.datetime(v=vs.110).aspx%3E
--// Calculate the interval between the two dates.
--TimeSpan interval = date2 - date1;
--
--// Display individual properties of the resulting TimeSpan object.
--Console.WriteLine("No of Days:", interval.Days); // 41
--Console.WriteLine("Total No of Days:", interval.TotalDays); // 41.0451
--Console.WriteLine("No of Hours:", interval.Hours); //1
--Console.WriteLine("Total No of Hours:", interval.TotalHours); // 985.084
--Console.WriteLine("No of Minutes:", interval.Minutes); // 5
--Console.WriteLine("Total No of Minutes:", interval.TotalMinutes); // 59105.833
--Console.WriteLine("No of Seconds:", interval.Seconds); // 5
--Console.WriteLine("Total No of Seconds:", interval.TotalSeconds); // 3546305.0
--Console.WriteLine("No of Milliseconds:", interval.Milliseconds); // 0
--Console.WriteLine("Total No of Milliseconds:", interval.TotalMilliseconds); // 3546305000
--Console.WriteLine("Ticks:", interval.Ticks); // 354630500000000
*/ 
//</DEV/SUG>
//
//  type timedate (weak validation)
//      a sequence of between 8 and 10 integers, depending on whether it has a timezone.
//      The result from date() is a valid timedate, without a timezone, as is {0,0,0,0,0,0,0,0}.
//      This type speeds development by trapping errors (eg "number expected") faster, as opposed to
//      catching partial or unusable values. It will however holler if it gets a month -1 or 13, or
//      a day or -1 or 32. Where you see "td" below, assume it is a timedate
//
//  timedelta(atom weeks=0, days=0, hours=0, minutes=0, seconds=0, milliseconds=0, microseconds=0)
//      returns a value in seconds and fractions of a second (idea cribbed from python)
//      milli/microseconds are probably only useful in these routines in delta*bignumber cases.
//      eg: atom tendays = timedelta(days:=10)
//
//  adjust_timedate(timedate td, atom timedelta)
//      returns a timedate adjusted by the specified delta in seconds
//      eg: td = adjust_timedate(td, tendays)
//
//  set_timezone(timedate td, string newtz)
//      Set a specific timezone on an un-timezoned timedate.
//      eg: td = set_timezone(td, "BST")
//
//  change_timezone(timedate td, string newtz)
//      converts a timedate to a different timezone
//      eg: td = change_timezone(td, "EDT")
//
//  set_timedate_formats(sequence parse_fmts, object out_fmt=1, integer partial=0)
//      sets the parameter defaults for parse_date_string() and format_dateline().
//      parse_fmts is a collection of formats for parse_date_string(), and
//      out_fmt is a single string or index to parse_fmts for format_timedate().
//      the partial flag controls whether to ignore excess text when parsing,
//      and if set, then parse_fmts should be ordered most detailed first.
//      eg: set_timedate_formats({"Mmmm d yyyy h:mmam tz"})
//
//  parse_date_string(string s, sequence fmts=$default_parse_fmts, integer partial=$allow_partial)
//      convert a string into a timedate [using set_timedate_formats() defaults].
//      eg: td = parse_date_string("March 7 2009 7:30pm EST")
//
//  format_timedate(timedate td, string fmt=$default_format)
//      convert a timedate into a string [using set_timedate_formats() defaults].
//      eg format_timedate(td) -- reconstitutes the preceding example
//
// for advanced use/testing only:
// =============================
//  override_timezone(string tz, string desc, atom adj, object dsr=0, string dst="")
//      dynamically modify/specify timezone details (for clash handling)
//
//  get_tzid(string tz)
//      get the internal integer id for a timezone (for testing purposes only)
//
//
// Technical notes:
//  I completely replaced the julian date stuff as the OE one didn't seem to gel
//  with some timezone code I found, but I've since replaced the latter and realised
//  it was really an internal implementation detail rather than any real bug that I
//  could pin down: the upshot is that the julian dates this uses internally are 
//  wholly incompatible with std/datetime.e, not like that should bother anyone.
//
//  

//DEV until I've fixed it (earein.ew handling of switch statements, multi-assignment, etc.
//          I'll work on a copy of this file w/o the next line soon [he said on 17/9/15]):
//#without reformat

//include pdate.e -- days_in_month() [not pwa/p2js]

// deliberately not global, to deter direct inspection:
const $DT_TZ = 9, 
      $DT_DSTZ = 10;
//(Draft/Old)
//  Daylight Savings Time
//  =====================
//
//      These routines offer limited support for daylight savings time.
//      Only current $US/$EU/$AU rules are implemented; I have created what
//      I think are all the needed $DSTrule entries, but it's the testing
//      /local knowledge that is the hard part. I have no plans to ever 
//      implement all the rules dating back to 1916, but if that floats 
//      your boat... feel free. (See you the christmas after next.)
//      As implemented, daylight savings always start at 12am and end at 
//      1am, rather than the precise country-specific times.
//
//      If you define something in BST and want to know the equivalent
//      in GMT, or EDT, that's all fine and easy:
//
//          set_timedate_formats({"D/M/YYYY hhpm TZ"})
//          s = parse_date_string("1/8/2015 10am BST")
//          s = change_timezone(s,"GMT")
//          ?format_timedate(s)
//
//      If you add 4 $months you want to get "1/12/2015 9am GMT", then add 
//      another 6 $months and it should be "1/6/2015 10am BST". To do this,
//      every timedate has both [$DT_TZ], which qualifies the value being
//      held, and [$DT_DSTZ], which holds the "test/revert to" timezone.
//      Note that parsing say "25/12/2015 10am BST" will do the honorable
//      thing, and return the same kind of gibberish that you fed in.
//      Likewise, changetimezone("25/12/2015 10am GMT",BST) will yield a
//      value that a) still prints "10am GMT", and b) after adding 9 
//      $months then prints "prints 9am BST". So, you convert it even when
//      it ain't got no immediate effect on display, capiche? It may also
//      be that you get "1/6/15 10am" but you know that means BST, so use
//      set_timezone(td,"BST"), which you can rest assured will do the 
//      right thing with 25/12 10am as well (ie leave it 10am GMT).
//
//      Finally, of course we don't really care about the geographical
//      locations these rules apply to, but it makes sense to keep two
//      entries separate if legislative changes could apply to one but
//      not the other, at some point in the future.
let /*sequence*/ $DSTrule = ["sequence"]; // rules for start and end days of DST
function $addDSTrule(/*object*/ rule) {
    $DSTrule = append($DSTrule,rule);
    return length($DSTrule);
}
const $EU = $addDSTrule(["sequence",3,25,10,25,1]);               // Last Sunday in March to Last Sunday in October       (Europe)
const $US = $addDSTrule(["sequence",3,8,11,1,1]);                 // Second Sunday in March to first Sunday in November   (North America)
const $AU = $addDSTrule(["sequence",10,1,4,1,1]);                 // First Sunday in October to first sunday in April     (South Australia)

//  == Daylight Savings Time rules as of 2015 ==
// Tried my best to double-check these (obviously many out-of-date websites exist with conflicting info),
//  but not tested any of them (a complete lack of any local knowledge is one very good reason why not).
//  I mainly used a "tzdata" thing that looked like it would be the best/most reliable, but it's huge...
//constant ?BRAZIL(SOUTH/CENT)? = $addDSTrule({10,15,2,15,1})    -- Third Sunday in October to third Sunday in February  (also delays end during carnival week)
//constant ?FIJI? = $addDSTrule({11,1,1,15,1})                   -- First Sunday in November to third Sunday in January
//constant ?FIJI2? = $addDSTrule({11,1,1,18,1})                  -- First Sunday in November to Sunday>=18 in January
//constant ?MEXICO? = $addDSTrule({4,1,10,25,1})                 -- First Sunday in April to last Sunday in October  (some exceptions, eg Sonora)
//constant ?CUBA? = $addDSTrule({3,8,11,1,1})                    -- Second Sunday in March to first Sunday in November
//constant ?HAITI?==CUBA
//constant ?ISRAEL?    = $addDSTrule({3,25,10,25,6,1})           -- Last Friday in March to Last Sunday in October
//constant ?JORDAN?    = $addDSTrule({3,25,10,25,6,6})           -- Last Friday in March to Last Friday in October
//constant ?PALESTINE? = $addDSTrule({3,25,10,22,6,6})           -- Last Friday in March to fourth Friday in October
//constant ?MONGOLIA? = $addDSTrule({3,25,9,24,1})               -- Last Sunday in March to last Sunday in September (not 2007..2014)
//constant ?NAMIBIA? = $addDSTrule({9,1,4,1,1})                  -- First Sunday in Septmber to First Sunday in April
//constant ?NEWZEALAND? = $addDSTrule{(9,24,4,1,1})              -- Last Sunday in September to first Sunday in April
//constant ?SAMOA(?WESTERN?)? = NEWZEALAND
//constant ?PARAGUAY? - $addDSTrule({10,1,3,22,1})               -- First Sunday in October to fourth Sunday in March
//constant ?SYRIA? = $addDSTrule({3,25,10,25,6,6})               -- Last Friday in Match to last Friday in October (same as Jordan)
//constant ?ZION? = $addDSTrule({3,23,10,25,6,1})                -- Friday on or after 23rd Match to last Sunday in October
// Canada (excluding Saskatchewan and parts of Quebec, B.C., and Ontario), Bermuda, St. Johns, Bahamas, Turks and Caicos use the $US rule.
// Cayman Islands due to start DST in 2016
// Chatham uses NZ rule but switches at 2:45am
// Greenland switches over at 22/23:00 on a Saturday but otherwise same rule as $EU.
// Iran starts March 21-22 and ends September 21-22 (code for that one manually?) [for 1996 and on, use d = 21+(remainder(y,4)!=0)]
// Lebanon, Kyrgyzstan, Moldova, and Turkey use the same rule as $EU
// Morocco and the parts of Western Sahara it controls uses the same rule as $EU except that DST is stopped during Ramadan.
// Some $US bases in Antarctica use NZ DST, "Troll" whatver that is, uses the $EU rule
// 

//
// Feel free to add more (non-clashing) entries, or set them up dynamically per
//  application using set_timezone() (see below). There are plenty of (out of date 
//  and conflicting websites out there with dirty great lists of timezone codes
//  (eg https://$en.wikipedia.org/wiki/List_of_time_zone_abbreviations ), the trick 
//  is not typing them in but matching up with the correct daylight savings rule(s).
//
// Britain is an obvious odd one out in terms of there being no "British Winter Time": 
//  GMT is not in any way tied to BST, it's the other way round. Other daylight savings
//  have a natural partner. For instance all areas that use ADT are part of AST, (eg/ie
//  Nova Scotia in Canada) but not all areas that use AST use ADT (eg Barbados). If in 
//  a region that uses daylight savings, and you want times to auto-toggle, obviously
//  when adjusted that is, then use the summer time with a non-zero $tzDSR, 4th column.
//  It should be obviuous why the partner of {ADT,$US,AST} is {AST,0,ADT} and is not
//  {AST,$US,ADT} - the latter would toggle Barbados times to ADT. Strictly speaking,
//  it could equally be {AST,0,""}, as with no rule $tzDSL could not be used anyway,
//  but somehow pairing them up feels better, even with no possible practical use.
//
// In the following incomplete table I have commented out anything that might be even
//  just a little bit dubious, and not attempted anything with no suitable $tzDSR value.
//  Feel free to add/uncomment/correct as you see fit.
//
const $tdaDD = ["sequence", ["sequence","UTC", "Coordinated Universal Time", +0, 0, ""],
                          ["sequence","BST", "British Summer Time", +1, $EU, "GMT"],
                          ["sequence","GMT", "Greenwich Mean Time", +0, 0, ""],
                          ["sequence","CEST", "Central European Summer Time", +2, $EU, "CET"],
                          ["sequence","CET", "Central European Time", +1, 0, "CEST"],
                          ["sequence","EEST", "Eastern European Summer Time", +3, $EU, "EET"],
                          ["sequence","EET", "Eastern European Time", +2, 0, "EEST"],
                          ["sequence","IST", "Irish Standard Time", +1, $EU, "GMT"],
                          ["sequence","WEST", "Western European Summer Time", +1, $EU, "WET"],
                          ["sequence","WET", "Western European Time", +0, 0, "WEST"],
                          ["sequence","ADT", "Atlantic Daylight Time", -3, $US, "AST"],
                          ["sequence","AST", "Atlantic Standard Time", -4, 0, "ADT"],
                          ["sequence","AKDT", "Alaska Daylight Time", -8, $US, "AKST"],
                          ["sequence","AKST", "Alaska Standard Time", -9, $US, "AKDT"],
                          ["sequence","CDT", "Central Daylight Time", -5, $US, "CST"],
                          ["sequence","CST", "Central Standard Time", -6, 0, "CDT"],
                          ["sequence","EDT", "Eastern Daylight Time", -4, $US, "EST"],
                          ["sequence","EST", "Eastern Standard Time", -5, 0, "EDT"],
                          ["sequence","EGST", "Eastern Greenland Summer Time", +0, $EU, "EGST"],
                          ["sequence","EGT", "Eastern Greenland Time", -1, 0, "EGT"],
                          ["sequence","HADT", "Hawaii-Aleutian Daylight Time", -9, $US, "HAST"],
                          ["sequence","HAST", "Hawaii-Aleutian Standard Time", -10, 0, "HADT"],
                          ["sequence","MDT", "Mountain Daylight Time", -6, $US, "MST"],
                          ["sequence","MST", "Mountain Standard Time", -7, 0, "MDT"],
                          ["sequence","NDT", "Newfoundland Daylight Time", -2.5, $US, "NST"],
                          ["sequence","NST", "Newfoundland Standard Time", -3.5, 0, "NDT"],
                          ["sequence","PDT", "Pacific Daylight Time", -7, $US, "PST"],
                          ["sequence","PST", "Pacific Standard Time", -8, 0, "PDT"],
                          ["sequence","WGST", "Western Greenland Summer Time", -2, $EU, "WGT"],
                          ["sequence","WGT", "West Greenland Time", -3, 0, "WGST"],
                          ["sequence","ACST", "Australian Central Standard Time", +9.5, 0, "ACDT"],
                          ["sequence","ACDT", "Australian Central Daylight Time", +10.5, $AU, "ACST"],
                          ["sequence","AEST", "Australian Eastern Standard Time", +10, 0, "AEDT"],
                          ["sequence","AEDT", "Australian Eastern Daylight Time", +11, $AU, "AEST"],
                          ["sequence","AWST", "Australian Western Standard Time", +8, 0, ""]];
let /*sequence*/ [,$timezones,$tzdescs,$tzadjs,$tzDSR,$tzDSL] = columnize($tdaDD);
//some other leftovers that may be helpful (or not):
// [[UTC-09:00]] ([[Alaska Time Zone|AKT]]) - most of the state of [[Alaska]]
// [[UTC-03:00]] ([[Time in Argentina|ART]])
// [[UTC+02:00]] ([[Central Africa Time|CAT]])
// [[UTC+10:00]] ([[Chamorro Time Zone|ChT]]) - [[Guam]] and the [[Northern Mariana Islands]]
// [[UTC+07:00]] ([[Christmas Island Time|CXT]]) - [[Christmas Island]]
// [[UTC+03:00]] ([[East Africa Time|EAT]])
// [[UTC+03:00]] ([[Further-eastern European Time|FET]])
// [[UTC-03:00]] ([[Falkland Islands Standard Time|FKST]]) - [[Falkland Islands]]
// [[UTC-06:00]] ([[Galapagos Time|GALT]]) - [[Galapagos Province, Ecuador|Galapagos Province]]
// [[UTC-10:00]] ([[Hawaii-Aleutian Time Zone|HAT]]) -  [[Hawaii]], most of the [[Aleutian Islands]], and [[Johnston Atoll]]
// [[UTC+08:00]] ([[Hong Kong Time|HKT]])
// [[UTC+03:30]] ([[Iran Standard Time|IRST]])
// [[UTC+09:00]] ([[Japan Standard Time|JST]])
// [[UTC+11:30]] ([[Norfolk (Island) Time|NFT]]) - [[Norfolk Island]]
// [[UTC-05:00]] ([[Time in Peru|PET]])
// [[UTC+08:00]] ([[Philippine Standard Time|PHT]])
// [[UTC+05:30]] ([[Sri Lanka Standard Time|SLST]])
// [[UTC+08:00]] ([[Singapore Standard Time|SST]])
// [[UTC-11:00]] ([[Samoa Time Zone|ST]]) - [[American Samoa]], [[Jarvis Island]], [[Kingman Reef]], [[Midway Atoll]] and [[Palmyra Atoll]]
// [[UTC+01:00]] ([[West Africa Time|WAT]])

//DEV unused as yet...
const $ktz = ["sequence", ["sequence","ADT", "HAA"],
                        ["sequence","AKDT", "HAY"],
                        ["sequence","AKST", "HNY"],
                        ["sequence","AST", "HNA"],
                        ["sequence","CDT", "HAC"],
                        ["sequence","CST", "HNC"],
                        ["sequence","CET", "CRT"],
                        ["sequence","EDT", "HAE"],
                        ["sequence","EST", "HNE"],
                        ["sequence","EST", "ET"],
                        ["sequence","MDT", "HAR"],
                        ["sequence","MST", "HNR"],
                        ["sequence","NST", "HNT"],
                        ["sequence","PDT", "HAP"],
                        ["sequence","PST", "HNP"],
                        ["sequence","PST", "PT"],
                        ["sequence","CST", "CT"],
                        ["sequence","MST", "MT"]];
const [,$alttzkeys,$alttz] = columnize($ktz);
if (sequence($alttzkeys) || sequence($alttz)) { }
let /*sequence*/ $validtd = repeat(0,$DT_DSTZ); // (say it out loud!)
$validtd = $repe($validtd,DT_YEAR,["sequence",1,0]); // do not test
$validtd = $repe($validtd,DT_MONTH,["sequence",0,12]);
$validtd = $repe($validtd,DT_DAY,["sequence",0,31]);
$validtd = $repe($validtd,DT_HOUR,["sequence",0,23]);
$validtd = $repe($validtd,DT_MINUTE,["sequence",0,59]);
$validtd = $repe($validtd,DT_SECOND,["sequence",0,59]);
//  $validtd[DT_DOW] = {0,7}
$validtd = $repe($validtd,DT_DOW,["sequence",0,999]); // accomodate milliseconds
$validtd = $repe($validtd,DT_DOY,["sequence",0,366]);
    // (the following two entries are updated in override_timezone)
$validtd = $repe($validtd,$DT_TZ,["sequence",0,length($timezones)]);
$validtd = $repe($validtd,$DT_DSTZ,["sequence",0,length($timezones)]);
/*without trace*/
/*global*/ function timedate(/*object*/ s) {
// result from date() should pass as well as those with timezome info
// note this must permit the result of eg parse_date_time, which can
// be {0,0,0,0,0,0,0,0}.
    let /*object*/ si;
    let /*integer*/ vmin, vmax;
    if (sequence(s) && compare(length(s),DT_SECOND)>=0) {
        for (let i=1, i$lim=length(s); i<=i$lim; i+=1) {
            si = $subse(s,i);
            if (!integer(si)) { return 0; }
            [,vmin,vmax] = $subse($validtd,i);
            if (vmin<=vmax) {
                if (compare(si,vmin)<0 || compare(si,vmax)>0) {
                    return 0;
                }
            }
        }
//added 20/11/19:
//7/5/20:
//      if s[DT_YEAR]!=0 and s[DT_MONTH]!=0 and s[DT_DAY]!=0
        if (((compare($subse(s,DT_YEAR),1752)>=0 && (!equal($subse(s,DT_MONTH),0))) && (!equal($subse(s,DT_DAY),0))) && compare($subse(s,DT_DAY),days_in_month($subse(s,DT_YEAR),$subse(s,DT_MONTH)))>0) {
            return 0;
        }
        return 1;
    }
    return 0;
}
/*with trace*/
/*global*/ function timedelta(/*atom*/ weeks=0, /*atom*/ days=0, /*atom*/ hours=0, /*atom*/ minutes=0, /*atom*/ seconds=0, /*atom*/ milliseconds=0, /*atom*/ microseconds=0) {
//
// The parameters are expected to be named: while 7 hours and 30 minutes could legally be defined using timedelta(0,0,7,30),
//  it is entirely expected the far more readable timedelta(hours:=7, minutes:=30) or timedelta(hours:=7.5) be used instead.
//
// The parameters are defined as atoms to allow huge and/or fractional values to be passed.
//
// 1,000 milliseconds equal 1 second and 1,000 microseconds equal 1 millisecond (and 1,000,000 microseconds equal 1 second)
//
// Returns an atom representing the timedelta in seconds and fractions of a second.
//
// Fairly obviously, I should hope, invoking timedelta(seconds:=a) is a rather pointless exercise.
//
// timedeltas up to one year should be accurate to within one microsecond or better,
// timedeltas up to one thousand years should be accurate to within one millisecond or better,
// timedeltas up to one million years should be accurate to within one second or better.
// timedeltas up to one billion years should be accurate to within 15 minutes or better.
// timedeltas up to the age of the universe should be accurate to within 4 hours or better.
//  all of the above accuracy claims are rendered completely moot by the following statements:
// timedeltas have no notion of and will account for neither leap years nor leap seconds; an
//  application programmer wishing to alter dates by more than 4 weeks is advised to take care
//  of any whole $months/years separately and manually, perhaps with a loop to adjust month by
//  12 and year by 1 until month is between 1 and 12, probably requiring standard/leap fiddles
//  for days near the end of the month, but days and below via a timedelta, and anything like 
//  first or last thursday of the month should probably not be using this routine at all.
// timedeltas have no notion of and will account for neither general relativity nor worm holes;
//  passengers travelling near the speed of light or passing through time portals should avoid 
//  attempting to apply timedeltas to any correspondingly incompatible timeframes.
//
    return (((((weeks*7+days)*24+hours)*60+minutes)*60+seconds)+milliseconds*.001)+microseconds*.000001;
}
//  Format Strings (modified)
//  Date and time format elements for parsing/printing are defined by the following groups of characters:
//
//  Element  Aliases     Description  
//  d           D       One- or two-digit day.  
//  dd          DD      Two-digit day. Single-digit day values are preceded by a zero.  
//  th       st/$TH/ST   Two-character ordinal suffix. (lower/uppercase)  Must immediately follow d/D/dd/DD.
//  ddd      Ddd/DDD    Three-character weekday abbreviation.  (lowercase/capitalised/uppercase)
//  dddd    Dddd/DDDD   Full weekday name.  (lowercase/capitalised/uppercase)
//  h           H       One- or two-digit hour.                                    (See am/pm notes below.)
//  hh          HH      Two-digit hour. Single-digit values are preceded by a zero. ""
//  m           mm      Two-digit minute. Single-digit values are preceded by a zero.        (NB not M/MM)
//  s        ss/S/SS    Two-digit second. Single-digit values are preceded by a zero.
//  pm       am/PM/$AM   Two-letter am/pm abbreviation, prior hour must exist. (lower/uppercase)
//  M                   One- or two-digit month number.                                      (NB not m)
//  MM                  Two-digit month number. Single-digit values are preceded by a zero.  (NB not mm)
//  mmm      Mmm/MMM    Three-character month abbreviation. (lowercase/capitalised/uppercase)
//  mmmm    Mmmm/MMMM   Full month name.  (lowercase/capitalised/uppercase)
//  y        yy/Y/YY    One- or two-digit year.
//  yyyy       YYYY     Four-digit year.
//  tz          $TZ      Three- or four-character uppercase time zone
//  tzz      Tzz/TZZ    Full time zone name. (capitalised)
//
// SUG:
//  n       nnn/N/NNN   The day of year. (nn/NN are also acceptable)
//
//  Notes: Special attention is required to avoid confusing m/mm (minute) and M/MM (month).
//         Spaces and punctuation (other than single quotes) in a format are treated as literals.
//         Any required literal alphanumerics must be enclosed in single quotes, with two adjacent
//         single quotes treated as one single quote, eg "'Today''''s date is 'DD/MM/YYYY.") which
//         yields/parses eg "Today's date is 14/09/2015."
//         Feel free to print fragments, eg "dst", "Mmmm", "tz", and post-process/stitch together.
//         At the moment $td_ordinals (1st/2nd/3rd/4th/etc) are only supported in/for english.
//         Minutes and seconds <10 cannot be printed without a leading 0, but month/day/hours can.
//         DD/dd/mm/MM will refuse to parse single digit inputs, however d/D/h/H/m/M/s will.
//         lowercase/uppercase actually match any case input, whereas capitalised is more strict;
//          it is really for output that all those different distinctions are available anyway.
//         Obviously uppercase/lowercase format specifiers make no difference on numeric fields.
//         A timezone is always parsed and printed in uppercase. tzz/Tzz/TZZ as-is, see tzdesc.
//         When am/pm is parsed/printed, it adjusts a previous hour (error if none) appropriately.
//          There is no way to print a 12-hour time without also printing an am/pm indicator.
//         The times "12:15am" and "2:15pm" are internally stored as {0,15} and {14,15} respectively,
//          and reconstituted exactly they were as long as you use the same format string.
//         Some languages, eg de, use a two-character weekday abbreviation - but the format string 
//          used to obtain said is still three characters long (ddd/Ddd/DDD).
//         Great care has been taken to avoid any potential ambiguity, the only potential mishap
//          is "stz" which opts for "st" (aka "th") which will probably error out because it
//          does not immediately follow a d, and if it was "dstz" then it would error on the 
//          "z" anyway. Should you really want seconds hard pressed against a timezone with 
//          no separating space, use "sstz" instead.
//

//constant true = (1=1), false = not true
const $TD_LITERAL = 1,
      $YEAR = 2,
      $MONTH = 3,
      $DAY = 4,
      $DOW = 5,
      $DOY = 6,
      $HOUR = 7,
      $MINUTE = 8,
      $SECOND = 9,
      $MSEC = 10,
      $AM = 11,
      $TZ = 12,
      $TH = 13
const $en = 1,
      $langmax = 1
let /*integer*/ $currlang = $en;
let /*sequence*/ $months = repeat(0,$langmax), 
                 $day_names = repeat(0,$langmax), 
//       shortdaylen = repeat(3,$langmax),
                 $td_ordinals = repeat(["sequence",""],$langmax), 
                 $ampm = repeat(0,$langmax);
//DEV
//,     langcodes   = repeat(0,$langmax)
//langcodes[$en] = "EN"  -- English
//langcodes[de] = "DE"  -- German
//langcodes[es] = "ES"  -- Spanish
//langcodes[fi] = "FI"  -- Finnish
//langcodes[fr] = "FR"  -- French
//langcodes[it] = "IT"  -- Italian
//langcodes[nl] = "NL"  -- Dutch
//langcodes[pt] = "PT"  -- Portugese
//global procedure set_timedate_lang(string langcode)
//  $currlang = find(upper(langcodes),langcode)
//  if $currlang=0 then ?9/0 end if
//end procedure
//English:
//January February March April May June July August September October November December 
//Sunday Monday Tuesday Wednesday Thursday Friday Saturday
$months = $repe($months,$en,["sequence","January","February","March","April","May","June","July","August","September","October","November","December"]);
//12/1/2020:
//$day_names[$en] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"}
$day_names = $repe($day_names,$en,["sequence","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"]);
//Google Translate (manually re-ascii-fied):
//$months[de] = {"Januar","Februar","Marz","April","Mai","Juni","Juli",
//              "August","September","Oktober","November","Dezember"}
//$day_names[de] = {"Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"}
//$months[es] = {"Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio",
//              "Agosto","Septiembre","Octubre","Noviembre","Diciembre"}
//$day_names[es] = {"Domingo","Lunes","Martes","Miercoles","Jueves","Viernes","Sabado"}
//$months[fi] = {"Tammikuu","Helmikuu","Maaliskuu","Huhtikuu","Toukokuu","Kesakuu",
//              "Heinakuu","Elokuu","Syyskuu","Lokakuu","Marraskuu","Joulukuu"}
//$day_names[fi] = {"maanantai","tiistai","keskiviikko","torstai","perjantai","lauantai"}
//$months[fr] = {"Janvier","Fevrier","Mars","Avril","Mai","Juin","Juillet",
//              "Aout","Septembre","Octobre","Novembre","Decembre"}
//$day_names[fr] = {"Dimanche","Lundi","Mardi","Mercredi","Jeudi","Vendredi","Samedi"}
//$months[it] = {"Gennaio","Febbraio","Marzo","Aprile","Maggio","Giugno","Luglio",
//              "Agosto","Settembre","Ottobre","Novembre","Dicembre"}
//$day_names[it] = {"domenica","lunedi","martedi","mercoledi","giovedi","venerdi","sabato
//$months[nl] = {"Januari","februari","maart","april","mei","juni","juli",
//              "augustus","september","oktober","november","december"}
//$day_names[nl] = {"zondag","maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag"}
//$months[pt] = {"Janeiro","Fevereiro","Marco","Abril","Maio","Junho","Julho",
//              "Agosto","Setembro","Outubro","Novembro","Dezembro"}
//$day_names[pt] = {"domingo","segunda","terca","quarta","quinta","sexta","sabado"}
$td_ordinals = $repe($td_ordinals,$en,["sequence","st","nd","rd","th"]);
//$td_ordinals[fr] = {"er","e"} --??

//DEV (only non-3 are rqd)
//shortdaylen[de] = 2
$ampm = $repe($ampm,$en,["sequence","am","pm"]);
// after updates to check the hours - not entirely perfect, but 5*1hr fwd then back gets:
//          "2015/03/28 10pm GMT"
//          "2015/03/28 11pm GMT"
//          "2015/03/29 1am BST"    -- (really 12am GMT)
//          "2015/03/29 2am BST"
//          "2015/03/29 3am BST"
//          "2015/03/29 4am BST"
//          "2015/03/29 3am BST"
//          "2015/03/29 2am BST"
//          "2015/03/29 1am BST"    -- ("")
//          "2015/03/28 11pm GMT"
//          "2015/03/28 10pm GMT"
//          ==
//          "2015/10/24 10pm BST"
//          "2015/10/24 11pm BST"
//          "2015/10/25 12am BST"
//          "2015/10/25 1am BST"
//          "2015/10/25 1am GMT"
//          "2015/10/25 2am GMT"
//          "2015/10/25 1am GMT"
//          "2015/10/25 1am BST"
//          "2015/10/25 12am BST"
//          "2015/10/24 11pm BST"
//          "2015/10/24 10pm BST"
function $isDSTr(/*timedate*/ td, /*integer*/ ruleidx) {
    let /*integer*/ [,y,m,d,h] = td;
    let /*sequence*/ dsrule = $subse($DSTrule,ruleidx);
    let /*integer*/ sm, sd, em, ed, wd; // (start/end month/day weekday)
    let /*integer*/ prevSun; // (can be -ve near the start of the month)
    if (y<1916) { return false; }      // (not that this has any rules for 1916..2014)
    [,sm,sd,em,ed,wd] = dsrule;
    if (sm<em) {  // northern hemisphere
        if (m<sm || m>em) { return false; }
        if (m>sm && m<em) { return true; }
    } else {
         // down under
        if (m>sm || m<em) { return true; }
        if (m<sm && m>em) { return false; }
    }
    if (wd!==1) { crash("9/0"); } // different code needed for Friday handling, 
//12/01/2020 (See readme. Without testing, I am just going to map dow back to Sun..Sat)
//  prevSun = d - day_of_week(y,m,d) + 1
    let /*integer*/ dow = $subse(["sequence",2,3,4,5,6,7,1],day_of_week(y,m,d));
    prevSun = (d-dow)+1;
//  if m=sm then return prevSun>=sd end if
    if (m===sm) {
        if (compare(length(td),$DT_DSTZ)<0 || (equal($subse(td,$DT_TZ),$subse(td,$DT_DSTZ)))) {
            if (d===prevSun) {
                return h>=1;
            }
        } else {
            if (equal(d,prevSun+1)) {
                return h>=1;
            }
        }
        return prevSun>=sd;
    }
    if (!equal(length(dsrule),5)) { crash("9/0"); } // .. plus wd=dsrule[6] for Israel etc.
//  if m=em then return prevSun<ed end if
    if (m===em) { // (always true)
        if (d===prevSun) {
            if (compare(length(td),$DT_DSTZ)<0 || (equal($subse(td,$DT_TZ),$subse(td,$DT_DSTZ)))) {
                return h<2;
            }
            return h<1;
        }
        return prevSun<ed;
    }
    crash("9/0"); // should never happen
}
//DEV move to test routine?
//if $isDSTr({2015, 8, 1},$EU)=0 then ?9/0 end if
//if $isDSTr({2015,12,25},$EU)=1 then ?9/0 end if
//if $isDSTr({2015, 3,28},$EU)=1 then ?9/0 end if
//if $isDSTr({2015, 3,29},$EU)=0 then ?9/0 end if
//if $isDSTr({2015,10,24},$EU)=0 then ?9/0 end if
//if $isDSTr({2015,10,25},$EU)=1 then ?9/0 end if
function $get_DST_rule(/*timedate*/ td, /*integer*/ DT_TZX) {
    let /*integer*/ tz = $subse(td,DT_TZX);
    if (tz===0) { return 0; }
    return $subse($tzDSR,tz);
}
//DEV??
//function isDST(timedate td)
//integer dsrule = $get_DST_rule(td,$DT_TZ)
//  if dsrule=0 then return 0 end if
//  return $isDSTr(td,dsrule)
//end function

/*global*/ function get_tzid(/*string*/ tz) {
// for testing purposes only
    return find(tz,$timezones);
}
//global function get_tzdesc(object tz)
//-- tz should be a string, eg "GMT", or an integer from td[$DT_TZ] or td[$DT_DSTZ]
//-- use format_timedate(td,"tz") to get $timezones[tz] (ie "" or "" -> "GMT" etc)
//  if string(tz) then tz = find(tz,$timezones) end if
//  return {tz,$timezones[tz],$tzdescs[tz],$tzadjs[tz]} end if
//  --get_tzdesc(object tz, integer retadj=0) (deprecated/commented out)
//  --  get more internal details (for testing/diagnostics only)
//end function

/*global*/ function override_timezone(/*string*/ tz, /*string*/ desc, /*atom*/ adj, /*object*/ dsr=0, /*string*/ dst="") {
//
// Time zone abbreviations are not necessarily unique, eg BST may refer to 
//  British Summer Time or Bangladesh Standard Time. Other collisions include 
//  EST (Eastern/Egypt), IST (Irish/India/Iran/Israel), and MST (Mountain/Myanmar).
// This routine allows you to replace any such clashes, or add new entries. The 
//  table cannot meaningfully hold two versions of a timezone code, so instead the 
//  application must swap any clashes in and out as required. Less importantly but 
//  still perhaps beneficial is the ability to extend the tables without modifying 
//  the (this) original source code.
// Unfortunately there is no international standard that includes GMT/BST/etc, and 
//  *ALL* of eg "America/Indiana/Indianapolis" is not something end-users are very
//  likely to want or agree to type in, or for that matter select from a drop-down 
//  of well over 400 (!!) such beasts.
//
// Example:
//  -- (this will revert things to their original settings)
//  override_timezone("BST","British Summer Time",+1,{3,25,10,25,1},"GMT")
//
    let /*integer*/ k = find(tz,$timezones), l, dsrdx;
    if (equal(length(tz),0)) { crash("9/0"); }
    if (equal(length(desc),0)) { crash("9/0"); }
    if (sequence(dsr)) {
        l = length(dsr);
        if (l<5 || l>6) { crash("9/0"); }
        if ((!equal($subse(dsr,5),1)) && (l!==6)) { crash("9/0"); }
        dsrdx = find(dsr,$DSTrule);
        if (dsrdx===0) {
            dsr = $addDSTrule(dsr);
        }
    } else {
        if (compare(dsr,0)<0 || compare(dsr,length($DSTrule))>0) { crash("9/0"); }
        dsrdx = dsr;
    }
    if (k!==0) {
        $tzdescs = $repe($tzdescs,k,desc);
        $tzadjs = $repe($tzadjs,k,adj);
        $tzDSR = $repe($tzDSR,k,dsrdx);
        $tzDSL = $repe($tzDSL,k,dst);
    } else {
        $timezones = append($timezones,tz);
        $tzdescs = append($tzdescs,desc);
        $tzadjs = append($tzadjs,adj);
        $tzDSR = append($tzDSR,dsrdx);
        $tzDSL = append($tzDSL,dst);
        $validtd = $repe($validtd,2,length($timezones),["sequence",$DT_TZ]);
        $validtd = $repe($validtd,2,length($timezones),["sequence",$DT_DSTZ]);
    }
}
function $timedate_to_julian_day(/*timedate*/ td) {
//
// A julian day is the number of days since Jan 1st 4713 BC in the julian calandar,
//  which is Nov 24th 4714 BC in the gregorian calendar, the one we use today.
//  Effectively a julian date is a meaningless number that, typically after some 
//  simple adjustment (eg +10 days), can be converted back to a meaningful date.
//
// Values returned are for noon on the given day. The parameter is always treated 
//  as a gregorian date, hence results prior to Oct 15 1582 may differ from other 
//  methods/languages, that is if they treat such as julian dates rather than as
//  back-dated gregorian calendar dates.
//
//integer {y,m,d} = td
//integer m1 = -(m<=2)
//  return floor((1461*(y+4800+m1))/4)+
//         floor((367*(m-2-12*m1))/12)-
//         floor((3*((y+4900+m1)/100))/4)+
//         d-32075
//end function
//
//-- The following routine (from wikipedia) gives the same results. -- 22/5/19 oh no it does not!
//function jd2(timedate td)
    let /*integer*/ [,y,m,d] = td;
    let /*integer*/ m1 = m<=2;
    y += 4800-m1;
    m += 12*m1-3;
    return (((((d+floor((153*m+2)/5))+365*y)+floor(y/4))-floor(y/100))+floor(y/400))-32045;
}
//
//?$timedate_to_julian_day({2000,1,1,0,0,0,0,0})
//?jd2({2000,1,1,0,0,0,0,0})
//?$timedate_to_julian_day({1500,1,1,0,0,0,0,0})
//?jd2({1500,1,1,0,0,0,0,0})
function $julian_day_to_timedate(/*integer*/ jd, /*integer*/ hour, /*integer*/ mins, /*integer*/ secs, /*integer*/ ms) {
// convert an integer julian day back to {y,m,d} form, and throw in the passed h,m,s
    let /*integer*/ l = jd+68569;
    let /*integer*/ i, j;
    let /*integer*/ d, m, y;
    let /*integer*/ n = floor((4*l)/146097);
    l = l-floor((146097*n+3)/4);
    i = floor((4000*(l+1))/1461001);
    l = (l-floor((1461*i)/4))+31;
    j = floor((80*l)/2447);
    d = l-floor((2447*j)/80);
    l = floor(j/11);
    m = (j+2)-12*l;
    y = (100*(n-49)+i)+l;
    return ["sequence",y,m,d,hour,mins,secs,ms];
}

/*local*/ const $DAY_IN_SECONDS = (24*60)*60; // (=86400)
function $timedate_to_seconds(/*timedate*/ td) {
// returns an atom
//22/3/18:
//  return $timedate_to_julian_day(td)*$DAY_IN_SECONDS+(td[DT_HOUR]*60+td[DT_MINUTE])*60+td[DT_SECOND]+td[DT_MSEC]/1000
//25/4/19:
//  return ($timedate_to_julian_day(td)-2440588)*$DAY_IN_SECONDS+(td[DT_HOUR]*60+td[DT_MINUTE])*60+td[DT_SECOND]+td[DT_MSEC]/1000
    let /*atom*/ s = ($subse(td,DT_HOUR)*60+$subse(td,DT_MINUTE))*60+$subse(td,DT_SECOND);
    if (compare(length(td),DT_MSEC)>=0) { s += $subse(td,DT_MSEC)/1000; }
    return ($timedate_to_julian_day(td)-2440588)*$DAY_IN_SECONDS+s;
}
function $seconds_to_timedate(/*atom*/ seconds) {
    let /*integer*/ days, minutes, hours, milliseconds;
//22/3/18:
//  days = floor(seconds/$DAY_IN_SECONDS)
    days = floor(seconds/$DAY_IN_SECONDS)+2440588;
    seconds = remainder(seconds,$DAY_IN_SECONDS);
    hours = floor(seconds/3600);
    seconds -= hours*3600;
    minutes = floor(seconds/60);
    seconds -= minutes*60;
//15/6/24
//  milliseconds = floor((seconds-floor(seconds))*1000)
    milliseconds = round((seconds-floor(seconds))*1000);
    seconds = floor(seconds);
    return $julian_day_to_timedate(days,hours,minutes,seconds,milliseconds);
}

/*global*/ function adjust_timedate(/*sequence*/ td, /*atom*/ delta) {
    let /*integer*/ [,y,m,d] = td, dsrule, tz, stz;
//15/6/24:
    let /*bool*/ y0m0 = (y===0) && (m===0);
    td = deep_copy(td);
    if (y0m0) {
        td = $repss(td,1,3,["sequence",2024,1,1]); [,y,m,d] = td; }
    assert(y>=1752,"date prior to introduction of Gregorian calendar");
    if (m<1) {
        while (true) {
            m += 12;
            y -= 1;
            if (m>1) {
                break;
            }
        }
        td = $repe(td,DT_YEAR,y);
        td = $repe(td,DT_MONTH,m);
    } else if (m>12) {
        while (true) {
            m -= 12;
            y += 1;
            if (m<=12) {
                break;
            }
        }
        td = $repe(td,DT_YEAR,y);
        td = $repe(td,DT_MONTH,m);
    }
    if (d===0) {
        delta -= $DAY_IN_SECONDS;
        td = $repe(td,DT_DAY,1);
    }
    let /*atom*/ secs = $timedate_to_seconds(td);
    secs += delta;
//1/5/24:
    let /*integer*/ ltd = length(td);
    if (ltd>=7) {
    //p2js
//      td = deep_copy(td)
        td = $repss(td,1,7,$seconds_to_timedate(secs));
    } else {
        td = $seconds_to_timedate(secs);
    }
    delta = 0;
    if (equal(length(td),$DT_DSTZ)) {
        dsrule = $get_DST_rule(td,$DT_DSTZ);
        if (dsrule!==0) {
            tz = $subse(td,$DT_TZ);
            stz = $subse(td,$DT_DSTZ);
            if ($isDSTr(td,dsrule)) {
                if (tz!==stz) {
                    // modify ..,GMT,BST} to ..,BST,BST}
                    delta = -$subse($tzadjs,tz)*3600;
                    td = $repe(td,$DT_TZ,stz);
                    delta += $subse($tzadjs,stz)*3600;
                }
            } else {
                if (tz===stz) {
                    // modify ..,BST,BST} to ..,GMT,BST}
                    stz = find($subse($tzDSL,tz),$timezones);
                    delta = $subse($tzadjs,stz)*3600;
                    td = $repe(td,$DT_TZ,stz);
                    delta -= $subse($tzadjs,tz)*3600;
                }
            }
        }
    } else if (equal(length(td),$DT_TZ)) {
        dsrule = $get_DST_rule(td,$DT_TZ);
        if (dsrule!==0) {
            if (!$isDSTr(td,dsrule)) {
                // modify ..,BST} to ..,GMT,BST}
                tz = $subse(td,$DT_TZ);
                stz = find($subse($tzDSL,tz),$timezones);
                td = append(td,tz);
                delta = $subse($tzadjs,stz)*3600;
                td = $repe(td,$DT_TZ,stz);
                delta -= $subse($tzadjs,tz)*3600;
            }
        }
    }
    if (delta!==0) {
        td = $repss(td,1,7,$seconds_to_timedate($timedate_to_seconds(td)+delta));
    }
    if (y0m0) {
        td = $repss(td,1,3,["sequence",0,0,0]);
    } else {
//4/3/18 don't clobber DT_MSECS!
//  if length(td)>=DT_DOW then
//      td[DT_DOW] = day_of_week(td)
//      {y,m,d} = td
//      td[DT_DOW] = day_of_week(y,m,d)
        if (compare(length(td),DT_DOY)>=0) {
            [,y,m,d] = td;
//          td[DT_DOY] = day_of_year(td)
            td = $repe(td,DT_DOY,day_of_year(y,m,d));
        }
    }
//1/5/24:
    if (ltd<9 && compare(ltd,length(td))<0) { td = $subss(td,1,ltd); }
    return td;
}

/*global*/ function set_timezone(/*timedate*/ td, /*string*/ newtz) {
//
// Set a specific timezone on an un-timezoned timedate.
// For example if you have processed/are processing a file with no $timezones 
//  but you know, or just want to pretend, they are all in GMT. Or maybe you 
//  can augment a specific user's input because you know where they live, or 
//  their account has a default.
//
// This routine allows you to treat "3am" (plus a date) as "3am EDT";
//  - see change_timezone() for "what is 3am GMT in EDT?".
//
// Specifying an unknown timezone causes a fatal error.
// If a timedate already has a timezone it is returned unmodified.
//
// Note that setting a DST out-of-season returns a ..,base,dst} timedate,
//  eg set_timezone(parse_date_string("25/12/2015"),"BST") returns a
//      timedate of {2015,12,25,0,0,0,dow,doy,GMT,BST}, whereas
//     set_timezone(parse_date_string("25/07/2015"),"BST") returns a
//      timedate of {2015, 7,25,0,0,0,dow,doy,BST,BST}.
//
    let /*integer*/ tz = find(newtz,$timezones), 
                    dsrule = $subse($tzDSR,tz);
//  if tz=0 then ?9/0 end if    -- (above line will crash anyway!)
//p2js:
    td = deep_copy(td);
    if (compare(length(td),$DT_TZ)>=0) {
        if (!equal($subse(td,$DT_TZ),0)) { return td; }
    } else {
        td = append(td,0);
        if (!equal(length(td),$DT_TZ)) { crash("9/0"); }
    }
    if (dsrule!==0) {
        if (compare(length(td),$DT_DSTZ)<0) {
            td = append(td,tz);
            if (!equal(length(td),$DT_DSTZ)) { crash("9/0"); }
        } else {
            td = $repe(td,$DT_DSTZ,tz);
        }
        if (!$isDSTr(td,dsrule)) {
            tz = find($subse($tzDSL,tz),$timezones);
        }
    }
    td = $repe(td,$DT_TZ,tz);
    return td;
}

/*global*/ function change_timezone(/*timedate*/ td, /*string*/ newtz) {
//
// If there is no existing timezone, GMT is assumed.
// Use set_timezone before calling this to change that default behaviour.
//
// technical details
// =================
//
//  valid $timezones are:
//
//      ..}         \
//      ..,0}        }=no timezone (assume UTC/GMT)
//      ..,0,?}     /
//      ..,tz},         \=single timezone, $tzadjs[tz] applied
//      ..,tz,0}        /
//      ..,dstz,dstz}   - daylight savings in-season
//      ..,tz,dstz}     - daylight savings out-of-season
//
    let /*integer*/ tz, prevtz;
    let /*atom*/ hourdelta = 0;
    tz = find(newtz,$timezones);
//  if tz=0 then ?9/0 end if    -- (next line will crash anyway!)
    hourdelta = $subse($tzadjs,tz);
//p2js:
    td = deep_copy(td);
    if (compare(length(td),$DT_TZ)>=0) {
        prevtz = $subse(td,$DT_TZ);
        if (prevtz!==0) {
            hourdelta -= $subse($tzadjs,prevtz);
            td = $repe(td,$DT_TZ,tz);
            if (compare(length(td),$DT_DSTZ)>=0) {
// removed 20/2/18:
//              if not find(td[$DT_DSTZ],{0,prevtz}) then
//                  if $tzadjs[prevtz]!=0 then ?9/0 end if   -- sanity check
//              end if
                td = $repe(td,$DT_DSTZ,tz);
            }
        }
    } else {
        td = append(td,tz);
        if (!equal(length(td),$DT_TZ)) { crash("9/0"); }
    }
    if (hourdelta!==0) {
        td = adjust_timedate(td,hourdelta*3600);
    }
    return td;
}
const $edescs = ["sequence","literal character mismatch",
                           "unrecognised",
                           "number expected",
                           "year is zero",
                           "invalid month",
                           "invalid day",
                           "unrecognised/illegal literal",
                           "invalid timedate",
                           "format code expected",
                           "attempt to parse null string",
                           "invalid hour",
                           "invalid hour for am/pm",
                           "invalid minutes",
                           "invalid seconds",
                           "no prior hour for am/pm",
                           "no prior day for th",
                           "no closing quote",
                           "unparsed input",
                           "incomplete input",
                           "month next to hour/second",
                           "minute next to year/day",
                           "invalid milliseconds"];
let /*object*/ $ecxtra = 0;
function $nxtch(/*string*/ s, /*integer*/ idx, /*integer*/ ch, /*integer*/ uppercase, /*integer*/ len) {
//
// internal, non-damaging test function
// returns true if there are len [case insensitive] instances of ch at s[idx+1..]
//
    if (uppercase) {
        ch = upper(ch);
    }
    for (let i=1, i$lim=len; i<=i$lim; i+=1) {
        if (compare(i+idx,length(s))>0) { return false; }
        if (uppercase) {
            if (!equal(upper($subse(s,i+idx)),ch)) { return false; }
        } else {
            if (!equal($subse(s,i+idx),ch)) { return false; }
        }
    }
    return true;
}
//Aside:
// I've put quite a few break statements in the switch constructs, but because the latter are not
//  declared "with fallthrough", they achieve nothing and represent the default behaviour anyway.
//  In contrast the explicit fallthough statements in this code are entirely necessary.
function $next_fmt(/*string*/ fmt, /*integer*/ fmtdx) {
    let /*integer*/ ch;
    let /*integer*/ fcase = 0; // lower, 1=upper
    let /*integer*/ fsize = 1;
    let /*integer*/ ftyp = 0;
    let /*integer*/ ecode = 0;
    let /*integer*/ closequote;
    fmtdx += 1;
    ch = $subse(fmt,fmtdx);
    //
    // parse a "token" character-by-character.
    // note that eg "mmam" is {mm,am}, iyswim.
    //
    switch (ch) {
        case 0X41: case 0X50:
            fcase = 1;
            /*fallthrough*/
        case 0X61: case 0X70:
            if ($nxtch(fmt,fmtdx,0X6D,fcase,1)) {
                fmtdx += 1;
                ftyp = $AM;
                fsize = 2;
                    //(else error, as ftyp=0 below)
            }
            break;
        case 0X44: fcase = 1;
            /*fallthrough*/
        case 0X64:
            ftyp = $DAY;
            for (let i=2; i<=4; i+=1) {
                if (!$nxtch(fmt,fmtdx,ch,fcase,1)) { break; }
                fmtdx += 1;
                fsize = i;
            }
            if (fsize>=3) {
                ftyp = $DOW;
                if ((fcase===1) && (equal($subse(fmt,fmtdx),0X64))) {
                    fcase = 2;
                }
            } else if ((fsize===1) && (fcase===0)) {
                if ($nxtch(fmt,fmtdx,0X6F,0,1) && $nxtch(fmt,fmtdx+1,0X79,0,1)) {
                    ftyp = $DOY;
                    fmtdx += 2;
                }
            }
            break;
        case 0X68: case 0X48:
            ftyp = $HOUR;
            if ($nxtch(fmt,fmtdx,ch,fcase,1)) {
                fmtdx += 1;
                fsize = 2;
            }
            break;
        case 0X4D: fcase = 1;
            /*fallthrough*/
        case 0X6D:
            for (let i=2; i<=4; i+=1) {
                if (!$nxtch(fmt,fmtdx,ch,fcase,1)) { break; }
                fmtdx += 1;
                fsize = i;
            }
            if ((!fcase && (fsize===1)) && $nxtch(fmt,fmtdx,0X73,fcase,1)) {
                ftyp = $MSEC;
                fmtdx += 1;
                fsize = 2;
            } else if (!fcase && fsize<=2) {
                ftyp = $MINUTE;
            } else {
                ftyp = $MONTH;
                if ((fcase===1) && (equal($subse(fmt,fmtdx),0X6D))) {
                    fcase = 2;
                }
            }
            break;
        case 0X73: case 0X53:
            ftyp = $SECOND;
            if ($nxtch(fmt,fmtdx,ch,0,1)) {
                fmtdx += 1;
            } else if ($nxtch(fmt,fmtdx,0X54,1,1)) {
                fmtdx += 1;
                fcase = ch===0X53;
                ftyp = $TH;
            }
            fsize = 2;
            break;
        case 0X79: case 0X59:
            ftyp = $YEAR;
            if ($nxtch(fmt,fmtdx,ch,0,1)) {
                fmtdx += 1;
                fsize = 2;
                if ($nxtch(fmt,fmtdx,ch,0,1)) {
                    if ($nxtch(fmt,fmtdx+1,ch,0,1)) {
                        fmtdx += 2;
                        fsize = 4;
                    } else {
                        $ecxtra = "yy or yyyy expected";
                        ecode = 7;
                    }
                }
//                  else
//                      $ecxtra = "yy or yyyy expected"
            }
            break;
        case 0X74: case 0X54:
            if ($nxtch(fmt,fmtdx,0X5A,1,1)) {
                fmtdx += 1;
                ftyp = $TZ;
                fsize = 4;
                if ($nxtch(fmt,fmtdx,0X5A,1,1)) {
                    fmtdx += 1;
                    fcase = 1;
                }
            } else if ($nxtch(fmt,fmtdx,0X48,1,1)) {
                fmtdx += 1;
                fcase = ch===0X54;
                ftyp = $TH;
                fsize = 2;
            } else {
//DEV (spotted in passing) ain't this going to get clobbered, always?
                $ecxtra = "tz or th expected";
            }
            break;
        case 0X27:
            ftyp = $TD_LITERAL;
            closequote = 0;
            for (let i=fmtdx+1, i$lim=length(fmt); i<=i$lim; i+=1) {
                if (equal($subse(fmt,i),0X27)) {
                    closequote = i;
                    break;
                }
            }
            if (closequote===0) {
                ecode = 17;
            }
            fsize = closequote-fmtdx;
            fmtdx += 1;
            break;
        default: 
            if (((ch>=0X61 && ch<=0X7A) || (ch>=0X41 && ch<=0X5A)) || (ch>=0X30 && ch<=0X39)) {
//DEV ditto
                $ecxtra = $conCat("ch is ", ch);
            } else {
                ftyp = $TD_LITERAL;
            }
    }
    if (ftyp===0) {
        ecode = 7;
        $ecxtra = $conCat("ch is ", ch);
    }
    return ["sequence",ecode,fmtdx,ftyp,fcase,fsize,ch];
}
function $to_space(/*string*/ s) {
// error messsage helper. shrink s to first space
    for (let i=2, i$lim=length(s); i<=i$lim; i+=1) {
//      if find(s[i]," \t\r\n") then
        if (find($subse(s,i),$conCat(" \r\n", 9))) {
            s = $subss(s,1,i-1);
            break;
        }
    }
    return s;
}
function $td_get_number(/*string*/ s, /*integer*/ idx, /*integer*/ nsize) {
// an nsize of 1..3 means 1 or 2 or 3, above that must be exact
    let /*integer*/ ch, n, asize = 1, sidx = idx+1;
    ch = $subse(s,sidx);
    if (ch<0X30 || ch>0X39) {
        $ecxtra = sprintf(`number expected "%s" at position %d, not "%s"`,["sequence",s,sidx,$to_space($subss(s,sidx,-1))]);
        return ["sequence",3,idx,0]; // "number expected"
    }
    n = ch-0X30;
    while (1) {
        if (compare(sidx,length(s))>=0) { break; }
        ch = $subse(s,sidx+1);
        if (ch<0X30) { break; }
        if (ch>0X39) { break; }
        n = n*10+(ch-0X30);
        sidx += 1;
        asize += 1;
    }
//  if nsize>1
//  and nsize!=asize then
    // (comment above updated)
    if ((asize!==nsize) && (asize>nsize || nsize>3)) {
        $ecxtra = sprintf(`wrong size (%d not %d) number in "%s" at position %d, ("%s")`,["sequence",asize,nsize,s,idx+1,$to_space($subss(s,idx+1,-1))]);
        return ["sequence",3,idx,0]; // "number expected"
    }
    return ["sequence",0,sidx,n];
}
function $get_any(/*string*/ s, /*integer*/ idx, /*sequence*/ stringset, /*integer*/ ssize, /*integer*/ scase, /*string*/ desc) {
// ssize can be 2 for $ampm, 3 for an abbreviation, and 4 means full length
    for (let i=1, i$lim=length(stringset); i<=i$lim; i+=1) {
        let /*string*/ si = $subse(stringset,i);
        if (ssize===3) {
            si = $subss(si,1,3);
        }
        let /*integer*/ sidx = idx+1, 
                        ecode = 0;
        for (let k=1, k$lim=length(si); k<=k$lim; k+=1) {
            if (compare(sidx,length(s))>0) { break; }
            let /*integer*/ sch = $subse(s,sidx);
            sidx += 1;
            if (scase!==2) {
                if (!equal(upper(sch),upper($subse(si,k)))) { ecode = -1; break; }
            } else {
                if (!equal(sch,$subse(si,k))) { ecode = -1; break; }
            }
        }
        if (ecode===0) {
            return ["sequence",ecode,idx+length(si),i];
        }
    }
    $ecxtra = sprintf(`%s expected in "%s" at position %d, not "%s"`,["sequence",desc,s,idx+1,$to_space($subss(s,idx+1,-1))]);
    return ["sequence",2,idx,0]; // "unrecognised"
}
function $parse_one(/*string*/ s, /*string*/ fmt, /*integer*/ partial) {
// see parse_date_string()
    let /*integer*/ sdx = 0,  // chars processed in s
                    fmtdx = 0,  // chars processed in fmt
                    ftyp,  // $TD_LITERAL..$AM
                    pftyp = 0,  // previous value of ftyp
                    fcase,  // 0=lower, 1=upper
                    fsize,  // 1 (1 or 2)
                    // 2 (2)
                    // 3 (abbreviation)
                    // 4 (full length)
                    ch, 
                    ecode = 0,  // error code
                    year = 0, 
                    month = 0, 
                    day = 0, 
                    hour = 0, 
                    minute = 0, 
                    second = 0, 
                    msecs = 0,  // (returned in dayofweek)
                    pm = 0,  // 1=am, 2=pm
                    dayofweek = 0, 
                    dayofyear = 0, 
                    tz = 0;
    $ecxtra = 0;
    if (equal(length(fmt),0)) {
        ecode = 9;
        $ecxtra = "";
        return ["sequence",ecode,$subse($edescs,ecode),$ecxtra];
    }
//  if length($default_format)=0 then
//      $default_format = fmt
//  end if
    if (equal(length(s),0)) {
        ecode = 10;
        $ecxtra = "";
        return ["sequence",ecode,$subse($edescs,ecode),$ecxtra];
    }
    while (((ecode===0) && compare(sdx,length(s))<0) && compare(fmtdx,length(fmt))<0) {
        [,ecode,fmtdx,ftyp,fcase,fsize,ch] = $next_fmt(fmt,fmtdx);
        if (ecode!==0) { break; }
        switch (ftyp) {
            case $TD_LITERAL:
                if (fsize===1) {
                    if (equal($nxtch(s,sdx,ch,0,1),0)) {
                        ecode = 1;
                        $ecxtra = sprintf("'%c' expected in %s at position %d",["sequence",ch,s,sdx+1]);
                        if (compare(sdx,length(s))<0) {
                            $ecxtra = $conCat($ecxtra, sprintf(", not '%c'",["sequence",$subse(s,sdx+1)]), false);
                        }
                    } else {
                        sdx += 1;
                    }
                } else {
                    for (let i=fmtdx, i$lim=(fmtdx+fsize)-2; i<=i$lim; i+=1) {
                        ch = $subse(fmt,i);
                        if (equal($nxtch(s,sdx,ch,0,1),0)) {
                            ecode = 1;
                            $ecxtra = sprintf("'%c' expected in %s at position %d",["sequence",ch,s,sdx+1]);
                            if (compare(sdx,length(s))<0) {
                                $ecxtra = $conCat($ecxtra, sprintf(", not '%c'",["sequence",$subse(s,sdx+1)]), false);
                            }
                            break;
                        }
                        sdx += 1;
                    }
                    if (ecode===0) {
                        fmtdx += fsize-1;
                    }
                }
                break;
            case $YEAR:
//NO!
//              if pftyp=$MINUTE then
//                  ecode = 21
//                  exit
//              end if
                switch (fsize) {
                    case 1: case 2:
//                      {ecode,sdx,year} = $td_get_number(s,sdx,fsize)
                        [,ecode,sdx,year] = $td_get_number(s,sdx,2);
//                      if fsize=2 then
//                      if fsize=2 
//                      or (fsize=4 and year>=0 and year<=99) then
                            //                          
                            // This split is quite arbitrary; assumes that
                            // date of births for people up to 80 is a bit
                            // more likely than futures >20 years away. By
                            // now most things use 4-digit dates anyway.
                            //
 /*
                            if year<35 then
                                year += 2000    -- 00..44 ==> 2000..2034
                            else
                                year += 1900    -- 35..99 ==> 1935..1999
                            end if
*/ 
                        let /*integer*/ current_year = $subse(date(),DT_YEAR), 
                                        century = floor(current_year/100)*100;
                        year += century-100;
                        if (year<current_year-80) {
                            year += 100;
                        }
//                      end if
//                      year -= 1900            -- to match date()
                        break;
                    case 4:
                        [,ecode,sdx,year] = $td_get_number(s,sdx,fsize);
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                break;
            case $MONTH:
                if (pftyp===$HOUR) {
                    ecode = 20;
                    break;
                }
                switch (fsize) {
                    case 1: case 2:
//                      {ecode,sdx,month} = $td_get_number(s,sdx,fsize)
                        [,ecode,sdx,month] = $td_get_number(s,sdx,2);
                        break;
                    case 3: case 4:
                        [,ecode,sdx,month] = $get_any(s,sdx,$subse($months,$currlang),fsize,fcase,"month");
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                if ((ecode===0) && (month<1 || month>12)) {
                    ecode = 5;
                }
                break;
            case $DAY:
                switch (fsize) {
                    case 1: case 2:
//                      {ecode,sdx,day} = $td_get_number(s,sdx,fsize)
                        [,ecode,sdx,day] = $td_get_number(s,sdx,2);
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                if ((ecode===0) && (day<1 || day>31)) { // (more tests below)
                    ecode = 6;
                }
                break;
            case $DOW:
                switch (fsize) {
                    case 3: case 4:
                        [,ecode,sdx,dayofweek] = $get_any(s,sdx,$subse($day_names,$currlang),fsize,fcase,"day");
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                break;
            case $DOY:
                [,ecode,sdx,dayofyear] = $td_get_number(s,sdx,3);
                break;
            case $HOUR:
//              {ecode,sdx,hour} = $td_get_number(s,sdx,fsize)
                [,ecode,sdx,hour] = $td_get_number(s,sdx,2);
                if ((ecode===0) && (hour<0 || hour>23)) {
                    ecode = 11;
                }
                break;
            case $MINUTE:
                if ((pftyp===$DAY) || (pftyp===$YEAR)) {
                    ecode = 21;
                    $ecxtra = "";
                    return ["sequence",ecode,$subse($edescs,ecode),$ecxtra];
                }
//              {ecode,sdx,minute} = $td_get_number(s,sdx,fsize)
                [,ecode,sdx,minute] = $td_get_number(s,sdx,2);
                if ((ecode===0) && (minute<0 || minute>59)) {
                    ecode = 13;
                }
                break;
            case $SECOND:
                if (pftyp===$MONTH) {
                    ecode = 20;
                    break;
                }
//              {ecode,sdx,second} = $td_get_number(s,sdx,fsize)
                [,ecode,sdx,second] = $td_get_number(s,sdx,2);
                if ((ecode===0) && (second<0 || second>59)) {
                    ecode = 14;
                }
                break;
            case $MSEC:
                [,ecode,sdx,msecs] = $td_get_number(s,sdx,3);
                if (ecode===0) {
                    if (msecs<0 || msecs>999) {
                        ecode = 22;
                    } else {
                        dayofweek = msecs;
                    }
                }
                break;
            case $AM:
                if (pftyp===$MONTH) {
                    ecode = 20;
                    break;
                }
                [,ecode,sdx,pm] = $get_any(s,sdx,$subse($ampm,$currlang),2,1,"am/pm");
                // note: "12:00:00pm" is noon, and "12:00:00am" is midnight
                //       on a 12 hour clock, 12:00am..12:59am and 12:00pm..12:59pm
                //       equate respectively to 0:00..00:59 and 12:00..12:59 on
                //       a 24 hour clock, and as stored. further, 0/13:00am/pm 
                //       have no meaning and should raise an error.
                if (ecode!==0) { break; }
                if (hour<=0 || hour>12) {
                    ecode = 12;
                    $ecxtra = sprintf("(hour is %d)",["sequence",hour]);
                    break;
                }
                if (pm===1) {   // am
                    if (hour===12) {
                        hour = 0;
                    }
                } else {
                     // pm=2    -- pm
                    if (hour!==12) {
                        hour += 12;
                    }
                }
                if (hour<0 || hour>23) {
                    crash("9/0"); // should never happen
                }
                break;
            case $TZ:
                if (fcase) {
                    [,ecode,sdx,tz] = $get_any(s,sdx,$tzdescs,4,1,"timezone");
                } else {
                    [,ecode,sdx,tz] = $get_any(s,sdx,$timezones,4,1,"timezone");
                }
                break;
            case $TH:
                if (pftyp!==$DAY) {
                    ecode = 16;
                    $ecxtra = "";
                    break;
                }
//              {ecode,sdx,{}} = $get_any(s,sdx,$td_ordinals[$currlang],2,1,"ordinal suffix")
//p2js:
//              {ecode,sdx,{}} = $get_any(s,sdx,$td_ordinals[$currlang],4,1,"ordinal suffix")
                [,ecode,sdx] = $get_any(s,sdx,$subse($td_ordinals,$currlang),4,1,"ordinal suffix");
                break;
            default: 
                crash("9/0"); // should never happen...
        }
        if (ecode!==0) { break; }
        if (ftyp!==$TD_LITERAL) {
            pftyp = ftyp;
        }
    }
    if (((ecode===0) && !partial) && (!equal(sdx,length(s)))) {
        for (let i=sdx+1, i$lim=length(s); i<=i$lim; i+=1) {
//          if not find(s[i]," \t\r\n") then
            if (!find($subse(s,i),$conCat(" \r\n", 9))) {
                $ecxtra = $conCat("remaining text is:", $subss(s,i,-1));
                ecode = 18;
                break;
            }
        }
    }
    if ((ecode===0) && (!equal(fmtdx,length(fmt)))) {
        $ecxtra = $conCat("remaining format is:", $subss(fmt,fmtdx+1,-1));
        ecode = 19;
    }
//added 20/11/19:
    if (((((ecode===0) && (year!==0)) && (month!==0)) && (day!==0)) && compare(day,days_in_month(year,month))>0) {
        ecode = 6;
    }
    if (ecode!==0) { return ["sequence",ecode,$subse($edescs,ecode),$ecxtra]; }
//  if fmtdx!=length(fmt) then ?9/0 end if  --should never happen

    //set dayofweek, dayofyear -- no!
    //  this routine has to handle eg parse("3am","ham") and you
    //  ain't going to get a day of week/year out of that!

    // return matches the result from date(), plus a timezone(/0)
    return ["sequence",year,month,day,hour,minute,second,dayofweek,dayofyear,tz];
}
//(local)
let /*sequence*/ $default_parse_fmts;
//sequence $default_parse_fmts = {}
let /*integer*/ $allow_partial = 0;
//string $default_format = ""
let /*string*/ $default_format = "h:mpm Dddd Mmmm ddth, yyyy";

/*global*/ function set_timedate_formats(/*sequence*/ parse_fmts, /*object*/ out_fmt=1, /*integer*/ partial=0) {
//
// Sets the default formats for parsing strings to timedates, and formatting 
//  timedates into strings.
//
// parse_fmts must be a sequence of format strings for parse_date_strings(), which
//  tries each in order.
//
// out_fmt is a single string or index to parse_fmts for format_dateime().
//
// the partial flag controls whether to ignore excess text when parsing, and if 
//  set then parse_fmts should be ordered with the most detailed first. (If not 
//  ignoring excess text, then the order of entries probably does not matter.)
//
// Examples: set_timedate_formats({"Mmmm d yyyy h:mmam tz"})
//           set_timedate_formats({"DD/MM/YYYY h:mmam tz",
//                                 "DD/MM/YYYY h:mmam",
//                                 "DD/MM/YYYY"},1,1)                       
//
//  In the second case, with partial matching enabled, we would not want to try
//  the DD/MM/YYYY first, and risk ignoring a following time and timezone.
//
    $default_parse_fmts = parse_fmts;
    if (string(out_fmt)) {
        $default_format = out_fmt;
    } else if (!equal(out_fmt,0)) {
        $default_format = $subse(parse_fmts,out_fmt);
    }
    $allow_partial = partial;
}

/*global*/ function parse_date_string(/*string*/ s, /*sequence*/ fmts=$default_parse_fmts, /*integer*/ partial=$allow_partial) {
//
// parse a date/time string, eg
//
//  parse_date_string("March 7 2009 7:30pm EST",{"Mmmm d yyyy h:mmpm tz"})
//
// returns {2009,3,7,19,30,0,0,0,21}, like date() plus one or two elements.
//
// The extra elements are $timezones, which are not meant to be examined 
//  directly, though you can use format_timedate(td,"tz") to decipher them.
//  $DT_TZ and $DT_DSTZ are deliberately /not/ global to deter direct access.
//
// If an error occurs, instead the result has a length of 3, which consists 
//  of a numeric error code, a description of that code, and 0 or extended 
//  description of the actual problem encountered.
//  Said messages are intended for a developer/typecheck, not an end user.
//
// Store the result in a timedate for fast-fail development.
//
// See set_timedate_formats() for detals of the fmts and partial parameters.
//
// Note that parsing say "Monday 1/01/2000" returns a DT_DOW element
//  set to 2, even though it was a Saturday, and any non-explicitly
//  mentioned elements get left as zero. It is in fact perfectly
//  legal to invoke parse_date_string("?","?"), which checks the input
//  for that exact literal and returns {0,0,0,0,0,0,0,0,0}, however it
//  is illegal to specify an empty string ("") as the format.
//
// The dayofyear field (res[DT_DOY]) is usually left zero, but can easily
//  be obtained using day_of_year(y,m,d).
//
// The partial parameter controls whether to ignore excess text; if set the most detailed 
//  format should be first. For example if the input is "03/09/15 6pm Customer was not happy", 
//  you want try "DD/MM/YY ham tz"(full) and fail before "DD/MM/YY ham"(part) and pass.
//
// A minor point is that p2js will not support omitting fmts and using a named parameter to 
// provide partial. (maybe using `$default_parse_fmts` in p2js_depends.e would work...)
//
    let /*sequence*/ res = ["sequence"];
    for (let i=1, i$lim=length(fmts); i<=i$lim; i+=1) {
        let /*string*/ fmti = $subse(fmts,i); // (delib typecheck)
        res = $parse_one(s,fmti,partial);
        if (!equal(length(res),3)) { return res; }
    }
    return res; // fail the lot
}

/*global*/ function format_timedate(/*timedate*/ td, /*string*/ fmt=$default_format) {
//
// td is normally a result originally from parse_date_string(), posibly adjusted.
//   You can also legally pass the result of date() to this routine, as long
//   as fmt does not contain a timezone.
//
// fmt is eg "Dddd, Mmmm ddth, YYYY" for eg "Monday, September 3rd, 2015".
//
// It is perfectly valid to invoke this routine to obtain various fragments
//  that you plan to check/stitch together later, with one small exception: 
//  * am (and pm/$AM/PM) cannot be specified without a preceding hour.
//  
// For example, performance considerations aside,
//
//      if format_timedate(td,"Dddd")="Monday" then
//
// may be much clearer than then the equivalent
//
//      if td[DT_DOW]=1 then
//
// Any required literals other than punctuation and whitespace should be
//  enclosed in single quotes (for a literal singlequote, pair two), eg:
//
//      format_timedate(td,"'Today''''s date is' Dddd, Mmmm ddth, YYYY")
//
// You can also explicitly set s[DT_DOW] to zero if, after some kind of
//  other manipulation on s, you want it to be recalculated. Or just use
//  day_of_week(y,m,d) like this does.
//
    let /*string*/ res = "";
    let /*integer*/ fmtdx = 0, 
                    ftyp,  // $TD_LITERAL..$AM
                    fcase,  // 0=lower/12-hour, 1=upper/24-hour, 2=capitalise
                    fsize,  // 1 (1 or 2)
                    // 2 (2)
                    // 3 (abbreviation)
                    // 4 (full length)
                    ch, 
                    ecode = 0, 
                    hidx = 0, 
                    hlen, 
                    hsize, 
                    hour, 
                    ispm, 
                    year, 
                    month, 
                    day, 
                    l, 
                    dayofweek, 
                    dayofyear, 
                    minute, 
                    second, 
                    msecs, 
                    tz, 
                    pftyp = -1;
    let /*object*/ x;
    $ecxtra = 0;
    if (equal(length(fmt),0)) {
        ecode = 9;
        $ecxtra = "";
        return ["sequence",ecode,$subse($edescs,ecode),$ecxtra];
    }
    if (equal(length($default_format),0)) {
        $default_format = fmt;
    }
// now covered by timedate:
//  if length(td)<DT_DOY then
//      $ecxtra = sprintf("format_timedate(s): length(s) is %d",length(td))
//      ecode = 8
//  end if
    while ((ecode===0) && compare(fmtdx,length(fmt))<0) {
        [,ecode,fmtdx,ftyp,fcase,fsize,ch] = $next_fmt(fmt,fmtdx);
        if (ecode!==0) { break; }
        switch (ftyp) {
            case $TD_LITERAL:
                if (fsize===1) {
                    x = ch;
                } else {
                    x = $subss(fmt,fmtdx,(fmtdx+fsize)-2);
                    fmtdx += fsize-1;
                }
                break;
            case $YEAR:
//NO!
//              if pftyp=$MINUTE then
//                  ecode = 21
//                  exit
//              end if
                year = $subse(td,DT_YEAR);
                switch (fsize) {
                    case 1: case 2:
                        x = sprintf("%02d",remainder(year,100));
                        break;
                    case 4:
                        x = sprintf("%04d",year);
                        break;
                    default: 
                        crash("9/0"); // shoule never happen
                }
                break;
            case $MONTH:
                if (pftyp===$HOUR) {
                    ecode = 20;
                    break;
                }
                month = $subse(td,DT_MONTH);
                if (month<1) {
                    $ecxtra = sprintf("month is %d",month);
                    ecode = 5;
                    break;
                }
                switch (fsize) {
                    case 1:
                        x = sprintf("%d",month);
                        break;
                    case 2:
                        x = sprintf("%02d",month);
                        break;
                    case 3: case 4:
                        x = $subse($subse($months,$currlang),month);
                        if (fsize===3) {
                            x = $subss(x,1,3);
                        }
                        if (fcase===0) {
                            x = lower(x);
                        } else if (fcase===1) {
                            x = upper(x);
//                      elsif fcase=2 then
//                          x should already be capitalised
                        }
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                break;
            case $DAY:
                day = $subse(td,DT_DAY);
//20/11/19:
//              if day<1 then
                year = $subse(td,DT_YEAR);
                month = $subse(td,DT_MONTH);
//7/5/20:
                if (year>=1752) {
                    if (day<1 || compare(day,days_in_month(year,month))>0) {
                        $ecxtra = sprintf("day is %d",day);
                        ecode = 6;
                        break;
                    }
                }
                switch (fsize) {
                    case 1:
                        x = sprintf("%d",day);
                        break;
                    case 2:
                        x = sprintf("%02d",day);
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                break;
            case $DOW:
//5/3/18 td[DT_DOW] may contain miliseconds...
//              dayofweek = td[DT_DOW]
//              if dayofweek=0 then
                year = $subse(td,DT_YEAR);
                month = $subse(td,DT_MONTH);
                if (month===0) { ecode = 5; break; }
                day = $subse(td,DT_DAY);
                if (day===0) { ecode = 6; break; }
                dayofweek = day_of_week(year,month,day);
//              end if
                switch (fsize) {
                    case 3: case 4:
                        x = $subse($subse($day_names,$currlang),dayofweek);
                        if (fsize===3) {
                            x = $subss(x,1,3);
                        }
                        if (fcase===0) {
                            x = lower(x);
                        } else if (fcase===1) {
                            x = upper(x);
//                      elsif fcase=2 then
//                          x should already be capitalised
                        }
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                break;
            case $DOY:
                dayofyear = $subse(td,DT_DOY);
                if (dayofyear===0) {
                    year = $subse(td,DT_YEAR);
                    month = $subse(td,DT_MONTH);
                    if (month===0) { ecode = 5; break; }
                    day = $subse(td,DT_DAY);
                    if (day===0) { ecode = 6; break; }
                    dayofyear = day_of_year(year,month,day);
                }
                x = sprintf("%d",dayofyear);
                break;
            case $HOUR:
                hour = $subse(td,DT_HOUR);
                switch (fsize) {
                    case 1:
                        x = sprintf("%d",hour);
                        break;
                    case 2:
                        x = sprintf("%02d",hour);
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                // replaced if am/pm found later...
                hidx = length(res)+1;
                hlen = length(x);
                hsize = fsize;
                break;
            case $MINUTE:
                if ((pftyp===$DAY) || (pftyp===$YEAR)) {
                    ecode = 21;
                    break;
                }
                minute = $subse(td,DT_MINUTE);
                switch (fsize) {
                    case 1: case 2:
                        x = sprintf("%02d",minute);
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                break;
            case $SECOND:
                if (pftyp===$MONTH) {
                    ecode = 20;
                    break;
                }
                second = $subse(td,DT_SECOND);
                switch (fsize) {
                    case 1: case 2:
                        x = sprintf("%02d",second);
                        break;
                    default: 
                        crash("9/0"); // should never happen
                }
                break;
            case $MSEC:
                msecs = $subse(td,DT_MSEC);
                x = sprintf("%03d",msecs);
                break;
            case $AM:
                if (pftyp===$MONTH) {
                    ecode = 20;
                    break;
                }
                // note: "12:00:00pm" is noon, and "12:00:00am" is midnight
                //       (ideally use "noon" and "midnight", when practical)
                //       on a 24 hour clock, 0:00..00:59 and 12:00..12:59 equate 
                //       respectively to 12:00am..12:59am and 12:00pm..12:59pm
                //       on a 12 hour clock.
                if (hidx===0) {
                    ecode = 15;
                    break;
                }
                hour = $subse(td,DT_HOUR);
                ispm = hour>=12;
                if (ispm) {
                    if (hour>12) {
                        hour -= 12;
                    } else {
                        hidx = 0;
                    }
                } else if (hour===0) {
                    hour = 12;
                } else {
                    hidx = 0;
                }
                if (hidx!==0) {
                    switch (hsize) {
                        case 1:
                            x = sprintf("%d",hour);
                            break;
                        case 2:
                            x = sprintf("%02d",hour);
                            break;
                        default: 
                            crash("9/0"); // should never happen
                    }
                    res = $repss(res,hidx,(hidx+hlen)-1,x);
                    hidx = 0;
                }
                // (is am/pm language-dependent? do they all use latin?)
                x = $subse($subse($ampm,$currlang),ispm+1);
                if (fcase) {
                    x = upper(x);
                }
                break;
            case $TZ:
//              tz = td[$DT_TZ]
                tz = ((compare(length(td),$DT_TZ)>=0) ? $subse(td,$DT_TZ) : 0);
                if (tz===0) { tz = 1; }
                if (fcase) {
                    x = $subse($tzdescs,tz);
                } else {
                    x = $subse($timezones,tz);
                }
                break;
            case $TH:
                if (pftyp!==$DAY) {
                    ecode = 16;
                    break;
                }
//DEV $en (english) only?
                if (day<5 || day>20) {
                    day = remainder(day,10);
                }
                l = length($subse($td_ordinals,$currlang));
                if ((day===0) || day>l) {
                    day = l;
                }
                x = $subse($subse($td_ordinals,$currlang),day);
                if (fcase) {
                    x = upper(x);
                }
                break;
            default: 
                crash("9/0"); // should never happen
        }
        if (ecode!==0) { break; }
        res = $conCat(res, x, false);
        if (ftyp!==$TD_LITERAL) {
            pftyp = ftyp;
        }
    }
    if (ecode!==0) { return ["sequence",ecode,$subse($edescs,ecode),$ecxtra]; }
    if (!equal(fmtdx,length(fmt))) { crash("9/0"); } // should never happen
    if (equal(length(res),0)) { crash("9/0"); } // should never happen
    return res;
}
// maybe:
//global function new_timedate(integer year, integer month, integer day, integer hour=0, integer minute=0, integer seconds=0, integer dow=0, integer doy=0, object tz=0)
//timedate td
//  if dow=0 then
//      dow = day_of_week(year,month,day)
//  end if
//  if doy=0 then
//      doy = day_of_year(year,month,day)
//  end if
//  td = {year,month,day,hour,minute,seconds,dow,doy}
//  if string(tz) then
//      tz = find(tz,$timezones)
//      if tz=0 then ?9/0 end if
//  end if
//  if tz!=0 then
//      td = append(td,tz)
//      >>
//  end if
//end function

//DEV: (put this in a test routine?)
//sequence s
//s = parse_date_string("1996-03-31",{"YYYY-MM-DD"})
//integer jd = $timedate_to_julian_day(s)
//if jd!=2450174 then ?9/0 end if
//if $julian_day_to_timedate(jd,0,0,0,0)!={1996,3,31,0,0,0,0} then ?9/0 end if
//if $julian_day_to_timedate(0,0,0,0,0)!={-4713,11,24,0,0,0,0} then ?9/0 end if

//constant Gregorian_Reformation = 1752     (what is 1582?)

//function isLeap(integer year)
//-- returns integer (0 or 1)
//integer ly = remainder(year,4)=0
//  if ly and year>Gregorian_Reformation then
//      ly -= (remainder(year,100)=0)
//      ly += (remainder(year,400)=0)
//      ly -= (remainder(year,3200)=0)
//      ly += (remainder(year,80000)=0)
//  end if
//  return ly
//end function

//?{1900,isLeap(1900)}
//?{2000,isLeap(2000)}
//?{2004,isLeap(2004)}
//?{2100,isLeap(2100)}
//if isLeap(1900)!=0 then ?9/0 end if
//if isLeap(2000)!=1 then ?9/0 end if
//if isLeap(2004)!=1 then ?9/0 end if
//if isLeap(2100)!=0 then ?9/0 end if

/*global*/ function timedate_diff(/*timedate*/ td1, /*timedate*/ td2, /*integer*/ term=0) {
    let /*atom*/ delta = $timedate_to_seconds(td2)-$timedate_to_seconds(td1);
    if (term!==0) {
        let /*atom*/ tsec = $subse(["sequence",((365.25*24)*60)*60,((30*24)*60)*60,(24*60)*60,60*60,60,1],term);
        delta = trunc(delta/tsec)*((term===DT_YEAR) ? ((365*24)*60)*60 : tsec);
    }
    return delta;
}
/* test code:
include builtins\timedate.e

set_timedate_formats({"DD/MM/YYYY","Dddd, Mmmm dd yyyy"},2)

constant BIRTH_DATE = parse_date_string("28/6/1950")
constant DATE2 = date()
 
constant secs = timedate_diff(BIRTH_DATE, DATE2)
constant days = floor(secs/(24*60*60))
 
constant d3 = adjust_timedate(BIRTH_DATE, secs)
 
printf(1, "There are %d days between %s and %s. \n\n",  
          {days, 
            format_timedate(BIRTH_DATE),  
            format_timedate(DATE2) 
          }) 
           
printf(1, "%s plus %d days = %s. \n\n",  
          {format_timedate(BIRTH_DATE), days,  
           format_timedate(d3 ) 
          })           

-- output: 
 
-- There are 24268 days between  Wednesday, June 28 1950 and Tuesday, December 06 2016  
 
-- Wednesday, June 28 1950 plus 24268 days = Tuesday, December 06 2016  
{} = wait_key()
abort(0)

--DEV/SUG possible builtin? (I wrote this for Edix, but then decided on a "not visited" count.)
--        Alternative: timedate_delta(dt1,dt2) produces a timedelta (in seconds) which can be
--                      displayed using elapsed(). Maybe better, but I haven't written that.
global function days_between(sequence dt1, sequence dt2={})
--
-- if dt2 is omitted or of length zero the current date is used.
-- dt1 and dt2 need to start with y,m,d, but can be longer, eg from date(), parse_date_string(), or adjust_timedate().
-- if dt1 and dt2 are the same date (the first three elements match), the result will be 0.
-- if dt1 is a date before dt2 the result will be positive
-- if dt1 is a date after dt2 the result will be negative
-- for any non-defaulted dt2, days_between(dt1,dt2)==days_between(dt2,dt1)*-1
-- no rounding occurs: if dt1 is one second past midnight and dt2 is one second before midnight on the same day,
-- the result will still be 0, even though it is 99.998% of a day, and likewise if dt1 is one second before
-- midnight and dt2 is 1 second later, the result will still be 1, even though it is really 0.001% of a day.
--
    integer {y1,m1,d1} = dt1
    if length(dt2)=0 then dt2 = date() end if
    integer {y2,m2,d2} = dt2
    integer res = day_of_year(y2,m2,d2)-day_of_year(y1,m1,d1)
    while y2>y1 do
        y2 -= 1
        res += 365+is_leap_year(y2)
    end while
    while y2<y1 do
        res -= 365+is_leap_year(y2)
        y2 += 1
    end while
    return res
end function

--and some tests:
--  if days_between({2016,08,08},{2016,08,09})!=1 then ?9/0 end if
--  if days_between({2016,01,01},{2016,08,09})!=221 then ?9/0 end if
--  if days_between({2015,12,31},{2016,08,09})!=222 then ?9/0 end if
--  if days_between({2015,01,01},{2016,08,09})!=586 then ?9/0 end if
--  if days_between({2014,12,31},{2016,08,09})!=587 then ?9/0 end if
--  if days_between({2017,01,01},{2016,08,09})!=-145 then ?9/0 end if
--  if days_between({2016,12,31},{2016,08,09})!=-144 then ?9/0 end if
--  if days_between({2016,08,10},{2016,08,09})!=-1 then ?9/0 end if
--  if days_between({2016,12,31},{2016,08,09})!=-144 then ?9/0 end if
--  if days_between({2016,08,09},{2016,12,31})!=144 then ?9/0 end if
--  if days_between(date())!=0 then ?9/0 end if
--  if days_between({1900,01,01},{2016,08,09})!=42589 then ?9/0 end if
*/
