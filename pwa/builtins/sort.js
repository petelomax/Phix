// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
// Euphoria 2.4
// Sorting

// Sort the elements of a sequence into ascending order, using "Shell" sort.

//without debug
//DEV wrong one for newEmit
//!/**/include builtins\pcfunc.e

//defined in psym.e:
//global enum ASCENDING = -1,  NORMAL_ORDER = ASCENDING,
//           DESCENDING = +1, REVERSE_ORDER = DESCENDING

/*global*/ function sort(/*sequence*/ x, /*integer*/ order=ASCENDING) {
//
// Sort a sequence into ascending order. The elements can be atoms or 
// sequences. The standard compare() routine is used to compare elements.
//
    let /*integer*/ gap, j, first, last;
    let /*object*/ tempi, tempj;
//DEV temp!
//?"sort deep_copy..."
//?x
//x = deep_copy(x)
    last = length(x);
    gap = floor(last/10)+1;
    while (true) {
        first = gap+1;
        for (let i=first, i$lim=last; i<=i$lim; i+=1) {
            tempi = $subse(x,i);
            j = i-gap;
            while (true) {
                tempj = $subse(x,j);
//              if tempi >= tempj then
//              if compare(tempi, tempj)>=0 then
                if (!equal(compare(tempi,tempj),order)) {
                    j += gap;
                    break;
                }
                x = $repe(x,j+gap,tempj);
                if (j<=gap) {
                    break;
                }
                j -= gap;
            }
            x = $repe(x,j,tempi);
        }
        if (gap===1) {
            return x;
        } else {
            gap = floor(gap/3.5)+1;
        }
    }
}
function $tagsort(/*integer*/ i, /*integer*/ j, /*sequence*/ data) {
// standard function for a standard $tagsort
//26/6/20
//  return compare(data[i],data[j])
    let /*integer*/ c = compare($subse(data,i),$subse(data,j));
    if (c===0) { c = compare(i,j); }
    return c;
}
//DEV/SUG column_tagsort???

/*global*/ function custom_sort(/*object*/ custom_compare, /*sequence*/ x, /*object*/ data=["sequence"], /*integer*/ order=ASCENDING) {
//
// Sort a sequence. A user-supplied comparison function is used to compare elements. 
// Note that this sort is not "stable", i.e. elements that are considered equal might 
// change position relative to each other.
//
    let /*integer*/ gap, j, first, last;
    let /*object*/ tempi, tempj;
    let /*sequence*/ args = ["sequence",0, 0];
    if (atom(data)) {
        args = $conCat(args, data, false);
//DEV... (broke self hosting... wtf??) [it ain't psym... afaict anyway] [seems to have righted itself 14/4/21...]
    } else if (!equal(data,["sequence"])) {
//  elsif length(data)!=0 then
        if (!equal(length(data),1)) { crash("9/0"); }
        args = append(args,$subse(data,1));
    } else if (sequence(custom_compare)) {
        //DEV For now. We could add order to tagset() above,
        //             and/or implement that column_tagsort?
        if ((!equal(data,["sequence"])) || (order!==ASCENDING)) { crash("9/0"); }
        args = append(args,custom_compare);
        custom_compare = $tagsort;
    }
    last = length(x);
    gap = floor(last/10)+1;
    while (1) {
        first = gap+1;
        for (let i=first, i$lim=last; i<=i$lim; i+=1) {
            tempi = $subse(x,i);
            args = $repe(args,1,tempi);
            j = i-gap;
            while (1) {
                tempj = $subse(x,j);
                args = $repe(args,2,tempj);
//              if call_func(custom_compare, {tempi, tempj})>=0 then
                if (!equal(call_func(custom_compare,args),order)) {
//              integer c = call_func(custom_compare, args)
//              if c!=order then
//?{"j+=gap",c,order}
                    j += gap;
                    break;
                }
                x = $repe(x,j+gap,tempj);
                if (j<=gap) {
                    break;
                }
                j -= gap;
            }
            x = $repe(x,j,tempi);
        }
        if (gap===1) {
            return x;
        } else {
            gap = floor(gap/3.5)+1;
        }
    }
}
function $column_compare(/*object*/ a, /*object*/ b, /*sequence*/ cols) {
// Local function used by sort_columns()
    for (let i=1, i$lim=length(cols); i<=i$lim; i+=1) {
        let /*integer*/ sgn = 1, 
                        column = $subse(cols,i);
        if (column<0) {
            sgn = -1;
            column = -column;
        }
        if (compare(column,length(a))<=0) {
            if (compare(column,length(b))>0) { return -sgn; }
            let /*integer*/ c = compare($subse(a,column),$subse(b,column));
            if (c!==0) { return sgn*c; }
        } else {
            if (compare(column,length(b))>0) { break; }
            return sgn;
        }
    }
    return 0;
}
//**
// Sort the rows in a sequence according to a user-defined
// column order.
//
// Parameters:
// # ##x## : a sequence, holding the sequences to be sorted.
// # ##column_list## : a list of columns indexes ##x## is to be sorted by.
//
// Returns:
//   A **sequence**, a copy of the original sequence in sorted order.
//
// Comments:
//
// ##x## must be a sequence of sequences.
//
// A non-existent column is treated as coming before an existing column. This
// allows sorting of records that are shorter than the columns in the
// column list.
//
// By default,
// columns are sorted in ascending order. To sort in descending
// order, make the column number negative.
//
//  This function uses the "Shell" sort algorithm.
// This sort is not "stable", i.e. elements that are considered equal might
// change position relative to each other.
//
// Example 1:
//   <eucode>
//   sequence dirlist
//   dirlist = dir(`c:\temp`)
//   sequence sorted
//   -- Order is Size:descending, Name
//   sorted = sort_columns( dirlist, {-D_SIZE, D_NAME} )
//   </eucode>
//
// See Also:
//   [[:compare]], [[:sort]]

/*global*/ function sort_columns(/*sequence*/ x, /*sequence*/ column_list) {
    x = custom_sort($column_compare,deep_copy(x),["sequence",column_list]);
    return x;
}
