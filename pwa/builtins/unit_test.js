// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\unit_test.e
//
//  A simple unit testing framework for Phix (autoinclude).
//
//      test_equal(2+2,4,"2+2 is not 4 !!!!")
//      test_summary()
//
//  If all goes well, no output is shown, and the program carries on normally.
//  You can easily force [summary/verbose] output, crash/prompt on fail, etc. [See docs]

//  Note that I have used the same routine names as Euphoria, but the parameters are
//       all different [esp their order] and therefore they are not compatibile...
//       In particular you have to give every test a name in Euphoria, whereas here
//       such things are optional. Also, Euphoria works by putting tests in files
//       named "t_*" and running eutest, whereas here they are part of the app, and
//       will start failing on live systems (eg) if not properly installed.
//
// now in psym.e:
//global enum
//  TEST_QUIET          = 0,    -- (summary only when fail)
//  TEST_SUMMARY        = 1,    -- (summary only [/always])
//  TEST_SHOW_FAILED    = 2,    -- (summary + failed tests)
//  TEST_SHOW_ALL       = 3     -- (summary + all tests)
//  TEST_ABORT          = 1     -- (abort on failure, at summary)
// (TEST_QUIET          = 0)    -- (carry on despite failure)
//  TEST_CRASH          = -1    -- (crash on failure, immediately)
//  TEST_PAUSE          = 1     -- (always pause)
// (TEST_QUIET          = 0)    -- (never pause)
//  TEST_PAUSE_FAIL     = -1    -- (pause on failure)
//
let /*integer*/ $tests_run = 0, 
                $tests_passed = 0, 
                $tests_failed = 0, 
                $verbosity = TEST_QUIET, 
                $abort_on_fail = TEST_QUIET, 
                $pause_summary = TEST_PAUSE_FAIL, 
                $log_fn = 0;
// (aside: 0 rather than "" avoids need for a test_init(), when autoincluded:)
let /*object*/ $module = 0,  // (set to string by set_test_module)
               $prev_module = 0; // (    ""           $show_module)
function $test_log(/*string*/ fmt, /*sequence*/ args=["sequence"]) {
    printf(2,fmt,args);
    if ($log_fn!==0) {
        printf($log_fn,fmt,args);
    }
}
function $show_module() {
    if (!equal($prev_module,$module)) {
        $test_log("%s:\n",["sequence",$module]);
        $prev_module = $module;
    }
}

/*global*/ function set_test_verbosity(/*integer*/ level) {
    $verbosity = level;
}

/*global*/ function get_test_verbosity() {
    return $verbosity;
}

/*global*/ function set_test_abort(/*integer*/ abort_test) {
// abort_test is TEST_ABORT(at summary)/TEST_QUIET/TEST_CRASH(immediately)
    $abort_on_fail = abort_test;
}

/*global*/ function get_test_abort() {
    return $abort_on_fail;
}

/*global*/ function set_test_pause(/*integer*/ pause) {
// pause is TEST_PAUSE/TEST_QUIET/TEST_PAUSE_FAIL (default)
    $pause_summary = pause;
}

/*global*/ function get_test_pause() {
    return $pause_summary;
}

/*global*/ function set_test_logfile(/*string*/ filename) {
// (closed by test_summary([true]))
    if ($log_fn!==0) { crash("9/0"); }
    if (!equal(platform(),JS)) {
        $log_fn = open(filename,"w");
        if ($log_fn===-1) { crash("9/0"); }
    }
}

/*global*/ function get_test_logfile() {
    return $log_fn;
}

/*global*/ function test_summary(/*bool*/ close_log=true) {
    if (($tests_run>0 && $verbosity>=TEST_SUMMARY) || $tests_failed>0) {
        $show_module();
        let /*string*/ passpc = sprintf("%.2f",($tests_passed/$tests_run)*100);
        if (equal($subss(passpc,-3,-1),".00")) { passpc = $subss(passpc,1,-4); }
        if (($tests_failed!==0) && (passpc==="100")) { passpc = "99.99"; }
                // (the above may be needed when $tests_run is > 10,000)
        $test_log("\n %d tests run, %d passed, %d failed, %s%% success\n",["sequence",$tests_run,$tests_passed,$tests_failed,passpc]);
        if (($pause_summary===TEST_PAUSE) || (($pause_summary===TEST_PAUSE_FAIL) && $tests_failed>0)) {
//?{"cl",command_line(true)}
//?{"cl",lower(command_line(true)),command_line(true)}
            if ((!equal(platform(),JS)) && !find("-nopause",lower(command_line(true)))) {
                puts(1,"Press any key to continue...");
                /*[,] =*/ wait_key();
                puts(1,"\n");
            }
        }
    }
    if (close_log && $log_fn>0) {
        close($log_fn);
        $log_fn = 0;
    }
    if ($tests_failed>0 && ($abort_on_fail===TEST_ABORT)) {
        abort(1);
    }
    $tests_run = 0;
    $tests_passed = 0;
    $tests_failed = 0;
    $module = 0;
    $prev_module = 0;
}

/*global*/ function set_test_module(/*string*/ name) {
//
//  The $module name is simply a hint to the programmer about where to go to 
//  fix some problem just introduced/detected, eg after
//
//      set_test_module("logical")
//      ...
//      set_test_module("relational")
//      ...
//      set_test_module("regression")
//      ...
//      test_summary()
//
//  if you get (say)
//
//      relational:
//        test12 failed: 2 expected, got 4
//       20 tests run, 19 passed, 1 failed, 95% success
//
//  then you know to look for the "test12" test in the relational section.
//  test_summary() is automatically invoked by set_test_module(), and you
//  have to do it right at the end, or risk getting no output whatsoever.
//  Obviously you are free to use any appropriate section names, and if
//  you never invoke set_test_module() they are all lumped together.
//  Likewise it is perfectly fine if you cannot be bothered to name the
//  individual tests, just a bit more of a hunt should they trigger.
//
    if ($tests_run!==0) {
        test_summary(false);
    }
    $module = name;
}
let set_test_section = set_test_module;
//Instead of this there is now an Alias() in psym.e:
//global procedure set_test_section(string name)
//  set_test_module(name)
//end procedure
function $sn2(/*sequence*/ s) {
    // both/two "\nhelpful strings"?
    return ((((string($subse(s,1)) && length($subse(s,1))) && (equal($subse($subse(s,1),1),0XA))) && string($subse(s,2))) && length($subse(s,2))) && (equal($subse($subse(s,2),1),0XA));
}
function $test_result(/*bool*/ success, /*sequence*/ args, /*integer*/ fdx, level) {
//  string fmt = iff(fdx=1?"  failed: %s: %v should %sequal %v\n"
    let /*string*/ fmt = 
                         ((fdx===1) ? (($sn2(extract(args,["sequence",2,4]))) ? "  failed: %s: %s should %sequal %s\n" : "  failed: %s: %v should %sequal %v\n") : "  failed: %s\n");
    $tests_run += 1;
    if (success) {
        if (($verbosity===TEST_SHOW_ALL) && (!equal($subse(args,1),""))) {
            $show_module();
            $test_log("  passed: %s\n",args);
        }
        $tests_passed += 1;
    } else {
        if ($verbosity>=TEST_SHOW_FAILED) {
            $show_module();
            $test_log(fmt,args);
        }
        if ($abort_on_fail===TEST_CRASH) {
            crash("unit test failure (%s)",args,level);
        }
        $tests_failed += 1;
    }
}
/*
local function str_equal(object a, b, string fmt)
    -- a and b always have the same "shape"
    if string(a) or string(b) then
        return string(a) and string(b) and a==b
    elsif not atom(a) then
        bool success = true
        for i=1 to length(a) do
            success = str_equal(a[i],b[i],fmt)
            if not success then exit end if
        end for
        return success
    end if
    return (a==b) or (sprintf(fmt,a)==sprintf(fmt,b))
end function

local function atom_equal(object a, b, atom epsilon)
    -- a and b always have the same "shape"
    if string(a) or string(b) then
        return string(a) and string(b) and a==b
    elsif not atom(a) then
        bool success = true
        for i=1 to length(a) do
            success = atom_equal(a[i],b[i],epsilon)
            if not success then exit end if
        end for
        return success
    elsif not atom(b) then
        return false
    end if
    return abs(a-b)<epsilon
end function

local type atom_or_string(object o)
    return string(o) or atom(o)
end type
*/

///!*
/*local*/ function $rec_equal(/*object*/ a, b, /*string*/ fmt) {
    if (string(a) || string(b)) {
        return (string(a) && string(b)) && (equal(a,b));
    } else if (!equal(atom(a),atom(b))) {
        return false;
    } else if (!atom(a)) {
        if (!equal(length(b),length(a))) { return false; }
        let /*bool*/ success = true;
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            success = $rec_equal($subse(a,i),$subse(b,i),fmt);
            if (!success) { break; }
        }
        return success;
    }
    // both atoms:
    if (equal(a,b)) { return true; }
    let /*string*/ sa = sprintf(fmt,a), 
                   sb = sprintf(fmt,b);
    if (sa===sb) { return true; }
    // catch eg `-0.000000000000000`
    //        != `0.000000000000000`
//?sa
//?sb
    return (equal(filter(sa,"out","0-."),"")) && (equal(filter(sb,"out","0-."),""));
}

/*local*/ function $bool_or_string(/*object*/ o) {
//  return iff(integer(o) ? o==not not o : string(o))
    return ((integer(o)) ? compare(abs(o),1)<=0 : string(o));
}
//*!/

//global procedure test_equal(object a, object b, string name="", atom_or_string epsilon=1e-9, bool eq=true)
//global procedure test_equal(object a, object b, string name="", object args={}, $bool_or_string bApprox=false, bool eq=true)
/*global*/ function test_equal(/*object*/ a, /*object*/ b, /*string*/ name="", /*object*/ args=["sequence"], /*$bool_or_string*/ bApprox=-1, /*bool*/ eq=true) {
    if (sequence(args) && !string(args)) {
        if (!equal(args,["sequence"])) { name = sprintf(name,args); }
        bApprox = compare(bApprox,0)>0;
    } else if (equal(bApprox,-1)) { // (no args and one bool/str case)
        bApprox = args;
    } else {
                          // (no args but two more args case)
        assert(eq);         // 3 args specified??
        eq = bApprox;
        bApprox = args;
    }
//global procedure test_equal(object a, object b, string name="", bool bApprox = false, eq=true)
    let /*bool*/ success;
/* I completely forgot about bool eq, bit of a daft idea anyway.
    -- Eu compatibility, ie args of (name, a, b):
    if string(a) and string(b) and name!="" then -- (and string(name), obvs!)
        if (length(a)!=length(b) and length(b)=length(name))
        or (a!=b and b=name) then
            {a,b,name} = {b,name,a}
        end if
    end if
    -- </Eu compatibility>
*/
    if (equal(a,b)) {
        success = true;
/*
    elsif sq_mul(0,a)=sq_mul(0,b) then
        -- for complicated sequences values (same shape)
        if string(epsilon) then
            success = str_equal(a,b,epsilon)
        elsif not atom(a) then
            success = atom_equal(a,b,epsilon)
        else
            success = abs(a-b)<epsilon
        end if
    else
*/
    } else if (equal(bApprox,false)) {
        success = false;
    } else {
        if (equal(bApprox,true)) { bApprox = "%g"; }
        success = $rec_equal(a,b,bApprox);
//      success = $rec_equal(a,b,iff(string(bApprox)?bApprox:"%g"))
        if ((!success && atom(a)) && atom(b)) {
            a = sprintf(bApprox,a);
            b = sprintf(bApprox,b);
        }
    }
    let /*string*/ ne = ((eq) ? "" : "not ");
    $test_result(success===eq,["sequence",name,a,ne,b],1,4-eq);
}
//global procedure test_not_equal(object a, object b, string name="", atom_or_string epsilon=1e-9)
/*global*/ function test_not_equal(/*object*/ a, /*object*/ b, /*string*/ name="", /*object*/ args=["sequence"], /*$bool_or_string*/ bApprox=false) {
//  test_equal(a,b,name,epsilon,false)
    test_equal(a,b,name,args,bApprox,false);
}

/*global*/ function test_true(/*bool*/ success, /*string*/ name="", /*sequence*/ args=["sequence"]) {
    if (!equal(args,["sequence"])) { name = sprintf(name,args); }
    $test_result(success,["sequence",name],2,3);
}

/*global*/ function test_false(/*bool*/ success, /*string*/ name="", /*sequence*/ args=["sequence"]) {
    if (!equal(args,["sequence"])) { name = sprintf(name,args); }
    $test_result(!success,["sequence",name],2,3);
}

/*global*/ function test_pass(/*string*/ name="", /*sequence*/ args=["sequence"]) {
    if (!equal(args,["sequence"])) { name = sprintf(name,args); }
    $test_result(true,["sequence",name],2,3);
}

/*global*/ function test_fail(/*string*/ name="", /*sequence*/ args=["sequence"]) {
    if (!equal(args,["sequence"])) { name = sprintf(name,args); }
    $test_result(false,["sequence",name],2,3);
}
