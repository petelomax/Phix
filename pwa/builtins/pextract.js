// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\pextract.e
//

/*global*/ function extract(/*sequence*/ source, indexes, /*integer*/ invert=false) {
    let /*integer*/ l = length(indexes), ii;
//  sequence res = repeat(0,l)
    if (odd(invert)) {
        let /*sequence*/ inverse = repeat(0,l); // (or tagset??)
        for (let i=1, i$lim=l; i<=i$lim; i+=1) {
            ii = $subse(indexes,i);
            inverse = $repe(inverse,ii,i);
        }
        indexes = inverse;
        invert -= 1;
    }
    let /*sequence*/ res = repeat((((invert===0) && string(source)) ? 0X20 : 0),l);
    for (let i=1, i$lim=l; i<=i$lim; i+=1) {
        ii = $subse(indexes,i);
        res = $repe(res,i,$subse(source,ii));
    }
    return res;
}

/*global*/ function reinstate(/*sequence*/ source, /*object*/ indexes, replacements, /*bool*/ invert=false) {
    let /*sequence*/ res;
    if ((equal(source,["sequence"])) && sequence(indexes)) {
        assert(!invert);   // (??)
        res = repeat(0,maxsq(indexes));
        if (equal(replacements,["sequence"])) {
            replacements = tagset(length(indexes));
        }
    } else {
        res = deep_copy(source);
    }
    if (integer(indexes)) {
        assert(!invert);
        res = $repe(res,indexes,replacements);
    } else {
        let /*integer*/ l = length(indexes), ii;
//2/5/24:
//      if length(replacements)!=l then ?9/0 end if
        if (invert) {
            let /*sequence*/ inverse = repeat(0,l);
            for (let i=1, i$lim=l; i<=i$lim; i+=1) {
                ii = $subse(indexes,i);
                inverse = $repe(inverse,ii,i);
            }
            indexes = inverse;
        }
        if (atom(replacements)) {
            for (let i=1, i$lim=l; i<=i$lim; i+=1) {
                ii = $subse(indexes,i);
                res = $repe(res,ii,replacements);
            }
        } else {
//21/5/24:
            let /*bool*/ one = (equal(length(replacements),1)) && (!equal(length(indexes),1));
            assert(one || (equal(length(replacements),l)));
            for (let i=1, i$lim=l; i<=i$lim; i+=1) {
                ii = $subse(indexes,i);
                res = $repe(res,ii,$subse(replacements,((one) ? 1 : i)));
            }
        }
    }
    return res;
}
