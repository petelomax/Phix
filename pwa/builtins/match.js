// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\match.e
// ================
//
//  hll implementation of match()  (replaces builtins\VM\pMatch.e)
//
//  Changes noted below ("Euphoria") arose from a protracted discussion on EuForum in 2002.
//
/*without debug*/
/*global*/ function match(/*object*/ needle, /*sequence*/ haystack, /*integer*/ start=1, /*bool*/ case_sensitive=true) {
//
// Try to match needle against some slice of haystack.
// Return the element number of haystack where the (first) matching slice begins, else 0.  
//
// Finding a short int is faster than anything else, because there is no dereference, hence 
// when we hit a mismatch and one of the disagreeing values is a shortint, use that to look
// for a better place to restart the top-level scan.
//
    // This line, and first parameter being object not sequence, is not Euphoria compliant.
    //  (Euphoria gives error "first argument of match() must be a sequence")
    if (atom(needle)) {
        return find(needle,haystack,start);
    }
    if (!case_sensitive) {
        needle = lower(needle);
        haystack = lower(haystack);
    }
    let /*integer*/ res = start, 
                    nl = length(needle), 
                    hl = length(haystack);
    // This line is also not Euphoria compliant
    //  (Euphoria gives error "first argument of match() must be a non-empty sequence")
    if (nl===0) { return 0; }
    if (start<1) { return 0; }
    while ((res+nl)-1<=hl) {
        for (let i=1, i$lim=nl; i<=i$lim; i+=1) {
            let /*integer*/ hdx = (i+res)-1;
            let /*object*/ ni = $subse(needle,i), 
                           hi = $subse(haystack,hdx);
            if (!equal(ni,hi)) {
                if (integer(ni)) {
                    // scan for ni later on in haystack
                    // eg needle=13131..., and
                    //  haystack=1313x31...
                    // with needle[5]=1, scanning forward two places to haystack[7]=1
                    // gives the earliest point worth re-starting from.
                    // if ni does not occur anywhere later in haystack, then
                    // clearly there will be no match anywhere.
                    for (let j=hdx+1, j$lim=hl+1; j<=j$lim; j+=1) {
                        res += 1;
                        if (j>hl) { return 0; }
                        hi = $subse(haystack,j);
                        if (equal(ni,hi)) { break; }
                    }
                    break;
                } else if (integer(hi)) {
                    // scan for hi earlier on in needle
                    // eg needle=131313x..., and
                    //  haystack=1313131...
                    // with haystack[7]=1, scanning back two places to needle[5]=1
                    // gives the earliest point worth re-starting from.
                    // if haystack[7] does not occur anywhere earlier in needle,
                    // then clearly we should restart from haystack[8].
                    for (let j=i-1; j>=0; j-=1) {
                        res += 1;
                        if (j===0) { break; }
                        ni = $subse(needle,j);
                        if (equal(hi,ni)) { break; }
                    }
                    break;
                } else {
                    res += 1;
                    break;
                }
            }
            if (i===nl) { return res; }
        }
    }
    return 0;
}

/*global*/ function rmatch(/*object*/ needle, /*sequence*/ haystack, /*integer*/ start=length(haystack), /*bool*/ case_sensitive=true) {
//
// Try to match a needle against some slice of a haystack in reverse order.
// Return the element number of haystack where the (last<=start) matching slice begins, else 0.  
//
    // This line, and first parameter being object not sequence, is not Euphoria compliant.
    //  (Euphoria gives error "first argument of match() must be a sequence")
    if (atom(needle)) {
        return rfind(needle,haystack,start);
    }
    let /*integer*/ nl = length(needle), 
                    hl = length(haystack);
    if ((((nl===0) || (start===0)) || start>hl) || compare(hl+start,1)<0) {
        return 0;
    }
    if (!case_sensitive) {
        needle = lower(needle);
        haystack = lower(haystack);
    }
    if (start<1) {
        start = hl+start;
    }
    if ((start+nl)-1>hl) {
        start = (hl-nl)+1;
    }
    for (let i=start; i>=1; i-=1) {
        for (let j=1, j$lim=nl; j<=j$lim; j+=1) {
            if (!equal($subse(needle,j),$subse(haystack,(i+j)-1))) { break; }
            if (j===nl) { return i; }
        }
    }
    return 0;
}

/*global*/ function match_all(/*object*/ needle, /*sequence*/ haystack, /*integer*/ start=1, /*bool*/ case_sensitive=true, overlap=false) {
    if (!case_sensitive) {
        needle = lower(needle);
        haystack = lower(haystack);
    }
    if (atom(needle)) {
        return find_all(needle,haystack,start);
    }
    let /*sequence*/ res = ["sequence"];
    while (1) {
        start = match(needle,haystack,start);
        if (start===0) { break; }
        res = append(res,start);
        start += ((overlap) ? 1 : length(needle));
    }
    return res;
}

/*global*/ function begins(/*object*/ sub_text, /*sequence*/ full_text) {
    let /*integer*/ lf = length(full_text);
    if (lf===0) { return false; }
    if (atom(sub_text)) {
        // eg begins('c',"cat") -> true.
        return equal(sub_text,$subse(full_text,1));
    }
    let /*integer*/ ls = length(sub_text);
    return ls<=lf && (equal(sub_text,$subss(full_text,1,ls)));
}

/*global*/ function $ends(/*object*/ sub_text, /*sequence*/ full_text) {
    let /*integer*/ lf = length(full_text);
    if (lf===0) { return false; }
    if (atom(sub_text)) {
        // eg $ends('t',"cat") -> true.
        return equal(sub_text,$subse(full_text,-1));
    }
    let /*integer*/ ls = length(sub_text);
    return ls<=lf && (equal(sub_text,$subss(full_text,-ls,-1)));
}
