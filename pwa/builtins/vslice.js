// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\vslice.e
//

/*
--global 
function vslice(sequence source, integer column)
--1/10/19 (make res string if possible)
--  for i=1 to length(source) do
--      source[i] = source[i][column]
--  end for
--  return source
    sequence res = ""
    for i=1 to length(source) do
        res = append(res,source[i][column])
    end for
    return res
end function
*/

//SUG: (untested/undocumented)
/*global*/ function vslice(/*sequence*/ source, /*object*/ column, error_control=0) {
    let /*integer*/ current_sub = 0, 
                    substitutes = 
                                  ((atom(error_control)) ? -!error_control : length(error_control));
//  sequence res = ""
    let /*sequence*/ res = ((string(source)) ? "" : ["sequence"]);
    if (integer(column)) {
        if (compare(column,1)<0) { crash("vslice(%d)",column); }
        for (let i=1, i$lim=length(source); i<=i$lim; i+=1) {
            if (atom($subse(source,i)) || compare(column,length($subse(source,i)))>0) {
                if (substitutes<=0) {
                    if (substitutes===0) { break; }
                    crash("vslice[%d][%d] oob",["sequence",i,column],2);
                }
                current_sub += 1;
                if (compare(current_sub,length(error_control))>0) { current_sub = 1; }
                res = append(res,$subse(error_control,current_sub));
            } else {
                res = append(res,$subse($subse(source,i),column));
            }
        }
    } else {
        let /*integer*/ [,s,e] = ((equal(length(column),2)) ? column : ["sequence",0,0]);
//19/5/24 (permit -ve idx)
        if (s<0) { s = (length(source)+s)+1; }
        if (e<0) { e = (length(source)+e)+1; }
        if (s<1 || e<s-1) { crash("vslice(%v)",["sequence",column]); }
        for (let i=1, i$lim=length(source); i<=i$lim; i+=1) {
            if (atom($subse(source,i)) || compare(e,length($subse(source,i)))>0) {
                if (substitutes<=0) {
                    if (substitutes===0) { break; }
//              if atom(error_control) then
//                  if error_control!=0 then exit end if
                    crash("vslice[%d][%d..%d] oob",$conCat(i, column),2);
                }
                current_sub += 1;
                if (compare(current_sub,length(error_control))>0) { current_sub = 1; }
                res = append(res,$subse(error_control,current_sub));
            } else {
                res = append(res,$subss($subse(source,i),s,e));
            }
        }
    }
    return res;
}
/*
function vslice(sequence source, atom colno, object error_control=0)
    for i = 1 to length(source) do
        if colno > length(source[i]) then
            if substitutes = -1 then
                error:crash("sequence:vslice(): colno should be a valid index on the %d-th element, but was %d", {i, colno})
            elsif substitutes = 0 then
                return source[1..i-1]
            else
                current_sub += 1
                if current_sub > length(error_control) then
                    current_sub = 1
                end if
                source[i] = error_control[current_sub]
                
            end if
        else
            if sequence(source[i]) then
                source[i] = source[i][colno]
            end if
        end if
    end for

    return source
end function

function vslice(sequence source, atom colno, object error_control=0)
    for i=1 to length(source) do
        if colno>=1+length(source[i]) then
            if substitutes=-1 then
                crash("sequence:vslice(): colno should be a valid index on the %d-th element, but was %d", {i,colno})
            elsif substitutes=0 then
                return ret[1..i-1]
            else
                                current_sub += 1
                                if current_sub > length(error_control) then
                                        current_sub = 1
                                end if

                substitutes -= 1
                ret[i] = error_control[current_sub]
                current_sub += 1
            end if
        else
            ret[i] = source[i][colno]
        end if
    end for

    return ret
end function

*/
