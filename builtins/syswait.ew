--
--  syswait.ew (Phix compatible)
--  ==========
--
--      Phix implementation of system_exec, system, and system_open.
--
--      system_wait is functionally identical to system_exec but takes only one parameter
--       and exists (as well as system_exec) for compatibility reasons only.
--      system_open can be used to open documents or web pages, equivalent to double-
--       clicking on a file in Explorer. The executable associated with the extension
--       is automatically located (and in fact cannot be specified).
--      system creates a new shell (%COMSPEC% /C) to run the specified command.
--      system_exec must be passed an executable (not dir, mkdir, rename, etc).
--      set_system_doevents() is used with system_exec/wait to allow background
--       processing, event handlers etc to continue while waiting.
--
-- Credit: based heavily on system_wait.ew by Juergen Luethje.
--

--DEV drop all pretence of Eu(2.4) compatibility: all the linux stuff is in #ilASM...

constant
    W = machine_word(),
--  FALSE = 0,
--  TRUE = 1,
    SW_NORMAL = 1,
--  INFINITE = #FFFFFFFF,    -- Infinite timeout
    FORTYMS = 40,            -- Forty milliseconds, 1/25th of a second
--  ONE32TH = 0.03125        -- 1/32 second (31.25 ms) (for linux)
--  STARTF_USESHOWWINDOW = 1,
    STARTF_USESTDHANDLES = #100,
--  STD_OUTPUT_HANDLE   = -11,  -- #FFFFFFF5
--  STD_INPUT_HANDLE    = -10,  -- #FFFFFFF6
--  STD_ERROR_HANDLE    = -12,
    STILL_ACTIVE = 259
--  ,
--  PROCESS_QUERY_INFORMATION=#400
--  CREATE_NEW_CONSOLE=#10
--Public Enum ProcessCreationFlags
--   DEBUG_PROCESS            = &H1
--   DEBUG_ONLY_THIS_PROCESS      = &H2
--   CREATE_SUSPENDED         = &H4
--   DETACHED_PROCESS         = &H8
--   CREATE_NEW_CONSOLE       = &H10
--   NORMAL_PRIORITY_CLASS    = &H20
--   IDLE_PRIORITY_CLASS          = &H40
--   HIGH_PRIORITY_CLASS          = &H80
--   REALTIME_PRIORITY_CLASS      = &H100
--   CREATE_NEW_PROCESS_GROUP   = &H200
--   CREATE_UNICODE_ENVIRONMENT = &H400
--   CREATE_SEPARATE_WOW_VDM      = &H800
--   CREATE_SHARED_WOW_VDM    = &H1000
--   CREATE_FORCEDOS              = &H2000
--   CREATE_DEFAULT_ERROR_MODE  = &H4000000
--   CREATE_NO_WINDOW         = &H8000000
--End Enum

constant    -- TYPE STARTUPINFO
--  cb              =  0,       -- DWORD        -- size in bytes
--  lpReserved      =  4,       -- ASCIIZ PTR
--  lpDesktop       =  8,       -- ASCIIZ PTR
--  lpTitle         = 12,       -- ASCIIZ PTR
--  dwX             = 16,       -- DWORD
--  dwY             = 20,       -- DWORD
--  dwXSize         = 24,       -- DWORD
--  dwYSize         = 28,       -- DWORD
--  dwXCountChars   = 32,       -- DWORD
--  dwYCountChars   = 36,       -- DWORD
--  dwFillAttribute = 40,       -- DWORD
--  dwFlags         = 44,       -- DWORD
    dwFlags         = 4*W+28,   -- DWORD
--  wShowWindow     = 48,       -- WORD
--  cbReserved2     = 50,       -- WORD
--  lpReserved2     = 52,       -- BYTE PTR
--  hStdInput       = 56,       -- DWORD
    hStdInput       = W*6+32,   -- DWORD
--  hStdOutput      = 60,       -- DWORD
    hStdOutput      = W*7+32,   -- DWORD
--  hStdError       = 64,       -- DWORD
    hStdError       = W*8+32,   -- DWORD
--SIZEOF_STARTUPINFO = 68
SIZEOF_STARTUPINFO = W*9+32

constant    -- TYPE PROCESS_INFORMATION
    hProcess    =  0,   -- HANDLE
    hThread     =  W,   -- HANDLE
--  dwProcessId =  8,   -- DWORD
--  dwThreadId  = 12,   -- DWORD
SIZEOF_PROCESS_INFORMATION = W*2+8

enum PIPEIN, PIPOUT, PIPERR
enum READ_PIPE, WRITE_PIPE

integer swinit swinit = 0
atom kernel32,xCreateProcess,xWaitForSingleObject,xGetExitCodeProcess,
--   xGetProcessTimes,lpCreationTime,lpExitTime,lpKernelTime,lpUserTime,
--   xGetStdHandle,
     xCloseHandle,
--   xGetLastError,
     shell32, xShellExecute
--   user32, xWaitForInputIdle,
--/*
     ,xOpen
--*/

procedure initsw()
    enter_cs()
    if platform()=WINDOWS then
        kernel32 = open_dll("kernel32.dll")

--#without reformat
        xCreateProcess = define_c_func(kernel32, "CreateProcessA",
            {C_PTR,     --  LPCTSTR lpApplicationName, // pointer to name of executable module
             C_PTR,     --  LPTSTR lpCommandLine, // pointer to command line string
             C_PTR,     --  LPSECURITY_ATTRIBUTES lpProcessAttributes, // pointer to process security attributes
             C_PTR,     --  LPSECURITY_ATTRIBUTES   lpThreadAttributes, // pointer to thread security attributes
             C_BOOL,    --  BOOL  bInheritHandles, // handle inheritance flag 
             C_DWORD,   --  DWORD   dwCreationFlags, // creation flags
             C_PTR,     --  LPVOID lpEnvironment, // pointer to new environment block
             C_PTR,     --  LPCTSTR  lpCurrentDirectory, // pointer to current directory name
             C_PTR,     --  LPSTARTUPINFO   lpStartupInfo, // pointer to STARTUPINFO
             C_PTR},    --  LPPROCESS_INFORMATION lpProcessInformation // pointer to PROCESS_INFORMATION
            C_LONG)     -- BOOL 

        xWaitForSingleObject = define_c_func(kernel32, "WaitForSingleObject",
            {C_PTR,     --  HANDLE hObject, // handle of object to wait for
             C_DWORD},  --  DWORD   dwTimeout // time-out interval in milliseconds
            C_DWORD)    -- DWORD -- WAIT_ABANDONED, WAIT_OBJECT_0, or WAIT_TIMEOUT

        xGetExitCodeProcess = define_c_func(kernel32, "GetExitCodeProcess",
            {C_PTR,     --  HANDLE hProcess, // handle to the process
             C_PTR},    --  LPDWORD  lpExitCode // address to receive termination status
            C_BOOL) -- BOOL

--      xGetProcessTimes = define_c_func(kernel32,"GetProcessTimes",
--          {C_PTR,     --  HANDLE  hProcess,   // specifies the process of interest
--           C_PTR,     --  LPFILETIME  lpCreationTime, // when the process was created
--           C_PTR,     --  LPFILETIME  lpExitTime, // when the process exited
--           C_PTR,     --  LPFILETIME  lpKernelTime,   // time the process has spent in kernel mode
--           C_PTR},    --  LPFILETIME  lpUserTime  // time the process has spent in user mode
--          C_BOOL)     -- BOOL

--      user32 = open_dll("user32.dll")
--
--      xWaitForInputIdle = define_c_func(user32, "WaitForInputIdle",
--          {C_PTR,     --  HANDLE hObject, // handle of object to wait for
--           C_DWORD},  --  DWORD   dwTimeout // time-out interval in milliseconds
--          C_DWORD)    -- DWORD -- 0, WAIT_TIMEOUT, or 0xFFFFFFFF

        shell32 = open_dll("shell32.dll")

        xShellExecute = define_c_func(shell32, "ShellExecuteA",
            {C_PTR,     --  HWND  hwnd, // handle to parent window
             C_PTR,     --  LPCTSTR  lpOperation,   // pointer to string that specifies operation to perform
             C_PTR,     --  LPCTSTR  lpFile,    // pointer to filename string
             C_PTR,     --  LPTSTR  lpParameters,   // pointer to string that specifies executable-file parameters
             C_PTR,     --  LPCTSTR  lpDirectory,   // pointer to string that specifies default directory
             C_INT},    --  INT  nShowCmd   // whether file is shown when opened
            C_PTR)  -- HINSTANCE

--      xGetStdHandle = define_c_func(kernel32,"GetStdHandle",
--          {C_DWORD},  --  DWORD  nStdHandle   // input, output, or error device
--          C_PTR)      -- HANDLE

        xCloseHandle = define_c_func(kernel32, "CloseHandle",
            {C_PTR},    --  HANDLE  hObject // handle of object to close
            C_BOOL)     -- BOOL

--      xGetLastError = define_c_func(kernel32, "GetLastError",
--          {},
--          C_DWORD)    -- DWORD

--#with reformat

--DEV allocate one block and split by hand? (si/pi/ec as well)

--      lpCreationTime = allocate(8)
--      lpExitTime = allocate(8)
--      lpKernelTime = allocate(8)
--      lpUserTime = allocate(8)

--/*
        xOpen = allocate(5)
        poke(xOpen,"open"&0)
--*/
    end if
    leave_cs()

    swinit = 1
end procedure

--integer suinit suinit = 0
--atom user32,xChangeDisplaySettings,xBeep

--procedure initsu()
----DEV locking as per pprntf
--  user32 = open_dll("user32.dll")
--
----#without reformat
--
--  xChangeDisplaySettings = define_c_func(user32, "xChangeDisplaySettingsW",
--      {C_PTR,     --  DEVMODE *lpDevMode, // NULL for default
--       C_DWORD},  --  DWORD   dwFlags,    // 0 for default
--      C_LONG)     -- LONG
--
--  xBeep = define_c_func(kernel32, "Beep",
--      {C_DWORD,   --  DWORD dwFreq
--       C_DWORD},  --  DWORD dwDuration
--      C_BOOL)     -- BOOL
--
----#with reformat
--
--  suinit = 1
--end procedure

integer Wait    -- for system()
        Wait = 1

--atom kutime
--
--global function get_ku_time()
---- valid only after a system_wait call.
--  return kutime
--end function

integer doevents
        doevents = -1
object doeventparams

global procedure set_system_doevents(integer rid, object params)
-- typical setup for win32lib/arwen:
--  set_system_doevents(routine_id("doEvents"),{0})
    doevents = rid
    doeventparams = params
end procedure

procedure cdc(object pipe_pair, integer c, d, n)
-- linux only (close/dup/close local helper)
    if sequence(pipe_pair) then
        c = pipe_pair[c]
        d = pipe_pair[d]
        #ilASM{
            [ELF32]
                mov eax,[c]
                push eax
                call "libc.so.6","close"
                add esp,4
                mov eax,[d]
                mov ecx,[n]
                push ecx
                push eax
                call "libc.so.6","dup2"
                add esp,8
                mov eax,[d]
                push eax
                call "libc.so.6","close"
                add esp,4
            [ELF64]
                mov rdi,[c]
                call "libc.so.6","close"
                mov rdi,[d]
                mov rsi,[n]
                call "libc.so.6","dup2"
                mov rdi,[d]
                call "libc.so.6","close"
            []
              }
    end if
end procedure

global function system_wait(sequence child_process, pipes={})
-- after:
-- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/creating_processes.asp
-- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/createprocess.asp
-- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/waitforsingleobject.asp
-- or, if you have win32.hlp configured, lookup (press F1 key on):
--  xCreateProcess, xGetExitCodeProcess, xWaitForSingleObject

atom ret, void, hProc
--atom stdin, stdout, stderr
, hThr
--integer doevents
atom si, pi, pError
atom child = allocate_string(child_process)
    if platform()=WINDOWS then
        if not swinit then initsw() end if
        si = allocate(SIZEOF_STARTUPINFO)
        mem_set(si,0,SIZEOF_STARTUPINFO)
        poke4(si, SIZEOF_STARTUPINFO)       -- cb
--      poke4(si+dwFlags,or_bits(STARTF_USESTDHANDLES,STARTF_USESHOWWINDOW))
--      bool inherit = (Wait<=0) and (length(pipes)>0)
        bool inherit = length(pipes)>0
        if inherit then
            if length(pipes)>=PIPEIN and sequence(pipes[PIPEIN]) then
                pokeN(si+hStdInput,pipes[PIPEIN][READ_PIPE],W)
            end if
            if length(pipes)>=PIPOUT and sequence(pipes[PIPOUT]) then
                pokeN(si+hStdOutput,pipes[PIPOUT][WRITE_PIPE],W)
            end if
            if length(pipes)>=PIPERR and sequence(pipes[PIPERR]) then
                pokeN(si+hStdError,pipes[PIPERR][WRITE_PIPE],W)
            end if
            poke4(si+dwFlags,STARTF_USESTDHANDLES)
        end if

        pi = allocate(SIZEOF_PROCESS_INFORMATION)
        mem_set(pi,0,SIZEOF_PROCESS_INFORMATION)

--DEV clutching at straws here...
--      mem_set(si,0,SIZEOF_STARTUPINFO)
--      poke4(si, SIZEOF_STARTUPINFO)       -- cb
--      mem_set(pi,0,SIZEOF_PROCESS_INFORMATION)

--5/3/10:
--         pCmdLine = allocate_string(CommandLine)
--         pPI = allocate(PROCESS_INFORMATION_SIZE)
--         mem_set(pPI,0,PROCESS_INFORMATION_SIZE)
--         pSUI = allocate(STARTUPINFO_SIZE)
--         mem_set(pSUI,0,STARTUPINFO_SIZE)
--         poke4(pSUI,STARTUPINFO_SIZE)
--         poke4(pSUI+SUIdwFlags,or_bits(STARTF_USESTDHANDLES,STARTF_USESHOWWINDOW))
--         poke4(pSUI+SUIhStdInput,StdHandles)
--         fnVal = c_func(iCreateProcess,{0,pCmdLine,0,0,1,0,0,0,pSUI,pPI})

--if 0 then
--  stdin = c_func(xGetStdHandle,{STD_INPUT_HANDLE})
--  stdout = c_func(xGetStdHandle,{STD_OUTPUT_HANDLE})
--  stderr = c_func(xGetStdHandle,{STD_ERROR_HANDLE})
--  poke4(si+hStdInput,stdin)
--  poke4(si+hStdOutput,stdout)
--  poke4(si+hStdError,stderr)
--end if

        -- Start the child process.
        ret = c_func(xCreateProcess,
                     {NULL,     -- No module name (use command line).
                      child,    -- Command line.
                      NULL,     -- Process handle not inheritable.
--instance(),
                      NULL,     -- Thread handle not inheritable.
--                    FALSE,    -- Set handle inheritance to FALSE.
                      inherit,  -- Set handle inheritance to FALSE.
--1,--TRUE,
--                    PROCESS_QUERY_INFORMATION,        -- No creation flags.
                      NULL,
--#10,
--#4000208,
--#8000210,
--Public Enum ProcessCreationFlags
--   DEBUG_PROCESS            = &H1
--   DEBUG_ONLY_THIS_PROCESS      = &H2
--   CREATE_SUSPENDED         = &H4
--   DETACHED_PROCESS         = &H8
--   CREATE_NEW_CONSOLE       = &H10
--   NORMAL_PRIORITY_CLASS    = &H20
--   IDLE_PRIORITY_CLASS          = &H40
--   HIGH_PRIORITY_CLASS          = &H80
--   REALTIME_PRIORITY_CLASS      = &H100
--   CREATE_NEW_PROCESS_GROUP   = &H200
--   CREATE_UNICODE_ENVIRONMENT = &H400
--   CREATE_SEPARATE_WOW_VDM      = &H800
--   CREATE_SHARED_WOW_VDM    = &H1000
--   CREATE_FORCEDOS              = &H2000
--   CREATE_DEFAULT_ERROR_MODE  = &H4000000
--   CREATE_NO_WINDOW         = &H8000000

                      NULL,     -- Use parent's environment block.
                      NULL,     -- Use parent's starting directory.
                      si,       -- Pointer to STARTUPINFO structure.
                      pi})      -- Pointer to PROCESS_INFORMATION structure.
        if ret=0 then
--          kutime = c_func(xGetLastError,{})
            free(si)
            free(pi)
            free(child)
            return -1       -- error
        end if
--printf(1,"system_wait: ret is %d\n",ret)

        free(child)
        ret = 0

        hProc = peek4u(pi+hProcess)
        hThr  = peek4u(pi+hThread)

        -- Wait until child process exits, or up to 0.4s if Wait<=0.
        pError = allocate(4)
        while 1 do
            void = c_func(xGetExitCodeProcess, {hProc, pError})
            ret = peek4u(pError)
            if ret!=STILL_ACTIVE then exit end if
            if doevents!=-1 then call_proc(doevents,doeventparams) end if
            void = c_func(xWaitForSingleObject, {hProc, FORTYMS})
            if Wait<0 then Wait += 1 end if
            if Wait=0 then exit end if
        end while
        free(pError)
        free(si)
        free(pi)

        -- Close process and thread handles.
        if Wait<=0 then 
            ret = hProc
        else
            void = c_func(xCloseHandle, {hProc})
        end if
        void = c_func(xCloseHandle, {hThr})

    elsif platform()=LINUX then

        if Wait<=0 then
            #ilASM{
                [ELF32]
                    call "libc.so.6","fork"
                    lea edi,[ret]
                    call :%pStoreMint
                [ELF64]
                    call "libc.so.6","fork"
                    lea rdi,[ret]
                    call :%pStoreMint
                []
                  }
            if ret=0 then
                -- child
                if length(pipes) then
                    if length(pipes)>=PIPEIN then cdc(pipes[PIPEIN],WRITE_PIPE,READ_PIPE,0) end if
                    if length(pipes)>=PIPOUT then cdc(pipes[PIPOUT],READ_PIPE,WRITE_PIPE,1) end if
                    if length(pipes)>=PIPERR then cdc(pipes[PIPERR],READ_PIPE,WRITE_PIPE,2) end if
                end if
                #ilASM{
                    [ELF32]
                        mov eax,[child]
--                      shl eax,2
                        push eax
                        call "libc.so.6","system"
                        add esp,4
                        mov ebx,eax 
                        mov eax,1                   -- sys_exit
                        int 0x80 
                    [ELF64]
                        mov rdi,[child]
--                      shl rdi,2
                        call "libc.so.6","system"
                        mov rdi,rax
                        mov rax,60                  -- sys_exit
                        syscall
                    []
                      }
            end if
--          ret = 0     -- (GAH! must fix that compiler bug)
            sleep(0.4)  -- give libc:system a chance to get going (before we free(child))
        else
            #ilASM{
                [ELF32]
                    mov eax,[child]
--                  shl eax,2
                    push eax
                    call "libc.so.6","system"
                    add esp,4
                    lea edi,[ret]
                    call :%pStoreMint
                [ELF64]
                    mov rdi,[child]
--                  shl rdi,2
                    call "libc.so.6","system"
                    lea rdi,[ret]
                    call :%pStoreMint
                []
                  }
        end if
--  char *const argv[] = {
--      "sh",
--      "-c", "ls | wc",  // Command to execute.
--      NULL
--  };
--
--  execvp(argv[0], argv)

--DEV:
        --
        --  split child_process into filename and param array (argv4) here, in hll...
        --  also do the same with env4
        -- (maybe, see http://littlesvr.ca/grumble/2011/01/20/createprocess-for-linux/ )
        --
--      ?9/0
--/*

sequence semi-perm      -- (not thread safe)
-- (locals)
sequence args           -- (semi-permanent)
integer pArg4=0,        -- (semi-permanent)
        max_args=0      -- sizeof pArgs
string path             -- (semi-permanent)
        --
        -- Then parse it into chunks.
        --
        args = {}
        chfirst = 1
        chlast = length(child_process)
--trim? omit?
        while find(child_process[chlast]," \t") do
            chlast -= 1
        end while

        while chfirst<=chlast do
            if child_process[chfirst]='\"' then
                chfirst += 1
                for i=chfirst to chlast+1 do
                    if i>chlast then ?9/0 end if -- closing quote not found...
                    if child_process[i]='\"' then
                        tmp = child_process[chfirst..i-1]
                        args = append(args,tmp)
                        chfirst = i+1
                        exit
                    end if
                end for
            else
                tmp = {}
                for i=chfirst to chlast do
                    if i=chlast then
                        tmp = child_process[chfirst..chlast]
                    elsif find(child_process[i]," \t") then
                        tmp = child_process[chfirst..i-1]
                    end if
                    if length(tmp) then
                        args = append(args,tmp)
                        chfirst = i+1
                        exit
                    end if
                    if i=chlast then chlast = 9/0 end if
                end for
            end if
            while chfirst<=chlast and find(child_process[chfirst]," \t") do
                chfirst += 1
            end while
        end while
        if length(args)>=max_args then
            if pArg4!=0 then
                free(pArg4*4)
            end if
            max_args = length(args)+1
            pArg4 = floor(allocate(max_args*machine_word())/4)
        end if
        for i=1 to length(args) do
            path = args[1]
            #ilASM{
                [ELF32]
                    mov edi,[pArg4]
                    mov eax,[path]
                    mov ecx,[i]
                    shl eax,2           -- raw address
                    shl edi,2           -- ""(pArg4*4)
                    mov [edi+ecx*4],eax
                [ELF64]
                    mov rdi,[pArg4]
                    mov rax,[path]
                    mov rcx,[i]
                    shl rax,2           -- raw address
                    shl rdi,2           -- ""(pArg4*4)
                    mov [rdi+rcx*8],rax
                []
                  }
        end for
        pokeN(pArg4*4+length(args)*machine_word(),0,machine_word())
        path = args[1]

--integer pArg4
--      #ilASM{
--          [ELF32]
--              call :%opGetArgELF
--              mov [pArg4],eax
--          [ELF64]
--              call :%opGetArgELF
--              mov [pArg4],rax
--          []
--            }

--*/

--DEV (not yet done:)
        -- The following logic is used:
        --  if wait<=0 then
        --      sys_fork
        --      test eax,eax
        --      jnz :exit       -- parent resumes
        --      sys_fork
        --      jnz :wait0      -- sub-parent waits
        --      sys_execv
        --      sys_exit
        --    ::wait0
        --      sys_wait4
        --      sys_exit
        --    ::exit
        --  else
--DEV (for now it's just this:)
        --      sys_fork
        --      test eax,eax
        --      jnz :wait       -- parent waits
        --      sys_execv
        --      sys_exit
        --    ::wait
        --      sys_wait4
        --  end if
        --  ie in the no-wait case we create a dummy sub-process (wait0) whose only job is 
        --      to wait4 and terminate, thus preventing zombification of the child process.
        --
--or (I think I like this better):
        --      sys_fork
        --      test eax,eax
        --      jnz :wait
        --          if wait<=0 then
        --              -- sys_sigaction(SIGCHLD,SIG_IGN,0,SA_NOCLDSTOP,0):
        --              sub esp,16              -- sizeof(sigaction)
        --              mov dword[esp],1        -- SIG_IGN
        --              mov dword[esp+4],ebx    -- mask(0)
        --              mov dword[esp+8],1      -- SA_NOCLDSTOP
        --              mov dword[esp+12],ebx   -- restorer(0)
        --              mov eax,67              -- sys_sigaction
        --              mov ebx,17              -- SIGCHLD
        --              mov ecx,esp             -- sigact struct
        --              xor edx,edx             -- oact not rqd
        --              int 0x80
        --              add esp,16
        --          end if
        --          sys_execv
        --          sys_exit
        --    ::wait
        --      if wait>0 then
        --          sys_wait4
        --      end if
        --
--/*
        #ilASM{
            [ELF32]
--#     Name                        Registers                                                                                                               Definition
--                                  eax     ebx                     ecx                     edx                     esi                     edi
--2     sys_fork                    0x02    struct pt_regs *        -                       -                       -                       -               arch/alpha/kernel/entry.S:716
--190   sys_vfork                   0xbe    struct pt_regs *        -                       -                       -                       -                       arch/alpha/kernel/entry.S:746
--11    sys_execve                  0x0b    char *                  char **                 char **                 struct pt_regs *        -               arch/alpha/kernel/entry.S:925
--284   sys_waitid                  0x11c   int which               pid_t pid               struct siginfo *infop   int options             struct rusage *ru                       kernel/exit.c:1655
--114   sys_wait4                   0x72    pid_t pid               int *stat_addr          int options             struct rusage *ru       -                       kernel/exit.c:1726
--120   sys_clone                   0x78    unsigned long           unsigned long           unsigned long           unsigned long           struct pt_regs *        arch/alpha/kernel/entry.S:733
--1     sys_exit                    0x01    int error_code          -                       -                       -                       -               kernel/exit.c:1046
--67    sys_sigaction               0x43    int sig                 const struct old_sigaction *act struct old_sigaction *oact  -           -               arch/mips/kernel/signal.c:300

                mov eax,2               -- sys_fork
                int 0x80 
                -- check if child or parent 
                test eax, eax 
                jnz :parent_wait
                    -- child process 
--DEV assume no parameters for now
                    mov eax,11          -- sys_execve
--                  mov ebx,[filename]
                    mov ebx,[child_process]
--                  mov ecx,[argv4]
                    xor ecx,ecx
                    shl ebx,2           -- raw ptr
                    shl ecx,2           -- raw ptr
                    xor edx,edx 
                    int 0x80
...
                call "libc.so.6","fork"
                test eax,eax
                jnz :parent_wait
                    test [wait],0
                    jg @f
--or fork/terminate?:
                        sub esp,16              -- sizeof(sigaction)
                        mov dword[esp],1        -- SIG_IGN
                        mov dword[esp+4],ebx    -- mask(0)
                        mov dword[esp+8],1      -- SA_NOCLDSTOP
                        mov dword[esp+12],ebx   -- restorer(0)
                        mov esi,esp
                        push esi                -- oldact
                        push esi                -- act
                        push 17                 -- signum (SIGCHLD)
                        call "libc.so.6","sigaction"
                        add esp,16+12
                  @@:
                    mov eax,[pArg4]
                    mov esi,[path]
                    shl eax,2                   -- pArg4*4(->addr)
                    shl esi,2                   -- raw string ptr
                    push eax                    -- argv[]
                    push esi                    -- path
                    call "libc.so.6","execv"
                    add esp,8
--DEV..
--                  call "libc.so.6","exit"
                    mov ebx,eax 
                    mov eax,1                   -- sys_exit
                    int 0x80 

              ::fork_error
                    int3
              ::parent_wait
                js :fork_error
                test [wait],0
                jle @f
                    sub esp,128             -- reserve space for siginfo
                    mov esi,esp
                    mov dword[esi+12],ebx   -- si_pid:=0
                    push 4                  -- options (WEXITED)
                    push esi                -- infop
                    push eax                -- id
                    push 1                  -- idtype (P_ID)
                    call "libc.so.6","waitid"
                    mov eax,[esi+20]        -- si_status
                    cmp dword[esi+12],ebx
                    je :m1res
                    cmp dword[esp+8],1      -- si_code=CLD_EXITED?
                    je @f
                      ::m1res
                        mov eax,-1
                 @@:
                    add esp,128+16
                    lea edi,[ret]
                    call :%pStoreMint
                    jmp :done
              @@:
                    -- give the execv a chance to get going
--DEV (see pSleep.e)
--                  nanosleep(0.4)
                    mov [ret],ebx
              ::done

 -- typedef struct siginfo {
 --         int si_signo;
 --         int si_errno;
 --         int si_code;
 -- 
 --         union {
 --                 int _pad[SI_PAD_SIZE];
 --                 /* SIGCHLD */
 --                 struct {
 --                         __kernel_pid_t _pid;    /* which child */
 --                         __ARCH_SI_UID_T _uid;   /* sender's uid */
 --                         int _status;            /* exit code */
 --                         __ARCH_SI_CLOCK_T _utime;
 --                         __ARCH_SI_CLOCK_T _stime;
 --                 } _sigchld;

--!*!/
                    -- execve returns only if any error occured, 
                    -- so here we exit child process, with an
                    -- error code (-1) that should be collected
                    -- by the following sys_wait4. 
                    mov ebx,eax 
                    mov eax,1           -- sys_exit
                    int 0x80 
              ::parent_wait
                sub esp,4
                mov ebx,eax             -- pid
                mov ecx,esp             -- exit_status
                mov edx,2               -- WUNTRACED 
                xor esi,esi             -- rusage unused
                mov eax,114             -- sys_wait4
                int 0x80 
--probably wants masking/shifting:  (eg #FE00 = 65024)
                xor ebx,ebx
                pop eax
--              shr eax,8       --???
--              mov [ret],eax
                lea edi,[ret]
                call :%pStoreMint
--maybe:
--              mov eax,[ONE32TH]
--              call :%opSleep
            [ELF64]
--%rax  System call             %rdi                    %rsi                            %rdx                    %rcx                    %r8                     %r9
--57    sys_fork
--58    sys_vfork
--59    sys_execve              const char *filename    const char *const argv[]        const char *const envp[]
--247   sys_waitid              int which               pid_t upid                      struct siginfo *infop       int options             struct rusage *ru
--61    sys_wait4               pid_t upid              int *stat_addr                  int options             struct rusage *ru
--56    sys_clone               unsigned long clone_flags   unsigned long newsp         void *parent_tid        void *child_tid
--60    sys_exit                int error_code
--13    sys_rt_sigaction        int sig                 const struct sigaction *act     struct sigaction *oact  size_t sigsetsize

                pop al
            []
              }
--*/
    else
        ?9/0
    end if

    return ret
end function
------------------------------------------------------------------------

--procedure restore(integer mode)
--  if not suinit then initsu() end if
--  if mode=1 then
--      if c_func(xBeep,{750,300}) then
--          if getc(0) then end if
--      end if
--  end if
--  if c_func(xChangeDisplaySettings,{NULL,0}) then end if
--end procedure

global function system_exec(sequence s, integer mode=2, sequence pipes={})
atom res -- exit code or -1 on failure
if platform()=WINDOWS then
--  if and_bits(mode,4) then            -- "new shell" bit is set
    if and_bits(mode,4)                 -- "new shell" bit is set
    or length(pipes) then               -- (rqd. for redirection)
        s = getenv("COMSPEC")&" /C "&s
    end if
end if
    if and_bits(mode,8) then            -- "no wait" bit is set
        Wait = -10                      -- Max 10 iterations (0.4s)
    end if
    res = system_wait(s,pipes)
--  if mode!=2 then restore(mode) end if
    Wait = 1
    return res
end function

global procedure system(sequence s, integer mode=2)
--global procedure system(sequence s, integer mode=2, sequence pipes={})
--
-- Invoke the specified shell command.
-- Uses %COMSPEC% /C, which means it has the same features (redirection, wildcards, etc) 
--  and is subject to the same limitations (eg it was 126 chars on Win98, but has grown 
--  to 8000 chars on Win7) as manually using an MS-DOS console window.
-- NOTE: Specifying a windows GUI app appears to hang the console, typically what has 
--  actually happened is that the shell has finished, but remains visible and unresponsive 
--  until the app terminates. In such cases, try using {} = system_exec(s,8) instead. 
-- NOTE2: mode is a legacy feature and now completely ignored.
--
--integer r
--  Wait = -10                          -- Max 10 iterations (0.4s)
--  s = getenv("COMSPEC")&" /C "&s
--  r = system_wait(s)
--  Wait = 1
--  if mode!=2 then restore(mode) end if
    if mode then end if
    {} = system_exec(s,12)
--  {} = system_exec(s,12,pipes)
end procedure

global procedure system_open(sequence filename)
    if platform()=WINDOWS then
        if not swinit then initsw() end if
        {} = c_func(xShellExecute,{0,"open",filename,0,0,SW_NORMAL})
    else
        system("xdg-open "&filename)
    end if
end procedure

--/*

It is important to note that setenv only modifies the environment of the current process, which will apply to any subsequently created child processes.
To put that into perspective, it is obvious that a statement such as
<!--eucode>
setenv("PATH",..)
</eucode-->
<pre>
</pre>
should <i><b>not</b></i> initiate system-wide disruption of all currently running processes. Neither should it upset the operation of its parent process.
A program such as
<!--eucode>
setenv("PHIXROOT","/home/pete/phix/")
</eucode-->
<pre>
</pre>
may appear to have no effect: what it actually does is start with a copy of the invoking environment, create a modified copy of that environment, and then
terminate and discard the modified environment. The statement will have effect on any subsequent calls to getenv in the same process, and on the initial 
environment of any child processes it subsequently creates. For more permanent changes to environment settings, you need to use batch files (using "source" 
rather than normal run on Linux), modify system files such as .profile or .bashrc or /etc/profile.d/<appname>.sh, or use operating system provided utilities 
such as Control Panel or regedit. Those methods will most likely have similar restrictions, such as only affecting the current terminal session, or requiring 
re-login or re-boot.

In fact, the Linux version of setenv does virtually nothing, except leave a table entry for subsequent calls to getenv and system_exec. The Windows
version of setenv and getenv is more conventional, relying on the Windows API routines SetEnvironmentVar and GetEnvironmentVar - but the overall
effect is almost identical. A big difference would occur when using c_func/c_proc to invoke some third party code that relies on the environment 
settings but does not let you specify them, which I cannot imagine is possible at all on Linux

??
Note: These routines are not deemed thread-safe. Ideally all process spawning, in partcular system(st) and system_exec(st,<i>&lt;mode with bit 8 set&gt;</i>), 
which do not wait for a result, should be performed by a single thread. If you need multiple threads to spawn waited-for processes.... UGH!!

format elf executable 

mov eax,11      -- sys_execve
mov ebx,arg0 
mov ecx,args 
mov edx,0 
int 0x80 

mov eax,1 
int 0x80 

arg0: db '/bin/ls',0 
arg1: db '-l',0 
args: dd arg0,arg1,0 

;this program is designed to have the same effect 
;as entering "/bin/ls -l" at the terminal 


===================
format ELF executable 
entry $ 

        ;; create new process 
        mov     eax, __NR_vfork 
        int     0x80 
        ;; check if child or parent 
        test    eax, eax 
        jnz     parent_process 
        ;; child process 
        ;; start sleep application 
        mov     eax, __NR_execve 
        mov     ebx, arg0 
        mov     ecx, argv 
        xor     edx, edx 
        int     0x80 
        ;; execve returns only if any error occured, 
        ;; so here we exit child process 
        mov     ebx, eax 
        mov     eax, __NR_exit 
        int     0x80 

        ;; parent process 
parent_process: 
        ;; wait for child process to complete 
        mov     ebx, eax 
        mov     ecx, exit_status 
        mov     edx, WUNTRACED 
        xor     esi, esi 
        mov     eax, __NR_wait4 
        int     0x80 
        ;; print "Thread completed" message 
        mov     eax, __NR_write 
        mov     ebx, STDOUT_FILENO 
        mov     ecx, msg 
        mov     edx, msg_size 
        int     0x80 
        mov     eax, __NR_write 
        mov     ecx, status_ok 
        mov     edx, status_ok_size 
        ;; only the least 8 bits of the exit status 
        cmp     byte [exit_status + 1], 0 
        jz      ok 
        mov     ecx, status_fail 
        mov     edx, status_fail_size 
ok: 
        int     0x80 
        ;; exit 
        xor     ebx, ebx 
        mov     eax, __NR_exit 
        int     0x80 

msg: 
        db      "Thread completed! Exit status: " 
msg_size = $ - msg 

status_ok: 
        db      "Succeeded", 0xa 
status_ok_size = $ - status_ok 

status_fail: 
        db      "Failed", 0xa 
status_fail_size = $ - status_fail 

arg0: 
        db      "/usr/bin/sleep", 0 
;;         db      "/bin/true", 0 
;;         db      "/bin/false", 0 
arg1: 
        db      "1", 0 
argv: 
        dd      arg0, arg1, 0 

        segment readable writeable 
         
exit_status: 
        dd      -1

================

struc pt_regs 
{ 
    .ebx            dd 0
    .ecx            dd 0
    .edx            dd 0
    .esi            dd 0
    .edi            dd 0
    .ebp            dd 0
    .eax            dd 0
    .xds            dd 0
    .xes            dd 0
    .orig_eax       dd 0
    .eip            dd 0
    .xcs            dd 0
    .eflags         dd 0
    .esp            dd 0
    .xss            dd 0     
} 

sys_clone 
        test eax,eax 
        jnz .L0 
        ; child 
        pop rsi rdi 
        call rsi 
        sys_exit 0 
.L0:  ; parent 

=================================
.section .data
file_to_run:
.asciz       "/bin/sh"

.section .text
.globl main

main:
    sub esp,8       # array of two pointers. array[0] = file_to_run  array[1] = 0

    mov edi,file_to_run
    mov dword[esp-8],edi
    mov dword[esp-4],0

    mov eax, 11                     # sys_execve
    mov ebx, file_to_run             # file to execute       
    lea ecx, [ebp-8]                # command line parameters
    mov edx, 0                      # environment block
    int 0x80                

    ret

; syscalls kernel
SYS_EXECVE equ 0x0b
 
_start:
 
    ; execve("/bin//sh", 0, 0);
    push SYS_EXECVE ; SYS_EXECVE = 11
    pop eax         ; set SYS_EXECVE to eax
 
    xor esi, esi    ; clean esi
    push esi        ; esi is zero
    push 0x68732f2f ; push 'hs//'
    push 0x6e69622f ; push 'nib/'
 
    ; execve("/bin//sh/", 0, 0);
    ;             ^
    ;             |
    ;            ebx
    mov ebx, esp
 
    ; execve("/bin//sh/", 0, 0);
    ;                     ^
    ;                     |
    ;                    ecx
    xor ecx, ecx    ; clean ecx
 
    ; execve("/bin//sh/", 0, 0);
    ;                        ^
    ;                        |
    ;                       edx
    mov edx, ecx    ; set zero to edx
    int 0x80        ; syscall execve

DING: [PL] The penny just dropped: if we don't want a return value we could always just fork/(fork|wait|discard)/exec...
(For now, concentrate on waiting for a result)

DING2: if the parent fork/resumes,
        the child fork/terminates,
        the grandchild won't zombify because it's parent is child, so terminated->init->auto killed.

==

SIGCHLD is a signal your program receives if a child process gets terminated. It is ignored by default. 
Well, why don't we write ourself a little signal handler? A signal handler is a void function with a int as only argument:

void cleanup_child(int signal) {
    wait();
}
Now register your signal handler at the very beginning of your main function and your done:

int main(...){
    signal(SIGCHLD,cleanup_child);
    ...
Now all zombies get cleaned automatically. Please keep in mind that a signal interrupts your current program, calls the specific signal handler and resumes your program.
--*/
