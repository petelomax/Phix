;;
;; Phix dissassembly listing.  Generated at 14:56:02 on Fri 21/08/15.  (-d)
;;  (NB: Intended for human readership only; see plist.e for details)
;;
;C:\Program Files (x86)\Phix\test\FP\t02.exw:
;============================================
;     1 format PE64
    call #00442618 (:>initFEH)            ;#0043A000: 350 13860000               v  00 00  1   1      
    call #004428C8 (:>initStack)          ;#0043A005: 350 BE880000               v  00 00  1   2      
    call #0044131E (:>initFPU)            ;#0043A00A: 350 0F730000               v  00 00  1   3      
;     2 --
;     3 -- (from t02parms.exw)
;     4 --
;     5 -- test program: 48 check5(..) calls (you shouldn't need to know what check5 is).
;     6 -- One line shorter, remove first, last, or any in the middle, and it is fine.
;     7 
;     8 integer i1,j2,k3,l4,m5
;     9         i1=1 j2=2 k3=3 l4=4 m5=5
    mov qword[#00402E98] (i1),1           ;#0043A00F: 48:307005 7E8EFCFF 01000000 uv 00 00  1   4      
    mov qword[#00402EA0] (j2),2           ;#0043A01A: 48:307005 7B8EFCFF 02000000 vu 00 00  1   4      
    mov qword[#00402EA8] (k3),3           ;#0043A025: 48:307005 788EFCFF 03000000 uv 00 00  1   5      
    mov qword[#00402EB0] (l4),4           ;#0043A030: 48:307005 758EFCFF 04000000 vu 00 00  1   5      
    mov qword[#00402EB8] (m5),5           ;#0043A03B: 48:307005 728EFCFF 05000000 uv 00 00  1   6      
;    10 
;    11 function f1() return 1 end function
;    12 function f2() return 2 end function
;    13 function f3() return 3 end function
    mov rax,3                             ;#0043AFCF: 48:307300 03000000         uv 01 00  1   1      
    jmp #0044298D (:%opRetf)              ;#0043AFD6: 351 B2790000               v  00 00  1   1      
;    14 function f4() return 4 end function
    mov rax,4                             ;#0043AFDB: 48:307300 04000000         uv 01 00  1   1      
    jmp #0044298D (:%opRetf)              ;#0043AFE2: 351 A6790000               v  00 00  1   1      
;    15 function f5() return 5 end function
    mov rax,5                             ;#0043AFE7: 48:307300 05000000         uv 01 00  1   1      
    jmp #0044298D (:%opRetf)              ;#0043AFEE: 351 9A790000               v  00 00  1   1      
;    16 
;    17 procedure Abort(sequence msg) puts(1,msg) if getc(0) then end if abort(1) end procedure
    mov rax,1                             ;#0043AFF8: 48:307300 01000000         uv 01 00  1   1      
    mov rdx,[rbp] (msg)                   ;#0043AFFF: 48:213125 00               vu 04 20  1   1      
    call #0043E218 (:%opPuts)             ;#0043B003: 350 10320000               v  00 00  1   2      
    lea rdi,[rbp-8] (symtab[884])         ;#0043B008: 48:215175 F8               uv 80 20  1   3      
    xor rax,rax                           ;#0043B00C: 48:061300                  vu 01 01  1   3      
    call #0043DBDD (:%opGetc)             ;#0043B00F: 350 C92B0000               v  00 00  1   4      
    mov rax,1                             ;#0043B014: 48:307300 01000000         uv 01 00  1   5      
    call #00442B33 (:%opAbort)            ;#0043B01B: 350 137B0000               v  00 00  1   5      
    jmp #0044298D (:%opRetf)              ;#0043B020: 351 68790000               v  00 00  1   6      
;    18 
;    19 procedure check5(integer a1, integer b2, integer c3, integer d4, integer e5)
;    20     if a1!=1 then Abort("a1!=1\n") end if
;    21     if b2!=2 then Abort("b2!=2\n") end if
;    22     if c3!=3 then Abort("c3!=3\n") end if
;    23     if d4!=4 then Abort("d4!=4\n") end if
;    24     if e5!=5 then Abort("e5!=5\n") end if
    jmp #0044298D (:%opRetf)              ;#0043AFF3: 351 95790000               v  00 00  1   1      
;    25 end procedure
;    26 
;    27 check5(   1,   2,   3,   4,   5)
    mov rcx,5                             ;#0043A046: 48:307301 05000000         uv 02 00  1   1      
    mov rdx,886                           ;#0043A04D: 48:307302 76030000         vu 04 00  1   1      
    call #004428DB (:%opFrame) (check5)   ;#0043A054: 350 82880000               v  00 00  1   2      
    mov qword[rbp] (a1),1                 ;#0043A059: 48:307105 00 01000000      uv 00 20  1   3      
    mov qword[rbp-8] (b2),2               ;#0043A061: 48:307105 F8 02000000      vu 00 20  1   3      
    mov qword[rbp-16] (c3),3              ;#0043A069: 48:307105 F0 03000000      uv 00 20  1   4      
    mov qword[rbp-24] (d4),4              ;#0043A071: 48:307105 E8 04000000      vu 00 20  1   4      
    mov qword[rbp-32] (e5),5              ;#0043A079: 48:307105 E0 05000000      uv 00 20  1   5      
    mov qword[retaddr],#0043A08E          ;#0043A081: 48:307105 20 8EA04300      vu 00 20  1   5      
    jmp #0043AFF3 (code:check5)           ;#0043A089: 351 650F0000               v  00 00  1   6      
;    28 check5(   1,   2,   3,   4,  m5)
    mov rcx,5                             ;#0043A08E: 48:307301 05000000         uv 02 00  1   7      
    mov rdx,886                           ;#0043A095: 48:307302 76030000         vu 04 00  1   7      
    call #004428DB (:%opFrame) (check5)   ;#0043A09C: 350 3A880000               v  00 00  1   8      
    mov qword[rbp] (a1),1                 ;#0043A0A1: 48:307105 00 01000000      uv 00 20  1   9      
    mov qword[rbp-8] (b2),2               ;#0043A0A9: 48:307105 F8 02000000      vu 00 20  1   9      
    mov qword[rbp-16] (c3),3              ;#0043A0B1: 48:307105 F0 03000000      uv 00 20  1  10      
    mov qword[rbp-24] (d4),4              ;#0043A0B9: 48:307105 E8 04000000      vu 00 20  1  10      
    mov qword[rbp-32] (e5),5              ;#0043A0C1: 48:307105 E0 05000000      uv 00 20  1  11      
    mov qword[retaddr],#0043A0D6          ;#0043A0C9: 48:307105 20 D6A04300      vu 00 20  1  11      
    jmp #0043AFF3 (code:check5)           ;#0043A0D1: 351 1D0F0000               v  00 00  1  12      
;    29 check5(   1,   2,   3,   4,f5())
    mov qword[#00402F90],5                ;#0043A0D6: 48:307005 AF8EFCFF 05000000 uv 00 00  1  13      
    mov rcx,5                             ;#0043A0E1: 48:307301 05000000         vu 02 00  1  13      
    mov rdx,886                           ;#0043A0E8: 48:307302 76030000         uv 04 00  1  14      
    call #004428DB (:%opFrame) (check5)   ;#0043A0EF: 350 E7870000               v  00 00  1  14      
    mov qword[rbp] (a1),1                 ;#0043A0F4: 48:307105 00 01000000      uv 00 20  1  15      
    mov qword[rbp-8] (b2),2               ;#0043A0FC: 48:307105 F8 02000000      vu 00 20  1  15      
    mov qword[rbp-16] (c3),3              ;#0043A104: 48:307105 F0 03000000      uv 00 20  1  16      
    mov qword[rbp-24] (d4),4              ;#0043A10C: 48:307105 E8 04000000      vu 00 20  1  16      
    mov qword[rbp-32] (e5),5              ;#0043A114: 48:307105 E0 05000000      uv 00 20  1  17      
    mov qword[retaddr],#0043A129          ;#0043A11C: 48:307105 20 29A14300      vu 00 20  1  17      
    jmp #0043AFF3 (code:check5)           ;#0043A124: 351 CA0E0000               v  00 00  1  18      
;    30 
;    31 check5(   1,   2,   3,  l4,   5)
    mov rcx,5                             ;#0043A129: 48:307301 05000000         uv 02 00  1  19      
    mov rdx,886                           ;#0043A130: 48:307302 76030000         vu 04 00  1  19      
    call #004428DB (:%opFrame) (check5)   ;#0043A137: 350 9F870000               v  00 00  1  20      
    mov qword[rbp] (a1),1                 ;#0043A13C: 48:307105 00 01000000      uv 00 20  1  21      
    mov qword[rbp-8] (b2),2               ;#0043A144: 48:307105 F8 02000000      vu 00 20  1  21      
    mov qword[rbp-16] (c3),3              ;#0043A14C: 48:307105 F0 03000000      uv 00 20  1  22      
    mov qword[rbp-24] (d4),4              ;#0043A154: 48:307105 E8 04000000      vu 00 20  1  22      
    mov qword[rbp-32] (e5),5              ;#0043A15C: 48:307105 E0 05000000      uv 00 20  1  23      
    mov qword[retaddr],#0043A171          ;#0043A164: 48:307105 20 71A14300      vu 00 20  1  23      
    jmp #0043AFF3 (code:check5)           ;#0043A16C: 351 820E0000               v  00 00  1  24      
;    32 check5(   1,   2,   3,  l4,  m5)
    mov rcx,5                             ;#0043A171: 48:307301 05000000         uv 02 00  1  25      
    mov rdx,886                           ;#0043A178: 48:307302 76030000         vu 04 00  1  25      
    call #004428DB (:%opFrame) (check5)   ;#0043A17F: 350 57870000               v  00 00  1  26      
    mov qword[rbp] (a1),1                 ;#0043A184: 48:307105 00 01000000      uv 00 20  1  27      
    mov qword[rbp-8] (b2),2               ;#0043A18C: 48:307105 F8 02000000      vu 00 20  1  27      
    mov qword[rbp-16] (c3),3              ;#0043A194: 48:307105 F0 03000000      uv 00 20  1  28      
    mov qword[rbp-24] (d4),4              ;#0043A19C: 48:307105 E8 04000000      vu 00 20  1  28      
    mov qword[rbp-32] (e5),5              ;#0043A1A4: 48:307105 E0 05000000      uv 00 20  1  29      
    mov qword[retaddr],#0043A1B9          ;#0043A1AC: 48:307105 20 B9A14300      vu 00 20  1  29      
    jmp #0043AFF3 (code:check5)           ;#0043A1B4: 351 3A0E0000               v  00 00  1  30      
;    33 check5(   1,   2,   3,  l4,f5())
    mov rdi,905                           ;#0043A1B9: 48:307307 89030000         uv 80 00  1  31      
    call :%opCallOnce (pfileioN.e)        ;#0043A1C0: 350 7E870000               v  00 00  1  31      
    mov qword[#004031F8],5                ;#0043A1C5: 48:307005 2890FCFF 05000000 uv 00 00  1  32      
    mov rcx,5                             ;#0043A1D0: 48:307301 05000000         vu 02 00  1  32      
    mov rdx,886                           ;#0043A1D7: 48:307302 76030000         uv 04 00  1  33      
    call #004428DB (:%opFrame) (check5)   ;#0043A1DE: 350 F8860000               v  00 00  1  33      
    mov qword[rbp] (a1),1                 ;#0043A1E3: 48:307105 00 01000000      uv 00 20  1  34      
    mov qword[rbp-8] (b2),2               ;#0043A1EB: 48:307105 F8 02000000      vu 00 20  1  34      
    mov qword[rbp-16] (c3),3              ;#0043A1F3: 48:307105 F0 03000000      uv 00 20  1  35      
    mov qword[rbp-24] (d4),4              ;#0043A1FB: 48:307105 E8 04000000      vu 00 20  1  35      
    mov qword[rbp-32] (e5),5              ;#0043A203: 48:307105 E0 05000000      uv 00 20  1  36      
    mov qword[retaddr],#0043A218          ;#0043A20B: 48:307105 20 18A24300      vu 00 20  1  36      
    jmp #0043AFF3 (code:check5)           ;#0043A213: 351 DB0D0000               v  00 00  1  37      
;    34 
;    35 check5(   1,   2,   3,f4(),   5)
    mov qword[#00403200],4                ;#0043A218: 48:307005 DD8FFCFF 04000000 uv 00 00  1  38      
    mov rcx,5                             ;#0043A223: 48:307301 05000000         vu 02 00  1  38      
    mov rdx,886                           ;#0043A22A: 48:307302 76030000         uv 04 00  1  39      
    call #004428DB (:%opFrame) (check5)   ;#0043A231: 350 A5860000               v  00 00  1  39      
    mov qword[rbp] (a1),1                 ;#0043A236: 48:307105 00 01000000      uv 00 20  1  40      
    mov qword[rbp-8] (b2),2               ;#0043A23E: 48:307105 F8 02000000      vu 00 20  1  40      
    mov qword[rbp-16] (c3),3              ;#0043A246: 48:307105 F0 03000000      uv 00 20  1  41      
    mov qword[rbp-24] (d4),4              ;#0043A24E: 48:307105 E8 04000000      vu 00 20  1  41      
    mov qword[rbp-32] (e5),5              ;#0043A256: 48:307105 E0 05000000      uv 00 20  1  42      
    mov qword[retaddr],#0043A26B          ;#0043A25E: 48:307105 20 6BA24300      vu 00 20  1  42      
    jmp #0043AFF3 (code:check5)           ;#0043A266: 351 880D0000               v  00 00  1  43      
;    36 check5(   1,   2,   3,f4(),  m5)
    mov qword[#00403208],4                ;#0043A26B: 48:307005 928FFCFF 04000000 uv 00 00  1  44      
    mov rcx,5                             ;#0043A276: 48:307301 05000000         vu 02 00  1  44      
    mov rdx,886                           ;#0043A27D: 48:307302 76030000         uv 04 00  1  45      
    call #004428DB (:%opFrame) (check5)   ;#0043A284: 350 52860000               v  00 00  1  45      
    mov qword[rbp] (a1),1                 ;#0043A289: 48:307105 00 01000000      uv 00 20  1  46      
    mov qword[rbp-8] (b2),2               ;#0043A291: 48:307105 F8 02000000      vu 00 20  1  46      
    mov qword[rbp-16] (c3),3              ;#0043A299: 48:307105 F0 03000000      uv 00 20  1  47      
    mov qword[rbp-24] (d4),4              ;#0043A2A1: 48:307105 E8 04000000      vu 00 20  1  47      
    mov qword[rbp-32] (e5),5              ;#0043A2A9: 48:307105 E0 05000000      uv 00 20  1  48      
    mov qword[retaddr],#0043A2BE          ;#0043A2B1: 48:307105 20 BEA24300      vu 00 20  1  48      
    jmp #0043AFF3 (code:check5)           ;#0043A2B9: 351 350D0000               v  00 00  1  49      
;    37 check5(   1,   2,   3,f4(),f5())
    mov qword[#00403210],4                ;#0043A2BE: 48:307005 478FFCFF 04000000 uv 00 00  1  50      
    mov qword[#00403218],5                ;#0043A2C9: 48:307005 448FFCFF 05000000 vu 00 00  1  50      
    mov rcx,5                             ;#0043A2D4: 48:307301 05000000         uv 02 00  1  51      
    mov rdx,886                           ;#0043A2DB: 48:307302 76030000         vu 04 00  1  51      
    call #004428DB (:%opFrame) (check5)   ;#0043A2E2: 350 F4850000               v  00 00  1  52      
    mov qword[rbp] (a1),1                 ;#0043A2E7: 48:307105 00 01000000      uv 00 20  1  53      
    mov qword[rbp-8] (b2),2               ;#0043A2EF: 48:307105 F8 02000000      vu 00 20  1  53      
    mov qword[rbp-16] (c3),3              ;#0043A2F7: 48:307105 F0 03000000      uv 00 20  1  54      
    mov qword[rbp-24] (d4),4              ;#0043A2FF: 48:307105 E8 04000000      vu 00 20  1  54      
    mov qword[rbp-32] (e5),5              ;#0043A307: 48:307105 E0 05000000      uv 00 20  1  55      
    mov qword[retaddr],#0043A31C          ;#0043A30F: 48:307105 20 1CA34300      vu 00 20  1  55      
    jmp #0043AFF3 (code:check5)           ;#0043A317: 351 D70C0000               v  00 00  1  56      
;    38 
;    39 check5(   1,   2,  k3,   4,   5)
    mov rdi,1135                          ;#0043A31C: 48:307307 6F040000         uv 80 00  1  57      
    call :%opCallOnce (pcfuncN.e)         ;#0043A323: 350 1B860000               v  00 00  1  57      
    mov rcx,5                             ;#0043A328: 48:307301 05000000         uv 02 00  1  58      
    mov rdx,886                           ;#0043A32F: 48:307302 76030000         vu 04 00  1  58      
    call #004428DB (:%opFrame) (check5)   ;#0043A336: 350 A0850000               v  00 00  1  59      
    mov qword[rbp] (a1),1                 ;#0043A33B: 48:307105 00 01000000      uv 00 20  1  60      
    mov qword[rbp-8] (b2),2               ;#0043A343: 48:307105 F8 02000000      vu 00 20  1  60      
    mov qword[rbp-16] (c3),3              ;#0043A34B: 48:307105 F0 03000000      uv 00 20  1  61      
    mov qword[rbp-24] (d4),4              ;#0043A353: 48:307105 E8 04000000      vu 00 20  1  61      
    mov qword[rbp-32] (e5),5              ;#0043A35B: 48:307105 E0 05000000      uv 00 20  1  62      
    mov qword[retaddr],#0043A370          ;#0043A363: 48:307105 20 70A34300      vu 00 20  1  62      
    jmp #0043AFF3 (code:check5)           ;#0043A36B: 351 830C0000               v  00 00  1  63      
;    40 check5(   1,   2,  k3,   4,  m5)
    mov rcx,5                             ;#0043A370: 48:307301 05000000         uv 02 00  1  64      
    mov rdx,886                           ;#0043A377: 48:307302 76030000         vu 04 00  1  64      
    call #004428DB (:%opFrame) (check5)   ;#0043A37E: 350 58850000               v  00 00  1  65      
    mov qword[rbp] (a1),1                 ;#0043A383: 48:307105 00 01000000      uv 00 20  1  66      
    mov qword[rbp-8] (b2),2               ;#0043A38B: 48:307105 F8 02000000      vu 00 20  1  66      
    mov qword[rbp-16] (c3),3              ;#0043A393: 48:307105 F0 03000000      uv 00 20  1  67      
    mov qword[rbp-24] (d4),4              ;#0043A39B: 48:307105 E8 04000000      vu 00 20  1  67      
    mov qword[rbp-32] (e5),5              ;#0043A3A3: 48:307105 E0 05000000      uv 00 20  1  68      
    mov qword[retaddr],#0043A3B8          ;#0043A3AB: 48:307105 20 B8A34300      vu 00 20  1  68      
    jmp #0043AFF3 (code:check5)           ;#0043A3B3: 351 3B0C0000               v  00 00  1  69      
;    41 check5(   1,   2,  k3,   4,f5())
    mov qword[#00403388],5                ;#0043A3B8: 48:307005 C58FFCFF 05000000 uv 00 00  1  70      
    mov rcx,5                             ;#0043A3C3: 48:307301 05000000         vu 02 00  1  70      
    mov rdx,886                           ;#0043A3CA: 48:307302 76030000         uv 04 00  1  71      
    call #004428DB (:%opFrame) (check5)   ;#0043A3D1: 350 05850000               v  00 00  1  71      
    mov qword[rbp] (a1),1                 ;#0043A3D6: 48:307105 00 01000000      uv 00 20  1  72      
    mov qword[rbp-8] (b2),2               ;#0043A3DE: 48:307105 F8 02000000      vu 00 20  1  72      
    mov qword[rbp-16] (c3),3              ;#0043A3E6: 48:307105 F0 03000000      uv 00 20  1  73      
    mov qword[rbp-24] (d4),4              ;#0043A3EE: 48:307105 E8 04000000      vu 00 20  1  73      
    mov qword[rbp-32] (e5),5              ;#0043A3F6: 48:307105 E0 05000000      uv 00 20  1  74      
    mov qword[retaddr],#0043A40B          ;#0043A3FE: 48:307105 20 0BA44300      vu 00 20  1  74      
    jmp #0043AFF3 (code:check5)           ;#0043A406: 351 E80B0000               v  00 00  1  75      
;    42 
;    43 check5(   1,   2,  k3,  l4,   5)
    mov rcx,5                             ;#0043A40B: 48:307301 05000000         uv 02 00  1  76      
    mov rdx,886                           ;#0043A412: 48:307302 76030000         vu 04 00  1  76      
    call #004428DB (:%opFrame) (check5)   ;#0043A419: 350 BD840000               v  00 00  1  77      
    mov qword[rbp] (a1),1                 ;#0043A41E: 48:307105 00 01000000      uv 00 20  1  78      
    mov qword[rbp-8] (b2),2               ;#0043A426: 48:307105 F8 02000000      vu 00 20  1  78      
    mov qword[rbp-16] (c3),3              ;#0043A42E: 48:307105 F0 03000000      uv 00 20  1  79      
    mov qword[rbp-24] (d4),4              ;#0043A436: 48:307105 E8 04000000      vu 00 20  1  79      
    mov qword[rbp-32] (e5),5              ;#0043A43E: 48:307105 E0 05000000      uv 00 20  1  80      
    mov qword[retaddr],#0043A453          ;#0043A446: 48:307105 20 53A44300      vu 00 20  1  80      
    jmp #0043AFF3 (code:check5)           ;#0043A44E: 351 A00B0000               v  00 00  1  81      
;    44 check5(   1,   2,  k3,  l4,  m5)
    mov rcx,5                             ;#0043A453: 48:307301 05000000         uv 02 00  1  82      
    mov rdx,886                           ;#0043A45A: 48:307302 76030000         vu 04 00  1  82      
    call #004428DB (:%opFrame) (check5)   ;#0043A461: 350 75840000               v  00 00  1  83      
    mov qword[rbp] (a1),1                 ;#0043A466: 48:307105 00 01000000      uv 00 20  1  84      
    mov qword[rbp-8] (b2),2               ;#0043A46E: 48:307105 F8 02000000      vu 00 20  1  84      
    mov qword[rbp-16] (c3),3              ;#0043A476: 48:307105 F0 03000000      uv 00 20  1  85      
    mov qword[rbp-24] (d4),4              ;#0043A47E: 48:307105 E8 04000000      vu 00 20  1  85      
    mov qword[rbp-32] (e5),5              ;#0043A486: 48:307105 E0 05000000      uv 00 20  1  86      
    mov qword[retaddr],#0043A49B          ;#0043A48E: 48:307105 20 9BA44300      vu 00 20  1  86      
    jmp #0043AFF3 (code:check5)           ;#0043A496: 351 580B0000               v  00 00  1  87      
;    45 check5(   1,   2,  k3,  l4,f5())
    mov qword[#00403398],5                ;#0043A49B: 48:307005 F28EFCFF 05000000 uv 00 00  1  88      
    mov rcx,5                             ;#0043A4A6: 48:307301 05000000         vu 02 00  1  88      
    mov rdx,886                           ;#0043A4AD: 48:307302 76030000         uv 04 00  1  89      
    call #004428DB (:%opFrame) (check5)   ;#0043A4B4: 350 22840000               v  00 00  1  89      
    mov qword[rbp] (a1),1                 ;#0043A4B9: 48:307105 00 01000000      uv 00 20  1  90      
    mov qword[rbp-8] (b2),2               ;#0043A4C1: 48:307105 F8 02000000      vu 00 20  1  90      
    mov qword[rbp-16] (c3),3              ;#0043A4C9: 48:307105 F0 03000000      uv 00 20  1  91      
    mov qword[rbp-24] (d4),4              ;#0043A4D1: 48:307105 E8 04000000      vu 00 20  1  91      
    mov qword[rbp-32] (e5),5              ;#0043A4D9: 48:307105 E0 05000000      uv 00 20  1  92      
    mov qword[retaddr],#0043A4EE          ;#0043A4E1: 48:307105 20 EEA44300      vu 00 20  1  92      
    jmp #0043AFF3 (code:check5)           ;#0043A4E9: 351 050B0000               v  00 00  1  93      
;    46 
;    47 check5(   1,   2,  k3,f4(),   5)
    mov qword[#004033A0],4                ;#0043A4EE: 48:307005 A78EFCFF 04000000 uv 00 00  1  94      
    mov rcx,5                             ;#0043A4F9: 48:307301 05000000         vu 02 00  1  94      
    mov rdx,886                           ;#0043A500: 48:307302 76030000         uv 04 00  1  95      
    call #004428DB (:%opFrame) (check5)   ;#0043A507: 350 CF830000               v  00 00  1  95      
    mov qword[rbp] (a1),1                 ;#0043A50C: 48:307105 00 01000000      uv 00 20  1  96      
    mov qword[rbp-8] (b2),2               ;#0043A514: 48:307105 F8 02000000      vu 00 20  1  96      
    mov qword[rbp-16] (c3),3              ;#0043A51C: 48:307105 F0 03000000      uv 00 20  1  97      
    mov qword[rbp-24] (d4),4              ;#0043A524: 48:307105 E8 04000000      vu 00 20  1  97      
    mov qword[rbp-32] (e5),5              ;#0043A52C: 48:307105 E0 05000000      uv 00 20  1  98      
    mov qword[retaddr],#0043A541          ;#0043A534: 48:307105 20 41A54300      vu 00 20  1  98      
    jmp #0043AFF3 (code:check5)           ;#0043A53C: 351 B20A0000               v  00 00  1  99      
;    48 check5(   1,   2,  k3,f4(),  m5)
    mov qword[#004033A8],4                ;#0043A541: 48:307005 5C8EFCFF 04000000 uv 00 00  1 100      
    mov rcx,5                             ;#0043A54C: 48:307301 05000000         vu 02 00  1 100      
    mov rdx,886                           ;#0043A553: 48:307302 76030000         uv 04 00  1 101      
    call #004428DB (:%opFrame) (check5)   ;#0043A55A: 350 7C830000               v  00 00  1 101      
    mov qword[rbp] (a1),1                 ;#0043A55F: 48:307105 00 01000000      uv 00 20  1 102      
    mov qword[rbp-8] (b2),2               ;#0043A567: 48:307105 F8 02000000      vu 00 20  1 102      
    mov qword[rbp-16] (c3),3              ;#0043A56F: 48:307105 F0 03000000      uv 00 20  1 103      
    mov qword[rbp-24] (d4),4              ;#0043A577: 48:307105 E8 04000000      vu 00 20  1 103      
    mov qword[rbp-32] (e5),5              ;#0043A57F: 48:307105 E0 05000000      uv 00 20  1 104      
    mov qword[retaddr],#0043A594          ;#0043A587: 48:307105 20 94A54300      vu 00 20  1 104      
    jmp #0043AFF3 (code:check5)           ;#0043A58F: 351 5F0A0000               v  00 00  1 105      
;    49 check5(   1,   2,  k3,f4(),f5())
    mov qword[#004033B0],4                ;#0043A594: 48:307005 118EFCFF 04000000 uv 00 00  1 106      
    mov qword[#004033B8],5                ;#0043A59F: 48:307005 0E8EFCFF 05000000 vu 00 00  1 106      
    mov rcx,5                             ;#0043A5AA: 48:307301 05000000         uv 02 00  1 107      
    mov rdx,886                           ;#0043A5B1: 48:307302 76030000         vu 04 00  1 107      
    call #004428DB (:%opFrame) (check5)   ;#0043A5B8: 350 1E830000               v  00 00  1 108      
    mov qword[rbp] (a1),1                 ;#0043A5BD: 48:307105 00 01000000      uv 00 20  1 109      
    mov qword[rbp-8] (b2),2               ;#0043A5C5: 48:307105 F8 02000000      vu 00 20  1 109      
    mov qword[rbp-16] (c3),3              ;#0043A5CD: 48:307105 F0 03000000      uv 00 20  1 110      
    mov qword[rbp-24] (d4),4              ;#0043A5D5: 48:307105 E8 04000000      vu 00 20  1 110      
    mov qword[rbp-32] (e5),5              ;#0043A5DD: 48:307105 E0 05000000      uv 00 20  1 111      
    mov qword[retaddr],#0043A5F2          ;#0043A5E5: 48:307105 20 F2A54300      vu 00 20  1 111      
    jmp #0043AFF3 (code:check5)           ;#0043A5ED: 351 010A0000               v  00 00  1 112      
;    50 
;    51 check5(   1,   2,f3(),   4,   5)
    mov qword[#004033C0],3                ;#0043A5F2: 48:307005 C38DFCFF 03000000 uv 00 00  1 113      
    mov rcx,5                             ;#0043A5FD: 48:307301 05000000         vu 02 00  1 113      
    mov rdx,886                           ;#0043A604: 48:307302 76030000         uv 04 00  1 114      
    call #004428DB (:%opFrame) (check5)   ;#0043A60B: 350 CB820000               v  00 00  1 114      
    mov qword[rbp] (a1),1                 ;#0043A610: 48:307105 00 01000000      uv 00 20  1 115      
    mov qword[rbp-8] (b2),2               ;#0043A618: 48:307105 F8 02000000      vu 00 20  1 115      
    mov qword[rbp-16] (c3),3              ;#0043A620: 48:307105 F0 03000000      uv 00 20  1 116      
    mov qword[rbp-24] (d4),4              ;#0043A628: 48:307105 E8 04000000      vu 00 20  1 116      
    mov qword[rbp-32] (e5),5              ;#0043A630: 48:307105 E0 05000000      uv 00 20  1 117      
    mov qword[retaddr],#0043A645          ;#0043A638: 48:307105 20 45A64300      vu 00 20  1 117      
    jmp #0043AFF3 (code:check5)           ;#0043A640: 351 AE090000               v  00 00  1 118      
;    52 check5(   1,   2,f3(),   4,  m5)
    mov qword[#004033C8],3                ;#0043A645: 48:307005 788DFCFF 03000000 uv 00 00  1 119      
    mov rcx,5                             ;#0043A650: 48:307301 05000000         vu 02 00  1 119      
    mov rdx,886                           ;#0043A657: 48:307302 76030000         uv 04 00  1 120      
    call #004428DB (:%opFrame) (check5)   ;#0043A65E: 350 78820000               v  00 00  1 120      
    mov qword[rbp] (a1),1                 ;#0043A663: 48:307105 00 01000000      uv 00 20  1 121      
    mov qword[rbp-8] (b2),2               ;#0043A66B: 48:307105 F8 02000000      vu 00 20  1 121      
    mov qword[rbp-16] (c3),3              ;#0043A673: 48:307105 F0 03000000      uv 00 20  1 122      
    mov qword[rbp-24] (d4),4              ;#0043A67B: 48:307105 E8 04000000      vu 00 20  1 122      
    mov qword[rbp-32] (e5),5              ;#0043A683: 48:307105 E0 05000000      uv 00 20  1 123      
    mov qword[retaddr],#0043A698          ;#0043A68B: 48:307105 20 98A64300      vu 00 20  1 123      
    jmp #0043AFF3 (code:check5)           ;#0043A693: 351 5B090000               v  00 00  1 124      
;    53 check5(   1,   2,f3(),   4,f5())
    mov qword[#004033D0],3                ;#0043A698: 48:307005 2D8DFCFF 03000000 uv 00 00  1 125      
    mov qword[#004033D8],5                ;#0043A6A3: 48:307005 2A8DFCFF 05000000 vu 00 00  1 125      
    mov rcx,5                             ;#0043A6AE: 48:307301 05000000         uv 02 00  1 126      
    mov rdx,886                           ;#0043A6B5: 48:307302 76030000         vu 04 00  1 126      
    call #004428DB (:%opFrame) (check5)   ;#0043A6BC: 350 1A820000               v  00 00  1 127      
    mov qword[rbp] (a1),1                 ;#0043A6C1: 48:307105 00 01000000      uv 00 20  1 128      
    mov qword[rbp-8] (b2),2               ;#0043A6C9: 48:307105 F8 02000000      vu 00 20  1 128      
    mov qword[rbp-16] (c3),3              ;#0043A6D1: 48:307105 F0 03000000      uv 00 20  1 129      
    mov qword[rbp-24] (d4),4              ;#0043A6D9: 48:307105 E8 04000000      vu 00 20  1 129      
    mov qword[rbp-32] (e5),5              ;#0043A6E1: 48:307105 E0 05000000      uv 00 20  1 130      
    mov qword[retaddr],#0043A6F6          ;#0043A6E9: 48:307105 20 F6A64300      vu 00 20  1 130      
    jmp #0043AFF3 (code:check5)           ;#0043A6F1: 351 FD080000               v  00 00  1 131      
;    54 
;    55 check5(   1,   2,f3(),  l4,   5)
    mov qword[#004033E0],3                ;#0043A6F6: 48:307005 DF8CFCFF 03000000 uv 00 00  1 132      
    mov rcx,5                             ;#0043A701: 48:307301 05000000         vu 02 00  1 132      
    mov rdx,886                           ;#0043A708: 48:307302 76030000         uv 04 00  1 133      
    call #004428DB (:%opFrame) (check5)   ;#0043A70F: 350 C7810000               v  00 00  1 133      
    mov qword[rbp] (a1),1                 ;#0043A714: 48:307105 00 01000000      uv 00 20  1 134      
    mov qword[rbp-8] (b2),2               ;#0043A71C: 48:307105 F8 02000000      vu 00 20  1 134      
    mov qword[rbp-16] (c3),3              ;#0043A724: 48:307105 F0 03000000      uv 00 20  1 135      
    mov qword[rbp-24] (d4),4              ;#0043A72C: 48:307105 E8 04000000      vu 00 20  1 135      
    mov qword[rbp-32] (e5),5              ;#0043A734: 48:307105 E0 05000000      uv 00 20  1 136      
    mov qword[retaddr],#0043A749          ;#0043A73C: 48:307105 20 49A74300      vu 00 20  1 136      
    jmp #0043AFF3 (code:check5)           ;#0043A744: 351 AA080000               v  00 00  1 137      
;    56 check5(   1,   2,f3(),  l4,  m5)
    mov qword[#004033E8],3                ;#0043A749: 48:307005 948CFCFF 03000000 uv 00 00  1 138      
    mov rcx,5                             ;#0043A754: 48:307301 05000000         vu 02 00  1 138      
    mov rdx,886                           ;#0043A75B: 48:307302 76030000         uv 04 00  1 139      
    call #004428DB (:%opFrame) (check5)   ;#0043A762: 350 74810000               v  00 00  1 139      
    mov qword[rbp] (a1),1                 ;#0043A767: 48:307105 00 01000000      uv 00 20  1 140      
    mov qword[rbp-8] (b2),2               ;#0043A76F: 48:307105 F8 02000000      vu 00 20  1 140      
    mov qword[rbp-16] (c3),3              ;#0043A777: 48:307105 F0 03000000      uv 00 20  1 141      
    mov qword[rbp-24] (d4),4              ;#0043A77F: 48:307105 E8 04000000      vu 00 20  1 141      
    mov qword[rbp-32] (e5),5              ;#0043A787: 48:307105 E0 05000000      uv 00 20  1 142      
    mov qword[retaddr],#0043A79C          ;#0043A78F: 48:307105 20 9CA74300      vu 00 20  1 142      
    jmp #0043AFF3 (code:check5)           ;#0043A797: 351 57080000               v  00 00  1 143      
;    57 check5(   1,   2,f3(),  l4,f5())
    mov qword[#004033F0],3                ;#0043A79C: 48:307005 498CFCFF 03000000 uv 00 00  1 144      
    mov qword[#004033F8],5                ;#0043A7A7: 48:307005 468CFCFF 05000000 vu 00 00  1 144      
    mov rcx,5                             ;#0043A7B2: 48:307301 05000000         uv 02 00  1 145      
    mov rdx,886                           ;#0043A7B9: 48:307302 76030000         vu 04 00  1 145      
    call #004428DB (:%opFrame) (check5)   ;#0043A7C0: 350 16810000               v  00 00  1 146      
    mov qword[rbp] (a1),1                 ;#0043A7C5: 48:307105 00 01000000      uv 00 20  1 147      
    mov qword[rbp-8] (b2),2               ;#0043A7CD: 48:307105 F8 02000000      vu 00 20  1 147      
    mov qword[rbp-16] (c3),3              ;#0043A7D5: 48:307105 F0 03000000      uv 00 20  1 148      
    mov qword[rbp-24] (d4),4              ;#0043A7DD: 48:307105 E8 04000000      vu 00 20  1 148      
    mov qword[rbp-32] (e5),5              ;#0043A7E5: 48:307105 E0 05000000      uv 00 20  1 149      
    mov qword[retaddr],#0043A7FA          ;#0043A7ED: 48:307105 20 FAA74300      vu 00 20  1 149      
    jmp #0043AFF3 (code:check5)           ;#0043A7F5: 351 F9070000               v  00 00  1 150      
;    58 
;    59 check5(   1,   2,f3(),f4(),   5)
    mov qword[#00403400],3                ;#0043A7FA: 48:307005 FB8BFCFF 03000000 uv 00 00  1 151      
    mov qword[#00403408],4                ;#0043A805: 48:307005 F88BFCFF 04000000 vu 00 00  1 151      
    mov rcx,5                             ;#0043A810: 48:307301 05000000         uv 02 00  1 152      
    mov rdx,886                           ;#0043A817: 48:307302 76030000         vu 04 00  1 152      
    call #004428DB (:%opFrame) (check5)   ;#0043A81E: 350 B8800000               v  00 00  1 153      
    mov qword[rbp] (a1),1                 ;#0043A823: 48:307105 00 01000000      uv 00 20  1 154      
    mov qword[rbp-8] (b2),2               ;#0043A82B: 48:307105 F8 02000000      vu 00 20  1 154      
    mov qword[rbp-16] (c3),3              ;#0043A833: 48:307105 F0 03000000      uv 00 20  1 155      
    mov qword[rbp-24] (d4),4              ;#0043A83B: 48:307105 E8 04000000      vu 00 20  1 155      
    mov qword[rbp-32] (e5),5              ;#0043A843: 48:307105 E0 05000000      uv 00 20  1 156      
    mov qword[retaddr],#0043A858          ;#0043A84B: 48:307105 20 58A84300      vu 00 20  1 156      
    jmp #0043AFF3 (code:check5)           ;#0043A853: 351 9B070000               v  00 00  1 157      
;    60 check5(   1,   2,f3(),f4(),  m5)
    mov qword[#00403410],3                ;#0043A858: 48:307005 AD8BFCFF 03000000 uv 00 00  1 158      
    mov qword[#00403418],4                ;#0043A863: 48:307005 AA8BFCFF 04000000 vu 00 00  1 158      
    mov rcx,5                             ;#0043A86E: 48:307301 05000000         uv 02 00  1 159      
    mov rdx,886                           ;#0043A875: 48:307302 76030000         vu 04 00  1 159      
    call #004428DB (:%opFrame) (check5)   ;#0043A87C: 350 5A800000               v  00 00  1 160      
    mov qword[rbp] (a1),1                 ;#0043A881: 48:307105 00 01000000      uv 00 20  1 161      
    mov qword[rbp-8] (b2),2               ;#0043A889: 48:307105 F8 02000000      vu 00 20  1 161      
    mov qword[rbp-16] (c3),3              ;#0043A891: 48:307105 F0 03000000      uv 00 20  1 162      
    mov qword[rbp-24] (d4),4              ;#0043A899: 48:307105 E8 04000000      vu 00 20  1 162      
    mov qword[rbp-32] (e5),5              ;#0043A8A1: 48:307105 E0 05000000      uv 00 20  1 163      
    mov qword[retaddr],#0043A8B6          ;#0043A8A9: 48:307105 20 B6A84300      vu 00 20  1 163      
    jmp #0043AFF3 (code:check5)           ;#0043A8B1: 351 3D070000               v  00 00  1 164      
;    61 check5(   1,   2,f3(),f4(),f5())
    mov qword[#00403420],3                ;#0043A8B6: 48:307005 5F8BFCFF 03000000 uv 00 00  1 165      
    mov qword[#00403428],4                ;#0043A8C1: 48:307005 5C8BFCFF 04000000 vu 00 00  1 165      
    mov qword[#00403430],5                ;#0043A8CC: 48:307005 598BFCFF 05000000 uv 00 00  1 166      
    mov rcx,5                             ;#0043A8D7: 48:307301 05000000         vu 02 00  1 166      
    mov rdx,886                           ;#0043A8DE: 48:307302 76030000         uv 04 00  1 167      
    call #004428DB (:%opFrame) (check5)   ;#0043A8E5: 350 F17F0000               v  00 00  1 167      
    mov qword[rbp] (a1),1                 ;#0043A8EA: 48:307105 00 01000000      uv 00 20  1 168      
    mov qword[rbp-8] (b2),2               ;#0043A8F2: 48:307105 F8 02000000      vu 00 20  1 168      
    mov qword[rbp-16] (c3),3              ;#0043A8FA: 48:307105 F0 03000000      uv 00 20  1 169      
    mov qword[rbp-24] (d4),4              ;#0043A902: 48:307105 E8 04000000      vu 00 20  1 169      
    mov qword[rbp-32] (e5),5              ;#0043A90A: 48:307105 E0 05000000      uv 00 20  1 170      
    mov qword[retaddr],#0043A91F          ;#0043A912: 48:307105 20 1FA94300      vu 00 20  1 170      
    jmp #0043AFF3 (code:check5)           ;#0043A91A: 351 D4060000               v  00 00  1 171      
;    62 puts(1,".")
    mov rax,1                             ;#0043A91F: 48:307300 01000000         uv 01 00  1 172      
    mov rdx,qword[#00403438]              ;#0043A926: 48:213025 0B8BFCFF         vu 04 00  1 172      
    call #0043E218 (:%opPuts)             ;#0043A92D: 350 E6380000               v  00 00  1 173      
;    63 check5(   1,  j2,   3,   4,   5)
    mov rcx,5                             ;#0043A932: 48:307301 05000000         uv 02 00  1 174      
    mov rdx,886                           ;#0043A939: 48:307302 76030000         vu 04 00  1 174      
    call #004428DB (:%opFrame) (check5)   ;#0043A940: 350 967F0000               v  00 00  1 175      
    mov qword[rbp] (a1),1                 ;#0043A945: 48:307105 00 01000000      uv 00 20  1 176      
    mov qword[rbp-8] (b2),2               ;#0043A94D: 48:307105 F8 02000000      vu 00 20  1 176      
    mov qword[rbp-16] (c3),3              ;#0043A955: 48:307105 F0 03000000      uv 00 20  1 177      
    mov qword[rbp-24] (d4),4              ;#0043A95D: 48:307105 E8 04000000      vu 00 20  1 177      
    mov qword[rbp-32] (e5),5              ;#0043A965: 48:307105 E0 05000000      uv 00 20  1 178      
    mov qword[retaddr],#0043A97A          ;#0043A96D: 48:307105 20 7AA94300      vu 00 20  1 178      
    jmp #0043AFF3 (code:check5)           ;#0043A975: 351 79060000               v  00 00  1 179      
;    64 check5(   1,  j2,   3,   4,  m5)
    mov rcx,5                             ;#0043A97A: 48:307301 05000000         uv 02 00  1 180      
    mov rdx,886                           ;#0043A981: 48:307302 76030000         vu 04 00  1 180      
    call #004428DB (:%opFrame) (check5)   ;#0043A988: 350 4E7F0000               v  00 00  1 181      
    mov qword[rbp] (a1),1                 ;#0043A98D: 48:307105 00 01000000      uv 00 20  1 182      
    mov qword[rbp-8] (b2),2               ;#0043A995: 48:307105 F8 02000000      vu 00 20  1 182      
    mov qword[rbp-16] (c3),3              ;#0043A99D: 48:307105 F0 03000000      uv 00 20  1 183      
    mov qword[rbp-24] (d4),4              ;#0043A9A5: 48:307105 E8 04000000      vu 00 20  1 183      
    mov qword[rbp-32] (e5),5              ;#0043A9AD: 48:307105 E0 05000000      uv 00 20  1 184      
    mov qword[retaddr],#0043A9C2          ;#0043A9B5: 48:307105 20 C2A94300      vu 00 20  1 184      
    jmp #0043AFF3 (code:check5)           ;#0043A9BD: 351 31060000               v  00 00  1 185      
;    65 check5(   1,  j2,   3,   4,f5())
    mov qword[#00403440],5                ;#0043A9C2: 48:307005 738AFCFF 05000000 uv 00 00  1 186      
    mov rcx,5                             ;#0043A9CD: 48:307301 05000000         vu 02 00  1 186      
    mov rdx,886                           ;#0043A9D4: 48:307302 76030000         uv 04 00  1 187      
    call #004428DB (:%opFrame) (check5)   ;#0043A9DB: 350 FB7E0000               v  00 00  1 187      
    mov qword[rbp] (a1),1                 ;#0043A9E0: 48:307105 00 01000000      uv 00 20  1 188      
    mov qword[rbp-8] (b2),2               ;#0043A9E8: 48:307105 F8 02000000      vu 00 20  1 188      
    mov qword[rbp-16] (c3),3              ;#0043A9F0: 48:307105 F0 03000000      uv 00 20  1 189      
    mov qword[rbp-24] (d4),4              ;#0043A9F8: 48:307105 E8 04000000      vu 00 20  1 189      
    mov qword[rbp-32] (e5),5              ;#0043AA00: 48:307105 E0 05000000      uv 00 20  1 190      
    mov qword[retaddr],#0043AA15          ;#0043AA08: 48:307105 20 15AA4300      vu 00 20  1 190      
    jmp #0043AFF3 (code:check5)           ;#0043AA10: 351 DE050000               v  00 00  1 191      
;    66 --30
;    67 check5(   1,  j2,   3,  l4,   5)
    mov rcx,5                             ;#0043AA15: 48:307301 05000000         uv 02 00  1 192      
    mov rdx,886                           ;#0043AA1C: 48:307302 76030000         vu 04 00  1 192      
    call #004428DB (:%opFrame) (check5)   ;#0043AA23: 350 B37E0000               v  00 00  1 193      
    mov qword[rbp] (a1),1                 ;#0043AA28: 48:307105 00 01000000      uv 00 20  1 194      
    mov qword[rbp-8] (b2),2               ;#0043AA30: 48:307105 F8 02000000      vu 00 20  1 194      
    mov qword[rbp-16] (c3),3              ;#0043AA38: 48:307105 F0 03000000      uv 00 20  1 195      
    mov qword[rbp-24] (d4),4              ;#0043AA40: 48:307105 E8 04000000      vu 00 20  1 195      
    mov qword[rbp-32] (e5),5              ;#0043AA48: 48:307105 E0 05000000      uv 00 20  1 196      
    mov qword[retaddr],#0043AA5D          ;#0043AA50: 48:307105 20 5DAA4300      vu 00 20  1 196      
    jmp #0043AFF3 (code:check5)           ;#0043AA58: 351 96050000               v  00 00  1 197      
;    68 check5(   1,  j2,   3,  l4,  m5)
    mov rcx,5                             ;#0043AA5D: 48:307301 05000000         uv 02 00  1 198      
    mov rdx,886                           ;#0043AA64: 48:307302 76030000         vu 04 00  1 198      
    call #004428DB (:%opFrame) (check5)   ;#0043AA6B: 350 6B7E0000               v  00 00  1 199      
    mov qword[rbp] (a1),1                 ;#0043AA70: 48:307105 00 01000000      uv 00 20  1 200      
    mov qword[rbp-8] (b2),2               ;#0043AA78: 48:307105 F8 02000000      vu 00 20  1 200      
    mov qword[rbp-16] (c3),3              ;#0043AA80: 48:307105 F0 03000000      uv 00 20  1 201      
    mov qword[rbp-24] (d4),4              ;#0043AA88: 48:307105 E8 04000000      vu 00 20  1 201      
    mov qword[rbp-32] (e5),5              ;#0043AA90: 48:307105 E0 05000000      uv 00 20  1 202      
    mov qword[retaddr],#0043AAA5          ;#0043AA98: 48:307105 20 A5AA4300      vu 00 20  1 202      
    jmp #0043AFF3 (code:check5)           ;#0043AAA0: 351 4E050000               v  00 00  1 203      
;    69 check5(   1,  j2,   3,  l4,f5())
    mov qword[#00403448],5                ;#0043AAA5: 48:307005 9889FCFF 05000000 uv 00 00  1 204      
    mov rcx,5                             ;#0043AAB0: 48:307301 05000000         vu 02 00  1 204      
    mov rdx,886                           ;#0043AAB7: 48:307302 76030000         uv 04 00  1 205      
    call #004428DB (:%opFrame) (check5)   ;#0043AABE: 350 187E0000               v  00 00  1 205      
    mov qword[rbp] (a1),1                 ;#0043AAC3: 48:307105 00 01000000      uv 00 20  1 206      
    mov qword[rbp-8] (b2),2               ;#0043AACB: 48:307105 F8 02000000      vu 00 20  1 206      
    mov qword[rbp-16] (c3),3              ;#0043AAD3: 48:307105 F0 03000000      uv 00 20  1 207      
    mov qword[rbp-24] (d4),4              ;#0043AADB: 48:307105 E8 04000000      vu 00 20  1 207      
    mov qword[rbp-32] (e5),5              ;#0043AAE3: 48:307105 E0 05000000      uv 00 20  1 208      
    mov qword[retaddr],#0043AAF8          ;#0043AAEB: 48:307105 20 F8AA4300      vu 00 20  1 208      
    jmp #0043AFF3 (code:check5)           ;#0043AAF3: 351 FB040000               v  00 00  1 209      
;    70 
;    71 check5(   1,  j2,   3,f4(),   5)
    mov qword[#00403450],4                ;#0043AAF8: 48:307005 4D89FCFF 04000000 uv 00 00  1 210      
    mov rcx,5                             ;#0043AB03: 48:307301 05000000         vu 02 00  1 210      
    mov rdx,886                           ;#0043AB0A: 48:307302 76030000         uv 04 00  1 211      
    call #004428DB (:%opFrame) (check5)   ;#0043AB11: 350 C57D0000               v  00 00  1 211      
    mov qword[rbp] (a1),1                 ;#0043AB16: 48:307105 00 01000000      uv 00 20  1 212      
    mov qword[rbp-8] (b2),2               ;#0043AB1E: 48:307105 F8 02000000      vu 00 20  1 212      
    mov qword[rbp-16] (c3),3              ;#0043AB26: 48:307105 F0 03000000      uv 00 20  1 213      
    mov qword[rbp-24] (d4),4              ;#0043AB2E: 48:307105 E8 04000000      vu 00 20  1 213      
    mov qword[rbp-32] (e5),5              ;#0043AB36: 48:307105 E0 05000000      uv 00 20  1 214      
    mov qword[retaddr],#0043AB4B          ;#0043AB3E: 48:307105 20 4BAB4300      vu 00 20  1 214      
    jmp #0043AFF3 (code:check5)           ;#0043AB46: 351 A8040000               v  00 00  1 215      
;    72 check5(   1,  j2,   3,f4(),  m5)
    mov qword[#00403458],4                ;#0043AB4B: 48:307005 0289FCFF 04000000 uv 00 00  1 216      
    mov rcx,5                             ;#0043AB56: 48:307301 05000000         vu 02 00  1 216      
    mov rdx,886                           ;#0043AB5D: 48:307302 76030000         uv 04 00  1 217      
    call #004428DB (:%opFrame) (check5)   ;#0043AB64: 350 727D0000               v  00 00  1 217      
    mov qword[rbp] (a1),1                 ;#0043AB69: 48:307105 00 01000000      uv 00 20  1 218      
    mov qword[rbp-8] (b2),2               ;#0043AB71: 48:307105 F8 02000000      vu 00 20  1 218      
    mov qword[rbp-16] (c3),3              ;#0043AB79: 48:307105 F0 03000000      uv 00 20  1 219      
    mov qword[rbp-24] (d4),4              ;#0043AB81: 48:307105 E8 04000000      vu 00 20  1 219      
    mov qword[rbp-32] (e5),5              ;#0043AB89: 48:307105 E0 05000000      uv 00 20  1 220      
    mov qword[retaddr],#0043AB9E          ;#0043AB91: 48:307105 20 9EAB4300      vu 00 20  1 220      
    jmp #0043AFF3 (code:check5)           ;#0043AB99: 351 55040000               v  00 00  1 221      
;    73 check5(   1,  j2,   3,f4(),f5())
    mov qword[#00403460],4                ;#0043AB9E: 48:307005 B788FCFF 04000000 uv 00 00  1 222      
    mov qword[#00403468],5                ;#0043ABA9: 48:307005 B488FCFF 05000000 vu 00 00  1 222      
    mov rcx,5                             ;#0043ABB4: 48:307301 05000000         uv 02 00  1 223      
    mov rdx,886                           ;#0043ABBB: 48:307302 76030000         vu 04 00  1 223      
    call #004428DB (:%opFrame) (check5)   ;#0043ABC2: 350 147D0000               v  00 00  1 224      
    mov qword[rbp] (a1),1                 ;#0043ABC7: 48:307105 00 01000000      uv 00 20  1 225      
    mov qword[rbp-8] (b2),2               ;#0043ABCF: 48:307105 F8 02000000      vu 00 20  1 225      
    mov qword[rbp-16] (c3),3              ;#0043ABD7: 48:307105 F0 03000000      uv 00 20  1 226      
    mov qword[rbp-24] (d4),4              ;#0043ABDF: 48:307105 E8 04000000      vu 00 20  1 226      
    mov qword[rbp-32] (e5),5              ;#0043ABE7: 48:307105 E0 05000000      uv 00 20  1 227      
    mov qword[retaddr],#0043ABFC          ;#0043ABEF: 48:307105 20 FCAB4300      vu 00 20  1 227      
    jmp #0043AFF3 (code:check5)           ;#0043ABF7: 351 F7030000               v  00 00  1 228      
;    74 
;    75 check5(   1,  j2,  k3,   4,   5)
    mov rcx,5                             ;#0043ABFC: 48:307301 05000000         uv 02 00  1 229      
    mov rdx,886                           ;#0043AC03: 48:307302 76030000         vu 04 00  1 229      
    call #004428DB (:%opFrame) (check5)   ;#0043AC0A: 350 CC7C0000               v  00 00  1 230      
    mov qword[rbp] (a1),1                 ;#0043AC0F: 48:307105 00 01000000      uv 00 20  1 231      
    mov qword[rbp-8] (b2),2               ;#0043AC17: 48:307105 F8 02000000      vu 00 20  1 231      
    mov qword[rbp-16] (c3),3              ;#0043AC1F: 48:307105 F0 03000000      uv 00 20  1 232      
    mov qword[rbp-24] (d4),4              ;#0043AC27: 48:307105 E8 04000000      vu 00 20  1 232      
    mov qword[rbp-32] (e5),5              ;#0043AC2F: 48:307105 E0 05000000      uv 00 20  1 233      
    mov qword[retaddr],#0043AC44          ;#0043AC37: 48:307105 20 44AC4300      vu 00 20  1 233      
    jmp #0043AFF3 (code:check5)           ;#0043AC3F: 351 AF030000               v  00 00  1 234      
;    76 check5(   1,  j2,  k3,   4,  m5)
    mov rcx,5                             ;#0043AC44: 48:307301 05000000         uv 02 00  1 235      
    mov rdx,886                           ;#0043AC4B: 48:307302 76030000         vu 04 00  1 235      
    call #004428DB (:%opFrame) (check5)   ;#0043AC52: 350 847C0000               v  00 00  1 236      
    mov qword[rbp] (a1),1                 ;#0043AC57: 48:307105 00 01000000      uv 00 20  1 237      
    mov qword[rbp-8] (b2),2               ;#0043AC5F: 48:307105 F8 02000000      vu 00 20  1 237      
    mov qword[rbp-16] (c3),3              ;#0043AC67: 48:307105 F0 03000000      uv 00 20  1 238      
    mov qword[rbp-24] (d4),4              ;#0043AC6F: 48:307105 E8 04000000      vu 00 20  1 238      
    mov qword[rbp-32] (e5),5              ;#0043AC77: 48:307105 E0 05000000      uv 00 20  1 239      
    mov qword[retaddr],#0043AC8C          ;#0043AC7F: 48:307105 20 8CAC4300      vu 00 20  1 239      
    jmp #0043AFF3 (code:check5)           ;#0043AC87: 351 67030000               v  00 00  1 240      
;    77 check5(   1,  j2,  k3,   4,f5())
    mov qword[#00403470],5                ;#0043AC8C: 48:307005 D987FCFF 05000000 uv 00 00  1 241      
    mov rcx,5                             ;#0043AC97: 48:307301 05000000         vu 02 00  1 241      
    mov rdx,886                           ;#0043AC9E: 48:307302 76030000         uv 04 00  1 242      
    call #004428DB (:%opFrame) (check5)   ;#0043ACA5: 350 317C0000               v  00 00  1 242      
    mov qword[rbp] (a1),1                 ;#0043ACAA: 48:307105 00 01000000      uv 00 20  1 243      
    mov qword[rbp-8] (b2),2               ;#0043ACB2: 48:307105 F8 02000000      vu 00 20  1 243      
    mov qword[rbp-16] (c3),3              ;#0043ACBA: 48:307105 F0 03000000      uv 00 20  1 244      
    mov qword[rbp-24] (d4),4              ;#0043ACC2: 48:307105 E8 04000000      vu 00 20  1 244      
    mov qword[rbp-32] (e5),5              ;#0043ACCA: 48:307105 E0 05000000      uv 00 20  1 245      
    mov qword[retaddr],#0043ACDF          ;#0043ACD2: 48:307105 20 DFAC4300      vu 00 20  1 245      
    jmp #0043AFF3 (code:check5)           ;#0043ACDA: 351 14030000               v  00 00  1 246      
;    78 
;    79 check5(   1,  j2,  k3,  l4,   5)
    mov rcx,5                             ;#0043ACDF: 48:307301 05000000         uv 02 00  1 247      
    mov rdx,886                           ;#0043ACE6: 48:307302 76030000         vu 04 00  1 247      
    call #004428DB (:%opFrame) (check5)   ;#0043ACED: 350 E97B0000               v  00 00  1 248      
    mov qword[rbp] (a1),1                 ;#0043ACF2: 48:307105 00 01000000      uv 00 20  1 249      
    mov qword[rbp-8] (b2),2               ;#0043ACFA: 48:307105 F8 02000000      vu 00 20  1 249      
    mov qword[rbp-16] (c3),3              ;#0043AD02: 48:307105 F0 03000000      uv 00 20  1 250      
    mov qword[rbp-24] (d4),4              ;#0043AD0A: 48:307105 E8 04000000      vu 00 20  1 250      
    mov qword[rbp-32] (e5),5              ;#0043AD12: 48:307105 E0 05000000      uv 00 20  1 251      
    mov qword[retaddr],#0043AD27          ;#0043AD1A: 48:307105 20 27AD4300      vu 00 20  1 251      
    jmp #0043AFF3 (code:check5)           ;#0043AD22: 351 CC020000               v  00 00  1 252      
;    80 check5(   1,  j2,  k3,  l4,  m5)
    mov rcx,5                             ;#0043AD27: 48:307301 05000000         uv 02 00  1 253      
    mov rdx,886                           ;#0043AD2E: 48:307302 76030000         vu 04 00  1 253      
    call #004428DB (:%opFrame) (check5)   ;#0043AD35: 350 A17B0000               v  00 00  1 254      
    mov qword[rbp] (a1),1                 ;#0043AD3A: 48:307105 00 01000000      uv 00 20  1 255      
    mov qword[rbp-8] (b2),2               ;#0043AD42: 48:307105 F8 02000000      vu 00 20  1 255      
    mov qword[rbp-16] (c3),3              ;#0043AD4A: 48:307105 F0 03000000      uv 00 20  1 256      
    mov qword[rbp-24] (d4),4              ;#0043AD52: 48:307105 E8 04000000      vu 00 20  1 256      
    mov qword[rbp-32] (e5),5              ;#0043AD5A: 48:307105 E0 05000000      uv 00 20  1 257      
    mov qword[retaddr],#0043AD6F          ;#0043AD62: 48:307105 20 6FAD4300      vu 00 20  1 257      
    jmp #0043AFF3 (code:check5)           ;#0043AD6A: 351 84020000               v  00 00  1 258      
;    81 check5(   1,  j2,  k3,  l4,f5())
    mov qword[#00403478],5                ;#0043AD6F: 48:307005 FE86FCFF 05000000 uv 00 00  1 259      
    mov rcx,5                             ;#0043AD7A: 48:307301 05000000         vu 02 00  1 259      
    mov rdx,886                           ;#0043AD81: 48:307302 76030000         uv 04 00  1 260      
    call #004428DB (:%opFrame) (check5)   ;#0043AD88: 350 4E7B0000               v  00 00  1 260      
    mov qword[rbp] (a1),1                 ;#0043AD8D: 48:307105 00 01000000      uv 00 20  1 261      
    mov qword[rbp-8] (b2),2               ;#0043AD95: 48:307105 F8 02000000      vu 00 20  1 261      
    mov qword[rbp-16] (c3),3              ;#0043AD9D: 48:307105 F0 03000000      uv 00 20  1 262      
    mov qword[rbp-24] (d4),4              ;#0043ADA5: 48:307105 E8 04000000      vu 00 20  1 262      
    mov qword[rbp-32] (e5),5              ;#0043ADAD: 48:307105 E0 05000000      uv 00 20  1 263      
    mov qword[retaddr],#0043ADC2          ;#0043ADB5: 48:307105 20 C2AD4300      vu 00 20  1 263      
    jmp #0043AFF3 (code:check5)           ;#0043ADBD: 351 31020000               v  00 00  1 264      
;    82 
;    83 check5(   1,  j2,  k3,f4(),   5)
    mov qword[#00403480],4                ;#0043ADC2: 48:307005 B386FCFF 04000000 uv 00 00  1 265      
    mov rcx,5                             ;#0043ADCD: 48:307301 05000000         vu 02 00  1 265      
    mov rdx,886                           ;#0043ADD4: 48:307302 76030000         uv 04 00  1 266      
    call #004428DB (:%opFrame) (check5)   ;#0043ADDB: 350 FB7A0000               v  00 00  1 266      
    mov qword[rbp] (a1),1                 ;#0043ADE0: 48:307105 00 01000000      uv 00 20  1 267      
    mov qword[rbp-8] (b2),2               ;#0043ADE8: 48:307105 F8 02000000      vu 00 20  1 267      
    mov qword[rbp-16] (c3),3              ;#0043ADF0: 48:307105 F0 03000000      uv 00 20  1 268      
    mov qword[rbp-24] (d4),4              ;#0043ADF8: 48:307105 E8 04000000      vu 00 20  1 268      
    mov qword[rbp-32] (e5),5              ;#0043AE00: 48:307105 E0 05000000      uv 00 20  1 269      
    mov qword[retaddr],#0043AE15          ;#0043AE08: 48:307105 20 15AE4300      vu 00 20  1 269      
    jmp #0043AFF3 (code:check5)           ;#0043AE10: 351 DE010000               v  00 00  1 270      
;    84 check5(   1,  j2,  k3,f4(),  m5)
    mov qword[#00403488],4                ;#0043AE15: 48:307005 6886FCFF 04000000 uv 00 00  1 271      
    mov rcx,5                             ;#0043AE20: 48:307301 05000000         vu 02 00  1 271      
    mov rdx,886                           ;#0043AE27: 48:307302 76030000         uv 04 00  1 272      
    call #004428DB (:%opFrame) (check5)   ;#0043AE2E: 350 A87A0000               v  00 00  1 272      
    mov qword[rbp] (a1),1                 ;#0043AE33: 48:307105 00 01000000      uv 00 20  1 273      
    mov qword[rbp-8] (b2),2               ;#0043AE3B: 48:307105 F8 02000000      vu 00 20  1 273      
    mov qword[rbp-16] (c3),3              ;#0043AE43: 48:307105 F0 03000000      uv 00 20  1 274      
    mov qword[rbp-24] (d4),4              ;#0043AE4B: 48:307105 E8 04000000      vu 00 20  1 274      
    mov qword[rbp-32] (e5),5              ;#0043AE53: 48:307105 E0 05000000      uv 00 20  1 275      
    mov qword[retaddr],#0043AE68          ;#0043AE5B: 48:307105 20 68AE4300      vu 00 20  1 275      
    jmp #0043AFF3 (code:check5)           ;#0043AE63: 351 8B010000               v  00 00  1 276      
;    85 check5(   1,  j2,  k3,f4(),f5())
    mov qword[#00403490],4                ;#0043AE68: 48:307005 1D86FCFF 04000000 uv 00 00  1 277      
    mov qword[#00403498],5                ;#0043AE73: 48:307005 1A86FCFF 05000000 vu 00 00  1 277      
    mov rcx,5                             ;#0043AE7E: 48:307301 05000000         uv 02 00  1 278      
    mov rdx,886                           ;#0043AE85: 48:307302 76030000         vu 04 00  1 278      
    call #004428DB (:%opFrame) (check5)   ;#0043AE8C: 350 4A7A0000               v  00 00  1 279      
    mov qword[rbp] (a1),1                 ;#0043AE91: 48:307105 00 01000000      uv 00 20  1 280      
    mov qword[rbp-8] (b2),2               ;#0043AE99: 48:307105 F8 02000000      vu 00 20  1 280      
    mov qword[rbp-16] (c3),3              ;#0043AEA1: 48:307105 F0 03000000      uv 00 20  1 281      
    mov qword[rbp-24] (d4),4              ;#0043AEA9: 48:307105 E8 04000000      vu 00 20  1 281      
    mov qword[rbp-32] (e5),5              ;#0043AEB1: 48:307105 E0 05000000      uv 00 20  1 282      
    mov qword[retaddr],#0043AEC6          ;#0043AEB9: 48:307105 20 C6AE4300      vu 00 20  1 282      
    jmp #0043AFF3 (code:check5)           ;#0043AEC1: 351 2D010000               v  00 00  1 283      
;    86 
;    87 check5(   1,  j2,f3(),   4,   5)
    mov qword[#004034A0],3                ;#0043AEC6: 48:307005 CF85FCFF 03000000 uv 00 00  1 284      
    mov rcx,5                             ;#0043AED1: 48:307301 05000000         vu 02 00  1 284      
    mov rdx,886                           ;#0043AED8: 48:307302 76030000         uv 04 00  1 285      
    call #004428DB (:%opFrame) (check5)   ;#0043AEDF: 350 F7790000               v  00 00  1 285      
    mov qword[rbp] (a1),1                 ;#0043AEE4: 48:307105 00 01000000      uv 00 20  1 286      
    mov qword[rbp-8] (b2),2               ;#0043AEEC: 48:307105 F8 02000000      vu 00 20  1 286      
    mov qword[rbp-16] (c3),3              ;#0043AEF4: 48:307105 F0 03000000      uv 00 20  1 287      
    mov qword[rbp-24] (d4),4              ;#0043AEFC: 48:307105 E8 04000000      vu 00 20  1 287      
    mov qword[rbp-32] (e5),5              ;#0043AF04: 48:307105 E0 05000000      uv 00 20  1 288      
    mov qword[retaddr],#0043AF19          ;#0043AF0C: 48:307105 20 19AF4300      vu 00 20  1 288      
    jmp #0043AFF3 (code:check5)           ;#0043AF14: 351 DA000000               v  00 00  1 289      
;    88 check5(   1,  j2,f3(),   4,  m5)
    mov qword[#004034A8],3                ;#0043AF19: 48:307005 8485FCFF 03000000 uv 00 00  1 290      
    mov rcx,5                             ;#0043AF24: 48:307301 05000000         vu 02 00  1 290      
    mov rdx,886                           ;#0043AF2B: 48:307302 76030000         uv 04 00  1 291      
    call #004428DB (:%opFrame) (check5)   ;#0043AF32: 350 A4790000               v  00 00  1 291      
    mov qword[rbp] (a1),1                 ;#0043AF37: 48:307105 00 01000000      uv 00 20  1 292      
    mov qword[rbp-8] (b2),2               ;#0043AF3F: 48:307105 F8 02000000      vu 00 20  1 292      
    mov qword[rbp-16] (c3),3              ;#0043AF47: 48:307105 F0 03000000      uv 00 20  1 293      
    mov qword[rbp-24] (d4),4              ;#0043AF4F: 48:307105 E8 04000000      vu 00 20  1 293      
    mov qword[rbp-32] (e5),5              ;#0043AF57: 48:307105 E0 05000000      uv 00 20  1 294      
    mov qword[retaddr],#0043AF6C          ;#0043AF5F: 48:307105 20 6CAF4300      vu 00 20  1 294      
    jmp #0043AFF3 (code:check5)           ;#0043AF67: 351 87000000               v  00 00  1 295      
;    89 check5(   1,  j2,f3(),   4,f5())
    mov qword[#004034B0],3                ;#0043AF6C: 48:307005 3985FCFF 03000000 uv 00 00  1 296      
    mov qword[#004034B8],5                ;#0043AF77: 48:307005 3685FCFF 05000000 vu 00 00  1 296      
    mov rcx,5                             ;#0043AF82: 48:307301 05000000         uv 02 00  1 297      
    mov rdx,886                           ;#0043AF89: 48:307302 76030000         vu 04 00  1 297      
    call #004428DB (:%opFrame) (check5)   ;#0043AF90: 350 46790000               v  00 00  1 298      
    mov qword[rbp] (a1),1                 ;#0043AF95: 48:307105 00 01000000      uv 00 20  1 299      
    mov qword[rbp-8] (b2),2               ;#0043AF9D: 48:307105 F8 02000000      vu 00 20  1 299      
    mov qword[rbp-16] (c3),3              ;#0043AFA5: 48:307105 F0 03000000      uv 00 20  1 300      
    mov qword[rbp-24] (d4),4              ;#0043AFAD: 48:307105 E8 04000000      vu 00 20  1 300      
    mov qword[rbp-32] (e5),5              ;#0043AFB5: 48:307105 E0 05000000      uv 00 20  1 301      
    mov qword[retaddr],#0043AFCA          ;#0043AFBD: 48:307105 20 CAAF4300      vu 00 20  1 301      
    jmp #0043AFF3 (code:check5)           ;#0043AFC5: 351 29000000               v  00 00  1 302      
    jmp #0044298D (:%opRetf)              ;#0043AFCA: 351 BE790000               v  00 00  1 303      
;    90 
;C:\Program Files (x86)\Phix\builtins\VM\pDiagN.e:
;=================================================
;     1 --
;     2 -- pdiagN.e
;     3 -- =======
;     4 --
;     5 -- code responsible for writing the ex.err file
;     6 --
;     7 constant diagdiag = 01  -- show progress messages for debugging this source.
;     8                         --  (0=none, 1=all, 2=almost all, ... N=last only.)
;     9 constant show_bad_era = 01
;    10 
;    11 -- Technical note:
;    12 --  This should be coded as defensively as possible, rather than relying on
;    13 --  itself to give meaningful messages about errors in itself. In other words,
;    14 --  pdiag.e should not rely on pdiag.e to catch runtime errors. Strangely, it
;    15 --  tends to manage better than expected, but even so that does not make it
;    16 --  a good idea, or mean you should be surprised, when it self-implodes.
;    17 --  This means (without going overboard) that variables should be defined as 
;    18 --  object and then explicitly tested for the expected type, instead of being
;    19 --  declared as the expected type and relying on the builtin type checking, 
;    20 --  that all subscripts should be explicitly tested to be in range, and that  
;    21 --  all peeks are checked first with xIsBadReadPtr, plus anything else that
;    22 --  you can think of!
;    23 --
;    24 --[DEV rewrite]
;    25 --  If you get any error message (before you start hacking this code) which 
;    26 --  begins with "diag.e: oops," then please reduce the program to the smallest
;    27 --  possible one which still exhibits the error and send it to me. Since this
;    28 --  has been passed a nonsense [era] or [ep1], there is nothing you can do to 
;    29 --  improve matters here; it is a low-level bug that I alone must fix, sorry.
;    30 --  The same is true for line numbers of -1, except of course when an error
;    31 --  is being reported in a dll, or some non-#ilasm assembly code, or maybe
;    32 --  when "without debug" is in force at the point where the error occurred.
;    33 --
;    34 --27/2/15:
;    35 --  **NOTE** [DEV gibberish...]
;    36 --  This (pdiagN.e) runs in the context of the debugee. The symtabptr and
;    37 --  gvarptr available via e/rbp are pertinent to the program being debugged,
;    38 --  rather than the (phix) interpreter that this is linked in as part of.
;    39 --  Hence routine_id/call_func/proc/opCallOnce are all liable to miserable
;    40 --  failure if you try anything clever without that in mind. Likewise a
;    41 --  delete_routine() triggering out-of-context may well fail, ie/eg if such
;    42 --  was used/saved during initialisation, and later invoked from diag().
;    43 --  I suppose it might be possible to combine prtnid.e and pcfunc.e into
;    44 --  a context-free module that used indexes to a {symtaptr,symtabidx} table
;    45 --  as the integer ids, all in an optable rippled down the opInterp chain, 
;    46 --  but don't look at me (like that) mate!
;    47 --
;    48 --include builtins\pmt.e    -- test pmach.e (passed with flying colours) [DEV newEmit needs work! but it can wait]
;    49 --
;    50 --global constant diagBase = 2  -- temp, checked by p.exw to match newBase
;    51 
;    52 -- See also pmsgs.e, which is responsible for the two-liners created by
;    53 --  compile-time errors.
;    54 --
;    55 -- This file is automatically included as part of any exe file.
;    56 --
;    57 -- ******************************************
;    58 -- ******************************************
;    59 -- *****  WARNING: FRAGILE CODE AHEAD!  *****
;    60 -- ******************************************
;    61 -- ******************************************
;    62 --
;    63 -- Needless to say, I hope, take extra care here as if this should crash,
;    64 -- well, it will probably crash while trying to report the bug in itself...
;    65 --
;    66 -- When interpreting, errors in the user app are handled by the copy of 
;    67 --  pdiag.e in p.exe, which is also sitting ready to handle any errors
;    68 --  in the p.exw it was compiled from, whereas, of course, all compiled
;    69 --  applications must be shipped with their own private copy. This also
;    70 --  means you CANNOT "edit/test" this code in interpreted mode; instead
;    71 --  you MUST use -c to actually execute any modifications. "p -c test"
;    72 --  is strongly advised as opposed to using "p -c p" for testing, since
;    73 --  the latter may confuse by always being "one-step-out-of-date" (plus
;    74 --  of course you really do not want a broken p.exe lying around).
;    75 --
;    76 -- In general I would say there is no way to trace() this file, in any
;    77 --  case not when it is actually handling a crash. While theoretically
;    78 --  it may be possible to fudge a partial trace "in situ", it is going
;    79 --  to be far easier if you just copy/paste/rename and try out any new
;    80 --  ideas in some other/new/temporary file.
;    81 -- In many cases I have needed to add a slew of console displays to
;    82 --  narrow down the location of a bug in this code.
;    83 -- Of course it took me a while to figure out the proper way to code
;    84 --  this is to test everything and leave clues in the [partial] ex.err
;    85 --  should anything go wrong, such as those at the start of getValue().
;    86 --
;    87 -- TIP: In some cases where "p -c test" does not seem to want to work,
;    88 --  "p p -c test" may do the trick, particularly when adding/changing 
;    89 --  an opcode or making some other change to the p.exw sources.
;    90 -- A favourite trick is to replace the "if bind then" in Compile() in
;    91 --  pmain.e with "if 0 then", and [perhaps] manually include pdiag.e 
;    92 --  in a test program, to force the issue. YMMV, though.
;    93 --
;    94 -- TO DO: [DONE, I think]
;    95 --  Unify compile-time and run-time file handling so that the 
;    96 --  warning messages (from pmsgs.e) can be written to a run-time
;    97 --  .err report. Or perhaps just re-open it in append mode?
;    98 --
;    99 --!/**/without debug -- removal may or may not ease debugging!
;   100                     -- (this option probably makes v. little difference
;   101                     --  here, but see without type_check below.)
;   102 -- NB: the above "without debug" propagates into ppp.e and prntf.e, 
;   103 --     since they are used in the following code.
;   104 
;   105 --/**/  -- not really needed, but avoids an opCallOnce:
;   106 --include builtins\VM\pcfuncN.e
;   107 --/**/  include builtins\VM\pprntfN.e
;   108 --/**/  include builtins\VM\psprintN.e
;   109 --/**/  include builtins\pcurrdir.e
;   110 --/**/  include builtins\pcase.e
;   111 --include builtins\VM\pfileioN.e
;   112 --include builtins\VM\pAbort.e -- (now in pStack.e)
;   113 
;   114 --include pgets0.ew     --DEV removed 16/6/08...
;   115 --include builtins\VM\pppN.e
;   116 include builtins\ppp.e
;   117 -- 01/08/2013: (DEV... some misunderstanding here, file was created 30/7/14)
;   118 --include builtins\VM\pdeleteN.e
;   119 
;   120 --constant MAXLEN=5000
;   121 
;   122 integer fn
;   123 
;   124 -- added 17/5/15:
;   125 constant MAXLINELEN = 77    -- approximate screen/printer width
;   126                             -- (77 rather than 80 as sprint(o,l) may tag
;   127                             --  a ".." in addition to the passed length)
;   128 
;   129 --
;   130 -- Note: The following just curbs the excesses, and is not meant to be accurate 
;   131 --       or have the desired effect when less than the above MAXLINELEN constant. 
;   132 --       It is quite arbitrary. Feel free to add an extra 0 or two on the end, but 
;   133 --       there is no point in making it so big it takes weeks to finish a report 
;   134 --       that is either too big to load into an editor, or takes another two weeks 
;   135 --       to do so, and equally of course a "no limit" option is just plain daft. 
;   136 --       Quite often, debugging can be a bit easier when this is fairly small,
;   137 --       ie/eg 500 equates to around 10 page downs to get past a big sequence,
;   138 --       whereas, obviously, 5000 could easily make that around 100 keystrokes.
;   139 --       Equally, while 500 might be best for day-to-day development, 50,000
;   140 --       might be more sensible on live end-user systems, to ensure you capture
;   141 --       everything needed to diagnose some rare intermittent problem.
;   142 --       DEV make this configurable in pgui, and default to 50000? Or maybe 50000 for compiled programs, 500 for interpreted?
;   143 --       Be warned that at 50000 I just start to notice the odd pregnant pause 
;   144 --       as it (p.exe) struggles to give birth to some monster ex.err files, and
;   145 --       would fully expect exponential slowdown as things get even bigger.
;   146 --
;   147 constant MAXLENN = 500      -- longest string/sequence you will ever really need
;   148 
;   149 -- Note: The following may not honor MAXLENN like it should/used to (which is, if 
;   150 --       anything, a problem in ppp.e rather than here). You may want this if, in 
;   151 --       order to reproduce a problem, you intend to cut/paste values out of an 
;   152 --       ex.err directly into the source of a test program.
;   153 --
;   154 constant OLDSTYLE = 0       --DEV/SUG make this a command line or pgui setting
;   155 
;   156 --
;   157 -- Of course the first notion is to print things as and when lines get full, however
;   158 --  consider s = repeat(0,20); s[10] = repeat(0,20): if, as I do, you want to see:
;   159 --  s[1..9] = {0,0,0,0,0,0,0,0,0}
;   160 --  s[10] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
;   161 --  s[11..20] = {0,0,0,0,0,0,0,0,0,0,0}
;   162 --  (assuming that 20 was enough to break past MAXLINELEN and force the linebreaks)
;   163 --  then while printing (or splitting) s[10] you've got 9 elements in hand, somewhere
;   164 --  higher up the call stack, that you haven't had reason to print yet, and of course 
;   165 --  with longer and more deeply nested structures things can get far worse. Instead,
;   166 --  just append things to a "printstack" along with a key to sort everything into the
;   167 --  right order before printing. The routines below chuck around a fair few partial
;   168 --  results, start and current indexes, and return the same in subtly different ways
;   169 --  depending on what just happened, that I would struggle to explain any better than
;   170 --  the source code itself does.
;   171 --
;   172 
;   173 sequence printstack -- each element contains 3 items:
;   174                     --  indicii - for sorting, eg {21,1}
;   175                     --  name    - eg "symtab[21][1..11]" (matches that {21,1})
;   176                     --  text    - the formatted value
;   177 
;   178 procedure addtostack(sequence idii, integer idxr, string name, string text)
    mov rsi,[rbp-24] (text)               ;#0044B089: 48:213165 E8               uv 40 20  1   1      
    mov r15,h4                            ;#0044B08D: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0044B097: 4C:071376                  uv 00 8040  1   2      
    jl #0044B0A3                          ;#0044B09A: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rsi*4-1],#82             ;#0044B09C: 200174263 FF 82            u  00 48  2   3      
    je #0044B0AF                          ;#0044B0A1: 164 0C                     v  00 00  1   4      
    mov rcx,396                           ;#0044B0A3: 48:307301 8C010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044B0AA: 350 A979FFFF               v  00 00  1   5      
;   179     idii[$] = idxr
    mov rdi,qword[#00402020]              ;#0044B0AF: 48:213075 6A6FFBFF         uv 80 00  1   6      
    mov rcx,[rbp-8] (idxr)                ;#0044B0B6: 48:213115 F8               vu 02 20  1   6      
    mov rsi,[rbp] (idii)                  ;#0044B0BA: 48:213165 00               uv 40 20  1   7      
    mov rax,rbp                           ;#0044B0BE: 48:213305                  vu 01 20  1   7      
    call #00440C54 (:%pRepe1)             ;#0044B0C1: 350 8E5BFFFF               v  00 00  1   8      
;   180 --  if idii={11} then ?9/0 end if
;   181     printstack = append(printstack,{idii,name,text})
    lea rax,[rbp-32] (symtab[397])        ;#0044B0C6: 48:215105 E0               uv 01 20  1   9      
    mov rdx,3                             ;#0044B0CA: 48:307302 03000000         vu 04 00  1   9      
    push #0044B13D                        ;#0044B0D1: 150 3DB14400               uv 00 00  1  10      
    push rax                              ;#0044B0D6: 120                        vu 00 01  1  10      
    mov rax,[rbp-24] (text)               ;#0044B0D7: 48:213105 E8               uv 01 20  1  11      
    mov r15,h4                            ;#0044B0DB: 49:277 0000000000000040    vu 8000 00  1  11      
    cmp rax,r15                           ;#0044B0E5: 4C:071370                  uv 00 8001  1  12      
    jl #0044B0F5                          ;#0044B0E8: 174 0B                     v  00 00  1  12      
    add qword[rbx+rax*4-16],1             ;#0044B0EA: 48:203104203 F0 01         u  00 09  3  13      
    cmp eax,396                           ;#0044B0F0: 075 8C010000               vu 00 01  1  15      
    push rax                              ;#0044B0F5: 120                        uv 00 01  1  16      
    mov rdi,[rbp-16] (name)               ;#0044B0F6: 48:213175 F0               vu 80 20  1  16      
    mov r15,h4                            ;#0044B0FA: 49:277 0000000000000040    uv 8000 00  1  17      
    cmp rdi,r15                           ;#0044B104: 4C:071377                  uv 00 8080  1  18 8000   
    jl #0044B114                          ;#0044B107: 174 0B                     v  00 00  1  18      
    add qword[rbx+rdi*4-16],1             ;#0044B109: 48:203104273 F0 01         u  00 88  3  19      
    cmp eax,395                           ;#0044B10F: 075 8B010000               vu 00 01  1  21      
    push rdi                              ;#0044B114: 127                        uv 00 80  1  22      
    mov rcx,[rbp] (idii)                  ;#0044B115: 48:213115 00               vu 02 20  1  22      
    mov r15,h4                            ;#0044B119: 49:277 0000000000000040    uv 8000 00  1  23      
    cmp rcx,r15                           ;#0044B123: 4C:071371                  uv 00 8002  1  24 8000   
    jl #0044B133                          ;#0044B126: 174 0B                     v  00 00  1  24      
    add qword[rbx+rcx*4-16],1             ;#0044B128: 48:203104213 F0 01         u  00 0A  3  25      
    cmp eax,393                           ;#0044B12E: 075 89010000               vu 00 01  1  27      
    push rcx                              ;#0044B133: 121                        uv 00 02  1  28      
    mov rdi,[rbp-32] (symtab[397])        ;#0044B134: 48:213175 E0               vu 80 20  1  28      
    jmp #004404BD (:%pMkSq)               ;#0044B138: 351 8053FFFF               v  00 00  1  29      
    mov rsi,[#00402638] (printstack)      ;#0044B13D: 48:213065 F474FBFF         uv 40 00  1  30      
    mov r15,h4                            ;#0044B144: 49:277 0000000000000040    vu 8000 00  1  30      
    cmp rsi,r15                           ;#0044B14E: 4C:071376                  uv 00 8040  1  31      
    jne #0044B15F                         ;#0044B151: 165 0C                     v  00 00  1  31      
    mov rsi,391                           ;#0044B153: 48:307306 87010000         uv 40 00  1  32      
    call #00442D75 (:%pUnassigned)        ;#0044B15A: 350 167CFFFF               v  00 00  1  32      
    lea rdx,[#00402638] (printstack)      ;#0044B15F: 48:215025 D274FBFF         uv 04 00  1  33      
    lea rdi,[#00402638] (printstack)      ;#0044B166: 48:215075 CB74FBFF         vu 80 00  1  33      
    lea rcx,[rbp-32] (symtab[397])        ;#0044B16D: 48:215115 E0               uv 02 20  1  34      
    xor rax,rax                           ;#0044B171: 48:061300                  vu 01 01  1  34      
    call #0043FC15 (:%opApnd)             ;#0044B174: 350 9C4AFFFF               v  00 00  1  35      
    jmp #0044298D (:%opRetf)              ;#0044B179: 351 0F78FFFF               v  00 00  1  36      
;   182 end procedure
;   183 
;   184 function subscr(string prev, string name, integer prst, integer prdx)
    mov rsi,[rbp] (prev)                  ;#0044C8E1: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0044C8E5: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0044C8EF: 4C:071376                  uv 00 8040  1   2      
    jl #0044C8FB                          ;#0044C8F2: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rsi*4-1],#82             ;#0044C8F4: 200174263 FF 82            u  00 48  2   3      
    je #0044C907                          ;#0044C8F9: 164 0C                     v  00 00  1   4      
    mov rcx,400                           ;#0044C8FB: 48:307301 90010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044C902: 350 5161FFFF               v  00 00  1   5      
;   185 -- Helper routine for setting subscripts, typically for things 
;   186 --  that are just about to be chucked onto the printstack.
;   187 -- Note this is not meant to be called for any [1..$] cases.
;   188     if prst=prdx then
    mov rcx,[rbp-16] (prst)               ;#0044C907: 48:213115 F0               uv 02 20  1   6      
    mov rdi,[rbp-24] (prdx)               ;#0044C90B: 48:213175 E8               vu 80 20  1   6      
    cmp rcx,rdi                           ;#0044C90F: 48:071371                  uv 00 82  1   7      
    jne #0044C9D8                         ;#0044C912: 017205 C0000000            v  00 00  1   7      
;   189         name = sprintf("%s[%d]",{name,prst})
    lea rax,[rbp-32] (symtab[405])        ;#0044C918: 48:215105 E0               uv 01 20  1   8      
    mov rdx,2                             ;#0044C91C: 48:307302 02000000         vu 04 00  1   8      
    push #0044C952                        ;#0044C923: 150 52C94400               uv 00 00  1   9      
    push rax                              ;#0044C928: 120                        vu 00 01  1   9      
    push rcx                              ;#0044C929: 121                        uv 00 02  1  10      
    mov rax,[rbp-8] (name)                ;#0044C92A: 48:213105 F8               vu 01 20  1  10      
    mov r15,h4                            ;#0044C92E: 49:277 0000000000000040    uv 8000 00  1  11      
    cmp rax,r15                           ;#0044C938: 4C:071370                  uv 00 8001  1  12 8000   
    jl #0044C948                          ;#0044C93B: 174 0B                     v  00 00  1  12      
    add qword[rbx+rax*4-16],1             ;#0044C93D: 48:203104203 F0 01         u  00 09  3  13      
    cmp eax,401                           ;#0044C943: 075 91010000               vu 00 01  1  15      
    push rax                              ;#0044C948: 120                        uv 00 01  1  16      
    mov rdi,[rbp-32] (symtab[405])        ;#0044C949: 48:213175 E0               vu 80 20  1  16      
    jmp #004404BD (:%pMkSq)               ;#0044C94D: 351 6B3BFFFF               v  00 00  1  17      
    mov rcx,33                            ;#0044C952: 48:307301 21000000         uv 02 00  1  18      
    mov rdx,89                            ;#0044C959: 48:307302 59000000         vu 04 00  1  18      
    call #004428DB (:%opFrame) (sprintf)  ;#0044C960: 350 765FFFFF               v  00 00  1  19      
    mov rsi,qword[#00402640]              ;#0044C965: 48:213065 D45CFBFF         uv 40 00  1  20      
    mov [rbp] (format),rsi                ;#0044C96C: 48:211165 00               uv 00 60  1  21 40   
    add qword[rbx+rsi*4-16],1             ;#0044C970: 48:203104263 F0 01         u  00 48  3  23    *40*
    mov rdi,[rbp+40] (prevebp)            ;#0044C976: 48:213175 28               vu 80 20  1  25      
    mov rax,[rdi-32]                      ;#0044C97A: 48:213107 E0               uv 01 80  1  28    *80*
    xor rbx,rbx                           ;#0044C97E: 48:061333                  vu 08 08  1  28      
    mov r15,h4                            ;#0044C981: 49:277 0000000000000040    uv 8000 00  1  29      
    cmp rax,r15                           ;#0044C98B: 4C:071370                  uv 00 8001  1  30 8000   
    jl #0044C99B                          ;#0044C98E: 174 0B                     v  00 00  1  30      
    add qword[rbx+rax*4-16],1             ;#0044C990: 48:203104203 F0 01         u  00 09  3  31      
    cmp eax,405                           ;#0044C996: 075 95010000               vu 00 01  1  33      
    mov [rbp-8] (args),rax                ;#0044C99B: 48:211105 F8               uv 00 21  1  34      
    mov qword[retaddr],#0044C9AC          ;#0044C99F: 48:307105 20 ACC94400      vu 00 20  1  34      
    jmp #0044E450 (code:sprintf)          ;#0044C9A7: 351 A41A0000               v  00 00  1  35      
    push rax                              ;#0044C9AC: 120                        uv 00 01  1  36      
    mov rcx,[rbp-8] (name)                ;#0044C9AD: 48:213115 F8               vu 02 20  1  36      
    mov r15,h4                            ;#0044C9B1: 49:277 0000000000000040    uv 8000 00  1  37      
    cmp rcx,r15                           ;#0044C9BB: 4C:071371                  uv 00 8002  1  38 8000   
    jle #0044C9D0                         ;#0044C9BE: 176 10                     v  00 00  1  38      
    sub qword[rbx+rcx*4-16],1             ;#0044C9C0: 48:203154213 F0 01         u  00 0A  3  39      
    jne #0044C9D0                         ;#0044C9C6: 165 08                     v  00 00  1  41      
    mov rdx,rcx                           ;#0044C9C8: 48:213321                  uv 04 02  1  42      
    call #004422DA (:%pDealloc)           ;#0044C9CB: 350 0A59FFFF               v  00 00  1  42      
    pop dword[rbp-8] (name)               ;#0044C9D0: 217105 F8                  np 00 20  3  43      
    jmp #0044CAB7                         ;#0044C9D3: 351 DF000000               v  00 00  1  46      
;   190     else
;   191         name = sprintf("%s[%d..%d]",{name,prst,prdx})
    lea rax,[rbp-32] (symtab[405])        ;#0044C9D8: 48:215105 E0               uv 01 20  1  47      
    mov rdx,3                             ;#0044C9DC: 48:307302 03000000         vu 04 00  1  47      
    push #0044CA13                        ;#0044C9E3: 150 13CA4400               uv 00 00  1  48      
    push rax                              ;#0044C9E8: 120                        vu 00 01  1  48      
    push rdi                              ;#0044C9E9: 127                        uv 00 80  1  49      
    push rcx                              ;#0044C9EA: 121                        vu 00 02  1  49      
    mov rsi,[rbp-8] (name)                ;#0044C9EB: 48:213165 F8               uv 40 20  1  50      
    mov r15,h4                            ;#0044C9EF: 49:277 0000000000000040    vu 8000 00  1  50      
    cmp rsi,r15                           ;#0044C9F9: 4C:071376                  uv 00 8040  1  51      
    jl #0044CA09                          ;#0044C9FC: 174 0B                     v  00 00  1  51      
    add qword[rbx+rsi*4-16],1             ;#0044C9FE: 48:203104263 F0 01         u  00 48  3  52      
    cmp eax,401                           ;#0044CA04: 075 91010000               vu 00 01  1  54      
    push rsi                              ;#0044CA09: 126                        uv 00 40  1  55      
    mov rdi,[rbp-32] (symtab[405])        ;#0044CA0A: 48:213175 E0               vu 80 20  1  55      
    jmp #004404BD (:%pMkSq)               ;#0044CA0E: 351 AA3AFFFF               v  00 00  1  56      
    mov rcx,33                            ;#0044CA13: 48:307301 21000000         uv 02 00  1  57      
    mov rdx,89                            ;#0044CA1A: 48:307302 59000000         vu 04 00  1  57      
    call #004428DB (:%opFrame) (sprintf)  ;#0044CA21: 350 B55EFFFF               v  00 00  1  58      
    mov rax,qword[#00402648]              ;#0044CA26: 48:213005 1B5CFBFF         uv 01 00  1  59      
    mov [rbp] (format),rax                ;#0044CA2D: 48:211105 00               uv 00 21  1  60 01   
    add qword[rbx+rax*4-16],1             ;#0044CA31: 48:203104203 F0 01         u  00 09  3  62    *01*
    mov rdi,[rbp+40] (prevebp)            ;#0044CA37: 48:213175 28               vu 80 20  1  64      
    mov rax,[rdi-32]                      ;#0044CA3B: 48:213107 E0               uv 01 80  1  67    *80*
    xor rbx,rbx                           ;#0044CA3F: 48:061333                  vu 08 08  1  67      
    mov r15,h4                            ;#0044CA42: 49:277 0000000000000040    uv 8000 00  1  68      
    cmp rax,r15                           ;#0044CA4C: 4C:071370                  uv 00 8001  1  69 8000   
    jl #0044CA5C                          ;#0044CA4F: 174 0B                     v  00 00  1  69      
    add qword[rbx+rax*4-16],1             ;#0044CA51: 48:203104203 F0 01         u  00 09  3  70      
    cmp eax,405                           ;#0044CA57: 075 95010000               vu 00 01  1  72      
    mov [rbp-8] (args),rax                ;#0044CA5C: 48:211105 F8               uv 00 21  1  73      
    mov qword[retaddr],#0044CA6D          ;#0044CA60: 48:307105 20 6DCA4400      vu 00 20  1  73      
    jmp #0044E450 (code:sprintf)          ;#0044CA68: 351 E3190000               v  00 00  1  74      
    push rax                              ;#0044CA6D: 120                        uv 00 01  1  75      
    mov rcx,[rbp-8] (name)                ;#0044CA6E: 48:213115 F8               vu 02 20  1  75      
    mov r15,h4                            ;#0044CA72: 49:277 0000000000000040    uv 8000 00  1  76      
    cmp rcx,r15                           ;#0044CA7C: 4C:071371                  uv 00 8002  1  77 8000   
    jle #0044CA91                         ;#0044CA7F: 176 10                     v  00 00  1  77      
    sub qword[rbx+rcx*4-16],1             ;#0044CA81: 48:203154213 F0 01         u  00 0A  3  78      
    jne #0044CA91                         ;#0044CA87: 165 08                     v  00 00  1  80      
    mov rdx,rcx                           ;#0044CA89: 48:213321                  uv 04 02  1  81      
    call #004422DA (:%pDealloc)           ;#0044CA8C: 350 4958FFFF               v  00 00  1  81      
    pop dword[rbp-8] (name)               ;#0044CA91: 217105 F8                  np 00 20  3  82      
;   192         prev = "{"&prev&"}"
    mov rcx,3                             ;#0044CA94: 48:307301 03000000         uv 02 00  1  85      
    push #0044CAB7                        ;#0044CA9B: 150 B7CA4400               vu 00 00  1  85      
    push qword[#00402330]                 ;#0044CAA0: 377065 8A58FBFF            np 00 00  2  86      
    push qword[rbp] (prev)                ;#0044CAA6: 377165 00                  np 00 20  2  88      
    push qword[#00402328]                 ;#0044CAA9: 377065 7958FBFF            np 00 00  2  90      
    mov rax,rbp                           ;#0044CAAF: 48:213305                  uv 01 20  1  92      
    jmp #004402C2 (:%opConcatN)           ;#0044CAB2: 351 0B38FFFF               v  00 00  1  92      
;   193     end if
;   194     return {prev,name}
    lea rax,[rbp-32] (symtab[405])        ;#0044CAB7: 48:215105 E0               uv 01 20  1  93      
    mov rdx,2                             ;#0044CABB: 48:307302 02000000         vu 04 00  1  93      
    push #0044CB0F                        ;#0044CAC2: 150 0FCB4400               uv 00 00  1  94      
    push rax                              ;#0044CAC7: 120                        vu 00 01  1  94      
    mov rsi,[rbp-8] (name)                ;#0044CAC8: 48:213165 F8               uv 40 20  1  95      
    mov r15,h4                            ;#0044CACC: 49:277 0000000000000040    vu 8000 00  1  95      
    cmp rsi,r15                           ;#0044CAD6: 4C:071376                  uv 00 8040  1  96      
    jl #0044CAE6                          ;#0044CAD9: 174 0B                     v  00 00  1  96      
    add qword[rbx+rsi*4-16],1             ;#0044CADB: 48:203104263 F0 01         u  00 48  3  97      
    cmp eax,401                           ;#0044CAE1: 075 91010000               vu 00 01  1  99      
    push rsi                              ;#0044CAE6: 126                        uv 00 40  1 100      
    mov rdi,[rbp] (prev)                  ;#0044CAE7: 48:213175 00               vu 80 20  1 100      
    mov r15,h4                            ;#0044CAEB: 49:277 0000000000000040    uv 8000 00  1 101      
    cmp rdi,r15                           ;#0044CAF5: 4C:071377                  uv 00 8080  1 102 8000   
    jl #0044CB05                          ;#0044CAF8: 174 0B                     v  00 00  1 102      
    add qword[rbx+rdi*4-16],1             ;#0044CAFA: 48:203104273 F0 01         u  00 88  3 103      
    cmp eax,400                           ;#0044CB00: 075 90010000               vu 00 01  1 105      
    push rdi                              ;#0044CB05: 127                        uv 00 80  1 106      
    mov rdi,[rbp-32] (symtab[405])        ;#0044CB06: 48:213175 E0               vu 80 20  1 106      
    jmp #004404BD (:%pMkSq)               ;#0044CB0A: 351 AE39FFFF               v  00 00  1 107      
    mov rax,[rbp-32] (symtab[405])        ;#0044CB0F: 48:213105 E0               uv 01 20  1 108      
    mov [rbp-32] (symtab[405]),rbx        ;#0044CB13: 48:211135 E0               vu 00 28  1 108      
    jmp #0044298D (:%opRetf)              ;#0044CB17: 351 715EFFFF               v  00 00  1 109      
;   195 end function
;   196 
;   197 constant tnr = "tnr\\\"\'0"
;   198 function allascii(string x)
    mov rcx,[rbp] (x)                     ;#0044CB1C: 48:213115 00               uv 02 20  1   1      
    mov r15,h4                            ;#0044CB20: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rcx,r15                           ;#0044CB2A: 4C:071371                  uv 00 8002  1   2      
    jl #0044CB36                          ;#0044CB2D: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rcx*4-1],#82             ;#0044CB2F: 200174213 FF 82            u  00 0A  2   3      
    je #0044CB42                          ;#0044CB34: 164 0C                     v  00 00  1   4      
    mov rcx,410                           ;#0044CB36: 48:307301 9A010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044CB3D: 350 165FFFFF               v  00 00  1   5      
;   199 -- Phix allows "strings" to hold binary data, so double check 
;   200 -- before printing it as a string.
;   201 integer c
;   202     for i=length(x) to 1 by -1 do
    mov rsi,[rbx+rcx*4-24]                ;#0044CB42: 48:48:213164213 E8         uv 40 0A  1   8    *02*
    mov [rbp-16] (symtab[412]),rsi        ;#0044CB48: 48:211165 F0               uv 00 60  1   9 40   
    mov [rbp-24] (i),rsi                  ;#0044CB4C: 48:211165 E8               vu 00 60  1   9      
    cmp rsi,1                             ;#0044CB50: 48:201376 01000000         uv 00 40  1  10      
    jl #0044CCAA                          ;#0044CB57: 017214 4D010000            v  00 00  1  10      
;   203         c = x[i]
    mov rdi,[rbp-24] (i)                  ;#0044CB5D: 48:213175 E8               uv 80 20  1  11      
    mov rsi,[rbp] (x)                     ;#0044CB61: 48:213165 00               vu 40 20  1  11      
    mov rdx,410                           ;#0044CB65: 48:307302 9A010000         uv 04 00  1  12      
    call #00441762 (:%pSubse1is)          ;#0044CB6C: 350 F14BFFFF               v  00 00  1  12      
    mov [rbp-8] (c),rax                   ;#0044CB71: 48:211105 F8               uv 00 21  1  13      
;   204 --      if c<' ' or c>#7E or find(c,"\\\"\'") then
;   205         if c<' ' or c>#FE or find(c,"\\\"\'") then
    cmp rax,32                            ;#0044CB75: 48:203370 20               vu 00 01  1  13      
    jl #0044CBC9                          ;#0044CB79: 174 4E                     v  00 00  1  14      
    cmp rax,254                           ;#0044CB7B: 48:075 FE000000            uv 00 01  1  15      
    jg #0044CBC9                          ;#0044CB81: 177 46                     v  00 00  1  15      
    mov rcx,7                             ;#0044CB83: 48:307301 07000000         uv 02 00  1  16      
    mov rdx,75                            ;#0044CB8A: 48:307302 4B000000         vu 04 00  1  16      
    call #004428DB (:%opFrame) (find)     ;#0044CB91: 350 455DFFFF               v  00 00  1  17      
    mov rdi,[rbp+40] (prevebp)            ;#0044CB96: 48:213175 28               uv 80 20  1  18      
    mov rax,[rdi-8]                       ;#0044CB9A: 48:213107 F8               uv 01 80  1  21 80 *80*
    mov [rbp] (x),rax                     ;#0044CB9E: 48:211105 00               uv 00 21  1  22 01   
    mov rcx,qword[#004022F0]              ;#0044CBA2: 48:213015 4757FBFF         vu 02 00  1  22      
    mov [rbp-8] (s),rcx                   ;#0044CBA9: 48:211115 F8               uv 00 22  1  23      
    add qword[rbx+rcx*4-16],1             ;#0044CBAD: 48:203104213 F0 01         u  00 0A  3  25    *02*
    mov qword[retaddr],#0044CBC0          ;#0044CBB3: 48:307105 20 C0CB4400      vu 00 20  1  27      
    jmp #0043DAD6 (code:find)             ;#0044CBBB: 351 160FFFFF               v  00 00  1  28      
    test rax,rax                          ;#0044CBC0: 48:205300                  uv 00 01  1  29      
    je #0044CC8E                          ;#0044CBC3: 017204 C5000000            v  00 00  1  29      
;   206             c = find(c,"\t\n\r\\\"\'\0")
    mov rcx,7                             ;#0044CBC9: 48:307301 07000000         uv 02 00  1  30      
    mov rdx,75                            ;#0044CBD0: 48:307302 4B000000         vu 04 00  1  30      
    call #004428DB (:%opFrame) (find)     ;#0044CBD7: 350 FF5CFFFF               v  00 00  1  31      
    mov rdi,[rbp+40] (prevebp)            ;#0044CBDC: 48:213175 28               uv 80 20  1  32      
    mov rax,[rdi-8]                       ;#0044CBE0: 48:213107 F8               uv 01 80  1  35 80 *80*
    mov [rbp] (x),rax                     ;#0044CBE4: 48:211105 00               uv 00 21  1  36 01   
    mov rdi,qword[#004022F8]              ;#0044CBE8: 48:213075 0957FBFF         vu 80 00  1  36      
    mov [rbp-8] (s),rdi                   ;#0044CBEF: 48:211175 F8               uv 00 A0  1  37      
    add qword[rbx+rdi*4-16],1             ;#0044CBF3: 48:203104273 F0 01         u  00 88  3  39    *80*
    mov qword[retaddr],#0044CC06          ;#0044CBF9: 48:307105 20 06CC4400      vu 00 20  1  41      
    jmp #0043DAD6 (code:find)             ;#0044CC01: 351 D00EFFFF               v  00 00  1  42      
    mov [rbp-8] (c),rax                   ;#0044CC06: 48:211105 F8               uv 00 21  1  43      
;   207             if c then
    test rax,rax                          ;#0044CC0A: 48:205300                  vu 00 01  1  43      
    je #0044CC82                          ;#0044CC0D: 164 73                     v  00 00  1  44      
;   208                 x[i..i] = '\\'&tnr[c]   -- NB does not work on RDS Eu/OpenEuphoria
    mov rdi,rax                           ;#0044CC0F: 48:211307                  uv 80 01  1  45      
    mov rsi,[#00402650] (tnr)             ;#0044CC12: 48:213065 375AFBFF         vu 40 00  1  45      
    mov rdx,407                           ;#0044CC19: 48:307302 97010000         uv 04 00  1  46      
    call #00441762 (:%pSubse1is)          ;#0044CC20: 350 3D4BFFFF               v  00 00  1  46      
    mov [rbp-32] (symtab[414]),rax        ;#0044CC25: 48:211105 E0               uv 00 21  1  47      
    lea rdx,[rbp-40] (symtab[415])        ;#0044CC29: 48:215125 D8               vu 04 20  1  47      
    lea rdi,qword[#00402300]              ;#0044CC2D: 48:215075 CC56FBFF         uv 80 00  1  48      
    lea rcx,[rbp-32] (symtab[414])        ;#0044CC34: 48:215115 E0               vu 02 20  1  48      
    call #00440021 (:%opConcat)           ;#0044CC38: 350 E433FFFF               v  00 00  1  49      
    mov rcx,1                             ;#0044CC3D: 48:307301 01000000         uv 02 00  1  50      
    push #0044CC5A                        ;#0044CC44: 150 5ACC4400               vu 00 00  1  50      
    push qword[rbp-40] (symtab[415])      ;#0044CC49: 377165 D8                  np 00 20  2  51      
    push qword[rbp-24] (i)                ;#0044CC4C: 377165 E8                  np 00 20  2  53      
    push qword[rbp-24] (i)                ;#0044CC4F: 377165 E8                  np 00 20  2  55      
    mov rax,rbp                           ;#0044CC52: 48:213305                  uv 01 20  1  57      
    jmp #00440524 (:%pReps)               ;#0044CC55: 351 CA38FFFF               v  00 00  1  57      
    mov rcx,[rbp] (x)                     ;#0044CC5A: 48:213115 00               uv 02 20  1  58      
    mov r15,h4                            ;#0044CC5E: 49:277 0000000000000040    vu 8000 00  1  58      
    cmp rcx,r15                           ;#0044CC68: 4C:071371                  uv 00 8002  1  59      
    jl #0044CC74                          ;#0044CC6B: 174 07                     v  00 00  1  59      
    cmp byte[rbx+rcx*4-1],#82             ;#0044CC6D: 200174213 FF 82            u  00 0A  2  60      
    je #0044CC8E                          ;#0044CC72: 164 1A                     v  00 00  1  61      
    mov rcx,410                           ;#0044CC74: 48:307301 9A010000         uv 02 00  1  62      
    call #00442A58 (:%opTchkFail)         ;#0044CC7B: 350 D85DFFFF               v  00 00  1  62      
    jmp #0044CC8E                         ;#0044CC80: 353 0C                     v  00 00  1  63      
;   209             else
;   210                 return 0
    mov rax,0                             ;#0044CC82: 48:307300 00000000         uv 01 00  1  64      
    jmp #0044298D (:%opRetf)              ;#0044CC89: 351 FF5CFFFF               v  00 00  1  64      
;   211             end if
;   212         end if
;   213     end for
    mov rdi,[rbp-24] (i)                  ;#0044CC8E: 48:213175 E8               uv 80 20  1  65      
    mov rdx,1                             ;#0044CC92: 48:307302 01000000         vu 04 00  1  65      
    add rdi,-1                            ;#0044CC99: 48:203307 FF               uv 80 80  1  66      
    cmp rdi,rdx                           ;#0044CC9D: 48:073372                  uv 00 84  1  67 80   
    mov [rbp-24] (i),rdi                  ;#0044CCA0: 48:211175 E8               vu 00 A0  1  67      
    jge #0044CB5D                         ;#0044CCA4: 017215 B3FEFFFF            v  00 00  1  68      
;   214     return '\"'&x&'\"'
    mov rcx,3                             ;#0044CCAA: 48:307301 03000000         uv 02 00  1  69      
    push #0044CCCE                        ;#0044CCB1: 150 CECC4400               vu 00 00  1  69      
    push qword[#00402308]                 ;#0044CCB6: 377065 4C56FBFF            np 00 00  2  70      
    push qword[rbp] (x)                   ;#0044CCBC: 377165 00                  np 00 20  2  72      
    push qword[#00402308]                 ;#0044CCBF: 377065 4356FBFF            np 00 00  2  74      
    lea rax,[rbp-48] (symtab[416])        ;#0044CCC5: 48:215105 D0               uv 01 20  1  76      
    jmp #004402C2 (:%opConcatN)           ;#0044CCC9: 351 F435FFFF               v  00 00  1  76      
    mov rax,[rbp-48] (symtab[416])        ;#0044CCCE: 48:213105 D0               uv 01 20  1  77      
    mov [rbp-48] (symtab[416]),rbx        ;#0044CCD2: 48:211135 D0               vu 00 28  1  77      
    jmp #0044298D (:%opRetf)              ;#0044CCD6: 351 B25CFFFF               v  00 00  1  78      
;   215 end function
;   216 
;   217 --
;   218 --DEV known "bug":
;   219 --If this outputs say (there's 160s at [22781..2], so allascii() says 0):
;   220 --  text[1..11] = {60'<',33'!',68'D',79'O',67'C',84'T',89'Y',80'P',69'E',32' ',104'h'}
;   221 --  text[12..21] = {116't',109'm',108'l',62'>',60'<',104'h',116't',109'm',108'l',32' '}
;   222 --  text[22753..22762] = {68'D',110'n',111'o',116't',101'e',68'D',62'>',60'<',115's',116't'}
;   223 --  text[22763..22772] = {114'r',111'o',110'n',103'g',62'>',78'N',111'o',116't',101'e',60'<'}
;   224 --  text[22773..22782] = {47'/',115's',116't',114'r',111'o',110'n',103'g',62'>',160'',160''}
;   225 --  text[22783..22792] = {73'I',110'n',32' ',87'W',105'i',110'n',100'd',111'o',119'w',115's'}
;   226 --  text[22793..22802] = {160'',56'8',32' ',97'a',110'n',100'd',32' ',108'l',97'a',116't'}
;   227 --  text[22803..22812] = {101'e',114'r',32' ',111'o',112'p',101'e',114'r',97'a',116't',105'i'}
;   228 --Then Edita/reformat ex.err munges it to:
;   229 --  text[1..11] = "<!DOCTYPE h"
;   230 --  text[12..21] = "tml><html "
;   231 --  text[22753..22762] = "DnoteD><st"
;   232 --  text[22763..22772] = "rong>Note<"
;   233 --  text[22773..22782] = {47'/',115's',116't',114'r',111'o',110'n',103'g',62'>',160'',160''}
;   234 --  text[22783..22792] = "In Windows"
;   235 --  text[22793..22802] = {160'',56'8',32' ',97'a',110'n',100'd',32' ',108'l',97'a',116't'}
;   236 --  text[22803..22812] = "er operati"
;   237 --a) it looks awful (all scrunched up), b) we could perhaps do better in the first place, here,
;   238 --c) we would still want to leave some dword-sequences, in the same way that eaerr.e does.
;   239 --d) we might want a length>40 and >95% of elements are ascii or similar.
;   240 --
;   241 
;   242 function cdi(string name, string prev, integer prst, integer prdx, object o, sequence idii)
    mov rax,[rbp-8] (prev)                ;#0044B17E: 48:213105 F8               uv 01 20  1   1      
    mov r15,h4                            ;#0044B182: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rax,r15                           ;#0044B18C: 4C:071370                  uv 00 8001  1   2      
    jl #0044B198                          ;#0044B18F: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rax*4-1],#82             ;#0044B191: 200174203 FF 82            u  00 09  2   3      
    je #0044B1A4                          ;#0044B196: 164 0C                     v  00 00  1   4      
    mov rcx,420                           ;#0044B198: 48:307301 A4010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044B19F: 350 B478FFFF               v  00 00  1   5      
;   243 --
;   244 -- Clever display of i'th item. Recursive.
;   245 --  name is eg "symtab", but may get "symtab[1]", "symtab[1][1]", etc.
;   246 --  prev is previously collected stuff to output: concatenate to it, or split the line.
;   247 --  prst is a starting index where (a non-empty) prev began.
;   248 --  prdx is the element index of name that we just got passed in o.
;   249 --  idii is a list of (start) indexes, to be used in the final sort.
;   250 --
;   251 -- Returns extended or purged {prst,prev}
;   252 --
;   253 -- ps: not totally sure I got return "1,2,3" vs return "{1,2,3}" precisely right, 
;   254 --      but, touch wood, it seems fine in all the cases I have tested so far...
;   255 --
;   256 object this     -- Scratch var: string representation of o or next element of o.
;   257                 -- In the key recursive call below, "this" gets passed to "prev",
;   258                 -- and grows/shrinks from what that returns rather than directly.
;   259 
;   260 string namedx   -- Scratch var: name with some or other idx tacked on the end.
;   261 
;   262 integer newprst,                -- Scratch/innner version of prst.
;   263         lo,                     -- length(o) shorthand
;   264         lp,                     -- length(prev) shorthand
;   265         lt,                     -- length(name)+4+length(this) shorthand
;   266         dotdot = 0,             -- add ".." on the end
    mov [rbp-96] (dotdot),rbx             ;#0044B1A4: 48:211135 A0               uv 00 28  1   6      
;   267         stringo = 0,            -- string(o)/allascii(o) shorthand
    mov [rbp-104] (stringo),rbx           ;#0044B1A8: 48:211135 98               vu 00 28  1   6      
;   268         wasstacklen             -- to check if something got dumped
;   269 
;   270     wasstacklen = length(printstack)
    lea rdi,[rbp-112] (wasstacklen)       ;#0044B1AC: 48:215175 90               uv 80 20  1   7      
    mov rsi,[#00402638] (printstack)      ;#0044B1B0: 48:213065 8174FBFF         vu 40 00  1   7      
    mov rdx,391                           ;#0044B1B7: 48:307302 87010000         uv 04 00  1   8      
    call #0043F28D (:%opLen)              ;#0044B1BE: 350 CA40FFFF               v  00 00  1   8      
;   271 
;   272     if string(o) then
    mov rdi,[rbp-32] (o)                  ;#0044B1C3: 48:213175 E0               uv 80 20  1   9      
    mov r15,h4                            ;#0044B1C7: 49:277 0000000000000040    vu 8000 00  1   9      
    cmp rdi,r15                           ;#0044B1D1: 4C:071377                  uv 00 8080  1  10      
    jl #0044B286                          ;#0044B1D4: 017214 AC000000            v  00 00  1  10      
    cmp byte[rbx+rdi*4-1],#82             ;#0044B1DA: 200174273 FF 82            u  00 88  2  11      
    jne #0044B286                         ;#0044B1DF: 017205 A1000000            v  00 00  1  12      
;   273         if length(o)>MAXLENN then
    mov rax,[rbx+rdi*4-24]                ;#0044B1E5: 48:48:213104273 E8         uv 01 88  1  13      
    cmp rax,500                           ;#0044B1EB: 48:075 F4010000            uv 00 01  1  14 01   
    jle #0044B222                         ;#0044B1F1: 176 2F                     v  00 00  1  14      
;   274             o = o[1..MAXLENN]
    lea rdx,[rbp-32] (o)                  ;#0044B1F3: 48:215125 E0               uv 04 20  1  15      
    mov rcx,1                             ;#0044B1F7: 48:307301 01000000         vu 02 00  1  15      
    push #0044B21A                        ;#0044B1FE: 150 1AB24400               uv 00 00  1  16      
    push rdx                              ;#0044B203: 122                        vu 00 04  1  16      
    push 500                              ;#0044B204: 150 F4010000               uv 00 00  1  17      
    push 1                                ;#0044B209: 152 01                     vu 00 00  1  17      
    mov rsi,rdi                           ;#0044B20B: 48:211376                  uv 40 80  1  18      
    mov rdx,423                           ;#0044B20E: 48:307302 A7010000         vu 04 00  1  18      
    jmp #00440F1F (:%pSubss)              ;#0044B215: 351 055DFFFF               v  00 00  1  19      
;   275             dotdot = 1
    mov qword[rbp-96] (dotdot),1          ;#0044B21A: 48:307105 A0 01000000      uv 00 20  1  20      
;   276         end if
;   277         this = allascii(o)
    mov rcx,7                             ;#0044B222: 48:307301 07000000         vu 02 00  1  20      
    mov rdx,409                           ;#0044B229: 48:307302 99010000         uv 04 00  1  21      
    call :%opFrame (allascii)             ;#0044B230: 350 A676FFFF               v  00 00  1  21      
    mov rdi,[rbp+40] (prevebp)            ;#0044B235: 48:213175 28               uv 80 20  1  22      
    mov rax,[rdi-32]                      ;#0044B239: 48:213107 E0               uv 01 80  1  25 80 *80*
    xor rbx,rbx                           ;#0044B23D: 48:061333                  vu 08 08  1  25      
    mov r15,h4                            ;#0044B240: 49:277 0000000000000040    uv 8000 00  1  26      
    cmp rax,r15                           ;#0044B24A: 4C:071370                  uv 00 8001  1  27 8000   
    jl #0044B25A                          ;#0044B24D: 174 0B                     v  00 00  1  27      
    add qword[rbx+rax*4-16],1             ;#0044B24F: 48:203104203 F0 01         u  00 09  3  28      
    cmp eax,423                           ;#0044B255: 075 A7010000               vu 00 01  1  30      
    mov [rbp] (x),rax                     ;#0044B25A: 48:211105 00               uv 00 21  1  31      
    mov qword[retaddr],#0044B26B          ;#0044B25E: 48:307105 20 6BB24400      vu 00 20  1  31      
    jmp #0044CB1C (code:allascii)         ;#0044B266: 351 B1180000               v  00 00  1  32      
    mov [rbp-48] (this),rax               ;#0044B26B: 48:211105 D0               uv 00 21  1  33      
;   278         if string(this) then
    mov r15,h4                            ;#0044B26F: 49:277 0000000000000040    vu 8000 00  1  33      
    cmp rax,r15                           ;#0044B279: 4C:071370                  uv 00 8001  1  34      
    jl #0044B286                          ;#0044B27C: 174 08                     v  00 00  1  34      
;   279             stringo = 1
    mov qword[rbp-104] (stringo),1        ;#0044B27E: 48:307105 98 01000000      uv 00 20  1  35      
;   280         end if
;   281     end if
;   282     if atom(o) then
    mov rsi,[rbp-32] (o)                  ;#0044B286: 48:213165 E0               vu 40 20  1  35      
    mov r15,h4                            ;#0044B28A: 49:277 0000000000000040    uv 8000 00  1  36      
    cmp rsi,r15                           ;#0044B294: 4C:071376                  uv 00 8040  1  37 8000   
    jl #0044B2A4                          ;#0044B297: 174 0B                     v  00 00  1  37      
    cmp byte[rbx+rsi*4-1],#12             ;#0044B299: 200174263 FF 12            u  00 48  2  38      
    jne #0044B4F4                         ;#0044B29E: 017205 50020000            v  00 00  1  39      
;   283         this = sprintf("%.10g", o)
    mov rcx,33                            ;#0044B2A4: 48:307301 21000000         uv 02 00  1  40      
    mov rdx,89                            ;#0044B2AB: 48:307302 59000000         vu 04 00  1  40      
    call #004428DB (:%opFrame) (sprintf)  ;#0044B2B2: 350 2476FFFF               v  00 00  1  41      
    mov rcx,qword[#00402310]              ;#0044B2B7: 48:213015 5270FBFF         uv 02 00  1  42      
    mov [rbp] (format),rcx                ;#0044B2BE: 48:211115 00               uv 00 22  1  43 02   
    add qword[rbx+rcx*4-16],1             ;#0044B2C2: 48:203104213 F0 01         u  00 0A  3  45    *02*
    mov rdi,[rbp+40] (prevebp)            ;#0044B2C8: 48:213175 28               vu 80 20  1  47      
    mov rax,[rdi-32]                      ;#0044B2CC: 48:213107 E0               uv 01 80  1  50    *80*
    xor rbx,rbx                           ;#0044B2D0: 48:061333                  vu 08 08  1  50      
    mov r15,h4                            ;#0044B2D3: 49:277 0000000000000040    uv 8000 00  1  51      
    cmp rax,r15                           ;#0044B2DD: 4C:071370                  uv 00 8001  1  52 8000   
    jl #0044B2ED                          ;#0044B2E0: 174 0B                     v  00 00  1  52      
    add qword[rbx+rax*4-16],1             ;#0044B2E2: 48:203104203 F0 01         u  00 09  3  53      
    cmp eax,423                           ;#0044B2E8: 075 A7010000               vu 00 01  1  55      
    mov [rbp-8] (args),rax                ;#0044B2ED: 48:211105 F8               uv 00 21  1  56      
    mov qword[retaddr],#0044B2FE          ;#0044B2F1: 48:307105 20 FEB24400      vu 00 20  1  56      
    jmp #0044E450 (code:sprintf)          ;#0044B2F9: 351 52310000               v  00 00  1  57      
    push rax                              ;#0044B2FE: 120                        uv 00 01  1  58      
    mov rdi,[rbp-48] (this)               ;#0044B2FF: 48:213175 D0               vu 80 20  1  58      
    mov r15,h4                            ;#0044B303: 49:277 0000000000000040    uv 8000 00  1  59      
    cmp rdi,r15                           ;#0044B30D: 4C:071377                  uv 00 8080  1  60 8000   
    jle #0044B322                         ;#0044B310: 176 10                     v  00 00  1  60      
    sub qword[rbx+rdi*4-16],1             ;#0044B312: 48:203154273 F0 01         u  00 88  3  61      
    jne #0044B322                         ;#0044B318: 165 08                     v  00 00  1  63      
    mov rdx,rdi                           ;#0044B31A: 48:213327                  uv 04 80  1  64      
    call #004422DA (:%pDealloc)           ;#0044B31D: 350 B86FFFFF               v  00 00  1  64      
    pop dword[rbp-48] (this)              ;#0044B322: 217105 D0                  np 00 20  3  65      
;   284         if integer(o) then
    mov rsi,[rbp-32] (o)                  ;#0044B325: 48:213165 E0               uv 40 20  1  68      
    mov r15,h4                            ;#0044B329: 49:277 0000000000000040    vu 8000 00  1  68      
    cmp rsi,r15                           ;#0044B333: 4C:071376                  uv 00 8040  1  69      
    jg #0044B3CD                          ;#0044B336: 017217 91000000            v  00 00  1  69      
;   285             if o>=#20 and o<=#FF then
    cmp rsi,32                            ;#0044B33C: 48:203376 20               uv 00 40  1  70      
    jl #0044BDD7                          ;#0044B340: 017214 910A0000            v  00 00  1  70      
    cmp rsi,255                           ;#0044B346: 48:201376 FF000000         uv 00 40  1  71      
    jg #0044BDD7                          ;#0044B34D: 017217 840A0000            v  00 00  1  71      
;   286                 this &= sprintf("'%s'",o)
    mov rcx,33                            ;#0044B353: 48:307301 21000000         uv 02 00  1  72      
    mov rdx,89                            ;#0044B35A: 48:307302 59000000         vu 04 00  1  72      
    call #004428DB (:%opFrame) (sprintf)  ;#0044B361: 350 7575FFFF               v  00 00  1  73      
    mov rcx,qword[#00402658]              ;#0044B366: 48:213015 EB72FBFF         uv 02 00  1  74      
    mov [rbp] (format),rcx                ;#0044B36D: 48:211115 00               uv 00 22  1  75 02   
    add qword[rbx+rcx*4-16],1             ;#0044B371: 48:203104213 F0 01         u  00 0A  3  77    *02*
    mov rdi,[rbp+40] (prevebp)            ;#0044B377: 48:213175 28               vu 80 20  1  79      
    mov rax,[rdi-32]                      ;#0044B37B: 48:213107 E0               uv 01 80  1  82    *80*
    mov [rbp-8] (args),rax                ;#0044B37F: 48:211105 F8               uv 00 21  1  83 01   
    mov qword[retaddr],#0044B390          ;#0044B383: 48:307105 20 90B34400      vu 00 20  1  83      
    jmp #0044E450 (code:sprintf)          ;#0044B38B: 351 C0300000               v  00 00  1  84      
    push rax                              ;#0044B390: 120                        uv 00 01  1  85      
    mov rdi,[rbp-128] (symtab[436])       ;#0044B391: 48:213175 80               vu 80 20  1  85      
    mov r15,h4                            ;#0044B395: 49:277 0000000000000040    uv 8000 00  1  86      
    cmp rdi,r15                           ;#0044B39F: 4C:071377                  uv 00 8080  1  87 8000   
    jle #0044B3B4                         ;#0044B3A2: 176 10                     v  00 00  1  87      
    sub qword[rbx+rdi*4-16],1             ;#0044B3A4: 48:203154273 F0 01         u  00 88  3  88      
    jne #0044B3B4                         ;#0044B3AA: 165 08                     v  00 00  1  90      
    mov rdx,rdi                           ;#0044B3AC: 48:213327                  uv 04 80  1  91      
    call #004422DA (:%pDealloc)           ;#0044B3AF: 350 266FFFFF               v  00 00  1  91      
    pop dword[rbp-128] (symtab[436])      ;#0044B3B4: 217105 80                  np 00 20  3  92      
    lea rdx,[rbp-48] (this)               ;#0044B3B7: 48:215125 D0               uv 04 20  1  95      
    lea rdi,[rbp-48] (this)               ;#0044B3BB: 48:215175 D0               vu 80 20  1  95      
    lea rcx,[rbp-128] (symtab[436])       ;#0044B3BF: 48:215115 80               uv 02 20  1  96      
    call #00440021 (:%opConcat)           ;#0044B3C3: 350 594CFFFF               v  00 00  1  96      
;   287             end if
    jmp #0044BDD7                         ;#0044B3C8: 351 0A0A0000               v  00 00  1  97      
;   288         elsif not find('.',this)
    mov rcx,7                             ;#0044B3CD: 48:307301 07000000         uv 02 00  1  98      
    mov rdx,75                            ;#0044B3D4: 48:307302 4B000000         vu 04 00  1  98      
    call #004428DB (:%opFrame) (find)     ;#0044B3DB: 350 FB74FFFF               v  00 00  1  99      
    mov qword[rbp] (x),46                 ;#0044B3E0: 48:307105 00 2E000000      uv 00 20  1 100      
    mov rdi,[rbp+40] (prevebp)            ;#0044B3E8: 48:213175 28               vu 80 20  1 100      
    mov rax,[rdi-48]                      ;#0044B3EC: 48:213107 D0               uv 01 80  1 103    *80*
    xor rbx,rbx                           ;#0044B3F0: 48:061333                  vu 08 08  1 103      
    mov r15,h4                            ;#0044B3F3: 49:277 0000000000000040    uv 8000 00  1 104      
    cmp rax,r15                           ;#0044B3FD: 4C:071370                  uv 00 8001  1 105 8000   
    jl #0044B40D                          ;#0044B400: 174 0B                     v  00 00  1 105      
    add qword[rbx+rax*4-16],1             ;#0044B402: 48:203104203 F0 01         u  00 09  3 106      
    cmp eax,425                           ;#0044B408: 075 A9010000               vu 00 01  1 108      
    mov [rbp-8] (s),rax                   ;#0044B40D: 48:211105 F8               uv 00 21  1 109      
    mov qword[retaddr],#0044B41E          ;#0044B411: 48:307105 20 1EB44400      vu 00 20  1 109      
    jmp #0043DAD6 (code:find)             ;#0044B419: 351 B826FFFF               v  00 00  1 110      
    test rax,rax                          ;#0044B41E: 48:205300                  uv 00 01  1 111      
    jne #0044BDD7                         ;#0044B421: 017205 B0090000            v  00 00  1 111      
;   289           and not find('e',this)        -- eg 1e308
    mov rcx,7                             ;#0044B427: 48:307301 07000000         uv 02 00  1 112      
    mov rdx,75                            ;#0044B42E: 48:307302 4B000000         vu 04 00  1 112      
    call #004428DB (:%opFrame) (find)     ;#0044B435: 350 A174FFFF               v  00 00  1 113      
    mov qword[rbp] (x),101                ;#0044B43A: 48:307105 00 65000000      uv 00 20  1 114      
    mov rdi,[rbp+40] (prevebp)            ;#0044B442: 48:213175 28               vu 80 20  1 114      
    mov rax,[rdi-48]                      ;#0044B446: 48:213107 D0               uv 01 80  1 117    *80*
    xor rbx,rbx                           ;#0044B44A: 48:061333                  vu 08 08  1 117      
    mov r15,h4                            ;#0044B44D: 49:277 0000000000000040    uv 8000 00  1 118      
    cmp rax,r15                           ;#0044B457: 4C:071370                  uv 00 8001  1 119 8000   
    jl #0044B467                          ;#0044B45A: 174 0B                     v  00 00  1 119      
    add qword[rbx+rax*4-16],1             ;#0044B45C: 48:203104203 F0 01         u  00 09  3 120      
    cmp eax,425                           ;#0044B462: 075 A9010000               vu 00 01  1 122      
    mov [rbp-8] (s),rax                   ;#0044B467: 48:211105 F8               uv 00 21  1 123      
    mov qword[retaddr],#0044B478          ;#0044B46B: 48:307105 20 78B44400      vu 00 20  1 123      
    jmp #0043DAD6 (code:find)             ;#0044B473: 351 5E26FFFF               v  00 00  1 124      
    test rax,rax                          ;#0044B478: 48:205300                  uv 00 01  1 125      
    jne #0044BDD7                         ;#0044B47B: 017205 56090000            v  00 00  1 125      
;   290           and not find('n',this) then   -- (inf/nan)
    mov rcx,7                             ;#0044B481: 48:307301 07000000         uv 02 00  1 126      
    mov rdx,75                            ;#0044B488: 48:307302 4B000000         vu 04 00  1 126      
    call #004428DB (:%opFrame) (find)     ;#0044B48F: 350 4774FFFF               v  00 00  1 127      
    mov qword[rbp] (x),110                ;#0044B494: 48:307105 00 6E000000      uv 00 20  1 128      
    mov rdi,[rbp+40] (prevebp)            ;#0044B49C: 48:213175 28               vu 80 20  1 128      
    mov rax,[rdi-48]                      ;#0044B4A0: 48:213107 D0               uv 01 80  1 131    *80*
    xor rbx,rbx                           ;#0044B4A4: 48:061333                  vu 08 08  1 131      
    mov r15,h4                            ;#0044B4A7: 49:277 0000000000000040    uv 8000 00  1 132      
    cmp rax,r15                           ;#0044B4B1: 4C:071370                  uv 00 8001  1 133 8000   
    jl #0044B4C1                          ;#0044B4B4: 174 0B                     v  00 00  1 133      
    add qword[rbx+rax*4-16],1             ;#0044B4B6: 48:203104203 F0 01         u  00 09  3 134      
    cmp eax,425                           ;#0044B4BC: 075 A9010000               vu 00 01  1 136      
    mov [rbp-8] (s),rax                   ;#0044B4C1: 48:211105 F8               uv 00 21  1 137      
    mov qword[retaddr],#0044B4D2          ;#0044B4C5: 48:307105 20 D2B44400      vu 00 20  1 137      
    jmp #0043DAD6 (code:find)             ;#0044B4CD: 351 0426FFFF               v  00 00  1 138      
    test rax,rax                          ;#0044B4D2: 48:205300                  uv 00 01  1 139      
    jne #0044BDD7                         ;#0044B4D5: 017205 FC080000            v  00 00  1 139      
;   291             --
;   292             -- Ensure you can tell 5 and 5.000000000001 apart.
;   293             -- Note that while you can infer from the presence
;   294             -- of ".0" it is "not integer", in no way does the
;   295             -- /absence/ mean anything at all about whether a 
;   296             -- variable was declared integer/atom/object/udt.
;   297             --
;   298             this &= ".0"
    lea rdx,[rbp-48] (this)               ;#0044B4DB: 48:215125 D0               uv 04 20  1 140      
    lea rdi,[rbp-48] (this)               ;#0044B4DF: 48:215175 D0               vu 80 20  1 140      
    lea rcx,qword[#00402318]              ;#0044B4E3: 48:215015 2E6EFBFF         uv 02 00  1 141      
    call #00440021 (:%opConcat)           ;#0044B4EA: 350 324BFFFF               v  00 00  1 141      
;   299         end if
    jmp #0044BDD7                         ;#0044B4EF: 351 E3080000               v  00 00  1 142      
;   300     elsif not stringo then
    mov rsi,[rbp-104] (stringo)           ;#0044B4F4: 48:213165 98               uv 40 20  1 143      
    test rsi,rsi                          ;#0044B4F8: 48:205366                  uv 00 40  1 144 40   
    jne #0044BDD7                         ;#0044B4FB: 017205 D6080000            v  00 00  1 144      
;   301         if length(idii) then
    mov rcx,[rbp-40] (idii)               ;#0044B501: 48:213115 D8               uv 02 20  1 145      
    mov rdi,[rbx+rcx*4-24]                ;#0044B505: 48:213174213 E8            uv 80 0A  1 148 02 *02*
    test rdi,edi                          ;#0044B50A: 205377                     uv 00 80  1 149 80   
    je #0044B5B7                          ;#0044B50C: 017204 A5000000            v  00 00  1 149      
;   302             namedx = sprintf("%s[%d]",{name,prdx})
    lea rax,[rbp-136] (symtab[437])       ;#0044B512: 48:215205 78FFFFFF         uv 01 20  1 150      
    mov rdx,2                             ;#0044B519: 48:307302 02000000         vu 04 00  1 150      
    push #0044B554                        ;#0044B520: 150 54B54400               uv 00 00  1 151      
    push rax                              ;#0044B525: 120                        vu 00 01  1 151      
    push qword[rbp-24] (prdx)             ;#0044B526: 377165 E8                  np 00 20  2 152      
    mov rax,[rbp] (name)                  ;#0044B529: 48:213105 00               uv 01 20  1 154      
    mov r15,h4                            ;#0044B52D: 49:277 0000000000000040    vu 8000 00  1 154      
    cmp rax,r15                           ;#0044B537: 4C:071370                  uv 00 8001  1 155      
    jl #0044B547                          ;#0044B53A: 174 0B                     v  00 00  1 155      
    add qword[rbx+rax*4-16],1             ;#0044B53C: 48:203104203 F0 01         u  00 09  3 156      
    cmp eax,419                           ;#0044B542: 075 A3010000               vu 00 01  1 158      
    push rax                              ;#0044B547: 120                        uv 00 01  1 159      
    mov rdi,[rbp-136] (symtab[437])       ;#0044B548: 48:213275 78FFFFFF         vu 80 20  1 159      
    jmp #004404BD (:%pMkSq)               ;#0044B54F: 351 694FFFFF               v  00 00  1 160      
    mov rcx,33                            ;#0044B554: 48:307301 21000000         uv 02 00  1 161      
    mov rdx,89                            ;#0044B55B: 48:307302 59000000         vu 04 00  1 161      
    call #004428DB (:%opFrame) (sprintf)  ;#0044B562: 350 7473FFFF               v  00 00  1 162      
    mov rsi,qword[#00402640]              ;#0044B567: 48:213065 D270FBFF         uv 40 00  1 163      
    mov [rbp] (format),rsi                ;#0044B56E: 48:211165 00               uv 00 60  1 164 40   
    add qword[rbx+rsi*4-16],1             ;#0044B572: 48:203104263 F0 01         u  00 48  3 166    *40*
    mov rdi,[rbp+40] (prevebp)            ;#0044B578: 48:213175 28               vu 80 20  1 168      
    mov rax,[rdi-136]                     ;#0044B57C: 48:213207 78FFFFFF         uv 01 80  1 171    *80*
    xor rbx,rbx                           ;#0044B583: 48:061333                  vu 08 08  1 171      
    mov r15,h4                            ;#0044B586: 49:277 0000000000000040    uv 8000 00  1 172      
    cmp rax,r15                           ;#0044B590: 4C:071370                  uv 00 8001  1 173 8000   
    jl #0044B5A0                          ;#0044B593: 174 0B                     v  00 00  1 173      
    add qword[rbx+rax*4-16],1             ;#0044B595: 48:203104203 F0 01         u  00 09  3 174      
    cmp eax,437                           ;#0044B59B: 075 B5010000               vu 00 01  1 176      
    mov [rbp-8] (args),rax                ;#0044B5A0: 48:211105 F8               uv 00 21  1 177      
    mov qword[retaddr],#0044B5B1          ;#0044B5A4: 48:307105 20 B1B54400      vu 00 20  1 177      
    jmp #0044E450 (code:sprintf)          ;#0044B5AC: 351 9F2E0000               v  00 00  1 178      
    mov [rbp-56] (namedx),rax             ;#0044B5B1: 48:211105 C8               uv 00 21  1 179      
    jmp #0044B5F4                         ;#0044B5B5: 353 3D                     v  00 00  1 179      
;   303         else
;   304             namedx = name
    mov rcx,[rbp] (name)                  ;#0044B5B7: 48:213115 00               uv 02 20  1 180      
    mov rdx,[rbp-56] (namedx)             ;#0044B5BB: 48:213125 C8               vu 04 20  1 180      
    mov r15,h4                            ;#0044B5BF: 49:277 0000000000000040    uv 8000 00  1 181      
    cmp rcx,r15                           ;#0044B5C9: 4C:071371                  uv 00 8002  1 182 8000   
    jl #0044B5D4                          ;#0044B5CC: 174 06                     v  00 00  1 182      
    add qword[rbx+rcx*4-16],1             ;#0044B5CE: 48:203104213 F0 01         u  00 0A  3 183      
    mov [rbp-56] (namedx),rcx             ;#0044B5D4: 48:211115 C8               vu 00 22  1 185      
    mov r15,h4                            ;#0044B5D8: 49:277 0000000000000040    uv 8000 00  1 186      
    cmp rdx,r15                           ;#0044B5E2: 4C:071372                  uv 00 8004  1 187 8000   
    jle #0044B5F4                         ;#0044B5E5: 176 0D                     v  00 00  1 187      
    sub qword[rbx+rdx*4-16],1             ;#0044B5E7: 48:203154223 F0 01         u  00 0C  3 188      
    jne #0044B5F4                         ;#0044B5ED: 165 05                     v  00 00  1 190      
    call #004422DA (:%pDealloc)           ;#0044B5EF: 350 E66CFFFF               v  00 00  1 191      
;   305         end if
;   306         this = ""
    mov rdi,qword[#00402240]              ;#0044B5F4: 48:213075 456CFBFF         uv 80 00  1 192      
    mov rdx,[rbp-48] (this)               ;#0044B5FB: 48:213125 D0               vu 04 20  1 192      
    mov r15,h4                            ;#0044B5FF: 49:277 0000000000000040    uv 8000 00  1 193      
    cmp rdi,r15                           ;#0044B609: 4C:071377                  uv 00 8080  1 194 8000   
    jl #0044B614                          ;#0044B60C: 174 06                     v  00 00  1 194      
    add qword[rbx+rdi*4-16],1             ;#0044B60E: 48:203104273 F0 01         u  00 88  3 195      
    mov [rbp-48] (this),rdi               ;#0044B614: 48:211175 D0               vu 00 A0  1 197      
    mov r15,h4                            ;#0044B618: 49:277 0000000000000040    uv 8000 00  1 198      
    cmp rdx,r15                           ;#0044B622: 4C:071372                  uv 00 8004  1 199 8000   
    jle #0044B634                         ;#0044B625: 176 0D                     v  00 00  1 199      
    sub qword[rbx+rdx*4-16],1             ;#0044B627: 48:203154223 F0 01         u  00 0C  3 200      
    jne #0044B634                         ;#0044B62D: 165 05                     v  00 00  1 202      
    call #004422DA (:%pDealloc)           ;#0044B62F: 350 A66CFFFF               v  00 00  1 203      
;   307         newprst = 1
    mov qword[rbp-64] (newprst),1         ;#0044B634: 48:307105 C0 01000000      uv 00 20  1 204      
;   308         lo = length(o)
    mov rsi,[rbp-32] (o)                  ;#0044B63C: 48:213165 E0               vu 40 20  1 204      
    mov rax,[rbx+rsi*4-24]                ;#0044B640: 48:48:213104263 E8         uv 01 48  1 207    *40*
    mov [rbp-72] (lo),rax                 ;#0044B646: 48:211105 B8               uv 00 21  1 208 01   
;   309         if lo>MAXLENN then
    cmp rax,500                           ;#0044B64A: 48:075 F4010000            vu 00 01  1 208      
    jle #0044B67E                         ;#0044B650: 176 2C                     v  00 00  1 209      
;   310             o = o[1..MAXLENN]
    lea rdx,[rbp-32] (o)                  ;#0044B652: 48:215125 E0               uv 04 20  1 210      
    mov rcx,1                             ;#0044B656: 48:307301 01000000         vu 02 00  1 210      
    push #0044B676                        ;#0044B65D: 150 76B64400               uv 00 00  1 211      
    push rdx                              ;#0044B662: 122                        vu 00 04  1 211      
    push 500                              ;#0044B663: 150 F4010000               uv 00 00  1 212      
    push 1                                ;#0044B668: 152 01                     vu 00 00  1 212      
    mov rdx,423                           ;#0044B66A: 48:307302 A7010000         uv 04 00  1 213      
    jmp #00440F1F (:%pSubss)              ;#0044B671: 351 A958FFFF               v  00 00  1 213      
;   311             dotdot = 1
    mov qword[rbp-96] (dotdot),1          ;#0044B676: 48:307105 A0 01000000      uv 00 20  1 214      
;   312         end if
;   313         for i=1 to length(o) do -- (nb not lo)
    mov rcx,[rbp-32] (o)                  ;#0044B67E: 48:213115 E0               vu 02 20  1 214      
    mov rdi,[rbx+rcx*4-24]                ;#0044B682: 48:48:213174213 E8         uv 80 0A  1 217    *02*
    mov [rbp-120] (symtab[434]),rdi       ;#0044B688: 48:211175 88               uv 00 A0  1 218 80   
    mov qword[rbp-144] (i),1              ;#0044B68C: 48:307205 70FFFFFF 01000000 vu 00 20  1 218      
    cmp rdi,1                             ;#0044B697: 48:201377 01000000         uv 00 80  1 219      
    jl #0044B864                          ;#0044B69E: 017214 C0010000            v  00 00  1 219      
;   314             {newprst,this} = cdi(namedx,this,newprst,i,o[i],idii&i)
    mov rdi,[rbp-144] (i)                 ;#0044B6A4: 48:213275 70FFFFFF         uv 80 20  1 220      
    lea rcx,[rbp-152] (symtab[439])       ;#0044B6AB: 48:215215 68FFFFFF         vu 02 20  1 220      
    mov rsi,[rbp-32] (o)                  ;#0044B6B2: 48:213165 E0               uv 40 20  1 221      
    mov rdx,423                           ;#0044B6B6: 48:307302 A7010000         vu 04 00  1 221      
    call #00441675 (:%pSubse1)            ;#0044B6BD: 350 B35FFFFF               v  00 00  1 222      
    lea rdx,[rbp-160] (symtab[440])       ;#0044B6C2: 48:215225 60FFFFFF         uv 04 20  1 223      
    lea rdi,[rbp-40] (idii)               ;#0044B6C9: 48:215175 D8               vu 80 20  1 223      
    lea rcx,[rbp-144] (i)                 ;#0044B6CD: 48:215215 70FFFFFF         uv 02 20  1 224      
    xor rax,rax                           ;#0044B6D4: 48:061300                  vu 01 01  1 224      
    call #0043FC15 (:%opApnd)             ;#0044B6D7: 350 3945FFFF               v  00 00  1 225      
    mov rcx,27                            ;#0044B6DC: 48:307301 1B000000         uv 02 00  1 226      
    mov rdx,418                           ;#0044B6E3: 48:307302 A2010000         vu 04 00  1 226      
    call #004428DB (:%opFrame) (cdi)      ;#0044B6EA: 350 EC71FFFF               v  00 00  1 227      
    mov rdi,[rbp+40] (prevebp)            ;#0044B6EF: 48:213175 28               uv 80 20  1 228      
    mov rax,[rdi-56]                      ;#0044B6F3: 48:213107 C8               uv 01 80  1 231 80 *80*
    xor rbx,rbx                           ;#0044B6F7: 48:061333                  vu 08 08  1 231      
    mov r15,h4                            ;#0044B6FA: 49:277 0000000000000040    uv 8000 00  1 232      
    cmp rax,r15                           ;#0044B704: 4C:071370                  uv 00 8001  1 233 8000   
    jl #0044B714                          ;#0044B707: 174 0B                     v  00 00  1 233      
    add qword[rbx+rax*4-16],1             ;#0044B709: 48:203104203 F0 01         u  00 09  3 234      
    cmp eax,426                           ;#0044B70F: 075 AA010000               vu 00 01  1 236      
    mov [rbp] (name),rax                  ;#0044B714: 48:211105 00               uv 00 21  1 237      
    mov rdi,[rbp+40] (prevebp)            ;#0044B718: 48:213175 28               vu 80 20  1 237      
    mov rax,[rdi-48]                      ;#0044B71C: 48:213107 D0               uv 01 80  1 240    *80*
    xor rbx,rbx                           ;#0044B720: 48:061333                  vu 08 08  1 240      
    mov r15,h4                            ;#0044B723: 49:277 0000000000000040    uv 8000 00  1 241      
    cmp rax,r15                           ;#0044B72D: 4C:071370                  uv 00 8001  1 242 8000   
    jl #0044B73D                          ;#0044B730: 174 0B                     v  00 00  1 242      
    add qword[rbx+rax*4-16],1             ;#0044B732: 48:203104203 F0 01         u  00 09  3 243      
    cmp eax,425                           ;#0044B738: 075 A9010000               vu 00 01  1 245      
    mov [rbp-8] (prev),rax                ;#0044B73D: 48:211105 F8               uv 00 21  1 246      
    mov rdi,[rbp+40] (prevebp)            ;#0044B741: 48:213175 28               vu 80 20  1 246      
    mov rax,[rdi-64]                      ;#0044B745: 48:213107 C0               uv 01 80  1 249    *80*
    mov [rbp-16] (prst),rax               ;#0044B749: 48:211105 F0               uv 00 21  1 250 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044B74D: 48:213175 28               vu 80 20  1 250      
    mov rax,[rdi-144]                     ;#0044B751: 48:213207 70FFFFFF         uv 01 80  1 253    *80*
    mov [rbp-24] (prdx),rax               ;#0044B758: 48:211105 E8               uv 00 21  1 254 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044B75C: 48:213175 28               vu 80 20  1 254      
    mov rax,[rdi-152]                     ;#0044B760: 48:213207 68FFFFFF         uv 01 80  1 257    *80*
    xor rbx,rbx                           ;#0044B767: 48:061333                  vu 08 08  1 257      
    mov r15,h4                            ;#0044B76A: 49:277 0000000000000040    uv 8000 00  1 258      
    cmp rax,r15                           ;#0044B774: 4C:071370                  uv 00 8001  1 259 8000   
    jl #0044B784                          ;#0044B777: 174 0B                     v  00 00  1 259      
    add qword[rbx+rax*4-16],1             ;#0044B779: 48:203104203 F0 01         u  00 09  3 260      
    cmp eax,439                           ;#0044B77F: 075 B7010000               vu 00 01  1 262      
    mov [rbp-32] (o),rax                  ;#0044B784: 48:211105 E0               uv 00 21  1 263      
    mov rdi,[rbp+40] (prevebp)            ;#0044B788: 48:213175 28               vu 80 20  1 263      
    mov rax,[rdi-160]                     ;#0044B78C: 48:213207 60FFFFFF         uv 01 80  1 266    *80*
    xor rbx,rbx                           ;#0044B793: 48:061333                  vu 08 08  1 266      
    mov r15,h4                            ;#0044B796: 49:277 0000000000000040    uv 8000 00  1 267      
    cmp rax,r15                           ;#0044B7A0: 4C:071370                  uv 00 8001  1 268 8000   
    jl #0044B7B0                          ;#0044B7A3: 174 0B                     v  00 00  1 268      
    add qword[rbx+rax*4-16],1             ;#0044B7A5: 48:203104203 F0 01         u  00 09  3 269      
    cmp eax,440                           ;#0044B7AB: 075 B8010000               vu 00 01  1 271      
    mov [rbp-40] (idii),rax               ;#0044B7B0: 48:211105 D8               uv 00 21  1 272      
    mov qword[retaddr],#0044B7C1          ;#0044B7B4: 48:307105 20 C1B74400      vu 00 20  1 272      
    jmp #0044B17E (code:cdi)              ;#0044B7BC: 351 BDF9FFFF               v  00 00  1 273      
    push rax                              ;#0044B7C1: 120                        uv 00 01  1 274      
    mov rcx,[rbp-152] (symtab[439])       ;#0044B7C2: 48:213215 68FFFFFF         vu 02 20  1 274      
    mov r15,h4                            ;#0044B7C9: 49:277 0000000000000040    uv 8000 00  1 275      
    cmp rcx,r15                           ;#0044B7D3: 4C:071371                  uv 00 8002  1 276 8000   
    jle #0044B7E8                         ;#0044B7D6: 176 10                     v  00 00  1 276      
    sub qword[rbx+rcx*4-16],1             ;#0044B7D8: 48:203154213 F0 01         u  00 0A  3 277      
    jne #0044B7E8                         ;#0044B7DE: 165 08                     v  00 00  1 279      
    mov rdx,rcx                           ;#0044B7E0: 48:213321                  uv 04 02  1 280      
    call #004422DA (:%pDealloc)           ;#0044B7E3: 350 F26AFFFF               v  00 00  1 280      
    pop dword[rbp-152] (symtab[439])      ;#0044B7E8: 217205 68FFFFFF            np 00 20  3 281      
    mov rdi,2                             ;#0044B7EE: 48:307307 02000000         uv 80 00  1 284      
    lea rcx,[rbp-48] (this)               ;#0044B7F5: 48:215115 D0               vu 02 20  1 284      
    mov rsi,[rbp-152] (symtab[439])       ;#0044B7F9: 48:213265 68FFFFFF         uv 40 20  1 285      
    mov rdx,439                           ;#0044B800: 48:307302 B7010000         vu 04 00  1 285      
    call #00441675 (:%pSubse1)            ;#0044B807: 350 695EFFFF               v  00 00  1 286      
    mov rdi,1                             ;#0044B80C: 48:307307 01000000         uv 80 00  1 287      
    lea rcx,[rbp-64] (newprst)            ;#0044B813: 48:215115 C0               vu 02 20  1 287      
    mov rsi,[rbp-152] (symtab[439])       ;#0044B817: 48:213265 68FFFFFF         uv 40 20  1 288      
    mov rdx,439                           ;#0044B81E: 48:307302 B7010000         vu 04 00  1 288      
    call #004416F2 (:%pSubse1i)           ;#0044B825: 350 C85EFFFF               v  00 00  1 289      
    mov r15,h4                            ;#0044B82A: 49:277 0000000000000040    uv 8000 00  1 290      
    cmp rax,r15                           ;#0044B834: 4C:071370                  uv 00 8001  1 291 8000   
    jl #0044B845                          ;#0044B837: 174 0C                     v  00 00  1 291      
    mov rcx,427                           ;#0044B839: 48:307301 AB010000         uv 02 00  1 292      
    call #00442A58 (:%opTchkFail)         ;#0044B840: 350 1372FFFF               v  00 00  1 292      
;   315         end for
    mov rdi,[rbp-144] (i)                 ;#0044B845: 48:213275 70FFFFFF         uv 80 20  1 293      
    mov rcx,[rbp-120] (symtab[434])       ;#0044B84C: 48:213115 88               vu 02 20  1 293      
    add rdi,1                             ;#0044B850: 48:203307 01               uv 80 80  1 294      
    cmp rdi,rcx                           ;#0044B854: 48:073371                  uv 00 82  1 295 80   
    mov [rbp-144] (i),rdi                 ;#0044B857: 48:211275 70FFFFFF         vu 00 A0  1 295      
    jle #0044B6A4                         ;#0044B85E: 017216 40FEFFFF            v  00 00  1 296      
;   316         if newprst>1
    mov rsi,[rbp-64] (newprst)            ;#0044B864: 48:213165 C0               uv 40 20  1 297      
    cmp rsi,1                             ;#0044B868: 48:203376 01               uv 00 40  1 298 40   
    jg #0044B8A6                          ;#0044B86C: 177 38                     v  00 00  1 298      
;   317         or (length(idii) and
    mov rax,[rbp-40] (idii)               ;#0044B86E: 48:213105 D8               uv 01 20  1 299      
    mov rcx,[rbx+rax*4-24]                ;#0044B872: 48:213114203 E8            uv 02 09  1 302 01 *01*
    test rcx,ecx                          ;#0044B877: 205311                     uv 00 02  1 303 02   
    je #0044BDB3                          ;#0044B879: 017204 34050000            v  00 00  1 303      
;   318             wasstacklen<length(printstack)) then
    lea rdi,[rbp-168] (symtab[441])       ;#0044B87F: 48:215275 58FFFFFF         uv 80 20  1 304      
    mov rsi,[#00402638] (printstack)      ;#0044B886: 48:213065 AB6DFBFF         vu 40 00  1 304      
    mov rdx,391                           ;#0044B88D: 48:307302 87010000         uv 04 00  1 305      
    call #0043F28D (:%opLen)              ;#0044B894: 350 F439FFFF               v  00 00  1 305      
    mov rdi,[rbp-112] (wasstacklen)       ;#0044B899: 48:213175 90               uv 80 20  1 306      
    cmp rdi,rcx                           ;#0044B89D: 48:071317                  uv 00 82  1 307 80   
    jge #0044BDB3                         ;#0044B8A0: 017215 0D050000            v  00 00  1 307      
;   319             --
;   320             -- Something just got printed, so empty prev and 
;   321             -- force linebreaks all the way back up the call 
;   322             -- stack (which is done by returning prdx+1)
;   323             --
;   324             if length(prev) then
    mov rax,[rbp-8] (prev)                ;#0044B8A6: 48:213105 F8               uv 01 20  1 308      
    mov rsi,[rbx+rax*4-24]                ;#0044B8AA: 48:213164203 E8            uv 40 09  1 311 01 *01*
    test rsi,esi                          ;#0044B8AF: 205366                     uv 00 40  1 312 40   
    je #0044BA90                          ;#0044B8B1: 017204 D9010000            v  00 00  1 312      
;   325                 {prev,namedx} = subscr(prev,name,prst,prdx-1)
    lea rdi,[rbp-176] (symtab[442])       ;#0044B8B7: 48:215275 50FFFFFF         uv 80 20  1 313      
    mov rcx,[rbp-24] (prdx)               ;#0044B8BE: 48:213115 E8               vu 02 20  1 313      
    mov rax,qword[#00402030]              ;#0044B8C2: 48:213005 6767FBFF         uv 01 00  1 314      
    call #0043F4D8 (:%opSub)              ;#0044B8C9: 350 0A3CFFFF               v  00 00  1 314      
    mov rcx,5                             ;#0044B8CE: 48:307301 05000000         uv 02 00  1 315      
    mov rdx,399                           ;#0044B8D5: 48:307302 8F010000         vu 04 00  1 315      
    call #004428DB (:%opFrame) (subscr)   ;#0044B8DC: 350 FA6FFFFF               v  00 00  1 316      
    mov rdi,[rbp+40] (prevebp)            ;#0044B8E1: 48:213175 28               uv 80 20  1 317      
    mov rax,[rdi-8]                       ;#0044B8E5: 48:213107 F8               uv 01 80  1 320 80 *80*
    xor rbx,rbx                           ;#0044B8E9: 48:061333                  vu 08 08  1 320      
    mov r15,h4                            ;#0044B8EC: 49:277 0000000000000040    uv 8000 00  1 321      
    cmp rax,r15                           ;#0044B8F6: 4C:071370                  uv 00 8001  1 322 8000   
    jl #0044B906                          ;#0044B8F9: 174 0B                     v  00 00  1 322      
    add qword[rbx+rax*4-16],1             ;#0044B8FB: 48:203104203 F0 01         u  00 09  3 323      
    cmp eax,420                           ;#0044B901: 075 A4010000               vu 00 01  1 325      
    mov [rbp] (prev),rax                  ;#0044B906: 48:211105 00               uv 00 21  1 326      
    mov rdi,[rbp+40] (prevebp)            ;#0044B90A: 48:213175 28               vu 80 20  1 326      
    mov rax,[rdi]                         ;#0044B90E: 48:213007                  uv 01 80  1 329    *80*
    xor rbx,rbx                           ;#0044B911: 48:061333                  vu 08 08  1 329      
    mov r15,h4                            ;#0044B914: 49:277 0000000000000040    uv 8000 00  1 330      
    cmp rax,r15                           ;#0044B91E: 4C:071370                  uv 00 8001  1 331 8000   
    jl #0044B92E                          ;#0044B921: 174 0B                     v  00 00  1 331      
    add qword[rbx+rax*4-16],1             ;#0044B923: 48:203104203 F0 01         u  00 09  3 332      
    cmp eax,419                           ;#0044B929: 075 A3010000               vu 00 01  1 334      
    mov [rbp-8] (name),rax                ;#0044B92E: 48:211105 F8               uv 00 21  1 335      
    mov rdi,[rbp+40] (prevebp)            ;#0044B932: 48:213175 28               vu 80 20  1 335      
    mov rax,[rdi-16]                      ;#0044B936: 48:213107 F0               uv 01 80  1 338    *80*
    mov [rbp-16] (prst),rax               ;#0044B93A: 48:211105 F0               uv 00 21  1 339 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044B93E: 48:213175 28               vu 80 20  1 339      
    mov rax,[rdi-176]                     ;#0044B942: 48:213207 50FFFFFF         uv 01 80  1 342    *80*
    mov [rbp-24] (prdx),rax               ;#0044B949: 48:211105 E8               uv 00 21  1 343 01   
    mov qword[retaddr],#0044B95A          ;#0044B94D: 48:307105 20 5AB94400      vu 00 20  1 343      
    jmp #0044C8E1 (code:subscr)           ;#0044B955: 351 870F0000               v  00 00  1 344      
    push rax                              ;#0044B95A: 120                        uv 00 01  1 345      
    mov rdi,[rbp-136] (symtab[437])       ;#0044B95B: 48:213275 78FFFFFF         vu 80 20  1 345      
    mov r15,h4                            ;#0044B962: 49:277 0000000000000040    uv 8000 00  1 346      
    cmp rdi,r15                           ;#0044B96C: 4C:071377                  uv 00 8080  1 347 8000   
    jle #0044B981                         ;#0044B96F: 176 10                     v  00 00  1 347      
    sub qword[rbx+rdi*4-16],1             ;#0044B971: 48:203154273 F0 01         u  00 88  3 348      
    jne #0044B981                         ;#0044B977: 165 08                     v  00 00  1 350      
    mov rdx,rdi                           ;#0044B979: 48:213327                  uv 04 80  1 351      
    call #004422DA (:%pDealloc)           ;#0044B97C: 350 5969FFFF               v  00 00  1 351      
    pop dword[rbp-136] (symtab[437])      ;#0044B981: 217205 78FFFFFF            np 00 20  3 352      
    mov rdi,2                             ;#0044B987: 48:307307 02000000         uv 80 00  1 355      
    lea rcx,[rbp-56] (namedx)             ;#0044B98E: 48:215115 C8               vu 02 20  1 355      
    mov rsi,[rbp-136] (symtab[437])       ;#0044B992: 48:213265 78FFFFFF         uv 40 20  1 356      
    mov rdx,437                           ;#0044B999: 48:307302 B5010000         vu 04 00  1 356      
    call #00441675 (:%pSubse1)            ;#0044B9A0: 350 D05CFFFF               v  00 00  1 357      
    mov rdi,1                             ;#0044B9A5: 48:307307 01000000         uv 80 00  1 358      
    lea rcx,[rbp-8] (prev)                ;#0044B9AC: 48:215115 F8               vu 02 20  1 358      
    mov rsi,[rbp-136] (symtab[437])       ;#0044B9B0: 48:213265 78FFFFFF         uv 40 20  1 359      
    mov rdx,437                           ;#0044B9B7: 48:307302 B5010000         vu 04 00  1 359      
    call #00441675 (:%pSubse1)            ;#0044B9BE: 350 B25CFFFF               v  00 00  1 360      
    mov rcx,[rbp-8] (prev)                ;#0044B9C3: 48:213115 F8               uv 02 20  1 361      
    mov r15,h4                            ;#0044B9C7: 49:277 0000000000000040    vu 8000 00  1 361      
    cmp rcx,r15                           ;#0044B9D1: 4C:071371                  uv 00 8002  1 362      
    jl #0044B9DD                          ;#0044B9D4: 174 07                     v  00 00  1 362      
    cmp byte[rbx+rcx*4-1],#82             ;#0044B9D6: 200174213 FF 82            u  00 0A  2 363      
    je #0044B9E9                          ;#0044B9DB: 164 0C                     v  00 00  1 364      
    mov rcx,420                           ;#0044B9DD: 48:307301 A4010000         uv 02 00  1 365      
    call #00442A58 (:%opTchkFail)         ;#0044B9E4: 350 6F70FFFF               v  00 00  1 365      
;   326                 addtostack(idii,prst,namedx,prev)
    mov rcx,5                             ;#0044B9E9: 48:307301 05000000         uv 02 00  1 366      
    mov rdx,392                           ;#0044B9F0: 48:307302 88010000         vu 04 00  1 366      
    call :%opFrame (addtostack)           ;#0044B9F7: 350 DF6EFFFF               v  00 00  1 367      
    mov rdi,[rbp+40] (prevebp)            ;#0044B9FC: 48:213175 28               uv 80 20  1 368      
    mov rax,[rdi-40]                      ;#0044BA00: 48:213107 D8               uv 01 80  1 371 80 *80*
    xor rbx,rbx                           ;#0044BA04: 48:061333                  vu 08 08  1 371      
    mov r15,h4                            ;#0044BA07: 49:277 0000000000000040    uv 8000 00  1 372      
    cmp rax,r15                           ;#0044BA11: 4C:071370                  uv 00 8001  1 373 8000   
    jl #0044BA21                          ;#0044BA14: 174 0B                     v  00 00  1 373      
    add qword[rbx+rax*4-16],1             ;#0044BA16: 48:203104203 F0 01         u  00 09  3 374      
    cmp eax,424                           ;#0044BA1C: 075 A8010000               vu 00 01  1 376      
    mov [rbp] (idii),rax                  ;#0044BA21: 48:211105 00               uv 00 21  1 377      
    mov rdi,[rbp+40] (prevebp)            ;#0044BA25: 48:213175 28               vu 80 20  1 377      
    mov rax,[rdi-16]                      ;#0044BA29: 48:213107 F0               uv 01 80  1 380    *80*
    mov [rbp-8] (idxr),rax                ;#0044BA2D: 48:211105 F8               uv 00 21  1 381 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044BA31: 48:213175 28               vu 80 20  1 381      
    mov rax,[rdi-56]                      ;#0044BA35: 48:213107 C8               uv 01 80  1 384    *80*
    xor rbx,rbx                           ;#0044BA39: 48:061333                  vu 08 08  1 384      
    mov r15,h4                            ;#0044BA3C: 49:277 0000000000000040    uv 8000 00  1 385      
    cmp rax,r15                           ;#0044BA46: 4C:071370                  uv 00 8001  1 386 8000   
    jl #0044BA56                          ;#0044BA49: 174 0B                     v  00 00  1 386      
    add qword[rbx+rax*4-16],1             ;#0044BA4B: 48:203104203 F0 01         u  00 09  3 387      
    cmp eax,426                           ;#0044BA51: 075 AA010000               vu 00 01  1 389      
    mov [rbp-16] (name),rax               ;#0044BA56: 48:211105 F0               uv 00 21  1 390      
    mov rdi,[rbp+40] (prevebp)            ;#0044BA5A: 48:213175 28               vu 80 20  1 390      
    mov rax,[rdi-8]                       ;#0044BA5E: 48:213107 F8               uv 01 80  1 393    *80*
    xor rbx,rbx                           ;#0044BA62: 48:061333                  vu 08 08  1 393      
    mov r15,h4                            ;#0044BA65: 49:277 0000000000000040    uv 8000 00  1 394      
    cmp rax,r15                           ;#0044BA6F: 4C:071370                  uv 00 8001  1 395 8000   
    jl #0044BA7F                          ;#0044BA72: 174 0B                     v  00 00  1 395      
    add qword[rbx+rax*4-16],1             ;#0044BA74: 48:203104203 F0 01         u  00 09  3 396      
    cmp eax,420                           ;#0044BA7A: 075 A4010000               vu 00 01  1 398      
    mov [rbp-24] (text),rax               ;#0044BA7F: 48:211105 E8               uv 00 21  1 399      
    mov qword[retaddr],#0044BA90          ;#0044BA83: 48:307105 20 90BA4400      vu 00 20  1 399      
    jmp #0044B089 (code:addtostack)       ;#0044BA8B: 351 F9F5FFFF               v  00 00  1 400      
;   327             end if
;   328             if newprst<=lo then
    mov rdi,[rbp-64] (newprst)            ;#0044BA90: 48:213175 C0               uv 80 20  1 401      
    mov rsi,[rbp-72] (lo)                 ;#0044BA94: 48:213165 B8               vu 40 20  1 401      
    cmp rdi,rsi                           ;#0044BA98: 48:071367                  uv 00 C0  1 402      
    jg #0044BD41                          ;#0044BA9B: 017217 A0020000            v  00 00  1 402      
;   329                 if prdx!=-1 then
    mov rcx,[rbp-24] (prdx)               ;#0044BAA1: 48:213115 E8               uv 02 20  1 403      
    cmp rcx,-1                            ;#0044BAA5: 48:203371 FF               uv 00 02  1 404 02   
    je #0044BB73                          ;#0044BAA9: 017204 C4000000            v  00 00  1 404      
;   330                     name = sprintf("%s[%d]",{name,prdx})
    lea rax,[rbp-184] (symtab[443])       ;#0044BAAF: 48:215205 48FFFFFF         uv 01 20  1 405      
    mov rdx,2                             ;#0044BAB6: 48:307302 02000000         vu 04 00  1 405      
    push #0044BAEF                        ;#0044BABD: 150 EFBA4400               uv 00 00  1 406      
    push rax                              ;#0044BAC2: 120                        vu 00 01  1 406      
    push rcx                              ;#0044BAC3: 121                        uv 00 02  1 407      
    mov rax,[rbp] (name)                  ;#0044BAC4: 48:213105 00               vu 01 20  1 407      
    mov r15,h4                            ;#0044BAC8: 49:277 0000000000000040    uv 8000 00  1 408      
    cmp rax,r15                           ;#0044BAD2: 4C:071370                  uv 00 8001  1 409 8000   
    jl #0044BAE2                          ;#0044BAD5: 174 0B                     v  00 00  1 409      
    add qword[rbx+rax*4-16],1             ;#0044BAD7: 48:203104203 F0 01         u  00 09  3 410      
    cmp eax,419                           ;#0044BADD: 075 A3010000               vu 00 01  1 412      
    push rax                              ;#0044BAE2: 120                        uv 00 01  1 413      
    mov rdi,[rbp-184] (symtab[443])       ;#0044BAE3: 48:213275 48FFFFFF         vu 80 20  1 413      
    jmp #004404BD (:%pMkSq)               ;#0044BAEA: 351 CE49FFFF               v  00 00  1 414      
    mov rcx,33                            ;#0044BAEF: 48:307301 21000000         uv 02 00  1 415      
    mov rdx,89                            ;#0044BAF6: 48:307302 59000000         vu 04 00  1 415      
    call #004428DB (:%opFrame) (sprintf)  ;#0044BAFD: 350 D96DFFFF               v  00 00  1 416      
    mov rsi,qword[#00402640]              ;#0044BB02: 48:213065 376BFBFF         uv 40 00  1 417      
    mov [rbp] (format),rsi                ;#0044BB09: 48:211165 00               uv 00 60  1 418 40   
    add qword[rbx+rsi*4-16],1             ;#0044BB0D: 48:203104263 F0 01         u  00 48  3 420    *40*
    mov rdi,[rbp+40] (prevebp)            ;#0044BB13: 48:213175 28               vu 80 20  1 422      
    mov rax,[rdi-184]                     ;#0044BB17: 48:213207 48FFFFFF         uv 01 80  1 425    *80*
    xor rbx,rbx                           ;#0044BB1E: 48:061333                  vu 08 08  1 425      
    mov r15,h4                            ;#0044BB21: 49:277 0000000000000040    uv 8000 00  1 426      
    cmp rax,r15                           ;#0044BB2B: 4C:071370                  uv 00 8001  1 427 8000   
    jl #0044BB3B                          ;#0044BB2E: 174 0B                     v  00 00  1 427      
    add qword[rbx+rax*4-16],1             ;#0044BB30: 48:203104203 F0 01         u  00 09  3 428      
    cmp eax,443                           ;#0044BB36: 075 BB010000               vu 00 01  1 430      
    mov [rbp-8] (args),rax                ;#0044BB3B: 48:211105 F8               uv 00 21  1 431      
    mov qword[retaddr],#0044BB4C          ;#0044BB3F: 48:307105 20 4CBB4400      vu 00 20  1 431      
    jmp #0044E450 (code:sprintf)          ;#0044BB47: 351 04290000               v  00 00  1 432      
    push rax                              ;#0044BB4C: 120                        uv 00 01  1 433      
    mov rcx,[rbp] (name)                  ;#0044BB4D: 48:213115 00               vu 02 20  1 433      
    mov r15,h4                            ;#0044BB51: 49:277 0000000000000040    uv 8000 00  1 434      
    cmp rcx,r15                           ;#0044BB5B: 4C:071371                  uv 00 8002  1 435 8000   
    jle #0044BB70                         ;#0044BB5E: 176 10                     v  00 00  1 435      
    sub qword[rbx+rcx*4-16],1             ;#0044BB60: 48:203154213 F0 01         u  00 0A  3 436      
    jne #0044BB70                         ;#0044BB66: 165 08                     v  00 00  1 438      
    mov rdx,rcx                           ;#0044BB68: 48:213321                  uv 04 02  1 439      
    call #004422DA (:%pDealloc)           ;#0044BB6B: 350 6A67FFFF               v  00 00  1 439      
    pop dword[rbp] (name)                 ;#0044BB70: 217105 00                  np 00 20  3 440      
;   331                 end if
;   332                 {this,name} = subscr(this,name,newprst,lo)
    mov rcx,5                             ;#0044BB73: 48:307301 05000000         uv 02 00  1 443      
    mov rdx,399                           ;#0044BB7A: 48:307302 8F010000         vu 04 00  1 443      
    call #004428DB (:%opFrame) (subscr)   ;#0044BB81: 350 556DFFFF               v  00 00  1 444      
    mov rdi,[rbp+40] (prevebp)            ;#0044BB86: 48:213175 28               uv 80 20  1 445      
    mov rax,[rdi-48]                      ;#0044BB8A: 48:213107 D0               uv 01 80  1 448 80 *80*
    xor rbx,rbx                           ;#0044BB8E: 48:061333                  vu 08 08  1 448      
    mov r15,h4                            ;#0044BB91: 49:277 0000000000000040    uv 8000 00  1 449      
    cmp rax,r15                           ;#0044BB9B: 4C:071370                  uv 00 8001  1 450 8000   
    jl #0044BBAB                          ;#0044BB9E: 174 0B                     v  00 00  1 450      
    add qword[rbx+rax*4-16],1             ;#0044BBA0: 48:203104203 F0 01         u  00 09  3 451      
    cmp eax,425                           ;#0044BBA6: 075 A9010000               vu 00 01  1 453      
    mov [rbp] (prev),rax                  ;#0044BBAB: 48:211105 00               uv 00 21  1 454      
    mov rdi,[rbp+40] (prevebp)            ;#0044BBAF: 48:213175 28               vu 80 20  1 454      
    mov rax,[rdi]                         ;#0044BBB3: 48:213007                  uv 01 80  1 457    *80*
    xor rbx,rbx                           ;#0044BBB6: 48:061333                  vu 08 08  1 457      
    mov r15,h4                            ;#0044BBB9: 49:277 0000000000000040    uv 8000 00  1 458      
    cmp rax,r15                           ;#0044BBC3: 4C:071370                  uv 00 8001  1 459 8000   
    jl #0044BBD3                          ;#0044BBC6: 174 0B                     v  00 00  1 459      
    add qword[rbx+rax*4-16],1             ;#0044BBC8: 48:203104203 F0 01         u  00 09  3 460      
    cmp eax,419                           ;#0044BBCE: 075 A3010000               vu 00 01  1 462      
    mov [rbp-8] (name),rax                ;#0044BBD3: 48:211105 F8               uv 00 21  1 463      
    mov rdi,[rbp+40] (prevebp)            ;#0044BBD7: 48:213175 28               vu 80 20  1 463      
    mov rax,[rdi-64]                      ;#0044BBDB: 48:213107 C0               uv 01 80  1 466    *80*
    mov [rbp-16] (prst),rax               ;#0044BBDF: 48:211105 F0               uv 00 21  1 467 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044BBE3: 48:213175 28               vu 80 20  1 467      
    mov rax,[rdi-72]                      ;#0044BBE7: 48:213107 B8               uv 01 80  1 470    *80*
    mov [rbp-24] (prdx),rax               ;#0044BBEB: 48:211105 E8               uv 00 21  1 471 01   
    mov qword[retaddr],#0044BBFC          ;#0044BBEF: 48:307105 20 FCBB4400      vu 00 20  1 471      
    jmp #0044C8E1 (code:subscr)           ;#0044BBF7: 351 E50C0000               v  00 00  1 472      
    push rax                              ;#0044BBFC: 120                        uv 00 01  1 473      
    mov rdi,[rbp-184] (symtab[443])       ;#0044BBFD: 48:213275 48FFFFFF         vu 80 20  1 473      
    mov r15,h4                            ;#0044BC04: 49:277 0000000000000040    uv 8000 00  1 474      
    cmp rdi,r15                           ;#0044BC0E: 4C:071377                  uv 00 8080  1 475 8000   
    jle #0044BC23                         ;#0044BC11: 176 10                     v  00 00  1 475      
    sub qword[rbx+rdi*4-16],1             ;#0044BC13: 48:203154273 F0 01         u  00 88  3 476      
    jne #0044BC23                         ;#0044BC19: 165 08                     v  00 00  1 478      
    mov rdx,rdi                           ;#0044BC1B: 48:213327                  uv 04 80  1 479      
    call #004422DA (:%pDealloc)           ;#0044BC1E: 350 B766FFFF               v  00 00  1 479      
    pop dword[rbp-184] (symtab[443])      ;#0044BC23: 217205 48FFFFFF            np 00 20  3 480      
    mov rdi,2                             ;#0044BC29: 48:307307 02000000         uv 80 00  1 483      
    mov rcx,rbp                           ;#0044BC30: 48:213315                  vu 02 20  1 483      
    mov rsi,[rbp-184] (symtab[443])       ;#0044BC33: 48:213265 48FFFFFF         uv 40 20  1 484      
    mov rdx,443                           ;#0044BC3A: 48:307302 BB010000         vu 04 00  1 484      
    call #00441675 (:%pSubse1)            ;#0044BC41: 350 2F5AFFFF               v  00 00  1 485      
    mov rdi,1                             ;#0044BC46: 48:307307 01000000         uv 80 00  1 486      
    lea rcx,[rbp-48] (this)               ;#0044BC4D: 48:215115 D0               vu 02 20  1 486      
    mov rsi,[rbp-184] (symtab[443])       ;#0044BC51: 48:213265 48FFFFFF         uv 40 20  1 487      
    mov rdx,443                           ;#0044BC58: 48:307302 BB010000         vu 04 00  1 487      
    call #00441675 (:%pSubse1)            ;#0044BC5F: 350 115AFFFF               v  00 00  1 488      
;   333                 if dotdot then
    mov rcx,[rbp-96] (dotdot)             ;#0044BC64: 48:213115 A0               uv 02 20  1 489      
    test rcx,rcx                          ;#0044BC68: 48:205311                  uv 00 02  1 490 02   
    je #0044BC81                          ;#0044BC6B: 164 14                     v  00 00  1 490      
;   334                     this &= ".."
    lea rdx,[rbp-48] (this)               ;#0044BC6D: 48:215125 D0               uv 04 20  1 491      
    lea rdi,[rbp-48] (this)               ;#0044BC71: 48:215175 D0               vu 80 20  1 491      
    lea rcx,qword[#00402320]              ;#0044BC75: 48:215015 A466FBFF         uv 02 00  1 492      
    call #00440021 (:%opConcat)           ;#0044BC7C: 350 A043FFFF               v  00 00  1 492      
;   335                 end if
;   336                 addtostack(idii&newprst,newprst,name,this)
    lea rdx,[rbp-160] (symtab[440])       ;#0044BC81: 48:215225 60FFFFFF         uv 04 20  1 493      
    lea rdi,[rbp-40] (idii)               ;#0044BC88: 48:215175 D8               vu 80 20  1 493      
    lea rcx,[rbp-64] (newprst)            ;#0044BC8C: 48:215115 C0               uv 02 20  1 494      
    xor rax,rax                           ;#0044BC90: 48:061300                  vu 01 01  1 494      
    call #0043FC15 (:%opApnd)             ;#0044BC93: 350 7D3FFFFF               v  00 00  1 495      
    mov rcx,5                             ;#0044BC98: 48:307301 05000000         uv 02 00  1 496      
    mov rdx,392                           ;#0044BC9F: 48:307302 88010000         vu 04 00  1 496      
    call :%opFrame (addtostack)           ;#0044BCA6: 350 306CFFFF               v  00 00  1 497      
    mov rdi,[rbp+40] (prevebp)            ;#0044BCAB: 48:213175 28               uv 80 20  1 498      
    mov rax,[rdi-160]                     ;#0044BCAF: 48:213207 60FFFFFF         uv 01 80  1 501 80 *80*
    xor rbx,rbx                           ;#0044BCB6: 48:061333                  vu 08 08  1 501      
    mov r15,h4                            ;#0044BCB9: 49:277 0000000000000040    uv 8000 00  1 502      
    cmp rax,r15                           ;#0044BCC3: 4C:071370                  uv 00 8001  1 503 8000   
    jl #0044BCD3                          ;#0044BCC6: 174 0B                     v  00 00  1 503      
    add qword[rbx+rax*4-16],1             ;#0044BCC8: 48:203104203 F0 01         u  00 09  3 504      
    cmp eax,440                           ;#0044BCCE: 075 B8010000               vu 00 01  1 506      
    mov [rbp] (idii),rax                  ;#0044BCD3: 48:211105 00               uv 00 21  1 507      
    mov rdi,[rbp+40] (prevebp)            ;#0044BCD7: 48:213175 28               vu 80 20  1 507      
    mov rax,[rdi-64]                      ;#0044BCDB: 48:213107 C0               uv 01 80  1 510    *80*
    mov [rbp-8] (idxr),rax                ;#0044BCDF: 48:211105 F8               uv 00 21  1 511 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044BCE3: 48:213175 28               vu 80 20  1 511      
    mov rax,[rdi]                         ;#0044BCE7: 48:213007                  uv 01 80  1 514    *80*
    xor rbx,rbx                           ;#0044BCEA: 48:061333                  vu 08 08  1 514      
    mov r15,h4                            ;#0044BCED: 49:277 0000000000000040    uv 8000 00  1 515      
    cmp rax,r15                           ;#0044BCF7: 4C:071370                  uv 00 8001  1 516 8000   
    jl #0044BD07                          ;#0044BCFA: 174 0B                     v  00 00  1 516      
    add qword[rbx+rax*4-16],1             ;#0044BCFC: 48:203104203 F0 01         u  00 09  3 517      
    cmp eax,419                           ;#0044BD02: 075 A3010000               vu 00 01  1 519      
    mov [rbp-16] (name),rax               ;#0044BD07: 48:211105 F0               uv 00 21  1 520      
    mov rdi,[rbp+40] (prevebp)            ;#0044BD0B: 48:213175 28               vu 80 20  1 520      
    mov rax,[rdi-48]                      ;#0044BD0F: 48:213107 D0               uv 01 80  1 523    *80*
    xor rbx,rbx                           ;#0044BD13: 48:061333                  vu 08 08  1 523      
    mov r15,h4                            ;#0044BD16: 49:277 0000000000000040    uv 8000 00  1 524      
    cmp rax,r15                           ;#0044BD20: 4C:071370                  uv 00 8001  1 525 8000   
    jl #0044BD30                          ;#0044BD23: 174 0B                     v  00 00  1 525      
    add qword[rbx+rax*4-16],1             ;#0044BD25: 48:203104203 F0 01         u  00 09  3 526      
    cmp eax,425                           ;#0044BD2B: 075 A9010000               vu 00 01  1 528      
    mov [rbp-24] (text),rax               ;#0044BD30: 48:211105 E8               uv 00 21  1 529      
    mov qword[retaddr],#0044BD41          ;#0044BD34: 48:307105 20 41BD4400      vu 00 20  1 529      
    jmp #0044B089 (code:addtostack)       ;#0044BD3C: 351 48F3FFFF               v  00 00  1 530      
;   337             end if
;   338             return {prdx+1,""}
    lea rdi,[rbp-176] (symtab[442])       ;#0044BD41: 48:215275 50FFFFFF         uv 80 20  1 531      
    mov rcx,[rbp-24] (prdx)               ;#0044BD48: 48:213115 E8               vu 02 20  1 531      
    mov rax,qword[#00402030]              ;#0044BD4C: 48:213005 DD62FBFF         uv 01 00  1 532      
    call #0043F4AF (:%opAdd)              ;#0044BD53: 350 5737FFFF               v  00 00  1 532      
    lea rax,[rbp-192] (symtab[444])       ;#0044BD58: 48:215205 40FFFFFF         uv 01 20  1 533      
    mov rdx,2                             ;#0044BD5F: 48:307302 02000000         vu 04 00  1 533      
    push #0044BDA0                        ;#0044BD66: 150 A0BD4400               uv 00 00  1 534      
    push rax                              ;#0044BD6B: 120                        vu 00 01  1 534      
    mov rdi,qword[#00402240]              ;#0044BD6C: 48:213075 CD64FBFF         uv 80 00  1 535      
    mov r15,h4                            ;#0044BD73: 49:277 0000000000000040    vu 8000 00  1 535      
    cmp rdi,r15                           ;#0044BD7D: 4C:071377                  uv 00 8080  1 536      
    jl #0044BD8D                          ;#0044BD80: 174 0B                     v  00 00  1 536      
    add qword[rbx+rdi*4-16],1             ;#0044BD82: 48:203104273 F0 01         u  00 88  3 537      
    cmp eax,169                           ;#0044BD88: 075 A9000000               vu 00 01  1 539      
    push rdi                              ;#0044BD8D: 127                        uv 00 80  1 540      
    push qword[rbp-176] (symtab[442])     ;#0044BD8E: 377265 50FFFFFF            np 00 20  2 541      
    mov rdi,[rbp-192] (symtab[444])       ;#0044BD94: 48:213275 40FFFFFF         uv 80 20  1 543      
    jmp #004404BD (:%pMkSq)               ;#0044BD9B: 351 1D47FFFF               v  00 00  1 543      
    mov rax,[rbp-192] (symtab[444])       ;#0044BDA0: 48:213205 40FFFFFF         uv 01 20  1 544      
    mov [rbp-192] (symtab[444]),rbx       ;#0044BDA7: 48:211235 40FFFFFF         vu 00 28  1 544      
    jmp #0044298D (:%opRetf)              ;#0044BDAE: 351 DA6BFFFF               v  00 00  1 545      
;   339         end if
;   340         this = "{"&this&"}"
    mov rcx,3                             ;#0044BDB3: 48:307301 03000000         uv 02 00  1 546      
    push #0044BDD7                        ;#0044BDBA: 150 D7BD4400               vu 00 00  1 546      
    push qword[#00402330]                 ;#0044BDBF: 377065 6B65FBFF            np 00 00  2 547      
    push qword[rbp-48] (this)             ;#0044BDC5: 377165 D0                  np 00 20  2 549      
    push qword[#00402328]                 ;#0044BDC8: 377065 5A65FBFF            np 00 00  2 551      
    lea rax,[rbp-48] (this)               ;#0044BDCE: 48:215105 D0               uv 01 20  1 553      
    jmp #004402C2 (:%opConcatN)           ;#0044BDD2: 351 EB44FFFF               v  00 00  1 553      
;   341     end if
;   342     if dotdot then
    mov rsi,[rbp-96] (dotdot)             ;#0044BDD7: 48:213165 A0               uv 40 20  1 554      
    test rsi,rsi                          ;#0044BDDB: 48:205366                  uv 00 40  1 555 40   
    je #0044BE13                          ;#0044BDDE: 164 33                     v  00 00  1 555      
;   343         this &= ".."
    mov rcx,[rbp-48] (this)               ;#0044BDE0: 48:213115 D0               uv 02 20  1 556      
    mov r15,h4                            ;#0044BDE4: 49:277 0000000000000040    vu 8000 00  1 556      
    cmp rcx,r15                           ;#0044BDEE: 4C:071371                  uv 00 8002  1 557      
    jne #0044BDFF                         ;#0044BDF1: 165 0C                     v  00 00  1 557      
    mov rsi,425                           ;#0044BDF3: 48:307306 A9010000         uv 40 00  1 558      
    call #00442D75 (:%pUnassigned)        ;#0044BDFA: 350 766FFFFF               v  00 00  1 558      
    lea rdx,[rbp-48] (this)               ;#0044BDFF: 48:215125 D0               uv 04 20  1 559      
    lea rdi,[rbp-48] (this)               ;#0044BE03: 48:215175 D0               vu 80 20  1 559      
    lea rcx,qword[#00402320]              ;#0044BE07: 48:215015 1265FBFF         uv 02 00  1 560      
    call #00440021 (:%opConcat)           ;#0044BE0E: 350 0E42FFFF               v  00 00  1 560      
;   344     end if
;   345     lp = length(prev)
    mov rdi,[rbp-8] (prev)                ;#0044BE13: 48:213175 F8               uv 80 20  1 561      
    mov rax,[rbx+rdi*4-24]                ;#0044BE17: 48:48:213104273 E8         uv 01 88  1 564 80 *80*
    mov [rbp-80] (lp),rax                 ;#0044BE1D: 48:211105 B0               uv 00 21  1 565 01   
;   346     lt = length(name)+4+length(this)    -- (+4 is for " = " and a ',')
    mov rsi,[rbp] (name)                  ;#0044BE21: 48:213165 00               vu 40 20  1 565      
    mov rcx,[rbx+rsi*4-24]                ;#0044BE25: 48:48:213114263 E8         uv 02 48  1 568    *40*
    mov [rbp-168] (symtab[441]),rcx       ;#0044BE2B: 48:211215 58FFFFFF         uv 00 22  1 569 02   
    lea rdi,[rbp-176] (symtab[442])       ;#0044BE32: 48:215275 50FFFFFF         vu 80 20  1 569      
    mov rax,[#004020A8] (D_YEAR)          ;#0044BE39: 48:213005 6862FBFF         uv 01 00  1 570      
    call #0043F4AF (:%opAdd)              ;#0044BE40: 350 6A36FFFF               v  00 00  1 570      
    lea rdi,[rbp-168] (symtab[441])       ;#0044BE45: 48:215275 58FFFFFF         uv 80 20  1 571      
    mov rsi,[rbp-48] (this)               ;#0044BE4C: 48:213165 D0               vu 40 20  1 571      
    mov rdx,425                           ;#0044BE50: 48:307302 A9010000         uv 04 00  1 572      
    call #0043F28D (:%opLen)              ;#0044BE57: 350 3134FFFF               v  00 00  1 572      
    lea rdi,[rbp-88] (lt)                 ;#0044BE5C: 48:215175 A8               uv 80 20  1 573      
    mov rcx,[rbp-176] (symtab[442])       ;#0044BE60: 48:213215 50FFFFFF         vu 02 20  1 573      
    mov rax,[rbp-168] (symtab[441])       ;#0044BE67: 48:213205 58FFFFFF         uv 01 20  1 574      
    call #0043F4BE (:%opAddi)             ;#0044BE6E: 350 4B36FFFF               v  00 00  1 574      
;   347 
;   348     while 1 do -- (max 2 iterations, before splitting long strings)
;   349         if lp=0 then
    mov rdi,[rbp-80] (lp)                 ;#0044BE73: 48:213175 B0               uv 80 20  1 575      
    cmp rdi,0                             ;#0044BE77: 48:203377 00               uv 00 80  1 576 80   
    jne #0044BF1F                         ;#0044BE7B: 017205 9E000000            v  00 00  1 576      
;   350             if not stringo              -- (any splitting already done)
    mov rsi,[rbp-104] (stringo)           ;#0044BE81: 48:213165 98               uv 40 20  1 577      
    test rsi,rsi                          ;#0044BE85: 48:205366                  uv 00 40  1 578 40   
    je #0044BEC5                          ;#0044BE88: 164 3B                     v  00 00  1 578      
;   351             or lt+lp<MAXLINELEN then    -- (or no need to split string)
    lea rdi,[rbp-176] (symtab[442])       ;#0044BE8A: 48:215275 50FFFFFF         uv 80 20  1 579      
    mov rcx,[rbp-88] (lt)                 ;#0044BE91: 48:213115 A8               vu 02 20  1 579      
    mov rax,[rbp-80] (lp)                 ;#0044BE95: 48:213105 B0               uv 01 20  1 580      
    call #0043F4AF (:%opAdd)              ;#0044BE99: 350 1136FFFF               v  00 00  1 580      
    mov rdi,77                            ;#0044BE9E: 48:307307 4D000000         uv 80 00  1 581      
    mov rax,[rbp-176] (symtab[442])       ;#0044BEA5: 48:213205 50FFFFFF         vu 01 20  1 581      
    mov rsi,388                           ;#0044BEAC: 48:307306 84010000         uv 40 00  1 582      
    mov rdx,442                           ;#0044BEB3: 48:307302 BA010000         vu 04 00  1 582      
    call #0043FA81 (:%opJcc)              ;#0044BEBA: 350 C23BFFFF               v  00 00  1 583      
    jge #0044C1CF                         ;#0044BEBF: 017215 0A030000            v  00 00  1 584      
;   352                 return {prst,this}
    lea rax,[rbp-192] (symtab[444])       ;#0044BEC5: 48:215205 40FFFFFF         uv 01 20  1 585      
    mov rdx,2                             ;#0044BECC: 48:307302 02000000         vu 04 00  1 585      
    push #0044BF07                        ;#0044BED3: 150 07BF4400               uv 00 00  1 586      
    push rax                              ;#0044BED8: 120                        vu 00 01  1 586      
    mov rdi,[rbp-48] (this)               ;#0044BED9: 48:213175 D0               uv 80 20  1 587      
    mov r15,h4                            ;#0044BEDD: 49:277 0000000000000040    vu 8000 00  1 587      
    cmp rdi,r15                           ;#0044BEE7: 4C:071377                  uv 00 8080  1 588      
    jl #0044BEF7                          ;#0044BEEA: 174 0B                     v  00 00  1 588      
    add qword[rbx+rdi*4-16],1             ;#0044BEEC: 48:203104273 F0 01         u  00 88  3 589      
    cmp eax,425                           ;#0044BEF2: 075 A9010000               vu 00 01  1 591      
    push rdi                              ;#0044BEF7: 127                        uv 00 80  1 592      
    push qword[rbp-16] (prst)             ;#0044BEF8: 377165 F0                  np 00 20  2 593      
    mov rdi,[rbp-192] (symtab[444])       ;#0044BEFB: 48:213275 40FFFFFF         uv 80 20  1 595      
    jmp #004404BD (:%pMkSq)               ;#0044BF02: 351 B645FFFF               v  00 00  1 595      
    mov rax,[rbp-192] (symtab[444])       ;#0044BF07: 48:213205 40FFFFFF         uv 01 20  1 596      
    mov [rbp-192] (symtab[444]),rbx       ;#0044BF0E: 48:211235 40FFFFFF         vu 00 28  1 596      
    jmp #0044298D (:%opRetf)              ;#0044BF15: 351 736AFFFF               v  00 00  1 597      
;   353             end if
;   354             exit
    jmp #0044C1CF                         ;#0044BF1A: 351 B0020000               v  00 00  1 598      
;   355         else
;   356             if lt+lp<MAXLINELEN then
    lea rdi,[rbp-176] (symtab[442])       ;#0044BF1F: 48:215275 50FFFFFF         uv 80 20  1 599      
    mov rcx,[rbp-88] (lt)                 ;#0044BF26: 48:213115 A8               vu 02 20  1 599      
    mov rax,[rbp-80] (lp)                 ;#0044BF2A: 48:213105 B0               uv 01 20  1 600      
    call #0043F4AF (:%opAdd)              ;#0044BF2E: 350 7C35FFFF               v  00 00  1 600      
    mov rdi,77                            ;#0044BF33: 48:307307 4D000000         uv 80 00  1 601      
    mov rax,[rbp-176] (symtab[442])       ;#0044BF3A: 48:213205 50FFFFFF         vu 01 20  1 601      
    mov rsi,388                           ;#0044BF41: 48:307306 84010000         uv 40 00  1 602      
    mov rdx,442                           ;#0044BF48: 48:307302 BA010000         vu 04 00  1 602      
    call #0043FA81 (:%opJcc)              ;#0044BF4F: 350 2D3BFFFF               v  00 00  1 603      
    jge #0044BFE5                         ;#0044BF54: 017215 8B000000            v  00 00  1 604      
;   357                 -- note that we are clearly returning a partial result here,
;   358                 -- of say "1,2,3" rather than "{1,2,3}".
;   359                 return {prst,prev&','&this}
    mov rsi,[rbp-48] (this)               ;#0044BF5A: 48:213165 D0               uv 40 20  1 605      
    mov r15,h4                            ;#0044BF5E: 49:277 0000000000000040    vu 8000 00  1 605      
    cmp rsi,r15                           ;#0044BF68: 4C:071376                  uv 00 8040  1 606      
    jne #0044BF79                         ;#0044BF6B: 165 0C                     v  00 00  1 606      
    mov rsi,425                           ;#0044BF6D: 48:307306 A9010000         uv 40 00  1 607      
    call #00442D75 (:%pUnassigned)        ;#0044BF74: 350 FC6DFFFF               v  00 00  1 607      
    mov rcx,3                             ;#0044BF79: 48:307301 03000000         uv 02 00  1 608      
    push #0044BF9D                        ;#0044BF80: 150 9DBF4400               vu 00 00  1 608      
    push qword[rbp-48] (this)             ;#0044BF85: 377165 D0                  np 00 20  2 609      
    push qword[#004022A0]                 ;#0044BF88: 377065 1263FBFF            np 00 00  2 611      
    push qword[rbp-8] (prev)              ;#0044BF8E: 377165 F8                  np 00 20  2 613      
    lea rax,[rbp-160] (symtab[440])       ;#0044BF91: 48:215205 60FFFFFF         uv 01 20  1 615      
    jmp #004402C2 (:%opConcatN)           ;#0044BF98: 351 2543FFFF               v  00 00  1 615      
    lea rax,[rbp-192] (symtab[444])       ;#0044BF9D: 48:215205 40FFFFFF         uv 01 20  1 616      
    mov rdx,2                             ;#0044BFA4: 48:307302 02000000         vu 04 00  1 616      
    push #0044BFCD                        ;#0044BFAB: 150 CDBF4400               uv 00 00  1 617      
    push rax                              ;#0044BFB0: 120                        vu 00 01  1 617      
    push qword[rbp-160] (symtab[440])     ;#0044BFB1: 377265 60FFFFFF            np 00 20  2 618      
    mov [rbp-160] (symtab[440]),rbx       ;#0044BFB7: 48:211235 60FFFFFF         uv 00 28  1 620      
    push qword[rbp-16] (prst)             ;#0044BFBE: 377165 F0                  np 00 20  2 621      
    mov rdi,[rbp-192] (symtab[444])       ;#0044BFC1: 48:213275 40FFFFFF         uv 80 20  1 623      
    jmp #004404BD (:%pMkSq)               ;#0044BFC8: 351 F044FFFF               v  00 00  1 623      
    mov rax,[rbp-192] (symtab[444])       ;#0044BFCD: 48:213205 40FFFFFF         uv 01 20  1 624      
    mov [rbp-192] (symtab[444]),rbx       ;#0044BFD4: 48:211235 40FFFFFF         vu 00 28  1 624      
    jmp #0044298D (:%opRetf)              ;#0044BFDB: 351 AD69FFFF               v  00 00  1 625      
    jmp #0044BE73                         ;#0044BFE0: 351 8EFEFFFF               v  00 00  1 626      
;   360             else
;   361                 {prev,namedx} = subscr(prev,name,prst,prdx-1)
    lea rdi,[rbp-176] (symtab[442])       ;#0044BFE5: 48:215275 50FFFFFF         uv 80 20  1 627      
    mov rcx,[rbp-24] (prdx)               ;#0044BFEC: 48:213115 E8               vu 02 20  1 627      
    mov rax,qword[#00402030]              ;#0044BFF0: 48:213005 3960FBFF         uv 01 00  1 628      
    call #0043F4D8 (:%opSub)              ;#0044BFF7: 350 DC34FFFF               v  00 00  1 628      
    mov rcx,5                             ;#0044BFFC: 48:307301 05000000         uv 02 00  1 629      
    mov rdx,399                           ;#0044C003: 48:307302 8F010000         vu 04 00  1 629      
    call #004428DB (:%opFrame) (subscr)   ;#0044C00A: 350 CC68FFFF               v  00 00  1 630      
    mov rdi,[rbp+40] (prevebp)            ;#0044C00F: 48:213175 28               uv 80 20  1 631      
    mov rax,[rdi-8]                       ;#0044C013: 48:213107 F8               uv 01 80  1 634 80 *80*
    xor rbx,rbx                           ;#0044C017: 48:061333                  vu 08 08  1 634      
    mov r15,h4                            ;#0044C01A: 49:277 0000000000000040    uv 8000 00  1 635      
    cmp rax,r15                           ;#0044C024: 4C:071370                  uv 00 8001  1 636 8000   
    jl #0044C034                          ;#0044C027: 174 0B                     v  00 00  1 636      
    add qword[rbx+rax*4-16],1             ;#0044C029: 48:203104203 F0 01         u  00 09  3 637      
    cmp eax,420                           ;#0044C02F: 075 A4010000               vu 00 01  1 639      
    mov [rbp] (prev),rax                  ;#0044C034: 48:211105 00               uv 00 21  1 640      
    mov rdi,[rbp+40] (prevebp)            ;#0044C038: 48:213175 28               vu 80 20  1 640      
    mov rax,[rdi]                         ;#0044C03C: 48:213007                  uv 01 80  1 643    *80*
    xor rbx,rbx                           ;#0044C03F: 48:061333                  vu 08 08  1 643      
    mov r15,h4                            ;#0044C042: 49:277 0000000000000040    uv 8000 00  1 644      
    cmp rax,r15                           ;#0044C04C: 4C:071370                  uv 00 8001  1 645 8000   
    jl #0044C05C                          ;#0044C04F: 174 0B                     v  00 00  1 645      
    add qword[rbx+rax*4-16],1             ;#0044C051: 48:203104203 F0 01         u  00 09  3 646      
    cmp eax,419                           ;#0044C057: 075 A3010000               vu 00 01  1 648      
    mov [rbp-8] (name),rax                ;#0044C05C: 48:211105 F8               uv 00 21  1 649      
    mov rdi,[rbp+40] (prevebp)            ;#0044C060: 48:213175 28               vu 80 20  1 649      
    mov rax,[rdi-16]                      ;#0044C064: 48:213107 F0               uv 01 80  1 652    *80*
    mov [rbp-16] (prst),rax               ;#0044C068: 48:211105 F0               uv 00 21  1 653 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044C06C: 48:213175 28               vu 80 20  1 653      
    mov rax,[rdi-176]                     ;#0044C070: 48:213207 50FFFFFF         uv 01 80  1 656    *80*
    mov [rbp-24] (prdx),rax               ;#0044C077: 48:211105 E8               uv 00 21  1 657 01   
    mov qword[retaddr],#0044C088          ;#0044C07B: 48:307105 20 88C04400      vu 00 20  1 657      
    jmp #0044C8E1 (code:subscr)           ;#0044C083: 351 59080000               v  00 00  1 658      
    push rax                              ;#0044C088: 120                        uv 00 01  1 659      
    mov rsi,[rbp-192] (symtab[444])       ;#0044C089: 48:213265 40FFFFFF         vu 40 20  1 659      
    mov r15,h4                            ;#0044C090: 49:277 0000000000000040    uv 8000 00  1 660      
    cmp rsi,r15                           ;#0044C09A: 4C:071376                  uv 00 8040  1 661 8000   
    jle #0044C0AF                         ;#0044C09D: 176 10                     v  00 00  1 661      
    sub qword[rbx+rsi*4-16],1             ;#0044C09F: 48:203154263 F0 01         u  00 48  3 662      
    jne #0044C0AF                         ;#0044C0A5: 165 08                     v  00 00  1 664      
    mov rdx,rsi                           ;#0044C0A7: 48:213326                  uv 04 40  1 665      
    call #004422DA (:%pDealloc)           ;#0044C0AA: 350 2B62FFFF               v  00 00  1 665      
    pop dword[rbp-192] (symtab[444])      ;#0044C0AF: 217205 40FFFFFF            np 00 20  3 666      
    mov rdi,2                             ;#0044C0B5: 48:307307 02000000         uv 80 00  1 669      
    lea rcx,[rbp-56] (namedx)             ;#0044C0BC: 48:215115 C8               vu 02 20  1 669      
    mov rsi,[rbp-192] (symtab[444])       ;#0044C0C0: 48:213265 40FFFFFF         uv 40 20  1 670      
    mov rdx,444                           ;#0044C0C7: 48:307302 BC010000         vu 04 00  1 670      
    call #00441675 (:%pSubse1)            ;#0044C0CE: 350 A255FFFF               v  00 00  1 671      
    mov rdi,1                             ;#0044C0D3: 48:307307 01000000         uv 80 00  1 672      
    lea rcx,[rbp-8] (prev)                ;#0044C0DA: 48:215115 F8               vu 02 20  1 672      
    mov rsi,[rbp-192] (symtab[444])       ;#0044C0DE: 48:213265 40FFFFFF         uv 40 20  1 673      
    mov rdx,444                           ;#0044C0E5: 48:307302 BC010000         vu 04 00  1 673      
    call #00441675 (:%pSubse1)            ;#0044C0EC: 350 8455FFFF               v  00 00  1 674      
    mov rdi,[rbp-8] (prev)                ;#0044C0F1: 48:213175 F8               uv 80 20  1 675      
    mov r15,h4                            ;#0044C0F5: 49:277 0000000000000040    vu 8000 00  1 675      
    cmp rdi,r15                           ;#0044C0FF: 4C:071377                  uv 00 8080  1 676      
    jl #0044C10B                          ;#0044C102: 174 07                     v  00 00  1 676      
    cmp byte[rbx+rdi*4-1],#82             ;#0044C104: 200174273 FF 82            u  00 88  2 677      
    je #0044C117                          ;#0044C109: 164 0C                     v  00 00  1 678      
    mov rcx,420                           ;#0044C10B: 48:307301 A4010000         uv 02 00  1 679      
    call #00442A58 (:%opTchkFail)         ;#0044C112: 350 4169FFFF               v  00 00  1 679      
;   362                 addtostack(idii,prst,namedx,prev)
    mov rcx,5                             ;#0044C117: 48:307301 05000000         uv 02 00  1 680      
    mov rdx,392                           ;#0044C11E: 48:307302 88010000         vu 04 00  1 680      
    call :%opFrame (addtostack)           ;#0044C125: 350 B167FFFF               v  00 00  1 681      
    mov rdi,[rbp+40] (prevebp)            ;#0044C12A: 48:213175 28               uv 80 20  1 682      
    mov rax,[rdi-40]                      ;#0044C12E: 48:213107 D8               uv 01 80  1 685 80 *80*
    xor rbx,rbx                           ;#0044C132: 48:061333                  vu 08 08  1 685      
    mov r15,h4                            ;#0044C135: 49:277 0000000000000040    uv 8000 00  1 686      
    cmp rax,r15                           ;#0044C13F: 4C:071370                  uv 00 8001  1 687 8000   
    jl #0044C14F                          ;#0044C142: 174 0B                     v  00 00  1 687      
    add qword[rbx+rax*4-16],1             ;#0044C144: 48:203104203 F0 01         u  00 09  3 688      
    cmp eax,424                           ;#0044C14A: 075 A8010000               vu 00 01  1 690      
    mov [rbp] (idii),rax                  ;#0044C14F: 48:211105 00               uv 00 21  1 691      
    mov rdi,[rbp+40] (prevebp)            ;#0044C153: 48:213175 28               vu 80 20  1 691      
    mov rax,[rdi-16]                      ;#0044C157: 48:213107 F0               uv 01 80  1 694    *80*
    mov [rbp-8] (idxr),rax                ;#0044C15B: 48:211105 F8               uv 00 21  1 695 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044C15F: 48:213175 28               vu 80 20  1 695      
    mov rax,[rdi-56]                      ;#0044C163: 48:213107 C8               uv 01 80  1 698    *80*
    xor rbx,rbx                           ;#0044C167: 48:061333                  vu 08 08  1 698      
    mov r15,h4                            ;#0044C16A: 49:277 0000000000000040    uv 8000 00  1 699      
    cmp rax,r15                           ;#0044C174: 4C:071370                  uv 00 8001  1 700 8000   
    jl #0044C184                          ;#0044C177: 174 0B                     v  00 00  1 700      
    add qword[rbx+rax*4-16],1             ;#0044C179: 48:203104203 F0 01         u  00 09  3 701      
    cmp eax,426                           ;#0044C17F: 075 AA010000               vu 00 01  1 703      
    mov [rbp-16] (name),rax               ;#0044C184: 48:211105 F0               uv 00 21  1 704      
    mov rdi,[rbp+40] (prevebp)            ;#0044C188: 48:213175 28               vu 80 20  1 704      
    mov rax,[rdi-8]                       ;#0044C18C: 48:213107 F8               uv 01 80  1 707    *80*
    xor rbx,rbx                           ;#0044C190: 48:061333                  vu 08 08  1 707      
    mov r15,h4                            ;#0044C193: 49:277 0000000000000040    uv 8000 00  1 708      
    cmp rax,r15                           ;#0044C19D: 4C:071370                  uv 00 8001  1 709 8000   
    jl #0044C1AD                          ;#0044C1A0: 174 0B                     v  00 00  1 709      
    add qword[rbx+rax*4-16],1             ;#0044C1A2: 48:203104203 F0 01         u  00 09  3 710      
    cmp eax,420                           ;#0044C1A8: 075 A4010000               vu 00 01  1 712      
    mov [rbp-24] (text),rax               ;#0044C1AD: 48:211105 E8               uv 00 21  1 713      
    mov qword[retaddr],#0044C1BE          ;#0044C1B1: 48:307105 20 BEC14400      vu 00 20  1 713      
    jmp #0044B089 (code:addtostack)       ;#0044C1B9: 351 CBEEFFFF               v  00 00  1 714      
;   363                 lp = 0
    mov [rbp-80] (lp),rbx                 ;#0044C1BE: 48:211135 B0               uv 00 28  1 715      
;   364                 prst = prdx
    mov rcx,[rbp-24] (prdx)               ;#0044C1C2: 48:213115 E8               vu 02 20  1 715      
    mov [rbp-16] (prst),rcx               ;#0044C1C6: 48:211115 F0               uv 00 22  1 716      
;   365             end if
;   366         end if
;   367     end while
    jmp #0044BE73                         ;#0044C1CA: 351 A4FCFFFF               v  00 00  1 716      
;   368 
;   369     if stringo then
    mov rsi,[rbp-104] (stringo)           ;#0044C1CF: 48:213165 98               uv 40 20  1 717      
    test rsi,rsi                          ;#0044C1D3: 48:205366                  uv 00 40  1 718 40   
    je #0044C88C                          ;#0044C1D6: 017204 B0060000            v  00 00  1 718      
;   370         --
;   371         -- One that wouldn't fit, so split if needed and
;   372         -- force linebreaks all the way back up the call 
;   373         -- stack (which is done by returning prdx+1)
;   374         --
;   375         if prdx!=-1 then
    mov rdi,[rbp-24] (prdx)               ;#0044C1DC: 48:213175 E8               uv 80 20  1 719      
    cmp rdi,-1                            ;#0044C1E0: 48:203377 FF               uv 00 80  1 720 80   
    je #0044C2AE                          ;#0044C1E4: 017204 C4000000            v  00 00  1 720      
;   376             name = sprintf("%s[%d]",{name,prdx})
    lea rax,[rbp-200] (symtab[445])       ;#0044C1EA: 48:215205 38FFFFFF         uv 01 20  1 721      
    mov rdx,2                             ;#0044C1F1: 48:307302 02000000         vu 04 00  1 721      
    push #0044C22A                        ;#0044C1F8: 150 2AC24400               uv 00 00  1 722      
    push rax                              ;#0044C1FD: 120                        vu 00 01  1 722      
    push rdi                              ;#0044C1FE: 127                        uv 00 80  1 723      
    mov rax,[rbp] (name)                  ;#0044C1FF: 48:213105 00               vu 01 20  1 723      
    mov r15,h4                            ;#0044C203: 49:277 0000000000000040    uv 8000 00  1 724      
    cmp rax,r15                           ;#0044C20D: 4C:071370                  uv 00 8001  1 725 8000   
    jl #0044C21D                          ;#0044C210: 174 0B                     v  00 00  1 725      
    add qword[rbx+rax*4-16],1             ;#0044C212: 48:203104203 F0 01         u  00 09  3 726      
    cmp eax,419                           ;#0044C218: 075 A3010000               vu 00 01  1 728      
    push rax                              ;#0044C21D: 120                        uv 00 01  1 729      
    mov rdi,[rbp-200] (symtab[445])       ;#0044C21E: 48:213275 38FFFFFF         vu 80 20  1 729      
    jmp #004404BD (:%pMkSq)               ;#0044C225: 351 9342FFFF               v  00 00  1 730      
    mov rcx,33                            ;#0044C22A: 48:307301 21000000         uv 02 00  1 731      
    mov rdx,89                            ;#0044C231: 48:307302 59000000         vu 04 00  1 731      
    call #004428DB (:%opFrame) (sprintf)  ;#0044C238: 350 9E66FFFF               v  00 00  1 732      
    mov rcx,qword[#00402640]              ;#0044C23D: 48:213015 FC63FBFF         uv 02 00  1 733      
    mov [rbp] (format),rcx                ;#0044C244: 48:211115 00               uv 00 22  1 734 02   
    add qword[rbx+rcx*4-16],1             ;#0044C248: 48:203104213 F0 01         u  00 0A  3 736    *02*
    mov rdi,[rbp+40] (prevebp)            ;#0044C24E: 48:213175 28               vu 80 20  1 738      
    mov rax,[rdi-200]                     ;#0044C252: 48:213207 38FFFFFF         uv 01 80  1 741    *80*
    xor rbx,rbx                           ;#0044C259: 48:061333                  vu 08 08  1 741      
    mov r15,h4                            ;#0044C25C: 49:277 0000000000000040    uv 8000 00  1 742      
    cmp rax,r15                           ;#0044C266: 4C:071370                  uv 00 8001  1 743 8000   
    jl #0044C276                          ;#0044C269: 174 0B                     v  00 00  1 743      
    add qword[rbx+rax*4-16],1             ;#0044C26B: 48:203104203 F0 01         u  00 09  3 744      
    cmp eax,445                           ;#0044C271: 075 BD010000               vu 00 01  1 746      
    mov [rbp-8] (args),rax                ;#0044C276: 48:211105 F8               uv 00 21  1 747      
    mov qword[retaddr],#0044C287          ;#0044C27A: 48:307105 20 87C24400      vu 00 20  1 747      
    jmp #0044E450 (code:sprintf)          ;#0044C282: 351 C9210000               v  00 00  1 748      
    push rax                              ;#0044C287: 120                        uv 00 01  1 749      
    mov rsi,[rbp] (name)                  ;#0044C288: 48:213165 00               vu 40 20  1 749      
    mov r15,h4                            ;#0044C28C: 49:277 0000000000000040    uv 8000 00  1 750      
    cmp rsi,r15                           ;#0044C296: 4C:071376                  uv 00 8040  1 751 8000   
    jle #0044C2AB                         ;#0044C299: 176 10                     v  00 00  1 751      
    sub qword[rbx+rsi*4-16],1             ;#0044C29B: 48:203154263 F0 01         u  00 48  3 752      
    jne #0044C2AB                         ;#0044C2A1: 165 08                     v  00 00  1 754      
    mov rdx,rsi                           ;#0044C2A3: 48:213326                  uv 04 40  1 755      
    call #004422DA (:%pDealloc)           ;#0044C2A6: 350 2F60FFFF               v  00 00  1 755      
    pop dword[rbp] (name)                 ;#0044C2AB: 217105 00                  np 00 20  3 756      
;   377         end if
;   378         newprst = 1
    mov qword[rbp-64] (newprst),1         ;#0044C2AE: 48:307105 C0 01000000      uv 00 20  1 759      
;   379         idii &= 1
    lea rdx,[rbp-40] (idii)               ;#0044C2B6: 48:215125 D8               vu 04 20  1 759      
    lea rdi,[rbp-40] (idii)               ;#0044C2BA: 48:215175 D8               uv 80 20  1 760      
    lea rcx,qword[#00402030]              ;#0044C2BE: 48:215015 6B5DFBFF         vu 02 00  1 760      
    xor rax,rax                           ;#0044C2C5: 48:061300                  uv 01 01  1 761      
    call #0043FC15 (:%opApnd)             ;#0044C2C8: 350 4839FFFF               v  00 00  1 761      
;   380         lo = length(o)
    lea rdi,[rbp-72] (lo)                 ;#0044C2CD: 48:215175 B8               uv 80 20  1 762      
    mov rsi,[rbp-32] (o)                  ;#0044C2D1: 48:213165 E0               vu 40 20  1 762      
    mov rdx,423                           ;#0044C2D5: 48:307302 A7010000         uv 04 00  1 763      
    call #0043F28D (:%opLen)              ;#0044C2DC: 350 AC2FFFFF               v  00 00  1 763      
;   381         while lo-newprst+length(name)+13>MAXLINELEN do
    lea rdi,[rbp-176] (symtab[442])       ;#0044C2E1: 48:215275 50FFFFFF         uv 80 20  1 764      
    mov rcx,[rbp-72] (lo)                 ;#0044C2E8: 48:213115 B8               vu 02 20  1 764      
    mov rax,[rbp-64] (newprst)            ;#0044C2EC: 48:213105 C0               uv 01 20  1 765      
    call #0043F4D8 (:%opSub)              ;#0044C2F0: 350 E331FFFF               v  00 00  1 765      
    mov rdi,[rbp] (name)                  ;#0044C2F5: 48:213175 00               uv 80 20  1 766      
    mov rsi,[rbx+rdi*4-24]                ;#0044C2F9: 48:48:213164273 E8         uv 40 88  1 769 80 *80*
    mov [rbp-168] (symtab[441]),rsi       ;#0044C2FF: 48:211265 58FFFFFF         uv 00 60  1 770 40   
    lea rdi,[rbp-208] (symtab[446])       ;#0044C306: 48:215275 30FFFFFF         vu 80 20  1 770      
    mov rcx,[rbp-176] (symtab[442])       ;#0044C30D: 48:213215 50FFFFFF         uv 02 20  1 771      
    mov rax,rsi                           ;#0044C314: 48:211360                  vu 01 40  1 771      
    call #0043F4AF (:%opAdd)              ;#0044C317: 350 9331FFFF               v  00 00  1 772      
    lea rdi,[rbp-176] (symtab[442])       ;#0044C31C: 48:215275 50FFFFFF         uv 80 20  1 773      
    mov rcx,[rbp-208] (symtab[446])       ;#0044C323: 48:213215 30FFFFFF         vu 02 20  1 773      
    mov rax,[#004020F0] (BRIGHT_MAGENTA)  ;#0044C32A: 48:213005 BF5DFBFF         uv 01 00  1 774      
    call #0043F4AF (:%opAdd)              ;#0044C331: 350 7931FFFF               v  00 00  1 774      
    mov rdi,77                            ;#0044C336: 48:307307 4D000000         uv 80 00  1 775      
    mov rax,[rbp-176] (symtab[442])       ;#0044C33D: 48:213205 50FFFFFF         vu 01 20  1 775      
    mov rsi,388                           ;#0044C344: 48:307306 84010000         uv 40 00  1 776      
    mov rdx,442                           ;#0044C34B: 48:307302 BA010000         vu 04 00  1 776      
    call #0043FA81 (:%opJcc)              ;#0044C352: 350 2A37FFFF               v  00 00  1 777      
    jle #0044C5E5                         ;#0044C357: 017216 88020000            v  00 00  1 778      
;   382             lp = newprst+MAXLINELEN-14-length(name)
    lea rdi,[rbp-176] (symtab[442])       ;#0044C35D: 48:215275 50FFFFFF         uv 80 20  1 779      
    mov rcx,[rbp-64] (newprst)            ;#0044C364: 48:213115 C0               vu 02 20  1 779      
    mov rax,[#00402620] (MAXLINELEN)      ;#0044C368: 48:213005 B162FBFF         uv 01 00  1 780      
    call #0043F4AF (:%opAdd)              ;#0044C36F: 350 3B31FFFF               v  00 00  1 780      
    lea rdi,[rbp-208] (symtab[446])       ;#0044C374: 48:215275 30FFFFFF         uv 80 20  1 781      
    mov rcx,[rbp-176] (symtab[442])       ;#0044C37B: 48:213215 50FFFFFF         vu 02 20  1 781      
    mov rax,[#004020F8] (YELLOW)          ;#0044C382: 48:213005 6F5DFBFF         uv 01 00  1 782      
    call #0043F4D8 (:%opSub)              ;#0044C389: 350 4A31FFFF               v  00 00  1 782      
    mov rdi,[rbp] (name)                  ;#0044C38E: 48:213175 00               uv 80 20  1 783      
    mov rsi,[rbx+rdi*4-24]                ;#0044C392: 48:48:213164273 E8         uv 40 88  1 786 80 *80*
    mov [rbp-168] (symtab[441]),rsi       ;#0044C398: 48:211265 58FFFFFF         uv 00 60  1 787 40   
    lea rdi,[rbp-80] (lp)                 ;#0044C39F: 48:215175 B0               vu 80 20  1 787      
    mov rcx,[rbp-208] (symtab[446])       ;#0044C3A3: 48:213215 30FFFFFF         uv 02 20  1 788      
    mov rax,rsi                           ;#0044C3AA: 48:211360                  vu 01 40  1 788      
    call #0043F4EB (:%opSubi)             ;#0044C3AD: 350 3931FFFF               v  00 00  1 789      
;   383             this = allascii(o[newprst..lp])
    lea rdx,[rbp-160] (symtab[440])       ;#0044C3B2: 48:215225 60FFFFFF         uv 04 20  1 790      
    mov rcx,1                             ;#0044C3B9: 48:307301 01000000         vu 02 00  1 790      
    push #0044C3DC                        ;#0044C3C0: 150 DCC34400               uv 00 00  1 791      
    push rdx                              ;#0044C3C5: 122                        vu 00 04  1 791      
    push qword[rbp-80] (lp)               ;#0044C3C6: 377165 B0                  np 00 20  2 792      
    push qword[rbp-64] (newprst)          ;#0044C3C9: 377165 C0                  np 00 20  2 794      
    mov rsi,[rbp-32] (o)                  ;#0044C3CC: 48:213165 E0               uv 40 20  1 796      
    mov rdx,423                           ;#0044C3D0: 48:307302 A7010000         vu 04 00  1 796      
    jmp #00440F1F (:%pSubss)              ;#0044C3D7: 351 434BFFFF               v  00 00  1 797      
    mov rcx,7                             ;#0044C3DC: 48:307301 07000000         uv 02 00  1 798      
    mov rdx,409                           ;#0044C3E3: 48:307302 99010000         vu 04 00  1 798      
    call :%opFrame (allascii)             ;#0044C3EA: 350 EC64FFFF               v  00 00  1 799      
    mov rdi,[rbp+40] (prevebp)            ;#0044C3EF: 48:213175 28               uv 80 20  1 800      
    mov rax,[rdi-160]                     ;#0044C3F3: 48:213207 60FFFFFF         uv 01 80  1 803 80 *80*
    xor rbx,rbx                           ;#0044C3FA: 48:061333                  vu 08 08  1 803      
    mov r15,h4                            ;#0044C3FD: 49:277 0000000000000040    uv 8000 00  1 804      
    cmp rax,r15                           ;#0044C407: 4C:071370                  uv 00 8001  1 805 8000   
    jl #0044C417                          ;#0044C40A: 174 0B                     v  00 00  1 805      
    add qword[rbx+rax*4-16],1             ;#0044C40C: 48:203104203 F0 01         u  00 09  3 806      
    cmp eax,440                           ;#0044C412: 075 B8010000               vu 00 01  1 808      
    mov [rbp] (x),rax                     ;#0044C417: 48:211105 00               uv 00 21  1 809      
    mov qword[retaddr],#0044C428          ;#0044C41B: 48:307105 20 28C44400      vu 00 20  1 809      
    jmp #0044CB1C (code:allascii)         ;#0044C423: 351 F4060000               v  00 00  1 810      
    push rax                              ;#0044C428: 120                        uv 00 01  1 811      
    mov rdi,[rbp-48] (this)               ;#0044C429: 48:213175 D0               vu 80 20  1 811      
    mov r15,h4                            ;#0044C42D: 49:277 0000000000000040    uv 8000 00  1 812      
    cmp rdi,r15                           ;#0044C437: 4C:071377                  uv 00 8080  1 813 8000   
    jle #0044C44C                         ;#0044C43A: 176 10                     v  00 00  1 813      
    sub qword[rbx+rdi*4-16],1             ;#0044C43C: 48:203154273 F0 01         u  00 88  3 814      
    jne #0044C44C                         ;#0044C442: 165 08                     v  00 00  1 816      
    mov rdx,rdi                           ;#0044C444: 48:213327                  uv 04 80  1 817      
    call #004422DA (:%pDealloc)           ;#0044C447: 350 8E5EFFFF               v  00 00  1 817      
    pop dword[rbp-48] (this)              ;#0044C44C: 217105 D0                  np 00 20  3 818      
;   384             namedx = sprintf("%s[%d..%d]",{name,newprst,lp})
    lea rax,[rbp-200] (symtab[445])       ;#0044C44F: 48:215205 38FFFFFF         uv 01 20  1 821      
    mov rdx,3                             ;#0044C456: 48:307302 03000000         vu 04 00  1 821      
    push #0044C494                        ;#0044C45D: 150 94C44400               uv 00 00  1 822      
    push rax                              ;#0044C462: 120                        vu 00 01  1 822      
    push qword[rbp-80] (lp)               ;#0044C463: 377165 B0                  np 00 20  2 823      
    push qword[rbp-64] (newprst)          ;#0044C466: 377165 C0                  np 00 20  2 825      
    mov rcx,[rbp] (name)                  ;#0044C469: 48:213115 00               uv 02 20  1 827      
    mov r15,h4                            ;#0044C46D: 49:277 0000000000000040    vu 8000 00  1 827      
    cmp rcx,r15                           ;#0044C477: 4C:071371                  uv 00 8002  1 828      
    jl #0044C487                          ;#0044C47A: 174 0B                     v  00 00  1 828      
    add qword[rbx+rcx*4-16],1             ;#0044C47C: 48:203104213 F0 01         u  00 0A  3 829      
    cmp eax,419                           ;#0044C482: 075 A3010000               vu 00 01  1 831      
    push rcx                              ;#0044C487: 121                        uv 00 02  1 832      
    mov rdi,[rbp-200] (symtab[445])       ;#0044C488: 48:213275 38FFFFFF         vu 80 20  1 832      
    jmp #004404BD (:%pMkSq)               ;#0044C48F: 351 2940FFFF               v  00 00  1 833      
    mov rcx,33                            ;#0044C494: 48:307301 21000000         uv 02 00  1 834      
    mov rdx,89                            ;#0044C49B: 48:307302 59000000         vu 04 00  1 834      
    call #004428DB (:%opFrame) (sprintf)  ;#0044C4A2: 350 3464FFFF               v  00 00  1 835      
    mov rsi,qword[#00402648]              ;#0044C4A7: 48:213065 9A61FBFF         uv 40 00  1 836      
    mov [rbp] (format),rsi                ;#0044C4AE: 48:211165 00               uv 00 60  1 837 40   
    add qword[rbx+rsi*4-16],1             ;#0044C4B2: 48:203104263 F0 01         u  00 48  3 839    *40*
    mov rdi,[rbp+40] (prevebp)            ;#0044C4B8: 48:213175 28               vu 80 20  1 841      
    mov rax,[rdi-200]                     ;#0044C4BC: 48:213207 38FFFFFF         uv 01 80  1 844    *80*
    xor rbx,rbx                           ;#0044C4C3: 48:061333                  vu 08 08  1 844      
    mov r15,h4                            ;#0044C4C6: 49:277 0000000000000040    uv 8000 00  1 845      
    cmp rax,r15                           ;#0044C4D0: 4C:071370                  uv 00 8001  1 846 8000   
    jl #0044C4E0                          ;#0044C4D3: 174 0B                     v  00 00  1 846      
    add qword[rbx+rax*4-16],1             ;#0044C4D5: 48:203104203 F0 01         u  00 09  3 847      
    cmp eax,445                           ;#0044C4DB: 075 BD010000               vu 00 01  1 849      
    mov [rbp-8] (args),rax                ;#0044C4E0: 48:211105 F8               uv 00 21  1 850      
    mov qword[retaddr],#0044C4F1          ;#0044C4E4: 48:307105 20 F1C44400      vu 00 20  1 850      
    jmp #0044E450 (code:sprintf)          ;#0044C4EC: 351 5F1F0000               v  00 00  1 851      
    push rax                              ;#0044C4F1: 120                        uv 00 01  1 852      
    mov rcx,[rbp-56] (namedx)             ;#0044C4F2: 48:213115 C8               vu 02 20  1 852      
    mov r15,h4                            ;#0044C4F6: 49:277 0000000000000040    uv 8000 00  1 853      
    cmp rcx,r15                           ;#0044C500: 4C:071371                  uv 00 8002  1 854 8000   
    jle #0044C515                         ;#0044C503: 176 10                     v  00 00  1 854      
    sub qword[rbx+rcx*4-16],1             ;#0044C505: 48:203154213 F0 01         u  00 0A  3 855      
    jne #0044C515                         ;#0044C50B: 165 08                     v  00 00  1 857      
    mov rdx,rcx                           ;#0044C50D: 48:213321                  uv 04 02  1 858      
    call #004422DA (:%pDealloc)           ;#0044C510: 350 C55DFFFF               v  00 00  1 858      
    pop dword[rbp-56] (namedx)            ;#0044C515: 217105 C8                  np 00 20  3 859      
;   385             addtostack(idii,newprst,namedx,this)
    mov rcx,5                             ;#0044C518: 48:307301 05000000         uv 02 00  1 862      
    mov rdx,392                           ;#0044C51F: 48:307302 88010000         vu 04 00  1 862      
    call :%opFrame (addtostack)           ;#0044C526: 350 B063FFFF               v  00 00  1 863      
    mov rdi,[rbp+40] (prevebp)            ;#0044C52B: 48:213175 28               uv 80 20  1 864      
    mov rax,[rdi-40]                      ;#0044C52F: 48:213107 D8               uv 01 80  1 867 80 *80*
    xor rbx,rbx                           ;#0044C533: 48:061333                  vu 08 08  1 867      
    mov r15,h4                            ;#0044C536: 49:277 0000000000000040    uv 8000 00  1 868      
    cmp rax,r15                           ;#0044C540: 4C:071370                  uv 00 8001  1 869 8000   
    jl #0044C550                          ;#0044C543: 174 0B                     v  00 00  1 869      
    add qword[rbx+rax*4-16],1             ;#0044C545: 48:203104203 F0 01         u  00 09  3 870      
    cmp eax,424                           ;#0044C54B: 075 A8010000               vu 00 01  1 872      
    mov [rbp] (idii),rax                  ;#0044C550: 48:211105 00               uv 00 21  1 873      
    mov rdi,[rbp+40] (prevebp)            ;#0044C554: 48:213175 28               vu 80 20  1 873      
    mov rax,[rdi-64]                      ;#0044C558: 48:213107 C0               uv 01 80  1 876    *80*
    mov [rbp-8] (idxr),rax                ;#0044C55C: 48:211105 F8               uv 00 21  1 877 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044C560: 48:213175 28               vu 80 20  1 877      
    mov rax,[rdi-56]                      ;#0044C564: 48:213107 C8               uv 01 80  1 880    *80*
    xor rbx,rbx                           ;#0044C568: 48:061333                  vu 08 08  1 880      
    mov r15,h4                            ;#0044C56B: 49:277 0000000000000040    uv 8000 00  1 881      
    cmp rax,r15                           ;#0044C575: 4C:071370                  uv 00 8001  1 882 8000   
    jl #0044C585                          ;#0044C578: 174 0B                     v  00 00  1 882      
    add qword[rbx+rax*4-16],1             ;#0044C57A: 48:203104203 F0 01         u  00 09  3 883      
    cmp eax,426                           ;#0044C580: 075 AA010000               vu 00 01  1 885      
    mov [rbp-16] (name),rax               ;#0044C585: 48:211105 F0               uv 00 21  1 886      
    mov rdi,[rbp+40] (prevebp)            ;#0044C589: 48:213175 28               vu 80 20  1 886      
    mov rax,[rdi-48]                      ;#0044C58D: 48:213107 D0               uv 01 80  1 889    *80*
    xor rbx,rbx                           ;#0044C591: 48:061333                  vu 08 08  1 889      
    mov r15,h4                            ;#0044C594: 49:277 0000000000000040    uv 8000 00  1 890      
    cmp rax,r15                           ;#0044C59E: 4C:071370                  uv 00 8001  1 891 8000   
    jl #0044C5AE                          ;#0044C5A1: 174 0B                     v  00 00  1 891      
    add qword[rbx+rax*4-16],1             ;#0044C5A3: 48:203104203 F0 01         u  00 09  3 892      
    cmp eax,425                           ;#0044C5A9: 075 A9010000               vu 00 01  1 894      
    mov [rbp-24] (text),rax               ;#0044C5AE: 48:211105 E8               uv 00 21  1 895      
    mov qword[retaddr],#0044C5BF          ;#0044C5B2: 48:307105 20 BFC54400      vu 00 20  1 895      
    jmp #0044B089 (code:addtostack)       ;#0044C5BA: 351 CAEAFFFF               v  00 00  1 896      
;   386             newprst = lp+1
    mov rdi,[rbp-80] (lp)                 ;#0044C5BF: 48:213175 B0               uv 80 20  1 897      
    add rdi,1                             ;#0044C5C3: 48:203307 01               uv 80 80  1 898 80   
    mov rdx,rdi                           ;#0044C5C7: 48:213327                  uv 04 80  1 899 80   
    mov [rbp-64] (newprst),rdi            ;#0044C5CA: 48:211175 C0               vu 00 A0  1 899      
    shl rdx,1                             ;#0044C5CE: 48:321342                  u  04 04  1 900      
    jno #0044C2E1                         ;#0044C5D1: 017201 0AFDFFFF            v  00 00  1 900      
    lea rdi,[rbp-64] (newprst)            ;#0044C5D7: 48:215175 C0               uv 80 20  1 901      
    call #00442DA9 (:%pAddiii)            ;#0044C5DB: 350 C967FFFF               v  00 00  1 901      
;   387         end while
    jmp #0044C2E1                         ;#0044C5E0: 351 FCFCFFFF               v  00 00  1 902      
;   388         if newprst!=1 then
    mov rsi,[rbp-64] (newprst)            ;#0044C5E5: 48:213165 C0               uv 40 20  1 903      
    cmp rsi,1                             ;#0044C5E9: 48:203376 01               uv 00 40  1 904 40   
    je #0044C774                          ;#0044C5ED: 017204 81010000            v  00 00  1 904      
;   389             name = sprintf("%s[%d..%d]",{name,newprst,lo})
    lea rax,[rbp-200] (symtab[445])       ;#0044C5F3: 48:215205 38FFFFFF         uv 01 20  1 905      
    mov rdx,3                             ;#0044C5FA: 48:307302 03000000         vu 04 00  1 905      
    push #0044C636                        ;#0044C601: 150 36C64400               uv 00 00  1 906      
    push rax                              ;#0044C606: 120                        vu 00 01  1 906      
    push qword[rbp-72] (lo)               ;#0044C607: 377165 B8                  np 00 20  2 907      
    push rsi                              ;#0044C60A: 126                        uv 00 40  1 909      
    mov rcx,[rbp] (name)                  ;#0044C60B: 48:213115 00               vu 02 20  1 909      
    mov r15,h4                            ;#0044C60F: 49:277 0000000000000040    uv 8000 00  1 910      
    cmp rcx,r15                           ;#0044C619: 4C:071371                  uv 00 8002  1 911 8000   
    jl #0044C629                          ;#0044C61C: 174 0B                     v  00 00  1 911      
    add qword[rbx+rcx*4-16],1             ;#0044C61E: 48:203104213 F0 01         u  00 0A  3 912      
    cmp eax,419                           ;#0044C624: 075 A3010000               vu 00 01  1 914      
    push rcx                              ;#0044C629: 121                        uv 00 02  1 915      
    mov rdi,[rbp-200] (symtab[445])       ;#0044C62A: 48:213275 38FFFFFF         vu 80 20  1 915      
    jmp #004404BD (:%pMkSq)               ;#0044C631: 351 873EFFFF               v  00 00  1 916      
    mov rcx,33                            ;#0044C636: 48:307301 21000000         uv 02 00  1 917      
    mov rdx,89                            ;#0044C63D: 48:307302 59000000         vu 04 00  1 917      
    call #004428DB (:%opFrame) (sprintf)  ;#0044C644: 350 9262FFFF               v  00 00  1 918      
    mov rax,qword[#00402648]              ;#0044C649: 48:213005 F85FFBFF         uv 01 00  1 919      
    mov [rbp] (format),rax                ;#0044C650: 48:211105 00               uv 00 21  1 920 01   
    add qword[rbx+rax*4-16],1             ;#0044C654: 48:203104203 F0 01         u  00 09  3 922    *01*
    mov rdi,[rbp+40] (prevebp)            ;#0044C65A: 48:213175 28               vu 80 20  1 924      
    mov rax,[rdi-200]                     ;#0044C65E: 48:213207 38FFFFFF         uv 01 80  1 927    *80*
    xor rbx,rbx                           ;#0044C665: 48:061333                  vu 08 08  1 927      
    mov r15,h4                            ;#0044C668: 49:277 0000000000000040    uv 8000 00  1 928      
    cmp rax,r15                           ;#0044C672: 4C:071370                  uv 00 8001  1 929 8000   
    jl #0044C682                          ;#0044C675: 174 0B                     v  00 00  1 929      
    add qword[rbx+rax*4-16],1             ;#0044C677: 48:203104203 F0 01         u  00 09  3 930      
    cmp eax,445                           ;#0044C67D: 075 BD010000               vu 00 01  1 932      
    mov [rbp-8] (args),rax                ;#0044C682: 48:211105 F8               uv 00 21  1 933      
    mov qword[retaddr],#0044C693          ;#0044C686: 48:307105 20 93C64400      vu 00 20  1 933      
    jmp #0044E450 (code:sprintf)          ;#0044C68E: 351 BD1D0000               v  00 00  1 934      
    push rax                              ;#0044C693: 120                        uv 00 01  1 935      
    mov rsi,[rbp] (name)                  ;#0044C694: 48:213165 00               vu 40 20  1 935      
    mov r15,h4                            ;#0044C698: 49:277 0000000000000040    uv 8000 00  1 936      
    cmp rsi,r15                           ;#0044C6A2: 4C:071376                  uv 00 8040  1 937 8000   
    jle #0044C6B7                         ;#0044C6A5: 176 10                     v  00 00  1 937      
    sub qword[rbx+rsi*4-16],1             ;#0044C6A7: 48:203154263 F0 01         u  00 48  3 938      
    jne #0044C6B7                         ;#0044C6AD: 165 08                     v  00 00  1 940      
    mov rdx,rsi                           ;#0044C6AF: 48:213326                  uv 04 40  1 941      
    call #004422DA (:%pDealloc)           ;#0044C6B2: 350 235CFFFF               v  00 00  1 941      
    pop dword[rbp] (name)                 ;#0044C6B7: 217105 00                  np 00 20  3 942      
;   390             this = allascii(o[newprst..lo])
    lea rdx,[rbp-160] (symtab[440])       ;#0044C6BA: 48:215225 60FFFFFF         uv 04 20  1 945      
    mov rcx,1                             ;#0044C6C1: 48:307301 01000000         vu 02 00  1 945      
    push #0044C6E4                        ;#0044C6C8: 150 E4C64400               uv 00 00  1 946      
    push rdx                              ;#0044C6CD: 122                        vu 00 04  1 946      
    push qword[rbp-72] (lo)               ;#0044C6CE: 377165 B8                  np 00 20  2 947      
    push qword[rbp-64] (newprst)          ;#0044C6D1: 377165 C0                  np 00 20  2 949      
    mov rsi,[rbp-32] (o)                  ;#0044C6D4: 48:213165 E0               uv 40 20  1 951      
    mov rdx,423                           ;#0044C6D8: 48:307302 A7010000         vu 04 00  1 951      
    jmp #00440F1F (:%pSubss)              ;#0044C6DF: 351 3B48FFFF               v  00 00  1 952      
    mov rcx,7                             ;#0044C6E4: 48:307301 07000000         uv 02 00  1 953      
    mov rdx,409                           ;#0044C6EB: 48:307302 99010000         vu 04 00  1 953      
    call :%opFrame (allascii)             ;#0044C6F2: 350 E461FFFF               v  00 00  1 954      
    mov rdi,[rbp+40] (prevebp)            ;#0044C6F7: 48:213175 28               uv 80 20  1 955      
    mov rax,[rdi-160]                     ;#0044C6FB: 48:213207 60FFFFFF         uv 01 80  1 958 80 *80*
    xor rbx,rbx                           ;#0044C702: 48:061333                  vu 08 08  1 958      
    mov r15,h4                            ;#0044C705: 49:277 0000000000000040    uv 8000 00  1 959      
    cmp rax,r15                           ;#0044C70F: 4C:071370                  uv 00 8001  1 960 8000   
    jl #0044C71F                          ;#0044C712: 174 0B                     v  00 00  1 960      
    add qword[rbx+rax*4-16],1             ;#0044C714: 48:203104203 F0 01         u  00 09  3 961      
    cmp eax,440                           ;#0044C71A: 075 B8010000               vu 00 01  1 963      
    mov [rbp] (x),rax                     ;#0044C71F: 48:211105 00               uv 00 21  1 964      
    mov qword[retaddr],#0044C730          ;#0044C723: 48:307105 20 30C74400      vu 00 20  1 964      
    jmp #0044CB1C (code:allascii)         ;#0044C72B: 351 EC030000               v  00 00  1 965      
    push rax                              ;#0044C730: 120                        uv 00 01  1 966      
    mov rcx,[rbp-48] (this)               ;#0044C731: 48:213115 D0               vu 02 20  1 966      
    mov r15,h4                            ;#0044C735: 49:277 0000000000000040    uv 8000 00  1 967      
    cmp rcx,r15                           ;#0044C73F: 4C:071371                  uv 00 8002  1 968 8000   
    jle #0044C754                         ;#0044C742: 176 10                     v  00 00  1 968      
    sub qword[rbx+rcx*4-16],1             ;#0044C744: 48:203154213 F0 01         u  00 0A  3 969      
    jne #0044C754                         ;#0044C74A: 165 08                     v  00 00  1 971      
    mov rdx,rcx                           ;#0044C74C: 48:213321                  uv 04 02  1 972      
    call #004422DA (:%pDealloc)           ;#0044C74F: 350 865BFFFF               v  00 00  1 972      
    pop dword[rbp-48] (this)              ;#0044C754: 217105 D0                  np 00 20  3 973      
;   391             if dotdot then
    mov rdi,[rbp-96] (dotdot)             ;#0044C757: 48:213175 A0               uv 80 20  1 976      
    test rdi,rdi                          ;#0044C75B: 48:205377                  uv 00 80  1 977 80   
    je #0044C774                          ;#0044C75E: 164 14                     v  00 00  1 977      
;   392                 this &= ".."
    lea rdx,[rbp-48] (this)               ;#0044C760: 48:215125 D0               uv 04 20  1 978      
    lea rdi,[rbp-48] (this)               ;#0044C764: 48:215175 D0               vu 80 20  1 978      
    lea rcx,qword[#00402320]              ;#0044C768: 48:215015 B15BFBFF         uv 02 00  1 979      
    call #00440021 (:%opConcat)           ;#0044C76F: 350 AD38FFFF               v  00 00  1 979      
;   393             end if
;   394         end if
;   395         addtostack(idii,newprst,name,this)
    mov rcx,5                             ;#0044C774: 48:307301 05000000         uv 02 00  1 980      
    mov rdx,392                           ;#0044C77B: 48:307302 88010000         vu 04 00  1 980      
    call :%opFrame (addtostack)           ;#0044C782: 350 5461FFFF               v  00 00  1 981      
    mov rdi,[rbp+40] (prevebp)            ;#0044C787: 48:213175 28               uv 80 20  1 982      
    mov rax,[rdi-40]                      ;#0044C78B: 48:213107 D8               uv 01 80  1 985 80 *80*
    xor rbx,rbx                           ;#0044C78F: 48:061333                  vu 08 08  1 985      
    mov r15,h4                            ;#0044C792: 49:277 0000000000000040    uv 8000 00  1 986      
    cmp rax,r15                           ;#0044C79C: 4C:071370                  uv 00 8001  1 987 8000   
    jl #0044C7AC                          ;#0044C79F: 174 0B                     v  00 00  1 987      
    add qword[rbx+rax*4-16],1             ;#0044C7A1: 48:203104203 F0 01         u  00 09  3 988      
    cmp eax,424                           ;#0044C7A7: 075 A8010000               vu 00 01  1 990      
    mov [rbp] (idii),rax                  ;#0044C7AC: 48:211105 00               uv 00 21  1 991      
    mov rdi,[rbp+40] (prevebp)            ;#0044C7B0: 48:213175 28               vu 80 20  1 991      
    mov rax,[rdi-64]                      ;#0044C7B4: 48:213107 C0               uv 01 80  1 994    *80*
    mov [rbp-8] (idxr),rax                ;#0044C7B8: 48:211105 F8               uv 00 21  1 995 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044C7BC: 48:213175 28               vu 80 20  1 995      
    mov rax,[rdi]                         ;#0044C7C0: 48:213007                  uv 01 80  1 998    *80*
    xor rbx,rbx                           ;#0044C7C3: 48:061333                  vu 08 08  1 998      
    mov r15,h4                            ;#0044C7C6: 49:277 0000000000000040    uv 8000 00  1 999      
    cmp rax,r15                           ;#0044C7D0: 4C:071370                  uv 00 8001  1 1000 8000   
    jl #0044C7E0                          ;#0044C7D3: 174 0B                     v  00 00  1 1000      
    add qword[rbx+rax*4-16],1             ;#0044C7D5: 48:203104203 F0 01         u  00 09  3 1001      
    cmp eax,419                           ;#0044C7DB: 075 A3010000               vu 00 01  1 1003      
    mov [rbp-16] (name),rax               ;#0044C7E0: 48:211105 F0               uv 00 21  1 1004      
    mov rdi,[rbp+40] (prevebp)            ;#0044C7E4: 48:213175 28               vu 80 20  1 1004      
    mov rax,[rdi-48]                      ;#0044C7E8: 48:213107 D0               uv 01 80  1 1007    *80*
    xor rbx,rbx                           ;#0044C7EC: 48:061333                  vu 08 08  1 1007      
    mov r15,h4                            ;#0044C7EF: 49:277 0000000000000040    uv 8000 00  1 1008      
    cmp rax,r15                           ;#0044C7F9: 4C:071370                  uv 00 8001  1 1009 8000   
    jl #0044C809                          ;#0044C7FC: 174 0B                     v  00 00  1 1009      
    add qword[rbx+rax*4-16],1             ;#0044C7FE: 48:203104203 F0 01         u  00 09  3 1010      
    cmp eax,425                           ;#0044C804: 075 A9010000               vu 00 01  1 1012      
    mov [rbp-24] (text),rax               ;#0044C809: 48:211105 E8               uv 00 21  1 1013      
    mov qword[retaddr],#0044C81A          ;#0044C80D: 48:307105 20 1AC84400      vu 00 20  1 1013      
    jmp #0044B089 (code:addtostack)       ;#0044C815: 351 6FE8FFFF               v  00 00  1 1014      
;   396         return {prdx+1,""}
    lea rdi,[rbp-208] (symtab[446])       ;#0044C81A: 48:215275 30FFFFFF         uv 80 20  1 1015      
    mov rcx,[rbp-24] (prdx)               ;#0044C821: 48:213115 E8               vu 02 20  1 1015      
    mov rax,qword[#00402030]              ;#0044C825: 48:213005 0458FBFF         uv 01 00  1 1016      
    call #0043F4AF (:%opAdd)              ;#0044C82C: 350 7E2CFFFF               v  00 00  1 1016      
    lea rax,[rbp-200] (symtab[445])       ;#0044C831: 48:215205 38FFFFFF         uv 01 20  1 1017      
    mov rdx,2                             ;#0044C838: 48:307302 02000000         vu 04 00  1 1017      
    push #0044C879                        ;#0044C83F: 150 79C84400               uv 00 00  1 1018      
    push rax                              ;#0044C844: 120                        vu 00 01  1 1018      
    mov rsi,qword[#00402240]              ;#0044C845: 48:213065 F459FBFF         uv 40 00  1 1019      
    mov r15,h4                            ;#0044C84C: 49:277 0000000000000040    vu 8000 00  1 1019      
    cmp rsi,r15                           ;#0044C856: 4C:071376                  uv 00 8040  1 1020      
    jl #0044C866                          ;#0044C859: 174 0B                     v  00 00  1 1020      
    add qword[rbx+rsi*4-16],1             ;#0044C85B: 48:203104263 F0 01         u  00 48  3 1021      
    cmp eax,169                           ;#0044C861: 075 A9000000               vu 00 01  1 1023      
    push rsi                              ;#0044C866: 126                        uv 00 40  1 1024      
    push qword[rbp-208] (symtab[446])     ;#0044C867: 377265 30FFFFFF            np 00 20  2 1025      
    mov rdi,[rbp-200] (symtab[445])       ;#0044C86D: 48:213275 38FFFFFF         uv 80 20  1 1027      
    jmp #004404BD (:%pMkSq)               ;#0044C874: 351 443CFFFF               v  00 00  1 1027      
    mov rax,[rbp-200] (symtab[445])       ;#0044C879: 48:213205 38FFFFFF         uv 01 20  1 1028      
    mov [rbp-200] (symtab[445]),rbx       ;#0044C880: 48:211235 38FFFFFF         vu 00 28  1 1028      
    jmp #0044298D (:%opRetf)              ;#0044C887: 351 0161FFFF               v  00 00  1 1029      
;   397     end if
;   398     return {prdx,this}
    lea rax,[rbp-200] (symtab[445])       ;#0044C88C: 48:215205 38FFFFFF         uv 01 20  1 1030      
    mov rdx,2                             ;#0044C893: 48:307302 02000000         vu 04 00  1 1030      
    push #0044C8CE                        ;#0044C89A: 150 CEC84400               uv 00 00  1 1031      
    push rax                              ;#0044C89F: 120                        vu 00 01  1 1031      
    mov rcx,[rbp-48] (this)               ;#0044C8A0: 48:213115 D0               uv 02 20  1 1032      
    mov r15,h4                            ;#0044C8A4: 49:277 0000000000000040    vu 8000 00  1 1032      
    cmp rcx,r15                           ;#0044C8AE: 4C:071371                  uv 00 8002  1 1033      
    jl #0044C8BE                          ;#0044C8B1: 174 0B                     v  00 00  1 1033      
    add qword[rbx+rcx*4-16],1             ;#0044C8B3: 48:203104213 F0 01         u  00 0A  3 1034      
    cmp eax,425                           ;#0044C8B9: 075 A9010000               vu 00 01  1 1036      
    push rcx                              ;#0044C8BE: 121                        uv 00 02  1 1037      
    push qword[rbp-24] (prdx)             ;#0044C8BF: 377165 E8                  np 00 20  2 1038      
    mov rdi,[rbp-200] (symtab[445])       ;#0044C8C2: 48:213275 38FFFFFF         uv 80 20  1 1040      
    jmp #004404BD (:%pMkSq)               ;#0044C8C9: 351 EF3BFFFF               v  00 00  1 1040      
    mov rax,[rbp-200] (symtab[445])       ;#0044C8CE: 48:213205 38FFFFFF         uv 01 20  1 1041      
    mov [rbp-200] (symtab[445]),rbx       ;#0044C8D5: 48:211235 38FFFFFF         vu 00 28  1 1041      
    jmp #0044298D (:%opRetf)              ;#0044C8DC: 351 AC60FFFF               v  00 00  1 1042      
;   399 end function
;   400 
;   401 procedure clever_dump(string name, object o)
    mov rsi,[rbp] (name)                  ;#0044AAD9: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0044AADD: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0044AAE7: 4C:071376                  uv 00 8040  1   2      
    jl #0044AAF3                          ;#0044AAEA: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rsi*4-1],#82             ;#0044AAEC: 200174263 FF 82            u  00 48  2   3      
    je #0044AAFF                          ;#0044AAF1: 164 0C                     v  00 00  1   4      
    mov rcx,448                           ;#0044AAF3: 48:307301 C0010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044AAFA: 350 597FFFFF               v  00 00  1   5      
;   402 --
;   403 -- Display "name = sprint(o)" but with indexes 
;   404 -- as needed, together with smart line splitting.
;   405 --
;   406 integer prst
;   407 string s
;   408     if OLDSTYLE then
;   409         printf(fn,"    %s = %s\n",{name,ppExf(o,{pp_Indent,length(name)+7})})
;   410     else
;   411         printstack = {}
    mov rcx,qword[#004022C8]              ;#0044AAFF: 48:213015 C277FBFF         uv 02 00  1   6      
    mov rdx,[#00402638] (printstack)      ;#0044AB06: 48:213025 2B7BFBFF         vu 04 00  1   6      
    mov r15,h4                            ;#0044AB0D: 49:277 0000000000000040    uv 8000 00  1   7      
    cmp rcx,r15                           ;#0044AB17: 4C:071371                  uv 00 8002  1   8 8000   
    jl #0044AB22                          ;#0044AB1A: 174 06                     v  00 00  1   8      
    add qword[rbx+rcx*4-16],1             ;#0044AB1C: 48:203104213 F0 01         u  00 0A  3   9      
    mov [#00402638] (printstack),rcx      ;#0044AB22: 48:211015 0F7BFBFF         vu 00 02  1  11      
    mov r15,h4                            ;#0044AB29: 49:277 0000000000000040    uv 8000 00  1  12      
    cmp rdx,r15                           ;#0044AB33: 4C:071372                  uv 00 8004  1  13 8000   
    jle #0044AB45                         ;#0044AB36: 176 0D                     v  00 00  1  13      
    sub qword[rbx+rdx*4-16],1             ;#0044AB38: 48:203154223 F0 01         u  00 0C  3  14      
    jne #0044AB45                         ;#0044AB3E: 165 05                     v  00 00  1  16      
    call #004422DA (:%pDealloc)           ;#0044AB40: 350 9577FFFF               v  00 00  1  17      
;   412         {prst,s} = cdi(name,"",1,-1,o,{})
    mov rcx,27                            ;#0044AB45: 48:307301 1B000000         uv 02 00  1  18      
    mov rdx,418                           ;#0044AB4C: 48:307302 A2010000         vu 04 00  1  18      
    call #004428DB (:%opFrame) (cdi)      ;#0044AB53: 350 837DFFFF               v  00 00  1  19      
    mov rdi,[rbp+40] (prevebp)            ;#0044AB58: 48:213175 28               uv 80 20  1  20      
    mov rax,[rdi]                         ;#0044AB5C: 48:213007                  uv 01 80  1  23 80 *80*
    xor rbx,rbx                           ;#0044AB5F: 48:061333                  vu 08 08  1  23      
    mov r15,h4                            ;#0044AB62: 49:277 0000000000000040    uv 8000 00  1  24      
    cmp rax,r15                           ;#0044AB6C: 4C:071370                  uv 00 8001  1  25 8000   
    jl #0044AB7C                          ;#0044AB6F: 174 0B                     v  00 00  1  25      
    add qword[rbx+rax*4-16],1             ;#0044AB71: 48:203104203 F0 01         u  00 09  3  26      
    cmp eax,448                           ;#0044AB77: 075 C0010000               vu 00 01  1  28      
    mov [rbp] (name),rax                  ;#0044AB7C: 48:211105 00               uv 00 21  1  29      
    mov rdi,qword[#00402240]              ;#0044AB80: 48:213075 B976FBFF         vu 80 00  1  29      
    mov [rbp-8] (prev),rdi                ;#0044AB87: 48:211175 F8               uv 00 A0  1  30      
    add qword[rbx+rdi*4-16],1             ;#0044AB8B: 48:203104273 F0 01         u  00 88  3  32    *80*
    mov qword[rbp-16] (prst),1            ;#0044AB91: 48:307105 F0 01000000      vu 00 20  1  34      
    mov qword[rbp-24] (prdx),-1           ;#0044AB99: 48:307105 E8 FFFFFFFF      uv 00 20  1  35      
    mov rdi,[rbp+40] (prevebp)            ;#0044ABA1: 48:213175 28               vu 80 20  1  35      
    mov rax,[rdi-8]                       ;#0044ABA5: 48:213107 F8               uv 01 80  1  38    *80*
    xor rbx,rbx                           ;#0044ABA9: 48:061333                  vu 08 08  1  38      
    mov r15,h4                            ;#0044ABAC: 49:277 0000000000000040    uv 8000 00  1  39      
    cmp rax,r15                           ;#0044ABB6: 4C:071370                  uv 00 8001  1  40 8000   
    jl #0044ABC6                          ;#0044ABB9: 174 0B                     v  00 00  1  40      
    add qword[rbx+rax*4-16],1             ;#0044ABBB: 48:203104203 F0 01         u  00 09  3  41      
    cmp eax,449                           ;#0044ABC1: 075 C1010000               vu 00 01  1  43      
    mov [rbp-32] (o),rax                  ;#0044ABC6: 48:211105 E0               uv 00 21  1  44      
    mov rsi,qword[#004022C8]              ;#0044ABCA: 48:213065 F776FBFF         vu 40 00  1  44      
    mov [rbp-40] (idii),rsi               ;#0044ABD1: 48:211165 D8               uv 00 60  1  45      
    add qword[rbx+rsi*4-16],1             ;#0044ABD5: 48:203104263 F0 01         u  00 48  3  47    *40*
    mov qword[retaddr],#0044ABE8          ;#0044ABDB: 48:307105 20 E8AB4400      vu 00 20  1  49      
    jmp #0044B17E (code:cdi)              ;#0044ABE3: 351 96050000               v  00 00  1  50      
    push rax                              ;#0044ABE8: 120                        uv 00 01  1  51      
    mov rcx,[rbp-40] (symtab[453])        ;#0044ABE9: 48:213115 D8               vu 02 20  1  51      
    mov r15,h4                            ;#0044ABED: 49:277 0000000000000040    uv 8000 00  1  52      
    cmp rcx,r15                           ;#0044ABF7: 4C:071371                  uv 00 8002  1  53 8000   
    jle #0044AC0C                         ;#0044ABFA: 176 10                     v  00 00  1  53      
    sub qword[rbx+rcx*4-16],1             ;#0044ABFC: 48:203154213 F0 01         u  00 0A  3  54      
    jne #0044AC0C                         ;#0044AC02: 165 08                     v  00 00  1  56      
    mov rdx,rcx                           ;#0044AC04: 48:213321                  uv 04 02  1  57      
    call #004422DA (:%pDealloc)           ;#0044AC07: 350 CE76FFFF               v  00 00  1  57      
    pop dword[rbp-40] (symtab[453])       ;#0044AC0C: 217105 D8                  np 00 20  3  58      
    mov rdi,2                             ;#0044AC0F: 48:307307 02000000         uv 80 00  1  61      
    lea rcx,[rbp-24] (s)                  ;#0044AC16: 48:215115 E8               vu 02 20  1  61      
    mov rsi,[rbp-40] (symtab[453])        ;#0044AC1A: 48:213165 D8               uv 40 20  1  62      
    mov rdx,453                           ;#0044AC1E: 48:307302 C5010000         vu 04 00  1  62      
    call #00441675 (:%pSubse1)            ;#0044AC25: 350 4B6AFFFF               v  00 00  1  63      
    mov rdi,[rbp-24] (s)                  ;#0044AC2A: 48:213175 E8               uv 80 20  1  64      
    mov r15,h4                            ;#0044AC2E: 49:277 0000000000000040    vu 8000 00  1  64      
    cmp rdi,r15                           ;#0044AC38: 4C:071377                  uv 00 8080  1  65      
    jl #0044AC44                          ;#0044AC3B: 174 07                     v  00 00  1  65      
    cmp byte[rbx+rdi*4-1],#82             ;#0044AC3D: 200174273 FF 82            u  00 88  2  66      
    je #0044AC50                          ;#0044AC42: 164 0C                     v  00 00  1  67      
    mov rcx,451                           ;#0044AC44: 48:307301 C3010000         uv 02 00  1  68      
    call #00442A58 (:%opTchkFail)         ;#0044AC4B: 350 087EFFFF               v  00 00  1  68      
    mov rdi,1                             ;#0044AC50: 48:307307 01000000         uv 80 00  1  69      
    lea rcx,[rbp-16] (prst)               ;#0044AC57: 48:215115 F0               vu 02 20  1  69      
    mov rsi,[rbp-40] (symtab[453])        ;#0044AC5B: 48:213165 D8               uv 40 20  1  70      
    mov rdx,453                           ;#0044AC5F: 48:307302 C5010000         vu 04 00  1  70      
    call #004416F2 (:%pSubse1i)           ;#0044AC66: 350 876AFFFF               v  00 00  1  71      
    mov r15,h4                            ;#0044AC6B: 49:277 0000000000000040    uv 8000 00  1  72      
    cmp rax,r15                           ;#0044AC75: 4C:071370                  uv 00 8001  1  73 8000   
    jl #0044AC86                          ;#0044AC78: 174 0C                     v  00 00  1  73      
    mov rcx,450                           ;#0044AC7A: 48:307301 C2010000         uv 02 00  1  74      
    call #00442A58 (:%opTchkFail)         ;#0044AC81: 350 D27DFFFF               v  00 00  1  74      
;   413         if length(s) then
    mov rcx,[rbp-24] (s)                  ;#0044AC86: 48:213115 E8               uv 02 20  1  75      
    mov rdi,[rbx+rcx*4-24]                ;#0044AC8A: 48:213174213 E8            uv 80 0A  1  78 02 *02*
    test rdi,edi                          ;#0044AC8F: 205377                     uv 00 80  1  79 80   
    je #0044AD5A                          ;#0044AC91: 017204 C3000000            v  00 00  1  79      
;   414             addtostack({prst},prst,name,s)
    lea rax,[rbp-48] (symtab[454])        ;#0044AC97: 48:215105 D0               uv 01 20  1  80      
    mov rdx,1                             ;#0044AC9B: 48:307302 01000000         vu 04 00  1  80      
    push #0044ACB4                        ;#0044ACA2: 150 B4AC4400               uv 00 00  1  81      
    push rax                              ;#0044ACA7: 120                        vu 00 01  1  81      
    push qword[rbp-16] (prst)             ;#0044ACA8: 377165 F0                  np 00 20  2  82      
    mov rdi,[rbp-48] (symtab[454])        ;#0044ACAB: 48:213175 D0               uv 80 20  1  84      
    jmp #004404BD (:%pMkSq)               ;#0044ACAF: 351 0958FFFF               v  00 00  1  84      
    mov rcx,5                             ;#0044ACB4: 48:307301 05000000         uv 02 00  1  85      
    mov rdx,392                           ;#0044ACBB: 48:307302 88010000         vu 04 00  1  85      
    call :%opFrame (addtostack)           ;#0044ACC2: 350 147CFFFF               v  00 00  1  86      
    mov rdi,[rbp+40] (prevebp)            ;#0044ACC7: 48:213175 28               uv 80 20  1  87      
    mov rax,[rdi-48]                      ;#0044ACCB: 48:213107 D0               uv 01 80  1  90 80 *80*
    xor rbx,rbx                           ;#0044ACCF: 48:061333                  vu 08 08  1  90      
    mov r15,h4                            ;#0044ACD2: 49:277 0000000000000040    uv 8000 00  1  91      
    cmp rax,r15                           ;#0044ACDC: 4C:071370                  uv 00 8001  1  92 8000   
    jl #0044ACEC                          ;#0044ACDF: 174 0B                     v  00 00  1  92      
    add qword[rbx+rax*4-16],1             ;#0044ACE1: 48:203104203 F0 01         u  00 09  3  93      
    cmp eax,454                           ;#0044ACE7: 075 C6010000               vu 00 01  1  95      
    mov [rbp] (idii),rax                  ;#0044ACEC: 48:211105 00               uv 00 21  1  96      
    mov rdi,[rbp+40] (prevebp)            ;#0044ACF0: 48:213175 28               vu 80 20  1  96      
    mov rax,[rdi-16]                      ;#0044ACF4: 48:213107 F0               uv 01 80  1  99    *80*
    mov [rbp-8] (idxr),rax                ;#0044ACF8: 48:211105 F8               uv 00 21  1 100 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044ACFC: 48:213175 28               vu 80 20  1 100      
    mov rax,[rdi]                         ;#0044AD00: 48:213007                  uv 01 80  1 103    *80*
    xor rbx,rbx                           ;#0044AD03: 48:061333                  vu 08 08  1 103      
    mov r15,h4                            ;#0044AD06: 49:277 0000000000000040    uv 8000 00  1 104      
    cmp rax,r15                           ;#0044AD10: 4C:071370                  uv 00 8001  1 105 8000   
    jl #0044AD20                          ;#0044AD13: 174 0B                     v  00 00  1 105      
    add qword[rbx+rax*4-16],1             ;#0044AD15: 48:203104203 F0 01         u  00 09  3 106      
    cmp eax,448                           ;#0044AD1B: 075 C0010000               vu 00 01  1 108      
    mov [rbp-16] (name),rax               ;#0044AD20: 48:211105 F0               uv 00 21  1 109      
    mov rdi,[rbp+40] (prevebp)            ;#0044AD24: 48:213175 28               vu 80 20  1 109      
    mov rax,[rdi-24]                      ;#0044AD28: 48:213107 E8               uv 01 80  1 112    *80*
    xor rbx,rbx                           ;#0044AD2C: 48:061333                  vu 08 08  1 112      
    mov r15,h4                            ;#0044AD2F: 49:277 0000000000000040    uv 8000 00  1 113      
    cmp rax,r15                           ;#0044AD39: 4C:071370                  uv 00 8001  1 114 8000   
    jl #0044AD49                          ;#0044AD3C: 174 0B                     v  00 00  1 114      
    add qword[rbx+rax*4-16],1             ;#0044AD3E: 48:203104203 F0 01         u  00 09  3 115      
    cmp eax,451                           ;#0044AD44: 075 C3010000               vu 00 01  1 117      
    mov [rbp-24] (text),rax               ;#0044AD49: 48:211105 E8               uv 00 21  1 118      
    mov qword[retaddr],#0044AD5A          ;#0044AD4D: 48:307105 20 5AAD4400      vu 00 20  1 118      
    jmp #0044B089 (code:addtostack)       ;#0044AD55: 351 2F030000               v  00 00  1 119      
;   415         end if
;   416         printstack = sort(printstack)
    mov rcx,12                            ;#0044AD5A: 48:307301 0C000000         uv 02 00  1 120      
    mov rdx,93                            ;#0044AD61: 48:307302 5D000000         vu 04 00  1 120      
    call #004428DB (:%opFrame) (sort)     ;#0044AD68: 350 6E7BFFFF               v  00 00  1 121      
    mov rsi,[#00402638] (printstack)      ;#0044AD6D: 48:213065 C478FBFF         uv 40 00  1 122      
    mov [rbp] (x),rsi                     ;#0044AD74: 48:211165 00               uv 00 60  1 123 40   
    add qword[rbx+rsi*4-16],1             ;#0044AD78: 48:203104263 F0 01         u  00 48  3 125    *40*
    mov qword[retaddr],#0044AD8B          ;#0044AD7E: 48:307105 20 8BAD4400      vu 00 20  1 127      
    jmp #0044AEAD (code:sort)             ;#0044AD86: 351 22010000               v  00 00  1 128      
    push rax                              ;#0044AD8B: 120                        uv 00 01  1 129      
    mov rcx,[#00402638] (printstack)      ;#0044AD8C: 48:213015 A578FBFF         vu 02 00  1 129      
    mov r15,h4                            ;#0044AD93: 49:277 0000000000000040    uv 8000 00  1 130      
    cmp rcx,r15                           ;#0044AD9D: 4C:071371                  uv 00 8002  1 131 8000   
    jle #0044ADB2                         ;#0044ADA0: 176 10                     v  00 00  1 131      
    sub qword[rbx+rcx*4-16],1             ;#0044ADA2: 48:203154213 F0 01         u  00 0A  3 132      
    jne #0044ADB2                         ;#0044ADA8: 165 08                     v  00 00  1 134      
    mov rdx,rcx                           ;#0044ADAA: 48:213321                  uv 04 02  1 135      
    call #004422DA (:%pDealloc)           ;#0044ADAD: 350 2875FFFF               v  00 00  1 135      
    pop [#00402638] (printstack)          ;#0044ADB2: 217005 8078FBFF            np 00 00  3 136      
;   417         for i=1 to length(printstack) do
    mov rdi,[#00402638] (printstack)      ;#0044ADB8: 48:213075 7978FBFF         uv 80 00  1 139      
    mov rax,[rbx+rdi*4-24]                ;#0044ADBF: 48:48:213104273 E8         uv 01 88  1 142 80 *80*
    mov [rbp-56] (symtab[455]),rax        ;#0044ADC5: 48:211105 C8               uv 00 21  1 143 01   
    mov qword[rbp-64] (i),1               ;#0044ADC9: 48:307105 C0 01000000      vu 00 20  1 143      
    cmp rax,1                             ;#0044ADD1: 48:075 01000000            uv 00 01  1 144      
    jl #0044AEA8                          ;#0044ADD7: 017214 CB000000            v  00 00  1 144      
;   418             printf(fn,"    %s = %s\n",printstack[i][2..3])
    lea rdx,[rbp-32] (symtab[452])        ;#0044ADDD: 48:215125 E0               uv 04 20  1 145      
    mov rcx,2                             ;#0044ADE1: 48:307301 02000000         vu 02 00  1 145      
    push #0044AE08                        ;#0044ADE8: 150 08AE4400               uv 00 00  1 146      
    push rdx                              ;#0044ADED: 122                        vu 00 04  1 146      
    push 3                                ;#0044ADEE: 152 03                     uv 00 00  1 147      
    push 2                                ;#0044ADF0: 152 02                     vu 00 00  1 147      
    push qword[rbp-64] (i)                ;#0044ADF2: 377165 C0                  np 00 20  2 148      
    mov rsi,[#00402638] (printstack)      ;#0044ADF5: 48:213065 3C78FBFF         uv 40 00  1 150      
    mov rdx,391                           ;#0044ADFC: 48:307302 87010000         vu 04 00  1 150      
    jmp #00440F1F (:%pSubss)              ;#0044AE03: 351 1761FFFF               v  00 00  1 151      
    mov rcx,4                             ;#0044AE08: 48:307301 04000000         uv 02 00  1 152      
    mov rdx,94                            ;#0044AE0F: 48:307302 5E000000         vu 04 00  1 152      
    call #004428DB (:%opFrame) (printf)   ;#0044AE16: 350 C07AFFFF               v  00 00  1 153      
    mov rcx,[#00402618] (fn)              ;#0044AE1B: 48:213015 F677FBFF         uv 02 00  1 154      
    mov [rbp] (fn),rcx                    ;#0044AE22: 48:211115 00               uv 00 22  1 155 02   
    mov r15,h4                            ;#0044AE26: 49:277 0000000000000040    vu 8000 00  1 155      
    cmp rcx,r15                           ;#0044AE30: 4C:071371                  uv 00 8002  1 156      
    jne #0044AE48                         ;#0044AE33: 165 13                     v  00 00  1 156      
    mov rsi,387                           ;#0044AE35: 48:307306 83010000         uv 40 00  1 157      
    mov rdi,238                           ;#0044AE3C: 48:307307 EE000000         vu 80 00  1 157      
    call #00442D75 (:%pUnassigned)        ;#0044AE43: 350 2D7FFFFF               v  00 00  1 158      
    mov rdi,qword[#00402660]              ;#0044AE48: 48:213075 1178FBFF         uv 80 00  1 159      
    mov [rbp-8] (format),rdi              ;#0044AE4F: 48:211175 F8               uv 00 A0  1 160 80   
    add qword[rbx+rdi*4-16],1             ;#0044AE53: 48:203104273 F0 01         u  00 88  3 162    *80*
    mov rdi,[rbp+40] (prevebp)            ;#0044AE59: 48:213175 28               vu 80 20  1 164      
    mov rax,[rdi-32]                      ;#0044AE5D: 48:213107 E0               uv 01 80  1 167    *80*
    xor rbx,rbx                           ;#0044AE61: 48:061333                  vu 08 08  1 167      
    mov r15,h4                            ;#0044AE64: 49:277 0000000000000040    uv 8000 00  1 168      
    cmp rax,r15                           ;#0044AE6E: 4C:071370                  uv 00 8001  1 169 8000   
    jl #0044AE7E                          ;#0044AE71: 174 0B                     v  00 00  1 169      
    add qword[rbx+rax*4-16],1             ;#0044AE73: 48:203104203 F0 01         u  00 09  3 170      
    cmp eax,452                           ;#0044AE79: 075 C4010000               vu 00 01  1 172      
    mov [rbp-16] (args),rax               ;#0044AE7E: 48:211105 F0               uv 00 21  1 173      
    mov qword[retaddr],#0044AE8F          ;#0044AE82: 48:307105 20 8FAE4400      vu 00 20  1 173      
    jmp #00451A31 (code:printf)           ;#0044AE8A: 351 A26B0000               v  00 00  1 174      
;   419         end for
    mov rsi,[rbp-64] (i)                  ;#0044AE8F: 48:213165 C0               uv 40 20  1 175      
    mov rcx,[rbp-56] (symtab[455])        ;#0044AE93: 48:213115 C8               vu 02 20  1 175      
    add rsi,1                             ;#0044AE97: 48:203306 01               uv 40 40  1 176      
    cmp rsi,rcx                           ;#0044AE9B: 48:073361                  uv 00 42  1 177 40   
    mov [rbp-64] (i),rsi                  ;#0044AE9E: 48:211165 C0               vu 00 60  1 177      
    jle #0044ADDD                         ;#0044AEA2: 017216 35FFFFFF            v  00 00  1 178      
;   420     end if
    jmp #0044298D (:%opRetf)              ;#0044AEA8: 351 E07AFFFF               v  00 00  1 179      
;   421 end procedure
;   422 
;   423 -- DEV wants to be a function[?] for use in eg "type check failure, %s is %s"
;   424 --procedure short_dump(string name, object o)
;   425 --  printf(1,"%s = %s\n",{name,sprint(o,MAXLINELEN-length(name)-3)})    --(DEV -e2 only)
;   426 --  printf(1,"%s = %s\n",{name,sprint(o)})
;   427 --end procedure
;   428 
;   429 
;   430 integer lines
;   431 object crash_msg = 0
;   432 
;   433 -- copy of the one in p.exw:
;   434 integer batchmode       -- set by -batch command line option
;   435         batchmode = 0   -- 1=suppress displays/prompts [incomplete]
;   436 
;   437 procedure putz(string name, object o, integer novalue)
    mov rsi,[rbp] (name)                  ;#0044CCDB: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0044CCDF: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0044CCE9: 4C:071376                  uv 00 8040  1   2      
    jl #0044CCF5                          ;#0044CCEC: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rsi*4-1],#82             ;#0044CCEE: 200174263 FF 82            u  00 48  2   3      
    je #0044CD01                          ;#0044CCF3: 164 0C                     v  00 00  1   4      
    mov rcx,462                           ;#0044CCF5: 48:307301 CE010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044CCFC: 350 575DFFFF               v  00 00  1   5      
;   438 string s
;   439     if novalue then
    mov rcx,[rbp-16] (novalue)            ;#0044CD01: 48:213115 F0               uv 02 20  1   6      
    test rcx,rcx                          ;#0044CD05: 48:205311                  uv 00 02  1   7 02   
    je #0044CE05                          ;#0044CD08: 017204 F7000000            v  00 00  1   7      
;   440         if novalue=1 then
    cmp rcx,1                             ;#0044CD0E: 48:203371 01               uv 00 02  1   8      
    jne #0044CD2A                         ;#0044CD12: 165 16                     v  00 00  1   8      
;   441             s = "<novalue>"
    mov rdi,qword[#00402680]              ;#0044CD14: 48:213075 6559FBFF         uv 80 00  1   9      
    mov [rbp-24] (s),rdi                  ;#0044CD1B: 48:211175 E8               uv 00 A0  1  10 80   
    add qword[rbx+rdi*4-16],1             ;#0044CD1F: 48:203104273 F0 01         u  00 88  3  12    *80*
    jmp #0044CE05                         ;#0044CD25: 351 DB000000               v  00 00  1  14      
;   442         elsif novalue=2 then
    cmp rcx,2                             ;#0044CD2A: 48:203371 02               uv 00 02  1  15      
    jne #0044CD7D                         ;#0044CD2E: 165 4D                     v  00 00  1  15      
;   443             s = "*** INVALID REF ***"
    mov rax,qword[#00402688]              ;#0044CD30: 48:213005 5159FBFF         uv 01 00  1  16      
    mov rdx,[rbp-24] (s)                  ;#0044CD37: 48:213125 E8               vu 04 20  1  16      
    mov r15,h4                            ;#0044CD3B: 49:277 0000000000000040    uv 8000 00  1  17      
    cmp rax,r15                           ;#0044CD45: 4C:071370                  uv 00 8001  1  18 8000   
    jl #0044CD50                          ;#0044CD48: 174 06                     v  00 00  1  18      
    add qword[rbx+rax*4-16],1             ;#0044CD4A: 48:203104203 F0 01         u  00 09  3  19      
    mov [rbp-24] (s),rax                  ;#0044CD50: 48:211105 E8               vu 00 21  1  21      
    mov r15,h4                            ;#0044CD54: 49:277 0000000000000040    uv 8000 00  1  22      
    cmp rdx,r15                           ;#0044CD5E: 4C:071372                  uv 00 8004  1  23 8000   
    jle #0044CE05                         ;#0044CD61: 017216 9E000000            v  00 00  1  23      
    sub qword[rbx+rdx*4-16],1             ;#0044CD67: 48:203154223 F0 01         u  00 0C  3  24      
    jne #0044CE05                         ;#0044CD6D: 017205 92000000            v  00 00  1  26      
    call #004422DA (:%pDealloc)           ;#0044CD73: 350 6255FFFF               v  00 00  1  27      
    jmp #0044CE05                         ;#0044CD78: 351 88000000               v  00 00  1  28      
;   444         elsif novalue=3 then
    cmp rcx,3                             ;#0044CD7D: 48:203371 03               uv 00 02  1  29      
    jne #0044CDC5                         ;#0044CD81: 165 42                     v  00 00  1  29      
;   445             s = "*** CORRUPT TYPE BYTE ***"
    mov rsi,qword[#00402690]              ;#0044CD83: 48:213065 0659FBFF         uv 40 00  1  30      
    mov rdx,[rbp-24] (s)                  ;#0044CD8A: 48:213125 E8               vu 04 20  1  30      
    mov r15,h4                            ;#0044CD8E: 49:277 0000000000000040    uv 8000 00  1  31      
    cmp rsi,r15                           ;#0044CD98: 4C:071376                  uv 00 8040  1  32 8000   
    jl #0044CDA3                          ;#0044CD9B: 174 06                     v  00 00  1  32      
    add qword[rbx+rsi*4-16],1             ;#0044CD9D: 48:203104263 F0 01         u  00 48  3  33      
    mov [rbp-24] (s),rsi                  ;#0044CDA3: 48:211165 E8               vu 00 60  1  35      
    mov r15,h4                            ;#0044CDA7: 49:277 0000000000000040    uv 8000 00  1  36      
    cmp rdx,r15                           ;#0044CDB1: 4C:071372                  uv 00 8004  1  37 8000   
    jle #0044CE05                         ;#0044CDB4: 176 4F                     v  00 00  1  37      
    sub qword[rbx+rdx*4-16],1             ;#0044CDB6: 48:203154223 F0 01         u  00 0C  3  38      
    jne #0044CE05                         ;#0044CDBC: 165 47                     v  00 00  1  40      
    call #004422DA (:%pDealloc)           ;#0044CDBE: 350 1755FFFF               v  00 00  1  41      
    jmp #0044CE05                         ;#0044CDC3: 353 40                     v  00 00  1  42      
;   446         else
;   447             s = "*** INVALID ??? ***"
    mov rdi,qword[#00402698]              ;#0044CDC5: 48:213075 CC58FBFF         uv 80 00  1  43      
    mov rdx,[rbp-24] (s)                  ;#0044CDCC: 48:213125 E8               vu 04 20  1  43      
    mov r15,h4                            ;#0044CDD0: 49:277 0000000000000040    uv 8000 00  1  44      
    cmp rdi,r15                           ;#0044CDDA: 4C:071377                  uv 00 8080  1  45 8000   
    jl #0044CDE5                          ;#0044CDDD: 174 06                     v  00 00  1  45      
    add qword[rbx+rdi*4-16],1             ;#0044CDDF: 48:203104273 F0 01         u  00 88  3  46      
    mov [rbp-24] (s),rdi                  ;#0044CDE5: 48:211175 E8               vu 00 A0  1  48      
    mov r15,h4                            ;#0044CDE9: 49:277 0000000000000040    uv 8000 00  1  49      
    cmp rdx,r15                           ;#0044CDF3: 4C:071372                  uv 00 8004  1  50 8000   
    jle #0044CE05                         ;#0044CDF6: 176 0D                     v  00 00  1  50      
    sub qword[rbx+rdx*4-16],1             ;#0044CDF8: 48:203154223 F0 01         u  00 0C  3  51      
    jne #0044CE05                         ;#0044CDFE: 165 05                     v  00 00  1  53      
    call #004422DA (:%pDealloc)           ;#0044CE00: 350 D554FFFF               v  00 00  1  54      
;   448         end if
;   449     end if
;   450     if not batchmode then
    mov rax,[#00402678] (batchmode)       ;#0044CE05: 48:213005 6C58FBFF         uv 01 00  1  55      
    test rax,rax                          ;#0044CE0C: 48:205300                  uv 00 01  1  56 01   
    jne #0044CFE7                         ;#0044CE0F: 017205 D2010000            v  00 00  1  56      
;   451         if lines<15 then    --DEV this (15) should be a parameter (or setting?):
    mov rdi,15                            ;#0044CE15: 48:307307 0F000000         uv 80 00  1  57      
    mov rax,[#00402668] (lines)           ;#0044CE1C: 48:213005 4558FBFF         vu 01 00  1  57      
    mov rsi,0                             ;#0044CE23: 48:307306 00000000         uv 40 00  1  58      
    mov rdx,458                           ;#0044CE2A: 48:307302 CA010000         vu 04 00  1  58      
    call #0043FA81 (:%opJcc)              ;#0044CE31: 350 4B2CFFFF               v  00 00  1  59      
    jge #0044CFE7                         ;#0044CE36: 017215 AB010000            v  00 00  1  60      
;   452 --DEV should this be in put2? (and not here)
;   453 --          if sequence(crash_msg) then
;   454 --              if length(crash_msg)=0 then
;   455 --                  crash_msg = "?? length 0 crash_msg ??\n"
;   456 --              elsif crash_msg[$]!='\n' then
;   457 --                  crash_msg &= "\n"
;   458 --              end if
;   459 --              puts(1,crash_msg)
;   460 --              lines = 999
;   461 --          else
;   462                 lines += 1
    mov rcx,[#00402668] (lines)           ;#0044CE3C: 48:213015 2558FBFF         uv 02 00  1  61      
    add rcx,1                             ;#0044CE43: 48:203301 01               uv 02 02  1  62 02   
    mov rdx,rcx                           ;#0044CE47: 48:213321                  uv 04 02  1  63 02   
    mov [#00402668] (lines),rcx           ;#0044CE4A: 48:211015 1758FBFF         vu 00 02  1  63      
    shl rdx,1                             ;#0044CE51: 48:321342                  u  04 04  1  64      
    jno #0044CE62                         ;#0044CE54: 161 0C                     v  00 00  1  64      
    lea rdi,[#00402668] (lines)           ;#0044CE56: 48:215075 0B58FBFF         uv 80 00  1  65      
    call #00442DA9 (:%pAddiii)            ;#0044CE5D: 350 475FFFFF               v  00 00  1  65      
;   463                 if not novalue then
    mov rsi,[rbp-16] (novalue)            ;#0044CE62: 48:213165 F0               uv 40 20  1  66      
    test rsi,rsi                          ;#0044CE66: 48:205366                  uv 00 40  1  67 40   
    jne #0044CF2D                         ;#0044CE69: 017205 BE000000            v  00 00  1  67      
;   464                     s = sprint(o,MAXLINELEN-7-length(name))
    mov rdi,[rbp] (name)                  ;#0044CE6F: 48:213175 00               uv 80 20  1  68      
    mov rax,[rbx+rdi*4-24]                ;#0044CE73: 48:48:213104273 E8         uv 01 88  1  71 80 *80*
    mov [rbp-32] (symtab[471]),rax        ;#0044CE79: 48:211105 E0               uv 00 21  1  72 01   
    mov rdx,70                            ;#0044CE7D: 48:307302 46000000         vu 04 00  1  72      
    sub rdx,rax                           ;#0044CE84: 48:051302                  uv 04 05  1  73      
    mov [rbp-40] (symtab[472]),rdx        ;#0044CE87: 48:211125 D8               uv 00 24  1  74 04   
    mov rcx,11                            ;#0044CE8B: 48:307301 0B000000         vu 02 00  1  74      
    mov rdx,91                            ;#0044CE92: 48:307302 5B000000         uv 04 00  1  75      
    call #004428DB (:%opFrame) (sprint)   ;#0044CE99: 350 3D5AFFFF               v  00 00  1  75      
    mov rdi,[rbp+40] (prevebp)            ;#0044CE9E: 48:213175 28               uv 80 20  1  76      
    mov rax,[rdi-8]                       ;#0044CEA2: 48:213107 F8               uv 01 80  1  79 80 *80*
    xor rbx,rbx                           ;#0044CEA6: 48:061333                  vu 08 08  1  79      
    mov r15,h4                            ;#0044CEA9: 49:277 0000000000000040    uv 8000 00  1  80      
    cmp rax,r15                           ;#0044CEB3: 4C:071370                  uv 00 8001  1  81 8000   
    jl #0044CEC3                          ;#0044CEB6: 174 0B                     v  00 00  1  81      
    add qword[rbx+rax*4-16],1             ;#0044CEB8: 48:203104203 F0 01         u  00 09  3  82      
    cmp eax,463                           ;#0044CEBE: 075 CF010000               vu 00 01  1  84      
    mov [rbp] (x),rax                     ;#0044CEC3: 48:211105 00               uv 00 21  1  85      
    mov rdi,[rbp+40] (prevebp)            ;#0044CEC7: 48:213175 28               vu 80 20  1  85      
    mov rax,[rdi-40]                      ;#0044CECB: 48:213107 D8               uv 01 80  1  88    *80*
    mov [rbp-8] (l),rax                   ;#0044CECF: 48:211105 F8               uv 00 21  1  89 01   
    mov qword[retaddr],#0044CEE0          ;#0044CED3: 48:307105 20 E0CE4400      vu 00 20  1  89      
    jmp #0044D2DF (code:sprint)           ;#0044CEDB: 351 FF030000               v  00 00  1  90      
    push rax                              ;#0044CEE0: 120                        uv 00 01  1  91      
    mov rcx,[rbp-24] (s)                  ;#0044CEE1: 48:213115 E8               vu 02 20  1  91      
    mov r15,h4                            ;#0044CEE5: 49:277 0000000000000040    uv 8000 00  1  92      
    cmp rcx,r15                           ;#0044CEEF: 4C:071371                  uv 00 8002  1  93 8000   
    jle #0044CF04                         ;#0044CEF2: 176 10                     v  00 00  1  93      
    sub qword[rbx+rcx*4-16],1             ;#0044CEF4: 48:203154213 F0 01         u  00 0A  3  94      
    jne #0044CF04                         ;#0044CEFA: 165 08                     v  00 00  1  96      
    mov rdx,rcx                           ;#0044CEFC: 48:213321                  uv 04 02  1  97      
    call #004422DA (:%pDealloc)           ;#0044CEFF: 350 D653FFFF               v  00 00  1  97      
    pop dword[rbp-24] (s)                 ;#0044CF04: 217105 E8                  np 00 20  3  98      
    mov rsi,[rbp-24] (s)                  ;#0044CF07: 48:213165 E8               uv 40 20  1 101      
    mov r15,h4                            ;#0044CF0B: 49:277 0000000000000040    vu 8000 00  1 101      
    cmp rsi,r15                           ;#0044CF15: 4C:071376                  uv 00 8040  1 102      
    jl #0044CF21                          ;#0044CF18: 174 07                     v  00 00  1 102      
    cmp byte[rbx+rsi*4-1],#82             ;#0044CF1A: 200174263 FF 82            u  00 48  2 103      
    je #0044CF2D                          ;#0044CF1F: 164 0C                     v  00 00  1 104      
    mov rcx,465                           ;#0044CF21: 48:307301 D1010000         uv 02 00  1 105      
    call #00442A58 (:%opTchkFail)         ;#0044CF28: 350 2B5BFFFF               v  00 00  1 105      
;   465                 end if
;   466                 printf(1,"    %s = %s\n",{name,s})
    lea rax,[rbp-48] (symtab[473])        ;#0044CF2D: 48:215105 D0               uv 01 20  1 106      
    mov rdx,2                             ;#0044CF31: 48:307302 02000000         vu 04 00  1 106      
    push #0044CF85                        ;#0044CF38: 150 85CF4400               uv 00 00  1 107      
    push rax                              ;#0044CF3D: 120                        vu 00 01  1 107      
    mov rdi,[rbp-24] (s)                  ;#0044CF3E: 48:213175 E8               uv 80 20  1 108      
    mov r15,h4                            ;#0044CF42: 49:277 0000000000000040    vu 8000 00  1 108      
    cmp rdi,r15                           ;#0044CF4C: 4C:071377                  uv 00 8080  1 109      
    jl #0044CF5C                          ;#0044CF4F: 174 0B                     v  00 00  1 109      
    add qword[rbx+rdi*4-16],1             ;#0044CF51: 48:203104273 F0 01         u  00 88  3 110      
    cmp eax,465                           ;#0044CF57: 075 D1010000               vu 00 01  1 112      
    push rdi                              ;#0044CF5C: 127                        uv 00 80  1 113      
    mov rax,[rbp] (name)                  ;#0044CF5D: 48:213105 00               vu 01 20  1 113      
    mov r15,h4                            ;#0044CF61: 49:277 0000000000000040    uv 8000 00  1 114      
    cmp rax,r15                           ;#0044CF6B: 4C:071370                  uv 00 8001  1 115 8000   
    jl #0044CF7B                          ;#0044CF6E: 174 0B                     v  00 00  1 115      
    add qword[rbx+rax*4-16],1             ;#0044CF70: 48:203104203 F0 01         u  00 09  3 116      
    cmp eax,462                           ;#0044CF76: 075 CE010000               vu 00 01  1 118      
    push rax                              ;#0044CF7B: 120                        uv 00 01  1 119      
    mov rdi,[rbp-48] (symtab[473])        ;#0044CF7C: 48:213175 D0               vu 80 20  1 119      
    jmp #004404BD (:%pMkSq)               ;#0044CF80: 351 3835FFFF               v  00 00  1 120      
    mov rcx,4                             ;#0044CF85: 48:307301 04000000         uv 02 00  1 121      
    mov rdx,94                            ;#0044CF8C: 48:307302 5E000000         vu 04 00  1 121      
    call #004428DB (:%opFrame) (printf)   ;#0044CF93: 350 4359FFFF               v  00 00  1 122      
    mov qword[rbp] (fn),1                 ;#0044CF98: 48:307105 00 01000000      uv 00 20  1 123      
    mov rcx,qword[#00402660]              ;#0044CFA0: 48:213015 B956FBFF         vu 02 00  1 123      
    mov [rbp-8] (format),rcx              ;#0044CFA7: 48:211115 F8               uv 00 22  1 124      
    add qword[rbx+rcx*4-16],1             ;#0044CFAB: 48:203104213 F0 01         u  00 0A  3 126    *02*
    mov rdi,[rbp+40] (prevebp)            ;#0044CFB1: 48:213175 28               vu 80 20  1 128      
    mov rax,[rdi-48]                      ;#0044CFB5: 48:213107 D0               uv 01 80  1 131    *80*
    xor rbx,rbx                           ;#0044CFB9: 48:061333                  vu 08 08  1 131      
    mov r15,h4                            ;#0044CFBC: 49:277 0000000000000040    uv 8000 00  1 132      
    cmp rax,r15                           ;#0044CFC6: 4C:071370                  uv 00 8001  1 133 8000   
    jl #0044CFD6                          ;#0044CFC9: 174 0B                     v  00 00  1 133      
    add qword[rbx+rax*4-16],1             ;#0044CFCB: 48:203104203 F0 01         u  00 09  3 134      
    cmp eax,473                           ;#0044CFD1: 075 D9010000               vu 00 01  1 136      
    mov [rbp-16] (args),rax               ;#0044CFD6: 48:211105 F0               uv 00 21  1 137      
    mov qword[retaddr],#0044CFE7          ;#0044CFDA: 48:307105 20 E7CF4400      vu 00 20  1 137      
    jmp #00451A31 (code:printf)           ;#0044CFE2: 351 4A4A0000               v  00 00  1 138      
;   467 --          end if
;   468         end if
;   469     end if
;   470     if fn!=-1 then
    mov rdi,-1                            ;#0044CFE7: 48:307307 FFFFFFFF         uv 80 00  1 139      
    mov rax,[#00402618] (fn)              ;#0044CFEE: 48:213005 2356FBFF         vu 01 00  1 139      
    mov rsi,24                            ;#0044CFF5: 48:307306 18000000         uv 40 00  1 140      
    mov rdx,387                           ;#0044CFFC: 48:307302 83010000         vu 04 00  1 140      
    call #0043FAF6 (:%opJccE)             ;#0044D003: 350 EE2AFFFF               v  00 00  1 141      
    je #0044D14B                          ;#0044D008: 017204 3D010000            v  00 00  1 142      
;   471         if novalue then
    mov rsi,[rbp-16] (novalue)            ;#0044D00E: 48:213165 F0               uv 40 20  1 143      
    test rsi,rsi                          ;#0044D012: 48:205366                  uv 00 40  1 144 40   
    je #0044D0DA                          ;#0044D015: 017204 BF000000            v  00 00  1 144      
;   472             printf(fn,"    %s = %s\n",{name,s})
    lea rax,[rbp-48] (symtab[473])        ;#0044D01B: 48:215105 D0               uv 01 20  1 145      
    mov rdx,2                             ;#0044D01F: 48:307302 02000000         vu 04 00  1 145      
    push #0044D073                        ;#0044D026: 150 73D04400               uv 00 00  1 146      
    push rax                              ;#0044D02B: 120                        vu 00 01  1 146      
    mov rdi,[rbp-24] (s)                  ;#0044D02C: 48:213175 E8               uv 80 20  1 147      
    mov r15,h4                            ;#0044D030: 49:277 0000000000000040    vu 8000 00  1 147      
    cmp rdi,r15                           ;#0044D03A: 4C:071377                  uv 00 8080  1 148      
    jl #0044D04A                          ;#0044D03D: 174 0B                     v  00 00  1 148      
    add qword[rbx+rdi*4-16],1             ;#0044D03F: 48:203104273 F0 01         u  00 88  3 149      
    cmp eax,465                           ;#0044D045: 075 D1010000               vu 00 01  1 151      
    push rdi                              ;#0044D04A: 127                        uv 00 80  1 152      
    mov rcx,[rbp] (name)                  ;#0044D04B: 48:213115 00               vu 02 20  1 152      
    mov r15,h4                            ;#0044D04F: 49:277 0000000000000040    uv 8000 00  1 153      
    cmp rcx,r15                           ;#0044D059: 4C:071371                  uv 00 8002  1 154 8000   
    jl #0044D069                          ;#0044D05C: 174 0B                     v  00 00  1 154      
    add qword[rbx+rcx*4-16],1             ;#0044D05E: 48:203104213 F0 01         u  00 0A  3 155      
    cmp eax,462                           ;#0044D064: 075 CE010000               vu 00 01  1 157      
    push rcx                              ;#0044D069: 121                        uv 00 02  1 158      
    mov rdi,[rbp-48] (symtab[473])        ;#0044D06A: 48:213175 D0               vu 80 20  1 158      
    jmp #004404BD (:%pMkSq)               ;#0044D06E: 351 4A34FFFF               v  00 00  1 159      
    mov rcx,4                             ;#0044D073: 48:307301 04000000         uv 02 00  1 160      
    mov rdx,94                            ;#0044D07A: 48:307302 5E000000         vu 04 00  1 160      
    call #004428DB (:%opFrame) (printf)   ;#0044D081: 350 5558FFFF               v  00 00  1 161      
    mov rax,[#00402618] (fn)              ;#0044D086: 48:213005 8B55FBFF         uv 01 00  1 162      
    mov [rbp] (fn),rax                    ;#0044D08D: 48:211105 00               uv 00 21  1 163 01   
    mov rsi,qword[#00402660]              ;#0044D091: 48:213065 C855FBFF         vu 40 00  1 163      
    mov [rbp-8] (format),rsi              ;#0044D098: 48:211165 F8               uv 00 60  1 164      
    add qword[rbx+rsi*4-16],1             ;#0044D09C: 48:203104263 F0 01         u  00 48  3 166    *40*
    mov rdi,[rbp+40] (prevebp)            ;#0044D0A2: 48:213175 28               vu 80 20  1 168      
    mov rax,[rdi-48]                      ;#0044D0A6: 48:213107 D0               uv 01 80  1 171    *80*
    xor rbx,rbx                           ;#0044D0AA: 48:061333                  vu 08 08  1 171      
    mov r15,h4                            ;#0044D0AD: 49:277 0000000000000040    uv 8000 00  1 172      
    cmp rax,r15                           ;#0044D0B7: 4C:071370                  uv 00 8001  1 173 8000   
    jl #0044D0C7                          ;#0044D0BA: 174 0B                     v  00 00  1 173      
    add qword[rbx+rax*4-16],1             ;#0044D0BC: 48:203104203 F0 01         u  00 09  3 174      
    cmp eax,473                           ;#0044D0C2: 075 D9010000               vu 00 01  1 176      
    mov [rbp-16] (args),rax               ;#0044D0C7: 48:211105 F0               uv 00 21  1 177      
    mov qword[retaddr],#0044D0D8          ;#0044D0CB: 48:307105 20 D8D04400      vu 00 20  1 177      
    jmp #00451A31 (code:printf)           ;#0044D0D3: 351 59490000               v  00 00  1 178      
    jmp #0044D14B                         ;#0044D0D8: 353 71                     v  00 00  1 179      
;   473         else
;   474             clever_dump(name, o)
    mov rcx,9                             ;#0044D0DA: 48:307301 09000000         uv 02 00  1 180      
    mov rdx,447                           ;#0044D0E1: 48:307302 BF010000         vu 04 00  1 180      
    call :%opFrame (clever_dump)          ;#0044D0E8: 350 EE57FFFF               v  00 00  1 181      
    mov rdi,[rbp+40] (prevebp)            ;#0044D0ED: 48:213175 28               uv 80 20  1 182      
    mov rax,[rdi]                         ;#0044D0F1: 48:213007                  uv 01 80  1 185 80 *80*
    xor rbx,rbx                           ;#0044D0F4: 48:061333                  vu 08 08  1 185      
    mov r15,h4                            ;#0044D0F7: 49:277 0000000000000040    uv 8000 00  1 186      
    cmp rax,r15                           ;#0044D101: 4C:071370                  uv 00 8001  1 187 8000   
    jl #0044D111                          ;#0044D104: 174 0B                     v  00 00  1 187      
    add qword[rbx+rax*4-16],1             ;#0044D106: 48:203104203 F0 01         u  00 09  3 188      
    cmp eax,462                           ;#0044D10C: 075 CE010000               vu 00 01  1 190      
    mov [rbp] (name),rax                  ;#0044D111: 48:211105 00               uv 00 21  1 191      
    mov rdi,[rbp+40] (prevebp)            ;#0044D115: 48:213175 28               vu 80 20  1 191      
    mov rax,[rdi-8]                       ;#0044D119: 48:213107 F8               uv 01 80  1 194    *80*
    xor rbx,rbx                           ;#0044D11D: 48:061333                  vu 08 08  1 194      
    mov r15,h4                            ;#0044D120: 49:277 0000000000000040    uv 8000 00  1 195      
    cmp rax,r15                           ;#0044D12A: 4C:071370                  uv 00 8001  1 196 8000   
    jl #0044D13A                          ;#0044D12D: 174 0B                     v  00 00  1 196      
    add qword[rbx+rax*4-16],1             ;#0044D12F: 48:203104203 F0 01         u  00 09  3 197      
    cmp eax,463                           ;#0044D135: 075 CF010000               vu 00 01  1 199      
    mov [rbp-8] (o),rax                   ;#0044D13A: 48:211105 F8               uv 00 21  1 200      
    mov qword[retaddr],#0044D14B          ;#0044D13E: 48:307105 20 4BD14400      vu 00 20  1 200      
    jmp #0044AAD9 (code:clever_dump)      ;#0044D146: 351 8ED9FFFF               v  00 00  1 201      
;   475         end if
;   476     end if
    jmp #0044298D (:%opRetf)              ;#0044D14B: 351 3D58FFFF               v  00 00  1 202      
;   477 end procedure
;   478 
;   479 procedure put2(string emsg)
    mov rcx,[rbp] (emsg)                  ;#0044D150: 48:213115 00               uv 02 20  1   1      
    mov r15,h4                            ;#0044D154: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rcx,r15                           ;#0044D15E: 4C:071371                  uv 00 8002  1   2      
    jl #0044D16A                          ;#0044D161: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rcx*4-1],#82             ;#0044D163: 200174213 FF 82            u  00 0A  2   3      
    je #0044D176                          ;#0044D168: 164 0C                     v  00 00  1   4      
    mov rcx,475                           ;#0044D16A: 48:307301 DB010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044D171: 350 E258FFFF               v  00 00  1   5      
;   480     if not batchmode then
    mov rdi,[#00402678] (batchmode)       ;#0044D176: 48:213075 FB54FBFF         uv 80 00  1   6      
    test rdi,rdi                          ;#0044D17D: 48:205377                  uv 00 80  1   7 80   
    jne #0044D2A7                         ;#0044D180: 017205 21010000            v  00 00  1   7      
;   481         if lines<15 then
    mov rdi,15                            ;#0044D186: 48:307307 0F000000         uv 80 00  1   8      
    mov rax,[#00402668] (lines)           ;#0044D18D: 48:213005 D454FBFF         vu 01 00  1   8      
    mov rsi,0                             ;#0044D194: 48:307306 00000000         uv 40 00  1   9      
    mov rdx,458                           ;#0044D19B: 48:307302 CA010000         vu 04 00  1   9      
    call #0043FA81 (:%opJcc)              ;#0044D1A2: 350 DA28FFFF               v  00 00  1  10      
    jge #0044D2A7                         ;#0044D1A7: 017215 FA000000            v  00 00  1  11      
;   482             if sequence(crash_msg) then
    mov rsi,[#00402670] (crash_msg)       ;#0044D1AD: 48:213065 BC54FBFF         uv 40 00  1  12      
    mov r15,h4                            ;#0044D1B4: 49:277 0000000000000040    vu 8000 00  1  12      
    cmp rsi,r15                           ;#0044D1BE: 4C:071376                  uv 00 8040  1  13      
    jl #0044D271                          ;#0044D1C1: 017214 AA000000            v  00 00  1  13      
;   483                 if length(crash_msg)=0 then
    mov rcx,[rbx+rsi*4-24]                ;#0044D1C7: 48:48:213114263 E8         uv 02 48  1  14      
    cmp rcx,0                             ;#0044D1CD: 48:203371 00               uv 00 02  1  15 02   
    jne #0044D216                         ;#0044D1D1: 165 43                     v  00 00  1  15      
;   484                     crash_msg = "?? length 0 crash_msg ??\n"
    mov rdi,qword[#004026A8]              ;#0044D1D3: 48:213075 CE54FBFF         uv 80 00  1  16      
    mov r15,h4                            ;#0044D1DA: 49:277 0000000000000040    vu 8000 00  1  16      
    cmp rdi,r15                           ;#0044D1E4: 4C:071377                  uv 00 8080  1  17      
    jl #0044D1EF                          ;#0044D1E7: 174 06                     v  00 00  1  17      
    add qword[rbx+rdi*4-16],1             ;#0044D1E9: 48:203104273 F0 01         u  00 88  3  18      
    mov [#00402670] (crash_msg),rdi       ;#0044D1EF: 48:211075 7A54FBFF         vu 00 80  1  20      
    mov r15,h4                            ;#0044D1F6: 49:277 0000000000000040    uv 8000 00  1  21      
    cmp rsi,r15                           ;#0044D200: 4C:071376                  uv 00 8040  1  22 8000   
    jle #0044D251                         ;#0044D203: 176 4C                     v  00 00  1  22      
    sub qword[rbx+rsi*4-16],1             ;#0044D205: 48:203154263 F0 01         u  00 48  3  23      
    jne #0044D251                         ;#0044D20B: 165 44                     v  00 00  1  25      
    mov edx,esi                           ;#0044D20D: 211362                     uv 04 40  1  26      
    call #004422DA (:%pDealloc)           ;#0044D20F: 350 C650FFFF               v  00 00  1  26      
    jmp #0044D251                         ;#0044D214: 353 3B                     v  00 00  1  27      
;   485                 elsif crash_msg[$]!='\n' then
    mov rdi,-1                            ;#0044D216: 48:307307 FFFFFFFF         uv 80 00  1  28      
    lea rcx,[rbp-16] (symtab[478])        ;#0044D21D: 48:215115 F0               vu 02 20  1  28      
    mov rdx,459                           ;#0044D221: 48:307302 CB010000         uv 04 00  1  29      
    call #00441675 (:%pSubse1)            ;#0044D228: 350 4844FFFF               v  00 00  1  29      
    mov rax,[rbp-16] (symtab[478])        ;#0044D22D: 48:213105 F0               uv 01 20  1  30      
    cmp rax,10                            ;#0044D231: 48:203370 0A               uv 00 01  1  31 01   
    je #0044D251                          ;#0044D235: 164 1A                     v  00 00  1  31      
;   486                     crash_msg &= "\n"
    lea rdx,[#00402670] (crash_msg)       ;#0044D237: 48:215025 3254FBFF         uv 04 00  1  32      
    lea rdi,[#00402670] (crash_msg)       ;#0044D23E: 48:215075 2B54FBFF         vu 80 00  1  32      
    lea rcx,qword[#00402600]              ;#0044D245: 48:215015 B453FBFF         uv 02 00  1  33      
    call #00440021 (:%opConcat)           ;#0044D24C: 350 D02DFFFF               v  00 00  1  33      
;   487                 end if
;   488                 puts(1,crash_msg)
    mov rax,1                             ;#0044D251: 48:307300 01000000         uv 01 00  1  34      
    mov rdx,[#00402670] (crash_msg)       ;#0044D258: 48:213025 1154FBFF         vu 04 00  1  34      
    call #0043E218 (:%opPuts)             ;#0044D25F: 350 B40FFFFF               v  00 00  1  35      
;   489                 lines = 999
    mov qword[#00402668] (lines),999      ;#0044D264: 48:307005 F953FBFF E7030000 uv 00 00  1  36      
    jmp #0044D2A7                         ;#0044D26F: 353 36                     v  00 00  1  36      
;   490             else
;   491                 lines += 1
    mov rcx,[#00402668] (lines)           ;#0044D271: 48:213015 F053FBFF         uv 02 00  1  37      
    add rcx,1                             ;#0044D278: 48:203301 01               uv 02 02  1  38 02   
    mov rdx,rcx                           ;#0044D27C: 48:213321                  uv 04 02  1  39 02   
    mov [#00402668] (lines),rcx           ;#0044D27F: 48:211015 E253FBFF         vu 00 02  1  39      
    shl rdx,1                             ;#0044D286: 48:321342                  u  04 04  1  40      
    jno #0044D297                         ;#0044D289: 161 0C                     v  00 00  1  40      
    lea rdi,[#00402668] (lines)           ;#0044D28B: 48:215075 D653FBFF         uv 80 00  1  41      
    call #00442DA9 (:%pAddiii)            ;#0044D292: 350 125BFFFF               v  00 00  1  41      
;   492                 puts(1,emsg)
    mov rax,1                             ;#0044D297: 48:307300 01000000         uv 01 00  1  42      
    mov rdx,[rbp] (emsg)                  ;#0044D29E: 48:213125 00               vu 04 20  1  42      
    call #0043E218 (:%opPuts)             ;#0044D2A2: 350 710FFFFF               v  00 00  1  43      
;   493             end if
;   494         end if
;   495     end if
;   496     if fn!=-1 then
    mov rdi,-1                            ;#0044D2A7: 48:307307 FFFFFFFF         uv 80 00  1  44      
    mov rax,[#00402618] (fn)              ;#0044D2AE: 48:213005 6353FBFF         vu 01 00  1  44      
    mov rsi,24                            ;#0044D2B5: 48:307306 18000000         uv 40 00  1  45      
    mov rdx,387                           ;#0044D2BC: 48:307302 83010000         vu 04 00  1  45      
    call #0043FAF6 (:%opJccE)             ;#0044D2C3: 350 2E28FFFF               v  00 00  1  46      
    je #0044D2DA                          ;#0044D2C8: 164 10                     v  00 00  1  47      
;   497         puts(fn,emsg)
    mov rax,[#00402618] (fn)              ;#0044D2CA: 48:213005 4753FBFF         uv 01 00  1  48      
    mov rdx,[rbp] (emsg)                  ;#0044D2D1: 48:213125 00               vu 04 20  1  48      
    call #0043E218 (:%opPuts)             ;#0044D2D5: 350 3E0FFFFF               v  00 00  1  49      
;   498     end if
    jmp #0044298D (:%opRetf)              ;#0044D2DA: 351 AE56FFFF               v  00 00  1  50      
;   499 end procedure
;   500 
;   501 without type_check  -- NB. This code is just too low-level.
;   502 -- If you remove the above in the hope that it will help, you will 
;   503 --  probably be disappointed. You tend to get eg:
;   504 --      diag looping (minimal diagnostics follow); error code is:30
;   505 --      ep1 is C0000005
;   506 --      ep2 is 00000000
;   507 --      era is 00409E9B
;   508 --      ern is 3186
;   509 
;   510 constant swod = 0 -- 1=show without debug routines and vars
;   511 
;   512 --
;   513 -- *NB* These must be kept in very strict order, never delete or insert entries.
;   514 --
;   515 constant msgs =
;   516 {
;   517  "type check failure, %s is %s\n",                              -- e01tcf
;   518     -- As called from opTchk, when var-id is known (idx in ecx).
;   519     -- See also e110tce, called when var_id not known (addr in ecx).
;   520     -- Note: s[i+1] gives a type check failure with a ???[S_name]=0
;   521     --  if i is #3FFFFFFF, as unnamed temporary index sums are given 
;   522     --  an integer type (for performance reasons). Obviously that is
;   523     --  less than ideal and ought to be fixed one day. [DEV]
;   524  "attempt to divide by 0\n",                                    -- e02atdb0
;   525  "true/false condition must be an ATOM\n",                      -- e03tfcmbaa
;   526     -- Usually only happens on "if x then" where x is not 
;   527     -- a relational expression (eg a=b) but is either a 
;   528     -- single variable or a function result. (unlike RDS)
;   529     -- see also e14NNsoXa. Note this message may not occur
;   530     -- on subscripted items when a program is compiled, eg
;   531     -- if x is {1,2,"fred",4} then "if x[3] then" is just 
;   532     -- treated as true (not zero), though you should get
;   533     -- an error when the same code is interpreted. This is
;   534     -- a deliberate optimisation.
;   535 --DEV maybe we shouldn't inline unless it's a sequence of integer?
;   536  "attempt to subscript an atom\n",                              -- e04atsaa
;   537  "subscript is not an atom\n",                                  -- e05sinaa
;   538  "index %d out of bounds, assigning to sequence length %d\n",   -- e06ioob
;   539  "slice start is less than 1 (%d)\n",                           -- e07ssilt1
;   540     -- Note that the value shown is that after adjustment 
;   541     -- for negative indexes, eg if length(x) is 10, then
;   542     -- x[-11..10] will complain ssilt1 (0) as -11 maps to 0.
;   543     -- see e10sspeos. In fact e07ssilt1 only ocurs for 0. [Erm? DEV test that]
;   544     -- Obviously if the slice start is a variable, rather
;   545     -- than an expression, the "true" value can be found
;   546     -- elsewhere in the ex.err file.
;   547  "slice end is not an integer\n",                               -- e08seinai
;   548  "slice length is negative [%d..%d]\n",                         -- e09slin
;   549     -- values shown are as adjusted for negative indexes, [DEV?]
;   550     --  eg if length(s)=4, then s[-1..-3] shows as [4..2]
;   551     -- see also comments against e07ssilt1.
;   552  "slice starts past end of sequence (%d > %d)\n",               -- e10sspeos
;   553     -- or slice start(%d) less than negative length(%d), see below
;   554  "slice ends past end of sequence (%d > %d)\n",                 -- e11sepeos
;   555     -- or slice end(%d) less than negative length(%d), see below
;   556  "program aborted\n",                                           -- e12pa
;   557     -- Operator has typed '!' in the trace() window.
;   558  "attempt to exit a function without returning a value\n",      -- e13ateafworav
;   559     -- For an example of why this cannot/should not be trapped 
;   560     -- as a compile-time error, see isChecked() in arwen.ew.
;   561  "sequence op (%s) attempted (use sq_%s?)\n",                   -- e14NNsoXa
;   562     -- Phix does not support implicit/infix sequence ops;
;   563     -- you must use explicit function-style calls, ie/eg
;   564     -- replace "{1,2}+3" with "sq_add({1,2},3)" to get {4,5}.
;   565     --  (Acutally, in the name of compatibility with legacy code,
;   566     --   it will replace some of the most blatently obvious cases,
;   567     --   see sqopWarn in p.exw/pmain.e)
;   568     -- Note that name="Pete" yields 1 or 0 (True/False) on Phix,
;   569     -- instead of eg {0,1,0,1}, "sequence lengths not the same",
;   570     -- or the infamous "true/false condition must be an ATOM".
;   571     -- (the latter can still happen, just nowhere near as often)
;   572     -- Forcing "+" to be replaced with "sq_add" is better, IMNSHO, than
;   573     -- forcing "=" to be replaced with "equal", as happens with RDS Eu.
;   574     -- (nb some legacy code may need "=" to be replaced with "sq_eq")
;   575     -- Also the compile-time errors "type error (use sq_add?)" et al
;   576     -- catch a significant number of cases before it gets to this.
;   577     -- Lastly, there is no sense, for example, in changing the infix
;   578     -- relational ops (<,<=,=,!=,>=,>) to always return a boolean but
;   579     -- still allowing maths ops (+,-,*,/) to do sequence ops. This 
;   580     -- would spanner all legacy code even more, for example the old
;   581     -- upper/lower would work fine on chars but leave all sequences/
;   582     -- strings completely unchanged. It is far more helpful to sound
;   583     -- this alarm than silently go wrong.
;   584  "unrecognised c_func return type\n",                           -- e15ucfrt
;   585     -- Note that C_FLOAT, E_INTEGER, E_ATOM, and E_OBJECT have not
;   586     --  been attempted/tested and hence report this error.
;   587     -- (for the latter 3 I require a suitable RDS-Eu-compiled DLL)  --DEV
;   588     -- BTW: E_INTEGER, E_ATOM, E_SEQUENCE, and E_OBJECT are only
;   589     --  used for RDS-Eu-compiled DLLs, new values (P_XXX?) will
;   590     --  have to be devised for Phix-compiled DLLs, if/when that
;   591     --  becomes possible.
;   592  "call_backs cannot have optional parameters\n",                -- e16cbchop
;   593     -- There is no way for Phix to determine how many parameters
;   594     --  some C/asm/other language has pushed onto the stack, shy 
;   595     --  of entire program dissassembly/analysis that is, and not
;   596     --  that I have ever seen a callback with anything other than
;   597     --  a fixed number of parameters (and if I ever did, then my
;   598     --  answer would be a separate "call_back_var_args" routine).
;   599     -- If you want optional/defaulted parameters for the benefit
;   600     --  of other Phix code, then you may need a "thin wrapper":
;   601     --  function varfunc(a=?, b=?,...)
;   602     --      ....
;   603     --  end function
;   604     --  ---nono = call_back(routine_id("varfunc")) -- this error
;   605     --  function fixfunc(a,b,...)
;   606     --      return varfunc(a,b,...) -- a "thin wrapper"
;   607     --  end function
;   608     --  cb_xx = call_back(routine_id("fixfunc"))
;   609     -- Hence you can call varfunc with more or less parameters,
;   610     --  whereas cb_xx is always invoked with a known fixed set.
;   611  "sequence op (mul) attempted (use sq_mul?)\n",                 -- e17soma      -- """"""""""""""" --
;   612  "sequence op (remainder) attempted (use sq_remainder?)\n",     -- e18sora      -- """"""""""""""" --
;   613  "sequence op (floor) attempted (use sq_floor?)\n",             -- e19sofa      -- """"""""""""""" --
;   614  "invalid match start index\n",                                 -- e20imsi
;   615  "invalid find start index\n",                                  -- e21ifsi
;   616     -- In find('3',"123",s), s of 1..3 and -1..-3 yield 3,
;   617     --  4 yields 0, but all other values, including non-atoms,
;   618     --  unassigned variables, and s<=-4, yield this error.
;   619     --  Of course -1, being shorthand for length(), is the 
;   620     --  same as 3 in the above, and -3 is the same as 1.
;   621     -- Aside: find('.',filename,-5) could be used to quickly
;   622     --  find a file extension of 4 or less characters. While
;   623     --  length+1 can be helpful, as resuming on lastresult+1
;   624     --  is a common idiom, there is no similar equivalent for
;   625     --  negative subscripts. It may turn out that just simply
;   626     --  ignoring bad (integer) starts and returning 0 makes
;   627     --  for an easier life, I could easily do that if the 
;   628     --  common consus suggests it would be better, though it
;   629     --  seems to me more likely to catch bugs/typos this way.
;   630  "invalid mem_copy length\n",                                   -- e22imcl
;   631     -- number of bytes to copy is negative
;   632  "invalid mem_set length\n",                                    -- e23imsl
;   633     -- number of bytes to set is negative
;   634     --  (ditto)
;   635  "invalid mem_copy memory address\n",                           -- e24imcma
;   636     -- a machine exception occurred in a mem_copy operation
;   637  "invalid mem_set memory address\n",                            -- e25imsma
;   638     -- a machine exception occurred in a mem_set operation
;   639  "invalid argument type for integer := peek()\n",               -- e26iatfpi
;   640     -- Occurs, for example, in:
;   641     --  integer i
;   642     --      i = peek({addr,4}).
;   643     -- Technically speaking, opPeeki is called (if not inlined,
;   644     --  that is) instead of the normal opPeek, because it knows
;   645     --  the result ought to be an integer. The former has no
;   646     --  dealloc code, and no code for the above, so instead it
;   647     --  displays this message. Arguably, it should perform the
;   648     --  peek anyway, then typecheck - but that would only make
;   649     --  things slower. Also, arguably the above should fail to
;   650     --  compile, though we would still have to handle the more
;   651     --  general i=peek(object) case with this run-time message.
;   652  "argument to rand() must be >= 1\n",                           -- e27atrmbge1
;   653  "argument to %s() must be an atom (use sq_%s?)\n",             -- e28NNatXmbausq
;   654  "argument to set_rand() must be an atom\n",                    -- e29atsrmba
;   655  "fatal exception %s at #%08x\n",                               -- e30ume
;   656     -- Unknown machine error.
;   657     --
;   658     -- It is pretty much the job of this program, with help
;   659     -- from the back end, to map such errors in Phix hll
;   660     -- code to human-readable form. As per the note above,
;   661     -- when an error occurs in some dll/asm code, this is
;   662     -- about the best I can do (with a line no of "-1", unless
;   663     -- it is part of a #ilasm statement), and hopefully there 
;   664     -- are enough clues later on in the ex.err to guide you 
;   665     -- towards solving the problem. However this message should 
;   666     -- not occur for "pure hll code".
;   667     --
;   668     -- There are literally thousands of places in the backend 
;   669     -- where it catches/maps exceptions, and without any doubt
;   670     -- there will be several left that were accidentally missed.
;   671     --
;   672     -- Generally speaking, addresses in the range #00400000 
;   673     -- to #0040C000 indicate a problem in the back-end, please
;   674     -- contact the author (Pete Lomax) for assistance, and/or
;   675     -- see plist.e, flag dumpVM/the list2.asm that creates.
;   676     --
;   677  "memory corruption: eax is #%08x, edx is #%08x\n",             -- e31mce
;   678     -- only occurs on debug builds
;   679  "heap corruption [era=%08x, edi=%08x]\n",                      -- e32hc(era,edi)
;   680     -- oh dear...
;   681  "argument to arctan() must be atom (use sq_arctan?)\n",        -- e33atatmba   -- no longer in use (see e28)
;   682  "power() function underflow\n",                                -- e34pfu
;   683     -- result is less than -1.7976931348623146e308
;   684     -- (technically the term underflow is usually
;   685     --  used to mean "too near zero", btw, which
;   686     --  just makes power() quietly return a zero.)
;   687  "power() function overflow\n",                                 -- e35pfo
;   688     -- result is more than +1.7976931348623146e308
;   689  "length of an atom is not defined\n",                          -- e36loaaind
;   690  "argument to allocate() must be positive integer\n",           -- e37atambpi
;   691  "argument to free() must be an atom\n",                        -- e38atfmba
;   692  "arguments to mem_copy() must be atoms\n",                     -- e39atmcmba
;   693  "arguments to mem_set() must be atoms\n",                      -- e40atmsmba
;   694  "first argument to poke() must be atom\n",                     -- e41fatpmba
;   695  "first argument to poke4() must be atom\n",                    -- e42fatp4mba
;   696  "argument to peek() must be atom or sequence of two atoms\n",  -- e43atpmbaoso2a
;   697  "argument to peek4s() must be atom or sequence of two atoms\n", -- e44atpmbaoso2a
;   698  "argument to peek4u() must be atom or sequence of two atoms\n", -- e45atpmbaoso2a
;   699  "argument to float32_to_atom() must be sequence of length 4\n", -- e46atf32tambsol4
;   700  "argument to float64_to_atom() must be sequence of length 8\n", -- e47atf64tambsol8
;   701     -- btw, the above messages occur for an unassigned argument, rather
;   702     --  than the usual e92/"variable xxx has not been assigned a value".
;   703 -- "argument to chdir() must be string\n",                      -- e48atcdmbs
;   704  -1,                                                            -- no longer in use
;   705  "argument to atom_to_float32() must be atom\n",                -- e49atatf32mba
;   706  "argument to atom_to_float64() must be atom\n",                -- e50atatf64mba
;   707  "HeapFree error code [%08x]\n",                                -- e51hfec
;   708     -- Should not happen. Suggests that your program has
;   709     -- corrupted memory, the operating system free chain, 
;   710     -- for instance. Try using safe.e (see that file for
;   711     -- instructions) and/or a debug version of p.exe. -- DEV
;   712     -- Make a copy of the program source, then repeatedly
;   713     -- delete as many lines as possible while the error
;   714     -- still occurs. If you can get it to under 100 lines
;   715     -- (program no longer has to do anything useful, btw)
;   716     -- then you can submit it for further investigation.
;   717  "repeat count must be non negative integer\n",                 -- e52rcmbnni
;   718  -1,--"for loop error\n",                                       -- e53fle           --DEV see e120,1
;   719  "attempt to raise negative number to non-integer power\n",     -- e54atrnntnip
;   720     -- mathematically, power(-3,-3) is an imaginary number.
;   721  -1,--"first argument to append() must be sequence\n",              -- e55fatambs
;   722     -- You may mean a&b instead of append(a,b)
;   723     -- Note that append("one","two") is {'o','n','e',"two"},
;   724     -- whereas "one"&"two" is "onetwo", although they 
;   725     -- give the same results if b is an atom.
;   726  -1,--"first argument to prepend() must be sequence\n",             -- e56fatpmbs
;   727     -- You may mean b&a instead of prepend(a,b)
;   728     -- Note that prepend("two","one") is {"one",'t','w','o'},
;   729     -- whereas "one"&"two" is "onetwo", although they 
;   730     -- give the same results if b is an atom.
;   731  "invalid file name\n",                                         -- e57ifn
;   732     -- A common cause of this is using append instead of &:
;   733     --  append("C:\test\","fred.txt") returns the nested
;   734     --  {'C',':','\','t','e','s','t','\',"fred.txt"}, whereas
;   735     --  "C:\test\"&"fred.txt" returns "C:\test\fred.txt".
;   736     -- Remember that "append(s,x)" always returns a sequence (or 
;   737     --  string) of length(s)+1, whereas "s&x" returns a sequence 
;   738     --  (or string) of length(s)+length(x) [that is, except when 
;   739     --  x is an atom, in which case they are equivalent].
;   740  "invalid file number (%d)\n",                                  -- e58bfn(edi)
;   741     -- file must be open for getc, puts, seek, where, etc.
;   742  "wrong file mode for attempted operation\n",                   -- e59wfmfao
;   743     -- eg attempt to read a file after open(x,"w").
;   744  "file number is not an integer\n",                             -- e60fninai
;   745     -- this error is also common for unassigned vars.
;   746  "invalid open mode\n",                                         -- e61iom
;   747     -- second parameter to open must be (r|w|a|u)[b].
;   748     -- BTW, Phix allows single-character modes, eg 'r',
;   749     -- whereas RDS Eu does not.
;   750  "file number %d is not open\n",                                -- e62fnnino
;   751  "second parameter of seek() must be an atom\n",                -- e63sposmba
;   752  "seek fail on open append\n",                                  -- e64sfooa
;   753     -- after successfully opening a file for append
;   754     -- (fn=open(xxx,"a")), it automatically seeks to
;   755     -- the end of file. This seek has failed.
;   756     -- This should not happen, maybe you found a bug,
;   757     -- or maybe your hard drive has errors.
;   758  "sequence found in character string\n",                        -- e65sfics
;   759     -- second parameter to puts or [s]printf may not
;   760     -- contain nested sequences. See e55/56/57, or
;   761     -- try using pp(), ppf(), ?, or [s]print().
;   762  "invalid lock type\n",                                         -- e66ilt
;   763  "byterange must be {} or pair of atoms\n",                     -- e67bre
;   764  -1,--"argument to dir() must be string\n",                     -- e68atcdmbs (not actually used/see pdir.e)
;   765     -- See e73atodmbs
;   766  "error in format string\n",                                    -- e69eifs (see pprntf.e/badfmt())
;   767     -- Missing or unrecognised format character after a '%',
;   768     --  eg "%", "%3.2", "%q". See also e73atodmbs.
;   769  "insufficient values for (s)printf()\n",                       -- e70ivfpf
;   770  -1,--"argument to getenv() must be string",                    -- e71atgmbs (not actually used/see penv.e)
;   771     -- See e73atodmbs
;   772  "invalid routine_id(%d)\n",                                    -- e72iri(edi)
;   773     -- The first argument to call_proc/func, or call_back (which
;   774     -- can also accept {'+',rtnid} as the first argument) is not
;   775     -- an integer, is not in the range 1..length(symtab), or
;   776     -- symtab[i] is not a type, function, or procedure. Usually 
;   777     -- occurs after a previous call to routine_id, define_c_func, 
;   778     -- etc returned -1.
;   779 --DEV++
;   780  "argument to open_dll() must be string\n",                     -- e73atodmbs
;   781     -- Either the parameter is not a sequence, or some element
;   782     -- of it is not a character. Note that strings and flat
;   783     -- dword sequences are equally acceptable, eg/ie "kernel32"
;   784     -- or {'k','e','r','n','e','l','3','2'} work the same.
;   785  "define_c_func/proc parameter error\n",                        -- e74dcfpe
;   786     -- the first argument to define_c_func/proc is:
;   787     --   an atom, and the second is either unassigned,
;   788     --                       a sequence of length zero,
;   789     --               or a sequence containing non-chars, or
;   790     --   a sequence, with non-zero length, or the second
;   791     --               parameter is unassigned or sequence.
;   792     -- ie the legal forms of define_c_func/proc are:
;   793     --      define_c_func/proc(atom,name,...)
;   794     --      define_c_func/proc({},addr,...)
;   795  "call back routine parameters must all be atoms\n",            -- e75cbrpmaba
;   796  "%c requires an atom value\n",                                 -- e76pcraav
;   797  "program has run out of memory\n",                             -- e77phroom
;   798  "attempt to get_text() >1GB file\n",                           -- e78atgtgt1gbf
;   799     -- You *can* read very large files line-by-line, or 
;   800     --  byte-by-byte, or via seeks, but *not* load the 
;   801     --  whole thing into memory at once (1GB is about
;   802     --  300 copies of the bible, a lot of text).
;   803  "argument to rand() must be an atom\n",                        -- e79atrmba
;   804  -1,                                                            -- e80 no longer in use
;   805  "insufficient parameters in call_func/proc()\n",               -- e81ipicfp
;   806     -- second argument to call_func/proc must be a sequence
;   807     -- containing at least the number of non-defaluted elements 
;   808     -- declared as parameters for the specified routine.
;   809  "argument to call() must be atom\n",                           -- e82atcmba                --DEV 8/6/15: I suspect this is no longer in use...
;   810     -- Note that Phix allows a call() to a call_back()
;   811     -- whereas RDS Eu suffers a machine exception.
;   812  "arguments to position() must be integer\n",                   -- e83atpmbi
;   813  "call_back parameter must be routine_id or {'+',routine_id}\n", -- e84cbpmbropr
;   814 
;   815  -1,                                                            -- e85 no longer used
;   816  "argument to trace() must be integer 0..3\n",                  -- e86attmbi03
;   817     -- technically -1 is also valid, and implements the same as
;   818     -- keying 'Q' in the trace() window, ie permanently off.
;   819  "abort() code must be integer\n",                              -- e87acmbi
;   820  "arguments to c_func() must be atoms or strings\n",            -- e88atcfpmbaos
;   821  "too many parameters in call_func/proc()\n",                   -- e89tmpicfp
;   822  "argument to profile() must be 0 or 1\n",                      -- e90atpmb01
;   823 -- "profile internal error\n",                                  -- e91pie   [DEV]
;   824  "variable %s has not been assigned a value\n",                 -- e91vhnbaav(ecx)
;   825     -- or_ecx is var no
;   826  "variable %s has not been assigned a value\n",                 -- e92vhnbaav(esi)
;   827     -- or_esi is var no
;   828  "variable %s has not been assigned a value\n",                 -- e93vhnbaav(edi) [:%opPpndSA]
;   829     -- or_edi is var address
;   830  "variable %s has not been assigned a value\n",                 -- e94vhnbaav(edx)
;   831     -- as e92 but or_edx is var no
;   832 --DEV these appear untested:::
;   833  "text_color error [%08x]\n",                                   -- e95tce
;   834  "bk_color error [%08x]\n",                                     -- e96bce
;   835  "heap error [%s]\n",                                           -- e97he
;   836  "flush error [%s]\n",                                          -- e98fiofe
;   837     -- internal kernel32 WriteFile failure when writing the
;   838     -- contents of a file buffer. Code is from Microsoft.
;   839     -- Unlikely, should not happen, maybe a scandisk
;   840     -- is needed, maybe your hard drive is failing...
;   841  "invalid peek memory address\n",                               -- e99ipma
;   842     -- A MEMORY VIOLATION (#C0000005) exception occured when
;   843     --  trying to read from the supplied memory address.
;   844     -- Can occur on peek[(2|4|8)(u|s)]() calls, if they are
;   845     --  passed a bad location or an impossible (-ve) length.
;   846  "invalid poke memory address\n",                               -- e100ipma
;   847     -- A MEMORY VIOLATION (#C0000005) exception occured when
;   848     --  trying to write to the supplied memory address.
;   849     -- Can occur in poke[(1|2|4|8)]() calls, if they are 
;   850     --  passsed a bad location or an invalid length.
;   851  "attempt to allocate string of negative length\n",             -- e101atasonl
;   852     -- internal error in the back end. The only way application
;   853     -- code could attempt something similar is repeat(' ',-n),
;   854     -- which is caught as e52rcmbnni before getting this far,
;   855     -- and, e37atambpi handles -ve values passed to allocate().
;   856     -- NB: a line no of -1 is expected should this occur; there
;   857     --     is no known way to deliberately cause this error.
;   858     -- (this message was added to catch bugs in gets().)
;   859  "attempt to raise 0 to power <= 0\n",                          -- e102cr0tple0
;   860  "attempt to get remainder of a number divided by 0\n",         -- e103atgrondb0
;   861  "call back error?\n",                                          -- e104cbe [DEV no longer used]
;   862  "not enough format strings to print data\n",                   -- e105nefstpd (pprntf.e only)
;   863     -- May be removed for compatibility reasons, see pprntf.e.
;   864  "index %d out of bounds, reading sequence length %d\n",        -- e106ioob
;   865     -- (edi,edx)
;   866  -1,                                                            -- e107 - DEV no longer used
;   867  "position error [%s]\n",                                       -- e108pe
;   868     -- Maybe the co-ordinates specified are outside the boundaries
;   869     -- of the (Windows) screen buffer. See also e83atpmbi, which
;   870     -- occurs for attempts to position at negative coordinates.
;   871  "clear_screen error\n",                                        -- e109cse
;   872     -- Internal error, should not happen (and in fact this
;   873     --  message has never been successfully triggered)
;   874  "type check failure, %s is %s\n",                              -- e110tce(ecx)
;   875     -- as e01tcf but ecx is var addr not idx
;   876  "bitwise operations are limited to 32-bit numbers\n",          -- e111bolt32b
;   877     -- DEV: it may be sensible to permit and_bits(x,#FFFFFFFF),
;   878     -- or in fact any and_bits op where either param is 32-bit:
;   879     -- In the case of and_bits, this message only occurs if both
;   880     -- arguments are larger than 32 bits.
;   881  "second argument of find() must be a sequence\n",              -- e112saofmbs
;   882  "second argument of match() must be a sequence\n",             -- e113saommbs
;   883  "sequence to be poked must only contain atoms\n",              -- e114stbpmoca
;   884  "argument to sleep() must be atom\n",                          -- e115atsmba
;   885  "routine requires %d parameters, not %d\n",                    -- e116rrnp
;   886     -- either the define_c_func/proc statement is wrong, or
;   887     --  the c_func/proc statement is wrong.
;   888  "routine does not return a value\n",                           -- e117rdnrav
;   889     -- typically this means the program is using c_func
;   890     --  to invoke a routine defined using define_c_proc
;   891  "routine returns a value\n",                                   -- e118rrav
;   892     -- typically this means the program is using c_proc
;   893     --  to invoke a routine defined using define_c_func
;   894 --DEV this should go:
;   895  "file number is not an integer or {fn,c}\n",                   -- e119fninaiofnc
;   896     -- gets() can accept an integer file number or a sequence
;   897     -- {fn,c} to read an entire text file in one operation.
;   898     --  fn is an open file (>2) with filepos 0, and c is one of:
;   899     --  -2: read file as one long string, with embedded '\n',
;   900     --  -1: return sequence of '\n'-stripped lines,
;   901     --   0: return sequence of lines as-is,
;   902     --   1: return sequence of lines with '\n' forced on last.
;   903     -- While gets({fn,c}) may be a useful shorthand for small
;   904     --  files, it is not recommended for anything over 1MB.
;   905     --  When processing larger files, a strategy which reads
;   906     --  a chunk (or just one line), processes it and discards
;   907     --  it before moving onto the next is much more likely to
;   908     --  achieve better performance than reading the whole hog
;   909     --  into memory at the start. Also, here are three sound
;   910     --  reasons not to meddle with working legacy code:
;   911     --      * You may introduce bugs
;   912     --      * It is unlikely to be noticeably faster
;   913     --      * It will be incompatible with RDS Eu
;   914  "for loop error, %s is %s\n",                              -- e120fle
;   915     -- Phix does not permit floating point for loops, since
;   916     -- they do not work (eg on RDS Eu, try for x=1.1 to 1.3 
;   917     -- by 0.1 do ?x end for; you only get 1.1 and 1.2 output).
;   918     -- Replace eg 'for x=1.0 to 2.0 by 0.1 do ... end for'
;   919     -- with 'atom x=1.0 for j=10 to 20 do ... x+=0.1 end for'
;   920     -- Can also be triggered by using large integers.
;   921     -- The "illegal expression type" compile-time error also 
;   922     -- helps to catch most such problems in legacy code.
;   923     -- NB: ep1 is init value (not var no)
;   924  "for loop error, limit is %s, step is %s\n",                   -- e121flelimstep
;   925     -- As above, Phix does not permit floating point for loops.
;   926     -- This extends to final values, for example if you get
;   927     --  for loop error, limit is 900,000,000, step is 800,000,000
;   928     -- then it is because 1,700,000,000 is > 1,073,741,823.
;   929     -- NB: ep1 is limit value, ep2 is step value (no var nos)
;   930  -1}
;   931 
;   932 --constant e14ops = {"add","sub","div","mul","remainder","floor","unary minus","not",
;   933 --                 "and_bits","or_bits","xor_bits","not_bits","power","xor"},
;   934 --       e28ops = {"rand","cos","sin","tan","arctan","log","sqrt"}
;   935 
;   936 --DEV use NTdesc from pglobals.e?: (no, we don't have that here!)
;   937 constant rtndescs = {"type","function", "procedure"}
;   938 
;   939 --
;   940 -- Symbol table constants/structure
;   941 --  duplicates from pglobals.e, needed for bound .exes
;   942 --   (there are *no globals* in this file, unless you count
;   943 --    external refs to printf/sprintf/stuff from ppp.e)
;   944 --
;   945 constant 
;   946          S_Name = 1,    -- const/var/rtn name
;   947          S_NTyp = 2,    -- Const/GVar/TVar/Nspc/Type/Func/Proc
;   948          S_FPno = 3,    -- File and Path number
;   949          S_State = 4,   -- state flag. S_fwd/S_used/S_set
;   950 --       S_Nlink = 5,   -- hash link
;   951          S_Slink = 6,   -- localscopeX link
;   952 -- constants and variables [S_NTyp<=S_TVar]
;   953 --       S_vtype = 7,   -- variable type or namespace fileno
;   954 --       S_value = 8,   -- value
;   955          S_Tidx = 9,    -- thread idx (S_NTyp=S_Tvar only)
;   956 --       S_ErrV = 10,   -- {'v', file, line, col}; see pmain.e[-35]
;   957 --       S_Init = 11,   -- Initialised chain (known init if non-0/see S_Const note below)
;   958 -- routines [S_NTyp>=S_Type]
;   959 --       S_sig  = 7,    -- routine signature
;   960          S_Parm1 = 8,   -- first parameter. (idx to symtab, follow S_Slink)
;   961 --       S_ParmN = 9,   -- minimum no of parameters (max is length(S_sig)-1)
;   962 --       S_Ltot = 10,   -- total no of parameters, locals, and temporary vars
;   963                         -- (needed to allocate the stack frame space)
;   964          S_il   = 11,   -- intermediate code
;   965          S_ltab = 12,   -- line table (packed when compiled, raw when interpreted)
;   966          S_1stl = 13,   -- first line (of "procedure"/"function"/"type" keyword)
;   967 --       S_Efct = 14,
;   968 --       S_ErrR = 15    -- {'R', file, line, col}; see pmain.e[-60]
;   969 $
;   970 
;   971 constant 
;   972 --       S_Const = 1,   -- symtab[i][S_NTyp] values
;   973          S_GVar2 = 2,   -- global or static variable
;   974          S_TVar3 = 3,   -- temp or threadstack (local) variable/parameter
;   975 --       S_Nspc = 4,    -- namespace
;   976 --       S_Rsvd = 5,
;   977          S_Type = 6,    -- Type of thermal yellow portable encryptor
;   978 --       S_Func = 7,    -- Function of finding unusual nonsense comments
;   979 --       S_Proc = 8     -- Procedure for private rotating obstacle counter
;   980          K_wdb = #100   -- with debug setting
;   981 
;   982 constant
;   983          T_pathset = 16,
;   984          T_fileset = 17,
;   985          T_cmdlnflg = 19,
;   986 --       T_callstk = 20,
;   987          T_maintls = 21,
;   988          T_EBP     = 22,    -- compiled/listing=0, interpreted={ebp4,esp4,sym4} (set at last possible moment)
;   989          T_ds4     = 23,    
;   990          T_const1  = 26
;   991 
;   992 --DEV should this just be a parameter to getVal?
;   993 --integer lc    -- limit counter (set to 500)
;   994 --integer showellipse -- set if lc blown
;   995 --integer novalue
;   996 
;   997 --constant
;   998 --  kernel32 = open_dll("kernel32.dll"),
;   999 --
;  1000 --  C_PTR = C_POINTER,
;  1001 --
;  1002 ----#without reformat
;  1003 --  xIsBadReadPtr = define_c_func(kernel32, "IsBadReadPtr",
;  1004 --      {C_PTR,     --  CONST VOID  * lp,   // address of memory block
;  1005 --       C_INT},    --  UINT  ucb   // size of block
;  1006 --      C_INT)      -- BOOL
;  1007 ----#with reformat
;  1008 
;  1009 --/*
;  1010 function getVal(atom addr)
;  1011 object  result,
;  1012         o
;  1013 integer vtyp, len, keep
;  1014     novalue = 0         -- control flag, to prevent ppExf of "<novalue>" result
;  1015 --DEV 64bit
;  1016     if machine_bits()=32 then
;  1017         result = peek4s(addr)   --DEV crash here after e91pie
;  1018         if result<#40000000 then    -- a 31-bit integer
;  1019             return result
;  1020         end if
;  1021         result -= #40000000
;  1022     else
;  1023         result = peek8s(addr)   --DEV crash here after e91pie
;  1024         if result<#4000000000000000 then    -- a 63-bit integer
;  1025             return result
;  1026         end if
;  1027         result -= #4000000000000000
;  1028     end if
;  1029     if result=0 then
;  1030         novalue = 1
;  1031         return "<novalue>"
;  1032     end if
;  1033     addr = result*4
;  1034 
;  1035 --  if c_func(xIsBadReadPtr,{addr,1}) then
;  1036 --      --DEV 64bit? (should be alright...)
;  1037 --      result = sprintf("<**diag.e: bad ptr** (#%08x)>\n",addr)
;  1038 --      puts(1,result)
;  1039 --      return result
;  1040 --  end if
;  1041 
;  1042     vtyp = peek(addr-1)
;  1043     if vtyp=#12 then        -- a 64-bit float
;  1044         if machine_bits()=32 then
;  1045             result = peek({addr,8})
;  1046             return float64_to_atom(result)
;  1047         else
;  1048             result = peek({addr,10})
;  1049             return float80_to_atom(result)
;  1050         end if
;  1051     end if
;  1052     if machine_bits()=32 then
;  1053         len = peek4s(addr-12)
;  1054     else
;  1055         len = peek8s(addr-24)
;  1056     end if
;  1057 --  if not diagBase then    -- (old style handling)
;  1058 --      addr = peek4u(addr-20)
;  1059 --  end if
;  1060     if vtyp=#82 then        -- an 8-bit ascii string
;  1061         if len>lc then
;  1062             len = lc
;  1063             lc = 0
;  1064             showellipse = 1
;  1065         end if
;  1066         return peek({addr,len})
;  1067     end if
;  1068     if vtyp!=#80 then       -- sanity check: must be a sequence then.
;  1069         novalue = 1
;  1070         result = sprintf("<**GARBAGE/CORRUPT TYPE BYTE** (#%02x at [#%08x])>\n",{vtyp,addr-1})
;  1071         puts(1,result)
;  1072         return result
;  1073     end if
;  1074     result = {}
;  1075     while len and lc do
;  1076         lc -= 1
;  1077         len -= 1
;  1078 --#without reformat
;  1079 if 0 then -- new code 12/6/10 (show more of eg allfiles)
;  1080         if lc>99 and len and showellipse=0 then
;  1081             keep = lc-99
;  1082             lc = 99
;  1083             o = getVal(addr)
;  1084             if showellipse then
;  1085                 if string(o) then
;  1086                     o &= "..."
;  1087                     showellipse = 0
;  1088                 else
;  1089                     -- (oops!) quit, so ellipse shows near the break
;  1090                     -- (which is added in getValue, once outta here)
;  1091                     exit
;  1092                 end if
;  1093             end if
;  1094             result = append(result,o)
;  1095             lc += keep
;  1096         else
;  1097             result = append(result,getVal(addr))
;  1098         end if
;  1099 else
;  1100         result = append(result,getVal(addr))
;  1101 end if
;  1102 --#with reformat
;  1103         if machine_bits()=32 then
;  1104             addr += 4
;  1105         else
;  1106             addr += 8
;  1107         end if
;  1108     end while
;  1109     if len then
;  1110         showellipse = 1
;  1111     end if
;  1112     return result
;  1113 end function
;  1114 --*/
;  1115 
;  1116 --
;  1117 -- NB: the or_xxx are held as refs, eg after string str="abc" #ilASM{ mov ecx,[str] }
;  1118 --  then [or_ecx] might be the atom #40100888 such that shl ecx,2 yields #00402220, and
;  1119 --  [#0040221F] is #82 and [#00402220] is 'a'. Likewise for floats/dword-sequences.
;  1120 --  (see builtins\VM\pHeap.e notes for some more details if any of that confuses you)
;  1121 --
;  1122 --  Also, h4 (unassigned) may show as 1073741824 (32bit) or 4.6116860185e+18 (64bit),
;  1123 --  (just for the or_xxx), at least until some extra code is added somewhere in here.
;  1124 --  Of course, should any of these values (or anything else from pDiagN.e) appear in 
;  1125 --  an ex.err (presumably because you took out the "without debug"), they are being 
;  1126 --DEV is that just or_ebp?
;  1127 --  manipulated on-the-fly and bear little or no resemblance to values at the point 
;  1128 --  of the crash, and should (with quite some justification) be regarded as complete 
;  1129 --  and utter gibberish. To be precise, they are far more believable if deliberately 
;  1130 --  displayed on-screen, in here or pFEH.e, than when they are incidentally printed 
;  1131 --  as a run-of-the-mill type thing, as is the case if they ever appear in an ex.err.
;  1132 
;  1133 --integer exception = 0
;  1134 --integer rtn           -- routine no, initially from symtab[T_callstk], then from callstack
;  1135 integer or_ebp          -- from the exception context, or the real ebp (pre-diag()) [stored/4]
;  1136 atom or_esp,            -- from the exception context, or the real esp
;  1137      xceptn,            -- exception code or 0
;  1138      xcepta,            -- exception address or 0
;  1139      or_ecx,            -- from the exception context, or the real ecx
;  1140      or_era,            -- effective return address (may==xcepta)
;  1141      or_edx,            -- from the exception context - not available if xceptn==0!
;  1142      or_esi,            -- from the exception context, or the real esi
;  1143      or_edi             -- from the exception context, or the real edi
;  1144 --   era                -- return address, initially from symtab[T_callstk] then callstack
;  1145 --   etd                -- threadstack addr
;  1146 
;  1147 --/*
;  1148 SUG:
;  1149 --function or_string(atom a)
;  1150 function or_ref(atom a)
;  1151 object o
;  1152 --  if integer(a) then return sprint(a) end if
;  1153     if integer(a) then return a end if
;  1154     #ilASM{
;  1155         [32]
;  1156             mov eax,[a]
;  1157             push ebx
;  1158             fld qword[ebx+eax*4]
;  1159             fistp dword[esp]
;  1160             pop eax
;  1161             add dword[ebx+eax*4-8],1
;  1162             mov [o],eax
;  1163         [64]
;  1164             mov rax,[a]
;  1165             push rbx
;  1166             fld tbyte[rbx+rax*4]
;  1167             fistp qword[rsp]
;  1168             pop rax
;  1169             add qword[rbx+rax*4-16],1
;  1170             mov [o],rax
;  1171         []
;  1172           }
;  1173 --  return sprint(o)
;  1174     return o
;  1175 end function
;  1176 --*/
;  1177 
;  1178 --constant repch = "\r\n\t",
;  1179 --       repstrs = {"\\r","\\n","\\t"}
;  1180 
;  1181 --object symtab     -- copy of symtab obtained via :%opGetST (see pStack.e)
;  1182 
;  1183 --constant unassigned = "<unassigned>"
;  1184 
;  1185 integer ds4
;  1186 
;  1187 function getGvarValue(integer gidx)
;  1188 integer novalue
;  1189 object res
;  1190 --      (maxop+gidx+2)*dsize+8
;  1191     #ilASM{
;  1192             mov [novalue],0
                    mov qword[rbp-8] (novalue),0  ;#0044DD19: 48:307105 F8 00000000      uv 00 20  1   1      
;  1193         [32]
;  1194 --DEV gvarptr@[vsb_root+12]...
;  1195 -- or symtab[T_EBP][4] (maxop of 0)
;  1196 --          lea esi,[ds+16]     -- maxgvar aka gvar[0], less maxop entries
;  1197 --          mov ecx,[ds+12]     -- maxop
;  1198 --DEV fixme
;  1199 --          add ecx,[gidx]
;  1200             mov esi,[ds4]
;  1201             mov edx,[gidx]
;  1202             shl esi,2
;  1203 --          add ecx,edx
;  1204 --          mov esi,[esi+ecx*4] -- ([maxgvar+(gidx+maxop)*4] == gvar[gidx])
;  1205             mov esi,[esi+edx*4+16] -- ([ds+(gidx+4)*4] == gvar[gidx])
;  1206 --untried:
;  1207 --          mov esi,[ds+ecx*4+16]
;  1208 --27/2/15:
;  1209 --          mov esi,[ebp+24]        -- vsb_root
;  1210 --          mov edx,[gidx]
;  1211 --          mov esi,[esi+12]        -- gvarptr
;  1212 --          mov esi,[esi+edx*4-4]   -- gvar[gidx]
;  1213             cmp esi,h4
;  1214             jne @f
;  1215                 mov [novalue],1
;  1216                 mov [res],0
;  1217                 jmp :done
;  1218           @@:
;  1219             jl @f
;  1220                 -- Note: this is fairly simplistic: we could go much further,
;  1221                 -- (DEV) with a recursive check on nested sequences (including
;  1222                 --       that it ain't circular), the entire length is valid,
;  1223                 --       and there is a pRoot locating "SBH\0" as per pHeap.e
;  1224                 --       Yes, I know MSDN says "This function is obsolete and
;  1225                 --       should not be used", but it /is/ reasonable here as
;  1226                 --       we will very shortly terminate the program anyway.
;  1227                 lea edi,[ebx+esi*4-1]
;  1228             [PE32]
;  1229                 push 1      -- UINT_PTR ucb
;  1230                 push edi    -- LPVOID lp
;  1231                 call "kernel32.dll","IsBadWritePtr"
;  1232             [ELF32]
;  1233                 pop al -- (or we could just skip this entirely)
;  1234             [32]
;  1235                 test eax,eax
;  1236                 jz :typeaddrok
;  1237                     mov [novalue],2 -- invalid ref
;  1238                     mov [res],0
;  1239                     jmp :done
;  1240               ::typeaddrok
;  1241                 mov cl,[edi]
;  1242                 cmp cl,#12
;  1243                 je :typebyteok
;  1244                 cmp cl,#80
;  1245                 je :typebyteok
;  1246                 cmp cl,#82
;  1247                 je :typebyteok
;  1248                     mov [novalue],3 -- corrupt type byte
;  1249                     mov [res],0
;  1250                     jmp :done
;  1251               ::typebyteok
;  1252                 add dword[ebx+esi*4-8],1
;  1253           @@:
;  1254             mov [res],esi
;  1255         [64]
;  1256 --pop al
;  1257 --          lea rsi,[ds+24]     -- maxgvar aka gvar[0], less maxop entries
;  1258 --          mov rcx,[ds+16]     -- maxop
;  1259 --DEV fixme
;  1260 --          add rcx,[gidx]
;  1261             mov rsi,[ds4]
                    mov rsi,[#00402B30] (ds4)  ;#0044DD21: 48:213065 084EFBFF         vu 40 00  1   1      
;  1262             mov rdx,[gidx]
                    mov rdx,[rbp] (gidx)  ;#0044DD28: 48:213125 00               uv 04 20  1   2      
;  1263             shl rsi,2
                    shl rsi,2             ;#0044DD2C: 48:301346 02               u  40 40  1   3      
;  1264 --          add rcx,rdx
;  1265 --          mov rsi,[rsi+rcx*8] -- ([maxgvar+(gidx+maxop)*8] == gvar[gidx])
;  1266             mov rsi,[rsi+rdx*8+24] -- ([ds+(gidx+3)*8] == gvar[gidx])
                    mov rsi,[rsi+rdx*8+24]  ;#0044DD30: 48:213164326 18            uv 40 44  1   6 40 *44*
;  1267 --untried:
;  1268 --          mov rax,[ds+rcx*8+24]
;  1269 --27/2/15:
;  1270 --          mov rsi,[rbp+48]        -- vsb_root
;  1271 --          mov rdx,[gidx]
;  1272 --          mov rsi,[rsi+24]        -- gvarptr
;  1273 --          mov rsi,[rsi+rdx*8-8]   -- gvar[gidx]
;  1274             mov r15,h4
                    mov r15,h4            ;#0044DD35: 49:277 0000000000000040    vu 8000 00  1   6      
;  1275             cmp rsi,r15
                    cmp rsi,r15           ;#0044DD3F: 49:073367                  uv 00 8040  1   7      
;  1276             jne @f
                    jne #0044DD56         ;#0044DD42: 165 12                     v  00 00  1   7      
;  1277                 mov [novalue],1
                        mov qword[rbp-8] (novalue),1  ;#0044DD44: 48:307105 F8 01000000      uv 00 20  1   8      
;  1278                 mov [res],0
                        mov qword[rbp-16] (res),0  ;#0044DD4C: 48:307105 F0 00000000      vu 00 20  1   8      
;  1279                 jmp :done
                        jmp #0044DDC5     ;#0044DD54: 353 6F                     v  00 00  1   9      
;  1280           @@:
;  1281             jl @f
                    jl #0044DDC1          ;#0044DD56: 174 69                     v  00 00  1  10      
;  1282                 -- ditto (as [32])
;  1283                 lea rdi,[rbx+rsi*4-1]
                        lea rdi,[rbx+rsi*4-1]  ;#0044DD58: 48:215174263 FF            uv 80 48  1  11      
;  1284             [PE64]
;  1285                 mov rcx,rsp -- put 2 copies of rsp onto the stack...
                        mov rcx,rsp       ;#0044DD5D: 48:213314                  vu 02 10  1  11      
;  1286                 push rsp
                        push rsp          ;#0044DD60: 48:124                     uv 00 10  1  12      
;  1287                 push rcx
                        push rcx          ;#0044DD62: 48:121                     vu 00 02  1  12      
;  1288                 or rsp,8    -- [rsp] is now 1st or 2nd copy:
                        or rsp,8          ;#0044DD64: 48:203314 08               uv 10 10  1  13      
;  1289                             -- if on entry rsp was xxx8: both copies remain on the stack
;  1290                             -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1291                             -- obviously rsp is now xxx8, whatever alignment we started with
;  1292                 sub rsp,8*5                 -- shadow space and align
                        sub rsp,40        ;#0044DD68: 48:203354 28               uv 10 10  1  14 10   
;  1293                 mov rdx,1                   -- UINT_PTR ucb
                        mov rdx,1         ;#0044DD6C: 48:307302 01000000         vu 04 00  1  14      
;  1294                 mov rcx,rdi                 -- LPVOID lp
                        mov rcx,rdi       ;#0044DD73: 48:213317                  uv 02 80  1  15      
;  1295                 call "kernel32.dll","IsBadWritePtr"
                        call [#004010D0] (IsBadWritePtr)  ;#0044DD76: 377025 5433FBFF            np 00 00  2  16      
;  1296 --              add rsp,8*5
;  1297 --              pop rsp     -- restore, equivalent to rsp += (either #08 or #10)
;  1298                 mov rsp,[rsp+8*5]   -- equivalent to add/pop
                        mov rsp,[rsp+40]  ;#0044DD7C: 48:213144044 28            uv 10 10  1  18      
;  1299             [ELF64]
;  1300                 pop al
;  1301             [64]
;  1302                 test rax,rax
                        test rax,rax      ;#0044DD81: 48:205300                  vu 00 01  1  18      
;  1303                 jz :typeaddrok
                        jz #0044DD98      ;#0044DD84: 164 12                     v  00 00  1  19      
;  1304                     mov [novalue],2 -- invalid ref
                            mov qword[rbp-8] (novalue),2  ;#0044DD86: 48:307105 F8 02000000      uv 00 20  1  20      
;  1305                     mov [res],0
                            mov qword[rbp-16] (res),0  ;#0044DD8E: 48:307105 F0 00000000      vu 00 20  1  20      
;  1306                     jmp :done
                            jmp #0044DDC5  ;#0044DD96: 353 2D                     v  00 00  1  21      
;  1307               ::typeaddrok
;  1308                 mov cl,[rdi]
                        mov cl,[edi]      ;#0044DD98: 212017                     uv 02 80  1  22      
;  1309                 cmp cl,#12
                        cmp cl,#12        ;#0044DD9A: 200371 12                  uv 00 02  1  23 02   
;  1310                 je :typebyteok
                        je #0044DDBB      ;#0044DD9D: 164 1C                     v  00 00  1  23      
;  1311                 cmp cl,#80
                        cmp cl,#80        ;#0044DD9F: 200371 80                  uv 00 02  1  24      
;  1312                 je :typebyteok
                        je #0044DDBB      ;#0044DDA2: 164 17                     v  00 00  1  24      
;  1313                 cmp cl,#82
                        cmp cl,#82        ;#0044DDA4: 200371 82                  uv 00 02  1  25      
;  1314                 je :typebyteok
                        je #0044DDBB      ;#0044DDA7: 164 12                     v  00 00  1  25      
;  1315                     mov [novalue],3 -- corrupt type byte
                            mov qword[rbp-8] (novalue),3  ;#0044DDA9: 48:307105 F8 03000000      uv 00 20  1  26      
;  1316                     mov [res],0
                            mov qword[rbp-16] (res),0  ;#0044DDB1: 48:307105 F0 00000000      vu 00 20  1  26      
;  1317                     jmp :done
                            jmp #0044DDC5  ;#0044DDB9: 353 0A                     v  00 00  1  27      
;  1318               ::typebyteok
;  1319                 add qword[rbx+rsi*4-16],1
                        add qword[rbx+rsi*4-16],1  ;#0044DDBB: 48:203104263 F0 01         u  00 48  3  28      
;  1320           @@:
;  1321             mov [res],rsi
                    mov [rbp-16] (res),rsi  ;#0044DDC1: 48:211165 F0               vu 00 60  1  30      
;  1322         []
;  1323           ::done
;  1324           } 
;  1325 --  res = sprintf("%s [gidx=%d, ds4=%d]",{sprint(res),gidx,ds4})
;  1326     return {novalue,res}    -- ({0,whatever} or {1\2\3,0})
    mov rcx,[rbp-8] (novalue)             ;#0044DDC5: 48:213115 F8               uv 02 20  1  31      
    mov r15,h4                            ;#0044DDC9: 49:277 0000000000000040    vu 8000 00  1  31      
    cmp rcx,r15                           ;#0044DDD3: 4C:071371                  uv 00 8002  1  32      
    jne #0044DDE4                         ;#0044DDD6: 165 0C                     v  00 00  1  32      
    mov rsi,627                           ;#0044DDD8: 48:307306 73020000         uv 40 00  1  33      
    call #00442D75 (:%pUnassigned)        ;#0044DDDF: 350 914FFFFF               v  00 00  1  33      
    lea rax,[rbp-24] (symtab[629])        ;#0044DDE4: 48:215105 E8               uv 01 20  1  34      
    mov rdx,2                             ;#0044DDE8: 48:307302 02000000         vu 04 00  1  34      
    push #0044DE1E                        ;#0044DDEF: 150 1EDE4400               uv 00 00  1  35      
    push rax                              ;#0044DDF4: 120                        vu 00 01  1  35      
    mov rsi,[rbp-16] (res)                ;#0044DDF5: 48:213165 F0               uv 40 20  1  36      
    mov r15,h4                            ;#0044DDF9: 49:277 0000000000000040    vu 8000 00  1  36      
    cmp rsi,r15                           ;#0044DE03: 4C:071376                  uv 00 8040  1  37      
    jl #0044DE13                          ;#0044DE06: 174 0B                     v  00 00  1  37      
    add qword[rbx+rsi*4-16],1             ;#0044DE08: 48:203104263 F0 01         u  00 48  3  38      
    cmp eax,628                           ;#0044DE0E: 075 74020000               vu 00 01  1  40      
    push rsi                              ;#0044DE13: 126                        uv 00 40  1  41      
    push rcx                              ;#0044DE14: 121                        vu 00 02  1  41      
    mov rdi,[rbp-24] (symtab[629])        ;#0044DE15: 48:213175 E8               uv 80 20  1  42      
    jmp #004404BD (:%pMkSq)               ;#0044DE19: 351 9F26FFFF               v  00 00  1  42      
    mov rax,[rbp-24] (symtab[629])        ;#0044DE1E: 48:213105 E8               uv 01 20  1  43      
    mov [rbp-24] (symtab[629]),rbx        ;#0044DE22: 48:211135 E8               vu 00 28  1  43      
    jmp #0044298D (:%opRetf)              ;#0044DE26: 351 624BFFFF               v  00 00  1  44      
;  1327 end function
;  1328 
;  1329 function getTvarValue(integer tidx)
;  1330 --
;  1331 -- tidx is 0,-1,-2,-3, etc as per symtab[N][S_Tidx],
;  1332 --  for [ebp], [ebp-4], [ebp-8], [ebp-12], [ebp-16],
;  1333 --   or [rbp], [rbp-8], [rbp-16], [rbp-24], [rsp-32],
;  1334 --  where ebp/rbp is as stored in or_ebp.
;  1335 --
;  1336 integer novalue
;  1337 object res
;  1338     #ilASM{
;  1339             mov [novalue],0
                    mov qword[rbp-8] (novalue),0  ;#0044DC08: 48:307105 F8 00000000      uv 00 20  1   1      
;  1340         [32]
;  1341             mov esi,[or_ebp]
;  1342             mov ecx,[tidx]
;  1343             shl esi,2
;  1344             mov esi,[esi+ecx*4]
;  1345             cmp esi,h4
;  1346             jne @f
;  1347                 mov [novalue],1
;  1348                 mov [res],0
;  1349                 jmp :done
;  1350           @@:
;  1351             jl @f
;  1352                 -- ditto (as getGvarValue/[32])
;  1353                 lea edi,[ebx+esi*4-1]
;  1354             [PE32]
;  1355                 push 1      -- UINT_PTR ucb
;  1356                 push edi    -- LPVOID lp
;  1357                 call "kernel32.dll","IsBadWritePtr"
;  1358             [ELF32]
;  1359                 pop al
;  1360             [32]
;  1361                 test eax,eax
;  1362                 jz :typeaddrok
;  1363                     mov [novalue],2 -- invalid ref
;  1364                     mov [res],0
;  1365                     jmp :done
;  1366               ::typeaddrok
;  1367                 mov cl,[edi]
;  1368                 cmp cl,#12
;  1369                 je :typebyteok
;  1370                 cmp cl,#80
;  1371                 je :typebyteok
;  1372                 cmp cl,#82
;  1373                 je :typebyteok
;  1374                     mov [novalue],3 -- corrupt type byte
;  1375                     mov [res],0
;  1376                     jmp :done
;  1377               ::typebyteok
;  1378                 add dword[ebx+esi*4-8],1
;  1379           @@:
;  1380             mov [res],esi
;  1381         [64]
;  1382             mov rsi,[or_ebp]
                    mov rsi,[#00402AE8] (or_ebp)  ;#0044DC10: 48:213065 D14EFBFF         vu 40 00  1   1      
;  1383             mov rcx,[tidx]
                    mov rcx,[rbp] (tidx)  ;#0044DC17: 48:213115 00               uv 02 20  1   2      
;  1384             shl rsi,2
                    shl rsi,2             ;#0044DC1B: 48:301346 02               u  40 40  1   3      
;  1385             mov r15,h4
                    mov r15,h4            ;#0044DC1F: 49:277 0000000000000040    vu 8000 00  1   3      
;  1386             mov rsi,[rsi+rcx*8]
                    mov rsi,[rsi+rcx*8]   ;#0044DC29: 48:213064316               uv 40 42  1   6    *40*
;  1387             cmp rsi,r15
                    cmp rsi,r15           ;#0044DC2D: 49:073367                  uv 00 8040  1   7 40   
;  1388             jne @f
                    jne #0044DC44         ;#0044DC30: 165 12                     v  00 00  1   7      
;  1389                 mov [novalue],1
                        mov qword[rbp-8] (novalue),1  ;#0044DC32: 48:307105 F8 01000000      uv 00 20  1   8      
;  1390                 mov [res],0
                        mov qword[rbp-16] (res),0  ;#0044DC3A: 48:307105 F0 00000000      vu 00 20  1   8      
;  1391                 jmp :done
                        jmp #0044DCB3     ;#0044DC42: 353 6F                     v  00 00  1   9      
;  1392           @@:
;  1393             jl @f
                    jl #0044DCAF          ;#0044DC44: 174 69                     v  00 00  1  10      
;  1394                 -- ditto (as getGvarValue/[32])
;  1395                 lea rdi,[rbx+rsi*4-1]
                        lea rdi,[rbx+rsi*4-1]  ;#0044DC46: 48:215174263 FF            uv 80 48  1  11      
;  1396             [PE64]
;  1397                 mov rcx,rsp -- put 2 copies of rsp onto the stack...
                        mov rcx,rsp       ;#0044DC4B: 48:213314                  vu 02 10  1  11      
;  1398                 push rsp
                        push rsp          ;#0044DC4E: 48:124                     uv 00 10  1  12      
;  1399                 push rcx
                        push rcx          ;#0044DC50: 48:121                     vu 00 02  1  12      
;  1400                 or rsp,8    -- [rsp] is now 1st or 2nd copy:
                        or rsp,8          ;#0044DC52: 48:203314 08               uv 10 10  1  13      
;  1401                             -- if on entry rsp was xxx8: both copies remain on the stack
;  1402                             -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1403                             -- obviously rsp is now xxx8, whatever alignment we started with
;  1404                 sub rsp,8*5                 -- shadow space and align
                        sub rsp,40        ;#0044DC56: 48:203354 28               uv 10 10  1  14 10   
;  1405                 mov rdx,1                   -- UINT_PTR ucb
                        mov rdx,1         ;#0044DC5A: 48:307302 01000000         vu 04 00  1  14      
;  1406                 mov rcx,rdi                 -- LPVOID lp
                        mov rcx,rdi       ;#0044DC61: 48:213317                  uv 02 80  1  15      
;  1407                 call "kernel32.dll","IsBadWritePtr"
                        call [#004010D0] (IsBadWritePtr)  ;#0044DC64: 377025 6634FBFF            np 00 00  2  16      
;  1408 --              add rsp,8*5
;  1409 --              pop rsp     -- restore, equivalent to rsp += (either #08 or #10)
;  1410                 mov rsp,[rsp+8*5]   -- equivalent to add/pop
                        mov rsp,[rsp+40]  ;#0044DC6A: 48:213144044 28            uv 10 10  1  18      
;  1411             [ELF64]
;  1412                 pop al
;  1413             [64]
;  1414                 test rax,rax
                        test rax,rax      ;#0044DC6F: 48:205300                  vu 00 01  1  18      
;  1415                 jz :typeaddrok
                        jz #0044DC86      ;#0044DC72: 164 12                     v  00 00  1  19      
;  1416                     mov [novalue],2 -- invalid ref
                            mov qword[rbp-8] (novalue),2  ;#0044DC74: 48:307105 F8 02000000      uv 00 20  1  20      
;  1417                     mov [res],0
                            mov qword[rbp-16] (res),0  ;#0044DC7C: 48:307105 F0 00000000      vu 00 20  1  20      
;  1418                     jmp :done
                            jmp #0044DCB3  ;#0044DC84: 353 2D                     v  00 00  1  21      
;  1419               ::typeaddrok
;  1420                 mov cl,[rdi]
                        mov cl,[edi]      ;#0044DC86: 212017                     uv 02 80  1  22      
;  1421                 cmp cl,#12
                        cmp cl,#12        ;#0044DC88: 200371 12                  uv 00 02  1  23 02   
;  1422                 je :typebyteok
                        je #0044DCA9      ;#0044DC8B: 164 1C                     v  00 00  1  23      
;  1423                 cmp cl,#80
                        cmp cl,#80        ;#0044DC8D: 200371 80                  uv 00 02  1  24      
;  1424                 je :typebyteok
                        je #0044DCA9      ;#0044DC90: 164 17                     v  00 00  1  24      
;  1425                 cmp cl,#82
                        cmp cl,#82        ;#0044DC92: 200371 82                  uv 00 02  1  25      
;  1426                 je :typebyteok
                        je #0044DCA9      ;#0044DC95: 164 12                     v  00 00  1  25      
;  1427                     mov [novalue],3 -- corrupt type byte
                            mov qword[rbp-8] (novalue),3  ;#0044DC97: 48:307105 F8 03000000      uv 00 20  1  26      
;  1428                     mov [res],0
                            mov qword[rbp-16] (res),0  ;#0044DC9F: 48:307105 F0 00000000      vu 00 20  1  26      
;  1429                     jmp :done
                            jmp #0044DCB3  ;#0044DCA7: 353 0A                     v  00 00  1  27      
;  1430               ::typebyteok
;  1431                 add qword[rbx+rsi*4-16],1
                        add qword[rbx+rsi*4-16],1  ;#0044DCA9: 48:203104263 F0 01         u  00 48  3  28      
;  1432           @@:
;  1433             mov [res],rsi
                    mov [rbp-16] (res),rsi  ;#0044DCAF: 48:211165 F0               vu 00 60  1  30      
;  1434         []
;  1435           ::done
;  1436           } 
;  1437     return {novalue,res}    -- ({0,whatever} or {1,0})
    mov rsi,[rbp-8] (novalue)             ;#0044DCB3: 48:213165 F8               uv 40 20  1  31      
    mov r15,h4                            ;#0044DCB7: 49:277 0000000000000040    vu 8000 00  1  31      
    cmp rsi,r15                           ;#0044DCC1: 4C:071376                  uv 00 8040  1  32      
    jne #0044DCD2                         ;#0044DCC4: 165 0C                     v  00 00  1  32      
    mov rsi,633                           ;#0044DCC6: 48:307306 79020000         uv 40 00  1  33      
    call #00442D75 (:%pUnassigned)        ;#0044DCCD: 350 A350FFFF               v  00 00  1  33      
    lea rax,[rbp-24] (symtab[635])        ;#0044DCD2: 48:215105 E8               uv 01 20  1  34      
    mov rdx,2                             ;#0044DCD6: 48:307302 02000000         vu 04 00  1  34      
    push #0044DD0C                        ;#0044DCDD: 150 0CDD4400               uv 00 00  1  35      
    push rax                              ;#0044DCE2: 120                        vu 00 01  1  35      
    mov rcx,[rbp-16] (res)                ;#0044DCE3: 48:213115 F0               uv 02 20  1  36      
    mov r15,h4                            ;#0044DCE7: 49:277 0000000000000040    vu 8000 00  1  36      
    cmp rcx,r15                           ;#0044DCF1: 4C:071371                  uv 00 8002  1  37      
    jl #0044DD01                          ;#0044DCF4: 174 0B                     v  00 00  1  37      
    add qword[rbx+rcx*4-16],1             ;#0044DCF6: 48:203104213 F0 01         u  00 0A  3  38      
    cmp eax,634                           ;#0044DCFC: 075 7A020000               vu 00 01  1  40      
    push rcx                              ;#0044DD01: 121                        uv 00 02  1  41      
    push rsi                              ;#0044DD02: 126                        vu 00 40  1  41      
    mov rdi,[rbp-24] (symtab[635])        ;#0044DD03: 48:213175 E8               uv 80 20  1  42      
    jmp #004404BD (:%pMkSq)               ;#0044DD07: 351 B127FFFF               v  00 00  1  42      
    mov rax,[rbp-24] (symtab[635])        ;#0044DD0C: 48:213105 E8               uv 01 20  1  43      
    mov [rbp-24] (symtab[635]),rbx        ;#0044DD10: 48:211135 E8               vu 00 28  1  43      
    jmp #0044298D (:%opRetf)              ;#0044DD14: 351 744CFFFF               v  00 00  1  44      
;  1438 end function
;  1439 
;  1440 --/*
;  1441 function getValue(integer symidx, integer limit, integer indent, integer crop)
;  1442 object  o,
;  1443         ss   -- symtab[symidx]
;  1444 integer r, k,
;  1445         nTyp, tidx
;  1446 
;  1447     lc = limit
;  1448     showellipse = 0
;  1449     -- obviously none of these should ever happen, but if they do then leave
;  1450     --  as many clues as you can in the ex.err to help resolve things.
;  1451     if symidx<0 or symidx>length(symtab) then
;  1452         return sprintf("pdiag:getValue bad symidx[=%d]",symidx)
;  1453     end if
;  1454     ss = symtab[symidx]
;  1455     if atom(ss) then
;  1456         return sprintf("pdiag:symtab[symidx[=%d]] is an atom",symidx)
;  1457     end if
;  1458     nTyp = ss[S_NTyp]
;  1459     if nTyp>S_TVar3 or nTyp<S_Const then
;  1460         return sprintf("pdiag:getValue bad symtab[symidx][S_NTyp]=%d",nTyp)
;  1461     end if
;  1462 --newEmit... and 64bit
;  1463     if nTyp=S_TVar3 then
;  1464         tidx = ss[S_Tidx]
;  1465         o = getVal(or_ebp*4+tidx*4)
;  1466     else
;  1467         tidx = ss[S_Slink]
;  1468         o = getVal(etd+tidx*4-4)
;  1469     end if
;  1470     if not novalue then
;  1471 --DEV try that new routine here...?
;  1472         if indent then
;  1473             o = ppExf(o,{pp_Indent,indent+7})
;  1474         else
;  1475             o = ppf(o)
;  1476         end if
;  1477         if showellipse then
;  1478             if crop then
;  1479                 lc = find('\n',o)
;  1480                 if lc then o = o[1..lc-1] end if
;  1481             end if
;  1482             lc = length(o)
;  1483             if o[lc]='}' then
;  1484                 o[lc..lc] = ",...}"
;  1485             else
;  1486                 o &= "..."
;  1487             end if
;  1488         end if
;  1489 --#without reformat
;  1490 --DEV 24/6/10 (need to experiment a bit here...)
;  1491 if 0 then -- (added 21/8/2010)
;  1492         r = 1
;  1493         while 1 do
;  1494             k = find(repch[r],o)
;  1495             if k then
;  1496                 o[k..k] = repstrs[r]
;  1497             else
;  1498                 r += 1
;  1499                 if r>length(repch) then exit end if
;  1500             end if
;  1501         end while
;  1502 end if
;  1503 --#with reformat
;  1504     end if
;  1505     return o
;  1506 end function
;  1507 --*/
;  1508 
;  1509 --integer dcount        -- number of dropped callstack blocks
;  1510 
;  1511 --newEBP... 64bit
;  1512 --/*
;  1513 function retN()
;  1514     if machine_bits()=32 then
;  1515         {N,rtn,from_addr,ret_addr,prev_ebp,ebp_root} = peek4u({or_ebp*4+4,6})
;  1516     else -- machine_bits()=64
;  1517         {N,rtn,from_addr,ret_addr,prev_ebp,ebp_root} = peek8u({or_ebp*4+8,6})
;  1518     end if
;  1519 
;  1520 atom prev_ebp
;  1521     while 1 do
;  1522         prev_ebp = peek4u(or_ebp*4+20)
;  1523         if prev_ebp=0 then return 0 end if
;  1524         era = peek4u(or_ebp*4+16)   -- return address
;  1525         or_ebp = floor(prev_ebp/4)
;  1526         if era=0 then
;  1527             put2("(^^^) call_back from Windows/dll/asm\n")
;  1528         else
;  1529 --          if c_func(xIsBadReadPtr,{or_ebp*4,12}) then
;  1530 --              put2(sprintf("<**diag.e: bad prev_ebp** (#%08x)>\n",or_ebp*4))
;  1531 --              return 0
;  1532 --          end if
;  1533             rtn = peek4u(or_ebp*4+8)
;  1534             era -= 1    -- ensure within code emitted for line [DEV??]
;  1535             return 1
;  1536         end if
;  1537     end while
;  1538 end function
;  1539 --*/
;  1540 --function retDX()
;  1541 --  --
;  1542 --  -- The callstack is managed as a linked list of 8K virtual stack blocks (vsb).
;  1543 --  -- The header of each block is 24 bytes:
;  1544 --  --
;  1545 --  --  vsb_prev, vsb_next, spare, [threadstackptr], vsb_used, [symtabptr]
;  1546 --  --
;  1547 --  --  [threadstackptr] and [symtabptr] are not relevant here, included as a
;  1548 --  --   precursor to full thread handling, and subject to change. In fact we
;  1549 --  --   got ecs (which now points at this header) from symtab[T_callstk], which 
;  1550 --  --   also contains etd, the real threadstack address, when we used opGetST as
;  1551 --  --   the very first step.
;  1552 --  --
;  1553 --  -- spare is set to #DC0DC0DC at the point where dcount blocks were 
;  1554 --  --  dropped, that is in the e77phroom case.
;  1555 --  --
;  1556 --  -- The remainder of each block contains frames, minimum of 6 dwords each:
;  1557 --  --
;  1558 --  --  called_from addr
;  1559 --  --  first (address of first item being saved)
;  1560 --  --  items 1..N (params and locals as they were before the call)
;  1561 --  --  N (number of params and locals which got saved)
;  1562 --  --  calling routine (index to symtab)
;  1563 --  --  routine being called (index to symtab)
;  1564 --  --  return addr
;  1565 --  --
;  1566 --  -- Each block can hold up to 339 frames, or a single frame can contain 
;  1567 --  --  up to 2032 parameters, local variables, and temporaries.
;  1568 --  -- To simplify handling, frames do not span blocks. If there is not
;  1569 --  --  enough space for the new frame, it is put in a new vsb and the old
;  1570 --  --  one is left not-quite-full. Each frame is intended to be read from
;  1571 --  --  the end downwards; attempts to read forwards are doomed to failure
;  1572 --  --  - though that should cause no great difficulty for anyone.
;  1573 --  -- The called from address is used for debug handling only and will 
;  1574 --  --  match the routine name, whereas the return address will match with
;  1575 --  --  the closing ')' or possibly the following statement.
;  1576 --  -- While strictly speaking the calling routine is redundant, it does
;  1577 --  --  allow some verification as the call stack is walked.
;  1578 --  --
;  1579 --  -- At startup, the lowest callstack block is created with a dummy pair
;  1580 --  -- of {T_maintls(=21),0}, which helps opRetf behave correctly and can/
;  1581 --  -- should be used to signal the bottom of stack.
;  1582 --  -- 
;  1583 ----puts(1,"retD()\n")
;  1584 --  while 1 do
;  1585 --      if vsb_used=2 then return 0 end if  -- must be our {21,0} pair.
;  1586 --      if vsb_used=0 then
;  1587 --if newEBP then -- (DEV [nonsense])
;  1588 --          if dcount then
;  1589 --              put2(sprintf("<%d callstack blocks skipped>\n",dcount))
;  1590 --              dcount = 0
;  1591 --          end if
;  1592 --else
;  1593 --          if peek4u(ecs+8)=#DC0DC0DC then
;  1594 --              put2(sprintf("<%d callstack blocks skipped>\n",dcount))
;  1595 --          end if
;  1596 --end if
;  1597 --          ecs = peek4u(ecs)   -- follow vsb_prev link
;  1598 ----DEV: not newEBP
;  1599 --          vsb_used = peek4u(ecs+16)
;  1600 --      end if
;  1601 ----o = peek4u({ecs,vsb_used+20})
;  1602 ----?o
;  1603 ----?vsb_used
;  1604 --      base = ecs+vsb_used*4
;  1605 --      rtnX = peek4u(base+16)
;  1606 --      if rtn!=rtnX then
;  1607 --          printf(1,"diag callee internal error (rtn %d!=%d)\n",{rtn,rtnX})
;  1608 --          return 0
;  1609 --      end if
;  1610 --      rtn = peek4u(base+12)
;  1611 ----printf(1,"new rtn=%d\n",rtn)
;  1612 --      N = peek4u(base+8)
;  1613 --      if N<0 or N>vsb_used then
;  1614 --          printf(1,"diag callee internal error (N=%d, vsb_used=%d)\n",{N,vsb_used})
;  1615 --          return 0
;  1616 --      end if
;  1617 ----printf(1,"N=%d\n",N)
;  1618 --      base += 4-N*4
;  1619 --      first = peek4u(base)
;  1620 --      if N=0 then
;  1621 --          if first!=0 then
;  1622 --              printf(1,"diag callee internal error (N=0, first=%08x)\n",first)
;  1623 --              return 0
;  1624 --          end if
;  1625 --      else
;  1626 --          if first<etd or first>etd+vmax*4then
;  1627 --              printf(1,"diag callee internal error (first=%08x, etd=%08x, vmax=%d)\n",{first,etd,vmax})
;  1628 --              return 0
;  1629 --          end if
;  1630 ----printf(1,"first=%d\n",first)
;  1631 --          mem_copy(first,base+4,N)
;  1632 --      end if
;  1633 --      era = peek4u(base-4)
;  1634 ----printf(1,"new era=%d\n",era)
;  1635 --      vsb_used -= (N+6)
;  1636 ----?vsb_used
;  1637 --      if era=0 then
;  1638 ----            if vsb_used=2 then exit end if
;  1639 --          put2("(^^^) call_back from Windows/dll/asm\n")
;  1640 ------      vsb_used -= ??
;  1641 --      else
;  1642 --          era -= 1    -- ensure within code emitted for line [DEV??]
;  1643 --          return 1
;  1644 --      end if
;  1645 --  end while
;  1646 --end function
;  1647 
;  1648 integer vmax        -- highest permitted threadstack entry
;  1649         vmax = 0    -- (equal to the length of vmap)
;  1650 
;  1651 sequence vmap -- variable map; var address --> offset into threadstack
;  1652                 --  (a flat array of all static and dynamic var refs)
;  1653                 -- ==> index into symtab for var name, type, etc.
;  1654 
;  1655 function varIdx(atom addr, integer rtn, sequence symtab)
;  1656 integer gvar0   -- addr gvar[0] (==[maxgvar]) [may need to be atom, or gvar04]
;  1657 integer maxgvar
;  1658 integer varno
;  1659 integer tidx
;  1660 object sr
;  1661 integer nTyp
;  1662     #ilASM{
;  1663         [32]
;  1664 --          lea esi,[ds+16]     -- maxgvar aka gvar[0], less maxop entries
;  1665 --          mov ecx,[ds+12]     -- maxop
;  1666 --          lea eax,[esi+ecx*4] -- ([maxgvar+(maxop)*4] == gvar[0])
;  1667             mov eax,[ds4]
;  1668             shl eax,2
;  1669             add eax,16
;  1670             mov [gvar0],eax
;  1671             mov eax,[eax]
;  1672             mov [maxgvar],eax
;  1673 --27/2/15:
;  1674 --          mov esi,[ebp+24]        -- vsb_root
;  1675 --          mov eax,[esi+12]        -- gvarptr
;  1676 --          mov edx,eax
;  1677 --          sub edx,4
;  1678 --          mov [gvar0],eax
;  1679 --          mov ecx,[eax-4]         -- maxgvar
;  1680 --          mov [maxgvar],ecx
;  1681         [64]
;  1682 --          lea rsi,[ds+24]     -- maxgvar aka gvar[0], less maxop entries
;  1683 --          mov rcx,[ds+16]     -- maxop
;  1684 --          lea rax,[rsi+rcx*8] -- ([maxgvar+(maxop)*8] == gvar[0])
;  1685             mov rax,[ds4]
                    mov rax,[#00402B30] (ds4)  ;#0044DE2B: 48:213005 FE4CFBFF         uv 01 00  1   1      
;  1686             shl rax,2
                    shl rax,2             ;#0044DE32: 48:301340 02               u  01 01  1   2      
;  1687             add rax,24
                    add rax,24            ;#0044DE36: 48:203300 18               uv 01 01  1   3 01   
;  1688             mov [gvar0],rax
                    mov [rbp-24] (gvar0),rax  ;#0044DE3A: 48:211105 E8               uv 00 21  1   4 01   
;  1689             mov rax,[rax]
                    mov rax,[rax]         ;#0044DE3E: 48:213000                  uv 01 01  1   6    *01*
;  1690             mov [maxgvar],rax
                    mov [rbp-32] (maxgvar),rax  ;#0044DE41: 48:211105 E0               uv 00 21  1   7 01   
;  1691 --27/2/15:
;  1692 --          mov rsi,[rbp+48]        -- vsb_root
;  1693 --          mov rax,[rsi+24]        -- gvarptr
;  1694 --          mov rdx,rax
;  1695 --          sub rdx,4
;  1696 --          mov [gvar0],rdx
;  1697 --          mov rcx,[rax-8]         -- maxgvar
;  1698 --          mov [maxgvar],rcx
;  1699         []
;  1700           } 
;  1701     if machine_bits()=32 then
;  1702         varno = floor((addr-gvar0)/4)
;  1703     else
;  1704         varno = floor((addr-gvar0)/8)
    mov rsi,[rbp-24] (gvar0)              ;#0044DE45: 48:213165 E8               vu 40 20  1   7      
    mov r15,h4                            ;#0044DE49: 49:277 0000000000000040    uv 8000 00  1   8      
    cmp rsi,r15                           ;#0044DE53: 4C:071376                  uv 00 8040  1   9 8000   
    jne #0044DE64                         ;#0044DE56: 165 0C                     v  00 00  1   9      
    mov rsi,643                           ;#0044DE58: 48:307306 83020000         uv 40 00  1  10      
    call #00442D75 (:%pUnassigned)        ;#0044DE5F: 350 114FFFFF               v  00 00  1  10      
    lea rdi,[rbp-72] (symtab[649])        ;#0044DE64: 48:215175 B8               uv 80 20  1  11      
    mov rcx,[rbp] (addr)                  ;#0044DE68: 48:213115 00               vu 02 20  1  11      
    mov rax,rsi                           ;#0044DE6C: 48:211360                  uv 01 40  1  12      
    call #0043F4D8 (:%opSub)              ;#0044DE6F: 350 6416FFFF               v  00 00  1  12      
    lea rdi,[rbp-40] (varno)              ;#0044DE74: 48:215175 D8               uv 80 20  1  13      
    mov rcx,[rbp-72] (symtab[649])        ;#0044DE78: 48:213115 B8               vu 02 20  1  13      
    mov rax,[#004020C8] (D_MINUTE)        ;#0044DE7C: 48:213005 4542FBFF         uv 01 00  1  14      
    call #0043F5E4 (:%opDivf)             ;#0044DE83: 350 5C17FFFF               v  00 00  1  14      
;  1705     end if
;  1706 --?{varno,maxgvar,addr,gvar0}
;  1707 --{-400121,561,#F4850,#402018}
;  1708 --DEV/SUG:
;  1709 --  if maxgvar!=vmax then return verror("pdiag.e/VarIdx: maxgvar(%d)!=vmax(%d)\n",{maxgvar,vmax})
;  1710     if varno>0 and varno<maxgvar then
    xor rdi,rdi                           ;#0044DE88: 48:061377                  uv 80 80  1  15      
    mov rax,[rbp-40] (varno)              ;#0044DE8B: 48:213105 D8               vu 01 20  1  15      
    mov rsi,25                            ;#0044DE8F: 48:307306 19000000         uv 40 00  1  16      
    mov rdx,645                           ;#0044DE96: 48:307302 85020000         vu 04 00  1  16      
    call #0043FA81 (:%opJcc)              ;#0044DE9D: 350 DF1BFFFF               v  00 00  1  17      
    jle #0044DFA9                         ;#0044DEA2: 017216 01010000            v  00 00  1  18      
    mov rdi,[rbp-32] (maxgvar)            ;#0044DEA8: 48:213175 E0               uv 80 20  1  19      
    mov rax,[rbp-40] (varno)              ;#0044DEAC: 48:213105 D8               vu 01 20  1  19      
    mov rsi,644                           ;#0044DEB0: 48:307306 84020000         uv 40 00  1  20      
    mov rdx,645                           ;#0044DEB7: 48:307302 85020000         vu 04 00  1  20      
    call #0043FA81 (:%opJcc)              ;#0044DEBE: 350 BE1BFFFF               v  00 00  1  21      
    jge #0044DFA9                         ;#0044DEC3: 017215 E0000000            v  00 00  1  22      
;  1711         -- a gvar
;  1712         --(DEV we could do some more error checking here...)
;  1713         --DEV** we need a gvar mapping...
;  1714 --      if varno>0 and varno<=length(vmap) then
;  1715         if varno>0 and varno<=vmax then
    mov rsi,[rbp-40] (varno)              ;#0044DEC9: 48:213165 D8               uv 40 20  1  23      
    cmp rsi,0                             ;#0044DECD: 48:203376 00               uv 00 40  1  24 40   
    jle #0044DF20                         ;#0044DED1: 176 4D                     v  00 00  1  24      
    mov rcx,[#00402B38] (vmax)            ;#0044DED3: 48:213015 5E4CFBFF         uv 02 00  1  25      
    cmp rsi,rcx                           ;#0044DEDA: 48:071316                  uv 00 42  1  26 02   
    jg #0044DF20                          ;#0044DEDD: 177 41                     v  00 00  1  26      
;  1716             return vmap[varno]
    mov rdi,[#00402B40] (vmap)            ;#0044DEDF: 48:213075 5A4CFBFF         uv 80 00  1  27      
    mov r15,h4                            ;#0044DEE6: 49:277 0000000000000040    vu 8000 00  1  27      
    cmp rdi,r15                           ;#0044DEF0: 4C:071377                  uv 00 8080  1  28      
    jne #0044DF01                         ;#0044DEF3: 165 0C                     v  00 00  1  28      
    mov rsi,637                           ;#0044DEF5: 48:307306 7D020000         uv 40 00  1  29      
    call #00442D75 (:%pUnassigned)        ;#0044DEFC: 350 744EFFFF               v  00 00  1  29      
    mov rdi,rsi                           ;#0044DF01: 48:211367                  uv 80 40  1  30      
    mov rsi,[#00402B40] (vmap)            ;#0044DF04: 48:213065 354CFBFF         vu 40 00  1  30      
    mov rdx,637                           ;#0044DF0B: 48:307302 7D020000         uv 04 00  1  31      
    call #00441744 (:%pSubse1ip)          ;#0044DF12: 350 2D38FFFF               v  00 00  1  31      
    mov [rbp-80] (symtab[650]),rax        ;#0044DF17: 48:211105 B0               uv 00 21  1  32      
    jmp #0044298D (:%opRetf)              ;#0044DF1B: 351 6D4AFFFF               v  00 00  1  32      
;  1717         end if
;  1718         printf(1,"bad varno(%d)\n",{varno})
    lea rax,[rbp-88] (symtab[652])        ;#0044DF20: 48:215105 A8               uv 01 20  1  33      
    mov rdx,1                             ;#0044DF24: 48:307302 01000000         vu 04 00  1  33      
    push #0044DF3B                        ;#0044DF2B: 150 3BDF4400               uv 00 00  1  34      
    push rax                              ;#0044DF30: 120                        vu 00 01  1  34      
    push rsi                              ;#0044DF31: 126                        uv 00 40  1  35      
    mov rdi,[rbp-88] (symtab[652])        ;#0044DF32: 48:213175 A8               vu 80 20  1  35      
    jmp #004404BD (:%pMkSq)               ;#0044DF36: 351 8225FFFF               v  00 00  1  36      
    mov rcx,4                             ;#0044DF3B: 48:307301 04000000         uv 02 00  1  37      
    mov rdx,94                            ;#0044DF42: 48:307302 5E000000         vu 04 00  1  37      
    call #004428DB (:%opFrame) (printf)   ;#0044DF49: 350 8D49FFFF               v  00 00  1  38      
    mov qword[rbp] (fn),1                 ;#0044DF4E: 48:307105 00 01000000      uv 00 20  1  39      
    mov rcx,qword[#00402B48]              ;#0044DF56: 48:213015 EB4BFBFF         vu 02 00  1  39      
    mov [rbp-8] (format),rcx              ;#0044DF5D: 48:211115 F8               uv 00 22  1  40      
    add qword[rbx+rcx*4-16],1             ;#0044DF61: 48:203104213 F0 01         u  00 0A  3  42    *02*
    mov rdi,[rbp+40] (prevebp)            ;#0044DF67: 48:213175 28               vu 80 20  1  44      
    mov rax,[rdi-88]                      ;#0044DF6B: 48:213107 A8               uv 01 80  1  47    *80*
    xor rbx,rbx                           ;#0044DF6F: 48:061333                  vu 08 08  1  47      
    mov r15,h4                            ;#0044DF72: 49:277 0000000000000040    uv 8000 00  1  48      
    cmp rax,r15                           ;#0044DF7C: 4C:071370                  uv 00 8001  1  49 8000   
    jl #0044DF8C                          ;#0044DF7F: 174 0B                     v  00 00  1  49      
    add qword[rbx+rax*4-16],1             ;#0044DF81: 48:203104203 F0 01         u  00 09  3  50      
    cmp eax,652                           ;#0044DF87: 075 8C020000               vu 00 01  1  52      
    mov [rbp-16] (args),rax               ;#0044DF8C: 48:211105 F0               uv 00 21  1  53      
    mov qword[retaddr],#0044DF9D          ;#0044DF90: 48:307105 20 9DDF4400      vu 00 20  1  53      
    jmp #00451A31 (code:printf)           ;#0044DF98: 351 943A0000               v  00 00  1  54      
;  1719         return -1
    mov rax,-1                            ;#0044DF9D: 48:307300 FFFFFFFF         uv 01 00  1  55      
    jmp #0044298D (:%opRetf)              ;#0044DFA4: 351 E449FFFF               v  00 00  1  55      
;  1720 --      return varno
;  1721 --DEV/SUG:
;  1722 --      return verror("bad varno(%d)\n",{varno})
;  1723     end if
;  1724     -- a tvar
;  1725     if rtn<1 or rtn>length(symtab) then
    mov rsi,[rbp-8] (rtn)                 ;#0044DFA9: 48:213165 F8               uv 40 20  1  56      
    cmp rsi,1                             ;#0044DFAD: 48:203376 01               uv 00 40  1  57 40   
    jl #0044DFC6                          ;#0044DFB1: 174 13                     v  00 00  1  57      
    mov rdi,[rbp-16] (symtab)             ;#0044DFB3: 48:213175 F0               uv 80 20  1  58      
    mov rcx,[rbx+rdi*4-24]                ;#0044DFB7: 48:48:213114273 E8         uv 02 88  1  61 80 *80*
    cmp rsi,rcx                           ;#0044DFBD: 48:071316                  uv 00 42  1  62 02   
    jle #0044E04F                         ;#0044DFC0: 017216 89000000            v  00 00  1  62      
;  1726         printf(1,"pdiag.e/VarIdx: bad rtn(%d)\n",{rtn})
    lea rax,[rbp-88] (symtab[652])        ;#0044DFC6: 48:215105 A8               uv 01 20  1  63      
    mov rdx,1                             ;#0044DFCA: 48:307302 01000000         vu 04 00  1  63      
    push #0044DFE1                        ;#0044DFD1: 150 E1DF4400               uv 00 00  1  64      
    push rax                              ;#0044DFD6: 120                        vu 00 01  1  64      
    push rsi                              ;#0044DFD7: 126                        uv 00 40  1  65      
    mov rdi,[rbp-88] (symtab[652])        ;#0044DFD8: 48:213175 A8               vu 80 20  1  65      
    jmp #004404BD (:%pMkSq)               ;#0044DFDC: 351 DC24FFFF               v  00 00  1  66      
    mov rcx,4                             ;#0044DFE1: 48:307301 04000000         uv 02 00  1  67      
    mov rdx,94                            ;#0044DFE8: 48:307302 5E000000         vu 04 00  1  67      
    call #004428DB (:%opFrame) (printf)   ;#0044DFEF: 350 E748FFFF               v  00 00  1  68      
    mov qword[rbp] (fn),1                 ;#0044DFF4: 48:307105 00 01000000      uv 00 20  1  69      
    mov rax,qword[#00402B50]              ;#0044DFFC: 48:213005 4D4BFBFF         vu 01 00  1  69      
    mov [rbp-8] (format),rax              ;#0044E003: 48:211105 F8               uv 00 21  1  70      
    add qword[rbx+rax*4-16],1             ;#0044E007: 48:203104203 F0 01         u  00 09  3  72    *01*
    mov rdi,[rbp+40] (prevebp)            ;#0044E00D: 48:213175 28               vu 80 20  1  74      
    mov rax,[rdi-88]                      ;#0044E011: 48:213107 A8               uv 01 80  1  77    *80*
    xor rbx,rbx                           ;#0044E015: 48:061333                  vu 08 08  1  77      
    mov r15,h4                            ;#0044E018: 49:277 0000000000000040    uv 8000 00  1  78      
    cmp rax,r15                           ;#0044E022: 4C:071370                  uv 00 8001  1  79 8000   
    jl #0044E032                          ;#0044E025: 174 0B                     v  00 00  1  79      
    add qword[rbx+rax*4-16],1             ;#0044E027: 48:203104203 F0 01         u  00 09  3  80      
    cmp eax,652                           ;#0044E02D: 075 8C020000               vu 00 01  1  82      
    mov [rbp-16] (args),rax               ;#0044E032: 48:211105 F0               uv 00 21  1  83      
    mov qword[retaddr],#0044E043          ;#0044E036: 48:307105 20 43E04400      vu 00 20  1  83      
    jmp #00451A31 (code:printf)           ;#0044E03E: 351 EE390000               v  00 00  1  84      
;  1727         return -1
    mov rax,-1                            ;#0044E043: 48:307300 FFFFFFFF         uv 01 00  1  85      
    jmp #0044298D (:%opRetf)              ;#0044E04A: 351 3E49FFFF               v  00 00  1  85      
;  1728     end if
;  1729     sr = symtab[rtn]
    mov rdi,rsi                           ;#0044E04F: 48:211367                  uv 80 40  1  86      
    lea rcx,[rbp-56] (sr)                 ;#0044E052: 48:215115 C8               vu 02 20  1  86      
    mov rsi,[rbp-16] (symtab)             ;#0044E056: 48:213165 F0               uv 40 20  1  87      
    mov rdx,642                           ;#0044E05A: 48:307302 82020000         vu 04 00  1  87      
    call #00441675 (:%pSubse1)            ;#0044E061: 350 0F36FFFF               v  00 00  1  88      
;  1730     if atom(sr) then
    mov rcx,[rbp-56] (sr)                 ;#0044E066: 48:213115 C8               uv 02 20  1  89      
    mov r15,h4                            ;#0044E06A: 49:277 0000000000000040    vu 8000 00  1  89      
    cmp rcx,r15                           ;#0044E074: 4C:071371                  uv 00 8002  1  90      
    jl #0044E084                          ;#0044E077: 174 0B                     v  00 00  1  90      
    cmp byte[rbx+rcx*4-1],#12             ;#0044E079: 200174213 FF 12            u  00 0A  2  91      
    jne #0044E10F                         ;#0044E07E: 017205 8B000000            v  00 00  1  92      
;  1731         printf(1,"pdiag.e/VarIdx:atom(symtab[%d])!\n",{rtn})
    lea rax,[rbp-88] (symtab[652])        ;#0044E084: 48:215105 A8               uv 01 20  1  93      
    mov rdx,1                             ;#0044E088: 48:307302 01000000         vu 04 00  1  93      
    push #0044E0A1                        ;#0044E08F: 150 A1E04400               uv 00 00  1  94      
    push rax                              ;#0044E094: 120                        vu 00 01  1  94      
    push qword[rbp-8] (rtn)               ;#0044E095: 377165 F8                  np 00 20  2  95      
    mov rdi,[rbp-88] (symtab[652])        ;#0044E098: 48:213175 A8               uv 80 20  1  97      
    jmp #004404BD (:%pMkSq)               ;#0044E09C: 351 1C24FFFF               v  00 00  1  97      
    mov rcx,4                             ;#0044E0A1: 48:307301 04000000         uv 02 00  1  98      
    mov rdx,94                            ;#0044E0A8: 48:307302 5E000000         vu 04 00  1  98      
    call #004428DB (:%opFrame) (printf)   ;#0044E0AF: 350 2748FFFF               v  00 00  1  99      
    mov qword[rbp] (fn),1                 ;#0044E0B4: 48:307105 00 01000000      uv 00 20  1 100      
    mov rax,qword[#00402B58]              ;#0044E0BC: 48:213005 954AFBFF         vu 01 00  1 100      
    mov [rbp-8] (format),rax              ;#0044E0C3: 48:211105 F8               uv 00 21  1 101      
    add qword[rbx+rax*4-16],1             ;#0044E0C7: 48:203104203 F0 01         u  00 09  3 103    *01*
    mov rdi,[rbp+40] (prevebp)            ;#0044E0CD: 48:213175 28               vu 80 20  1 105      
    mov rax,[rdi-88]                      ;#0044E0D1: 48:213107 A8               uv 01 80  1 108    *80*
    xor rbx,rbx                           ;#0044E0D5: 48:061333                  vu 08 08  1 108      
    mov r15,h4                            ;#0044E0D8: 49:277 0000000000000040    uv 8000 00  1 109      
    cmp rax,r15                           ;#0044E0E2: 4C:071370                  uv 00 8001  1 110 8000   
    jl #0044E0F2                          ;#0044E0E5: 174 0B                     v  00 00  1 110      
    add qword[rbx+rax*4-16],1             ;#0044E0E7: 48:203104203 F0 01         u  00 09  3 111      
    cmp eax,652                           ;#0044E0ED: 075 8C020000               vu 00 01  1 113      
    mov [rbp-16] (args),rax               ;#0044E0F2: 48:211105 F0               uv 00 21  1 114      
    mov qword[retaddr],#0044E103          ;#0044E0F6: 48:307105 20 03E14400      vu 00 20  1 114      
    jmp #00451A31 (code:printf)           ;#0044E0FE: 351 2E390000               v  00 00  1 115      
;  1732         return -1
    mov rax,-1                            ;#0044E103: 48:307300 FFFFFFFF         uv 01 00  1 116      
    jmp #0044298D (:%opRetf)              ;#0044E10A: 351 7E48FFFF               v  00 00  1 116      
;  1733     end if
;  1734     nTyp = sr[S_NTyp]
    mov rdi,2                             ;#0044E10F: 48:307307 02000000         uv 80 00  1 117      
    lea rcx,[rbp-64] (nTyp)               ;#0044E116: 48:215115 C0               vu 02 20  1 117      
    mov rsi,[rbp-56] (sr)                 ;#0044E11A: 48:213165 C8               uv 40 20  1 118      
    mov rdx,647                           ;#0044E11E: 48:307302 87020000         vu 04 00  1 118      
    call #00441675 (:%pSubse1)            ;#0044E125: 350 4B35FFFF               v  00 00  1 119      
;  1735     if nTyp<S_Type then
    cmp rax,6                             ;#0044E12A: 48:203370 06               uv 00 01  1 120      
    jge #0044E1C2                         ;#0044E12E: 017215 8E000000            v  00 00  1 120      
;  1736         printf(1,"pdiag.e/VarIdx:bad type(symtab[%d][S_NTyp]=%d)!\n",{rtn,nTyp})
    lea rax,[rbp-88] (symtab[652])        ;#0044E134: 48:215105 A8               uv 01 20  1 121      
    mov rdx,2                             ;#0044E138: 48:307302 02000000         vu 04 00  1 121      
    push #0044E154                        ;#0044E13F: 150 54E14400               uv 00 00  1 122      
    push rax                              ;#0044E144: 120                        vu 00 01  1 122      
    push qword[rbp-64] (nTyp)             ;#0044E145: 377165 C0                  np 00 20  2 123      
    push qword[rbp-8] (rtn)               ;#0044E148: 377165 F8                  np 00 20  2 125      
    mov rdi,[rbp-88] (symtab[652])        ;#0044E14B: 48:213175 A8               uv 80 20  1 127      
    jmp #004404BD (:%pMkSq)               ;#0044E14F: 351 6923FFFF               v  00 00  1 127      
    mov rcx,4                             ;#0044E154: 48:307301 04000000         uv 02 00  1 128      
    mov rdx,94                            ;#0044E15B: 48:307302 5E000000         vu 04 00  1 128      
    call #004428DB (:%opFrame) (printf)   ;#0044E162: 350 7447FFFF               v  00 00  1 129      
    mov qword[rbp] (fn),1                 ;#0044E167: 48:307105 00 01000000      uv 00 20  1 130      
    mov rcx,qword[#00402B60]              ;#0044E16F: 48:213015 EA49FBFF         vu 02 00  1 130      
    mov [rbp-8] (format),rcx              ;#0044E176: 48:211115 F8               uv 00 22  1 131      
    add qword[rbx+rcx*4-16],1             ;#0044E17A: 48:203104213 F0 01         u  00 0A  3 133    *02*
    mov rdi,[rbp+40] (prevebp)            ;#0044E180: 48:213175 28               vu 80 20  1 135      
    mov rax,[rdi-88]                      ;#0044E184: 48:213107 A8               uv 01 80  1 138    *80*
    xor rbx,rbx                           ;#0044E188: 48:061333                  vu 08 08  1 138      
    mov r15,h4                            ;#0044E18B: 49:277 0000000000000040    uv 8000 00  1 139      
    cmp rax,r15                           ;#0044E195: 4C:071370                  uv 00 8001  1 140 8000   
    jl #0044E1A5                          ;#0044E198: 174 0B                     v  00 00  1 140      
    add qword[rbx+rax*4-16],1             ;#0044E19A: 48:203104203 F0 01         u  00 09  3 141      
    cmp eax,652                           ;#0044E1A0: 075 8C020000               vu 00 01  1 143      
    mov [rbp-16] (args),rax               ;#0044E1A5: 48:211105 F0               uv 00 21  1 144      
    mov qword[retaddr],#0044E1B6          ;#0044E1A9: 48:307105 20 B6E14400      vu 00 20  1 144      
    jmp #00451A31 (code:printf)           ;#0044E1B1: 351 7B380000               v  00 00  1 145      
;  1737         return -1
    mov rax,-1                            ;#0044E1B6: 48:307300 FFFFFFFF         uv 01 00  1 146      
    jmp #0044298D (:%opRetf)              ;#0044E1BD: 351 CB47FFFF               v  00 00  1 146      
;  1738     end if
;  1739     if machine_bits()=32 then
;  1740         tidx = floor((or_ebp*4-addr)/4)
;  1741     else
;  1742         tidx = floor((or_ebp*4-addr)/8)
    mov rsi,[#00402AE8] (or_ebp)          ;#0044E1C2: 48:213065 1F49FBFF         uv 40 00  1 147      
    mov r15,h4                            ;#0044E1C9: 49:277 0000000000000040    vu 8000 00  1 147      
    cmp rsi,r15                           ;#0044E1D3: 4C:071376                  uv 00 8040  1 148      
    jne #0044E1E4                         ;#0044E1D6: 165 0C                     v  00 00  1 148      
    mov rsi,614                           ;#0044E1D8: 48:307306 66020000         uv 40 00  1 149      
    call #00442D75 (:%pUnassigned)        ;#0044E1DF: 350 914BFFFF               v  00 00  1 149      
    lea rdi,[rbp-72] (symtab[649])        ;#0044E1E4: 48:215175 B8               uv 80 20  1 150      
    mov rcx,rsi                           ;#0044E1E8: 48:211361                  vu 02 40  1 150      
    mov rax,[#004020A8] (D_YEAR)          ;#0044E1EB: 48:213005 B63EFBFF         uv 01 00  1 151      
    call #0043F67C (:%opMul)              ;#0044E1F2: 350 8514FFFF               v  00 00  1 151      
    lea rdi,[rbp-104] (symtab[657])       ;#0044E1F7: 48:215175 98               uv 80 20  1 152      
    mov rcx,[rbp-72] (symtab[649])        ;#0044E1FB: 48:213115 B8               vu 02 20  1 152      
    mov rax,[rbp] (addr)                  ;#0044E1FF: 48:213105 00               uv 01 20  1 153      
    call #0043F4D8 (:%opSub)              ;#0044E203: 350 D012FFFF               v  00 00  1 153      
    lea rdi,[rbp-48] (tidx)               ;#0044E208: 48:215175 D0               uv 80 20  1 154      
    mov rcx,[rbp-104] (symtab[657])       ;#0044E20C: 48:213115 98               vu 02 20  1 154      
    mov rax,[#004020C8] (D_MINUTE)        ;#0044E210: 48:213005 B13EFBFF         uv 01 00  1 155      
    call #0043F5E4 (:%opDivf)             ;#0044E217: 350 C813FFFF               v  00 00  1 155      
;  1743     end if
;  1744 --?tidx
;  1745     varno = sr[S_Parm1]
    mov rdi,8                             ;#0044E21C: 48:307307 08000000         uv 80 00  1 156      
    lea rcx,[rbp-40] (varno)              ;#0044E223: 48:215115 D8               vu 02 20  1 156      
    mov rsi,[rbp-56] (sr)                 ;#0044E227: 48:213165 C8               uv 40 20  1 157      
    mov rdx,647                           ;#0044E22B: 48:307302 87020000         vu 04 00  1 157      
    call #00441675 (:%pSubse1)            ;#0044E232: 350 3E34FFFF               v  00 00  1 158      
;  1746     while 1 do
;  1747         if varno<1 or varno>length(symtab) then
    mov rdi,[rbp-40] (varno)              ;#0044E237: 48:213175 D8               uv 80 20  1 159      
    cmp rdi,1                             ;#0044E23B: 48:203377 01               uv 00 80  1 160 80   
    jl #0044E250                          ;#0044E23F: 174 0F                     v  00 00  1 160      
    mov rcx,[rbp-16] (symtab)             ;#0044E241: 48:213115 F0               uv 02 20  1 161      
    mov rsi,[rbx+rcx*4-24]                ;#0044E245: 48:48:213164213 E8         uv 40 0A  1 164 02 *02*
    cmp rdi,rsi                           ;#0044E24B: 48:071367                  uv 00 C0  1 165 40   
    jle #0044E2A1                         ;#0044E24E: 176 51                     v  00 00  1 165      
;  1748             printf(1,"pdiag.e/VarIdx:bad S_Parm1/S_link chain (varno=%d)\n",varno)
    mov rcx,4                             ;#0044E250: 48:307301 04000000         uv 02 00  1 166      
    mov rdx,94                            ;#0044E257: 48:307302 5E000000         vu 04 00  1 166      
    call #004428DB (:%opFrame) (printf)   ;#0044E25E: 350 7846FFFF               v  00 00  1 167      
    mov qword[rbp] (fn),1                 ;#0044E263: 48:307105 00 01000000      uv 00 20  1 168      
    mov rax,qword[#00402B68]              ;#0044E26B: 48:213005 F648FBFF         vu 01 00  1 168      
    mov [rbp-8] (format),rax              ;#0044E272: 48:211105 F8               uv 00 21  1 169      
    add qword[rbx+rax*4-16],1             ;#0044E276: 48:203104203 F0 01         u  00 09  3 171    *01*
    mov rdi,[rbp+40] (prevebp)            ;#0044E27C: 48:213175 28               vu 80 20  1 173      
    mov rax,[rdi-40]                      ;#0044E280: 48:213107 D8               uv 01 80  1 176    *80*
    mov [rbp-16] (args),rax               ;#0044E284: 48:211105 F0               uv 00 21  1 177 01   
    mov qword[retaddr],#0044E295          ;#0044E288: 48:307105 20 95E24400      vu 00 20  1 177      
    jmp #00451A31 (code:printf)           ;#0044E290: 351 9C370000               v  00 00  1 178      
;  1749             return -1
    mov rax,-1                            ;#0044E295: 48:307300 FFFFFFFF         uv 01 00  1 179      
    jmp #0044298D (:%opRetf)              ;#0044E29C: 351 EC46FFFF               v  00 00  1 179      
;  1750         end if
;  1751         sr = symtab[varno]
    lea rcx,[rbp-56] (sr)                 ;#0044E2A1: 48:215115 C8               uv 02 20  1 180      
    mov rsi,[rbp-16] (symtab)             ;#0044E2A5: 48:213165 F0               vu 40 20  1 180      
    mov rdx,642                           ;#0044E2A9: 48:307302 82020000         uv 04 00  1 181      
    call #00441675 (:%pSubse1)            ;#0044E2B0: 350 C033FFFF               v  00 00  1 181      
;  1752         if atom(sr) then
    mov rcx,[rbp-56] (sr)                 ;#0044E2B5: 48:213115 C8               uv 02 20  1 182      
    mov r15,h4                            ;#0044E2B9: 49:277 0000000000000040    vu 8000 00  1 182      
    cmp rcx,r15                           ;#0044E2C3: 4C:071371                  uv 00 8002  1 183      
    jl #0044E2CF                          ;#0044E2C6: 174 07                     v  00 00  1 183      
    cmp byte[rbx+rcx*4-1],#12             ;#0044E2C8: 200174213 FF 12            u  00 0A  2 184      
    jne #0044E320                         ;#0044E2CD: 165 51                     v  00 00  1 185      
;  1753             printf(1,"pdiag.e:atom(symtab[%d])!\n",varno)
    mov rcx,4                             ;#0044E2CF: 48:307301 04000000         uv 02 00  1 186      
    mov rdx,94                            ;#0044E2D6: 48:307302 5E000000         vu 04 00  1 186      
    call #004428DB (:%opFrame) (printf)   ;#0044E2DD: 350 F945FFFF               v  00 00  1 187      
    mov qword[rbp] (fn),1                 ;#0044E2E2: 48:307105 00 01000000      uv 00 20  1 188      
    mov rax,qword[#00402B70]              ;#0044E2EA: 48:213005 7F48FBFF         vu 01 00  1 188      
    mov [rbp-8] (format),rax              ;#0044E2F1: 48:211105 F8               uv 00 21  1 189      
    add qword[rbx+rax*4-16],1             ;#0044E2F5: 48:203104203 F0 01         u  00 09  3 191    *01*
    mov rdi,[rbp+40] (prevebp)            ;#0044E2FB: 48:213175 28               vu 80 20  1 193      
    mov rax,[rdi-40]                      ;#0044E2FF: 48:213107 D8               uv 01 80  1 196    *80*
    mov [rbp-16] (args),rax               ;#0044E303: 48:211105 F0               uv 00 21  1 197 01   
    mov qword[retaddr],#0044E314          ;#0044E307: 48:307105 20 14E34400      vu 00 20  1 197      
    jmp #00451A31 (code:printf)           ;#0044E30F: 351 1D370000               v  00 00  1 198      
;  1754             return -1
    mov rax,-1                            ;#0044E314: 48:307300 FFFFFFFF         uv 01 00  1 199      
    jmp #0044298D (:%opRetf)              ;#0044E31B: 351 6D46FFFF               v  00 00  1 199      
;  1755         end if
;  1756         nTyp = sr[S_NTyp]
    mov rdi,2                             ;#0044E320: 48:307307 02000000         uv 80 00  1 200      
    lea rcx,[rbp-64] (nTyp)               ;#0044E327: 48:215115 C0               vu 02 20  1 200      
    mov rsi,[rbp-56] (sr)                 ;#0044E32B: 48:213165 C8               uv 40 20  1 201      
    mov rdx,647                           ;#0044E32F: 48:307302 87020000         vu 04 00  1 201      
    call #00441675 (:%pSubse1)            ;#0044E336: 350 3A33FFFF               v  00 00  1 202      
;  1757         if nTyp!=S_TVar3 then
    cmp rax,3                             ;#0044E33B: 48:203370 03               uv 00 01  1 203      
    je #0044E3D3                          ;#0044E33F: 017204 8E000000            v  00 00  1 203      
;  1758             printf(1,"pdiag.e/VarIdx:bad type(symtab[%d][S_NTyp](%d)!=S_TVar3)\n",{rtn,nTyp})
    lea rax,[rbp-88] (symtab[652])        ;#0044E345: 48:215105 A8               uv 01 20  1 204      
    mov rdx,2                             ;#0044E349: 48:307302 02000000         vu 04 00  1 204      
    push #0044E365                        ;#0044E350: 150 65E34400               uv 00 00  1 205      
    push rax                              ;#0044E355: 120                        vu 00 01  1 205      
    push qword[rbp-64] (nTyp)             ;#0044E356: 377165 C0                  np 00 20  2 206      
    push qword[rbp-8] (rtn)               ;#0044E359: 377165 F8                  np 00 20  2 208      
    mov rdi,[rbp-88] (symtab[652])        ;#0044E35C: 48:213175 A8               uv 80 20  1 210      
    jmp #004404BD (:%pMkSq)               ;#0044E360: 351 5821FFFF               v  00 00  1 210      
    mov rcx,4                             ;#0044E365: 48:307301 04000000         uv 02 00  1 211      
    mov rdx,94                            ;#0044E36C: 48:307302 5E000000         vu 04 00  1 211      
    call #004428DB (:%opFrame) (printf)   ;#0044E373: 350 6345FFFF               v  00 00  1 212      
    mov qword[rbp] (fn),1                 ;#0044E378: 48:307105 00 01000000      uv 00 20  1 213      
    mov rcx,qword[#00402B78]              ;#0044E380: 48:213015 F147FBFF         vu 02 00  1 213      
    mov [rbp-8] (format),rcx              ;#0044E387: 48:211115 F8               uv 00 22  1 214      
    add qword[rbx+rcx*4-16],1             ;#0044E38B: 48:203104213 F0 01         u  00 0A  3 216    *02*
    mov rdi,[rbp+40] (prevebp)            ;#0044E391: 48:213175 28               vu 80 20  1 218      
    mov rax,[rdi-88]                      ;#0044E395: 48:213107 A8               uv 01 80  1 221    *80*
    xor rbx,rbx                           ;#0044E399: 48:061333                  vu 08 08  1 221      
    mov r15,h4                            ;#0044E39C: 49:277 0000000000000040    uv 8000 00  1 222      
    cmp rax,r15                           ;#0044E3A6: 4C:071370                  uv 00 8001  1 223 8000   
    jl #0044E3B6                          ;#0044E3A9: 174 0B                     v  00 00  1 223      
    add qword[rbx+rax*4-16],1             ;#0044E3AB: 48:203104203 F0 01         u  00 09  3 224      
    cmp eax,652                           ;#0044E3B1: 075 8C020000               vu 00 01  1 226      
    mov [rbp-16] (args),rax               ;#0044E3B6: 48:211105 F0               uv 00 21  1 227      
    mov qword[retaddr],#0044E3C7          ;#0044E3BA: 48:307105 20 C7E34400      vu 00 20  1 227      
    jmp #00451A31 (code:printf)           ;#0044E3C2: 351 6A360000               v  00 00  1 228      
;  1759             return -1
    mov rax,-1                            ;#0044E3C7: 48:307300 FFFFFFFF         uv 01 00  1 229      
    jmp #0044298D (:%opRetf)              ;#0044E3CE: 351 BA45FFFF               v  00 00  1 229      
;  1760         end if
;  1761         if tidx=0 then exit end if
    xor rdi,rdi                           ;#0044E3D3: 48:061377                  uv 80 80  1 230      
    mov rax,[rbp-48] (tidx)               ;#0044E3D6: 48:213105 D0               vu 01 20  1 230      
    mov rsi,25                            ;#0044E3DA: 48:307306 19000000         uv 40 00  1 231      
    mov rdx,646                           ;#0044E3E1: 48:307302 86020000         vu 04 00  1 231      
    call #0043FAF6 (:%opJccE)             ;#0044E3E8: 350 0917FFFF               v  00 00  1 232      
    je #0044E442                          ;#0044E3ED: 164 53                     v  00 00  1 233      
;  1762         varno = sr[S_Slink]
    mov rdi,6                             ;#0044E3EF: 48:307307 06000000         uv 80 00  1 234      
    lea rcx,[rbp-40] (varno)              ;#0044E3F6: 48:215115 D8               vu 02 20  1 234      
    mov rsi,[rbp-56] (sr)                 ;#0044E3FA: 48:213165 C8               uv 40 20  1 235      
    mov rdx,647                           ;#0044E3FE: 48:307302 87020000         vu 04 00  1 235      
    call #00441675 (:%pSubse1)            ;#0044E405: 350 6B32FFFF               v  00 00  1 236      
;  1763         tidx -= 1
    mov rdi,[rbp-48] (tidx)               ;#0044E40A: 48:213175 D0               uv 80 20  1 237      
    mov r15,h4                            ;#0044E40E: 49:277 0000000000000040    vu 8000 00  1 237      
    cmp rdi,r15                           ;#0044E418: 4C:071377                  uv 00 8080  1 238      
    jne #0044E429                         ;#0044E41B: 165 0C                     v  00 00  1 238      
    mov rsi,646                           ;#0044E41D: 48:307306 86020000         uv 40 00  1 239      
    call #00442D75 (:%pUnassigned)        ;#0044E424: 350 4C49FFFF               v  00 00  1 239      
    lea rdi,[rbp-48] (tidx)               ;#0044E429: 48:215175 D0               uv 80 20  1 240      
    mov rcx,[rbp-48] (tidx)               ;#0044E42D: 48:213115 D0               vu 02 20  1 240      
    mov rax,qword[#00402030]              ;#0044E431: 48:213005 F83BFBFF         uv 01 00  1 241      
    call #0043F4EB (:%opSubi)             ;#0044E438: 350 AE10FFFF               v  00 00  1 241      
;  1764     end while
    jmp #0044E237                         ;#0044E43D: 351 F5FDFFFF               v  00 00  1 242      
;  1765     return varno
    mov rax,[rbp-40] (varno)              ;#0044E442: 48:213105 D8               uv 01 20  1 243      
    jmp #0044298D (:%opRetf)              ;#0044E446: 351 4245FFFF               v  00 00  1 243      
;  1766 --/*
;  1767 integer tidx, stidx
;  1768 integer N, rtnid
;  1769 object sr
;  1770     stidx = floor((addr-etd)/4)+1
;  1771 --  stidx = floor((etd-addr)/4)+1
;  1772     if stidx>0 and stidx<=length(vmap) then
;  1773         return vmap[stidx]
;  1774     end if
;  1775     -- a local var then:
;  1776     N = peek4u(or_ebp*4+4)
;  1777 --  tidx = floor((addr-or_ebp*4)/4)
;  1778     tidx = floor((or_ebp*4-addr)/4)
;  1779 --DEV isn't this <=0? aren't both N and tidx +ve?!
;  1780 --  if tidx<0 and tidx<N then
;  1781     if tidx>=0 and tidx<N then
;  1782         rtnid = peek4u(or_ebp*4+8)  --DEV?? rtn not good enough for ya?
;  1783 -- this may be temp!
;  1784 if rtnid!=rtn then
;  1785     puts(1,"pdiag.e:varIdx - rtnid!=rtn\n")
;  1786 end if
;  1787         if rtnid<1 or rtnid>length(symtab) then
;  1788             puts(1,"pdiag.e:symtab[rtnid] ioob!\n")
;  1789             return -1
;  1790         end if
;  1791         sr = symtab[rtnid]
;  1792         if atom(sr) then
;  1793             puts(1,"pdiag.e:atom(symtab[rtnid])!\n")
;  1794             return -1
;  1795         end if
;  1796         nTyp = sr[S_NTyp]
;  1797         if nTyp>=S_Type then
;  1798             N = tidx
;  1799             tidx = sr[S_Parm1]
;  1800             while N do
;  1801                 if tidx<1 or tidx>length(symtab) then
;  1802                     puts(1,"\n\n**pdiag.e:bad S_Parm1/S_link chain!\n\n")
;  1803                     return -1
;  1804                 end if
;  1805                 sr = symtab[tidx]
;  1806                 if atom(sr) then
;  1807                     printf(1,"pdiag.e:atom(symtab[tidx(=%d)])!\n",tidx)
;  1808                     return -1
;  1809                 end if
;  1810                 tidx = sr[S_Slink]
;  1811                 N -= 1
;  1812             end while
;  1813             return tidx
;  1814         end if
;  1815     end if
;  1816     printf(1,"\n**pdiag.e:tidx(=%d) out of range!\n",tidx)
;  1817     printf(1,"  (addr=#%08x, ebp=#%08x, N=%d)\n",{addr,or_ebp*4,N})
;  1818     printf(1,"  (stidx=%d, etd=#%08x, length(vmap)=%d)\n",{stidx,etd,length(vmap)})
;  1819 --*/
;  1820 --  return -1   -- oops!
    call #00442D91 (:%pBadRetf)           ;#0044E44B: 350 4149FFFF               v  00 00  1 244      
;  1821 end function
;  1822 
;  1823 constant cmp_eax_imm32  = #3D           -- 0o075 imm32              -- cmp eax,imm32
;  1824 
;  1825 --DEV...
;  1826 object crashfile = 0
;  1827 
;  1828 integer diaglooping = 0
;  1829 constant ecode = "diag looping, error code is "
;  1830 constant erais = ", era is #"
;  1831 
;  1832 integer msg_id = 0  -- 1..255  (should we ever need more, then I suggest if al is #FF, 
;  1833                     --          then instead of "and e/rax,#FF", "shr e/rax,8" allows
;  1834                     --          the high 3 bytes of eax to contain another 16 million,
;  1835                     --          and leaves "mov al,#01".."mov al,#FE" still working.)
;  1836 
;  1837 function addrS(atom a)
;  1838     if a=0 then return "0" end if
    mov rcx,[rbp] (a)                     ;#004519B7: 48:213115 00               uv 02 20  1   1      
    cmp rcx,0                             ;#004519BB: 48:203371 00               uv 00 02  1   2 02   
    jne #004519D3                         ;#004519BF: 165 12                     v  00 00  1   2      
    mov rax,qword[#00402238]              ;#004519C1: 48:213005 7008FBFF         uv 01 00  1   3      
    add qword[rbx+rax*4-16],1             ;#004519C8: 48:203104203 F0 01         u  00 09  3   6    *01*
    jmp #0044298D (:%opRetf)              ;#004519CE: 351 BA0FFFFF               v  00 00  1   8      
;  1839     return sprintf("%08x",a)
    mov rcx,33                            ;#004519D3: 48:307301 21000000         uv 02 00  1   9      
    mov rdx,89                            ;#004519DA: 48:307302 59000000         vu 04 00  1   9      
    call #004428DB (:%opFrame) (sprintf)  ;#004519E1: 350 F50EFFFF               v  00 00  1  10      
    mov rdi,qword[#00402BB0]              ;#004519E6: 48:213075 C311FBFF         uv 80 00  1  11      
    mov [rbp] (format),rdi                ;#004519ED: 48:211175 00               uv 00 A0  1  12 80   
    add qword[rbx+rdi*4-16],1             ;#004519F1: 48:203104273 F0 01         u  00 88  3  14    *80*
    mov rdi,[rbp+40] (prevebp)            ;#004519F7: 48:213175 28               vu 80 20  1  16      
    mov rax,[rdi]                         ;#004519FB: 48:213007                  uv 01 80  1  19    *80*
    xor rbx,rbx                           ;#004519FE: 48:061333                  vu 08 08  1  19      
    mov r15,h4                            ;#00451A01: 49:277 0000000000000040    uv 8000 00  1  20      
    cmp rax,r15                           ;#00451A0B: 4C:071370                  uv 00 8001  1  21 8000   
    jl #00451A1B                          ;#00451A0E: 174 0B                     v  00 00  1  21      
    add qword[rbx+rax*4-16],1             ;#00451A10: 48:203104203 F0 01         u  00 09  3  22      
    cmp eax,669                           ;#00451A16: 075 9D020000               vu 00 01  1  24      
    mov [rbp-8] (args),rax                ;#00451A1B: 48:211105 F8               uv 00 21  1  25      
    mov qword[retaddr],#00451A2C          ;#00451A1F: 48:307105 20 2C1A4500      vu 00 20  1  25      
    jmp #0044E450 (code:sprintf)          ;#00451A27: 351 24CAFFFF               v  00 00  1  26      
    jmp #0044298D (:%opRetf)              ;#00451A2C: 351 5C0FFFFF               v  00 00  1  27      
;  1840 end function
;  1841 
;  1842 --DEV this may in fact be pointless...
;  1843 integer rbldrqd=1   -- (shadow copy of the one in pemit2.e)
;  1844 
;  1845 --function diag(atom msg_id)
;  1846 procedure diag()
;  1847 --
;  1848 -- create the ex.err.
;  1849 --
;  1850 -- on entry (only called from below) the following must be set:
;  1851 --  msg_id, 1..255
;  1852 --  xceptn, exception code (may be 0)
;  1853 --  xcepta, exception address (iff xceptn!=0)
;  1854 --  or_era, effective return address
;  1855 --  and from the exception context or the real register,
;  1856 --  or_ebp, (should match ebp, pre-diag()) [stored/4]
;  1857 --  or_ecx,
;  1858 --  or_edi,
;  1859 --  or_esi,
;  1860 --  or_esp (should match esp)
;  1861 --
;  1862 -- note that ep1 and ep2 (if used) are (now) msg_id-dependent.
;  1863 --
;  1864 
;  1865 object symtab   -- copy of symtab obtained via :%opGetST (see pStack.e)
;  1866 
;  1867 object  si,             -- copy of symtab[i]
;  1868         sp,             -- copy of symtab[<param/local var>]
;  1869         name,           -- var name or -1 for temporaries we should skip
;  1870         o--,o2          -- output vars
;  1871 integer lineno,         -- linenumber as calculated from return addr/offset & linetab
;  1872         linenxt,        -- see lineno calculation
;  1873         lti,            -- copy of linetab[i] used in lineno calculation
;  1874         thisline,       -- needed for lineno in packed linetab case
;  1875         skip,           -- needed for packed linetabs
;  1876         fileno,         -- for grouping symtab entries into files
;  1877         fpno,           -- copy of si[S_FPno]
;  1878         sNTyp           -- copy of sr[S_NTyp]
;  1879 integer c               -- scratch var
;  1880 atom    returnoffset    -- era as offset into code block, used in lineno calc
;  1881 
;  1882 sequence msg,           -- error message, from msgs[msg_id] plus any params
;  1883          wmsg,          -- work var, used for building msg
;  1884 --       s8,            -- copy of symtab[T_callstk], see below
;  1885          sr,            -- copy of symtab[rtn]
;  1886          linetab,       -- copy of symtab[rtn][S_ltab]
;  1887          filename,      -- output var
;  1888          pathset,       -- copy of symtab[T_pathset] with mainpath added if .exe
;  1889          x6             -- e30->e92 fixup
;  1890 
;  1891 --atom ep1, ep2         -- error parameters
;  1892 
;  1893 integer lastline
;  1894 integer base = 0, tmp
    mov [rbp-184] (base),rbx              ;#004439B9: 48:211235 48FFFFFF         uv 00 28  1   1      
;  1895 
;  1896 integer p
;  1897 
;  1898 integer N, rtn
;  1899 --DEV from_addr is not really used!! (if we can get away without it...)
;  1900 atom from_addr, ret_addr, prev_ebp, ebp_root
;  1901 atom vsb_prev, vsb_next, vsb_magic
;  1902 string magicok
;  1903 integer abortcode
;  1904 integer rtype   -- 1 skip (lineno=-1),
;  1905                 -- 2 normal
;  1906                 -- 3 without debug
;  1907 integer tidx
;  1908 integer varno
;  1909 integer novalue
;  1910 string msg2
;  1911 
;  1912 --DEV:
;  1913 atom symtabptr
;  1914 atom gvarptr
;  1915 
;  1916 --/*
;  1917     This will definitely never work on RDS Eu!
;  1918 --*/
;  1919 --puts(1,"uh1?\n")
;  1920 --?msg_id
;  1921     diaglooping += 1
    mov rsi,[#00402B90] (diaglooping)     ;#004439C0: 48:213065 C9F1FBFF         vu 40 00  1   1      
    add rsi,1                             ;#004439C7: 48:203306 01               uv 40 40  1   2      
    mov rdx,rsi                           ;#004439CB: 48:213326                  uv 04 40  1   3 40   
    mov [#00402B90] (diaglooping),rsi     ;#004439CE: 48:211065 BBF1FBFF         vu 00 40  1   3      
    shl rdx,1                             ;#004439D5: 48:321342                  u  04 04  1   4      
    jno #004439E6                         ;#004439D8: 161 0C                     v  00 00  1   4      
    lea rdi,[#00402B90] (diaglooping)     ;#004439DA: 48:215075 AFF1FBFF         uv 80 00  1   5      
    call #00442DA9 (:%pAddiii)            ;#004439E1: 350 C3F3FFFF               v  00 00  1   5      
;  1922 --maybe:
;  1923 --  enter_cs()
;  1924 --DEV
;  1925 --!/*
;  1926     if rbldrqd then
    mov rcx,[#00402BB8] (rbldrqd)         ;#004439E6: 48:213015 CBF1FBFF         uv 02 00  1   6      
    test rcx,rcx                          ;#004439ED: 48:205311                  uv 00 02  1   7 02   
    je #00443A13                          ;#004439F0: 164 21                     v  00 00  1   7      
;  1927 --      rebuild_callback()
;  1928         --
;  1929         -- invoke pemit2.e/rebuild_callback() if needed, but we can't use a
;  1930         -- normal hll call as this is linked into all .exe files, in which 
;  1931         -- case :!rbidscb resolves to 0 and this does nothing. Likewise we
;  1932         -- use a shadow copy of rbldrqd, and invoke :!rbidscb at most once,
;  1933         -- which (if non-0) tests the real rbldrqd before doing anything.
;  1934         --
;  1935         rbldrqd = 0
    mov [#00402BB8] (rbldrqd),rbx         ;#004439F2: 48:211035 BFF1FBFF         uv 00 08  1   8      
;  1936         #ilASM{ 
;  1937             [32]
;  1938 --DEV push/pop d/qword[ds+8] (not yet supported by pilasm.e)
;  1939                 mov eax,[ds+8]
;  1940                 push eax
;  1941                 call :!rbidscb  -- (leaves return addr on stack)
;  1942                 add esp,4       -- (discard "")
;  1943                 pop eax
;  1944                 mov [ds+8],eax
;  1945             [64]
;  1946                 mov rax,[ds+8]
                        mov rax,qword[#00402008]  ;#004439F9: 48:213005 08E6FBFF         vu 01 00  1   8      
;  1947                 push rax
                        push rax          ;#00443A00: 48:120                     uv 00 01  1   9      
;  1948                 call :!rbidscb  -- (leaves return addr on stack)
                        call #00443A07    ;#00443A02: 350 00000000               v  00 00  1   9      
;  1949                 add rsp,8       -- (discard "")
                        add rsp,8         ;#00443A07: 48:203304 08               uv 10 10  1  10      
;  1950                 pop rax
                        pop rax           ;#00443A0B: 48:130                     vu 01 00  1  10      
;  1951                 mov [ds+8],rax
                        mov dword[#00402008],eax  ;#00443A0D: 211005 F5E5FBFF            uv 00 01  1  11      
;  1952             []
;  1953               }
;  1954     end if
;  1955 --!*/
;  1956 --/*
;  1957     if rbldrqd then
;  1958         #ilASM{ 
;  1959 --jmp :fin
;  1960 --    :!rbidscb
;  1961             [32]
;  1962 --              push dword[esp]                         -- (leave the ret addr on stack)
;  1963                 mov edx,routine_id(rebuild_callback)    -- mov edx,imm32 (sets K_ridt)
;  1964                 mov ecx,$_Ltot                          -- mov ecx,imm32 (=symtab[rebuild_callback][S_Ltot])
;  1965                 call :%opFrame
;  1966                 mov dword[ebp+16],:rbidsret
;  1967                 jmp $_il                                -- jmp code:rebuild_callback
;  1968             [64]
;  1969 --              push qword[rsp]                         -- (leave the ret addr on stack)
;  1970 --pop al
;  1971                 mov rdx,routine_id(rebuild_callback)    -- mov edx,imm32 (sets K_ridt)
;  1972                 mov rcx,$_Ltot                          -- mov ecx,imm32 (=symtab[rebuild_callback][S_Ltot])
;  1973                 call :%opFrame
;  1974                 mov qword[rbp+32],:rbidsret
;  1975                 jmp $_il                                -- jmp code:rebuild_callback
;  1976             []
;  1977           ::rbidsret    
;  1978 --          ret
;  1979 --    ::fin
;  1980           }
;  1981     end if
;  1982 --*/
;  1983 --?1
;  1984 --?9/0
;  1985 --?2
;  1986 
;  1987 --  if msg_id=#FFFFFFFF then    -- (-1 as an unsigned 32-bit value!)
;  1988 ----puts(1,"setting batchmode to 1...\n") --DEV temp!
;  1989 --      batchmode = 1
;  1990 --      return 0
;  1991 --  end if
;  1992     puts(1,"\n")
    mov rax,1                             ;#00443A13: 48:307300 01000000         vu 01 00  1  11      
    mov rdx,qword[#00402600]              ;#00443A1A: 48:213025 DFEBFBFF         uv 04 00  1  12      
    call #0043E218 (:%opPuts)             ;#00443A21: 350 F2A7FFFF               v  00 00  1  12      
;  1993 --DEV [may no longer be rqd] [set routines should be in here anyway]
;  1994 --  crash_msg = ""      -- /necessary/: ensure compiler knows this is string/integer
;  1995 --  crash_msg = "abc"       -- /necessary/: ensure compiler knows this is string/integer
;  1996                         --  (needed since it is only ever set by assembly code)
;  1997 --  crash_msg = 0   -- get callstack as at enumbset.
;  1998 --  crashfile = 0
;  1999     #ilASM{
;  2000         [32]
;  2001             lea edi,[symtab]
;  2002         [64]
;  2003             lea rdi,[symtab]
                    mov rdi,rbp           ;#00443A26: 48:213375                  uv 80 20  1  13      
;  2004         []
;  2005             call :%opGetST  -- [e/rdi]:=symtab (see pStack.e)
                    call #00442802 (:%opGetST)  ;#00443A29: 350 D4EDFFFF               v  00 00  1  13      
;  2006           }
;  2007     lines = 0
    mov [#00402668] (lines),rbx           ;#00443A2E: 48:211035 33ECFBFF         uv 00 08  1  14      
;  2008 --puts(1,"d2\n")
;  2009     if symtab[T_EBP]=0 then             -- compiled
    mov rax,[rbp] (symtab)                ;#00443A35: 48:213105 00               vu 01 20  1  14      
    mov r15,h4                            ;#00443A39: 49:277 0000000000000040    uv 8000 00  1  15      
    cmp rax,r15                           ;#00443A43: 4C:071370                  uv 00 8001  1  16 8000   
    jne #00443A54                         ;#00443A46: 165 0C                     v  00 00  1  16      
    mov rsi,673                           ;#00443A48: 48:307306 A1020000         uv 40 00  1  17      
    call #00442D75 (:%pUnassigned)        ;#00443A4F: 350 21F3FFFF               v  00 00  1  17      
    mov rdi,22                            ;#00443A54: 48:307307 16000000         uv 80 00  1  18      
    lea rcx,[rbp-352] (symtab[717])       ;#00443A5B: 48:215215 A0FEFFFF         vu 02 20  1  18      
    mov rsi,rax                           ;#00443A62: 48:211306                  uv 40 01  1  19      
    mov rdx,673                           ;#00443A65: 48:307302 A1020000         vu 04 00  1  19      
    call #00441675 (:%pSubse1)            ;#00443A6C: 350 04DCFFFF               v  00 00  1  20      
    mov rdi,[rbp-352] (symtab[717])       ;#00443A71: 48:213275 A0FEFFFF         uv 80 20  1  21      
    cmp rdi,0                             ;#00443A78: 48:203377 00               uv 00 80  1  22 80   
    jne #00443AD3                         ;#00443A7C: 165 55                     v  00 00  1  22      
;  2010         ds4 = floor(symtab[T_ds4]/4)
    mov rsi,[rbp] (symtab)                ;#00443A7E: 48:213165 00               uv 40 20  1  23      
    mov r15,h4                            ;#00443A82: 49:277 0000000000000040    vu 8000 00  1  23      
    cmp rsi,r15                           ;#00443A8C: 4C:071376                  uv 00 8040  1  24      
    jne #00443A9D                         ;#00443A8F: 165 0C                     v  00 00  1  24      
    mov rsi,673                           ;#00443A91: 48:307306 A1020000         uv 40 00  1  25      
    call #00442D75 (:%pUnassigned)        ;#00443A98: 350 D8F2FFFF               v  00 00  1  25      
    mov rdi,23                            ;#00443A9D: 48:307307 17000000         uv 80 00  1  26      
    lea rcx,[rbp-352] (symtab[717])       ;#00443AA4: 48:215215 A0FEFFFF         vu 02 20  1  26      
    mov rdx,673                           ;#00443AAB: 48:307302 A1020000         uv 04 00  1  27      
    call #00441675 (:%pSubse1)            ;#00443AB2: 350 BEDBFFFF               v  00 00  1  27      
    lea rdi,[#00402B30] (ds4)             ;#00443AB7: 48:215075 72F0FBFF         uv 80 00  1  28      
    mov rcx,[rbp-352] (symtab[717])       ;#00443ABE: 48:213215 A0FEFFFF         vu 02 20  1  28      
    mov rax,[#004020A8] (D_YEAR)          ;#00443AC5: 48:213005 DCE5FBFF         uv 01 00  1  29      
    call #0043F5E4 (:%opDivf)             ;#00443ACC: 350 13BBFFFF               v  00 00  1  29      
    jmp #00443B10                         ;#00443AD1: 353 3D                     v  00 00  1  30      
;  2011     else                                -- interpreted
;  2012         ds4 = symtab[T_ds4]
    mov rdi,[rbp] (symtab)                ;#00443AD3: 48:213175 00               uv 80 20  1  31      
    mov r15,h4                            ;#00443AD7: 49:277 0000000000000040    vu 8000 00  1  31      
    cmp rdi,r15                           ;#00443AE1: 4C:071377                  uv 00 8080  1  32      
    jne #00443AF2                         ;#00443AE4: 165 0C                     v  00 00  1  32      
    mov rsi,673                           ;#00443AE6: 48:307306 A1020000         uv 40 00  1  33      
    call #00442D75 (:%pUnassigned)        ;#00443AED: 350 83F2FFFF               v  00 00  1  33      
    mov rdi,23                            ;#00443AF2: 48:307307 17000000         uv 80 00  1  34      
    lea rcx,[#00402B30] (ds4)             ;#00443AF9: 48:215015 30F0FBFF         vu 02 00  1  34      
    mov rsi,[rbp] (symtab)                ;#00443B00: 48:213165 00               uv 40 20  1  35      
    mov rdx,673                           ;#00443B04: 48:307302 A1020000         vu 04 00  1  35      
    call #00441675 (:%pSubse1)            ;#00443B0B: 350 65DBFFFF               v  00 00  1  36      
;  2013     end if
;  2014 
;  2015 -- 4/8/15:
;  2016     if and_bits(symtab[T_cmdlnflg],#04)!=0 then
    mov rcx,[rbp] (symtab)                ;#00443B10: 48:213115 00               uv 02 20  1  37      
    mov r15,h4                            ;#00443B14: 49:277 0000000000000040    vu 8000 00  1  37      
    cmp rcx,r15                           ;#00443B1E: 4C:071371                  uv 00 8002  1  38      
    jne #00443B2F                         ;#00443B21: 165 0C                     v  00 00  1  38      
    mov rsi,673                           ;#00443B23: 48:307306 A1020000         uv 40 00  1  39      
    call #00442D75 (:%pUnassigned)        ;#00443B2A: 350 46F2FFFF               v  00 00  1  39      
    mov rdi,19                            ;#00443B2F: 48:307307 13000000         uv 80 00  1  40      
    lea rcx,[rbp-352] (symtab[717])       ;#00443B36: 48:215215 A0FEFFFF         vu 02 20  1  40      
    mov rsi,[rbp] (symtab)                ;#00443B3D: 48:213165 00               uv 40 20  1  41      
    mov rdx,673                           ;#00443B41: 48:307302 A1020000         vu 04 00  1  41      
    call #00441675 (:%pSubse1)            ;#00443B48: 350 28DBFFFF               v  00 00  1  42      
    lea rdi,[rbp-360] (symtab[718])       ;#00443B4D: 48:215275 98FEFFFF         uv 80 20  1  43      
    mov rcx,[rbp-352] (symtab[717])       ;#00443B54: 48:213215 A0FEFFFF         vu 02 20  1  43      
    mov rax,[#004020A8] (D_YEAR)          ;#00443B5B: 48:213005 46E5FBFF         uv 01 00  1  44      
    call #0043F6C1 (:%opAndBits)          ;#00443B62: 350 5ABBFFFF               v  00 00  1  44      
    mov rdi,[rbp-360] (symtab[718])       ;#00443B67: 48:213275 98FEFFFF         uv 80 20  1  45      
    cmp rdi,0                             ;#00443B6E: 48:203377 00               uv 00 80  1  46 80   
    je #00443B7F                          ;#00443B72: 164 0B                     v  00 00  1  46      
;  2017         batchmode = 1
    mov qword[#00402678] (batchmode),1    ;#00443B74: 48:307005 F9EAFBFF 01000000 uv 00 00  1  47      
;  2018     end if
;  2019 
;  2020 --(DEV) this may help you get better ex.err when something crashes in this file (untested)
;  2021 --/*
;  2022     pst4 = symtab[T_EBP][3]     -- (we may want to loop until we hit a 0)
;  2023     #ilASM{
;  2024         [32]
;  2025             mov eax,[pst4]
;  2026             shl eax,2
;  2027             mov [ds+8],eax
;  2028         [64]
;  2029             pop al
;  2030         []
;  2031           }
;  2032 --*/
;  2033 
;  2034 --?1
;  2035 --?msg_id
;  2036 --?2
;  2037 --?msg_id
;  2038 --puts(1,"d2a-\n")
;  2039 --DEV (temp)
;  2040 --DEV these may want to be inside the loop... (is ebp_root overwritten?)
;  2041     if machine_bits()=32 then
;  2042         {N,rtn,from_addr,ret_addr,prev_ebp,ebp_root} = peek4u({or_ebp*4+4,6})
;  2043 --      {vsb_prev,vsb_next,vsb_magic} = peek4u({ebp_root,3})
;  2044 --?     dd symtabptr                [vsb_root+8]        -- (raw address of symtab[1])
;  2045 --?     dd gvarptr                  [vsb_root+12]       -- (raw address of gvar[1])
;  2046 --      dd magic                    [vsb_root+16]       -- (#40565342 = "@VSB")
;  2047         {vsb_prev,vsb_next,symtabptr,gvarptr,vsb_magic} = peek4u({ebp_root,5})
;  2048     else -- machine_bits()=64
;  2049         {N,rtn,from_addr,ret_addr,prev_ebp,ebp_root} = peek8u({or_ebp*4+8,6})
    mov rsi,[#00402AE8] (or_ebp)          ;#00443B7F: 48:213065 62EFFBFF         vu 40 00  1  47      
    mov r15,h4                            ;#00443B86: 49:277 0000000000000040    uv 8000 00  1  48      
    cmp rsi,r15                           ;#00443B90: 4C:071376                  uv 00 8040  1  49 8000   
    jne #00443BA1                         ;#00443B93: 165 0C                     v  00 00  1  49      
    mov rsi,614                           ;#00443B95: 48:307306 66020000         uv 40 00  1  50      
    call #00442D75 (:%pUnassigned)        ;#00443B9C: 350 D4F1FFFF               v  00 00  1  50      
    lea rdi,[rbp-368] (symtab[719])       ;#00443BA1: 48:215275 90FEFFFF         uv 80 20  1  51      
    mov rcx,rsi                           ;#00443BA8: 48:211361                  vu 02 40  1  51      
    mov rax,[#004020A8] (D_YEAR)          ;#00443BAB: 48:213005 F6E4FBFF         uv 01 00  1  52      
    call #0043F67C (:%opMul)              ;#00443BB2: 350 C5BAFFFF               v  00 00  1  52      
    lea rdi,[rbp-376] (symtab[720])       ;#00443BB7: 48:215275 88FEFFFF         uv 80 20  1  53      
    mov rcx,[rbp-368] (symtab[719])       ;#00443BBE: 48:213215 90FEFFFF         vu 02 20  1  53      
    mov rax,[#004020C8] (D_MINUTE)        ;#00443BC5: 48:213005 FCE4FBFF         uv 01 00  1  54      
    call #0043F4AF (:%opAdd)              ;#00443BCC: 350 DEB8FFFF               v  00 00  1  54      
    lea rax,[rbp-384] (symtab[721])       ;#00443BD1: 48:215205 80FEFFFF         uv 01 20  1  55      
    mov rdx,2                             ;#00443BD8: 48:307302 02000000         vu 04 00  1  55      
    push #00443C00                        ;#00443BDF: 150 003C4400               uv 00 00  1  56      
    push rax                              ;#00443BE4: 120                        vu 00 01  1  56      
    push 6                                ;#00443BE5: 152 06                     uv 00 00  1  57      
    push qword[rbp-376] (symtab[720])     ;#00443BE7: 377265 88FEFFFF            np 00 20  2  58      
    mov [rbp-376] (symtab[720]),rbx       ;#00443BED: 48:211235 88FEFFFF         uv 00 28  1  60      
    mov rdi,[rbp-384] (symtab[721])       ;#00443BF4: 48:213275 80FEFFFF         vu 80 20  1  60      
    jmp #004404BD (:%pMkSq)               ;#00443BFB: 351 BDC8FFFF               v  00 00  1  61      
    lea rdi,[rbp-352] (symtab[717])       ;#00443C00: 48:215275 A0FEFFFF         uv 80 20  1  62      
    mov rsi,[rbp-384] (symtab[721])       ;#00443C07: 48:213265 80FEFFFF         vu 40 20  1  62      
    xor rcx,rcx                           ;#00443C0E: 48:061311                  uv 02 02  1  63      
    mov rdx,8                             ;#00443C11: 48:307302 08000000         vu 04 00  1  63      
    call #0043ED6C (:%opPeekNx)           ;#00443C18: 350 4FB1FFFF               v  00 00  1  64      
    mov rdi,6                             ;#00443C1D: 48:307307 06000000         uv 80 00  1  65      
    lea rcx,[rbp-248] (ebp_root)          ;#00443C24: 48:215215 08FFFFFF         vu 02 20  1  65      
    mov rsi,[rbp-352] (symtab[717])       ;#00443C2B: 48:213265 A0FEFFFF         uv 40 20  1  66      
    mov rdx,717                           ;#00443C32: 48:307302 CD020000         vu 04 00  1  66      
    call #00441675 (:%pSubse1)            ;#00443C39: 350 37DAFFFF               v  00 00  1  67      
    mov rdi,5                             ;#00443C3E: 48:307307 05000000         uv 80 00  1  68      
    lea rcx,[rbp-240] (prev_ebp)          ;#00443C45: 48:215215 10FFFFFF         vu 02 20  1  68      
    mov rsi,[rbp-352] (symtab[717])       ;#00443C4C: 48:213265 A0FEFFFF         uv 40 20  1  69      
    mov rdx,717                           ;#00443C53: 48:307302 CD020000         vu 04 00  1  69      
    call #00441675 (:%pSubse1)            ;#00443C5A: 350 16DAFFFF               v  00 00  1  70      
    mov rdi,4                             ;#00443C5F: 48:307307 04000000         uv 80 00  1  71      
    lea rcx,[rbp-232] (ret_addr)          ;#00443C66: 48:215215 18FFFFFF         vu 02 20  1  71      
    mov rsi,[rbp-352] (symtab[717])       ;#00443C6D: 48:213265 A0FEFFFF         uv 40 20  1  72      
    mov rdx,717                           ;#00443C74: 48:307302 CD020000         vu 04 00  1  72      
    call #00441675 (:%pSubse1)            ;#00443C7B: 350 F5D9FFFF               v  00 00  1  73      
    mov rdi,3                             ;#00443C80: 48:307307 03000000         uv 80 00  1  74      
    lea rcx,[rbp-224] (from_addr)         ;#00443C87: 48:215215 20FFFFFF         vu 02 20  1  74      
    mov rsi,[rbp-352] (symtab[717])       ;#00443C8E: 48:213265 A0FEFFFF         uv 40 20  1  75      
    mov rdx,717                           ;#00443C95: 48:307302 CD020000         vu 04 00  1  75      
    call #00441675 (:%pSubse1)            ;#00443C9C: 350 D4D9FFFF               v  00 00  1  76      
    mov rdi,2                             ;#00443CA1: 48:307307 02000000         uv 80 00  1  77      
    lea rcx,[rbp-216] (rtn)               ;#00443CA8: 48:215215 28FFFFFF         vu 02 20  1  77      
    mov rsi,[rbp-352] (symtab[717])       ;#00443CAF: 48:213265 A0FEFFFF         uv 40 20  1  78      
    mov rdx,717                           ;#00443CB6: 48:307302 CD020000         vu 04 00  1  78      
    call #004416F2 (:%pSubse1i)           ;#00443CBD: 350 30DAFFFF               v  00 00  1  79      
    mov rdi,1                             ;#00443CC2: 48:307307 01000000         uv 80 00  1  80      
    lea rcx,[rbp-208] (N)                 ;#00443CC9: 48:215215 30FFFFFF         vu 02 20  1  80      
    mov rsi,[rbp-352] (symtab[717])       ;#00443CD0: 48:213265 A0FEFFFF         uv 40 20  1  81      
    mov rdx,717                           ;#00443CD7: 48:307302 CD020000         vu 04 00  1  81      
    call #004416F2 (:%pSubse1i)           ;#00443CDE: 350 0FDAFFFF               v  00 00  1  82      
;  2050 --      {vsb_prev,vsb_next,vsb_magic} = peek8u({ebp_root,3})
;  2051         {vsb_prev,vsb_next,symtabptr,gvarptr,vsb_magic} = peek8u({ebp_root,5})
    lea rax,[rbp-384] (symtab[721])       ;#00443CE3: 48:215205 80FEFFFF         uv 01 20  1  83      
    mov rdx,2                             ;#00443CEA: 48:307302 02000000         vu 04 00  1  83      
    push #00443D27                        ;#00443CF1: 150 273D4400               uv 00 00  1  84      
    push rax                              ;#00443CF6: 120                        vu 00 01  1  84      
    push 5                                ;#00443CF7: 152 05                     uv 00 00  1  85      
    mov rcx,[rbp-248] (ebp_root)          ;#00443CF9: 48:213215 08FFFFFF         vu 02 20  1  85      
    mov r15,h4                            ;#00443D00: 49:277 0000000000000040    uv 8000 00  1  86      
    cmp rcx,r15                           ;#00443D0A: 4C:071371                  uv 00 8002  1  87 8000   
    jl #00443D1A                          ;#00443D0D: 174 0B                     v  00 00  1  87      
    add qword[rbx+rcx*4-16],1             ;#00443D0F: 48:203104213 F0 01         u  00 0A  3  88      
    cmp eax,704                           ;#00443D15: 075 C0020000               vu 00 01  1  90      
    push rcx                              ;#00443D1A: 121                        uv 00 02  1  91      
    mov rdi,[rbp-384] (symtab[721])       ;#00443D1B: 48:213275 80FEFFFF         vu 80 20  1  91      
    jmp #004404BD (:%pMkSq)               ;#00443D22: 351 96C7FFFF               v  00 00  1  92      
    lea rdi,[rbp-392] (symtab[722])       ;#00443D27: 48:215275 78FEFFFF         uv 80 20  1  93      
    mov rsi,[rbp-384] (symtab[721])       ;#00443D2E: 48:213265 80FEFFFF         vu 40 20  1  93      
    xor rcx,rcx                           ;#00443D35: 48:061311                  uv 02 02  1  94      
    mov rdx,8                             ;#00443D38: 48:307302 08000000         vu 04 00  1  94      
    call #0043ED6C (:%opPeekNx)           ;#00443D3F: 350 28B0FFFF               v  00 00  1  95      
    mov rdi,5                             ;#00443D44: 48:307307 05000000         uv 80 00  1  96      
    lea rcx,[rbp-272] (vsb_magic)         ;#00443D4B: 48:215215 F0FEFFFF         vu 02 20  1  96      
    mov rsi,[rbp-392] (symtab[722])       ;#00443D52: 48:213265 78FEFFFF         uv 40 20  1  97      
    mov rdx,722                           ;#00443D59: 48:307302 D2020000         vu 04 00  1  97      
    call #00441675 (:%pSubse1)            ;#00443D60: 350 10D9FFFF               v  00 00  1  98      
    mov rdi,4                             ;#00443D65: 48:307307 04000000         uv 80 00  1  99      
    lea rcx,[rbp-344] (gvarptr)           ;#00443D6C: 48:215215 A8FEFFFF         vu 02 20  1  99      
    mov rsi,[rbp-392] (symtab[722])       ;#00443D73: 48:213265 78FEFFFF         uv 40 20  1 100      
    mov rdx,722                           ;#00443D7A: 48:307302 D2020000         vu 04 00  1 100      
    call #00441675 (:%pSubse1)            ;#00443D81: 350 EFD8FFFF               v  00 00  1 101      
    mov rdi,3                             ;#00443D86: 48:307307 03000000         uv 80 00  1 102      
    lea rcx,[rbp-336] (symtabptr)         ;#00443D8D: 48:215215 B0FEFFFF         vu 02 20  1 102      
    mov rsi,[rbp-392] (symtab[722])       ;#00443D94: 48:213265 78FEFFFF         uv 40 20  1 103      
    mov rdx,722                           ;#00443D9B: 48:307302 D2020000         vu 04 00  1 103      
    call #00441675 (:%pSubse1)            ;#00443DA2: 350 CED8FFFF               v  00 00  1 104      
    mov rdi,2                             ;#00443DA7: 48:307307 02000000         uv 80 00  1 105      
    lea rcx,[rbp-264] (vsb_next)          ;#00443DAE: 48:215215 F8FEFFFF         vu 02 20  1 105      
    mov rsi,[rbp-392] (symtab[722])       ;#00443DB5: 48:213265 78FEFFFF         uv 40 20  1 106      
    mov rdx,722                           ;#00443DBC: 48:307302 D2020000         vu 04 00  1 106      
    call #00441675 (:%pSubse1)            ;#00443DC3: 350 ADD8FFFF               v  00 00  1 107      
    mov rdi,1                             ;#00443DC8: 48:307307 01000000         uv 80 00  1 108      
    lea rcx,[rbp-256] (vsb_prev)          ;#00443DCF: 48:215215 00FFFFFF         vu 02 20  1 108      
    mov rsi,[rbp-392] (symtab[722])       ;#00443DD6: 48:213265 78FEFFFF         uv 40 20  1 109      
    mov rdx,722                           ;#00443DDD: 48:307302 D2020000         vu 04 00  1 109      
    call #00441675 (:%pSubse1)            ;#00443DE4: 350 8CD8FFFF               v  00 00  1 110      
;  2052     end if
;  2053 
;  2054 --  if not batchmode then --DEV
;  2055     if diagdiag>0 or (vsb_magic-#40565342) or msg_id<1 or msg_id>length(msgs) then
;  2056         printf(1,"N=%d, rtn=%d, from=#%s, ret=#%s, prevebp=#%s, ebproot=#%s\n",
;  2057                {N,rtn,addrS(from_addr),addrS(ret_addr),addrS(prev_ebp),addrS(ebp_root)})
    mov rcx,1                             ;#00443DE9: 48:307301 01000000         uv 02 00  1 111      
    mov rdx,668                           ;#00443DF0: 48:307302 9C020000         vu 04 00  1 111      
    call #004428DB (:%opFrame) (addrS)    ;#00443DF7: 350 DFEAFFFF               v  00 00  1 112      
    mov rdi,[rbp+40] (prevebp)            ;#00443DFC: 48:213175 28               uv 80 20  1 113      
    mov rax,[rdi-224]                     ;#00443E00: 48:213207 20FFFFFF         uv 01 80  1 116 80 *80*
    xor rbx,rbx                           ;#00443E07: 48:061333                  vu 08 08  1 116      
    mov r15,h4                            ;#00443E0A: 49:277 0000000000000040    uv 8000 00  1 117      
    cmp rax,r15                           ;#00443E14: 4C:071370                  uv 00 8001  1 118 8000   
    jl #00443E24                          ;#00443E17: 174 0B                     v  00 00  1 118      
    add qword[rbx+rax*4-16],1             ;#00443E19: 48:203104203 F0 01         u  00 09  3 119      
    cmp eax,701                           ;#00443E1F: 075 BD020000               vu 00 01  1 121      
    mov [rbp] (a),rax                     ;#00443E24: 48:211105 00               uv 00 21  1 122      
    mov qword[retaddr],#00443E35          ;#00443E28: 48:307105 20 353E4400      vu 00 20  1 122      
    jmp #004519B7 (code:addrS)            ;#00443E30: 351 82DB0000               v  00 00  1 123      
    push rax                              ;#00443E35: 120                        uv 00 01  1 124      
    mov rcx,[rbp-400] (symtab[725])       ;#00443E36: 48:213215 70FEFFFF         vu 02 20  1 124      
    mov r15,h4                            ;#00443E3D: 49:277 0000000000000040    uv 8000 00  1 125      
    cmp rcx,r15                           ;#00443E47: 4C:071371                  uv 00 8002  1 126 8000   
    jle #00443E5C                         ;#00443E4A: 176 10                     v  00 00  1 126      
    sub qword[rbx+rcx*4-16],1             ;#00443E4C: 48:203154213 F0 01         u  00 0A  3 127      
    jne #00443E5C                         ;#00443E52: 165 08                     v  00 00  1 129      
    mov rdx,rcx                           ;#00443E54: 48:213321                  uv 04 02  1 130      
    call #004422DA (:%pDealloc)           ;#00443E57: 350 7EE4FFFF               v  00 00  1 130      
    pop dword[rbp-400] (symtab[725])      ;#00443E5C: 217205 70FEFFFF            np 00 20  3 131      
    mov rcx,1                             ;#00443E62: 48:307301 01000000         uv 02 00  1 134      
    mov rdx,668                           ;#00443E69: 48:307302 9C020000         vu 04 00  1 134      
    call #004428DB (:%opFrame) (addrS)    ;#00443E70: 350 66EAFFFF               v  00 00  1 135      
    mov rdi,[rbp+40] (prevebp)            ;#00443E75: 48:213175 28               uv 80 20  1 136      
    mov rax,[rdi-232]                     ;#00443E79: 48:213207 18FFFFFF         uv 01 80  1 139 80 *80*
    xor rbx,rbx                           ;#00443E80: 48:061333                  vu 08 08  1 139      
    mov r15,h4                            ;#00443E83: 49:277 0000000000000040    uv 8000 00  1 140      
    cmp rax,r15                           ;#00443E8D: 4C:071370                  uv 00 8001  1 141 8000   
    jl #00443E9D                          ;#00443E90: 174 0B                     v  00 00  1 141      
    add qword[rbx+rax*4-16],1             ;#00443E92: 48:203104203 F0 01         u  00 09  3 142      
    cmp eax,702                           ;#00443E98: 075 BE020000               vu 00 01  1 144      
    mov [rbp] (a),rax                     ;#00443E9D: 48:211105 00               uv 00 21  1 145      
    mov qword[retaddr],#00443EAE          ;#00443EA1: 48:307105 20 AE3E4400      vu 00 20  1 145      
    jmp #004519B7 (code:addrS)            ;#00443EA9: 351 09DB0000               v  00 00  1 146      
    push rax                              ;#00443EAE: 120                        uv 00 01  1 147      
    mov rdi,[rbp-408] (symtab[726])       ;#00443EAF: 48:213275 68FEFFFF         vu 80 20  1 147      
    mov r15,h4                            ;#00443EB6: 49:277 0000000000000040    uv 8000 00  1 148      
    cmp rdi,r15                           ;#00443EC0: 4C:071377                  uv 00 8080  1 149 8000   
    jle #00443ED5                         ;#00443EC3: 176 10                     v  00 00  1 149      
    sub qword[rbx+rdi*4-16],1             ;#00443EC5: 48:203154273 F0 01         u  00 88  3 150      
    jne #00443ED5                         ;#00443ECB: 165 08                     v  00 00  1 152      
    mov rdx,rdi                           ;#00443ECD: 48:213327                  uv 04 80  1 153      
    call #004422DA (:%pDealloc)           ;#00443ED0: 350 05E4FFFF               v  00 00  1 153      
    pop dword[rbp-408] (symtab[726])      ;#00443ED5: 217205 68FEFFFF            np 00 20  3 154      
    mov rcx,1                             ;#00443EDB: 48:307301 01000000         uv 02 00  1 157      
    mov rdx,668                           ;#00443EE2: 48:307302 9C020000         vu 04 00  1 157      
    call #004428DB (:%opFrame) (addrS)    ;#00443EE9: 350 EDE9FFFF               v  00 00  1 158      
    mov rdi,[rbp+40] (prevebp)            ;#00443EEE: 48:213175 28               uv 80 20  1 159      
    mov rax,[rdi-240]                     ;#00443EF2: 48:213207 10FFFFFF         uv 01 80  1 162 80 *80*
    xor rbx,rbx                           ;#00443EF9: 48:061333                  vu 08 08  1 162      
    mov r15,h4                            ;#00443EFC: 49:277 0000000000000040    uv 8000 00  1 163      
    cmp rax,r15                           ;#00443F06: 4C:071370                  uv 00 8001  1 164 8000   
    jl #00443F16                          ;#00443F09: 174 0B                     v  00 00  1 164      
    add qword[rbx+rax*4-16],1             ;#00443F0B: 48:203104203 F0 01         u  00 09  3 165      
    cmp eax,703                           ;#00443F11: 075 BF020000               vu 00 01  1 167      
    mov [rbp] (a),rax                     ;#00443F16: 48:211105 00               uv 00 21  1 168      
    mov qword[retaddr],#00443F27          ;#00443F1A: 48:307105 20 273F4400      vu 00 20  1 168      
    jmp #004519B7 (code:addrS)            ;#00443F22: 351 90DA0000               v  00 00  1 169      
    push rax                              ;#00443F27: 120                        uv 00 01  1 170      
    mov rsi,[rbp-416] (symtab[727])       ;#00443F28: 48:213265 60FEFFFF         vu 40 20  1 170      
    mov r15,h4                            ;#00443F2F: 49:277 0000000000000040    uv 8000 00  1 171      
    cmp rsi,r15                           ;#00443F39: 4C:071376                  uv 00 8040  1 172 8000   
    jle #00443F4E                         ;#00443F3C: 176 10                     v  00 00  1 172      
    sub qword[rbx+rsi*4-16],1             ;#00443F3E: 48:203154263 F0 01         u  00 48  3 173      
    jne #00443F4E                         ;#00443F44: 165 08                     v  00 00  1 175      
    mov rdx,rsi                           ;#00443F46: 48:213326                  uv 04 40  1 176      
    call #004422DA (:%pDealloc)           ;#00443F49: 350 8CE3FFFF               v  00 00  1 176      
    pop dword[rbp-416] (symtab[727])      ;#00443F4E: 217205 60FEFFFF            np 00 20  3 177      
    mov rcx,1                             ;#00443F54: 48:307301 01000000         uv 02 00  1 180      
    mov rdx,668                           ;#00443F5B: 48:307302 9C020000         vu 04 00  1 180      
    call #004428DB (:%opFrame) (addrS)    ;#00443F62: 350 74E9FFFF               v  00 00  1 181      
    mov rdi,[rbp+40] (prevebp)            ;#00443F67: 48:213175 28               uv 80 20  1 182      
    mov rax,[rdi-248]                     ;#00443F6B: 48:213207 08FFFFFF         uv 01 80  1 185 80 *80*
    xor rbx,rbx                           ;#00443F72: 48:061333                  vu 08 08  1 185      
    mov r15,h4                            ;#00443F75: 49:277 0000000000000040    uv 8000 00  1 186      
    cmp rax,r15                           ;#00443F7F: 4C:071370                  uv 00 8001  1 187 8000   
    jl #00443F8F                          ;#00443F82: 174 0B                     v  00 00  1 187      
    add qword[rbx+rax*4-16],1             ;#00443F84: 48:203104203 F0 01         u  00 09  3 188      
    cmp eax,704                           ;#00443F8A: 075 C0020000               vu 00 01  1 190      
    mov [rbp] (a),rax                     ;#00443F8F: 48:211105 00               uv 00 21  1 191      
    mov qword[retaddr],#00443FA0          ;#00443F93: 48:307105 20 A03F4400      vu 00 20  1 191      
    jmp #004519B7 (code:addrS)            ;#00443F9B: 351 17DA0000               v  00 00  1 192      
    push rax                              ;#00443FA0: 120                        uv 00 01  1 193      
    mov rcx,[rbp-424] (symtab[728])       ;#00443FA1: 48:213215 58FEFFFF         vu 02 20  1 193      
    mov r15,h4                            ;#00443FA8: 49:277 0000000000000040    uv 8000 00  1 194      
    cmp rcx,r15                           ;#00443FB2: 4C:071371                  uv 00 8002  1 195 8000   
    jle #00443FC7                         ;#00443FB5: 176 10                     v  00 00  1 195      
    sub qword[rbx+rcx*4-16],1             ;#00443FB7: 48:203154213 F0 01         u  00 0A  3 196      
    jne #00443FC7                         ;#00443FBD: 165 08                     v  00 00  1 198      
    mov rdx,rcx                           ;#00443FBF: 48:213321                  uv 04 02  1 199      
    call #004422DA (:%pDealloc)           ;#00443FC2: 350 13E3FFFF               v  00 00  1 199      
    pop dword[rbp-424] (symtab[728])      ;#00443FC7: 217205 58FEFFFF            np 00 20  3 200      
    mov rdi,[rbp-216] (rtn)               ;#00443FCD: 48:213275 28FFFFFF         uv 80 20  1 203      
    mov r15,h4                            ;#00443FD4: 49:277 0000000000000040    vu 8000 00  1 203      
    cmp rdi,r15                           ;#00443FDE: 4C:071377                  uv 00 8080  1 204      
    jne #00443FEF                         ;#00443FE1: 165 0C                     v  00 00  1 204      
    mov rsi,700                           ;#00443FE3: 48:307306 BC020000         uv 40 00  1 205      
    call #00442D75 (:%pUnassigned)        ;#00443FEA: 350 86EDFFFF               v  00 00  1 205      
    mov rsi,[rbp-208] (N)                 ;#00443FEF: 48:213265 30FFFFFF         uv 40 20  1 206      
    mov r15,h4                            ;#00443FF6: 49:277 0000000000000040    vu 8000 00  1 206      
    cmp rsi,r15                           ;#00444000: 4C:071376                  uv 00 8040  1 207      
    jne #00444011                         ;#00444003: 165 0C                     v  00 00  1 207      
    mov rsi,699                           ;#00444005: 48:307306 BB020000         uv 40 00  1 208      
    call #00442D75 (:%pUnassigned)        ;#0044400C: 350 64EDFFFF               v  00 00  1 208      
    lea rax,[rbp-384] (symtab[721])       ;#00444011: 48:215205 80FEFFFF         uv 01 20  1 209      
    mov rdx,6                             ;#00444018: 48:307302 06000000         vu 04 00  1 209      
    push #00444067                        ;#0044401F: 150 67404400               uv 00 00  1 210      
    push rax                              ;#00444024: 120                        vu 00 01  1 210      
    push qword[rbp-424] (symtab[728])     ;#00444025: 377265 58FEFFFF            np 00 20  2 211      
    mov [rbp-424] (symtab[728]),rbx       ;#0044402B: 48:211235 58FEFFFF         uv 00 28  1 213      
    push qword[rbp-416] (symtab[727])     ;#00444032: 377265 60FEFFFF            np 00 20  2 214      
    mov [rbp-416] (symtab[727]),rbx       ;#00444038: 48:211235 60FEFFFF         uv 00 28  1 216      
    push qword[rbp-408] (symtab[726])     ;#0044403F: 377265 68FEFFFF            np 00 20  2 217      
    mov [rbp-408] (symtab[726]),rbx       ;#00444045: 48:211235 68FEFFFF         uv 00 28  1 219      
    push qword[rbp-400] (symtab[725])     ;#0044404C: 377265 70FEFFFF            np 00 20  2 220      
    mov [rbp-400] (symtab[725]),rbx       ;#00444052: 48:211235 70FEFFFF         uv 00 28  1 222      
    push rdi                              ;#00444059: 127                        vu 00 80  1 222      
    push rsi                              ;#0044405A: 126                        uv 00 40  1 223      
    mov rdi,[rbp-384] (symtab[721])       ;#0044405B: 48:213275 80FEFFFF         vu 80 20  1 223      
    jmp #004404BD (:%pMkSq)               ;#00444062: 351 56C4FFFF               v  00 00  1 224      
    mov rcx,4                             ;#00444067: 48:307301 04000000         uv 02 00  1 225      
    mov rdx,94                            ;#0044406E: 48:307302 5E000000         vu 04 00  1 225      
    call #004428DB (:%opFrame) (printf)   ;#00444075: 350 61E8FFFF               v  00 00  1 226      
    mov qword[rbp] (fn),1                 ;#0044407A: 48:307105 00 01000000      uv 00 20  1 227      
    mov rax,qword[#00402BC8]              ;#00444082: 48:213005 3FEBFBFF         vu 01 00  1 227      
    mov [rbp-8] (format),rax              ;#00444089: 48:211105 F8               uv 00 21  1 228      
    add qword[rbx+rax*4-16],1             ;#0044408D: 48:203104203 F0 01         u  00 09  3 230    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00444093: 48:213175 28               vu 80 20  1 232      
    mov rax,[rdi-384]                     ;#00444097: 48:213207 80FEFFFF         uv 01 80  1 235    *80*
    xor rbx,rbx                           ;#0044409E: 48:061333                  vu 08 08  1 235      
    mov r15,h4                            ;#004440A1: 49:277 0000000000000040    uv 8000 00  1 236      
    cmp rax,r15                           ;#004440AB: 4C:071370                  uv 00 8001  1 237 8000   
    jl #004440BB                          ;#004440AE: 174 0B                     v  00 00  1 237      
    add qword[rbx+rax*4-16],1             ;#004440B0: 48:203104203 F0 01         u  00 09  3 238      
    cmp eax,721                           ;#004440B6: 075 D1020000               vu 00 01  1 240      
    mov [rbp-16] (args),rax               ;#004440BB: 48:211105 F0               uv 00 21  1 241      
    mov qword[retaddr],#004440CC          ;#004440BF: 48:307105 20 CC404400      vu 00 20  1 241      
    jmp #00451A31 (code:printf)           ;#004440C7: 351 65D90000               v  00 00  1 242      
;  2058         printf(1,"or_ecx=#%08x, or_edx=#%08x, or_esi=#%08x, or_edi=#%08x\n",
;  2059                {or_ecx,or_edx,or_esi,or_edi})
    lea rax,[rbp-384] (symtab[721])       ;#004440CC: 48:215205 80FEFFFF         uv 01 20  1 243      
    mov rdx,4                             ;#004440D3: 48:307302 04000000         vu 04 00  1 243      
    push #00444174                        ;#004440DA: 150 74414400               uv 00 00  1 244      
    push rax                              ;#004440DF: 120                        vu 00 01  1 244      
    mov rcx,[#00402B28] (or_edi)          ;#004440E0: 48:213015 41EAFBFF         uv 02 00  1 245      
    mov r15,h4                            ;#004440E7: 49:277 0000000000000040    vu 8000 00  1 245      
    cmp rcx,r15                           ;#004440F1: 4C:071371                  uv 00 8002  1 246      
    jl #00444101                          ;#004440F4: 174 0B                     v  00 00  1 246      
    add qword[rbx+rcx*4-16],1             ;#004440F6: 48:203104213 F0 01         u  00 0A  3 247      
    cmp eax,622                           ;#004440FC: 075 6E020000               vu 00 01  1 249      
    push rcx                              ;#00444101: 121                        uv 00 02  1 250      
    mov rsi,[#00402B20] (or_esi)          ;#00444102: 48:213065 17EAFBFF         vu 40 00  1 250      
    mov r15,h4                            ;#00444109: 49:277 0000000000000040    uv 8000 00  1 251      
    cmp rsi,r15                           ;#00444113: 4C:071376                  uv 00 8040  1 252 8000   
    jl #00444123                          ;#00444116: 174 0B                     v  00 00  1 252      
    add qword[rbx+rsi*4-16],1             ;#00444118: 48:203104263 F0 01         u  00 48  3 253      
    cmp eax,621                           ;#0044411E: 075 6D020000               vu 00 01  1 255      
    push rsi                              ;#00444123: 126                        uv 00 40  1 256      
    mov rdi,[#00402B18] (or_edx)          ;#00444124: 48:213075 EDE9FBFF         vu 80 00  1 256      
    mov r15,h4                            ;#0044412B: 49:277 0000000000000040    uv 8000 00  1 257      
    cmp rdi,r15                           ;#00444135: 4C:071377                  uv 00 8080  1 258 8000   
    jl #00444145                          ;#00444138: 174 0B                     v  00 00  1 258      
    add qword[rbx+rdi*4-16],1             ;#0044413A: 48:203104273 F0 01         u  00 88  3 259      
    cmp eax,620                           ;#00444140: 075 6C020000               vu 00 01  1 261      
    push rdi                              ;#00444145: 127                        uv 00 80  1 262      
    mov rax,[#00402B08] (or_ecx)          ;#00444146: 48:213005 BBE9FBFF         vu 01 00  1 262      
    mov r15,h4                            ;#0044414D: 49:277 0000000000000040    uv 8000 00  1 263      
    cmp rax,r15                           ;#00444157: 4C:071370                  uv 00 8001  1 264 8000   
    jl #00444167                          ;#0044415A: 174 0B                     v  00 00  1 264      
    add qword[rbx+rax*4-16],1             ;#0044415C: 48:203104203 F0 01         u  00 09  3 265      
    cmp eax,618                           ;#00444162: 075 6A020000               vu 00 01  1 267      
    push rax                              ;#00444167: 120                        uv 00 01  1 268      
    mov rdi,[rbp-384] (symtab[721])       ;#00444168: 48:213275 80FEFFFF         vu 80 20  1 268      
    jmp #004404BD (:%pMkSq)               ;#0044416F: 351 49C3FFFF               v  00 00  1 269      
    mov rcx,4                             ;#00444174: 48:307301 04000000         uv 02 00  1 270      
    mov rdx,94                            ;#0044417B: 48:307302 5E000000         vu 04 00  1 270      
    call #004428DB (:%opFrame) (printf)   ;#00444182: 350 54E7FFFF               v  00 00  1 271      
    mov qword[rbp] (fn),1                 ;#00444187: 48:307105 00 01000000      uv 00 20  1 272      
    mov rcx,qword[#00402BD0]              ;#0044418F: 48:213015 3AEAFBFF         vu 02 00  1 272      
    mov [rbp-8] (format),rcx              ;#00444196: 48:211115 F8               uv 00 22  1 273      
    add qword[rbx+rcx*4-16],1             ;#0044419A: 48:203104213 F0 01         u  00 0A  3 275    *02*
    mov rdi,[rbp+40] (prevebp)            ;#004441A0: 48:213175 28               vu 80 20  1 277      
    mov rax,[rdi-384]                     ;#004441A4: 48:213207 80FEFFFF         uv 01 80  1 280    *80*
    xor rbx,rbx                           ;#004441AB: 48:061333                  vu 08 08  1 280      
    mov r15,h4                            ;#004441AE: 49:277 0000000000000040    uv 8000 00  1 281      
    cmp rax,r15                           ;#004441B8: 4C:071370                  uv 00 8001  1 282 8000   
    jl #004441C8                          ;#004441BB: 174 0B                     v  00 00  1 282      
    add qword[rbx+rax*4-16],1             ;#004441BD: 48:203104203 F0 01         u  00 09  3 283      
    cmp eax,721                           ;#004441C3: 075 D1020000               vu 00 01  1 285      
    mov [rbp-16] (args),rax               ;#004441C8: 48:211105 F0               uv 00 21  1 286      
    mov qword[retaddr],#004441D9          ;#004441CC: 48:307105 20 D9414400      vu 00 20  1 286      
    jmp #00451A31 (code:printf)           ;#004441D4: 351 58D80000               v  00 00  1 287      
;  2060         magicok = "\"@VSB\""
    mov rsi,qword[#00402BD8]              ;#004441D9: 48:213065 F8E9FBFF         uv 40 00  1 288      
    mov [rbp-280] (magicok),rsi           ;#004441E0: 48:211265 E8FEFFFF         uv 00 60  1 289 40   
    add qword[rbx+rsi*4-16],1             ;#004441E7: 48:203104263 F0 01         u  00 48  3 291    *40*
;  2061 --DEV wrong on machine_bits()=64... (possibly one for docs)
;  2062 --      if vsb_magic!=#40565342 then
;  2063         if (vsb_magic-#40565342) then
    mov rdi,[rbp-272] (vsb_magic)         ;#004441ED: 48:213275 F0FEFFFF         vu 80 20  1 293      
    mov r15,h4                            ;#004441F4: 49:277 0000000000000040    uv 8000 00  1 294      
    cmp rdi,r15                           ;#004441FE: 4C:071377                  uv 00 8080  1 295 8000   
    jne #0044420F                         ;#00444201: 165 0C                     v  00 00  1 295      
    mov rsi,707                           ;#00444203: 48:307306 C3020000         uv 40 00  1 296      
    call #00442D75 (:%pUnassigned)        ;#0044420A: 350 66EBFFFF               v  00 00  1 296      
    lea rdi,[rbp-376] (symtab[720])       ;#0044420F: 48:215275 88FEFFFF         uv 80 20  1 297      
    mov rcx,[rbp-272] (vsb_magic)         ;#00444216: 48:213215 F0FEFFFF         vu 02 20  1 297      
    mov rax,qword[#00402BC0]              ;#0044421D: 48:213005 9CE9FBFF         uv 01 00  1 298      
    call #0043F4D8 (:%opSub)              ;#00444224: 350 AFB2FFFF               v  00 00  1 298      
    mov rsi,[rbp-376] (symtab[720])       ;#00444229: 48:213265 88FEFFFF         uv 40 20  1 299      
    test rsi,rsi                          ;#00444230: 48:205366                  uv 00 40  1 300 40   
    je #0044427B                          ;#00444233: 164 46                     v  00 00  1 300      
;  2064             magicok = "**BAD MAGIC**"
    mov rdi,qword[#00402BE0]              ;#00444235: 48:213075 A4E9FBFF         uv 80 00  1 301      
    mov rdx,[rbp-280] (magicok)           ;#0044423C: 48:213225 E8FEFFFF         vu 04 20  1 301      
    mov r15,h4                            ;#00444243: 49:277 0000000000000040    uv 8000 00  1 302      
    cmp rdi,r15                           ;#0044424D: 4C:071377                  uv 00 8080  1 303 8000   
    jl #00444258                          ;#00444250: 174 06                     v  00 00  1 303      
    add qword[rbx+rdi*4-16],1             ;#00444252: 48:203104273 F0 01         u  00 88  3 304      
    mov [rbp-280] (magicok),rdi           ;#00444258: 48:211275 E8FEFFFF         vu 00 A0  1 306      
    mov r15,h4                            ;#0044425F: 49:277 0000000000000040    uv 8000 00  1 307      
    cmp rdx,r15                           ;#00444269: 4C:071372                  uv 00 8004  1 308 8000   
    jle #0044427B                         ;#0044426C: 176 0D                     v  00 00  1 308      
    sub qword[rbx+rdx*4-16],1             ;#0044426E: 48:203154223 F0 01         u  00 0C  3 309      
    jne #0044427B                         ;#00444274: 165 05                     v  00 00  1 311      
    call #004422DA (:%pDealloc)           ;#00444276: 350 5FE0FFFF               v  00 00  1 312      
;  2065         end if
;  2066         printf(1,"vsb_prev=#%s, vsb_next=#%s, vsb_magic=%s (%s)\n",
;  2067                {addrS(vsb_prev),addrS(vsb_next),addrS(vsb_magic),magicok})
    mov rcx,1                             ;#0044427B: 48:307301 01000000         uv 02 00  1 313      
    mov rdx,668                           ;#00444282: 48:307302 9C020000         vu 04 00  1 313      
    call #004428DB (:%opFrame) (addrS)    ;#00444289: 350 4DE6FFFF               v  00 00  1 314      
    mov rdi,[rbp+40] (prevebp)            ;#0044428E: 48:213175 28               uv 80 20  1 315      
    mov rax,[rdi-256]                     ;#00444292: 48:213207 00FFFFFF         uv 01 80  1 318 80 *80*
    xor rbx,rbx                           ;#00444299: 48:061333                  vu 08 08  1 318      
    mov r15,h4                            ;#0044429C: 49:277 0000000000000040    uv 8000 00  1 319      
    cmp rax,r15                           ;#004442A6: 4C:071370                  uv 00 8001  1 320 8000   
    jl #004442B6                          ;#004442A9: 174 0B                     v  00 00  1 320      
    add qword[rbx+rax*4-16],1             ;#004442AB: 48:203104203 F0 01         u  00 09  3 321      
    cmp eax,705                           ;#004442B1: 075 C1020000               vu 00 01  1 323      
    mov [rbp] (a),rax                     ;#004442B6: 48:211105 00               uv 00 21  1 324      
    mov qword[retaddr],#004442C7          ;#004442BA: 48:307105 20 C7424400      vu 00 20  1 324      
    jmp #004519B7 (code:addrS)            ;#004442C2: 351 F0D60000               v  00 00  1 325      
    push rax                              ;#004442C7: 120                        uv 00 01  1 326      
    mov rcx,[rbp-400] (symtab[725])       ;#004442C8: 48:213215 70FEFFFF         vu 02 20  1 326      
    mov r15,h4                            ;#004442CF: 49:277 0000000000000040    uv 8000 00  1 327      
    cmp rcx,r15                           ;#004442D9: 4C:071371                  uv 00 8002  1 328 8000   
    jle #004442EE                         ;#004442DC: 176 10                     v  00 00  1 328      
    sub qword[rbx+rcx*4-16],1             ;#004442DE: 48:203154213 F0 01         u  00 0A  3 329      
    jne #004442EE                         ;#004442E4: 165 08                     v  00 00  1 331      
    mov rdx,rcx                           ;#004442E6: 48:213321                  uv 04 02  1 332      
    call #004422DA (:%pDealloc)           ;#004442E9: 350 ECDFFFFF               v  00 00  1 332      
    pop dword[rbp-400] (symtab[725])      ;#004442EE: 217205 70FEFFFF            np 00 20  3 333      
    mov rcx,1                             ;#004442F4: 48:307301 01000000         uv 02 00  1 336      
    mov rdx,668                           ;#004442FB: 48:307302 9C020000         vu 04 00  1 336      
    call #004428DB (:%opFrame) (addrS)    ;#00444302: 350 D4E5FFFF               v  00 00  1 337      
    mov rdi,[rbp+40] (prevebp)            ;#00444307: 48:213175 28               uv 80 20  1 338      
    mov rax,[rdi-264]                     ;#0044430B: 48:213207 F8FEFFFF         uv 01 80  1 341 80 *80*
    xor rbx,rbx                           ;#00444312: 48:061333                  vu 08 08  1 341      
    mov r15,h4                            ;#00444315: 49:277 0000000000000040    uv 8000 00  1 342      
    cmp rax,r15                           ;#0044431F: 4C:071370                  uv 00 8001  1 343 8000   
    jl #0044432F                          ;#00444322: 174 0B                     v  00 00  1 343      
    add qword[rbx+rax*4-16],1             ;#00444324: 48:203104203 F0 01         u  00 09  3 344      
    cmp eax,706                           ;#0044432A: 075 C2020000               vu 00 01  1 346      
    mov [rbp] (a),rax                     ;#0044432F: 48:211105 00               uv 00 21  1 347      
    mov qword[retaddr],#00444340          ;#00444333: 48:307105 20 40434400      vu 00 20  1 347      
    jmp #004519B7 (code:addrS)            ;#0044433B: 351 77D60000               v  00 00  1 348      
    push rax                              ;#00444340: 120                        uv 00 01  1 349      
    mov rsi,[rbp-408] (symtab[726])       ;#00444341: 48:213265 68FEFFFF         vu 40 20  1 349      
    mov r15,h4                            ;#00444348: 49:277 0000000000000040    uv 8000 00  1 350      
    cmp rsi,r15                           ;#00444352: 4C:071376                  uv 00 8040  1 351 8000   
    jle #00444367                         ;#00444355: 176 10                     v  00 00  1 351      
    sub qword[rbx+rsi*4-16],1             ;#00444357: 48:203154263 F0 01         u  00 48  3 352      
    jne #00444367                         ;#0044435D: 165 08                     v  00 00  1 354      
    mov rdx,rsi                           ;#0044435F: 48:213326                  uv 04 40  1 355      
    call #004422DA (:%pDealloc)           ;#00444362: 350 73DFFFFF               v  00 00  1 355      
    pop dword[rbp-408] (symtab[726])      ;#00444367: 217205 68FEFFFF            np 00 20  3 356      
    mov rcx,1                             ;#0044436D: 48:307301 01000000         uv 02 00  1 359      
    mov rdx,668                           ;#00444374: 48:307302 9C020000         vu 04 00  1 359      
    call #004428DB (:%opFrame) (addrS)    ;#0044437B: 350 5BE5FFFF               v  00 00  1 360      
    mov rdi,[rbp+40] (prevebp)            ;#00444380: 48:213175 28               uv 80 20  1 361      
    mov rax,[rdi-272]                     ;#00444384: 48:213207 F0FEFFFF         uv 01 80  1 364 80 *80*
    xor rbx,rbx                           ;#0044438B: 48:061333                  vu 08 08  1 364      
    mov r15,h4                            ;#0044438E: 49:277 0000000000000040    uv 8000 00  1 365      
    cmp rax,r15                           ;#00444398: 4C:071370                  uv 00 8001  1 366 8000   
    jl #004443A8                          ;#0044439B: 174 0B                     v  00 00  1 366      
    add qword[rbx+rax*4-16],1             ;#0044439D: 48:203104203 F0 01         u  00 09  3 367      
    cmp eax,707                           ;#004443A3: 075 C3020000               vu 00 01  1 369      
    mov [rbp] (a),rax                     ;#004443A8: 48:211105 00               uv 00 21  1 370      
    mov qword[retaddr],#004443B9          ;#004443AC: 48:307105 20 B9434400      vu 00 20  1 370      
    jmp #004519B7 (code:addrS)            ;#004443B4: 351 FED50000               v  00 00  1 371      
    push rax                              ;#004443B9: 120                        uv 00 01  1 372      
    mov rdi,[rbp-416] (symtab[727])       ;#004443BA: 48:213275 60FEFFFF         vu 80 20  1 372      
    mov r15,h4                            ;#004443C1: 49:277 0000000000000040    uv 8000 00  1 373      
    cmp rdi,r15                           ;#004443CB: 4C:071377                  uv 00 8080  1 374 8000   
    jle #004443E0                         ;#004443CE: 176 10                     v  00 00  1 374      
    sub qword[rbx+rdi*4-16],1             ;#004443D0: 48:203154273 F0 01         u  00 88  3 375      
    jne #004443E0                         ;#004443D6: 165 08                     v  00 00  1 377      
    mov rdx,rdi                           ;#004443D8: 48:213327                  uv 04 80  1 378      
    call #004422DA (:%pDealloc)           ;#004443DB: 350 FADEFFFF               v  00 00  1 378      
    pop dword[rbp-416] (symtab[727])      ;#004443E0: 217205 60FEFFFF            np 00 20  3 379      
    lea rax,[rbp-384] (symtab[721])       ;#004443E6: 48:215205 80FEFFFF         uv 01 20  1 382      
    mov rdx,4                             ;#004443ED: 48:307302 04000000         vu 04 00  1 382      
    push #0044444F                        ;#004443F4: 150 4F444400               uv 00 00  1 383      
    push rax                              ;#004443F9: 120                        vu 00 01  1 383      
    mov rcx,[rbp-280] (magicok)           ;#004443FA: 48:213215 E8FEFFFF         uv 02 20  1 384      
    mov r15,h4                            ;#00444401: 49:277 0000000000000040    vu 8000 00  1 384      
    cmp rcx,r15                           ;#0044440B: 4C:071371                  uv 00 8002  1 385      
    jl #0044441B                          ;#0044440E: 174 0B                     v  00 00  1 385      
    add qword[rbx+rcx*4-16],1             ;#00444410: 48:203104213 F0 01         u  00 0A  3 386      
    cmp eax,708                           ;#00444416: 075 C4020000               vu 00 01  1 388      
    push rcx                              ;#0044441B: 121                        uv 00 02  1 389      
    push qword[rbp-416] (symtab[727])     ;#0044441C: 377265 60FEFFFF            np 00 20  2 390      
    mov [rbp-416] (symtab[727]),rbx       ;#00444422: 48:211235 60FEFFFF         uv 00 28  1 392      
    push qword[rbp-408] (symtab[726])     ;#00444429: 377265 68FEFFFF            np 00 20  2 393      
    mov [rbp-408] (symtab[726]),rbx       ;#0044442F: 48:211235 68FEFFFF         uv 00 28  1 395      
    push qword[rbp-400] (symtab[725])     ;#00444436: 377265 70FEFFFF            np 00 20  2 396      
    mov [rbp-400] (symtab[725]),rbx       ;#0044443C: 48:211235 70FEFFFF         uv 00 28  1 398      
    mov rdi,[rbp-384] (symtab[721])       ;#00444443: 48:213275 80FEFFFF         vu 80 20  1 398      
    jmp #004404BD (:%pMkSq)               ;#0044444A: 351 6EC0FFFF               v  00 00  1 399      
    mov rcx,4                             ;#0044444F: 48:307301 04000000         uv 02 00  1 400      
    mov rdx,94                            ;#00444456: 48:307302 5E000000         vu 04 00  1 400      
    call #004428DB (:%opFrame) (printf)   ;#0044445D: 350 79E4FFFF               v  00 00  1 401      
    mov qword[rbp] (fn),1                 ;#00444462: 48:307105 00 01000000      uv 00 20  1 402      
    mov rsi,qword[#00402BE8]              ;#0044446A: 48:213065 77E7FBFF         vu 40 00  1 402      
    mov [rbp-8] (format),rsi              ;#00444471: 48:211165 F8               uv 00 60  1 403      
    add qword[rbx+rsi*4-16],1             ;#00444475: 48:203104263 F0 01         u  00 48  3 405    *40*
    mov rdi,[rbp+40] (prevebp)            ;#0044447B: 48:213175 28               vu 80 20  1 407      
    mov rax,[rdi-384]                     ;#0044447F: 48:213207 80FEFFFF         uv 01 80  1 410    *80*
    xor rbx,rbx                           ;#00444486: 48:061333                  vu 08 08  1 410      
    mov r15,h4                            ;#00444489: 49:277 0000000000000040    uv 8000 00  1 411      
    cmp rax,r15                           ;#00444493: 4C:071370                  uv 00 8001  1 412 8000   
    jl #004444A3                          ;#00444496: 174 0B                     v  00 00  1 412      
    add qword[rbx+rax*4-16],1             ;#00444498: 48:203104203 F0 01         u  00 09  3 413      
    cmp eax,721                           ;#0044449E: 075 D1020000               vu 00 01  1 415      
    mov [rbp-16] (args),rax               ;#004444A3: 48:211105 F0               uv 00 21  1 416      
    mov qword[retaddr],#004444B4          ;#004444A7: 48:307105 20 B4444400      vu 00 20  1 416      
    jmp #00451A31 (code:printf)           ;#004444AF: 351 7DD50000               v  00 00  1 417      
;  2068 --  end if
;  2069 --
;  2070 --  if not batchmode then
;  2071 --      if msg_id<1 or msg_id>length(msgs) then
;  2072 --          msg = "**BAD MESSAGE ID**"
;  2073 --      else
;  2074 --          msg = msgs[msg_id][1..-2] -- (strip trailing \n)
;  2075 --      end if
;  2076 --      printf(1,"\ndiag(%d[%s]) called...\n",{msg_id,msg})
;  2077 --      lines += 1
;  2078 --end if
;  2079     end if
;  2080 --puts(1,"d2a\n")
;  2081     abortcode = 1
    mov qword[rbp-288] (abortcode),1      ;#004444B4: 48:307205 E0FEFFFF 01000000 uv 00 20  1 418      
;  2082     if string(crash_msg) then
    mov rcx,[#00402670] (crash_msg)       ;#004444BF: 48:213015 AAE1FBFF         vu 02 00  1 418      
    mov r15,h4                            ;#004444C6: 49:277 0000000000000040    uv 8000 00  1 419      
    cmp rcx,r15                           ;#004444D0: 4C:071371                  uv 00 8002  1 420 8000   
    jl #004444EB                          ;#004444D3: 174 16                     v  00 00  1 420      
    cmp byte[rbx+rcx*4-1],#82             ;#004444D5: 200174213 FF 82            u  00 0A  2 421      
    jne #004444EB                         ;#004444DA: 165 0F                     v  00 00  1 422      
;  2083         msg = crash_msg
    mov [rbp-120] (msg),rcx               ;#004444DC: 48:211115 88               uv 00 22  1 423      
    add qword[rbx+rcx*4-16],1             ;#004444E0: 48:203104213 F0 01         u  00 0A  3 424      
    jmp #00444588                         ;#004444E6: 351 9D000000               v  00 00  1 426      
;  2084     elsif msg_id<1 or msg_id>length(msgs) then
    mov rdi,[#00402BA8] (msg_id)          ;#004444EB: 48:213075 B6E6FBFF         uv 80 00  1 427      
    cmp rdi,1                             ;#004444F2: 48:203377 01               uv 00 80  1 428 80   
    jl #004444FE                          ;#004444F6: 174 06                     v  00 00  1 428      
    cmp rdi,122                           ;#004444F8: 48:203377 7A               uv 00 80  1 429      
    jle #00444563                         ;#004444FC: 176 65                     v  00 00  1 429      
;  2085         msg = sprintf("diag(%d) [**BAD MESSAGE ID**] called\n",msg_id)
    mov rcx,33                            ;#004444FE: 48:307301 21000000         uv 02 00  1 430      
    mov rdx,89                            ;#00444505: 48:307302 59000000         vu 04 00  1 430      
    call #004428DB (:%opFrame) (sprintf)  ;#0044450C: 350 CAE3FFFF               v  00 00  1 431      
    mov rsi,qword[#00402BF0]              ;#00444511: 48:213065 D8E6FBFF         uv 40 00  1 432      
    mov [rbp] (format),rsi                ;#00444518: 48:211165 00               uv 00 60  1 433 40   
    add qword[rbx+rsi*4-16],1             ;#0044451C: 48:203104263 F0 01         u  00 48  3 435    *40*
    mov rax,[#00402BA8] (msg_id)          ;#00444522: 48:213005 7FE6FBFF         vu 01 00  1 437      
    mov [rbp-8] (args),rax                ;#00444529: 48:211105 F8               uv 00 21  1 438      
    mov qword[retaddr],#0044453A          ;#0044452D: 48:307105 20 3A454400      vu 00 20  1 438      
    jmp #0044E450 (code:sprintf)          ;#00444535: 351 169F0000               v  00 00  1 439      
    push rax                              ;#0044453A: 120                        uv 00 01  1 440      
    mov rcx,[rbp-120] (msg)               ;#0044453B: 48:213115 88               vu 02 20  1 440      
    mov r15,h4                            ;#0044453F: 49:277 0000000000000040    uv 8000 00  1 441      
    cmp rcx,r15                           ;#00444549: 4C:071371                  uv 00 8002  1 442 8000   
    jle #0044455E                         ;#0044454C: 176 10                     v  00 00  1 442      
    sub qword[rbx+rcx*4-16],1             ;#0044454E: 48:203154213 F0 01         u  00 0A  3 443      
    jne #0044455E                         ;#00444554: 165 08                     v  00 00  1 445      
    mov rdx,rcx                           ;#00444556: 48:213321                  uv 04 02  1 446      
    call #004422DA (:%pDealloc)           ;#00444559: 350 7CDDFFFF               v  00 00  1 446      
    pop dword[rbp-120] (msg)              ;#0044455E: 217105 88                  np 00 20  3 447      
;  2086 --      msg_id = 1 --DEV abortcode
;  2087 --      abortcode = 1
    jmp #00444588                         ;#00444561: 353 25                     v  00 00  1 450      
;  2088     else
;  2089         msg = msgs[msg_id]
    lea rcx,[rbp-120] (msg)               ;#00444563: 48:215115 88               uv 02 20  1 451      
    mov rsi,[#00402A20] (msgs)            ;#00444567: 48:213065 B2E4FBFF         vu 40 00  1 451      
    mov rdx,589                           ;#0044456E: 48:307302 4D020000         uv 04 00  1 452      
    call #00441675 (:%pSubse1)            ;#00444575: 350 FBD0FFFF               v  00 00  1 452      
;  2090         abortcode = msg_id
    mov rax,[#00402BA8] (msg_id)          ;#0044457A: 48:213005 27E6FBFF         uv 01 00  1 453      
    mov [rbp-288] (abortcode),rax         ;#00444581: 48:211205 E0FEFFFF         uv 00 21  1 454 01   
;  2091     end if
;  2092 
;  2093 --puts(1,"d2b\n")
;  2094     --
;  2095     -- NB. symtab may contain uninitialised fields (especially S_value). [DEV]
;  2096     --
;  2097     --    Attempts to modify symtab, which now has a reference count of 2,
;  2098     --    will attempt a clone operation and may therefore crash, as well
;  2099     --    as being about as likely to succeed as changing the brake pads,
;  2100     --    clutch, gearbox, tyres, steering wheel, and engine oil, all at 
;  2101     --    the same time, on a juggernaut careering out of control down 
;  2102     --    a steep mountain road.
;  2103     --
;  2104     --    Likewise attempts to (eg) print symtab may also crash.
;  2105     --
;  2106     --    Lastly, note that \constants\ are not necessarily initialised yet, 
;  2107     --    not just the obvious main=create(Window...) but also name="name",
;  2108     --    though literal integer constants (eg DEBUG=1) should be fine.
;  2109     --
;  2110 --puts(1,"d2c\n")
;  2111 --if atom(symtab) then return 0 end if  --DEV??!
;  2112 --  s8 = symtab[T_callstk]  -- {ep1,ep2,era,etd,ern,or_ebp*4,?vsb_used?,dcount}
;  2113     --
;  2114     -- NB. s8 is "volatile". Hopefully this is of no concern to you, but in 
;  2115     -- order to avoid allocating space on the heap (which may be full), or 
;  2116     -- messing with bytesallocated/freed counts, opGetST uses a rather dim
;  2117     -- ref-count-agnostic-hack when it updates symtab[T_callstk]. If opGetST 
;  2118     -- is invoked again (eg it is used in both routine_id and command_line) 
;  2119     -- then this s8, or more specifically any float elements extracted from 
;  2120     -- this s8, may also get modified (from afar). An atom z z=s8[5] is not
;  2121     -- necessarily safe from a following opGetST either. Of course if you 
;  2122     -- create eg a string version of s8, or z, then that won't change.
;  2123     --
;  2124     -- ep1 and ep2 are error code specific, for example e09slin is
;  2125     --  "slice length is negative [%d..%d]\n" and ep1/2 are those idx.
;  2126     -- era is a return addr, possibly adjusted to pick up a var address,
;  2127     --  which can be converted to a line number via routineno/linetab.
;  2128     -- etd is a raw pointer to the threadstack static ref bank.
;  2129     --  Note this is non-subscriptable and may contain unassigned items.
;  2130     -- ern is a routine no/index into symtab, eg 21 for main file code.
;  2131     -- or_ebp is a raw pointer to frame in the callstack (see function retD)
;  2132 --DEV currently not reported!
;  2133     -- dcount is the number of dropped callstack blocks. If the program
;  2134     --  runs out of memory all but the first and last two callstack 
;  2135     --  blocks are freed, which will hopefully release enough memory
;  2136     --  for this routine to complete successfully. This program should 
;  2137     --  also limit the entries printed to keep ex.err reasonably sized.
;  2138     --
;  2139 --puts(1,"d2d\n")
;  2140 --/*
;  2141 --  if not batchmode then
;  2142 --      puts(1,"{ep1,ep2,era,etd,ern,or_ebp*4,???,dcount}:\n")
;  2143 --      printf(1,"s8=#%08x,#%08x,#%08x,#%08x,%d,#%08x,%d,%d\n",s8) lines += 2
;  2144 --  end if
;  2145     --?8
;  2146     ep1 = s8[1]             -- error parameter 1
;  2147     ep2 = s8[2]             -- error parameter 2
;  2148     era = s8[3]             -- return addr (adjusted to be within code emitted for line)
;  2149     etd = s8[4]             -- threadstack ptr
;  2150     rtn = s8[5]             -- active routine number
;  2151     or_ebp*4 = s8[6]            -- frame ptr (at point of failure)
;  2152 --vsb_used [DEV]
;  2153     dcount = s8[8]          -- dropped callstack blocks
;  2154 --?9
;  2155     if not batchmode then
;  2156         ppOpt({pp_Ascii,{' ',#7E},pp_Nest,1})
;  2157     end if
;  2158 --  ppOpt({pp_Pause,10})
;  2159 --ppOpt({pp_Pause,0})
;  2160 
;  2161 --puts(1,"d3\n")
;  2162 --?10
;  2163 --*/
;  2164     --
;  2165     -- First create a vmap to allow gvar idx/addr to be mapped to symtab
;  2166     --
;  2167     if vmax=0 then
    mov rcx,[#00402B38] (vmax)            ;#00444588: 48:213015 A9E5FBFF         vu 02 00  1 454      
    cmp rcx,0                             ;#0044458F: 48:203371 00               uv 00 02  1 455      
    jne #00444762                         ;#00444593: 017205 C9010000            v  00 00  1 455      
;  2168         vmap = {}
    mov rdi,qword[#004022C8]              ;#00444599: 48:213075 28DDFBFF         uv 80 00  1 456      
    mov rdx,[#00402B40] (vmap)            ;#004445A0: 48:213025 99E5FBFF         vu 04 00  1 456      
    mov r15,h4                            ;#004445A7: 49:277 0000000000000040    uv 8000 00  1 457      
    cmp rdi,r15                           ;#004445B1: 4C:071377                  uv 00 8080  1 458 8000   
    jl #004445BC                          ;#004445B4: 174 06                     v  00 00  1 458      
    add qword[rbx+rdi*4-16],1             ;#004445B6: 48:203104273 F0 01         u  00 88  3 459      
    mov [#00402B40] (vmap),rdi            ;#004445BC: 48:211075 7DE5FBFF         vu 00 80  1 461      
    mov r15,h4                            ;#004445C3: 49:277 0000000000000040    uv 8000 00  1 462      
    cmp rdx,r15                           ;#004445CD: 4C:071372                  uv 00 8004  1 463 8000   
    jle #004445DF                         ;#004445D0: 176 0D                     v  00 00  1 463      
    sub qword[rbx+rdx*4-16],1             ;#004445D2: 48:203154223 F0 01         u  00 0C  3 464      
    jne #004445DF                         ;#004445D8: 165 05                     v  00 00  1 466      
    call #004422DA (:%pDealloc)           ;#004445DA: 350 FBDCFFFF               v  00 00  1 467      
;  2169         for i=length(symtab) to T_maintls by -1 do
    lea rdi,[rbp-360] (symtab[718])       ;#004445DF: 48:215275 98FEFFFF         uv 80 20  1 468      
    mov rsi,[rbp] (symtab)                ;#004445E6: 48:213165 00               vu 40 20  1 468      
    mov rdx,673                           ;#004445EA: 48:307302 A1020000         uv 04 00  1 469      
    call #0043F28D (:%opLen)              ;#004445F1: 350 97ACFFFF               v  00 00  1 469      
    mov [rbp-432] (i),rcx                 ;#004445F6: 48:211215 50FEFFFF         uv 00 22  1 470      
    cmp rcx,21                            ;#004445FD: 48:201371 15000000         vu 00 02  1 470      
    jl #00444762                          ;#00444604: 017214 58010000            v  00 00  1 471      
;  2170             si = symtab[i]
    mov rax,[rbp] (symtab)                ;#0044460A: 48:213105 00               uv 01 20  1 472      
    mov r15,h4                            ;#0044460E: 49:277 0000000000000040    vu 8000 00  1 472      
    cmp rax,r15                           ;#00444618: 4C:071370                  uv 00 8001  1 473      
    jne #00444629                         ;#0044461B: 165 0C                     v  00 00  1 473      
    mov rsi,673                           ;#0044461D: 48:307306 A1020000         uv 40 00  1 474      
    call #00442D75 (:%pUnassigned)        ;#00444624: 350 4CE7FFFF               v  00 00  1 474      
    mov rdi,[rbp-432] (i)                 ;#00444629: 48:213275 50FEFFFF         uv 80 20  1 475      
    lea rcx,[rbp-8] (si)                  ;#00444630: 48:215115 F8               vu 02 20  1 475      
    mov rsi,rax                           ;#00444634: 48:211306                  uv 40 01  1 476      
    mov rdx,673                           ;#00444637: 48:307302 A1020000         vu 04 00  1 476      
    call #00441675 (:%pSubse1)            ;#0044463E: 350 32D0FFFF               v  00 00  1 477      
;  2171             if sequence(si)
    mov rsi,[rbp-8] (si)                  ;#00444643: 48:213165 F8               uv 40 20  1 478      
    mov r15,h4                            ;#00444647: 49:277 0000000000000040    vu 8000 00  1 478      
    cmp rsi,r15                           ;#00444651: 4C:071376                  uv 00 8040  1 479      
    jl #00444740                          ;#00444654: 017214 E6000000            v  00 00  1 479      
    test byte[rbx+rsi*4-1],#80            ;#0044465A: 366104263 FF 80            u  00 48  2 480      
    je #00444740                          ;#0044465F: 017204 DB000000            v  00 00  1 481      
;  2172             and si[S_NTyp]<=S_GVar2 then
    mov rdi,2                             ;#00444665: 48:307307 02000000         uv 80 00  1 482      
    lea rcx,[rbp-440] (symtab[735])       ;#0044466C: 48:215215 48FEFFFF         vu 02 20  1 482      
    mov rdx,674                           ;#00444673: 48:307302 A2020000         uv 04 00  1 483      
    call #00441675 (:%pSubse1)            ;#0044467A: 350 F6CFFFFF               v  00 00  1 483      
    mov rdi,2                             ;#0044467F: 48:307307 02000000         uv 80 00  1 484      
    mov rax,[rbp-440] (symtab[735])       ;#00444686: 48:213205 48FEFFFF         vu 01 20  1 484      
    mov rsi,604                           ;#0044468D: 48:307306 5C020000         uv 40 00  1 485      
    mov rdx,735                           ;#00444694: 48:307302 DF020000         vu 04 00  1 485      
    call #0043FA81 (:%opJcc)              ;#0044469B: 350 E1B3FFFF               v  00 00  1 486      
    jg #00444740                          ;#004446A0: 017217 9A000000            v  00 00  1 487      
;  2173                 c = si[S_Slink]
    mov rdi,6                             ;#004446A6: 48:307307 06000000         uv 80 00  1 488      
    lea rcx,[rbp-104] (c)                 ;#004446AD: 48:215115 98               vu 02 20  1 488      
    mov rsi,[rbp-8] (si)                  ;#004446B1: 48:213165 F8               uv 40 20  1 489      
    mov rdx,674                           ;#004446B5: 48:307302 A2020000         vu 04 00  1 489      
    call #004416F2 (:%pSubse1i)           ;#004446BC: 350 31D0FFFF               v  00 00  1 490      
;  2174                 if c>vmax then
    mov rcx,[#00402B38] (vmax)            ;#004446C1: 48:213015 70E4FBFF         uv 02 00  1 491      
    cmp rax,rcx                           ;#004446C8: 48:071310                  uv 00 03  1 492 02   
    jle #00444722                         ;#004446CB: 176 55                     v  00 00  1 492      
;  2175                     vmap &= repeat(0,c-vmax)
    lea rdi,[rbp-376] (symtab[720])       ;#004446CD: 48:215275 88FEFFFF         uv 80 20  1 493      
    mov rcx,rax                           ;#004446D4: 48:211301                  vu 02 01  1 493      
    mov rax,[#00402B38] (vmax)            ;#004446D7: 48:213005 5AE4FBFF         uv 01 00  1 494      
    call #0043F4D8 (:%opSub)              ;#004446DE: 350 F5ADFFFF               v  00 00  1 494      
    lea rdi,[rbp-448] (symtab[736])       ;#004446E3: 48:215275 40FEFFFF         uv 80 20  1 495      
    mov rax,0                             ;#004446EA: 48:307300 00000000         vu 01 00  1 495      
    mov rcx,[rbp-376] (symtab[720])       ;#004446F1: 48:213215 88FEFFFF         uv 02 20  1 496      
    call #0043B1F3 (:%opRepeat)           ;#004446F8: 350 F66AFFFF               v  00 00  1 496      
    lea rdx,[#00402B40] (vmap)            ;#004446FD: 48:215025 3CE4FBFF         uv 04 00  1 497      
    lea rdi,[#00402B40] (vmap)            ;#00444704: 48:215075 35E4FBFF         vu 80 00  1 497      
    lea rcx,[rbp-448] (symtab[736])       ;#0044470B: 48:215215 40FEFFFF         uv 02 20  1 498      
    call #00440021 (:%opConcat)           ;#00444712: 350 0AB9FFFF               v  00 00  1 498      
;  2176                     vmax = c
    mov rdi,[rbp-104] (c)                 ;#00444717: 48:213175 98               uv 80 20  1 499      
    mov [#00402B38] (vmax),rdi            ;#0044471B: 48:211075 16E4FBFF         uv 00 80  1 500 80   
;  2177                 end if
;  2178                 vmap[c] = i
    mov rdi,[rbp-104] (c)                 ;#00444722: 48:213175 98               vu 80 20  1 500      
    mov rcx,[rbp-432] (i)                 ;#00444726: 48:213215 50FEFFFF         uv 02 20  1 501      
    mov rsi,[#00402B40] (vmap)            ;#0044472D: 48:213065 0CE4FBFF         vu 40 00  1 501      
    lea rax,[#00402B40] (vmap)            ;#00444734: 48:215005 05E4FBFF         uv 01 00  1 502      
    call #00440E37 (:%pRepe1ip)           ;#0044473B: 350 F7C6FFFF               v  00 00  1 502      
;  2179             end if
;  2180         end for
    mov rax,[rbp-432] (i)                 ;#00444740: 48:213205 50FEFFFF         uv 01 20  1 503      
    mov rdx,21                            ;#00444747: 48:307302 15000000         vu 04 00  1 503      
    add rax,-1                            ;#0044474E: 48:203300 FF               uv 01 01  1 504      
    cmp rax,rdx                           ;#00444752: 48:073302                  uv 00 05  1 505 01   
    mov [rbp-432] (i),rax                 ;#00444755: 48:211205 50FEFFFF         vu 00 21  1 505      
    jge #0044460A                         ;#0044475C: 017215 A8FEFFFF            v  00 00  1 506      
;  2181     end if
;  2182     --
;  2183     -- initialise pathset [DEV do we want this/call current_dir&'\\' just the once?] [seems ok like this...]
;  2184     --
;  2185     pathset = symtab[T_pathset]
    mov rdi,[rbp] (symtab)                ;#00444762: 48:213175 00               uv 80 20  1 507      
    mov r15,h4                            ;#00444766: 49:277 0000000000000040    vu 8000 00  1 507      
    cmp rdi,r15                           ;#00444770: 4C:071377                  uv 00 8080  1 508      
    jne #00444781                         ;#00444773: 165 0C                     v  00 00  1 508      
    mov rsi,673                           ;#00444775: 48:307306 A1020000         uv 40 00  1 509      
    call #00442D75 (:%pUnassigned)        ;#0044477C: 350 F4E5FFFF               v  00 00  1 509      
    mov rdi,16                            ;#00444781: 48:307307 10000000         uv 80 00  1 510      
    lea rcx,[rbp-160] (pathset)           ;#00444788: 48:215215 60FFFFFF         vu 02 20  1 510      
    mov rsi,[rbp] (symtab)                ;#0044478F: 48:213165 00               uv 40 20  1 511      
    mov rdx,673                           ;#00444793: 48:307302 A1020000         vu 04 00  1 511      
    call #00441675 (:%pSubse1)            ;#0044479A: 350 D6CEFFFF               v  00 00  1 512      
;  2186 --  for j=1 to length(pathset) do
;  2187 --      if length(pathset[j])<2 or pathset[j][2]!=':' then
;  2188 --          pathset[j] = current_dir()&'\\'&pathset[j]
;  2189 --      end if
;  2190 --  end for
;  2191     if msg_id=106 then      -- e106ioob(edi,edx) or e94vhnbaav(ecx)
    mov rcx,[#00402BA8] (msg_id)          ;#0044479F: 48:213015 02E4FBFF         uv 02 00  1 513      
    cmp rcx,106                           ;#004447A6: 48:203371 6A               uv 00 02  1 514 02   
    jne #00444952                         ;#004447AA: 017205 A2010000            v  00 00  1 514      
;  2192         if find(or_edi,{#40000000,#4000000000000000}) then
    mov rcx,7                             ;#004447B0: 48:307301 07000000         uv 02 00  1 515      
    mov rdx,75                            ;#004447B7: 48:307302 4B000000         vu 04 00  1 515      
    call #004428DB (:%opFrame) (find)     ;#004447BE: 350 18E1FFFF               v  00 00  1 516      
    mov rax,[#00402B28] (or_edi)          ;#004447C3: 48:213005 5EE3FBFF         uv 01 00  1 517      
    mov [rbp] (x),rax                     ;#004447CA: 48:211105 00               uv 00 21  1 518 01   
    mov r15,h4                            ;#004447CE: 49:277 0000000000000040    vu 8000 00  1 518      
    cmp rax,r15                           ;#004447D8: 4C:071370                  uv 00 8001  1 519      
    jl #004447E8                          ;#004447DB: 174 0B                     v  00 00  1 519      
    add qword[rbx+rax*4-16],1             ;#004447DD: 48:203104203 F0 01         u  00 09  3 520      
    cmp eax,622                           ;#004447E3: 075 6E020000               vu 00 01  1 522      
    mov rdi,qword[#00402C10]              ;#004447E8: 48:213075 21E4FBFF         uv 80 00  1 523      
    mov [rbp-8] (s),rdi                   ;#004447EF: 48:211175 F8               uv 00 A0  1 524 80   
    add qword[rbx+rdi*4-16],1             ;#004447F3: 48:203104273 F0 01         u  00 88  3 526    *80*
    mov qword[retaddr],#00444806          ;#004447F9: 48:307105 20 06484400      vu 00 20  1 528      
    jmp #0043DAD6 (code:find)             ;#00444801: 351 D092FFFF               v  00 00  1 529      
    test rax,rax                          ;#00444806: 48:205300                  uv 00 01  1 530      
    je #00444866                          ;#00444809: 164 5B                     v  00 00  1 530      
;  2193 --          or_edx = or_ecx
;  2194             or_esi = or_ecx
    mov rsi,[#00402B08] (or_ecx)          ;#0044480B: 48:213065 F6E2FBFF         uv 40 00  1 531      
    mov rdx,[#00402B20] (or_esi)          ;#00444812: 48:213025 07E3FBFF         vu 04 00  1 531      
    mov r15,h4                            ;#00444819: 49:277 0000000000000040    uv 8000 00  1 532      
    cmp rsi,r15                           ;#00444823: 4C:071376                  uv 00 8040  1 533 8000   
    jl #00444833                          ;#00444826: 174 0B                     v  00 00  1 533      
    add qword[rbx+rsi*4-16],1             ;#00444828: 48:203104263 F0 01         u  00 48  3 534      
    cmp eax,618                           ;#0044482E: 075 6A020000               vu 00 01  1 536      
    mov [#00402B20] (or_esi),rsi          ;#00444833: 48:211065 E6E2FBFF         uv 00 40  1 537      
    mov r15,h4                            ;#0044483A: 49:277 0000000000000040    vu 8000 00  1 537      
    cmp rdx,r15                           ;#00444844: 4C:071372                  uv 00 8004  1 538      
    jle #00444856                         ;#00444847: 176 0D                     v  00 00  1 538      
    sub qword[rbx+rdx*4-16],1             ;#00444849: 48:203154223 F0 01         u  00 0C  3 539      
    jne #00444856                         ;#0044484F: 165 05                     v  00 00  1 541      
    call #004422DA (:%pDealloc)           ;#00444851: 350 84DAFFFF               v  00 00  1 542      
;  2195             msg_id = 92
    mov qword[#00402BA8] (msg_id),92      ;#00444856: 48:307005 47E3FBFF 5C000000 uv 00 00  1 543      
    jmp #00444D04                         ;#00444861: 351 9E040000               v  00 00  1 543      
;  2196         else
;  2197 --          msg = sprintf(msg,{or_edi,or_edx})
;  2198             msg = sprintf(msg,{or_edi,or_esi})
    lea rax,[rbp-384] (symtab[721])       ;#00444866: 48:215205 80FEFFFF         uv 01 20  1 544      
    mov rdx,2                             ;#0044486D: 48:307302 02000000         vu 04 00  1 544      
    push #004448CA                        ;#00444874: 150 CA484400               uv 00 00  1 545      
    push rax                              ;#00444879: 120                        vu 00 01  1 545      
    mov rcx,[#00402B20] (or_esi)          ;#0044487A: 48:213015 9FE2FBFF         uv 02 00  1 546      
    mov r15,h4                            ;#00444881: 49:277 0000000000000040    vu 8000 00  1 546      
    cmp rcx,r15                           ;#0044488B: 4C:071371                  uv 00 8002  1 547      
    jl #0044489B                          ;#0044488E: 174 0B                     v  00 00  1 547      
    add qword[rbx+rcx*4-16],1             ;#00444890: 48:203104213 F0 01         u  00 0A  3 548      
    cmp eax,621                           ;#00444896: 075 6D020000               vu 00 01  1 550      
    push rcx                              ;#0044489B: 121                        uv 00 02  1 551      
    mov rax,[#00402B28] (or_edi)          ;#0044489C: 48:213005 85E2FBFF         vu 01 00  1 551      
    mov r15,h4                            ;#004448A3: 49:277 0000000000000040    uv 8000 00  1 552      
    cmp rax,r15                           ;#004448AD: 4C:071370                  uv 00 8001  1 553 8000   
    jl #004448BD                          ;#004448B0: 174 0B                     v  00 00  1 553      
    add qword[rbx+rax*4-16],1             ;#004448B2: 48:203104203 F0 01         u  00 09  3 554      
    cmp eax,622                           ;#004448B8: 075 6E020000               vu 00 01  1 556      
    push rax                              ;#004448BD: 120                        uv 00 01  1 557      
    mov rdi,[rbp-384] (symtab[721])       ;#004448BE: 48:213275 80FEFFFF         vu 80 20  1 557      
    jmp #004404BD (:%pMkSq)               ;#004448C5: 351 F3BBFFFF               v  00 00  1 558      
    mov rcx,33                            ;#004448CA: 48:307301 21000000         uv 02 00  1 559      
    mov rdx,89                            ;#004448D1: 48:307302 59000000         vu 04 00  1 559      
    call #004428DB (:%opFrame) (sprintf)  ;#004448D8: 350 FEDFFFFF               v  00 00  1 560      
    mov rdi,[rbp+40] (prevebp)            ;#004448DD: 48:213175 28               uv 80 20  1 561      
    mov rax,[rdi-120]                     ;#004448E1: 48:213107 88               uv 01 80  1 564 80 *80*
    mov [rdi-120],r15                     ;#004448E5: 4C:211177 88               vu 00 8080  1 564      
    mov [rbp] (format),rax                ;#004448E9: 48:211105 00               uv 00 21  1 565      
    mov rdi,[rbp+40] (prevebp)            ;#004448ED: 48:213175 28               vu 80 20  1 565      
    mov rax,[rdi-384]                     ;#004448F1: 48:213207 80FEFFFF         uv 01 80  1 568    *80*
    xor rbx,rbx                           ;#004448F8: 48:061333                  vu 08 08  1 568      
    mov r15,h4                            ;#004448FB: 49:277 0000000000000040    uv 8000 00  1 569      
    cmp rax,r15                           ;#00444905: 4C:071370                  uv 00 8001  1 570 8000   
    jl #00444915                          ;#00444908: 174 0B                     v  00 00  1 570      
    add qword[rbx+rax*4-16],1             ;#0044490A: 48:203104203 F0 01         u  00 09  3 571      
    cmp eax,721                           ;#00444910: 075 D1020000               vu 00 01  1 573      
    mov [rbp-8] (args),rax                ;#00444915: 48:211105 F8               uv 00 21  1 574      
    mov qword[retaddr],#00444926          ;#00444919: 48:307105 20 26494400      vu 00 20  1 574      
    jmp #0044E450 (code:sprintf)          ;#00444921: 351 2A9B0000               v  00 00  1 575      
    push rax                              ;#00444926: 120                        uv 00 01  1 576      
    mov rsi,[rbp-120] (msg)               ;#00444927: 48:213165 88               vu 40 20  1 576      
    mov r15,h4                            ;#0044492B: 49:277 0000000000000040    uv 8000 00  1 577      
    cmp rsi,r15                           ;#00444935: 4C:071376                  uv 00 8040  1 578 8000   
    jle #0044494A                         ;#00444938: 176 10                     v  00 00  1 578      
    sub qword[rbx+rsi*4-16],1             ;#0044493A: 48:203154263 F0 01         u  00 48  3 579      
    jne #0044494A                         ;#00444940: 165 08                     v  00 00  1 581      
    mov rdx,rsi                           ;#00444942: 48:213326                  uv 04 40  1 582      
    call #004422DA (:%pDealloc)           ;#00444945: 350 90D9FFFF               v  00 00  1 582      
    pop dword[rbp-120] (msg)              ;#0044494A: 217105 88                  np 00 20  3 583      
;  2199         end if
    jmp #00444D04                         ;#0044494D: 351 B2030000               v  00 00  1 586      
;  2200     elsif msg_id=30 then    -- e30ume
    cmp rcx,30                            ;#00444952: 48:203371 1E               uv 00 02  1 587      
    jne #00444D04                         ;#00444956: 017205 A8030000            v  00 00  1 587      
;  2201         -- Map any machine exceptions that occur on add1 (refcount) 
;  2202         --  followed by a "helper" cmp eax,<varno>; ==> to e92:
;  2203         if machine_bits()=32 then
;  2204             x6 = peek({or_era,6})
;  2205     --      --  inc dword[ebx+src*4-8]      377104 2s3 F8
;  2206             --  add dword[ebx+src*4-8],1    203104 2s3 F8 01
;  2207             if x6[1]=0o203
;  2208             and x6[2]=0o104
;  2209             and and_bits(x6[3],0o307)=0o203         -- sib(maybe!) of 0o2s3,
;  2210             and x6[4]=#F8                           -- displacement is -8
;  2211             and x6[5]=#01 then                      -- literal imm8 of 1
;  2212     --DEV 64-bit
;  2213                 if x6[6]=cmp_eax_imm32 then
;  2214                     or_esi = peek4u(or_era+6)
;  2215                     msg_id = 92
;  2216                     msg = msgs[92]
;  2217                 end if
;  2218             end if
;  2219         else
;  2220 --  add qword[rbx+rcx*4-16],1             ;#0042D0E9: 48:203104213 F0 01         u  00 0A  3   6      
;  2221 --  cmp eax,662                           ;#0042D0EF: 075 96020000               vu 00 01  1   8      
;  2222             x6 = peek({or_era,7})
    lea rax,[rbp-384] (symtab[721])       ;#0044495C: 48:215205 80FEFFFF         uv 01 20  1 588      
    mov rdx,2                             ;#00444963: 48:307302 02000000         vu 04 00  1 588      
    push #004449A0                        ;#0044496A: 150 A0494400               uv 00 00  1 589      
    push rax                              ;#0044496F: 120                        vu 00 01  1 589      
    push 7                                ;#00444970: 152 07                     uv 00 00  1 590      
    mov rdi,[#00402B10] (or_era)          ;#00444972: 48:213075 97E1FBFF         vu 80 00  1 590      
    mov r15,h4                            ;#00444979: 49:277 0000000000000040    uv 8000 00  1 591      
    cmp rdi,r15                           ;#00444983: 4C:071377                  uv 00 8080  1 592 8000   
    jl #00444993                          ;#00444986: 174 0B                     v  00 00  1 592      
    add qword[rbx+rdi*4-16],1             ;#00444988: 48:203104273 F0 01         u  00 88  3 593      
    cmp eax,619                           ;#0044498E: 075 6B020000               vu 00 01  1 595      
    push rdi                              ;#00444993: 127                        uv 00 80  1 596      
    mov rdi,[rbp-384] (symtab[721])       ;#00444994: 48:213275 80FEFFFF         vu 80 20  1 596      
    jmp #004404BD (:%pMkSq)               ;#0044499B: 351 1DBBFFFF               v  00 00  1 597      
    lea rdi,[rbp-168] (x6)                ;#004449A0: 48:215275 58FFFFFF         uv 80 20  1 598      
    mov rsi,[rbp-384] (symtab[721])       ;#004449A7: 48:213265 80FEFFFF         vu 40 20  1 598      
    xor rcx,rcx                           ;#004449AE: 48:061311                  uv 02 02  1 599      
    mov rdx,1                             ;#004449B1: 48:307302 01000000         vu 04 00  1 599      
    call #0043ED6C (:%opPeekNx)           ;#004449B8: 350 AFA3FFFF               v  00 00  1 600      
;  2223             if x6[1]=#48
    mov rdi,1                             ;#004449BD: 48:307307 01000000         uv 80 00  1 601      
    lea rcx,[rbp-440] (symtab[735])       ;#004449C4: 48:215215 48FEFFFF         vu 02 20  1 601      
    mov rsi,[rbp-168] (x6)                ;#004449CB: 48:213265 58FFFFFF         uv 40 20  1 602      
    mov rdx,694                           ;#004449D2: 48:307302 B6020000         vu 04 00  1 602      
    call #00441675 (:%pSubse1)            ;#004449D9: 350 97CCFFFF               v  00 00  1 603      
    mov rax,[rbp-440] (symtab[735])       ;#004449DE: 48:213205 48FEFFFF         uv 01 20  1 604      
    cmp rax,72                            ;#004449E5: 48:203370 48               uv 00 01  1 605 01   
    jne #00444BB5                         ;#004449E9: 017205 C6010000            v  00 00  1 605      
;  2224             and x6[2]=0o203
    mov rdi,2                             ;#004449EF: 48:307307 02000000         uv 80 00  1 606      
    lea rcx,[rbp-440] (symtab[735])       ;#004449F6: 48:215215 48FEFFFF         vu 02 20  1 606      
    mov rsi,[rbp-168] (x6)                ;#004449FD: 48:213265 58FFFFFF         uv 40 20  1 607      
    mov rdx,694                           ;#00444A04: 48:307302 B6020000         vu 04 00  1 607      
    call #00441675 (:%pSubse1)            ;#00444A0B: 350 65CCFFFF               v  00 00  1 608      
    mov rcx,[rbp-440] (symtab[735])       ;#00444A10: 48:213215 48FEFFFF         uv 02 20  1 609      
    cmp rcx,131                           ;#00444A17: 48:201371 83000000         uv 00 02  1 610 02   
    jne #00444BB5                         ;#00444A1E: 017205 91010000            v  00 00  1 610      
;  2225             and x6[3]=0o104
    mov rdi,3                             ;#00444A24: 48:307307 03000000         uv 80 00  1 611      
    lea rcx,[rbp-440] (symtab[735])       ;#00444A2B: 48:215215 48FEFFFF         vu 02 20  1 611      
    mov rsi,[rbp-168] (x6)                ;#00444A32: 48:213265 58FFFFFF         uv 40 20  1 612      
    mov rdx,694                           ;#00444A39: 48:307302 B6020000         vu 04 00  1 612      
    call #00441675 (:%pSubse1)            ;#00444A40: 350 30CCFFFF               v  00 00  1 613      
    mov rdi,[rbp-440] (symtab[735])       ;#00444A45: 48:213275 48FEFFFF         uv 80 20  1 614      
    cmp rdi,68                            ;#00444A4C: 48:203377 44               uv 00 80  1 615 80   
    jne #00444BB5                         ;#00444A50: 017205 5F010000            v  00 00  1 615      
;  2226             and and_bits(x6[4],0o307)=0o203         -- sib(maybe!) of 0o2s3,
    mov rdi,4                             ;#00444A56: 48:307307 04000000         uv 80 00  1 616      
    lea rcx,[rbp-440] (symtab[735])       ;#00444A5D: 48:215215 48FEFFFF         vu 02 20  1 616      
    mov rsi,[rbp-168] (x6)                ;#00444A64: 48:213265 58FFFFFF         uv 40 20  1 617      
    mov rdx,694                           ;#00444A6B: 48:307302 B6020000         vu 04 00  1 617      
    call #00441675 (:%pSubse1)            ;#00444A72: 350 FECBFFFF               v  00 00  1 618      
    lea rdi,[rbp-456] (symtab[746])       ;#00444A77: 48:215275 38FEFFFF         uv 80 20  1 619      
    mov rcx,[rbp-440] (symtab[735])       ;#00444A7E: 48:213215 48FEFFFF         vu 02 20  1 619      
    mov rax,qword[#00402C38]              ;#00444A85: 48:213005 ACE1FBFF         uv 01 00  1 620      
    call #0043F6C1 (:%opAndBits)          ;#00444A8C: 350 30ACFFFF               v  00 00  1 620      
    mov rdi,[rbp-456] (symtab[746])       ;#00444A91: 48:213275 38FEFFFF         uv 80 20  1 621      
    cmp rdi,131                           ;#00444A98: 48:201377 83000000         uv 00 80  1 622 80   
    jne #00444BB5                         ;#00444A9F: 017205 10010000            v  00 00  1 622      
;  2227             and x6[5]=#F0                           -- displacement is -16
    mov rdi,5                             ;#00444AA5: 48:307307 05000000         uv 80 00  1 623      
    lea rcx,[rbp-440] (symtab[735])       ;#00444AAC: 48:215215 48FEFFFF         vu 02 20  1 623      
    mov rsi,[rbp-168] (x6)                ;#00444AB3: 48:213265 58FFFFFF         uv 40 20  1 624      
    mov rdx,694                           ;#00444ABA: 48:307302 B6020000         vu 04 00  1 624      
    call #00441675 (:%pSubse1)            ;#00444AC1: 350 AFCBFFFF               v  00 00  1 625      
    mov rcx,[rbp-440] (symtab[735])       ;#00444AC6: 48:213215 48FEFFFF         uv 02 20  1 626      
    cmp rcx,240                           ;#00444ACD: 48:201371 F0000000         uv 00 02  1 627 02   
    jne #00444BB5                         ;#00444AD4: 017205 DB000000            v  00 00  1 627      
;  2228             and x6[6]=#01 then                      -- literal imm8 of 1
    mov rdi,6                             ;#00444ADA: 48:307307 06000000         uv 80 00  1 628      
    lea rcx,[rbp-440] (symtab[735])       ;#00444AE1: 48:215215 48FEFFFF         vu 02 20  1 628      
    mov rsi,[rbp-168] (x6)                ;#00444AE8: 48:213265 58FFFFFF         uv 40 20  1 629      
    mov rdx,694                           ;#00444AEF: 48:307302 B6020000         vu 04 00  1 629      
    call #00441675 (:%pSubse1)            ;#00444AF6: 350 7ACBFFFF               v  00 00  1 630      
    mov rax,[rbp-440] (symtab[735])       ;#00444AFB: 48:213205 48FEFFFF         uv 01 20  1 631      
    cmp rax,1                             ;#00444B02: 48:203370 01               uv 00 01  1 632 01   
    jne #00444BB5                         ;#00444B06: 017205 A9000000            v  00 00  1 632      
;  2229                 if x6[7]=cmp_eax_imm32 then
    mov rdi,7                             ;#00444B0C: 48:307307 07000000         uv 80 00  1 633      
    lea rcx,[rbp-440] (symtab[735])       ;#00444B13: 48:215215 48FEFFFF         vu 02 20  1 633      
    mov rsi,[rbp-168] (x6)                ;#00444B1A: 48:213265 58FFFFFF         uv 40 20  1 634      
    mov rdx,694                           ;#00444B21: 48:307302 B6020000         vu 04 00  1 634      
    call #00441675 (:%pSubse1)            ;#00444B28: 350 48CBFFFF               v  00 00  1 635      
    mov rdi,[rbp-440] (symtab[735])       ;#00444B2D: 48:213275 48FEFFFF         uv 80 20  1 636      
    cmp rdi,61                            ;#00444B34: 48:203377 3D               uv 00 80  1 637 80   
    jne #00444BB5                         ;#00444B38: 165 7B                     v  00 00  1 637      
;  2230                     or_esi = peek4u(or_era+7)
    mov rcx,[#00402B10] (or_era)          ;#00444B3A: 48:213015 CFDFFBFF         uv 02 00  1 638      
    mov r15,h4                            ;#00444B41: 49:277 0000000000000040    vu 8000 00  1 638      
    cmp rcx,r15                           ;#00444B4B: 4C:071371                  uv 00 8002  1 639      
    jne #00444B5C                         ;#00444B4E: 165 0C                     v  00 00  1 639      
    mov rsi,619                           ;#00444B50: 48:307306 6B020000         uv 40 00  1 640      
    call #00442D75 (:%pUnassigned)        ;#00444B57: 350 19E2FFFF               v  00 00  1 640      
    lea rdi,[rbp-376] (symtab[720])       ;#00444B5C: 48:215275 88FEFFFF         uv 80 20  1 641      
    mov rax,[#004020C0] (D_HOUR)          ;#00444B63: 48:213005 56D5FBFF         vu 01 00  1 641      
    call #0043F4AF (:%opAdd)              ;#00444B6A: 350 40A9FFFF               v  00 00  1 642      
    lea rdi,[#00402B20] (or_esi)          ;#00444B6F: 48:215075 AADFFBFF         uv 80 00  1 643      
    mov rsi,[rbp-376] (symtab[720])       ;#00444B76: 48:213265 88FEFFFF         vu 40 20  1 643      
    xor rcx,rcx                           ;#00444B7D: 48:061311                  uv 02 02  1 644      
    mov rdx,4                             ;#00444B80: 48:307302 04000000         vu 04 00  1 644      
    call #0043ED6C (:%opPeekNx)           ;#00444B87: 350 E0A1FFFF               v  00 00  1 645      
;  2231                     msg_id = 92
    mov qword[#00402BA8] (msg_id),92      ;#00444B8C: 48:307005 11E0FBFF 5C000000 uv 00 00  1 646      
;  2232                     msg = msgs[92]
    mov rdi,92                            ;#00444B97: 48:307307 5C000000         vu 80 00  1 646      
    lea rcx,[rbp-120] (msg)               ;#00444B9E: 48:215115 88               uv 02 20  1 647      
    mov rsi,[#00402A20] (msgs)            ;#00444BA2: 48:213065 77DEFBFF         vu 40 00  1 647      
    mov rdx,589                           ;#00444BA9: 48:307302 4D020000         uv 04 00  1 648      
    call #00441675 (:%pSubse1)            ;#00444BB0: 350 C0CAFFFF               v  00 00  1 648      
;  2233                 end if
;  2234             end if
;  2235         end if
;  2236         if msg_id=30 then
    mov rdi,[#00402BA8] (msg_id)          ;#00444BB5: 48:213075 ECDFFBFF         uv 80 00  1 649      
    cmp rdi,30                            ;#00444BBC: 48:203377 1E               uv 00 80  1 650 80   
    jne #00444D04                         ;#00444BC0: 017205 3E010000            v  00 00  1 650      
;  2237 --          if xceptn=#C0000005-#100000000 then
;  2238 --              wmsg = "[MEMORY VIOLATION]"
;  2239 --          elsif xceptn=#C00000FD-#100000000 then
;  2240 --              wmsg = "[STACK OVERFLOW]"
;  2241 --          else
;  2242                 wmsg = sprintf("#%08x",xceptn)
    mov rcx,33                            ;#00444BC6: 48:307301 21000000         uv 02 00  1 651      
    mov rdx,89                            ;#00444BCD: 48:307302 59000000         vu 04 00  1 651      
    call #004428DB (:%opFrame) (sprintf)  ;#00444BD4: 350 02DDFFFF               v  00 00  1 652      
    mov rcx,qword[#00402C48]              ;#00444BD9: 48:213015 68E0FBFF         uv 02 00  1 653      
    mov [rbp] (format),rcx                ;#00444BE0: 48:211115 00               uv 00 22  1 654 02   
    add qword[rbx+rcx*4-16],1             ;#00444BE4: 48:203104213 F0 01         u  00 0A  3 656    *02*
    mov rax,[#00402AF8] (xceptn)          ;#00444BEA: 48:213005 07DFFBFF         vu 01 00  1 658      
    mov [rbp-8] (args),rax                ;#00444BF1: 48:211105 F8               uv 00 21  1 659      
    mov r15,h4                            ;#00444BF5: 49:277 0000000000000040    vu 8000 00  1 659      
    cmp rax,r15                           ;#00444BFF: 4C:071370                  uv 00 8001  1 660      
    jl #00444C0F                          ;#00444C02: 174 0B                     v  00 00  1 660      
    add qword[rbx+rax*4-16],1             ;#00444C04: 48:203104203 F0 01         u  00 09  3 661      
    cmp eax,616                           ;#00444C0A: 075 68020000               vu 00 01  1 663      
    mov qword[retaddr],#00444C1C          ;#00444C0F: 48:307105 20 1C4C4400      uv 00 20  1 664      
    jmp #0044E450 (code:sprintf)          ;#00444C17: 351 34980000               v  00 00  1 664      
    mov [rbp-128] (wmsg),rax              ;#00444C1C: 48:211105 80               uv 00 21  1 665      
;  2243 --          end if
;  2244             msg = sprintf(msg,{wmsg,xcepta})
    lea rax,[rbp-384] (symtab[721])       ;#00444C20: 48:215205 80FEFFFF         vu 01 20  1 665      
    mov rdx,2                             ;#00444C27: 48:307302 02000000         uv 04 00  1 666      
    push #00444C81                        ;#00444C2E: 150 814C4400               vu 00 00  1 666      
    push rax                              ;#00444C33: 120                        uv 00 01  1 667      
    mov rsi,[#00402B00] (xcepta)          ;#00444C34: 48:213065 C5DEFBFF         vu 40 00  1 667      
    mov r15,h4                            ;#00444C3B: 49:277 0000000000000040    uv 8000 00  1 668      
    cmp rsi,r15                           ;#00444C45: 4C:071376                  uv 00 8040  1 669 8000   
    jl #00444C55                          ;#00444C48: 174 0B                     v  00 00  1 669      
    add qword[rbx+rsi*4-16],1             ;#00444C4A: 48:203104263 F0 01         u  00 48  3 670      
    cmp eax,617                           ;#00444C50: 075 69020000               vu 00 01  1 672      
    push rsi                              ;#00444C55: 126                        uv 00 40  1 673      
    mov rdi,[rbp-128] (wmsg)              ;#00444C56: 48:213175 80               vu 80 20  1 673      
    mov r15,h4                            ;#00444C5A: 49:277 0000000000000040    uv 8000 00  1 674      
    cmp rdi,r15                           ;#00444C64: 4C:071377                  uv 00 8080  1 675 8000   
    jl #00444C74                          ;#00444C67: 174 0B                     v  00 00  1 675      
    add qword[rbx+rdi*4-16],1             ;#00444C69: 48:203104273 F0 01         u  00 88  3 676      
    cmp eax,689                           ;#00444C6F: 075 B1020000               vu 00 01  1 678      
    push rdi                              ;#00444C74: 127                        uv 00 80  1 679      
    mov rdi,[rbp-384] (symtab[721])       ;#00444C75: 48:213275 80FEFFFF         vu 80 20  1 679      
    jmp #004404BD (:%pMkSq)               ;#00444C7C: 351 3CB8FFFF               v  00 00  1 680      
    mov rcx,33                            ;#00444C81: 48:307301 21000000         uv 02 00  1 681      
    mov rdx,89                            ;#00444C88: 48:307302 59000000         vu 04 00  1 681      
    call #004428DB (:%opFrame) (sprintf)  ;#00444C8F: 350 47DCFFFF               v  00 00  1 682      
    mov rdi,[rbp+40] (prevebp)            ;#00444C94: 48:213175 28               uv 80 20  1 683      
    mov rax,[rdi-120]                     ;#00444C98: 48:213107 88               uv 01 80  1 686 80 *80*
    mov [rdi-120],r15                     ;#00444C9C: 4C:211177 88               vu 00 8080  1 686      
    mov [rbp] (format),rax                ;#00444CA0: 48:211105 00               uv 00 21  1 687      
    mov rdi,[rbp+40] (prevebp)            ;#00444CA4: 48:213175 28               vu 80 20  1 687      
    mov rax,[rdi-384]                     ;#00444CA8: 48:213207 80FEFFFF         uv 01 80  1 690    *80*
    xor rbx,rbx                           ;#00444CAF: 48:061333                  vu 08 08  1 690      
    mov r15,h4                            ;#00444CB2: 49:277 0000000000000040    uv 8000 00  1 691      
    cmp rax,r15                           ;#00444CBC: 4C:071370                  uv 00 8001  1 692 8000   
    jl #00444CCC                          ;#00444CBF: 174 0B                     v  00 00  1 692      
    add qword[rbx+rax*4-16],1             ;#00444CC1: 48:203104203 F0 01         u  00 09  3 693      
    cmp eax,721                           ;#00444CC7: 075 D1020000               vu 00 01  1 695      
    mov [rbp-8] (args),rax                ;#00444CCC: 48:211105 F8               uv 00 21  1 696      
    mov qword[retaddr],#00444CDD          ;#00444CD0: 48:307105 20 DD4C4400      vu 00 20  1 696      
    jmp #0044E450 (code:sprintf)          ;#00444CD8: 351 73970000               v  00 00  1 697      
    push rax                              ;#00444CDD: 120                        uv 00 01  1 698      
    mov rcx,[rbp-120] (msg)               ;#00444CDE: 48:213115 88               vu 02 20  1 698      
    mov r15,h4                            ;#00444CE2: 49:277 0000000000000040    uv 8000 00  1 699      
    cmp rcx,r15                           ;#00444CEC: 4C:071371                  uv 00 8002  1 700 8000   
    jle #00444D01                         ;#00444CEF: 176 10                     v  00 00  1 700      
    sub qword[rbx+rcx*4-16],1             ;#00444CF1: 48:203154213 F0 01         u  00 0A  3 701      
    jne #00444D01                         ;#00444CF7: 165 08                     v  00 00  1 703      
    mov rdx,rcx                           ;#00444CF9: 48:213321                  uv 04 02  1 704      
    call #004422DA (:%pDealloc)           ;#00444CFC: 350 D9D5FFFF               v  00 00  1 704      
    pop dword[rbp-120] (msg)              ;#00444D01: 217105 88                  np 00 20  3 705      
;  2245         end if
;  2246     end if
;  2247 --?msg_id
;  2248     if msg_id=1             -- e01tcf(ecx)  -- (ecx is var no)
    mov rsi,[#00402BA8] (msg_id)          ;#00444D04: 48:213065 9DDEFBFF         uv 40 00  1 708      
    cmp rsi,1                             ;#00444D0B: 48:203376 01               uv 00 40  1 709 40   
    jl #00446CC1                          ;#00444D0F: 017214 AC1F0000            v  00 00  1 709      
    cmp rsi,120                           ;#00444D15: 48:203376 78               uv 00 40  1 710      
    jg #00446CC1                          ;#00444D19: 017217 A21F0000            v  00 00  1 710      
    jmp [esi*8+#00444D1E]                 ;#00444D1F: 377044365 1E4D4400         np 00 40  2 711      
    #00000000004450E6 [1]                 ;#00444D26:  E650440000000000          
    #0000000000446CC1 [2]                 ;#00444D2E:  C16C440000000000          
    #0000000000446CC1 [3]                 ;#00444D36:  C16C440000000000          
    #0000000000446CC1 [4]                 ;#00444D3E:  C16C440000000000          
    #0000000000446CC1 [5]                 ;#00444D46:  C16C440000000000          
    #0000000000446CC1 [6]                 ;#00444D4E:  C16C440000000000          
    #0000000000446CC1 [7]                 ;#00444D56:  C16C440000000000          
    #0000000000446CC1 [8]                 ;#00444D5E:  C16C440000000000          
    #0000000000446947 [9]                 ;#00444D66:  4769440000000000          
    #0000000000446CC1 [10]                ;#00444D6E:  C16C440000000000          
    #0000000000446A33 [11]                ;#00444D76:  336A440000000000          
    #0000000000446CC1 [12]                ;#00444D7E:  C16C440000000000          
    #0000000000446CC1 [13]                ;#00444D86:  C16C440000000000          
    #0000000000446CC1 [14]                ;#00444D8E:  C16C440000000000          
    #0000000000446CC1 [15]                ;#00444D96:  C16C440000000000          
    #0000000000446CC1 [16]                ;#00444D9E:  C16C440000000000          
    #0000000000446CC1 [17]                ;#00444DA6:  C16C440000000000          
    #0000000000446CC1 [18]                ;#00444DAE:  C16C440000000000          
    #0000000000446CC1 [19]                ;#00444DB6:  C16C440000000000          
    #0000000000446CC1 [20]                ;#00444DBE:  C16C440000000000          
    #0000000000446CC1 [21]                ;#00444DC6:  C16C440000000000          
    #0000000000446CC1 [22]                ;#00444DCE:  C16C440000000000          
    #0000000000446CC1 [23]                ;#00444DD6:  C16C440000000000          
    #0000000000446CC1 [24]                ;#00444DDE:  C16C440000000000          
    #0000000000446CC1 [25]                ;#00444DE6:  C16C440000000000          
    #0000000000446CC1 [26]                ;#00444DEE:  C16C440000000000          
    #0000000000446CC1 [27]                ;#00444DF6:  C16C440000000000          
    #0000000000446CC1 [28]                ;#00444DFE:  C16C440000000000          
    #0000000000446CC1 [29]                ;#00444E06:  C16C440000000000          
    #0000000000446CC1 [30]                ;#00444E0E:  C16C440000000000          
    #0000000000446CC1 [31]                ;#00444E16:  C16C440000000000          
    #0000000000445EE9 [32]                ;#00444E1E:  E95E440000000000          
    #0000000000446CC1 [33]                ;#00444E26:  C16C440000000000          
    #0000000000446CC1 [34]                ;#00444E2E:  C16C440000000000          
    #0000000000446CC1 [35]                ;#00444E36:  C16C440000000000          
    #0000000000446CC1 [36]                ;#00444E3E:  C16C440000000000          
    #0000000000446CC1 [37]                ;#00444E46:  C16C440000000000          
    #0000000000446CC1 [38]                ;#00444E4E:  C16C440000000000          
    #0000000000446CC1 [39]                ;#00444E56:  C16C440000000000          
    #0000000000446CC1 [40]                ;#00444E5E:  C16C440000000000          
    #0000000000446CC1 [41]                ;#00444E66:  C16C440000000000          
    #0000000000446CC1 [42]                ;#00444E6E:  C16C440000000000          
    #0000000000446CC1 [43]                ;#00444E76:  C16C440000000000          
    #0000000000446CC1 [44]                ;#00444E7E:  C16C440000000000          
    #0000000000446CC1 [45]                ;#00444E86:  C16C440000000000          
    #0000000000446CC1 [46]                ;#00444E8E:  C16C440000000000          
    #0000000000446CC1 [47]                ;#00444E96:  C16C440000000000          
    #0000000000446CC1 [48]                ;#00444E9E:  C16C440000000000          
    #0000000000446CC1 [49]                ;#00444EA6:  C16C440000000000          
    #0000000000446CC1 [50]                ;#00444EAE:  C16C440000000000          
    #0000000000446CC1 [51]                ;#00444EB6:  C16C440000000000          
    #0000000000446CC1 [52]                ;#00444EBE:  C16C440000000000          
    #0000000000446CC1 [53]                ;#00444EC6:  C16C440000000000          
    #0000000000446CC1 [54]                ;#00444ECE:  C16C440000000000          
    #0000000000446CC1 [55]                ;#00444ED6:  C16C440000000000          
    #0000000000446CC1 [56]                ;#00444EDE:  C16C440000000000          
    #0000000000446CC1 [57]                ;#00444EE6:  C16C440000000000          
    #0000000000446028 [58]                ;#00444EEE:  2860440000000000          
    #0000000000446CC1 [59]                ;#00444EF6:  C16C440000000000          
    #0000000000446CC1 [60]                ;#00444EFE:  C16C440000000000          
    #0000000000446CC1 [61]                ;#00444F06:  C16C440000000000          
    #0000000000446CC1 [62]                ;#00444F0E:  C16C440000000000          
    #0000000000446CC1 [63]                ;#00444F16:  C16C440000000000          
    #0000000000446CC1 [64]                ;#00444F1E:  C16C440000000000          
    #0000000000446CC1 [65]                ;#00444F26:  C16C440000000000          
    #0000000000446CC1 [66]                ;#00444F2E:  C16C440000000000          
    #0000000000446CC1 [67]                ;#00444F36:  C16C440000000000          
    #0000000000446CC1 [68]                ;#00444F3E:  C16C440000000000          
    #0000000000446CC1 [69]                ;#00444F46:  C16C440000000000          
    #0000000000446CC1 [70]                ;#00444F4E:  C16C440000000000          
    #0000000000446CC1 [71]                ;#00444F56:  C16C440000000000          
    #0000000000446C45 [72]                ;#00444F5E:  456C440000000000          
    #0000000000446CC1 [73]                ;#00444F66:  C16C440000000000          
    #0000000000446CC1 [74]                ;#00444F6E:  C16C440000000000          
    #0000000000446CC1 [75]                ;#00444F76:  C16C440000000000          
    #0000000000446CC1 [76]                ;#00444F7E:  C16C440000000000          
    #0000000000446CC1 [77]                ;#00444F86:  C16C440000000000          
    #0000000000446CC1 [78]                ;#00444F8E:  C16C440000000000          
    #0000000000446CC1 [79]                ;#00444F96:  C16C440000000000          
    #0000000000446CC1 [80]                ;#00444F9E:  C16C440000000000          
    #0000000000446CC1 [81]                ;#00444FA6:  C16C440000000000          
    #0000000000446CC1 [82]                ;#00444FAE:  C16C440000000000          
    #0000000000446CC1 [83]                ;#00444FB6:  C16C440000000000          
    #0000000000446CC1 [84]                ;#00444FBE:  C16C440000000000          
    #0000000000446CC1 [85]                ;#00444FC6:  C16C440000000000          
    #0000000000446CC1 [86]                ;#00444FCE:  C16C440000000000          
    #0000000000446CC1 [87]                ;#00444FD6:  C16C440000000000          
    #0000000000446CC1 [88]                ;#00444FDE:  C16C440000000000          
    #0000000000446CC1 [89]                ;#00444FE6:  C16C440000000000          
    #0000000000446CC1 [90]                ;#00444FEE:  C16C440000000000          
    #00000000004459D6 [91]                ;#00444FF6:  D659440000000000          
    #00000000004459D6 [92]                ;#00444FFE:  D659440000000000          
    #00000000004459D6 [93]                ;#00445006:  D659440000000000          
    #00000000004459D6 [94]                ;#0044500E:  D659440000000000          
    #0000000000446CC1 [95]                ;#00445016:  C16C440000000000          
    #0000000000446CC1 [96]                ;#0044501E:  C16C440000000000          
    #0000000000446CC1 [97]                ;#00445026:  C16C440000000000          
    #0000000000446CC1 [98]                ;#0044502E:  C16C440000000000          
    #0000000000446CC1 [99]                ;#00445036:  C16C440000000000          
    #0000000000446CC1 [100]               ;#0044503E:  C16C440000000000          
    #0000000000446CC1 [101]               ;#00445046:  C16C440000000000          
    #0000000000446CC1 [102]               ;#0044504E:  C16C440000000000          
    #0000000000446CC1 [103]               ;#00445056:  C16C440000000000          
    #0000000000446CC1 [104]               ;#0044505E:  C16C440000000000          
    #0000000000446CC1 [105]               ;#00445066:  C16C440000000000          
    #0000000000446CC1 [106]               ;#0044506E:  C16C440000000000          
    #0000000000446CC1 [107]               ;#00445076:  C16C440000000000          
    #0000000000446CC1 [108]               ;#0044507E:  C16C440000000000          
    #0000000000446CC1 [109]               ;#00445086:  C16C440000000000          
    #00000000004450E6 [110]               ;#0044508E:  E650440000000000          
    #0000000000446CC1 [111]               ;#00445096:  C16C440000000000          
    #0000000000446CC1 [112]               ;#0044509E:  C16C440000000000          
    #0000000000446CC1 [113]               ;#004450A6:  C16C440000000000          
    #0000000000446CC1 [114]               ;#004450AE:  C16C440000000000          
    #0000000000446CC1 [115]               ;#004450B6:  C16C440000000000          
    #0000000000446CC1 [116]               ;#004450BE:  C16C440000000000          
    #0000000000446CC1 [117]               ;#004450C6:  C16C440000000000          
    #0000000000446CC1 [118]               ;#004450CE:  C16C440000000000          
    #0000000000446CC1 [119]               ;#004450D6:  C16C440000000000          
    #00000000004460A9 [120]               ;#004450DE:  A960440000000000          
;  2249     or msg_id=110 then      -- e110tce(ecx) -- (ecx is var address)
;  2250         if msg_id=1 then
    cmp rsi,1                             ;#004450E6: 48:203376 01               uv 00 40  1 713      
    jne #00445125                         ;#004450EA: 165 39                     v  00 00  1 713      
;  2251             varno = or_ecx
    mov rdi,[#00402B08] (or_ecx)          ;#004450EC: 48:213075 15DAFBFF         uv 80 00  1 714      
    mov [rbp-312] (varno),rdi             ;#004450F3: 48:211275 C8FEFFFF         uv 00 A0  1 715 80   
    mov r15,h4                            ;#004450FA: 49:277 0000000000000040    vu 8000 00  1 715      
    cmp rdi,r15                           ;#00445104: 4C:071377                  uv 00 8080  1 716      
    jl #004451A8                          ;#00445107: 017214 9B000000            v  00 00  1 716      
    mov rsi,618                           ;#0044510D: 48:307306 6A020000         uv 40 00  1 717      
    mov rdi,712                           ;#00445114: 48:307307 C8020000         vu 80 00  1 717      
    call #00442D75 (:%pUnassigned)        ;#0044511B: 350 55DCFFFF               v  00 00  1 718      
    jmp #004451A8                         ;#00445120: 351 83000000               v  00 00  1 719      
;  2252         else
;  2253             varno = varIdx(or_ecx,rtn,symtab)
    mov rcx,14                            ;#00445125: 48:307301 0E000000         uv 02 00  1 720      
    mov rdx,639                           ;#0044512C: 48:307302 7F020000         vu 04 00  1 720      
    call #004428DB (:%opFrame) (varIdx)   ;#00445133: 350 A3D7FFFF               v  00 00  1 721      
    mov rax,[#00402B08] (or_ecx)          ;#00445138: 48:213005 C9D9FBFF         uv 01 00  1 722      
    mov [rbp] (addr),rax                  ;#0044513F: 48:211105 00               uv 00 21  1 723 01   
    mov r15,h4                            ;#00445143: 49:277 0000000000000040    vu 8000 00  1 723      
    cmp rax,r15                           ;#0044514D: 4C:071370                  uv 00 8001  1 724      
    jl #0044515D                          ;#00445150: 174 0B                     v  00 00  1 724      
    add qword[rbx+rax*4-16],1             ;#00445152: 48:203104203 F0 01         u  00 09  3 725      
    cmp eax,618                           ;#00445158: 075 6A020000               vu 00 01  1 727      
    mov rdi,[rbp+40] (prevebp)            ;#0044515D: 48:213175 28               uv 80 20  1 728      
    mov rax,[rdi-216]                     ;#00445161: 48:213207 28FFFFFF         uv 01 80  1 731 80 *80*
    mov [rbp-8] (rtn),rax                 ;#00445168: 48:211105 F8               uv 00 21  1 732 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044516C: 48:213175 28               vu 80 20  1 732      
    mov rax,[rdi]                         ;#00445170: 48:213007                  uv 01 80  1 735    *80*
    xor rbx,rbx                           ;#00445173: 48:061333                  vu 08 08  1 735      
    mov r15,h4                            ;#00445176: 49:277 0000000000000040    uv 8000 00  1 736      
    cmp rax,r15                           ;#00445180: 4C:071370                  uv 00 8001  1 737 8000   
    jl #00445190                          ;#00445183: 174 0B                     v  00 00  1 737      
    add qword[rbx+rax*4-16],1             ;#00445185: 48:203104203 F0 01         u  00 09  3 738      
    cmp eax,673                           ;#0044518B: 075 A1020000               vu 00 01  1 740      
    mov [rbp-16] (symtab),rax             ;#00445190: 48:211105 F0               uv 00 21  1 741      
    mov qword[retaddr],#004451A1          ;#00445194: 48:307105 20 A1514400      vu 00 20  1 741      
    jmp #0044DE2B (code:varIdx)           ;#0044519C: 351 8A8C0000               v  00 00  1 742      
    mov [rbp-312] (varno),rax             ;#004451A1: 48:211205 C8FEFFFF         uv 00 21  1 743      
;  2254         end if
;  2255         o = "???"
    mov rcx,qword[#00402C50]              ;#004451A8: 48:213015 A1DAFBFF         vu 02 00  1 743      
    mov [rbp-32] (o),rcx                  ;#004451AF: 48:211115 E0               uv 00 22  1 744      
    add qword[rbx+rcx*4-16],1             ;#004451B3: 48:203104213 F0 01         u  00 0A  3 746    *02*
;  2256         if varno<1 or varno>length(symtab) then
    mov rdi,1                             ;#004451B9: 48:307307 01000000         vu 80 00  1 748      
    mov rax,[rbp-312] (varno)             ;#004451C0: 48:213205 C8FEFFFF         uv 01 20  1 749      
    mov rsi,26                            ;#004451C7: 48:307306 1A000000         vu 40 00  1 749      
    mov rdx,712                           ;#004451CE: 48:307302 C8020000         uv 04 00  1 750      
    call #0043FA81 (:%opJcc)              ;#004451D5: 350 A7A8FFFF               v  00 00  1 750      
    jl #00445203                          ;#004451DA: 174 27                     v  00 00  1 751      
    lea rdi,[rbp-456] (symtab[746])       ;#004451DC: 48:215275 38FEFFFF         uv 80 20  1 752      
    mov rsi,[rbp] (symtab)                ;#004451E3: 48:213165 00               vu 40 20  1 752      
    mov rdx,673                           ;#004451E7: 48:307302 A1020000         uv 04 00  1 753      
    call #0043F28D (:%opLen)              ;#004451EE: 350 9AA0FFFF               v  00 00  1 753      
    mov rdi,[rbp-312] (varno)             ;#004451F3: 48:213275 C8FEFFFF         uv 80 20  1 754      
    cmp rdi,rcx                           ;#004451FA: 48:071317                  uv 00 82  1 755 80   
    jle #004452B1                         ;#004451FD: 017216 AE000000            v  00 00  1 755      
;  2257             name = sprintf("???(varno=%d[or_ecx=#%08x])",{varno,or_ecx})
    lea rax,[rbp-384] (symtab[721])       ;#00445203: 48:215205 80FEFFFF         uv 01 20  1 756      
    mov rdx,2                             ;#0044520A: 48:307302 02000000         vu 04 00  1 756      
    push #0044524B                        ;#00445211: 150 4B524400               uv 00 00  1 757      
    push rax                              ;#00445216: 120                        vu 00 01  1 757      
    mov rax,[#00402B08] (or_ecx)          ;#00445217: 48:213005 EAD8FBFF         uv 01 00  1 758      
    mov r15,h4                            ;#0044521E: 49:277 0000000000000040    vu 8000 00  1 758      
    cmp rax,r15                           ;#00445228: 4C:071370                  uv 00 8001  1 759      
    jl #00445238                          ;#0044522B: 174 0B                     v  00 00  1 759      
    add qword[rbx+rax*4-16],1             ;#0044522D: 48:203104203 F0 01         u  00 09  3 760      
    cmp eax,618                           ;#00445233: 075 6A020000               vu 00 01  1 762      
    push rax                              ;#00445238: 120                        uv 00 01  1 763      
    push qword[rbp-312] (varno)           ;#00445239: 377265 C8FEFFFF            np 00 20  2 764      
    mov rdi,[rbp-384] (symtab[721])       ;#0044523F: 48:213275 80FEFFFF         uv 80 20  1 766      
    jmp #004404BD (:%pMkSq)               ;#00445246: 351 72B2FFFF               v  00 00  1 766      
    mov rcx,33                            ;#0044524B: 48:307301 21000000         uv 02 00  1 767      
    mov rdx,89                            ;#00445252: 48:307302 59000000         vu 04 00  1 767      
    call #004428DB (:%opFrame) (sprintf)  ;#00445259: 350 7DD6FFFF               v  00 00  1 768      
    mov rsi,qword[#00402C58]              ;#0044525E: 48:213065 F3D9FBFF         uv 40 00  1 769      
    mov [rbp] (format),rsi                ;#00445265: 48:211165 00               uv 00 60  1 770 40   
    add qword[rbx+rsi*4-16],1             ;#00445269: 48:203104263 F0 01         u  00 48  3 772    *40*
    mov rdi,[rbp+40] (prevebp)            ;#0044526F: 48:213175 28               vu 80 20  1 774      
    mov rax,[rdi-384]                     ;#00445273: 48:213207 80FEFFFF         uv 01 80  1 777    *80*
    xor rbx,rbx                           ;#0044527A: 48:061333                  vu 08 08  1 777      
    mov r15,h4                            ;#0044527D: 49:277 0000000000000040    uv 8000 00  1 778      
    cmp rax,r15                           ;#00445287: 4C:071370                  uv 00 8001  1 779 8000   
    jl #00445297                          ;#0044528A: 174 0B                     v  00 00  1 779      
    add qword[rbx+rax*4-16],1             ;#0044528C: 48:203104203 F0 01         u  00 09  3 780      
    cmp eax,721                           ;#00445292: 075 D1020000               vu 00 01  1 782      
    mov [rbp-8] (args),rax                ;#00445297: 48:211105 F8               uv 00 21  1 783      
    mov qword[retaddr],#004452A8          ;#0044529B: 48:307105 20 A8524400      vu 00 20  1 783      
    jmp #0044E450 (code:sprintf)          ;#004452A3: 351 A8910000               v  00 00  1 784      
    mov [rbp-24] (name),rax               ;#004452A8: 48:211105 E8               uv 00 21  1 785      
    jmp #004458F0                         ;#004452AC: 351 3F060000               v  00 00  1 785      
;  2258         else
;  2259             si = symtab[varno]
    mov r15,h4                            ;#004452B1: 49:277 0000000000000040    uv 8000 00  1 786      
    cmp rsi,r15                           ;#004452BB: 4C:071376                  uv 00 8040  1 787 8000   
    jne #004452CC                         ;#004452BE: 165 0C                     v  00 00  1 787      
    mov rsi,673                           ;#004452C0: 48:307306 A1020000         uv 40 00  1 788      
    call #00442D75 (:%pUnassigned)        ;#004452C7: 350 A9DAFFFF               v  00 00  1 788      
    mov r15,h4                            ;#004452CC: 49:277 0000000000000040    uv 8000 00  1 789      
    cmp rdi,r15                           ;#004452D6: 4C:071377                  uv 00 8080  1 790 8000   
    jne #004452E7                         ;#004452D9: 165 0C                     v  00 00  1 790      
    mov rsi,712                           ;#004452DB: 48:307306 C8020000         uv 40 00  1 791      
    call #00442D75 (:%pUnassigned)        ;#004452E2: 350 8EDAFFFF               v  00 00  1 791      
    lea rcx,[rbp-8] (si)                  ;#004452E7: 48:215115 F8               uv 02 20  1 792      
    mov rdx,673                           ;#004452EB: 48:307302 A1020000         vu 04 00  1 792      
    call #00441675 (:%pSubse1)            ;#004452F2: 350 7EC3FFFF               v  00 00  1 793      
;  2260             if atom(si) then
    mov rcx,[rbp-8] (si)                  ;#004452F7: 48:213115 F8               uv 02 20  1 794      
    mov r15,h4                            ;#004452FB: 49:277 0000000000000040    vu 8000 00  1 794      
    cmp rcx,r15                           ;#00445305: 4C:071371                  uv 00 8002  1 795      
    jl #00445311                          ;#00445308: 174 07                     v  00 00  1 795      
    cmp byte[rbx+rcx*4-1],#12             ;#0044530A: 200174213 FF 12            u  00 0A  2 796      
    jne #0044537D                         ;#0044530F: 165 6C                     v  00 00  1 797      
;  2261                 name = sprintf("???(atom(symtab[%d]))",varno)
    mov rcx,33                            ;#00445311: 48:307301 21000000         uv 02 00  1 798      
    mov rdx,89                            ;#00445318: 48:307302 59000000         vu 04 00  1 798      
    call #004428DB (:%opFrame) (sprintf)  ;#0044531F: 350 B7D5FFFF               v  00 00  1 799      
    mov rax,qword[#00402C60]              ;#00445324: 48:213005 35D9FBFF         uv 01 00  1 800      
    mov [rbp] (format),rax                ;#0044532B: 48:211105 00               uv 00 21  1 801 01   
    add qword[rbx+rax*4-16],1             ;#0044532F: 48:203104203 F0 01         u  00 09  3 803    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00445335: 48:213175 28               vu 80 20  1 805      
    mov rax,[rdi-312]                     ;#00445339: 48:213207 C8FEFFFF         uv 01 80  1 808    *80*
    mov [rbp-8] (args),rax                ;#00445340: 48:211105 F8               uv 00 21  1 809 01   
    mov qword[retaddr],#00445351          ;#00445344: 48:307105 20 51534400      vu 00 20  1 809      
    jmp #0044E450 (code:sprintf)          ;#0044534C: 351 FF900000               v  00 00  1 810      
    push rax                              ;#00445351: 120                        uv 00 01  1 811      
    mov rdi,[rbp-24] (name)               ;#00445352: 48:213175 E8               vu 80 20  1 811      
    mov r15,h4                            ;#00445356: 49:277 0000000000000040    uv 8000 00  1 812      
    cmp rdi,r15                           ;#00445360: 4C:071377                  uv 00 8080  1 813 8000   
    jle #00445375                         ;#00445363: 176 10                     v  00 00  1 813      
    sub qword[rbx+rdi*4-16],1             ;#00445365: 48:203154273 F0 01         u  00 88  3 814      
    jne #00445375                         ;#0044536B: 165 08                     v  00 00  1 816      
    mov rdx,rdi                           ;#0044536D: 48:213327                  uv 04 80  1 817      
    call #004422DA (:%pDealloc)           ;#00445370: 350 65CFFFFF               v  00 00  1 817      
    pop dword[rbp-24] (name)              ;#00445375: 217105 E8                  np 00 20  3 818      
    jmp #004458F0                         ;#00445378: 351 73050000               v  00 00  1 821      
;  2262             else
;  2263                 name = si[S_Name]
    mov rdi,1                             ;#0044537D: 48:307307 01000000         uv 80 00  1 822      
    lea rcx,[rbp-24] (name)               ;#00445384: 48:215115 E8               vu 02 20  1 822      
    mov rsi,[rbp-8] (si)                  ;#00445388: 48:213165 F8               uv 40 20  1 823      
    mov rdx,674                           ;#0044538C: 48:307302 A2020000         vu 04 00  1 823      
    call #00441675 (:%pSubse1)            ;#00445393: 350 DDC2FFFF               v  00 00  1 824      
;  2264                 if atom(name) then
    mov rcx,[rbp-24] (name)               ;#00445398: 48:213115 E8               uv 02 20  1 825      
    mov r15,h4                            ;#0044539C: 49:277 0000000000000040    vu 8000 00  1 825      
    cmp rcx,r15                           ;#004453A6: 4C:071371                  uv 00 8002  1 826      
    jl #004453B6                          ;#004453A9: 174 0B                     v  00 00  1 826      
    cmp byte[rbx+rcx*4-1],#12             ;#004453AB: 200174213 FF 12            u  00 0A  2 827      
    jne #004454A1                         ;#004453B0: 017205 EB000000            v  00 00  1 828      
;  2265                     name = sprintf("???(symtab[%d][S_name]=%d)",{varno,si})
    mov rax,[rbp-312] (varno)             ;#004453B6: 48:213205 C8FEFFFF         uv 01 20  1 829      
    mov r15,h4                            ;#004453BD: 49:277 0000000000000040    vu 8000 00  1 829      
    cmp rax,r15                           ;#004453C7: 4C:071370                  uv 00 8001  1 830      
    jne #004453D8                         ;#004453CA: 165 0C                     v  00 00  1 830      
    mov rsi,712                           ;#004453CC: 48:307306 C8020000         uv 40 00  1 831      
    call #00442D75 (:%pUnassigned)        ;#004453D3: 350 9DD9FFFF               v  00 00  1 831      
    lea rax,[rbp-384] (symtab[721])       ;#004453D8: 48:215205 80FEFFFF         uv 01 20  1 832      
    mov rdx,2                             ;#004453DF: 48:307302 02000000         vu 04 00  1 832      
    push #0044541D                        ;#004453E6: 150 1D544400               uv 00 00  1 833      
    push rax                              ;#004453EB: 120                        vu 00 01  1 833      
    mov rdi,[rbp-8] (si)                  ;#004453EC: 48:213175 F8               uv 80 20  1 834      
    mov r15,h4                            ;#004453F0: 49:277 0000000000000040    vu 8000 00  1 834      
    cmp rdi,r15                           ;#004453FA: 4C:071377                  uv 00 8080  1 835      
    jl #0044540A                          ;#004453FD: 174 0B                     v  00 00  1 835      
    add qword[rbx+rdi*4-16],1             ;#004453FF: 48:203104273 F0 01         u  00 88  3 836      
    cmp eax,674                           ;#00445405: 075 A2020000               vu 00 01  1 838      
    push rdi                              ;#0044540A: 127                        uv 00 80  1 839      
    push qword[rbp-312] (varno)           ;#0044540B: 377265 C8FEFFFF            np 00 20  2 840      
    mov rdi,[rbp-384] (symtab[721])       ;#00445411: 48:213275 80FEFFFF         uv 80 20  1 842      
    jmp #004404BD (:%pMkSq)               ;#00445418: 351 A0B0FFFF               v  00 00  1 842      
    mov rcx,33                            ;#0044541D: 48:307301 21000000         uv 02 00  1 843      
    mov rdx,89                            ;#00445424: 48:307302 59000000         vu 04 00  1 843      
    call #004428DB (:%opFrame) (sprintf)  ;#0044542B: 350 ABD4FFFF               v  00 00  1 844      
    mov rsi,qword[#00402C68]              ;#00445430: 48:213065 31D8FBFF         uv 40 00  1 845      
    mov [rbp] (format),rsi                ;#00445437: 48:211165 00               uv 00 60  1 846 40   
    add qword[rbx+rsi*4-16],1             ;#0044543B: 48:203104263 F0 01         u  00 48  3 848    *40*
    mov rdi,[rbp+40] (prevebp)            ;#00445441: 48:213175 28               vu 80 20  1 850      
    mov rax,[rdi-384]                     ;#00445445: 48:213207 80FEFFFF         uv 01 80  1 853    *80*
    xor rbx,rbx                           ;#0044544C: 48:061333                  vu 08 08  1 853      
    mov r15,h4                            ;#0044544F: 49:277 0000000000000040    uv 8000 00  1 854      
    cmp rax,r15                           ;#00445459: 4C:071370                  uv 00 8001  1 855 8000   
    jl #00445469                          ;#0044545C: 174 0B                     v  00 00  1 855      
    add qword[rbx+rax*4-16],1             ;#0044545E: 48:203104203 F0 01         u  00 09  3 856      
    cmp eax,721                           ;#00445464: 075 D1020000               vu 00 01  1 858      
    mov [rbp-8] (args),rax                ;#00445469: 48:211105 F8               uv 00 21  1 859      
    mov qword[retaddr],#0044547A          ;#0044546D: 48:307105 20 7A544400      vu 00 20  1 859      
    jmp #0044E450 (code:sprintf)          ;#00445475: 351 D68F0000               v  00 00  1 860      
    push rax                              ;#0044547A: 120                        uv 00 01  1 861      
    mov rcx,[rbp-24] (name)               ;#0044547B: 48:213115 E8               vu 02 20  1 861      
    mov r15,h4                            ;#0044547F: 49:277 0000000000000040    uv 8000 00  1 862      
    cmp rcx,r15                           ;#00445489: 4C:071371                  uv 00 8002  1 863 8000   
    jle #0044549E                         ;#0044548C: 176 10                     v  00 00  1 863      
    sub qword[rbx+rcx*4-16],1             ;#0044548E: 48:203154213 F0 01         u  00 0A  3 864      
    jne #0044549E                         ;#00445494: 165 08                     v  00 00  1 866      
    mov rdx,rcx                           ;#00445496: 48:213321                  uv 04 02  1 867      
    call #004422DA (:%pDealloc)           ;#00445499: 350 3CCEFFFF               v  00 00  1 867      
    pop dword[rbp-24] (name)              ;#0044549E: 217105 E8                  np 00 20  3 868      
;  2266                 end if
;  2267                 sNTyp = si[S_NTyp]
    mov rdi,2                             ;#004454A1: 48:307307 02000000         uv 80 00  1 871      
    lea rcx,[rbp-96] (sNTyp)              ;#004454A8: 48:215115 A0               vu 02 20  1 871      
    mov rsi,[rbp-8] (si)                  ;#004454AC: 48:213165 F8               uv 40 20  1 872      
    mov rdx,674                           ;#004454B0: 48:307302 A2020000         vu 04 00  1 872      
    call #004416F2 (:%pSubse1i)           ;#004454B7: 350 36C2FFFF               v  00 00  1 873      
;  2268                 if sNTyp!=S_GVar2
    cmp rax,2                             ;#004454BC: 48:203370 02               uv 00 01  1 874      
    je #00445534                          ;#004454C0: 164 72                     v  00 00  1 874      
;  2269                 and sNTyp!=S_TVar3 then
    cmp rax,3                             ;#004454C2: 48:203370 03               uv 00 01  1 875      
    je #00445534                          ;#004454C6: 164 6C                     v  00 00  1 875      
;  2270                     o = sprintf("???(symtab[%d] wrong type)",varno)
    mov rcx,33                            ;#004454C8: 48:307301 21000000         uv 02 00  1 876      
    mov rdx,89                            ;#004454CF: 48:307302 59000000         vu 04 00  1 876      
    call #004428DB (:%opFrame) (sprintf)  ;#004454D6: 350 00D4FFFF               v  00 00  1 877      
    mov rdi,qword[#00402C70]              ;#004454DB: 48:213075 8ED7FBFF         uv 80 00  1 878      
    mov [rbp] (format),rdi                ;#004454E2: 48:211175 00               uv 00 A0  1 879 80   
    add qword[rbx+rdi*4-16],1             ;#004454E6: 48:203104273 F0 01         u  00 88  3 881    *80*
    mov rdi,[rbp+40] (prevebp)            ;#004454EC: 48:213175 28               vu 80 20  1 883      
    mov rax,[rdi-312]                     ;#004454F0: 48:213207 C8FEFFFF         uv 01 80  1 886    *80*
    mov [rbp-8] (args),rax                ;#004454F7: 48:211105 F8               uv 00 21  1 887 01   
    mov qword[retaddr],#00445508          ;#004454FB: 48:307105 20 08554400      vu 00 20  1 887      
    jmp #0044E450 (code:sprintf)          ;#00445503: 351 488F0000               v  00 00  1 888      
    push rax                              ;#00445508: 120                        uv 00 01  1 889      
    mov rcx,[rbp-32] (o)                  ;#00445509: 48:213115 E0               vu 02 20  1 889      
    mov r15,h4                            ;#0044550D: 49:277 0000000000000040    uv 8000 00  1 890      
    cmp rcx,r15                           ;#00445517: 4C:071371                  uv 00 8002  1 891 8000   
    jle #0044552C                         ;#0044551A: 176 10                     v  00 00  1 891      
    sub qword[rbx+rcx*4-16],1             ;#0044551C: 48:203154213 F0 01         u  00 0A  3 892      
    jne #0044552C                         ;#00445522: 165 08                     v  00 00  1 894      
    mov rdx,rcx                           ;#00445524: 48:213321                  uv 04 02  1 895      
    call #004422DA (:%pDealloc)           ;#00445527: 350 AECDFFFF               v  00 00  1 895      
    pop dword[rbp-32] (o)                 ;#0044552C: 217105 E0                  np 00 20  3 896      
    jmp #004458F0                         ;#0044552F: 351 BC030000               v  00 00  1 899      
;  2271                 else
;  2272                     if sNTyp=S_GVar2 then
    cmp rax,2                             ;#00445534: 48:203370 02               uv 00 01  1 900      
    jne #00445619                         ;#00445538: 017205 DB000000            v  00 00  1 900      
;  2273                         {novalue,o} = getGvarValue(si[S_Slink])
    mov rdi,6                             ;#0044553E: 48:307307 06000000         uv 80 00  1 901      
    lea rcx,[rbp-440] (symtab[735])       ;#00445545: 48:215215 48FEFFFF         vu 02 20  1 901      
    mov rsi,[rbp-8] (si)                  ;#0044554C: 48:213165 F8               uv 40 20  1 902      
    mov rdx,674                           ;#00445550: 48:307302 A2020000         vu 04 00  1 902      
    call #00441675 (:%pSubse1)            ;#00445557: 350 19C1FFFF               v  00 00  1 903      
    mov rcx,4                             ;#0044555C: 48:307301 04000000         uv 02 00  1 904      
    mov rdx,625                           ;#00445563: 48:307302 71020000         vu 04 00  1 904      
    call :%opFrame (getGvarValue)         ;#0044556A: 350 6CD3FFFF               v  00 00  1 905      
    mov rdi,[rbp+40] (prevebp)            ;#0044556F: 48:213175 28               uv 80 20  1 906      
    mov rax,[rdi-440]                     ;#00445573: 48:213207 48FEFFFF         uv 01 80  1 909 80 *80*
    xor rbx,rbx                           ;#0044557A: 48:061333                  vu 08 08  1 909      
    mov r15,h4                            ;#0044557D: 49:277 0000000000000040    uv 8000 00  1 910      
    cmp rax,r15                           ;#00445587: 4C:071370                  uv 00 8001  1 911 8000   
    jl #00445597                          ;#0044558A: 174 0B                     v  00 00  1 911      
    add qword[rbx+rax*4-16],1             ;#0044558C: 48:203104203 F0 01         u  00 09  3 912      
    cmp eax,735                           ;#00445592: 075 DF020000               vu 00 01  1 914      
    mov [rbp] (gidx),rax                  ;#00445597: 48:211105 00               uv 00 21  1 915      
    mov qword[retaddr],#004455A8          ;#0044559B: 48:307105 20 A8554400      vu 00 20  1 915      
    jmp #0044DD19 (code:getGvarValue)     ;#004455A3: 351 71870000               v  00 00  1 916      
    push rax                              ;#004455A8: 120                        uv 00 01  1 917      
    mov rdi,[rbp-384] (symtab[721])       ;#004455A9: 48:213275 80FEFFFF         vu 80 20  1 917      
    mov r15,h4                            ;#004455B0: 49:277 0000000000000040    uv 8000 00  1 918      
    cmp rdi,r15                           ;#004455BA: 4C:071377                  uv 00 8080  1 919 8000   
    jle #004455CF                         ;#004455BD: 176 10                     v  00 00  1 919      
    sub qword[rbx+rdi*4-16],1             ;#004455BF: 48:203154273 F0 01         u  00 88  3 920      
    jne #004455CF                         ;#004455C5: 165 08                     v  00 00  1 922      
    mov rdx,rdi                           ;#004455C7: 48:213327                  uv 04 80  1 923      
    call #004422DA (:%pDealloc)           ;#004455CA: 350 0BCDFFFF               v  00 00  1 923      
    pop dword[rbp-384] (symtab[721])      ;#004455CF: 217205 80FEFFFF            np 00 20  3 924      
    mov rdi,2                             ;#004455D5: 48:307307 02000000         uv 80 00  1 927      
    lea rcx,[rbp-32] (o)                  ;#004455DC: 48:215115 E0               vu 02 20  1 927      
    mov rsi,[rbp-384] (symtab[721])       ;#004455E0: 48:213265 80FEFFFF         uv 40 20  1 928      
    mov rdx,721                           ;#004455E7: 48:307302 D1020000         vu 04 00  1 928      
    call #00441675 (:%pSubse1)            ;#004455EE: 350 82C0FFFF               v  00 00  1 929      
    mov rdi,1                             ;#004455F3: 48:307307 01000000         uv 80 00  1 930      
    lea rcx,[rbp-320] (novalue)           ;#004455FA: 48:215215 C0FEFFFF         vu 02 20  1 930      
    mov rsi,[rbp-384] (symtab[721])       ;#00445601: 48:213265 80FEFFFF         uv 40 20  1 931      
    mov rdx,721                           ;#00445608: 48:307302 D1020000         vu 04 00  1 931      
    call #004416F2 (:%pSubse1i)           ;#0044560F: 350 DEC0FFFF               v  00 00  1 932      
    jmp #004456F9                         ;#00445614: 351 E0000000               v  00 00  1 933      
;  2274                     elsif sNTyp=S_TVar3 then
    cmp rax,3                             ;#00445619: 48:203370 03               uv 00 01  1 934      
    jne #004456F9                         ;#0044561D: 017205 D6000000            v  00 00  1 934      
;  2275                         {novalue,o} = getTvarValue(si[S_Tidx])
    mov rdi,9                             ;#00445623: 48:307307 09000000         uv 80 00  1 935      
    lea rcx,[rbp-440] (symtab[735])       ;#0044562A: 48:215215 48FEFFFF         vu 02 20  1 935      
    mov rsi,[rbp-8] (si)                  ;#00445631: 48:213165 F8               uv 40 20  1 936      
    mov rdx,674                           ;#00445635: 48:307302 A2020000         vu 04 00  1 936      
    call #00441675 (:%pSubse1)            ;#0044563C: 350 34C0FFFF               v  00 00  1 937      
    mov rcx,4                             ;#00445641: 48:307301 04000000         uv 02 00  1 938      
    mov rdx,631                           ;#00445648: 48:307302 77020000         vu 04 00  1 938      
    call :%opFrame (getTvarValue)         ;#0044564F: 350 87D2FFFF               v  00 00  1 939      
    mov rdi,[rbp+40] (prevebp)            ;#00445654: 48:213175 28               uv 80 20  1 940      
    mov rax,[rdi-440]                     ;#00445658: 48:213207 48FEFFFF         uv 01 80  1 943 80 *80*
    xor rbx,rbx                           ;#0044565F: 48:061333                  vu 08 08  1 943      
    mov r15,h4                            ;#00445662: 49:277 0000000000000040    uv 8000 00  1 944      
    cmp rax,r15                           ;#0044566C: 4C:071370                  uv 00 8001  1 945 8000   
    jl #0044567C                          ;#0044566F: 174 0B                     v  00 00  1 945      
    add qword[rbx+rax*4-16],1             ;#00445671: 48:203104203 F0 01         u  00 09  3 946      
    cmp eax,735                           ;#00445677: 075 DF020000               vu 00 01  1 948      
    mov [rbp] (tidx),rax                  ;#0044567C: 48:211105 00               uv 00 21  1 949      
    mov qword[retaddr],#0044568D          ;#00445680: 48:307105 20 8D564400      vu 00 20  1 949      
    jmp #0044DC08 (code:getTvarValue)     ;#00445688: 351 7B850000               v  00 00  1 950      
    push rax                              ;#0044568D: 120                        uv 00 01  1 951      
    mov rcx,[rbp-464] (symtab[754])       ;#0044568E: 48:213215 30FEFFFF         vu 02 20  1 951      
    mov r15,h4                            ;#00445695: 49:277 0000000000000040    uv 8000 00  1 952      
    cmp rcx,r15                           ;#0044569F: 4C:071371                  uv 00 8002  1 953 8000   
    jle #004456B4                         ;#004456A2: 176 10                     v  00 00  1 953      
    sub qword[rbx+rcx*4-16],1             ;#004456A4: 48:203154213 F0 01         u  00 0A  3 954      
    jne #004456B4                         ;#004456AA: 165 08                     v  00 00  1 956      
    mov rdx,rcx                           ;#004456AC: 48:213321                  uv 04 02  1 957      
    call #004422DA (:%pDealloc)           ;#004456AF: 350 26CCFFFF               v  00 00  1 957      
    pop dword[rbp-464] (symtab[754])      ;#004456B4: 217205 30FEFFFF            np 00 20  3 958      
    mov rdi,2                             ;#004456BA: 48:307307 02000000         uv 80 00  1 961      
    lea rcx,[rbp-32] (o)                  ;#004456C1: 48:215115 E0               vu 02 20  1 961      
    mov rsi,[rbp-464] (symtab[754])       ;#004456C5: 48:213265 30FEFFFF         uv 40 20  1 962      
    mov rdx,754                           ;#004456CC: 48:307302 F2020000         vu 04 00  1 962      
    call #00441675 (:%pSubse1)            ;#004456D3: 350 9DBFFFFF               v  00 00  1 963      
    mov rdi,1                             ;#004456D8: 48:307307 01000000         uv 80 00  1 964      
    lea rcx,[rbp-320] (novalue)           ;#004456DF: 48:215215 C0FEFFFF         vu 02 20  1 964      
    mov rsi,[rbp-464] (symtab[754])       ;#004456E6: 48:213265 30FEFFFF         uv 40 20  1 965      
    mov rdx,754                           ;#004456ED: 48:307302 F2020000         vu 04 00  1 965      
    call #004416F2 (:%pSubse1i)           ;#004456F4: 350 F9BFFFFF               v  00 00  1 966      
;  2276                     end if
;  2277                     if novalue then
    mov rax,[rbp-320] (novalue)           ;#004456F9: 48:213205 C0FEFFFF         uv 01 20  1 967      
    mov rdx,713                           ;#00445700: 48:48:307302 C9020000      vu 04 00  1 967      
    call #0043FB2C (:%opJif)              ;#00445708: 350 1FA4FFFF               v  00 00  1 968      
    je #00445859                          ;#0044570D: 017204 46010000            v  00 00  1 969      
;  2278                         if novalue=1 then
    cmp rax,1                             ;#00445713: 48:203370 01               uv 00 01  1 970      
    jne #00445766                         ;#00445717: 165 4D                     v  00 00  1 970      
;  2279                             o = "<novalue>"
    mov rdi,qword[#00402680]              ;#00445719: 48:213075 60CFFBFF         uv 80 00  1 971      
    mov rdx,[rbp-32] (o)                  ;#00445720: 48:213125 E0               vu 04 20  1 971      
    mov r15,h4                            ;#00445724: 49:277 0000000000000040    uv 8000 00  1 972      
    cmp rdi,r15                           ;#0044572E: 4C:071377                  uv 00 8080  1 973 8000   
    jl #00445739                          ;#00445731: 174 06                     v  00 00  1 973      
    add qword[rbx+rdi*4-16],1             ;#00445733: 48:203104273 F0 01         u  00 88  3 974      
    mov [rbp-32] (o),rdi                  ;#00445739: 48:211175 E0               vu 00 A0  1 976      
    mov r15,h4                            ;#0044573D: 49:277 0000000000000040    uv 8000 00  1 977      
    cmp rdx,r15                           ;#00445747: 4C:071372                  uv 00 8004  1 978 8000   
    jle #004458F0                         ;#0044574A: 017216 A0010000            v  00 00  1 978      
    sub qword[rbx+rdx*4-16],1             ;#00445750: 48:203154223 F0 01         u  00 0C  3 979      
    jne #004458F0                         ;#00445756: 017205 94010000            v  00 00  1 981      
    call #004422DA (:%pDealloc)           ;#0044575C: 350 79CBFFFF               v  00 00  1 982      
    jmp #004458F0                         ;#00445761: 351 8A010000               v  00 00  1 983      
;  2280                         elsif novalue=2 then
    cmp rax,2                             ;#00445766: 48:203370 02               uv 00 01  1 984      
    jne #004457B9                         ;#0044576A: 165 4D                     v  00 00  1 984      
;  2281                             o = "*** INVALID REF ***"
    mov rcx,qword[#00402688]              ;#0044576C: 48:213015 15CFFBFF         uv 02 00  1 985      
    mov rdx,[rbp-32] (o)                  ;#00445773: 48:213125 E0               vu 04 20  1 985      
    mov r15,h4                            ;#00445777: 49:277 0000000000000040    uv 8000 00  1 986      
    cmp rcx,r15                           ;#00445781: 4C:071371                  uv 00 8002  1 987 8000   
    jl #0044578C                          ;#00445784: 174 06                     v  00 00  1 987      
    add qword[rbx+rcx*4-16],1             ;#00445786: 48:203104213 F0 01         u  00 0A  3 988      
    mov [rbp-32] (o),rcx                  ;#0044578C: 48:211115 E0               vu 00 22  1 990      
    mov r15,h4                            ;#00445790: 49:277 0000000000000040    uv 8000 00  1 991      
    cmp rdx,r15                           ;#0044579A: 4C:071372                  uv 00 8004  1 992 8000   
    jle #004458F0                         ;#0044579D: 017216 4D010000            v  00 00  1 992      
    sub qword[rbx+rdx*4-16],1             ;#004457A3: 48:203154223 F0 01         u  00 0C  3 993      
    jne #004458F0                         ;#004457A9: 017205 41010000            v  00 00  1 995      
    call #004422DA (:%pDealloc)           ;#004457AF: 350 26CBFFFF               v  00 00  1 996      
    jmp #004458F0                         ;#004457B4: 351 37010000               v  00 00  1 997      
;  2282                         elsif novalue=3 then
    cmp rax,3                             ;#004457B9: 48:203370 03               uv 00 01  1 998      
    jne #0044580C                         ;#004457BD: 165 4D                     v  00 00  1 998      
;  2283                             o = "*** CORRUPT TYPE BYTE ***"
    mov rsi,qword[#00402690]              ;#004457BF: 48:213065 CACEFBFF         uv 40 00  1 999      
    mov rdx,[rbp-32] (o)                  ;#004457C6: 48:213125 E0               vu 04 20  1 999      
    mov r15,h4                            ;#004457CA: 49:277 0000000000000040    uv 8000 00  1 1000      
    cmp rsi,r15                           ;#004457D4: 4C:071376                  uv 00 8040  1 1001 8000   
    jl #004457DF                          ;#004457D7: 174 06                     v  00 00  1 1001      
    add qword[rbx+rsi*4-16],1             ;#004457D9: 48:203104263 F0 01         u  00 48  3 1002      
    mov [rbp-32] (o),rsi                  ;#004457DF: 48:211165 E0               vu 00 60  1 1004      
    mov r15,h4                            ;#004457E3: 49:277 0000000000000040    uv 8000 00  1 1005      
    cmp rdx,r15                           ;#004457ED: 4C:071372                  uv 00 8004  1 1006 8000   
    jle #004458F0                         ;#004457F0: 017216 FA000000            v  00 00  1 1006      
    sub qword[rbx+rdx*4-16],1             ;#004457F6: 48:203154223 F0 01         u  00 0C  3 1007      
    jne #004458F0                         ;#004457FC: 017205 EE000000            v  00 00  1 1009      
    call #004422DA (:%pDealloc)           ;#00445802: 350 D3CAFFFF               v  00 00  1 1010      
    jmp #004458F0                         ;#00445807: 351 E4000000               v  00 00  1 1011      
;  2284                         else
;  2285                             o = "*** INVALID ??? ***"
    mov rdi,qword[#00402698]              ;#0044580C: 48:213075 85CEFBFF         uv 80 00  1 1012      
    mov rdx,[rbp-32] (o)                  ;#00445813: 48:213125 E0               vu 04 20  1 1012      
    mov r15,h4                            ;#00445817: 49:277 0000000000000040    uv 8000 00  1 1013      
    cmp rdi,r15                           ;#00445821: 4C:071377                  uv 00 8080  1 1014 8000   
    jl #0044582C                          ;#00445824: 174 06                     v  00 00  1 1014      
    add qword[rbx+rdi*4-16],1             ;#00445826: 48:203104273 F0 01         u  00 88  3 1015      
    mov [rbp-32] (o),rdi                  ;#0044582C: 48:211175 E0               vu 00 A0  1 1017      
    mov r15,h4                            ;#00445830: 49:277 0000000000000040    uv 8000 00  1 1018      
    cmp rdx,r15                           ;#0044583A: 4C:071372                  uv 00 8004  1 1019 8000   
    jle #004458F0                         ;#0044583D: 017216 AD000000            v  00 00  1 1019      
    sub qword[rbx+rdx*4-16],1             ;#00445843: 48:203154223 F0 01         u  00 0C  3 1020      
    jne #004458F0                         ;#00445849: 017205 A1000000            v  00 00  1 1022      
    call #004422DA (:%pDealloc)           ;#0044584F: 350 86CAFFFF               v  00 00  1 1023      
;  2286                         end if
    jmp #004458F0                         ;#00445854: 351 97000000               v  00 00  1 1024      
;  2287                     else
;  2288                         o = sprint(o,50-length(name))
    lea rdi,[rbp-456] (symtab[746])       ;#00445859: 48:215275 38FEFFFF         uv 80 20  1 1025      
    mov rsi,[rbp-24] (name)               ;#00445860: 48:213165 E8               vu 40 20  1 1025      
    mov rdx,676                           ;#00445864: 48:307302 A4020000         uv 04 00  1 1026      
    call #0043F28D (:%opLen)              ;#0044586B: 350 1D9AFFFF               v  00 00  1 1026      
    lea rdi,[rbp-376] (symtab[720])       ;#00445870: 48:215275 88FEFFFF         uv 80 20  1 1027      
    mov rcx,qword[#00402C78]              ;#00445877: 48:213015 FAD3FBFF         vu 02 00  1 1027      
    mov rax,[rbp-456] (symtab[746])       ;#0044587E: 48:213205 38FEFFFF         uv 01 20  1 1028      
    call #0043F4D8 (:%opSub)              ;#00445885: 350 4E9CFFFF               v  00 00  1 1028      
    mov rcx,11                            ;#0044588A: 48:307301 0B000000         uv 02 00  1 1029      
    mov rdx,91                            ;#00445891: 48:307302 5B000000         vu 04 00  1 1029      
    call #004428DB (:%opFrame) (sprint)   ;#00445898: 350 3ED0FFFF               v  00 00  1 1030      
    mov rdi,[rbp+40] (prevebp)            ;#0044589D: 48:213175 28               uv 80 20  1 1031      
    mov rax,[rdi-32]                      ;#004458A1: 48:213107 E0               uv 01 80  1 1034 80 *80*
    mov [rdi-32],r15                      ;#004458A5: 4C:211177 E0               vu 00 8080  1 1034      
    mov [rbp] (x),rax                     ;#004458A9: 48:211105 00               uv 00 21  1 1035      
    mov rdi,[rbp+40] (prevebp)            ;#004458AD: 48:213175 28               vu 80 20  1 1035      
    mov rax,[rdi-376]                     ;#004458B1: 48:213207 88FEFFFF         uv 01 80  1 1038    *80*
    mov [rbp-8] (l),rax                   ;#004458B8: 48:211105 F8               uv 00 21  1 1039 01   
    mov qword[retaddr],#004458C9          ;#004458BC: 48:307105 20 C9584400      vu 00 20  1 1039      
    jmp #0044D2DF (code:sprint)           ;#004458C4: 351 167A0000               v  00 00  1 1040      
    push rax                              ;#004458C9: 120                        uv 00 01  1 1041      
    mov rdi,[rbp-32] (o)                  ;#004458CA: 48:213175 E0               vu 80 20  1 1041      
    mov r15,h4                            ;#004458CE: 49:277 0000000000000040    uv 8000 00  1 1042      
    cmp rdi,r15                           ;#004458D8: 4C:071377                  uv 00 8080  1 1043 8000   
    jle #004458ED                         ;#004458DB: 176 10                     v  00 00  1 1043      
    sub qword[rbx+rdi*4-16],1             ;#004458DD: 48:203154273 F0 01         u  00 88  3 1044      
    jne #004458ED                         ;#004458E3: 165 08                     v  00 00  1 1046      
    mov rdx,rdi                           ;#004458E5: 48:213327                  uv 04 80  1 1047      
    call #004422DA (:%pDealloc)           ;#004458E8: 350 EDC9FFFF               v  00 00  1 1047      
    pop dword[rbp-32] (o)                 ;#004458ED: 217105 E0                  np 00 20  3 1048      
;  2289                     end if
;  2290                 end if
;  2291             end if
;  2292         end if
;  2293 --      o = getValue(or_edi, 50, length(si)+17, 1)
;  2294         msg = sprintf(msg,{name,o})         -- "type check failure, %s is %s\n"
    lea rax,[rbp-472] (symtab[756])       ;#004458F0: 48:215205 28FEFFFF         uv 01 20  1 1051      
    mov rdx,2                             ;#004458F7: 48:307302 02000000         vu 04 00  1 1051      
    push #0044594E                        ;#004458FE: 150 4E594400               uv 00 00  1 1052      
    push rax                              ;#00445903: 120                        vu 00 01  1 1052      
    mov rsi,[rbp-32] (o)                  ;#00445904: 48:213165 E0               uv 40 20  1 1053      
    mov r15,h4                            ;#00445908: 49:277 0000000000000040    vu 8000 00  1 1053      
    cmp rsi,r15                           ;#00445912: 4C:071376                  uv 00 8040  1 1054      
    jl #00445922                          ;#00445915: 174 0B                     v  00 00  1 1054      
    add qword[rbx+rsi*4-16],1             ;#00445917: 48:203104263 F0 01         u  00 48  3 1055      
    cmp eax,677                           ;#0044591D: 075 A5020000               vu 00 01  1 1057      
    push rsi                              ;#00445922: 126                        uv 00 40  1 1058      
    mov rcx,[rbp-24] (name)               ;#00445923: 48:213115 E8               vu 02 20  1 1058      
    mov r15,h4                            ;#00445927: 49:277 0000000000000040    uv 8000 00  1 1059      
    cmp rcx,r15                           ;#00445931: 4C:071371                  uv 00 8002  1 1060 8000   
    jl #00445941                          ;#00445934: 174 0B                     v  00 00  1 1060      
    add qword[rbx+rcx*4-16],1             ;#00445936: 48:203104213 F0 01         u  00 0A  3 1061      
    cmp eax,676                           ;#0044593C: 075 A4020000               vu 00 01  1 1063      
    push rcx                              ;#00445941: 121                        uv 00 02  1 1064      
    mov rdi,[rbp-472] (symtab[756])       ;#00445942: 48:213275 28FEFFFF         vu 80 20  1 1064      
    jmp #004404BD (:%pMkSq)               ;#00445949: 351 6FABFFFF               v  00 00  1 1065      
    mov rcx,33                            ;#0044594E: 48:307301 21000000         uv 02 00  1 1066      
    mov rdx,89                            ;#00445955: 48:307302 59000000         vu 04 00  1 1066      
    call #004428DB (:%opFrame) (sprintf)  ;#0044595C: 350 7ACFFFFF               v  00 00  1 1067      
    mov rdi,[rbp+40] (prevebp)            ;#00445961: 48:213175 28               uv 80 20  1 1068      
    mov rax,[rdi-120]                     ;#00445965: 48:213107 88               uv 01 80  1 1071 80 *80*
    mov [rdi-120],r15                     ;#00445969: 4C:211177 88               vu 00 8080  1 1071      
    mov [rbp] (format),rax                ;#0044596D: 48:211105 00               uv 00 21  1 1072      
    mov rdi,[rbp+40] (prevebp)            ;#00445971: 48:213175 28               vu 80 20  1 1072      
    mov rax,[rdi-472]                     ;#00445975: 48:213207 28FEFFFF         uv 01 80  1 1075    *80*
    xor rbx,rbx                           ;#0044597C: 48:061333                  vu 08 08  1 1075      
    mov r15,h4                            ;#0044597F: 49:277 0000000000000040    uv 8000 00  1 1076      
    cmp rax,r15                           ;#00445989: 4C:071370                  uv 00 8001  1 1077 8000   
    jl #00445999                          ;#0044598C: 174 0B                     v  00 00  1 1077      
    add qword[rbx+rax*4-16],1             ;#0044598E: 48:203104203 F0 01         u  00 09  3 1078      
    cmp eax,756                           ;#00445994: 075 F4020000               vu 00 01  1 1080      
    mov [rbp-8] (args),rax                ;#00445999: 48:211105 F8               uv 00 21  1 1081      
    mov qword[retaddr],#004459AA          ;#0044599D: 48:307105 20 AA594400      vu 00 20  1 1081      
    jmp #0044E450 (code:sprintf)          ;#004459A5: 351 A68A0000               v  00 00  1 1082      
    push rax                              ;#004459AA: 120                        uv 00 01  1 1083      
    mov rsi,[rbp-120] (msg)               ;#004459AB: 48:213165 88               vu 40 20  1 1083      
    mov r15,h4                            ;#004459AF: 49:277 0000000000000040    uv 8000 00  1 1084      
    cmp rsi,r15                           ;#004459B9: 4C:071376                  uv 00 8040  1 1085 8000   
    jle #004459CE                         ;#004459BC: 176 10                     v  00 00  1 1085      
    sub qword[rbx+rsi*4-16],1             ;#004459BE: 48:203154263 F0 01         u  00 48  3 1086      
    jne #004459CE                         ;#004459C4: 165 08                     v  00 00  1 1088      
    mov rdx,rsi                           ;#004459C6: 48:213326                  uv 04 40  1 1089      
    call #004422DA (:%pDealloc)           ;#004459C9: 350 0CC9FFFF               v  00 00  1 1089      
    pop dword[rbp-120] (msg)              ;#004459CE: 217105 88                  np 00 20  3 1090      
    jmp #00446CC1                         ;#004459D1: 351 EB120000               v  00 00  1 1093      
;  2295     elsif msg_id=91     -- e92vhnbaav(ecx)
;  2296        or msg_id=92     -- e92vhnbaav(esi)
;  2297        or msg_id=93     -- e93vhnbaav(edi)
;  2298        or msg_id=94 then    -- e94vhnbaav(edx)
;  2299 --      -- varno in or_edx
;  2300 --      if or_edx<1 or or_edx>length(symtab) then
;  2301 --          si = sprintf("???(varno=%d)",or_edx)
;  2302 --      else
;  2303 --          si = symtab[or_edx]
;  2304 --          if atom(si) then
;  2305 --              si = sprintf("???(atom(symtab[%d]))",or_edx)
;  2306 --          else
;  2307 --              si = symtab[or_edx][S_Name]
;  2308 --              if atom(si) then
;  2309 --                  si = sprintf("???(symtab[%d][S_name]=%d)",{or_edx,si})
;  2310 --              end if
;  2311 --          end if
;  2312 --      end if
;  2313         if msg_id=94 then
    cmp rsi,94                            ;#004459D6: 48:203376 5E               uv 00 40  1 1094      
    jne #00445A34                         ;#004459DA: 165 58                     v  00 00  1 1094      
;  2314             or_esi = or_edx
    mov rcx,[#00402B18] (or_edx)          ;#004459DC: 48:213015 35D1FBFF         uv 02 00  1 1095      
    mov rdx,[#00402B20] (or_esi)          ;#004459E3: 48:213025 36D1FBFF         vu 04 00  1 1095      
    mov r15,h4                            ;#004459EA: 49:277 0000000000000040    uv 8000 00  1 1096      
    cmp rcx,r15                           ;#004459F4: 4C:071371                  uv 00 8002  1 1097 8000   
    jl #00445A04                          ;#004459F7: 174 0B                     v  00 00  1 1097      
    add qword[rbx+rcx*4-16],1             ;#004459F9: 48:203104213 F0 01         u  00 0A  3 1098      
    cmp eax,620                           ;#004459FF: 075 6C020000               vu 00 01  1 1100      
    mov [#00402B20] (or_esi),rcx          ;#00445A04: 48:211015 15D1FBFF         uv 00 02  1 1101      
    mov r15,h4                            ;#00445A0B: 49:277 0000000000000040    vu 8000 00  1 1101      
    cmp rdx,r15                           ;#00445A15: 4C:071372                  uv 00 8004  1 1102      
    jle #00445B42                         ;#00445A18: 017216 24010000            v  00 00  1 1102      
    sub qword[rbx+rdx*4-16],1             ;#00445A1E: 48:203154223 F0 01         u  00 0C  3 1103      
    jne #00445B42                         ;#00445A24: 017205 18010000            v  00 00  1 1105      
    call #004422DA (:%pDealloc)           ;#00445A2A: 350 ABC8FFFF               v  00 00  1 1106      
;  2315 --?{65,or_esi}
    jmp #00445B42                         ;#00445A2F: 351 0E010000               v  00 00  1 1107      
;  2316         elsif msg_id=91 then
    cmp rsi,91                            ;#00445A34: 48:203376 5B               uv 00 40  1 1108      
    jne #00445A92                         ;#00445A38: 165 58                     v  00 00  1 1108      
;  2317             or_esi = or_ecx
    mov rdi,[#00402B08] (or_ecx)          ;#00445A3A: 48:213075 C7D0FBFF         uv 80 00  1 1109      
    mov rdx,[#00402B20] (or_esi)          ;#00445A41: 48:213025 D8D0FBFF         vu 04 00  1 1109      
    mov r15,h4                            ;#00445A48: 49:277 0000000000000040    uv 8000 00  1 1110      
    cmp rdi,r15                           ;#00445A52: 4C:071377                  uv 00 8080  1 1111 8000   
    jl #00445A62                          ;#00445A55: 174 0B                     v  00 00  1 1111      
    add qword[rbx+rdi*4-16],1             ;#00445A57: 48:203104273 F0 01         u  00 88  3 1112      
    cmp eax,618                           ;#00445A5D: 075 6A020000               vu 00 01  1 1114      
    mov [#00402B20] (or_esi),rdi          ;#00445A62: 48:211075 B7D0FBFF         uv 00 80  1 1115      
    mov r15,h4                            ;#00445A69: 49:277 0000000000000040    vu 8000 00  1 1115      
    cmp rdx,r15                           ;#00445A73: 4C:071372                  uv 00 8004  1 1116      
    jle #00445B42                         ;#00445A76: 017216 C6000000            v  00 00  1 1116      
    sub qword[rbx+rdx*4-16],1             ;#00445A7C: 48:203154223 F0 01         u  00 0C  3 1117      
    jne #00445B42                         ;#00445A82: 017205 BA000000            v  00 00  1 1119      
    call #004422DA (:%pDealloc)           ;#00445A88: 350 4DC8FFFF               v  00 00  1 1120      
    jmp #00445B42                         ;#00445A8D: 351 B0000000               v  00 00  1 1121      
;  2318         elsif msg_id=93 then
    cmp rsi,93                            ;#00445A92: 48:203376 5D               uv 00 40  1 1122      
    jne #00445B42                         ;#00445A96: 017205 A6000000            v  00 00  1 1122      
;  2319             or_esi = varIdx(or_edi,rtn,symtab)
    mov rcx,14                            ;#00445A9C: 48:307301 0E000000         uv 02 00  1 1123      
    mov rdx,639                           ;#00445AA3: 48:307302 7F020000         vu 04 00  1 1123      
    call #004428DB (:%opFrame) (varIdx)   ;#00445AAA: 350 2CCEFFFF               v  00 00  1 1124      
    mov rax,[#00402B28] (or_edi)          ;#00445AAF: 48:213005 72D0FBFF         uv 01 00  1 1125      
    mov [rbp] (addr),rax                  ;#00445AB6: 48:211105 00               uv 00 21  1 1126 01   
    mov r15,h4                            ;#00445ABA: 49:277 0000000000000040    vu 8000 00  1 1126      
    cmp rax,r15                           ;#00445AC4: 4C:071370                  uv 00 8001  1 1127      
    jl #00445AD4                          ;#00445AC7: 174 0B                     v  00 00  1 1127      
    add qword[rbx+rax*4-16],1             ;#00445AC9: 48:203104203 F0 01         u  00 09  3 1128      
    cmp eax,622                           ;#00445ACF: 075 6E020000               vu 00 01  1 1130      
    mov rdi,[rbp+40] (prevebp)            ;#00445AD4: 48:213175 28               uv 80 20  1 1131      
    mov rax,[rdi-216]                     ;#00445AD8: 48:213207 28FFFFFF         uv 01 80  1 1134 80 *80*
    mov [rbp-8] (rtn),rax                 ;#00445ADF: 48:211105 F8               uv 00 21  1 1135 01   
    mov rdi,[rbp+40] (prevebp)            ;#00445AE3: 48:213175 28               vu 80 20  1 1135      
    mov rax,[rdi]                         ;#00445AE7: 48:213007                  uv 01 80  1 1138    *80*
    xor rbx,rbx                           ;#00445AEA: 48:061333                  vu 08 08  1 1138      
    mov r15,h4                            ;#00445AED: 49:277 0000000000000040    uv 8000 00  1 1139      
    cmp rax,r15                           ;#00445AF7: 4C:071370                  uv 00 8001  1 1140 8000   
    jl #00445B07                          ;#00445AFA: 174 0B                     v  00 00  1 1140      
    add qword[rbx+rax*4-16],1             ;#00445AFC: 48:203104203 F0 01         u  00 09  3 1141      
    cmp eax,673                           ;#00445B02: 075 A1020000               vu 00 01  1 1143      
    mov [rbp-16] (symtab),rax             ;#00445B07: 48:211105 F0               uv 00 21  1 1144      
    mov qword[retaddr],#00445B18          ;#00445B0B: 48:307105 20 185B4400      vu 00 20  1 1144      
    jmp #0044DE2B (code:varIdx)           ;#00445B13: 351 13830000               v  00 00  1 1145      
    mov rdx,[#00402B20] (or_esi)          ;#00445B18: 48:213025 01D0FBFF         uv 04 00  1 1146      
    mov r15,h4                            ;#00445B1F: 49:277 0000000000000040    vu 8000 00  1 1146      
    cmp rdx,r15                           ;#00445B29: 4C:071372                  uv 00 8004  1 1147      
    mov [#00402B20] (or_esi),rax          ;#00445B2C: 48:211005 EDCFFBFF         vu 00 01  1 1147      
    jle #00445B42                         ;#00445B33: 176 0D                     v  00 00  1 1148      
    sub qword[rbx+rdx*4-16],1             ;#00445B35: 48:203154223 F0 01         u  00 0C  3 1149      
    jne #00445B42                         ;#00445B3B: 165 05                     v  00 00  1 1151      
    call #004422DA (:%pDealloc)           ;#00445B3D: 350 98C7FFFF               v  00 00  1 1152      
;  2320         end if
;  2321         -- varno in or_esi
;  2322         if or_esi<1 or or_esi>length(symtab) then
    mov rdi,1                             ;#00445B42: 48:307307 01000000         uv 80 00  1 1153      
    mov rax,[#00402B20] (or_esi)          ;#00445B49: 48:213005 D0CFFBFF         vu 01 00  1 1153      
    mov rsi,26                            ;#00445B50: 48:307306 1A000000         uv 40 00  1 1154      
    mov rdx,621                           ;#00445B57: 48:307302 6D020000         vu 04 00  1 1154      
    call #0043FA81 (:%opJcc)              ;#00445B5E: 350 1E9FFFFF               v  00 00  1 1155      
    jl #00445B9B                          ;#00445B63: 174 36                     v  00 00  1 1156      
    lea rdi,[rbp-456] (symtab[746])       ;#00445B65: 48:215275 38FEFFFF         uv 80 20  1 1157      
    mov rsi,[rbp] (symtab)                ;#00445B6C: 48:213165 00               vu 40 20  1 1157      
    mov rdx,673                           ;#00445B70: 48:307302 A1020000         uv 04 00  1 1158      
    call #0043F28D (:%opLen)              ;#00445B77: 350 1197FFFF               v  00 00  1 1158      
    mov rdi,rcx                           ;#00445B7C: 48:211317                  uv 80 02  1 1159      
    mov rax,[#00402B20] (or_esi)          ;#00445B7F: 48:213005 9ACFFBFF         vu 01 00  1 1159      
    mov rsi,746                           ;#00445B86: 48:307306 EA020000         uv 40 00  1 1160      
    mov rdx,621                           ;#00445B8D: 48:307302 6D020000         vu 04 00  1 1160      
    call #0043FA81 (:%opJcc)              ;#00445B94: 350 E89EFFFF               v  00 00  1 1161      
    jle #00445C18                         ;#00445B99: 176 7D                     v  00 00  1 1162      
;  2323             si = sprintf("???(varno=%d)",or_esi)
    mov rcx,33                            ;#00445B9B: 48:307301 21000000         uv 02 00  1 1163      
    mov rdx,89                            ;#00445BA2: 48:307302 59000000         vu 04 00  1 1163      
    call #004428DB (:%opFrame) (sprintf)  ;#00445BA9: 350 2DCDFFFF               v  00 00  1 1164      
    mov rdi,qword[#00402C98]              ;#00445BAE: 48:213075 E3D0FBFF         uv 80 00  1 1165      
    mov [rbp] (format),rdi                ;#00445BB5: 48:211175 00               uv 00 A0  1 1166 80   
    add qword[rbx+rdi*4-16],1             ;#00445BB9: 48:203104273 F0 01         u  00 88  3 1168    *80*
    mov rsi,[#00402B20] (or_esi)          ;#00445BBF: 48:213065 5ACFFBFF         vu 40 00  1 1170      
    mov [rbp-8] (args),rsi                ;#00445BC6: 48:211165 F8               uv 00 60  1 1171      
    mov r15,h4                            ;#00445BCA: 49:277 0000000000000040    vu 8000 00  1 1171      
    cmp rsi,r15                           ;#00445BD4: 4C:071376                  uv 00 8040  1 1172      
    jl #00445BDF                          ;#00445BD7: 174 06                     v  00 00  1 1172      
    add qword[rbx+rsi*4-16],1             ;#00445BD9: 48:203104263 F0 01         u  00 48  3 1173      
    mov qword[retaddr],#00445BEC          ;#00445BDF: 48:307105 20 EC5B4400      vu 00 20  1 1175      
    jmp #0044E450 (code:sprintf)          ;#00445BE7: 351 64880000               v  00 00  1 1176      
    push rax                              ;#00445BEC: 120                        uv 00 01  1 1177      
    mov rcx,[rbp-8] (si)                  ;#00445BED: 48:213115 F8               vu 02 20  1 1177      
    mov r15,h4                            ;#00445BF1: 49:277 0000000000000040    uv 8000 00  1 1178      
    cmp rcx,r15                           ;#00445BFB: 4C:071371                  uv 00 8002  1 1179 8000   
    jle #00445C10                         ;#00445BFE: 176 10                     v  00 00  1 1179      
    sub qword[rbx+rcx*4-16],1             ;#00445C00: 48:203154213 F0 01         u  00 0A  3 1180      
    jne #00445C10                         ;#00445C06: 165 08                     v  00 00  1 1182      
    mov rdx,rcx                           ;#00445C08: 48:213321                  uv 04 02  1 1183      
    call #004422DA (:%pDealloc)           ;#00445C0B: 350 CAC6FFFF               v  00 00  1 1183      
    pop dword[rbp-8] (si)                 ;#00445C10: 217105 F8                  np 00 20  3 1184      
    jmp #00445E22                         ;#00445C13: 351 0A020000               v  00 00  1 1187      
;  2324         else
;  2325             si = symtab[or_esi]
    mov rax,[rbp] (symtab)                ;#00445C18: 48:213105 00               uv 01 20  1 1188      
    mov r15,h4                            ;#00445C1C: 49:277 0000000000000040    vu 8000 00  1 1188      
    cmp rax,r15                           ;#00445C26: 4C:071370                  uv 00 8001  1 1189      
    jne #00445C37                         ;#00445C29: 165 0C                     v  00 00  1 1189      
    mov rsi,673                           ;#00445C2B: 48:307306 A1020000         uv 40 00  1 1190      
    call #00442D75 (:%pUnassigned)        ;#00445C32: 350 3ED1FFFF               v  00 00  1 1190      
    mov rdi,[#00402B20] (or_esi)          ;#00445C37: 48:213075 E2CEFBFF         uv 80 00  1 1191      
    mov r15,h4                            ;#00445C3E: 49:277 0000000000000040    vu 8000 00  1 1191      
    cmp rdi,r15                           ;#00445C48: 4C:071377                  uv 00 8080  1 1192      
    jne #00445C59                         ;#00445C4B: 165 0C                     v  00 00  1 1192      
    mov rsi,621                           ;#00445C4D: 48:307306 6D020000         uv 40 00  1 1193      
    call #00442D75 (:%pUnassigned)        ;#00445C54: 350 1CD1FFFF               v  00 00  1 1193      
    lea rcx,[rbp-8] (si)                  ;#00445C59: 48:215115 F8               uv 02 20  1 1194      
    mov rsi,rax                           ;#00445C5D: 48:211306                  vu 40 01  1 1194      
    mov rdx,673                           ;#00445C60: 48:307302 A1020000         uv 04 00  1 1195      
    call #00441675 (:%pSubse1)            ;#00445C67: 350 09BAFFFF               v  00 00  1 1195      
;  2326             if atom(si) then
    mov rsi,[rbp-8] (si)                  ;#00445C6C: 48:213165 F8               uv 40 20  1 1196      
    mov r15,h4                            ;#00445C70: 49:277 0000000000000040    vu 8000 00  1 1196      
    cmp rsi,r15                           ;#00445C7A: 4C:071376                  uv 00 8040  1 1197      
    jl #00445C8A                          ;#00445C7D: 174 0B                     v  00 00  1 1197      
    cmp byte[rbx+rsi*4-1],#12             ;#00445C7F: 200174263 FF 12            u  00 48  2 1198      
    jne #00445D0C                         ;#00445C84: 017205 82000000            v  00 00  1 1199      
;  2327                 si = sprintf("???(atom(symtab[%d]))",or_esi)
    mov rcx,33                            ;#00445C8A: 48:307301 21000000         uv 02 00  1 1200      
    mov rdx,89                            ;#00445C91: 48:307302 59000000         vu 04 00  1 1200      
    call #004428DB (:%opFrame) (sprintf)  ;#00445C98: 350 3ECCFFFF               v  00 00  1 1201      
    mov rcx,qword[#00402C60]              ;#00445C9D: 48:213015 BCCFFBFF         uv 02 00  1 1202      
    mov [rbp] (format),rcx                ;#00445CA4: 48:211115 00               uv 00 22  1 1203 02   
    add qword[rbx+rcx*4-16],1             ;#00445CA8: 48:203104213 F0 01         u  00 0A  3 1205    *02*
    mov rdi,[#00402B20] (or_esi)          ;#00445CAE: 48:213075 6BCEFBFF         vu 80 00  1 1207      
    mov [rbp-8] (args),rdi                ;#00445CB5: 48:211175 F8               uv 00 A0  1 1208      
    mov r15,h4                            ;#00445CB9: 49:277 0000000000000040    vu 8000 00  1 1208      
    cmp rdi,r15                           ;#00445CC3: 4C:071377                  uv 00 8080  1 1209      
    jl #00445CD3                          ;#00445CC6: 174 0B                     v  00 00  1 1209      
    add qword[rbx+rdi*4-16],1             ;#00445CC8: 48:203104273 F0 01         u  00 88  3 1210      
    cmp eax,621                           ;#00445CCE: 075 6D020000               vu 00 01  1 1212      
    mov qword[retaddr],#00445CE0          ;#00445CD3: 48:307105 20 E05C4400      uv 00 20  1 1213      
    jmp #0044E450 (code:sprintf)          ;#00445CDB: 351 70870000               v  00 00  1 1213      
    push rax                              ;#00445CE0: 120                        uv 00 01  1 1214      
    mov rax,[rbp-8] (si)                  ;#00445CE1: 48:213105 F8               vu 01 20  1 1214      
    mov r15,h4                            ;#00445CE5: 49:277 0000000000000040    uv 8000 00  1 1215      
    cmp rax,r15                           ;#00445CEF: 4C:071370                  uv 00 8001  1 1216 8000   
    jle #00445D04                         ;#00445CF2: 176 10                     v  00 00  1 1216      
    sub qword[rbx+rax*4-16],1             ;#00445CF4: 48:203154203 F0 01         u  00 09  3 1217      
    jne #00445D04                         ;#00445CFA: 165 08                     v  00 00  1 1219      
    mov rdx,rax                           ;#00445CFC: 48:213320                  uv 04 01  1 1220      
    call #004422DA (:%pDealloc)           ;#00445CFF: 350 D6C5FFFF               v  00 00  1 1220      
    pop dword[rbp-8] (si)                 ;#00445D04: 217105 F8                  np 00 20  3 1221      
    jmp #00445E22                         ;#00445D07: 351 16010000               v  00 00  1 1224      
;  2328             else
;  2329                 si = si[S_Name]
    mov rdi,1                             ;#00445D0C: 48:307307 01000000         uv 80 00  1 1225      
    lea rcx,[rbp-8] (si)                  ;#00445D13: 48:215115 F8               vu 02 20  1 1225      
    mov rdx,674                           ;#00445D17: 48:307302 A2020000         uv 04 00  1 1226      
    call #00441675 (:%pSubse1)            ;#00445D1E: 350 52B9FFFF               v  00 00  1 1226      
;  2330                 if atom(si) then
    mov rcx,[rbp-8] (si)                  ;#00445D23: 48:213115 F8               uv 02 20  1 1227      
    mov r15,h4                            ;#00445D27: 49:277 0000000000000040    vu 8000 00  1 1227      
    cmp rcx,r15                           ;#00445D31: 4C:071371                  uv 00 8002  1 1228      
    jl #00445D41                          ;#00445D34: 174 0B                     v  00 00  1 1228      
    cmp byte[rbx+rcx*4-1],#12             ;#00445D36: 200174213 FF 12            u  00 0A  2 1229      
    jne #00445E22                         ;#00445D3B: 017205 E1000000            v  00 00  1 1230      
;  2331                     si = sprintf("???(symtab[%d][S_name]=%d)",{or_esi,si})
    lea rax,[rbp-472] (symtab[756])       ;#00445D41: 48:215205 28FEFFFF         uv 01 20  1 1231      
    mov rdx,2                             ;#00445D48: 48:307302 02000000         vu 04 00  1 1231      
    push #00445D9E                        ;#00445D4F: 150 9E5D4400               uv 00 00  1 1232      
    push rax                              ;#00445D54: 120                        vu 00 01  1 1232      
    mov r15,h4                            ;#00445D55: 49:277 0000000000000040    uv 8000 00  1 1233      
    cmp rcx,r15                           ;#00445D5F: 4C:071371                  uv 00 8002  1 1234 8000   
    jl #00445D6F                          ;#00445D62: 174 0B                     v  00 00  1 1234      
    add qword[rbx+rcx*4-16],1             ;#00445D64: 48:203104213 F0 01         u  00 0A  3 1235      
    cmp eax,674                           ;#00445D6A: 075 A2020000               vu 00 01  1 1237      
    push rcx                              ;#00445D6F: 121                        uv 00 02  1 1238      
    mov rdi,[#00402B20] (or_esi)          ;#00445D70: 48:213075 A9CDFBFF         vu 80 00  1 1238      
    mov r15,h4                            ;#00445D77: 49:277 0000000000000040    uv 8000 00  1 1239      
    cmp rdi,r15                           ;#00445D81: 4C:071377                  uv 00 8080  1 1240 8000   
    jl #00445D91                          ;#00445D84: 174 0B                     v  00 00  1 1240      
    add qword[rbx+rdi*4-16],1             ;#00445D86: 48:203104273 F0 01         u  00 88  3 1241      
    cmp eax,621                           ;#00445D8C: 075 6D020000               vu 00 01  1 1243      
    push rdi                              ;#00445D91: 127                        uv 00 80  1 1244      
    mov rdi,[rbp-472] (symtab[756])       ;#00445D92: 48:213275 28FEFFFF         vu 80 20  1 1244      
    jmp #004404BD (:%pMkSq)               ;#00445D99: 351 1FA7FFFF               v  00 00  1 1245      
    mov rcx,33                            ;#00445D9E: 48:307301 21000000         uv 02 00  1 1246      
    mov rdx,89                            ;#00445DA5: 48:307302 59000000         vu 04 00  1 1246      
    call #004428DB (:%opFrame) (sprintf)  ;#00445DAC: 350 2ACBFFFF               v  00 00  1 1247      
    mov rax,qword[#00402C68]              ;#00445DB1: 48:213005 B0CEFBFF         uv 01 00  1 1248      
    mov [rbp] (format),rax                ;#00445DB8: 48:211105 00               uv 00 21  1 1249 01   
    add qword[rbx+rax*4-16],1             ;#00445DBC: 48:203104203 F0 01         u  00 09  3 1251    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00445DC2: 48:213175 28               vu 80 20  1 1253      
    mov rax,[rdi-472]                     ;#00445DC6: 48:213207 28FEFFFF         uv 01 80  1 1256    *80*
    xor rbx,rbx                           ;#00445DCD: 48:061333                  vu 08 08  1 1256      
    mov r15,h4                            ;#00445DD0: 49:277 0000000000000040    uv 8000 00  1 1257      
    cmp rax,r15                           ;#00445DDA: 4C:071370                  uv 00 8001  1 1258 8000   
    jl #00445DEA                          ;#00445DDD: 174 0B                     v  00 00  1 1258      
    add qword[rbx+rax*4-16],1             ;#00445DDF: 48:203104203 F0 01         u  00 09  3 1259      
    cmp eax,756                           ;#00445DE5: 075 F4020000               vu 00 01  1 1261      
    mov [rbp-8] (args),rax                ;#00445DEA: 48:211105 F8               uv 00 21  1 1262      
    mov qword[retaddr],#00445DFB          ;#00445DEE: 48:307105 20 FB5D4400      vu 00 20  1 1262      
    jmp #0044E450 (code:sprintf)          ;#00445DF6: 351 55860000               v  00 00  1 1263      
    push rax                              ;#00445DFB: 120                        uv 00 01  1 1264      
    mov rsi,[rbp-8] (si)                  ;#00445DFC: 48:213165 F8               vu 40 20  1 1264      
    mov r15,h4                            ;#00445E00: 49:277 0000000000000040    uv 8000 00  1 1265      
    cmp rsi,r15                           ;#00445E0A: 4C:071376                  uv 00 8040  1 1266 8000   
    jle #00445E1F                         ;#00445E0D: 176 10                     v  00 00  1 1266      
    sub qword[rbx+rsi*4-16],1             ;#00445E0F: 48:203154263 F0 01         u  00 48  3 1267      
    jne #00445E1F                         ;#00445E15: 165 08                     v  00 00  1 1269      
    mov rdx,rsi                           ;#00445E17: 48:213326                  uv 04 40  1 1270      
    call #004422DA (:%pDealloc)           ;#00445E1A: 350 BBC4FFFF               v  00 00  1 1270      
    pop dword[rbp-8] (si)                 ;#00445E1F: 217105 F8                  np 00 20  3 1271      
;  2332                 end if
;  2333             end if
;  2334         end if
;  2335         msg = sprintf(msg,{si})
    lea rax,[rbp-472] (symtab[756])       ;#00445E22: 48:215205 28FEFFFF         uv 01 20  1 1274      
    mov rdx,1                             ;#00445E29: 48:307302 01000000         vu 04 00  1 1274      
    push #00445E61                        ;#00445E30: 150 615E4400               uv 00 00  1 1275      
    push rax                              ;#00445E35: 120                        vu 00 01  1 1275      
    mov rcx,[rbp-8] (si)                  ;#00445E36: 48:213115 F8               uv 02 20  1 1276      
    mov r15,h4                            ;#00445E3A: 49:277 0000000000000040    vu 8000 00  1 1276      
    cmp rcx,r15                           ;#00445E44: 4C:071371                  uv 00 8002  1 1277      
    jl #00445E54                          ;#00445E47: 174 0B                     v  00 00  1 1277      
    add qword[rbx+rcx*4-16],1             ;#00445E49: 48:203104213 F0 01         u  00 0A  3 1278      
    cmp eax,674                           ;#00445E4F: 075 A2020000               vu 00 01  1 1280      
    push rcx                              ;#00445E54: 121                        uv 00 02  1 1281      
    mov rdi,[rbp-472] (symtab[756])       ;#00445E55: 48:213275 28FEFFFF         vu 80 20  1 1281      
    jmp #004404BD (:%pMkSq)               ;#00445E5C: 351 5CA6FFFF               v  00 00  1 1282      
    mov rcx,33                            ;#00445E61: 48:307301 21000000         uv 02 00  1 1283      
    mov rdx,89                            ;#00445E68: 48:307302 59000000         vu 04 00  1 1283      
    call #004428DB (:%opFrame) (sprintf)  ;#00445E6F: 350 67CAFFFF               v  00 00  1 1284      
    mov rdi,[rbp+40] (prevebp)            ;#00445E74: 48:213175 28               uv 80 20  1 1285      
    mov rax,[rdi-120]                     ;#00445E78: 48:213107 88               uv 01 80  1 1288 80 *80*
    mov [rdi-120],r15                     ;#00445E7C: 4C:211177 88               vu 00 8080  1 1288      
    mov [rbp] (format),rax                ;#00445E80: 48:211105 00               uv 00 21  1 1289      
    mov rdi,[rbp+40] (prevebp)            ;#00445E84: 48:213175 28               vu 80 20  1 1289      
    mov rax,[rdi-472]                     ;#00445E88: 48:213207 28FEFFFF         uv 01 80  1 1292    *80*
    xor rbx,rbx                           ;#00445E8F: 48:061333                  vu 08 08  1 1292      
    mov r15,h4                            ;#00445E92: 49:277 0000000000000040    uv 8000 00  1 1293      
    cmp rax,r15                           ;#00445E9C: 4C:071370                  uv 00 8001  1 1294 8000   
    jl #00445EAC                          ;#00445E9F: 174 0B                     v  00 00  1 1294      
    add qword[rbx+rax*4-16],1             ;#00445EA1: 48:203104203 F0 01         u  00 09  3 1295      
    cmp eax,756                           ;#00445EA7: 075 F4020000               vu 00 01  1 1297      
    mov [rbp-8] (args),rax                ;#00445EAC: 48:211105 F8               uv 00 21  1 1298      
    mov qword[retaddr],#00445EBD          ;#00445EB0: 48:307105 20 BD5E4400      vu 00 20  1 1298      
    jmp #0044E450 (code:sprintf)          ;#00445EB8: 351 93850000               v  00 00  1 1299      
    push rax                              ;#00445EBD: 120                        uv 00 01  1 1300      
    mov rsi,[rbp-120] (msg)               ;#00445EBE: 48:213165 88               vu 40 20  1 1300      
    mov r15,h4                            ;#00445EC2: 49:277 0000000000000040    uv 8000 00  1 1301      
    cmp rsi,r15                           ;#00445ECC: 4C:071376                  uv 00 8040  1 1302 8000   
    jle #00445EE1                         ;#00445ECF: 176 10                     v  00 00  1 1302      
    sub qword[rbx+rsi*4-16],1             ;#00445ED1: 48:203154263 F0 01         u  00 48  3 1303      
    jne #00445EE1                         ;#00445ED7: 165 08                     v  00 00  1 1305      
    mov rdx,rsi                           ;#00445ED9: 48:213326                  uv 04 40  1 1306      
    call #004422DA (:%pDealloc)           ;#00445EDC: 350 F9C3FFFF               v  00 00  1 1306      
    pop dword[rbp-120] (msg)              ;#00445EE1: 217105 88                  np 00 20  3 1307      
;  2336 --?msg
;  2337 --?1
    jmp #00446CC1                         ;#00445EE4: 351 D80D0000               v  00 00  1 1310      
;  2338     elsif msg_id=32 then        -- e32hc(era,edi)
;  2339         msg = sprintf(msg,{or_era,or_edi})
    lea rax,[rbp-472] (symtab[756])       ;#00445EE9: 48:215205 28FEFFFF         uv 01 20  1 1311      
    mov rdx,2                             ;#00445EF0: 48:307302 02000000         vu 04 00  1 1311      
    push #00445F4D                        ;#00445EF7: 150 4D5F4400               uv 00 00  1 1312      
    push rax                              ;#00445EFC: 120                        vu 00 01  1 1312      
    mov rcx,[#00402B28] (or_edi)          ;#00445EFD: 48:213015 24CCFBFF         uv 02 00  1 1313      
    mov r15,h4                            ;#00445F04: 49:277 0000000000000040    vu 8000 00  1 1313      
    cmp rcx,r15                           ;#00445F0E: 4C:071371                  uv 00 8002  1 1314      
    jl #00445F1E                          ;#00445F11: 174 0B                     v  00 00  1 1314      
    add qword[rbx+rcx*4-16],1             ;#00445F13: 48:203104213 F0 01         u  00 0A  3 1315      
    cmp eax,622                           ;#00445F19: 075 6E020000               vu 00 01  1 1317      
    push rcx                              ;#00445F1E: 121                        uv 00 02  1 1318      
    mov rdi,[#00402B10] (or_era)          ;#00445F1F: 48:213075 EACBFBFF         vu 80 00  1 1318      
    mov r15,h4                            ;#00445F26: 49:277 0000000000000040    uv 8000 00  1 1319      
    cmp rdi,r15                           ;#00445F30: 4C:071377                  uv 00 8080  1 1320 8000   
    jl #00445F40                          ;#00445F33: 174 0B                     v  00 00  1 1320      
    add qword[rbx+rdi*4-16],1             ;#00445F35: 48:203104273 F0 01         u  00 88  3 1321      
    cmp eax,619                           ;#00445F3B: 075 6B020000               vu 00 01  1 1323      
    push rdi                              ;#00445F40: 127                        uv 00 80  1 1324      
    mov rdi,[rbp-472] (symtab[756])       ;#00445F41: 48:213275 28FEFFFF         vu 80 20  1 1324      
    jmp #004404BD (:%pMkSq)               ;#00445F48: 351 70A5FFFF               v  00 00  1 1325      
    mov rcx,33                            ;#00445F4D: 48:307301 21000000         uv 02 00  1 1326      
    mov rdx,89                            ;#00445F54: 48:307302 59000000         vu 04 00  1 1326      
    call #004428DB (:%opFrame) (sprintf)  ;#00445F5B: 350 7BC9FFFF               v  00 00  1 1327      
    mov rdi,[rbp+40] (prevebp)            ;#00445F60: 48:213175 28               uv 80 20  1 1328      
    mov rax,[rdi-120]                     ;#00445F64: 48:213107 88               uv 01 80  1 1331 80 *80*
    mov [rdi-120],r15                     ;#00445F68: 4C:211177 88               vu 00 8080  1 1331      
    mov [rbp] (format),rax                ;#00445F6C: 48:211105 00               uv 00 21  1 1332      
    mov rdi,[rbp+40] (prevebp)            ;#00445F70: 48:213175 28               vu 80 20  1 1332      
    mov rax,[rdi-472]                     ;#00445F74: 48:213207 28FEFFFF         uv 01 80  1 1335    *80*
    xor rbx,rbx                           ;#00445F7B: 48:061333                  vu 08 08  1 1335      
    mov r15,h4                            ;#00445F7E: 49:277 0000000000000040    uv 8000 00  1 1336      
    cmp rax,r15                           ;#00445F88: 4C:071370                  uv 00 8001  1 1337 8000   
    jl #00445F98                          ;#00445F8B: 174 0B                     v  00 00  1 1337      
    add qword[rbx+rax*4-16],1             ;#00445F8D: 48:203104203 F0 01         u  00 09  3 1338      
    cmp eax,756                           ;#00445F93: 075 F4020000               vu 00 01  1 1340      
    mov [rbp-8] (args),rax                ;#00445F98: 48:211105 F8               uv 00 21  1 1341      
    mov qword[retaddr],#00445FA9          ;#00445F9C: 48:307105 20 A95F4400      vu 00 20  1 1341      
    jmp #0044E450 (code:sprintf)          ;#00445FA4: 351 A7840000               v  00 00  1 1342      
    push rax                              ;#00445FA9: 120                        uv 00 01  1 1343      
    mov rsi,[rbp-120] (msg)               ;#00445FAA: 48:213165 88               vu 40 20  1 1343      
    mov r15,h4                            ;#00445FAE: 49:277 0000000000000040    uv 8000 00  1 1344      
    cmp rsi,r15                           ;#00445FB8: 4C:071376                  uv 00 8040  1 1345 8000   
    jle #00445FCD                         ;#00445FBB: 176 10                     v  00 00  1 1345      
    sub qword[rbx+rsi*4-16],1             ;#00445FBD: 48:203154263 F0 01         u  00 48  3 1346      
    jne #00445FCD                         ;#00445FC3: 165 08                     v  00 00  1 1348      
    mov rdx,rsi                           ;#00445FC5: 48:213326                  uv 04 40  1 1349      
    call #004422DA (:%pDealloc)           ;#00445FC8: 350 0DC3FFFF               v  00 00  1 1349      
    pop dword[rbp-120] (msg)              ;#00445FCD: 217105 88                  np 00 20  3 1350      
;  2340         or_era = or_edi
    mov rcx,[#00402B28] (or_edi)          ;#00445FD0: 48:213015 51CBFBFF         uv 02 00  1 1353      
    mov rdx,[#00402B10] (or_era)          ;#00445FD7: 48:213025 32CBFBFF         vu 04 00  1 1353      
    mov r15,h4                            ;#00445FDE: 49:277 0000000000000040    uv 8000 00  1 1354      
    cmp rcx,r15                           ;#00445FE8: 4C:071371                  uv 00 8002  1 1355 8000   
    jl #00445FF8                          ;#00445FEB: 174 0B                     v  00 00  1 1355      
    add qword[rbx+rcx*4-16],1             ;#00445FED: 48:203104213 F0 01         u  00 0A  3 1356      
    cmp eax,622                           ;#00445FF3: 075 6E020000               vu 00 01  1 1358      
    mov [#00402B10] (or_era),rcx          ;#00445FF8: 48:211015 11CBFBFF         uv 00 02  1 1359      
    mov r15,h4                            ;#00445FFF: 49:277 0000000000000040    vu 8000 00  1 1359      
    cmp rdx,r15                           ;#00446009: 4C:071372                  uv 00 8004  1 1360      
    jle #00446CC1                         ;#0044600C: 017216 AF0C0000            v  00 00  1 1360      
    sub qword[rbx+rdx*4-16],1             ;#00446012: 48:203154223 F0 01         u  00 0C  3 1361      
    jne #00446CC1                         ;#00446018: 017205 A30C0000            v  00 00  1 1363      
    call #004422DA (:%pDealloc)           ;#0044601E: 350 B7C2FFFF               v  00 00  1 1364      
    jmp #00446CC1                         ;#00446023: 351 990C0000               v  00 00  1 1365      
;  2341     elsif msg_id=58 then        -- e58bfn(edi)
;  2342         msg = sprintf(msg,or_edi)
    mov rcx,33                            ;#00446028: 48:307301 21000000         uv 02 00  1 1366      
    mov rdx,89                            ;#0044602F: 48:307302 59000000         vu 04 00  1 1366      
    call #004428DB (:%opFrame) (sprintf)  ;#00446036: 350 A0C8FFFF               v  00 00  1 1367      
    mov rdi,[rbp+40] (prevebp)            ;#0044603B: 48:213175 28               uv 80 20  1 1368      
    mov rax,[rdi-120]                     ;#0044603F: 48:213107 88               uv 01 80  1 1371 80 *80*
    mov [rdi-120],r15                     ;#00446043: 4C:211177 88               vu 00 8080  1 1371      
    mov [rbp] (format),rax                ;#00446047: 48:211105 00               uv 00 21  1 1372      
    mov rdi,[#00402B28] (or_edi)          ;#0044604B: 48:213075 D6CAFBFF         vu 80 00  1 1372      
    mov [rbp-8] (args),rdi                ;#00446052: 48:211175 F8               uv 00 A0  1 1373      
    mov r15,h4                            ;#00446056: 49:277 0000000000000040    vu 8000 00  1 1373      
    cmp rdi,r15                           ;#00446060: 4C:071377                  uv 00 8080  1 1374      
    jl #00446070                          ;#00446063: 174 0B                     v  00 00  1 1374      
    add qword[rbx+rdi*4-16],1             ;#00446065: 48:203104273 F0 01         u  00 88  3 1375      
    cmp eax,622                           ;#0044606B: 075 6E020000               vu 00 01  1 1377      
    mov qword[retaddr],#0044607D          ;#00446070: 48:307105 20 7D604400      uv 00 20  1 1378      
    jmp #0044E450 (code:sprintf)          ;#00446078: 351 D3830000               v  00 00  1 1378      
    push rax                              ;#0044607D: 120                        uv 00 01  1 1379      
    mov rsi,[rbp-120] (msg)               ;#0044607E: 48:213165 88               vu 40 20  1 1379      
    mov r15,h4                            ;#00446082: 49:277 0000000000000040    uv 8000 00  1 1380      
    cmp rsi,r15                           ;#0044608C: 4C:071376                  uv 00 8040  1 1381 8000   
    jle #004460A1                         ;#0044608F: 176 10                     v  00 00  1 1381      
    sub qword[rbx+rsi*4-16],1             ;#00446091: 48:203154263 F0 01         u  00 48  3 1382      
    jne #004460A1                         ;#00446097: 165 08                     v  00 00  1 1384      
    mov rdx,rsi                           ;#00446099: 48:213326                  uv 04 40  1 1385      
    call #004422DA (:%pDealloc)           ;#0044609C: 350 39C2FFFF               v  00 00  1 1385      
    pop dword[rbp-120] (msg)              ;#004460A1: 217105 88                  np 00 20  3 1386      
    jmp #00446CC1                         ;#004460A4: 351 180C0000               v  00 00  1 1389      
;  2343     elsif msg_id=120 then       -- e120fle
;  2344 --      c = varIdx(ep1)
;  2345         if or_esi=1 then
    mov rdi,1                             ;#004460A9: 48:307307 01000000         uv 80 00  1 1390      
    mov rax,[#00402B20] (or_esi)          ;#004460B0: 48:213005 69CAFBFF         vu 01 00  1 1390      
    mov rsi,26                            ;#004460B7: 48:307306 1A000000         uv 40 00  1 1391      
    mov rdx,621                           ;#004460BE: 48:307302 6D020000         vu 04 00  1 1391      
    call #0043FAF6 (:%opJccE)             ;#004460C5: 350 2C9AFFFF               v  00 00  1 1392      
    jne #00446119                         ;#004460CA: 165 4D                     v  00 00  1 1393      
;  2346             name = "init"
    mov rcx,qword[#00402CA8]              ;#004460CC: 48:213015 D5CBFBFF         uv 02 00  1 1394      
    mov rdx,[rbp-24] (name)               ;#004460D3: 48:213125 E8               vu 04 20  1 1394      
    mov r15,h4                            ;#004460D7: 49:277 0000000000000040    uv 8000 00  1 1395      
    cmp rcx,r15                           ;#004460E1: 4C:071371                  uv 00 8002  1 1396 8000   
    jl #004460EC                          ;#004460E4: 174 06                     v  00 00  1 1396      
    add qword[rbx+rcx*4-16],1             ;#004460E6: 48:203104213 F0 01         u  00 0A  3 1397      
    mov [rbp-24] (name),rcx               ;#004460EC: 48:211115 E8               vu 00 22  1 1399      
    mov r15,h4                            ;#004460F0: 49:277 0000000000000040    uv 8000 00  1 1400      
    cmp rdx,r15                           ;#004460FA: 4C:071372                  uv 00 8004  1 1401 8000   
    jle #0044622E                         ;#004460FD: 017216 2B010000            v  00 00  1 1401      
    sub qword[rbx+rdx*4-16],1             ;#00446103: 48:203154223 F0 01         u  00 0C  3 1402      
    jne #0044622E                         ;#00446109: 017205 1F010000            v  00 00  1 1404      
    call #004422DA (:%pDealloc)           ;#0044610F: 350 C6C1FFFF               v  00 00  1 1405      
    jmp #0044622E                         ;#00446114: 351 15010000               v  00 00  1 1406      
;  2347         elsif or_esi=2 then
    mov rdi,2                             ;#00446119: 48:307307 02000000         uv 80 00  1 1407      
    mov rax,[#00402B20] (or_esi)          ;#00446120: 48:213005 F9C9FBFF         vu 01 00  1 1407      
    mov rsi,39                            ;#00446127: 48:307306 27000000         uv 40 00  1 1408      
    mov rdx,621                           ;#0044612E: 48:307302 6D020000         vu 04 00  1 1408      
    call #0043FAF6 (:%opJccE)             ;#00446135: 350 BC99FFFF               v  00 00  1 1409      
    jne #00446189                         ;#0044613A: 165 4D                     v  00 00  1 1410      
;  2348             name = "limit"
    mov rdi,qword[#00402CB0]              ;#0044613C: 48:213075 6DCBFBFF         uv 80 00  1 1411      
    mov rdx,[rbp-24] (name)               ;#00446143: 48:213125 E8               vu 04 20  1 1411      
    mov r15,h4                            ;#00446147: 49:277 0000000000000040    uv 8000 00  1 1412      
    cmp rdi,r15                           ;#00446151: 4C:071377                  uv 00 8080  1 1413 8000   
    jl #0044615C                          ;#00446154: 174 06                     v  00 00  1 1413      
    add qword[rbx+rdi*4-16],1             ;#00446156: 48:203104273 F0 01         u  00 88  3 1414      
    mov [rbp-24] (name),rdi               ;#0044615C: 48:211175 E8               vu 00 A0  1 1416      
    mov r15,h4                            ;#00446160: 49:277 0000000000000040    uv 8000 00  1 1417      
    cmp rdx,r15                           ;#0044616A: 4C:071372                  uv 00 8004  1 1418 8000   
    jle #0044622E                         ;#0044616D: 017216 BB000000            v  00 00  1 1418      
    sub qword[rbx+rdx*4-16],1             ;#00446173: 48:203154223 F0 01         u  00 0C  3 1419      
    jne #0044622E                         ;#00446179: 017205 AF000000            v  00 00  1 1421      
    call #004422DA (:%pDealloc)           ;#0044617F: 350 56C1FFFF               v  00 00  1 1422      
    jmp #0044622E                         ;#00446184: 351 A5000000               v  00 00  1 1423      
;  2349         elsif or_esi=4 then
    mov rdi,4                             ;#00446189: 48:307307 04000000         uv 80 00  1 1424      
    mov rax,[#00402B20] (or_esi)          ;#00446190: 48:213005 89C9FBFF         vu 01 00  1 1424      
    mov rsi,41                            ;#00446197: 48:307306 29000000         uv 40 00  1 1425      
    mov rdx,621                           ;#0044619E: 48:307302 6D020000         vu 04 00  1 1425      
    call #0043FAF6 (:%opJccE)             ;#004461A5: 350 4C99FFFF               v  00 00  1 1426      
    jne #004461EE                         ;#004461AA: 165 42                     v  00 00  1 1427      
;  2350             name = "step"
    mov rsi,qword[#00402CB8]              ;#004461AC: 48:213065 05CBFBFF         uv 40 00  1 1428      
    mov rdx,[rbp-24] (name)               ;#004461B3: 48:213125 E8               vu 04 20  1 1428      
    mov r15,h4                            ;#004461B7: 49:277 0000000000000040    uv 8000 00  1 1429      
    cmp rsi,r15                           ;#004461C1: 4C:071376                  uv 00 8040  1 1430 8000   
    jl #004461CC                          ;#004461C4: 174 06                     v  00 00  1 1430      
    add qword[rbx+rsi*4-16],1             ;#004461C6: 48:203104263 F0 01         u  00 48  3 1431      
    mov [rbp-24] (name),rsi               ;#004461CC: 48:211165 E8               vu 00 60  1 1433      
    mov r15,h4                            ;#004461D0: 49:277 0000000000000040    uv 8000 00  1 1434      
    cmp rdx,r15                           ;#004461DA: 4C:071372                  uv 00 8004  1 1435 8000   
    jle #0044622E                         ;#004461DD: 176 4F                     v  00 00  1 1435      
    sub qword[rbx+rdx*4-16],1             ;#004461DF: 48:203154223 F0 01         u  00 0C  3 1436      
    jne #0044622E                         ;#004461E5: 165 47                     v  00 00  1 1438      
    call #004422DA (:%pDealloc)           ;#004461E7: 350 EEC0FFFF               v  00 00  1 1439      
    jmp #0044622E                         ;#004461EC: 353 40                     v  00 00  1 1440      
;  2351         else
;  2352             name = "???"
    mov rcx,qword[#00402C50]              ;#004461EE: 48:213015 5BCAFBFF         uv 02 00  1 1441      
    mov rdx,[rbp-24] (name)               ;#004461F5: 48:213125 E8               vu 04 20  1 1441      
    mov r15,h4                            ;#004461F9: 49:277 0000000000000040    uv 8000 00  1 1442      
    cmp rcx,r15                           ;#00446203: 4C:071371                  uv 00 8002  1 1443 8000   
    jl #0044620E                          ;#00446206: 174 06                     v  00 00  1 1443      
    add qword[rbx+rcx*4-16],1             ;#00446208: 48:203104213 F0 01         u  00 0A  3 1444      
    mov [rbp-24] (name),rcx               ;#0044620E: 48:211115 E8               vu 00 22  1 1446      
    mov r15,h4                            ;#00446212: 49:277 0000000000000040    uv 8000 00  1 1447      
    cmp rdx,r15                           ;#0044621C: 4C:071372                  uv 00 8004  1 1448 8000   
    jle #0044622E                         ;#0044621F: 176 0D                     v  00 00  1 1448      
    sub qword[rbx+rdx*4-16],1             ;#00446221: 48:203154223 F0 01         u  00 0C  3 1449      
    jne #0044622E                         ;#00446227: 165 05                     v  00 00  1 1451      
    call #004422DA (:%pDealloc)           ;#00446229: 350 ACC0FFFF               v  00 00  1 1452      
;  2353         end if
;  2354         if or_edi<1 or or_edi>length(symtab) then
    mov rdi,1                             ;#0044622E: 48:307307 01000000         uv 80 00  1 1453      
    mov rax,[#00402B28] (or_edi)          ;#00446235: 48:213005 ECC8FBFF         vu 01 00  1 1453      
    mov rsi,26                            ;#0044623C: 48:307306 1A000000         uv 40 00  1 1454      
    mov rdx,622                           ;#00446243: 48:307302 6E020000         vu 04 00  1 1454      
    call #0043FA81 (:%opJcc)              ;#0044624A: 350 3298FFFF               v  00 00  1 1455      
    jl #00446287                          ;#0044624F: 174 36                     v  00 00  1 1456      
    lea rdi,[rbp-456] (symtab[746])       ;#00446251: 48:215275 38FEFFFF         uv 80 20  1 1457      
    mov rsi,[rbp] (symtab)                ;#00446258: 48:213165 00               vu 40 20  1 1457      
    mov rdx,673                           ;#0044625C: 48:307302 A1020000         uv 04 00  1 1458      
    call #0043F28D (:%opLen)              ;#00446263: 350 2590FFFF               v  00 00  1 1458      
    mov rdi,rcx                           ;#00446268: 48:211317                  uv 80 02  1 1459      
    mov rax,[#00402B28] (or_edi)          ;#0044626B: 48:213005 B6C8FBFF         vu 01 00  1 1459      
    mov rsi,746                           ;#00446272: 48:307306 EA020000         uv 40 00  1 1460      
    mov rdx,622                           ;#00446279: 48:307302 6E020000         vu 04 00  1 1460      
    call #0043FA81 (:%opJcc)              ;#00446280: 350 FC97FFFF               v  00 00  1 1461      
    jle #00446304                         ;#00446285: 176 7D                     v  00 00  1 1462      
;  2355             o = sprintf("???(varno=%d)",or_edi)
    mov rcx,33                            ;#00446287: 48:307301 21000000         uv 02 00  1 1463      
    mov rdx,89                            ;#0044628E: 48:307302 59000000         vu 04 00  1 1463      
    call #004428DB (:%opFrame) (sprintf)  ;#00446295: 350 41C6FFFF               v  00 00  1 1464      
    mov rdi,qword[#00402C98]              ;#0044629A: 48:213075 F7C9FBFF         uv 80 00  1 1465      
    mov [rbp] (format),rdi                ;#004462A1: 48:211175 00               uv 00 A0  1 1466 80   
    add qword[rbx+rdi*4-16],1             ;#004462A5: 48:203104273 F0 01         u  00 88  3 1468    *80*
    mov rsi,[#00402B28] (or_edi)          ;#004462AB: 48:213065 76C8FBFF         vu 40 00  1 1470      
    mov [rbp-8] (args),rsi                ;#004462B2: 48:211165 F8               uv 00 60  1 1471      
    mov r15,h4                            ;#004462B6: 49:277 0000000000000040    vu 8000 00  1 1471      
    cmp rsi,r15                           ;#004462C0: 4C:071376                  uv 00 8040  1 1472      
    jl #004462CB                          ;#004462C3: 174 06                     v  00 00  1 1472      
    add qword[rbx+rsi*4-16],1             ;#004462C5: 48:203104263 F0 01         u  00 48  3 1473      
    mov qword[retaddr],#004462D8          ;#004462CB: 48:307105 20 D8624400      vu 00 20  1 1475      
    jmp #0044E450 (code:sprintf)          ;#004462D3: 351 78810000               v  00 00  1 1476      
    push rax                              ;#004462D8: 120                        uv 00 01  1 1477      
    mov rcx,[rbp-32] (o)                  ;#004462D9: 48:213115 E0               vu 02 20  1 1477      
    mov r15,h4                            ;#004462DD: 49:277 0000000000000040    uv 8000 00  1 1478      
    cmp rcx,r15                           ;#004462E7: 4C:071371                  uv 00 8002  1 1479 8000   
    jle #004462FC                         ;#004462EA: 176 10                     v  00 00  1 1479      
    sub qword[rbx+rcx*4-16],1             ;#004462EC: 48:203154213 F0 01         u  00 0A  3 1480      
    jne #004462FC                         ;#004462F2: 165 08                     v  00 00  1 1482      
    mov rdx,rcx                           ;#004462F4: 48:213321                  uv 04 02  1 1483      
    call #004422DA (:%pDealloc)           ;#004462F7: 350 DEBFFFFF               v  00 00  1 1483      
    pop dword[rbp-32] (o)                 ;#004462FC: 217105 E0                  np 00 20  3 1484      
    jmp #00446861                         ;#004462FF: 351 5D050000               v  00 00  1 1487      
;  2356         else
;  2357             si = symtab[or_edi]
    mov rax,[rbp] (symtab)                ;#00446304: 48:213105 00               uv 01 20  1 1488      
    mov r15,h4                            ;#00446308: 49:277 0000000000000040    vu 8000 00  1 1488      
    cmp rax,r15                           ;#00446312: 4C:071370                  uv 00 8001  1 1489      
    jne #00446323                         ;#00446315: 165 0C                     v  00 00  1 1489      
    mov rsi,673                           ;#00446317: 48:307306 A1020000         uv 40 00  1 1490      
    call #00442D75 (:%pUnassigned)        ;#0044631E: 350 52CAFFFF               v  00 00  1 1490      
    mov rdi,[#00402B28] (or_edi)          ;#00446323: 48:213075 FEC7FBFF         uv 80 00  1 1491      
    mov r15,h4                            ;#0044632A: 49:277 0000000000000040    vu 8000 00  1 1491      
    cmp rdi,r15                           ;#00446334: 4C:071377                  uv 00 8080  1 1492      
    jne #00446345                         ;#00446337: 165 0C                     v  00 00  1 1492      
    mov rsi,622                           ;#00446339: 48:307306 6E020000         uv 40 00  1 1493      
    call #00442D75 (:%pUnassigned)        ;#00446340: 350 30CAFFFF               v  00 00  1 1493      
    lea rcx,[rbp-8] (si)                  ;#00446345: 48:215115 F8               uv 02 20  1 1494      
    mov rsi,rax                           ;#00446349: 48:211306                  vu 40 01  1 1494      
    mov rdx,673                           ;#0044634C: 48:307302 A1020000         uv 04 00  1 1495      
    call #00441675 (:%pSubse1)            ;#00446353: 350 1DB3FFFF               v  00 00  1 1495      
;  2358             if atom(si) then
    mov rsi,[rbp-8] (si)                  ;#00446358: 48:213165 F8               uv 40 20  1 1496      
    mov r15,h4                            ;#0044635C: 49:277 0000000000000040    vu 8000 00  1 1496      
    cmp rsi,r15                           ;#00446366: 4C:071376                  uv 00 8040  1 1497      
    jl #00446376                          ;#00446369: 174 0B                     v  00 00  1 1497      
    cmp byte[rbx+rsi*4-1],#12             ;#0044636B: 200174263 FF 12            u  00 48  2 1498      
    jne #004463F8                         ;#00446370: 017205 82000000            v  00 00  1 1499      
;  2359                 o = sprintf("???(atom(symtab[%d]))",or_edi)
    mov rcx,33                            ;#00446376: 48:307301 21000000         uv 02 00  1 1500      
    mov rdx,89                            ;#0044637D: 48:307302 59000000         vu 04 00  1 1500      
    call #004428DB (:%opFrame) (sprintf)  ;#00446384: 350 52C5FFFF               v  00 00  1 1501      
    mov rcx,qword[#00402C60]              ;#00446389: 48:213015 D0C8FBFF         uv 02 00  1 1502      
    mov [rbp] (format),rcx                ;#00446390: 48:211115 00               uv 00 22  1 1503 02   
    add qword[rbx+rcx*4-16],1             ;#00446394: 48:203104213 F0 01         u  00 0A  3 1505    *02*
    mov rdi,[#00402B28] (or_edi)          ;#0044639A: 48:213075 87C7FBFF         vu 80 00  1 1507      
    mov [rbp-8] (args),rdi                ;#004463A1: 48:211175 F8               uv 00 A0  1 1508      
    mov r15,h4                            ;#004463A5: 49:277 0000000000000040    vu 8000 00  1 1508      
    cmp rdi,r15                           ;#004463AF: 4C:071377                  uv 00 8080  1 1509      
    jl #004463BF                          ;#004463B2: 174 0B                     v  00 00  1 1509      
    add qword[rbx+rdi*4-16],1             ;#004463B4: 48:203104273 F0 01         u  00 88  3 1510      
    cmp eax,622                           ;#004463BA: 075 6E020000               vu 00 01  1 1512      
    mov qword[retaddr],#004463CC          ;#004463BF: 48:307105 20 CC634400      uv 00 20  1 1513      
    jmp #0044E450 (code:sprintf)          ;#004463C7: 351 84800000               v  00 00  1 1513      
    push rax                              ;#004463CC: 120                        uv 00 01  1 1514      
    mov rax,[rbp-32] (o)                  ;#004463CD: 48:213105 E0               vu 01 20  1 1514      
    mov r15,h4                            ;#004463D1: 49:277 0000000000000040    uv 8000 00  1 1515      
    cmp rax,r15                           ;#004463DB: 4C:071370                  uv 00 8001  1 1516 8000   
    jle #004463F0                         ;#004463DE: 176 10                     v  00 00  1 1516      
    sub qword[rbx+rax*4-16],1             ;#004463E0: 48:203154203 F0 01         u  00 09  3 1517      
    jne #004463F0                         ;#004463E6: 165 08                     v  00 00  1 1519      
    mov rdx,rax                           ;#004463E8: 48:213320                  uv 04 01  1 1520      
    call #004422DA (:%pDealloc)           ;#004463EB: 350 EABEFFFF               v  00 00  1 1520      
    pop dword[rbp-32] (o)                 ;#004463F0: 217105 E0                  np 00 20  3 1521      
    jmp #00446861                         ;#004463F3: 351 69040000               v  00 00  1 1524      
;  2360             else
;  2361                 sNTyp = si[S_NTyp]
    mov rdi,2                             ;#004463F8: 48:307307 02000000         uv 80 00  1 1525      
    lea rcx,[rbp-96] (sNTyp)              ;#004463FF: 48:215115 A0               vu 02 20  1 1525      
    mov rdx,674                           ;#00446403: 48:307302 A2020000         uv 04 00  1 1526      
    call #004416F2 (:%pSubse1i)           ;#0044640A: 350 E3B2FFFF               v  00 00  1 1526      
;  2362                 if sNTyp!=S_GVar2
    cmp rax,2                             ;#0044640F: 48:203370 02               uv 00 01  1 1527      
    je #004464A5                          ;#00446413: 017204 8C000000            v  00 00  1 1527      
;  2363                 and sNTyp!=S_TVar3 then
    cmp rax,3                             ;#00446419: 48:203370 03               uv 00 01  1 1528      
    je #004464A5                          ;#0044641D: 017204 82000000            v  00 00  1 1528      
;  2364                     o = sprintf("???(symtab[%d] wrong type)",or_edi)
    mov rcx,33                            ;#00446423: 48:307301 21000000         uv 02 00  1 1529      
    mov rdx,89                            ;#0044642A: 48:307302 59000000         vu 04 00  1 1529      
    call #004428DB (:%opFrame) (sprintf)  ;#00446431: 350 A5C4FFFF               v  00 00  1 1530      
    mov rcx,qword[#00402C70]              ;#00446436: 48:213015 33C8FBFF         uv 02 00  1 1531      
    mov [rbp] (format),rcx                ;#0044643D: 48:211115 00               uv 00 22  1 1532 02   
    add qword[rbx+rcx*4-16],1             ;#00446441: 48:203104213 F0 01         u  00 0A  3 1534    *02*
    mov rdi,[#00402B28] (or_edi)          ;#00446447: 48:213075 DAC6FBFF         vu 80 00  1 1536      
    mov [rbp-8] (args),rdi                ;#0044644E: 48:211175 F8               uv 00 A0  1 1537      
    mov r15,h4                            ;#00446452: 49:277 0000000000000040    vu 8000 00  1 1537      
    cmp rdi,r15                           ;#0044645C: 4C:071377                  uv 00 8080  1 1538      
    jl #0044646C                          ;#0044645F: 174 0B                     v  00 00  1 1538      
    add qword[rbx+rdi*4-16],1             ;#00446461: 48:203104273 F0 01         u  00 88  3 1539      
    cmp eax,622                           ;#00446467: 075 6E020000               vu 00 01  1 1541      
    mov qword[retaddr],#00446479          ;#0044646C: 48:307105 20 79644400      uv 00 20  1 1542      
    jmp #0044E450 (code:sprintf)          ;#00446474: 351 D77F0000               v  00 00  1 1542      
    push rax                              ;#00446479: 120                        uv 00 01  1 1543      
    mov rsi,[rbp-32] (o)                  ;#0044647A: 48:213165 E0               vu 40 20  1 1543      
    mov r15,h4                            ;#0044647E: 49:277 0000000000000040    uv 8000 00  1 1544      
    cmp rsi,r15                           ;#00446488: 4C:071376                  uv 00 8040  1 1545 8000   
    jle #0044649D                         ;#0044648B: 176 10                     v  00 00  1 1545      
    sub qword[rbx+rsi*4-16],1             ;#0044648D: 48:203154263 F0 01         u  00 48  3 1546      
    jne #0044649D                         ;#00446493: 165 08                     v  00 00  1 1548      
    mov rdx,rsi                           ;#00446495: 48:213326                  uv 04 40  1 1549      
    call #004422DA (:%pDealloc)           ;#00446498: 350 3DBEFFFF               v  00 00  1 1549      
    pop dword[rbp-32] (o)                 ;#0044649D: 217105 E0                  np 00 20  3 1550      
    jmp #00446861                         ;#004464A0: 351 BC030000               v  00 00  1 1553      
;  2365                 else
;  2366                     if sNTyp=S_GVar2 then
    cmp rax,2                             ;#004464A5: 48:203370 02               uv 00 01  1 1554      
    jne #0044658A                         ;#004464A9: 017205 DB000000            v  00 00  1 1554      
;  2367                         {novalue,o} = getGvarValue(si[S_Slink])
    mov rdi,6                             ;#004464AF: 48:307307 06000000         uv 80 00  1 1555      
    lea rcx,[rbp-440] (symtab[735])       ;#004464B6: 48:215215 48FEFFFF         vu 02 20  1 1555      
    mov rsi,[rbp-8] (si)                  ;#004464BD: 48:213165 F8               uv 40 20  1 1556      
    mov rdx,674                           ;#004464C1: 48:307302 A2020000         vu 04 00  1 1556      
    call #00441675 (:%pSubse1)            ;#004464C8: 350 A8B1FFFF               v  00 00  1 1557      
    mov rcx,4                             ;#004464CD: 48:307301 04000000         uv 02 00  1 1558      
    mov rdx,625                           ;#004464D4: 48:307302 71020000         vu 04 00  1 1558      
    call :%opFrame (getGvarValue)         ;#004464DB: 350 FBC3FFFF               v  00 00  1 1559      
    mov rdi,[rbp+40] (prevebp)            ;#004464E0: 48:213175 28               uv 80 20  1 1560      
    mov rax,[rdi-440]                     ;#004464E4: 48:213207 48FEFFFF         uv 01 80  1 1563 80 *80*
    xor rbx,rbx                           ;#004464EB: 48:061333                  vu 08 08  1 1563      
    mov r15,h4                            ;#004464EE: 49:277 0000000000000040    uv 8000 00  1 1564      
    cmp rax,r15                           ;#004464F8: 4C:071370                  uv 00 8001  1 1565 8000   
    jl #00446508                          ;#004464FB: 174 0B                     v  00 00  1 1565      
    add qword[rbx+rax*4-16],1             ;#004464FD: 48:203104203 F0 01         u  00 09  3 1566      
    cmp eax,735                           ;#00446503: 075 DF020000               vu 00 01  1 1568      
    mov [rbp] (gidx),rax                  ;#00446508: 48:211105 00               uv 00 21  1 1569      
    mov qword[retaddr],#00446519          ;#0044650C: 48:307105 20 19654400      vu 00 20  1 1569      
    jmp #0044DD19 (code:getGvarValue)     ;#00446514: 351 00780000               v  00 00  1 1570      
    push rax                              ;#00446519: 120                        uv 00 01  1 1571      
    mov rcx,[rbp-472] (symtab[756])       ;#0044651A: 48:213215 28FEFFFF         vu 02 20  1 1571      
    mov r15,h4                            ;#00446521: 49:277 0000000000000040    uv 8000 00  1 1572      
    cmp rcx,r15                           ;#0044652B: 4C:071371                  uv 00 8002  1 1573 8000   
    jle #00446540                         ;#0044652E: 176 10                     v  00 00  1 1573      
    sub qword[rbx+rcx*4-16],1             ;#00446530: 48:203154213 F0 01         u  00 0A  3 1574      
    jne #00446540                         ;#00446536: 165 08                     v  00 00  1 1576      
    mov rdx,rcx                           ;#00446538: 48:213321                  uv 04 02  1 1577      
    call #004422DA (:%pDealloc)           ;#0044653B: 350 9ABDFFFF               v  00 00  1 1577      
    pop dword[rbp-472] (symtab[756])      ;#00446540: 217205 28FEFFFF            np 00 20  3 1578      
    mov rdi,2                             ;#00446546: 48:307307 02000000         uv 80 00  1 1581      
    lea rcx,[rbp-32] (o)                  ;#0044654D: 48:215115 E0               vu 02 20  1 1581      
    mov rsi,[rbp-472] (symtab[756])       ;#00446551: 48:213265 28FEFFFF         uv 40 20  1 1582      
    mov rdx,756                           ;#00446558: 48:307302 F4020000         vu 04 00  1 1582      
    call #00441675 (:%pSubse1)            ;#0044655F: 350 11B1FFFF               v  00 00  1 1583      
    mov rdi,1                             ;#00446564: 48:307307 01000000         uv 80 00  1 1584      
    lea rcx,[rbp-320] (novalue)           ;#0044656B: 48:215215 C0FEFFFF         vu 02 20  1 1584      
    mov rsi,[rbp-472] (symtab[756])       ;#00446572: 48:213265 28FEFFFF         uv 40 20  1 1585      
    mov rdx,756                           ;#00446579: 48:307302 F4020000         vu 04 00  1 1585      
    call #004416F2 (:%pSubse1i)           ;#00446580: 350 6DB1FFFF               v  00 00  1 1586      
    jmp #0044666A                         ;#00446585: 351 E0000000               v  00 00  1 1587      
;  2368                     elsif sNTyp=S_TVar3 then
    cmp rax,3                             ;#0044658A: 48:203370 03               uv 00 01  1 1588      
    jne #0044666A                         ;#0044658E: 017205 D6000000            v  00 00  1 1588      
;  2369                         {novalue,o} = getTvarValue(si[S_Tidx])
    mov rdi,9                             ;#00446594: 48:307307 09000000         uv 80 00  1 1589      
    lea rcx,[rbp-440] (symtab[735])       ;#0044659B: 48:215215 48FEFFFF         vu 02 20  1 1589      
    mov rsi,[rbp-8] (si)                  ;#004465A2: 48:213165 F8               uv 40 20  1 1590      
    mov rdx,674                           ;#004465A6: 48:307302 A2020000         vu 04 00  1 1590      
    call #00441675 (:%pSubse1)            ;#004465AD: 350 C3B0FFFF               v  00 00  1 1591      
    mov rcx,4                             ;#004465B2: 48:307301 04000000         uv 02 00  1 1592      
    mov rdx,631                           ;#004465B9: 48:307302 77020000         vu 04 00  1 1592      
    call :%opFrame (getTvarValue)         ;#004465C0: 350 16C3FFFF               v  00 00  1 1593      
    mov rdi,[rbp+40] (prevebp)            ;#004465C5: 48:213175 28               uv 80 20  1 1594      
    mov rax,[rdi-440]                     ;#004465C9: 48:213207 48FEFFFF         uv 01 80  1 1597 80 *80*
    xor rbx,rbx                           ;#004465D0: 48:061333                  vu 08 08  1 1597      
    mov r15,h4                            ;#004465D3: 49:277 0000000000000040    uv 8000 00  1 1598      
    cmp rax,r15                           ;#004465DD: 4C:071370                  uv 00 8001  1 1599 8000   
    jl #004465ED                          ;#004465E0: 174 0B                     v  00 00  1 1599      
    add qword[rbx+rax*4-16],1             ;#004465E2: 48:203104203 F0 01         u  00 09  3 1600      
    cmp eax,735                           ;#004465E8: 075 DF020000               vu 00 01  1 1602      
    mov [rbp] (tidx),rax                  ;#004465ED: 48:211105 00               uv 00 21  1 1603      
    mov qword[retaddr],#004465FE          ;#004465F1: 48:307105 20 FE654400      vu 00 20  1 1603      
    jmp #0044DC08 (code:getTvarValue)     ;#004465F9: 351 0A760000               v  00 00  1 1604      
    push rax                              ;#004465FE: 120                        uv 00 01  1 1605      
    mov rdi,[rbp-480] (symtab[765])       ;#004465FF: 48:213275 20FEFFFF         vu 80 20  1 1605      
    mov r15,h4                            ;#00446606: 49:277 0000000000000040    uv 8000 00  1 1606      
    cmp rdi,r15                           ;#00446610: 4C:071377                  uv 00 8080  1 1607 8000   
    jle #00446625                         ;#00446613: 176 10                     v  00 00  1 1607      
    sub qword[rbx+rdi*4-16],1             ;#00446615: 48:203154273 F0 01         u  00 88  3 1608      
    jne #00446625                         ;#0044661B: 165 08                     v  00 00  1 1610      
    mov rdx,rdi                           ;#0044661D: 48:213327                  uv 04 80  1 1611      
    call #004422DA (:%pDealloc)           ;#00446620: 350 B5BCFFFF               v  00 00  1 1611      
    pop dword[rbp-480] (symtab[765])      ;#00446625: 217205 20FEFFFF            np 00 20  3 1612      
    mov rdi,2                             ;#0044662B: 48:307307 02000000         uv 80 00  1 1615      
    lea rcx,[rbp-32] (o)                  ;#00446632: 48:215115 E0               vu 02 20  1 1615      
    mov rsi,[rbp-480] (symtab[765])       ;#00446636: 48:213265 20FEFFFF         uv 40 20  1 1616      
    mov rdx,765                           ;#0044663D: 48:307302 FD020000         vu 04 00  1 1616      
    call #00441675 (:%pSubse1)            ;#00446644: 350 2CB0FFFF               v  00 00  1 1617      
    mov rdi,1                             ;#00446649: 48:307307 01000000         uv 80 00  1 1618      
    lea rcx,[rbp-320] (novalue)           ;#00446650: 48:215215 C0FEFFFF         vu 02 20  1 1618      
    mov rsi,[rbp-480] (symtab[765])       ;#00446657: 48:213265 20FEFFFF         uv 40 20  1 1619      
    mov rdx,765                           ;#0044665E: 48:307302 FD020000         vu 04 00  1 1619      
    call #004416F2 (:%pSubse1i)           ;#00446665: 350 88B0FFFF               v  00 00  1 1620      
;  2370                     end if
;  2371                     if novalue then
    mov rax,[rbp-320] (novalue)           ;#0044666A: 48:213205 C0FEFFFF         uv 01 20  1 1621      
    mov rdx,713                           ;#00446671: 48:48:307302 C9020000      vu 04 00  1 1621      
    call #0043FB2C (:%opJif)              ;#00446679: 350 AE94FFFF               v  00 00  1 1622      
    je #004467CA                          ;#0044667E: 017204 46010000            v  00 00  1 1623      
;  2372                         if novalue=1 then
    cmp rax,1                             ;#00446684: 48:203370 01               uv 00 01  1 1624      
    jne #004466D7                         ;#00446688: 165 4D                     v  00 00  1 1624      
;  2373                             o = "<novalue>"
    mov rcx,qword[#00402680]              ;#0044668A: 48:213015 EFBFFBFF         uv 02 00  1 1625      
    mov rdx,[rbp-32] (o)                  ;#00446691: 48:213125 E0               vu 04 20  1 1625      
    mov r15,h4                            ;#00446695: 49:277 0000000000000040    uv 8000 00  1 1626      
    cmp rcx,r15                           ;#0044669F: 4C:071371                  uv 00 8002  1 1627 8000   
    jl #004466AA                          ;#004466A2: 174 06                     v  00 00  1 1627      
    add qword[rbx+rcx*4-16],1             ;#004466A4: 48:203104213 F0 01         u  00 0A  3 1628      
    mov [rbp-32] (o),rcx                  ;#004466AA: 48:211115 E0               vu 00 22  1 1630      
    mov r15,h4                            ;#004466AE: 49:277 0000000000000040    uv 8000 00  1 1631      
    cmp rdx,r15                           ;#004466B8: 4C:071372                  uv 00 8004  1 1632 8000   
    jle #00446861                         ;#004466BB: 017216 A0010000            v  00 00  1 1632      
    sub qword[rbx+rdx*4-16],1             ;#004466C1: 48:203154223 F0 01         u  00 0C  3 1633      
    jne #00446861                         ;#004466C7: 017205 94010000            v  00 00  1 1635      
    call #004422DA (:%pDealloc)           ;#004466CD: 350 08BCFFFF               v  00 00  1 1636      
    jmp #00446861                         ;#004466D2: 351 8A010000               v  00 00  1 1637      
;  2374                         elsif novalue=2 then
    cmp rax,2                             ;#004466D7: 48:203370 02               uv 00 01  1 1638      
    jne #0044672A                         ;#004466DB: 165 4D                     v  00 00  1 1638      
;  2375                             o = "*** INVALID REF ***"
    mov rdi,qword[#00402688]              ;#004466DD: 48:213075 A4BFFBFF         uv 80 00  1 1639      
    mov rdx,[rbp-32] (o)                  ;#004466E4: 48:213125 E0               vu 04 20  1 1639      
    mov r15,h4                            ;#004466E8: 49:277 0000000000000040    uv 8000 00  1 1640      
    cmp rdi,r15                           ;#004466F2: 4C:071377                  uv 00 8080  1 1641 8000   
    jl #004466FD                          ;#004466F5: 174 06                     v  00 00  1 1641      
    add qword[rbx+rdi*4-16],1             ;#004466F7: 48:203104273 F0 01         u  00 88  3 1642      
    mov [rbp-32] (o),rdi                  ;#004466FD: 48:211175 E0               vu 00 A0  1 1644      
    mov r15,h4                            ;#00446701: 49:277 0000000000000040    uv 8000 00  1 1645      
    cmp rdx,r15                           ;#0044670B: 4C:071372                  uv 00 8004  1 1646 8000   
    jle #00446861                         ;#0044670E: 017216 4D010000            v  00 00  1 1646      
    sub qword[rbx+rdx*4-16],1             ;#00446714: 48:203154223 F0 01         u  00 0C  3 1647      
    jne #00446861                         ;#0044671A: 017205 41010000            v  00 00  1 1649      
    call #004422DA (:%pDealloc)           ;#00446720: 350 B5BBFFFF               v  00 00  1 1650      
    jmp #00446861                         ;#00446725: 351 37010000               v  00 00  1 1651      
;  2376                         elsif novalue=3 then
    cmp rax,3                             ;#0044672A: 48:203370 03               uv 00 01  1 1652      
    jne #0044677D                         ;#0044672E: 165 4D                     v  00 00  1 1652      
;  2377                             o = "*** CORRUPT TYPE BYTE ***"
    mov rsi,qword[#00402690]              ;#00446730: 48:213065 59BFFBFF         uv 40 00  1 1653      
    mov rdx,[rbp-32] (o)                  ;#00446737: 48:213125 E0               vu 04 20  1 1653      
    mov r15,h4                            ;#0044673B: 49:277 0000000000000040    uv 8000 00  1 1654      
    cmp rsi,r15                           ;#00446745: 4C:071376                  uv 00 8040  1 1655 8000   
    jl #00446750                          ;#00446748: 174 06                     v  00 00  1 1655      
    add qword[rbx+rsi*4-16],1             ;#0044674A: 48:203104263 F0 01         u  00 48  3 1656      
    mov [rbp-32] (o),rsi                  ;#00446750: 48:211165 E0               vu 00 60  1 1658      
    mov r15,h4                            ;#00446754: 49:277 0000000000000040    uv 8000 00  1 1659      
    cmp rdx,r15                           ;#0044675E: 4C:071372                  uv 00 8004  1 1660 8000   
    jle #00446861                         ;#00446761: 017216 FA000000            v  00 00  1 1660      
    sub qword[rbx+rdx*4-16],1             ;#00446767: 48:203154223 F0 01         u  00 0C  3 1661      
    jne #00446861                         ;#0044676D: 017205 EE000000            v  00 00  1 1663      
    call #004422DA (:%pDealloc)           ;#00446773: 350 62BBFFFF               v  00 00  1 1664      
    jmp #00446861                         ;#00446778: 351 E4000000               v  00 00  1 1665      
;  2378                         else
;  2379                             o = "*** INVALID ??? ***"
    mov rcx,qword[#00402698]              ;#0044677D: 48:213015 14BFFBFF         uv 02 00  1 1666      
    mov rdx,[rbp-32] (o)                  ;#00446784: 48:213125 E0               vu 04 20  1 1666      
    mov r15,h4                            ;#00446788: 49:277 0000000000000040    uv 8000 00  1 1667      
    cmp rcx,r15                           ;#00446792: 4C:071371                  uv 00 8002  1 1668 8000   
    jl #0044679D                          ;#00446795: 174 06                     v  00 00  1 1668      
    add qword[rbx+rcx*4-16],1             ;#00446797: 48:203104213 F0 01         u  00 0A  3 1669      
    mov [rbp-32] (o),rcx                  ;#0044679D: 48:211115 E0               vu 00 22  1 1671      
    mov r15,h4                            ;#004467A1: 49:277 0000000000000040    uv 8000 00  1 1672      
    cmp rdx,r15                           ;#004467AB: 4C:071372                  uv 00 8004  1 1673 8000   
    jle #00446861                         ;#004467AE: 017216 AD000000            v  00 00  1 1673      
    sub qword[rbx+rdx*4-16],1             ;#004467B4: 48:203154223 F0 01         u  00 0C  3 1674      
    jne #00446861                         ;#004467BA: 017205 A1000000            v  00 00  1 1676      
    call #004422DA (:%pDealloc)           ;#004467C0: 350 15BBFFFF               v  00 00  1 1677      
;  2380                         end if
    jmp #00446861                         ;#004467C5: 351 97000000               v  00 00  1 1678      
;  2381                     else
;  2382                         o = sprint(o,55-length(name))
    lea rdi,[rbp-456] (symtab[746])       ;#004467CA: 48:215275 38FEFFFF         uv 80 20  1 1679      
    mov rsi,[rbp-24] (name)               ;#004467D1: 48:213165 E8               vu 40 20  1 1679      
    mov rdx,676                           ;#004467D5: 48:307302 A4020000         uv 04 00  1 1680      
    call #0043F28D (:%opLen)              ;#004467DC: 350 AC8AFFFF               v  00 00  1 1680      
    lea rdi,[rbp-376] (symtab[720])       ;#004467E1: 48:215275 88FEFFFF         uv 80 20  1 1681      
    mov rcx,qword[#00402CC0]              ;#004467E8: 48:213015 D1C4FBFF         vu 02 00  1 1681      
    mov rax,[rbp-456] (symtab[746])       ;#004467EF: 48:213205 38FEFFFF         uv 01 20  1 1682      
    call #0043F4D8 (:%opSub)              ;#004467F6: 350 DD8CFFFF               v  00 00  1 1682      
    mov rcx,11                            ;#004467FB: 48:307301 0B000000         uv 02 00  1 1683      
    mov rdx,91                            ;#00446802: 48:307302 5B000000         vu 04 00  1 1683      
    call #004428DB (:%opFrame) (sprint)   ;#00446809: 350 CDC0FFFF               v  00 00  1 1684      
    mov rdi,[rbp+40] (prevebp)            ;#0044680E: 48:213175 28               uv 80 20  1 1685      
    mov rax,[rdi-32]                      ;#00446812: 48:213107 E0               uv 01 80  1 1688 80 *80*
    mov [rdi-32],r15                      ;#00446816: 4C:211177 E0               vu 00 8080  1 1688      
    mov [rbp] (x),rax                     ;#0044681A: 48:211105 00               uv 00 21  1 1689      
    mov rdi,[rbp+40] (prevebp)            ;#0044681E: 48:213175 28               vu 80 20  1 1689      
    mov rax,[rdi-376]                     ;#00446822: 48:213207 88FEFFFF         uv 01 80  1 1692    *80*
    mov [rbp-8] (l),rax                   ;#00446829: 48:211105 F8               uv 00 21  1 1693 01   
    mov qword[retaddr],#0044683A          ;#0044682D: 48:307105 20 3A684400      vu 00 20  1 1693      
    jmp #0044D2DF (code:sprint)           ;#00446835: 351 A56A0000               v  00 00  1 1694      
    push rax                              ;#0044683A: 120                        uv 00 01  1 1695      
    mov rdi,[rbp-32] (o)                  ;#0044683B: 48:213175 E0               vu 80 20  1 1695      
    mov r15,h4                            ;#0044683F: 49:277 0000000000000040    uv 8000 00  1 1696      
    cmp rdi,r15                           ;#00446849: 4C:071377                  uv 00 8080  1 1697 8000   
    jle #0044685E                         ;#0044684C: 176 10                     v  00 00  1 1697      
    sub qword[rbx+rdi*4-16],1             ;#0044684E: 48:203154273 F0 01         u  00 88  3 1698      
    jne #0044685E                         ;#00446854: 165 08                     v  00 00  1 1700      
    mov rdx,rdi                           ;#00446856: 48:213327                  uv 04 80  1 1701      
    call #004422DA (:%pDealloc)           ;#00446859: 350 7CBAFFFF               v  00 00  1 1701      
    pop dword[rbp-32] (o)                 ;#0044685E: 217105 E0                  np 00 20  3 1702      
;  2383                     end if
;  2384                 end if
;  2385             end if
;  2386         end if
;  2387 --      o = "??"--getValue(or_edi, 5, 0, 1)
;  2388         msg = sprintf(msg,{name,o}) -- "for loop error, %s is %s\n"
    lea rax,[rbp-488] (symtab[767])       ;#00446861: 48:215205 18FEFFFF         uv 01 20  1 1705      
    mov rdx,2                             ;#00446868: 48:307302 02000000         vu 04 00  1 1705      
    push #004468BF                        ;#0044686F: 150 BF684400               uv 00 00  1 1706      
    push rax                              ;#00446874: 120                        vu 00 01  1 1706      
    mov rsi,[rbp-32] (o)                  ;#00446875: 48:213165 E0               uv 40 20  1 1707      
    mov r15,h4                            ;#00446879: 49:277 0000000000000040    vu 8000 00  1 1707      
    cmp rsi,r15                           ;#00446883: 4C:071376                  uv 00 8040  1 1708      
    jl #00446893                          ;#00446886: 174 0B                     v  00 00  1 1708      
    add qword[rbx+rsi*4-16],1             ;#00446888: 48:203104263 F0 01         u  00 48  3 1709      
    cmp eax,677                           ;#0044688E: 075 A5020000               vu 00 01  1 1711      
    push rsi                              ;#00446893: 126                        uv 00 40  1 1712      
    mov rcx,[rbp-24] (name)               ;#00446894: 48:213115 E8               vu 02 20  1 1712      
    mov r15,h4                            ;#00446898: 49:277 0000000000000040    uv 8000 00  1 1713      
    cmp rcx,r15                           ;#004468A2: 4C:071371                  uv 00 8002  1 1714 8000   
    jl #004468B2                          ;#004468A5: 174 0B                     v  00 00  1 1714      
    add qword[rbx+rcx*4-16],1             ;#004468A7: 48:203104213 F0 01         u  00 0A  3 1715      
    cmp eax,676                           ;#004468AD: 075 A4020000               vu 00 01  1 1717      
    push rcx                              ;#004468B2: 121                        uv 00 02  1 1718      
    mov rdi,[rbp-488] (symtab[767])       ;#004468B3: 48:213275 18FEFFFF         vu 80 20  1 1718      
    jmp #004404BD (:%pMkSq)               ;#004468BA: 351 FE9BFFFF               v  00 00  1 1719      
    mov rcx,33                            ;#004468BF: 48:307301 21000000         uv 02 00  1 1720      
    mov rdx,89                            ;#004468C6: 48:307302 59000000         vu 04 00  1 1720      
    call #004428DB (:%opFrame) (sprintf)  ;#004468CD: 350 09C0FFFF               v  00 00  1 1721      
    mov rdi,[rbp+40] (prevebp)            ;#004468D2: 48:213175 28               uv 80 20  1 1722      
    mov rax,[rdi-120]                     ;#004468D6: 48:213107 88               uv 01 80  1 1725 80 *80*
    mov [rdi-120],r15                     ;#004468DA: 4C:211177 88               vu 00 8080  1 1725      
    mov [rbp] (format),rax                ;#004468DE: 48:211105 00               uv 00 21  1 1726      
    mov rdi,[rbp+40] (prevebp)            ;#004468E2: 48:213175 28               vu 80 20  1 1726      
    mov rax,[rdi-488]                     ;#004468E6: 48:213207 18FEFFFF         uv 01 80  1 1729    *80*
    xor rbx,rbx                           ;#004468ED: 48:061333                  vu 08 08  1 1729      
    mov r15,h4                            ;#004468F0: 49:277 0000000000000040    uv 8000 00  1 1730      
    cmp rax,r15                           ;#004468FA: 4C:071370                  uv 00 8001  1 1731 8000   
    jl #0044690A                          ;#004468FD: 174 0B                     v  00 00  1 1731      
    add qword[rbx+rax*4-16],1             ;#004468FF: 48:203104203 F0 01         u  00 09  3 1732      
    cmp eax,767                           ;#00446905: 075 FF020000               vu 00 01  1 1734      
    mov [rbp-8] (args),rax                ;#0044690A: 48:211105 F8               uv 00 21  1 1735      
    mov qword[retaddr],#0044691B          ;#0044690E: 48:307105 20 1B694400      vu 00 20  1 1735      
    jmp #0044E450 (code:sprintf)          ;#00446916: 351 357B0000               v  00 00  1 1736      
    push rax                              ;#0044691B: 120                        uv 00 01  1 1737      
    mov rsi,[rbp-120] (msg)               ;#0044691C: 48:213165 88               vu 40 20  1 1737      
    mov r15,h4                            ;#00446920: 49:277 0000000000000040    uv 8000 00  1 1738      
    cmp rsi,r15                           ;#0044692A: 4C:071376                  uv 00 8040  1 1739 8000   
    jle #0044693F                         ;#0044692D: 176 10                     v  00 00  1 1739      
    sub qword[rbx+rsi*4-16],1             ;#0044692F: 48:203154263 F0 01         u  00 48  3 1740      
    jne #0044693F                         ;#00446935: 165 08                     v  00 00  1 1742      
    mov rdx,rsi                           ;#00446937: 48:213326                  uv 04 40  1 1743      
    call #004422DA (:%pDealloc)           ;#0044693A: 350 9BB9FFFF               v  00 00  1 1743      
    pop dword[rbp-120] (msg)              ;#0044693F: 217105 88                  np 00 20  3 1744      
;  2389 --      msg = sprintf(msg,{ep1})
    jmp #00446CC1                         ;#00446942: 351 7A030000               v  00 00  1 1747      
;  2390     elsif msg_id=9 then -- e09slin(edi,ecx)
;  2391         msg = sprintf(msg,{or_edi,or_ecx})  -- "slice length is negative [%d..%d]\n"
    lea rax,[rbp-488] (symtab[767])       ;#00446947: 48:215205 18FEFFFF         uv 01 20  1 1748      
    mov rdx,2                             ;#0044694E: 48:307302 02000000         vu 04 00  1 1748      
    push #004469AB                        ;#00446955: 150 AB694400               uv 00 00  1 1749      
    push rax                              ;#0044695A: 120                        vu 00 01  1 1749      
    mov rcx,[#00402B08] (or_ecx)          ;#0044695B: 48:213015 A6C1FBFF         uv 02 00  1 1750      
    mov r15,h4                            ;#00446962: 49:277 0000000000000040    vu 8000 00  1 1750      
    cmp rcx,r15                           ;#0044696C: 4C:071371                  uv 00 8002  1 1751      
    jl #0044697C                          ;#0044696F: 174 0B                     v  00 00  1 1751      
    add qword[rbx+rcx*4-16],1             ;#00446971: 48:203104213 F0 01         u  00 0A  3 1752      
    cmp eax,618                           ;#00446977: 075 6A020000               vu 00 01  1 1754      
    push rcx                              ;#0044697C: 121                        uv 00 02  1 1755      
    mov rdi,[#00402B28] (or_edi)          ;#0044697D: 48:213075 A4C1FBFF         vu 80 00  1 1755      
    mov r15,h4                            ;#00446984: 49:277 0000000000000040    uv 8000 00  1 1756      
    cmp rdi,r15                           ;#0044698E: 4C:071377                  uv 00 8080  1 1757 8000   
    jl #0044699E                          ;#00446991: 174 0B                     v  00 00  1 1757      
    add qword[rbx+rdi*4-16],1             ;#00446993: 48:203104273 F0 01         u  00 88  3 1758      
    cmp eax,622                           ;#00446999: 075 6E020000               vu 00 01  1 1760      
    push rdi                              ;#0044699E: 127                        uv 00 80  1 1761      
    mov rdi,[rbp-488] (symtab[767])       ;#0044699F: 48:213275 18FEFFFF         vu 80 20  1 1761      
    jmp #004404BD (:%pMkSq)               ;#004469A6: 351 129BFFFF               v  00 00  1 1762      
    mov rcx,33                            ;#004469AB: 48:307301 21000000         uv 02 00  1 1763      
    mov rdx,89                            ;#004469B2: 48:307302 59000000         vu 04 00  1 1763      
    call #004428DB (:%opFrame) (sprintf)  ;#004469B9: 350 1DBFFFFF               v  00 00  1 1764      
    mov rdi,[rbp+40] (prevebp)            ;#004469BE: 48:213175 28               uv 80 20  1 1765      
    mov rax,[rdi-120]                     ;#004469C2: 48:213107 88               uv 01 80  1 1768 80 *80*
    mov [rdi-120],r15                     ;#004469C6: 4C:211177 88               vu 00 8080  1 1768      
    mov [rbp] (format),rax                ;#004469CA: 48:211105 00               uv 00 21  1 1769      
    mov rdi,[rbp+40] (prevebp)            ;#004469CE: 48:213175 28               vu 80 20  1 1769      
    mov rax,[rdi-488]                     ;#004469D2: 48:213207 18FEFFFF         uv 01 80  1 1772    *80*
    xor rbx,rbx                           ;#004469D9: 48:061333                  vu 08 08  1 1772      
    mov r15,h4                            ;#004469DC: 49:277 0000000000000040    uv 8000 00  1 1773      
    cmp rax,r15                           ;#004469E6: 4C:071370                  uv 00 8001  1 1774 8000   
    jl #004469F6                          ;#004469E9: 174 0B                     v  00 00  1 1774      
    add qword[rbx+rax*4-16],1             ;#004469EB: 48:203104203 F0 01         u  00 09  3 1775      
    cmp eax,767                           ;#004469F1: 075 FF020000               vu 00 01  1 1777      
    mov [rbp-8] (args),rax                ;#004469F6: 48:211105 F8               uv 00 21  1 1778      
    mov qword[retaddr],#00446A07          ;#004469FA: 48:307105 20 076A4400      vu 00 20  1 1778      
    jmp #0044E450 (code:sprintf)          ;#00446A02: 351 497A0000               v  00 00  1 1779      
    push rax                              ;#00446A07: 120                        uv 00 01  1 1780      
    mov rsi,[rbp-120] (msg)               ;#00446A08: 48:213165 88               vu 40 20  1 1780      
    mov r15,h4                            ;#00446A0C: 49:277 0000000000000040    uv 8000 00  1 1781      
    cmp rsi,r15                           ;#00446A16: 4C:071376                  uv 00 8040  1 1782 8000   
    jle #00446A2B                         ;#00446A19: 176 10                     v  00 00  1 1782      
    sub qword[rbx+rsi*4-16],1             ;#00446A1B: 48:203154263 F0 01         u  00 48  3 1783      
    jne #00446A2B                         ;#00446A21: 165 08                     v  00 00  1 1785      
    mov rdx,rsi                           ;#00446A23: 48:213326                  uv 04 40  1 1786      
    call #004422DA (:%pDealloc)           ;#00446A26: 350 AFB8FFFF               v  00 00  1 1786      
    pop dword[rbp-120] (msg)              ;#00446A2B: 217105 88                  np 00 20  3 1787      
    jmp #00446CC1                         ;#00446A2E: 351 8E020000               v  00 00  1 1790      
;  2392     elsif msg_id=11 then -- e11sepeos(edi,esi)
;  2393         if or_edi<0 then
    xor rdi,rdi                           ;#00446A33: 48:061377                  uv 80 80  1 1791      
    mov rax,[#00402B28] (or_edi)          ;#00446A36: 48:213005 EBC0FBFF         vu 01 00  1 1791      
    mov rsi,25                            ;#00446A3D: 48:307306 19000000         uv 40 00  1 1792      
    mov rdx,622                           ;#00446A44: 48:307302 6E020000         vu 04 00  1 1792      
    call #0043FA81 (:%opJcc)              ;#00446A4B: 350 3190FFFF               v  00 00  1 1793      
    jge #00446B5C                         ;#00446A50: 017215 06010000            v  00 00  1 1794      
;  2394             msg = sprintf("slice end(%d) less than negative length(%d)\n",{or_edi,-or_esi})
    mov rcx,[#00402B20] (or_esi)          ;#00446A56: 48:213015 C3C0FBFF         uv 02 00  1 1795      
    mov r15,h4                            ;#00446A5D: 49:277 0000000000000040    vu 8000 00  1 1795      
    cmp rcx,r15                           ;#00446A67: 4C:071371                  uv 00 8002  1 1796      
    jne #00446A78                         ;#00446A6A: 165 0C                     v  00 00  1 1796      
    mov rsi,621                           ;#00446A6C: 48:307306 6D020000         uv 40 00  1 1797      
    call #00442D75 (:%pUnassigned)        ;#00446A73: 350 FDC2FFFF               v  00 00  1 1797      
    lea rdi,[rbp-376] (symtab[720])       ;#00446A78: 48:215275 88FEFFFF         uv 80 20  1 1798      
    call #0043F746 (:%opUminus)           ;#00446A7F: 350 C28CFFFF               v  00 00  1 1798      
    lea rax,[rbp-488] (symtab[767])       ;#00446A84: 48:215205 18FEFFFF         uv 01 20  1 1799      
    mov rdx,2                             ;#00446A8B: 48:307302 02000000         vu 04 00  1 1799      
    push #00446AD3                        ;#00446A92: 150 D36A4400               uv 00 00  1 1800      
    push rax                              ;#00446A97: 120                        vu 00 01  1 1800      
    push qword[rbp-376] (symtab[720])     ;#00446A98: 377265 88FEFFFF            np 00 20  2 1801      
    mov [rbp-376] (symtab[720]),rbx       ;#00446A9E: 48:211235 88FEFFFF         uv 00 28  1 1803      
    mov rdi,[#00402B28] (or_edi)          ;#00446AA5: 48:213075 7CC0FBFF         vu 80 00  1 1803      
    mov r15,h4                            ;#00446AAC: 49:277 0000000000000040    uv 8000 00  1 1804      
    cmp rdi,r15                           ;#00446AB6: 4C:071377                  uv 00 8080  1 1805 8000   
    jl #00446AC6                          ;#00446AB9: 174 0B                     v  00 00  1 1805      
    add qword[rbx+rdi*4-16],1             ;#00446ABB: 48:203104273 F0 01         u  00 88  3 1806      
    cmp eax,622                           ;#00446AC1: 075 6E020000               vu 00 01  1 1808      
    push rdi                              ;#00446AC6: 127                        uv 00 80  1 1809      
    mov rdi,[rbp-488] (symtab[767])       ;#00446AC7: 48:213275 18FEFFFF         vu 80 20  1 1809      
    jmp #004404BD (:%pMkSq)               ;#00446ACE: 351 EA99FFFF               v  00 00  1 1810      
    mov rcx,33                            ;#00446AD3: 48:307301 21000000         uv 02 00  1 1811      
    mov rdx,89                            ;#00446ADA: 48:307302 59000000         vu 04 00  1 1811      
    call #004428DB (:%opFrame) (sprintf)  ;#00446AE1: 350 F5BDFFFF               v  00 00  1 1812      
    mov rsi,qword[#00402CC8]              ;#00446AE6: 48:213065 DBC1FBFF         uv 40 00  1 1813      
    mov [rbp] (format),rsi                ;#00446AED: 48:211165 00               uv 00 60  1 1814 40   
    add qword[rbx+rsi*4-16],1             ;#00446AF1: 48:203104263 F0 01         u  00 48  3 1816    *40*
    mov rdi,[rbp+40] (prevebp)            ;#00446AF7: 48:213175 28               vu 80 20  1 1818      
    mov rax,[rdi-488]                     ;#00446AFB: 48:213207 18FEFFFF         uv 01 80  1 1821    *80*
    xor rbx,rbx                           ;#00446B02: 48:061333                  vu 08 08  1 1821      
    mov r15,h4                            ;#00446B05: 49:277 0000000000000040    uv 8000 00  1 1822      
    cmp rax,r15                           ;#00446B0F: 4C:071370                  uv 00 8001  1 1823 8000   
    jl #00446B1F                          ;#00446B12: 174 0B                     v  00 00  1 1823      
    add qword[rbx+rax*4-16],1             ;#00446B14: 48:203104203 F0 01         u  00 09  3 1824      
    cmp eax,767                           ;#00446B1A: 075 FF020000               vu 00 01  1 1826      
    mov [rbp-8] (args),rax                ;#00446B1F: 48:211105 F8               uv 00 21  1 1827      
    mov qword[retaddr],#00446B30          ;#00446B23: 48:307105 20 306B4400      vu 00 20  1 1827      
    jmp #0044E450 (code:sprintf)          ;#00446B2B: 351 20790000               v  00 00  1 1828      
    push rax                              ;#00446B30: 120                        uv 00 01  1 1829      
    mov rcx,[rbp-120] (msg)               ;#00446B31: 48:213115 88               vu 02 20  1 1829      
    mov r15,h4                            ;#00446B35: 49:277 0000000000000040    uv 8000 00  1 1830      
    cmp rcx,r15                           ;#00446B3F: 4C:071371                  uv 00 8002  1 1831 8000   
    jle #00446B54                         ;#00446B42: 176 10                     v  00 00  1 1831      
    sub qword[rbx+rcx*4-16],1             ;#00446B44: 48:203154213 F0 01         u  00 0A  3 1832      
    jne #00446B54                         ;#00446B4A: 165 08                     v  00 00  1 1834      
    mov rdx,rcx                           ;#00446B4C: 48:213321                  uv 04 02  1 1835      
    call #004422DA (:%pDealloc)           ;#00446B4F: 350 86B7FFFF               v  00 00  1 1835      
    pop dword[rbp-120] (msg)              ;#00446B54: 217105 88                  np 00 20  3 1836      
    jmp #00446CC1                         ;#00446B57: 351 65010000               v  00 00  1 1839      
;  2395         else
;  2396             msg = sprintf(msg,{or_edi,or_esi})  -- "slice ends past end of sequence (%d > %d)\n"
    lea rax,[rbp-488] (symtab[767])       ;#00446B5C: 48:215205 18FEFFFF         uv 01 20  1 1840      
    mov rdx,2                             ;#00446B63: 48:307302 02000000         vu 04 00  1 1840      
    push #00446BC0                        ;#00446B6A: 150 C06B4400               uv 00 00  1 1841      
    push rax                              ;#00446B6F: 120                        vu 00 01  1 1841      
    mov rdi,[#00402B20] (or_esi)          ;#00446B70: 48:213075 A9BFFBFF         uv 80 00  1 1842      
    mov r15,h4                            ;#00446B77: 49:277 0000000000000040    vu 8000 00  1 1842      
    cmp rdi,r15                           ;#00446B81: 4C:071377                  uv 00 8080  1 1843      
    jl #00446B91                          ;#00446B84: 174 0B                     v  00 00  1 1843      
    add qword[rbx+rdi*4-16],1             ;#00446B86: 48:203104273 F0 01         u  00 88  3 1844      
    cmp eax,621                           ;#00446B8C: 075 6D020000               vu 00 01  1 1846      
    push rdi                              ;#00446B91: 127                        uv 00 80  1 1847      
    mov rsi,[#00402B28] (or_edi)          ;#00446B92: 48:213065 8FBFFBFF         vu 40 00  1 1847      
    mov r15,h4                            ;#00446B99: 49:277 0000000000000040    uv 8000 00  1 1848      
    cmp rsi,r15                           ;#00446BA3: 4C:071376                  uv 00 8040  1 1849 8000   
    jl #00446BB3                          ;#00446BA6: 174 0B                     v  00 00  1 1849      
    add qword[rbx+rsi*4-16],1             ;#00446BA8: 48:203104263 F0 01         u  00 48  3 1850      
    cmp eax,622                           ;#00446BAE: 075 6E020000               vu 00 01  1 1852      
    push rsi                              ;#00446BB3: 126                        uv 00 40  1 1853      
    mov rdi,[rbp-488] (symtab[767])       ;#00446BB4: 48:213275 18FEFFFF         vu 80 20  1 1853      
    jmp #004404BD (:%pMkSq)               ;#00446BBB: 351 FD98FFFF               v  00 00  1 1854      
    mov rcx,33                            ;#00446BC0: 48:307301 21000000         uv 02 00  1 1855      
    mov rdx,89                            ;#00446BC7: 48:307302 59000000         vu 04 00  1 1855      
    call #004428DB (:%opFrame) (sprintf)  ;#00446BCE: 350 08BDFFFF               v  00 00  1 1856      
    mov rdi,[rbp+40] (prevebp)            ;#00446BD3: 48:213175 28               uv 80 20  1 1857      
    mov rax,[rdi-120]                     ;#00446BD7: 48:213107 88               uv 01 80  1 1860 80 *80*
    mov [rdi-120],r15                     ;#00446BDB: 4C:211177 88               vu 00 8080  1 1860      
    mov [rbp] (format),rax                ;#00446BDF: 48:211105 00               uv 00 21  1 1861      
    mov rdi,[rbp+40] (prevebp)            ;#00446BE3: 48:213175 28               vu 80 20  1 1861      
    mov rax,[rdi-488]                     ;#00446BE7: 48:213207 18FEFFFF         uv 01 80  1 1864    *80*
    xor rbx,rbx                           ;#00446BEE: 48:061333                  vu 08 08  1 1864      
    mov r15,h4                            ;#00446BF1: 49:277 0000000000000040    uv 8000 00  1 1865      
    cmp rax,r15                           ;#00446BFB: 4C:071370                  uv 00 8001  1 1866 8000   
    jl #00446C0B                          ;#00446BFE: 174 0B                     v  00 00  1 1866      
    add qword[rbx+rax*4-16],1             ;#00446C00: 48:203104203 F0 01         u  00 09  3 1867      
    cmp eax,767                           ;#00446C06: 075 FF020000               vu 00 01  1 1869      
    mov [rbp-8] (args),rax                ;#00446C0B: 48:211105 F8               uv 00 21  1 1870      
    mov qword[retaddr],#00446C1C          ;#00446C0F: 48:307105 20 1C6C4400      vu 00 20  1 1870      
    jmp #0044E450 (code:sprintf)          ;#00446C17: 351 34780000               v  00 00  1 1871      
    push rax                              ;#00446C1C: 120                        uv 00 01  1 1872      
    mov rcx,[rbp-120] (msg)               ;#00446C1D: 48:213115 88               vu 02 20  1 1872      
    mov r15,h4                            ;#00446C21: 49:277 0000000000000040    uv 8000 00  1 1873      
    cmp rcx,r15                           ;#00446C2B: 4C:071371                  uv 00 8002  1 1874 8000   
    jle #00446C40                         ;#00446C2E: 176 10                     v  00 00  1 1874      
    sub qword[rbx+rcx*4-16],1             ;#00446C30: 48:203154213 F0 01         u  00 0A  3 1875      
    jne #00446C40                         ;#00446C36: 165 08                     v  00 00  1 1877      
    mov rdx,rcx                           ;#00446C38: 48:213321                  uv 04 02  1 1878      
    call #004422DA (:%pDealloc)           ;#00446C3B: 350 9AB6FFFF               v  00 00  1 1878      
    pop dword[rbp-120] (msg)              ;#00446C40: 217105 88                  np 00 20  3 1879      
;  2397         end if
    jmp #00446CC1                         ;#00446C43: 353 7C                     v  00 00  1 1882      
;  2398     elsif msg_id=72 then        -- e72iri(edi)
;  2399         msg = sprintf(msg,or_edi)
    mov rcx,33                            ;#00446C45: 48:307301 21000000         uv 02 00  1 1883      
    mov rdx,89                            ;#00446C4C: 48:307302 59000000         vu 04 00  1 1883      
    call #004428DB (:%opFrame) (sprintf)  ;#00446C53: 350 83BCFFFF               v  00 00  1 1884      
    mov rdi,[rbp+40] (prevebp)            ;#00446C58: 48:213175 28               uv 80 20  1 1885      
    mov rax,[rdi-120]                     ;#00446C5C: 48:213107 88               uv 01 80  1 1888 80 *80*
    mov [rdi-120],r15                     ;#00446C60: 4C:211177 88               vu 00 8080  1 1888      
    mov [rbp] (format),rax                ;#00446C64: 48:211105 00               uv 00 21  1 1889      
    mov rsi,[#00402B28] (or_edi)          ;#00446C68: 48:213065 B9BEFBFF         vu 40 00  1 1889      
    mov [rbp-8] (args),rsi                ;#00446C6F: 48:211165 F8               uv 00 60  1 1890      
    mov r15,h4                            ;#00446C73: 49:277 0000000000000040    vu 8000 00  1 1890      
    cmp rsi,r15                           ;#00446C7D: 4C:071376                  uv 00 8040  1 1891      
    jl #00446C8D                          ;#00446C80: 174 0B                     v  00 00  1 1891      
    add qword[rbx+rsi*4-16],1             ;#00446C82: 48:203104263 F0 01         u  00 48  3 1892      
    cmp eax,622                           ;#00446C88: 075 6E020000               vu 00 01  1 1894      
    mov qword[retaddr],#00446C9A          ;#00446C8D: 48:307105 20 9A6C4400      uv 00 20  1 1895      
    jmp #0044E450 (code:sprintf)          ;#00446C95: 351 B6770000               v  00 00  1 1895      
    push rax                              ;#00446C9A: 120                        uv 00 01  1 1896      
    mov rdi,[rbp-120] (msg)               ;#00446C9B: 48:213175 88               vu 80 20  1 1896      
    mov r15,h4                            ;#00446C9F: 49:277 0000000000000040    uv 8000 00  1 1897      
    cmp rdi,r15                           ;#00446CA9: 4C:071377                  uv 00 8080  1 1898 8000   
    jle #00446CBE                         ;#00446CAC: 176 10                     v  00 00  1 1898      
    sub qword[rbx+rdi*4-16],1             ;#00446CAE: 48:203154273 F0 01         u  00 88  3 1899      
    jne #00446CBE                         ;#00446CB4: 165 08                     v  00 00  1 1901      
    mov rdx,rdi                           ;#00446CB6: 48:213327                  uv 04 80  1 1902      
    call #004422DA (:%pDealloc)           ;#00446CB9: 350 1CB6FFFF               v  00 00  1 1902      
    pop dword[rbp-120] (msg)              ;#00446CBE: 217105 88                  np 00 20  3 1903      
;  2400     end if
;  2401 --?2
;  2402 --/*
;  2403 
;  2404     if msg_id=1         -- e01tcf (ep1 is var idx)
;  2405     or msg_id=110 then  -- e110tce (ep1 is var addr)
;  2406         if msg_id=110 then
;  2407             ep1 = varIdx(ep1)
;  2408         end if
;  2409         si = "???"
;  2410         if ep1>0 and ep1<=length(symtab) then
;  2411             si = symtab[ep1][S_Name]
;  2412             if atom(si) then
;  2413                 si = sprintf("???(name=%d)",si)
;  2414             end if
;  2415         end if
;  2416         o = getValue(ep1, 50, length(si)+17, 1)
;  2417         msg = sprintf(msg,{si,o})       -- "type check failure, %s is %s\n"
;  2418     elsif msg_id=10         -- e10sspeos
;  2419       and ep1<0 then
;  2420         msg = sprintf("slice start(%d) less than negative length(%d)\n",{ep1,-ep2})
;  2421     elsif msg_id=11         -- e11sepeos
;  2422       and ep1<0 then
;  2423         msg = sprintf("slice end(%d) less than negative length(%d)\n",{ep1,-ep2})
;  2424     elsif msg_id=6          -- e06ioob
;  2425        or msg_id=9          -- e09slin
;  2426        or msg_id=10         -- e10sspeos
;  2427        or msg_id=11         -- e11sepeos
;  2428        or msg_id=31         -- e31mce
;  2429        or msg_id=116 then   -- e116rrnp
;  2430         msg = sprintf(msg,{ep1,ep2})
;  2431 --  elsif msg_id=120 then   -- e120fle
;  2432 ----        c = varIdx(ep1)
;  2433 --      o = getValue(ep1, 5, 0, 1)
;  2434 --      if ep2=1 then
;  2435 --          si = "init"
;  2436 --      elsif ep2=2 then
;  2437 --          si = "limit"
;  2438 --      elsif ep2=4 then
;  2439 --          si = "step"
;  2440 --      else
;  2441 --          si = "???"
;  2442 --      end if
;  2443 --      msg = sprintf(msg,{si,o})
;  2444 ----        msg = sprintf(msg,{ep1})
;  2445     elsif msg_id=121 then   -- e121flelimstep
;  2446         c = varIdx(ep1)
;  2447         o = getValue(c, 5, 0, 1)
;  2448         c = varIdx(ep2)
;  2449         o2 = getValue(c, 5, 0, 1)
;  2450         msg = sprintf(msg,{o,o2})
;  2451     elsif msg_id=14 then    -- e14NNsoXa
;  2452         if ep1>=1 and ep1<=length(e14ops) then
;  2453             o = e14ops[ep1]
;  2454         else
;  2455             o = "???"
;  2456         end if
;  2457         msg = sprintf(msg,{o,o})
;  2458     elsif msg_id=28 then    -- e28NNatXmbausq
;  2459         if ep1>=1 and ep1<=length(e28ops) then
;  2460             o = e28ops[ep1]
;  2461         else
;  2462             o = "???"
;  2463         end if
;  2464         msg = sprintf(msg,{o,o})
;  2465     elsif msg_id=30 then    -- e30ume
;  2466         -- Map any machine exceptions that occur on inc/add1 (refcount) 
;  2467         --  followed by a "helper" cmp eax,<varno>; ==> to e92:
;  2468         x6 = peek({era,6})
;  2469         --  inc dword[ebx+src*4-8]      377104 2s3 F8
;  2470         --  add dword[ebx+src*4-8],1    203104 2s3 F8 01
;  2471         if x6[2]=0o104
;  2472         and and_bits(x6[3],0o307)=0o203         -- sib(maybe!) of 0o2s3,
;  2473         and x6[4]=#F8 then                      -- displacement is -8
;  2474 --DEV 64-bit
;  2475             if x6[1]=0o377 -- inc
;  2476             and x6[5]=cmp_eax_imm32 then
;  2477                 ep1 = peek4u(era+5)
;  2478                 msg_id = 92
;  2479             elsif x6[1]=0o203 -- add
;  2480               and x6[5]=#01                     -- ie [ebx+idx*4-8],1
;  2481               and x6[6]=cmp_eax_imm32 then
;  2482                 ep1 = peek4u(era+6)
;  2483                 msg_id = 92
;  2484             end if
;  2485         end if
;  2486         if msg_id=92 then -- ie e92vhnbaav, aka "variable %s has not been assigned a value"
;  2487             msg = msgs[92]
;  2488             if ep1>0 and ep1<=length(symtab) then
;  2489                 si = symtab[ep1]
;  2490                 msg = sprintf(msg,si[S_Name..S_Name])
;  2491             else
;  2492                 printf(1,"diag.e: oops(4), var no[=%d] out of range\n",ep1) -- See note at top
;  2493             end if
;  2494         else
;  2495             if ep1=#C0000005-#100000000 then
;  2496                 wmsg = "[MEMORY VIOLATION]"
;  2497             elsif ep1=#C00000FD-#100000000 then
;  2498                 wmsg = "[STACK OVERFLOW]"
;  2499             else
;  2500                 wmsg = sprintf("#%08x",ep1)
;  2501             end if
;  2502             msg = sprintf(msg,{wmsg,era})
;  2503         end if
;  2504     elsif msg_id=92 then    -- e92vhnbaav
;  2505         c = varIdx(ep1)
;  2506         si = symtab[c][S_Name]
;  2507         if atom(si) then
;  2508             si = sprintf("???(name=%d)",si)
;  2509         end if
;  2510         msg = sprintf(msg,{si})
;  2511     elsif msg_id=97 then    -- e97he
;  2512 --      if ep1=112 then
;  2513 --          o = {"112(ERROR_DISK_FULL)"}
;  2514 --      else
;  2515             o = {sprintf("%d",ep1)}
;  2516 --      end if
;  2517         msg = sprintf(msg,o)
;  2518     elsif msg_id=98 then    -- e98fiofe
;  2519         if ep1=112 then
;  2520             o = {"112(ERROR_DISK_FULL)"}
;  2521         else
;  2522             o = {sprintf("%d",ep1)}
;  2523         end if
;  2524         msg = sprintf(msg,o)
;  2525         crashfile = "NUL"
;  2526     elsif msg_id>=120 and msg_id<=122 then  -- for loop errors:
;  2527         c = varIdx(ep1)
;  2528         o = getValue(c, 50, 18, 1)
;  2529         msg = sprintf(msg,{o})
;  2530     elsif msg_id=108 then       -- e108pe
;  2531         if ep1=87 then
;  2532             wmsg = "ERROR_INVALID_PARAMETER"
;  2533         else
;  2534             wmsg = sprintf("#%08x",ep1)
;  2535         end if
;  2536         msg = sprintf(msg,{wmsg})
;  2537     end if
;  2538 --puts(1,"d4\n")
;  2539 --*/
;  2540 --?3
;  2541 --?msg
;  2542 --?4
;  2543 --  if equal(crashfile,"") then return batchmode end if
;  2544     if equal(crashfile,"") then return end if
    mov rdi,qword[#00402240]              ;#00446CC1: 48:213075 78B5FBFF         uv 80 00  1 1906      
    mov rax,[#00402B88] (crashfile)       ;#00446CC8: 48:213005 B9BEFBFF         vu 01 00  1 1906      
    mov rsi,169                           ;#00446CCF: 48:307306 A9000000         uv 40 00  1 1907      
    mov rdx,662                           ;#00446CD6: 48:307302 96020000         vu 04 00  1 1907      
    call #0043FAF6 (:%opJccE)             ;#00446CDD: 350 148EFFFF               v  00 00  1 1908      
    je #0044298D (:%opRetf)               ;#00446CE2: 017204 A5BCFFFF            v  00 00  1 1909      
;  2545     if find(crashfile,{"NUL","NULL","/dev/null"}) then
    mov rcx,7                             ;#00446CE8: 48:307301 07000000         uv 02 00  1 1910      
    mov rdx,75                            ;#00446CEF: 48:307302 4B000000         vu 04 00  1 1910      
    call #004428DB (:%opFrame) (find)     ;#00446CF6: 350 E0BBFFFF               v  00 00  1 1911      
    mov rcx,[#00402B88] (crashfile)       ;#00446CFB: 48:213015 86BEFBFF         uv 02 00  1 1912      
    mov [rbp] (x),rcx                     ;#00446D02: 48:211115 00               uv 00 22  1 1913 02   
    mov r15,h4                            ;#00446D06: 49:277 0000000000000040    vu 8000 00  1 1913      
    cmp rcx,r15                           ;#00446D10: 4C:071371                  uv 00 8002  1 1914      
    jl #00446D1B                          ;#00446D13: 174 06                     v  00 00  1 1914      
    add qword[rbx+rcx*4-16],1             ;#00446D15: 48:203104213 F0 01         u  00 0A  3 1915      
    mov rsi,qword[#00402CE8]              ;#00446D1B: 48:213065 C6BFFBFF         vu 40 00  1 1917      
    mov [rbp-8] (s),rsi                   ;#00446D22: 48:211165 F8               uv 00 60  1 1918      
    add qword[rbx+rsi*4-16],1             ;#00446D26: 48:203104263 F0 01         u  00 48  3 1920    *40*
    mov qword[retaddr],#00446D39          ;#00446D2C: 48:307105 20 396D4400      vu 00 20  1 1922      
    jmp #0043DAD6 (code:find)             ;#00446D34: 351 9D6DFFFF               v  00 00  1 1923      
    test rax,rax                          ;#00446D39: 48:205300                  uv 00 01  1 1924      
    je #00446D4B                          ;#00446D3C: 164 0D                     v  00 00  1 1924      
;  2546         fn = -1
    mov qword[#00402618] (fn),-1          ;#00446D3E: 48:307005 CFB8FBFF FFFFFFFF uv 00 00  1 1925      
    jmp #00446D9E                         ;#00446D49: 353 53                     v  00 00  1 1925      
;  2547     elsif not atom(crashfile) then
    mov rdi,[#00402B88] (crashfile)       ;#00446D4B: 48:213075 36BEFBFF         uv 80 00  1 1926      
    mov r15,h4                            ;#00446D52: 49:277 0000000000000040    vu 8000 00  1 1926      
    cmp rdi,r15                           ;#00446D5C: 4C:071377                  uv 00 8080  1 1927      
    jl #00446D84                          ;#00446D5F: 174 23                     v  00 00  1 1927      
    cmp byte[rbx+rdi*4-1],#12             ;#00446D61: 200174273 FF 12            u  00 88  2 1928      
    je #00446D84                          ;#00446D66: 164 1C                     v  00 00  1 1929      
;  2548         fn = open(crashfile,"w")
    lea rdi,[#00402618] (fn)              ;#00446D68: 48:215075 A9B8FBFF         uv 80 00  1 1930      
    mov rax,[#00402B88] (crashfile)       ;#00446D6F: 48:213005 12BEFBFF         vu 01 00  1 1930      
    mov rcx,qword[#00402CF0]              ;#00446D76: 48:213015 73BFFBFF         uv 02 00  1 1931      
    call #0043E845 (:%opOpen)             ;#00446D7D: 350 C37AFFFF               v  00 00  1 1931      
    jmp #00446D9E                         ;#00446D82: 353 1A                     v  00 00  1 1932      
;  2549     else
;  2550         fn = open("ex.err","w")
    lea rdi,[#00402618] (fn)              ;#00446D84: 48:215075 8DB8FBFF         uv 80 00  1 1933      
    mov rax,qword[#00402CF8]              ;#00446D8B: 48:213005 66BFFBFF         vu 01 00  1 1933      
    mov rcx,qword[#00402CF0]              ;#00446D92: 48:213015 57BFFBFF         uv 02 00  1 1934      
    call #0043E845 (:%opOpen)             ;#00446D99: 350 A77AFFFF               v  00 00  1 1934      
;  2551     end if
;  2552 --puts(1,"ex.err open\n")
;  2553     msg2 = ""
    mov rsi,qword[#00402240]              ;#00446D9E: 48:213065 9BB4FBFF         uv 40 00  1 1935      
    mov [rbp-328] (msg2),rsi              ;#00446DA5: 48:211265 B8FEFFFF         uv 00 60  1 1936 40   
    add qword[rbx+rsi*4-16],1             ;#00446DAC: 48:203104263 F0 01         u  00 48  3 1938    *40*
;  2554     while 1 do
;  2555 --?rtn
;  2556         if rtn<1 or rtn>length(symtab) then -- See note at top
    mov rdi,1                             ;#00446DB2: 48:307307 01000000         vu 80 00  1 1940      
    mov rax,[rbp-216] (rtn)               ;#00446DB9: 48:213205 28FFFFFF         uv 01 20  1 1941      
    mov rsi,26                            ;#00446DC0: 48:307306 1A000000         vu 40 00  1 1941      
    mov rdx,700                           ;#00446DC7: 48:307302 BC020000         uv 04 00  1 1942      
    call #0043FA81 (:%opJcc)              ;#00446DCE: 350 AE8CFFFF               v  00 00  1 1942      
    jl #00446DFC                          ;#00446DD3: 174 27                     v  00 00  1 1943      
    lea rdi,[rbp-456] (symtab[746])       ;#00446DD5: 48:215275 38FEFFFF         uv 80 20  1 1944      
    mov rsi,[rbp] (symtab)                ;#00446DDC: 48:213165 00               vu 40 20  1 1944      
    mov rdx,673                           ;#00446DE0: 48:307302 A1020000         uv 04 00  1 1945      
    call #0043F28D (:%opLen)              ;#00446DE7: 350 A184FFFF               v  00 00  1 1945      
    mov rdi,[rbp-216] (rtn)               ;#00446DEC: 48:213275 28FFFFFF         uv 80 20  1 1946      
    cmp rdi,rcx                           ;#00446DF3: 48:071317                  uv 00 82  1 1947 80   
    jle #00446EA4                         ;#00446DF6: 017216 A8000000            v  00 00  1 1947      
;  2557             printf(1,"diag.e: oops, rtn[=%d] out of range[1..%d]\n",{rtn,length(symtab)})
    lea rdi,[rbp-456] (symtab[746])       ;#00446DFC: 48:215275 38FEFFFF         uv 80 20  1 1948      
    mov rsi,[rbp] (symtab)                ;#00446E03: 48:213165 00               vu 40 20  1 1948      
    mov rdx,673                           ;#00446E07: 48:307302 A1020000         uv 04 00  1 1949      
    call #0043F28D (:%opLen)              ;#00446E0E: 350 7A84FFFF               v  00 00  1 1949      
    lea rax,[rbp-488] (symtab[767])       ;#00446E13: 48:215205 18FEFFFF         uv 01 20  1 1950      
    mov rdx,2                             ;#00446E1A: 48:307302 02000000         vu 04 00  1 1950      
    push #00446E3A                        ;#00446E21: 150 3A6E4400               uv 00 00  1 1951      
    push rax                              ;#00446E26: 120                        vu 00 01  1 1951      
    push rcx                              ;#00446E27: 121                        uv 00 02  1 1952      
    push qword[rbp-216] (rtn)             ;#00446E28: 377265 28FFFFFF            np 00 20  2 1953      
    mov rdi,[rbp-488] (symtab[767])       ;#00446E2E: 48:213275 18FEFFFF         uv 80 20  1 1955      
    jmp #004404BD (:%pMkSq)               ;#00446E35: 351 8396FFFF               v  00 00  1 1955      
    mov rcx,4                             ;#00446E3A: 48:307301 04000000         uv 02 00  1 1956      
    mov rdx,94                            ;#00446E41: 48:307302 5E000000         vu 04 00  1 1956      
    call #004428DB (:%opFrame) (printf)   ;#00446E48: 350 8EBAFFFF               v  00 00  1 1957      
    mov qword[rbp] (fn),1                 ;#00446E4D: 48:307105 00 01000000      uv 00 20  1 1958      
    mov rax,qword[#00402D00]              ;#00446E55: 48:213005 A4BEFBFF         vu 01 00  1 1958      
    mov [rbp-8] (format),rax              ;#00446E5C: 48:211105 F8               uv 00 21  1 1959      
    add qword[rbx+rax*4-16],1             ;#00446E60: 48:203104203 F0 01         u  00 09  3 1961    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00446E66: 48:213175 28               vu 80 20  1 1963      
    mov rax,[rdi-488]                     ;#00446E6A: 48:213207 18FEFFFF         uv 01 80  1 1966    *80*
    xor rbx,rbx                           ;#00446E71: 48:061333                  vu 08 08  1 1966      
    mov r15,h4                            ;#00446E74: 49:277 0000000000000040    uv 8000 00  1 1967      
    cmp rax,r15                           ;#00446E7E: 4C:071370                  uv 00 8001  1 1968 8000   
    jl #00446E8E                          ;#00446E81: 174 0B                     v  00 00  1 1968      
    add qword[rbx+rax*4-16],1             ;#00446E83: 48:203104203 F0 01         u  00 09  3 1969      
    cmp eax,767                           ;#00446E89: 075 FF020000               vu 00 01  1 1971      
    mov [rbp-16] (args),rax               ;#00446E8E: 48:211105 F0               uv 00 21  1 1972      
    mov qword[retaddr],#00446E9F          ;#00446E92: 48:307105 20 9F6E4400      vu 00 20  1 1972      
    jmp #00451A31 (code:printf)           ;#00446E9A: 351 92AB0000               v  00 00  1 1973      
;  2558 --          exit
;  2559 --      end if
    jmp #004481EC                         ;#00446E9F: 351 48130000               v  00 00  1 1974      
;  2560 else
;  2561         sr = symtab[rtn]
    mov r15,h4                            ;#00446EA4: 49:277 0000000000000040    uv 8000 00  1 1975      
    cmp rsi,r15                           ;#00446EAE: 4C:071376                  uv 00 8040  1 1976 8000   
    jne #00446EBF                         ;#00446EB1: 165 0C                     v  00 00  1 1976      
    mov rsi,673                           ;#00446EB3: 48:307306 A1020000         uv 40 00  1 1977      
    call #00442D75 (:%pUnassigned)        ;#00446EBA: 350 B6BEFFFF               v  00 00  1 1977      
    mov r15,h4                            ;#00446EBF: 49:277 0000000000000040    uv 8000 00  1 1978      
    cmp rdi,r15                           ;#00446EC9: 4C:071377                  uv 00 8080  1 1979 8000   
    jne #00446EDA                         ;#00446ECC: 165 0C                     v  00 00  1 1979      
    mov rsi,700                           ;#00446ECE: 48:307306 BC020000         uv 40 00  1 1980      
    call #00442D75 (:%pUnassigned)        ;#00446ED5: 350 9BBEFFFF               v  00 00  1 1980      
    lea rcx,[rbp-136] (sr)                ;#00446EDA: 48:215215 78FFFFFF         uv 02 20  1 1981      
    mov rdx,673                           ;#00446EE1: 48:307302 A1020000         vu 04 00  1 1981      
    call #00441675 (:%pSubse1)            ;#00446EE8: 350 88A7FFFF               v  00 00  1 1982      
;  2562 --?sr
;  2563         sNTyp = sr[S_NTyp]
    mov rdi,2                             ;#00446EED: 48:307307 02000000         uv 80 00  1 1983      
    lea rcx,[rbp-96] (sNTyp)              ;#00446EF4: 48:215115 A0               vu 02 20  1 1983      
    mov rsi,[rbp-136] (sr)                ;#00446EF8: 48:213265 78FFFFFF         uv 40 20  1 1984      
    mov rdx,690                           ;#00446EFF: 48:307302 B2020000         vu 04 00  1 1984      
    call #004416F2 (:%pSubse1i)           ;#00446F06: 350 E7A7FFFF               v  00 00  1 1985      
;  2564         if sNTyp>=S_Type
    cmp rax,6                             ;#00446F0B: 48:203370 06               uv 00 01  1 1986      
    jl #004480B2                          ;#00446F0F: 017214 9D110000            v  00 00  1 1986      
;  2565         and (swod or and_bits(sr[S_State],K_wdb)) then -- skip without debug items
    mov rdi,4                             ;#00446F15: 48:307307 04000000         uv 80 00  1 1987      
    lea rcx,[rbp-440] (symtab[735])       ;#00446F1C: 48:215215 48FEFFFF         vu 02 20  1 1987      
    mov rsi,[rbp-136] (sr)                ;#00446F23: 48:213265 78FFFFFF         uv 40 20  1 1988      
    mov rdx,690                           ;#00446F2A: 48:307302 B2020000         vu 04 00  1 1988      
    call #00441675 (:%pSubse1)            ;#00446F31: 350 3FA7FFFF               v  00 00  1 1989      
    lea rdi,[rbp-456] (symtab[746])       ;#00446F36: 48:215275 38FEFFFF         uv 80 20  1 1990      
    mov rcx,[rbp-440] (symtab[735])       ;#00446F3D: 48:213215 48FEFFFF         vu 02 20  1 1990      
    mov rax,[#00402AB0] (K_wdb)           ;#00446F44: 48:213005 65BBFBFF         uv 01 00  1 1991      
    call #0043F6C1 (:%opAndBits)          ;#00446F4B: 350 7187FFFF               v  00 00  1 1991      
    mov rdi,[rbp-456] (symtab[746])       ;#00446F50: 48:213275 38FEFFFF         uv 80 20  1 1992      
    test rdi,rdi                          ;#00446F57: 48:205377                  uv 00 80  1 1993 80   
    je #004480B2                          ;#00446F5A: 017204 52110000            v  00 00  1 1993      
;  2566 
;  2567             lineno = sr[S_1stl]     -- line no of "procedure"/"function"/"type" keyword
    mov rdi,13                            ;#00446F60: 48:307307 0D000000         uv 80 00  1 1994      
    lea rcx,[rbp-40] (lineno)             ;#00446F67: 48:215115 D8               vu 02 20  1 1994      
    mov rsi,[rbp-136] (sr)                ;#00446F6B: 48:213265 78FFFFFF         uv 40 20  1 1995      
    mov rdx,690                           ;#00446F72: 48:307302 B2020000         vu 04 00  1 1995      
    call #004416F2 (:%pSubse1i)           ;#00446F79: 350 74A7FFFF               v  00 00  1 1996      
;  2568             linetab = sr[S_ltab]
    mov rdi,12                            ;#00446F7E: 48:307307 0C000000         uv 80 00  1 1997      
    lea rcx,[rbp-144] (linetab)           ;#00446F85: 48:215215 70FFFFFF         vu 02 20  1 1997      
    mov rsi,[rbp-136] (sr)                ;#00446F8C: 48:213265 78FFFFFF         uv 40 20  1 1998      
    mov rdx,690                           ;#00446F93: 48:307302 B2020000         vu 04 00  1 1998      
    call #00441675 (:%pSubse1)            ;#00446F9A: 350 D6A6FFFF               v  00 00  1 1999      
;  2569             lastline = linetab[$]
    mov rdi,-1                            ;#00446F9F: 48:307307 FFFFFFFF         uv 80 00  1 2000      
    lea rcx,[rbp-176] (lastline)          ;#00446FA6: 48:215215 50FFFFFF         vu 02 20  1 2000      
    mov rsi,[rbp-144] (linetab)           ;#00446FAD: 48:213265 70FFFFFF         uv 40 20  1 2001      
    mov rdx,691                           ;#00446FB4: 48:307302 B3020000         vu 04 00  1 2001      
    call #004416F2 (:%pSubse1i)           ;#00446FBB: 350 32A7FFFF               v  00 00  1 2002      
;  2570 
;  2571 --          returnoffset = era-sr[S_il]
;  2572             returnoffset = or_era-sr[S_il]
    mov rdi,11                            ;#00446FC0: 48:307307 0B000000         uv 80 00  1 2003      
    lea rcx,[rbp-440] (symtab[735])       ;#00446FC7: 48:215215 48FEFFFF         vu 02 20  1 2003      
    mov rsi,[rbp-136] (sr)                ;#00446FCE: 48:213265 78FFFFFF         uv 40 20  1 2004      
    mov rdx,690                           ;#00446FD5: 48:307302 B2020000         vu 04 00  1 2004      
    call #00441675 (:%pSubse1)            ;#00446FDC: 350 94A6FFFF               v  00 00  1 2005      
    mov rcx,[#00402B10] (or_era)          ;#00446FE1: 48:213015 28BBFBFF         uv 02 00  1 2006      
    mov r15,h4                            ;#00446FE8: 49:277 0000000000000040    vu 8000 00  1 2006      
    cmp rcx,r15                           ;#00446FF2: 4C:071371                  uv 00 8002  1 2007      
    jne #00447003                         ;#00446FF5: 165 0C                     v  00 00  1 2007      
    mov rsi,619                           ;#00446FF7: 48:307306 6B020000         uv 40 00  1 2008      
    call #00442D75 (:%pUnassigned)        ;#00446FFE: 350 72BDFFFF               v  00 00  1 2008      
    lea rdi,[rbp-112] (returnoffset)      ;#00447003: 48:215175 90               uv 80 20  1 2009      
    mov rax,[rbp-440] (symtab[735])       ;#00447007: 48:213205 48FEFFFF         vu 01 20  1 2009      
    call #0043F4D8 (:%opSub)              ;#0044700E: 350 C584FFFF               v  00 00  1 2010      
;  2573             --
;  2574             -- Convert the offset to a line number.
;  2575             -- A raw line table, as built in pilx86.e, is {skip|offset} where
;  2576             --  skip is <0, meaning -n lines emitted no code, and
;  2577             --  offset is >=0, a start offset of the next code-emitting line.
;  2578             --  There is also a dummy max entry added at the end of ilxlate().
;  2579             --  A line table should never have two (or more) skips in a row.
;  2580             -- When interpreting, we can just use the raw table directly: skip down the
;  2581             --  table until the offset is (b)reached, though we only know that when we 
;  2582             --  hit the next entry, as detailed in the following.
;  2583             --  Example1: a raw linetab of {-2,0,24,36} means offsets 0..23 are S_1st+2,
;  2584             --            24..35 are S_1st+3, and <0 or >=36 are out-of-bounds (so leave 
;  2585             --            lineno as -1). We only know that we should have stopped for an 
;  2586             --            offset of 17 when we hit the 24, and the lineno we want is that 
;  2587             --            before the +1 triggered by the 0 (or whatever line adjustment 
;  2588             --            we made on [2] when we decide to stop on [3]).
;  2589             --  Example2: for a linetab of {-14,#14,-3,#47...} and offset of #22, we only 
;  2590             --            know that #14 (S_1st+14) is the right entry when we hit the #47
;  2591             --            (S_1st+18), so there is a +1 and -(-3) that we must ignore.
;  2592             --            Note that while an exception at offset #47 means S_1st+18, a 
;  2593             --            return address of #47 would be the last call made by S_1st+14;
;  2594             --            hence add -1 when using a return address to report an error.
;  2595             -- When compiled, the linetab is packed: the offsets are converted to deltas
;  2596             --  (so most will be <=127) with #81,#80 used as lead-ins for word,dword to
;  2597             --  hold values that will not fit in a byte, and lastly stored as a "string"
;  2598             --  of binary (#00..#FF) bytes, making it just over 25% of the size, on 32
;  2599             --  bit systems, and just over 12.5% on 64 bit systems (ie worth having).
;  2600             --  A fairly straightforward decode of the next raw value (into lti) is
;  2601             --  followed by the same logic as above, except that when we start with a
;  2602             --  raw table we can test lastline directly, but not when unpacking it.
;  2603             -- Lastly note that [era] is incredibly fiddly to set, especially for
;  2604             --  low-level routines isolated several calls deep from user code. If
;  2605             --  the following yields -1, first suspect [era] rather than this code,
;  2606             --  except for e30ume, in which case suspect that "Address Mapping" in
;  2607             --  :!fehDiag (below) is missing a test/label.
;  2608             --
;  2609             if string(linetab) then -- compiled (deltas packed to string)
    mov rdi,[rbp-144] (linetab)           ;#00447013: 48:213275 70FFFFFF         uv 80 20  1 2011      
    cmp byte[rbx+rdi*4-1],#82             ;#0044701A: 200174273 FF 82            u  00 88  2 2014    *80*
    jne #0044740C                         ;#0044701F: 017205 E7030000            v  00 00  1 2015      
;  2610                 lineno = -1
    mov qword[rbp-40] (lineno),-1         ;#00447025: 48:307105 D8 FFFFFFFF      uv 00 20  1 2016      
;  2611                 if returnoffset>=0 then
    xor rdi,rdi                           ;#0044702D: 48:061377                  vu 80 80  1 2016      
    mov rax,[rbp-112] (returnoffset)      ;#00447030: 48:213105 90               uv 01 20  1 2017      
    mov rsi,25                            ;#00447034: 48:307306 19000000         vu 40 00  1 2017      
    mov rdx,687                           ;#0044703B: 48:307302 AF020000         uv 04 00  1 2018      
    call #0043FA81 (:%opJcc)              ;#00447042: 350 3A8AFFFF               v  00 00  1 2018      
    jl #00447569                          ;#00447047: 017214 1C050000            v  00 00  1 2019      
;  2612                     thisline = sr[S_1stl]
    mov rdi,13                            ;#0044704D: 48:307307 0D000000         uv 80 00  1 2020      
    lea rcx,[rbp-64] (thisline)           ;#00447054: 48:215115 C0               vu 02 20  1 2020      
    mov rsi,[rbp-136] (sr)                ;#00447058: 48:213265 78FFFFFF         uv 40 20  1 2021      
    mov rdx,690                           ;#0044705F: 48:307302 B2020000         vu 04 00  1 2021      
    call #004416F2 (:%pSubse1i)           ;#00447066: 350 87A6FFFF               v  00 00  1 2022      
;  2613                     linenxt = thisline
    mov [rbp-48] (linenxt),rax            ;#0044706B: 48:211105 D0               uv 00 21  1 2023      
;  2614                     skip = 0
    mov [rbp-72] (skip),rbx               ;#0044706F: 48:211135 B8               vu 00 28  1 2023      
;  2615                     base = 0
    mov [rbp-184] (base),rbx              ;#00447073: 48:211235 48FFFFFF         uv 00 28  1 2024      
;  2616                     for i=1 to length(linetab) do
    mov rcx,[rbp-144] (linetab)           ;#0044707A: 48:213215 70FFFFFF         vu 02 20  1 2024      
    mov rdi,[rbx+rcx*4-24]                ;#00447081: 48:48:213174213 E8         uv 80 0A  1 2027    *02*
    mov [rbp-456] (symtab[746]),rdi       ;#00447087: 48:211275 38FEFFFF         uv 00 A0  1 2028 80   
    mov qword[rbp-496] (i),1              ;#0044708E: 48:307205 10FEFFFF 01000000 vu 00 20  1 2028      
    cmp rdi,1                             ;#00447099: 48:201377 01000000         uv 00 80  1 2029      
    jl #00447569                          ;#004470A0: 017214 C3040000            v  00 00  1 2029      
;  2617                         if skip then
    mov rsi,[rbp-72] (skip)               ;#004470A6: 48:213165 B8               uv 40 20  1 2030      
    test rsi,rsi                          ;#004470AA: 48:205366                  uv 00 40  1 2031 40   
    je #004470D1                          ;#004470AD: 164 22                     v  00 00  1 2031      
;  2618                             skip -= 1
    sub rsi,1                             ;#004470AF: 48:203356 01               uv 40 40  1 2032      
    mov rdx,rsi                           ;#004470B3: 48:213326                  uv 04 40  1 2033 40   
    mov [rbp-72] (skip),rsi               ;#004470B6: 48:211165 B8               vu 00 60  1 2033      
    shl rdx,1                             ;#004470BA: 48:321342                  u  04 04  1 2034      
    jno #004473E5                         ;#004470BD: 017201 22030000            v  00 00  1 2034      
    lea rdi,[rbp-72] (skip)               ;#004470C3: 48:215175 B8               uv 80 20  1 2035      
    call #00442DA9 (:%pAddiii)            ;#004470C7: 350 DDBCFFFF               v  00 00  1 2035      
    jmp #004473E5                         ;#004470CC: 351 14030000               v  00 00  1 2036      
;  2619                         else
;  2620                             lti = linetab[i]
    mov rdi,[rbp-496] (i)                 ;#004470D1: 48:213275 10FEFFFF         uv 80 20  1 2037      
    mov rsi,[rbp-144] (linetab)           ;#004470D8: 48:213265 70FFFFFF         vu 40 20  1 2037      
    mov rdx,691                           ;#004470DF: 48:307302 B3020000         uv 04 00  1 2038      
    call #00441762 (:%pSubse1is)          ;#004470E6: 350 77A6FFFF               v  00 00  1 2038      
    mov [rbp-56] (lti),rax                ;#004470EB: 48:211105 C8               uv 00 21  1 2039      
;  2621                             if lti>#7F then
    cmp rax,127                           ;#004470EF: 48:203370 7F               vu 00 01  1 2039      
    jle #00447335                         ;#004470F3: 017216 3C020000            v  00 00  1 2040      
;  2622                                 if lti>#81 then
    cmp rax,129                           ;#004470F9: 48:075 81000000            uv 00 01  1 2041      
    jle #00447110                         ;#004470FF: 176 0F                     v  00 00  1 2041      
;  2623                                     lti = lti-#100
    sub rax,256                           ;#00447101: 48:055 00010000            uv 01 01  1 2042      
    mov [rbp-56] (lti),rax                ;#00447107: 48:211105 C8               uv 00 21  1 2043 01   
    jmp #00447335                         ;#0044710B: 351 25020000               v  00 00  1 2043      
;  2624                                 elsif lti=#81 then
    cmp rax,129                           ;#00447110: 48:075 81000000            uv 00 01  1 2044      
    jne #004471B9                         ;#00447116: 017205 9D000000            v  00 00  1 2044      
;  2625                                     lti = linetab[i+1]*#100+linetab[i+2]
    mov rcx,[rbp-496] (i)                 ;#0044711C: 48:213215 10FEFFFF         uv 02 20  1 2045      
    add rcx,1                             ;#00447123: 48:203301 01               uv 02 02  1 2046 02   
    mov rdi,rcx                           ;#00447127: 48:213371                  uv 80 02  1 2047 02   
    lea rcx,[rbp-440] (symtab[735])       ;#0044712A: 48:215215 48FEFFFF         vu 02 20  1 2047      
    mov rsi,[rbp-144] (linetab)           ;#00447131: 48:213265 70FFFFFF         uv 40 20  1 2048      
    mov rdx,691                           ;#00447138: 48:307302 B3020000         vu 04 00  1 2048      
    call #00441675 (:%pSubse1)            ;#0044713F: 350 31A5FFFF               v  00 00  1 2049      
    lea rdi,[rbp-376] (symtab[720])       ;#00447144: 48:215275 88FEFFFF         uv 80 20  1 2050      
    mov rcx,[rbp-440] (symtab[735])       ;#0044714B: 48:213215 48FEFFFF         vu 02 20  1 2050      
    mov rax,[#00402180] (MB_DEFBUTTON2)   ;#00447152: 48:213005 27B0FBFF         uv 01 00  1 2051      
    call #0043F67C (:%opMul)              ;#00447159: 350 1E85FFFF               v  00 00  1 2051      
    mov rdi,[rbp-496] (i)                 ;#0044715E: 48:213275 10FEFFFF         uv 80 20  1 2052      
    add rdi,2                             ;#00447165: 48:203307 02               uv 80 80  1 2053 80   
    lea rcx,[rbp-440] (symtab[735])       ;#00447169: 48:215215 48FEFFFF         vu 02 20  1 2053      
    mov rsi,[rbp-144] (linetab)           ;#00447170: 48:213265 70FFFFFF         uv 40 20  1 2054      
    mov rdx,691                           ;#00447177: 48:307302 B3020000         vu 04 00  1 2054      
    call #00441675 (:%pSubse1)            ;#0044717E: 350 F2A4FFFF               v  00 00  1 2055      
    mov rcx,[rbp-376] (symtab[720])       ;#00447183: 48:213215 88FEFFFF         uv 02 20  1 2056      
    mov rax,[rbp-440] (symtab[735])       ;#0044718A: 48:213205 48FEFFFF         vu 01 20  1 2056      
    add rcx,rax                           ;#00447191: 48:001301                  uv 02 03  1 2057      
    mov [rbp-56] (lti),rcx                ;#00447194: 48:211115 C8               uv 00 22  1 2058 02   
;  2626                                     if lti>#7FFF then
    cmp rcx,32767                         ;#00447198: 48:201371 FF7F0000         vu 00 02  1 2058      
    jle #004471AC                         ;#0044719F: 176 0B                     v  00 00  1 2059      
;  2627                                         lti -= #10000   -- (skip < -128)
    sub rcx,65536                         ;#004471A1: 48:201351 00000100         uv 02 02  1 2060      
    mov [rbp-56] (lti),rcx                ;#004471A8: 48:211115 C8               uv 00 22  1 2061 02   
;  2628                                     end if
;  2629                                     skip = 2
    mov qword[rbp-72] (skip),2            ;#004471AC: 48:307105 B8 02000000      vu 00 20  1 2061      
    jmp #00447335                         ;#004471B4: 351 7C010000               v  00 00  1 2062      
;  2630                                 elsif lti=#80 then
    cmp rax,128                           ;#004471B9: 48:075 80000000            uv 00 01  1 2063      
    jne #00447330                         ;#004471BF: 017205 6B010000            v  00 00  1 2063      
;  2631                                     lti = linetab[i+1]*#1000000+linetab[i+2]*#10000+linetab[i+3]*#100+linetab[i+4]
    mov rdi,[rbp-496] (i)                 ;#004471C5: 48:213275 10FEFFFF         uv 80 20  1 2064      
    add rdi,1                             ;#004471CC: 48:203307 01               uv 80 80  1 2065 80   
    lea rcx,[rbp-440] (symtab[735])       ;#004471D0: 48:215215 48FEFFFF         vu 02 20  1 2065      
    mov rsi,[rbp-144] (linetab)           ;#004471D7: 48:213265 70FFFFFF         uv 40 20  1 2066      
    mov rdx,691                           ;#004471DE: 48:307302 B3020000         vu 04 00  1 2066      
    call #00441675 (:%pSubse1)            ;#004471E5: 350 8BA4FFFF               v  00 00  1 2067      
    lea rdi,[rbp-376] (symtab[720])       ;#004471EA: 48:215275 88FEFFFF         uv 80 20  1 2068      
    mov rcx,[rbp-440] (symtab[735])       ;#004471F1: 48:213215 48FEFFFF         vu 02 20  1 2068      
    mov rax,qword[#00402D20]              ;#004471F8: 48:213005 21BBFBFF         uv 01 00  1 2069      
    call #0043F67C (:%opMul)              ;#004471FF: 350 7884FFFF               v  00 00  1 2069      
    mov rdi,[rbp-496] (i)                 ;#00447204: 48:213275 10FEFFFF         uv 80 20  1 2070      
    add rdi,2                             ;#0044720B: 48:203307 02               uv 80 80  1 2071 80   
    lea rcx,[rbp-440] (symtab[735])       ;#0044720F: 48:215215 48FEFFFF         vu 02 20  1 2071      
    mov rsi,[rbp-144] (linetab)           ;#00447216: 48:213265 70FFFFFF         uv 40 20  1 2072      
    mov rdx,691                           ;#0044721D: 48:307302 B3020000         vu 04 00  1 2072      
    call #00441675 (:%pSubse1)            ;#00447224: 350 4CA4FFFF               v  00 00  1 2073      
    lea rdi,[rbp-368] (symtab[719])       ;#00447229: 48:215275 90FEFFFF         uv 80 20  1 2074      
    mov rcx,[rbp-440] (symtab[735])       ;#00447230: 48:213215 48FEFFFF         vu 02 20  1 2074      
    mov rax,[MB_SETFOREGROUND]            ;#00447237: 48:213005 4AAFFBFF         uv 01 00  1 2075      
    call #0043F67C (:%opMul)              ;#0044723E: 350 3984FFFF               v  00 00  1 2075      
    lea rdi,[rbp-512] (symtab[782])       ;#00447243: 48:215275 00FEFFFF         uv 80 20  1 2076      
    mov rcx,[rbp-376] (symtab[720])       ;#0044724A: 48:213215 88FEFFFF         vu 02 20  1 2076      
    mov rax,[rbp-368] (symtab[719])       ;#00447251: 48:213205 90FEFFFF         uv 01 20  1 2077      
    call #0043F4AF (:%opAdd)              ;#00447258: 350 5282FFFF               v  00 00  1 2077      
    mov rdi,[rbp-496] (i)                 ;#0044725D: 48:213275 10FEFFFF         uv 80 20  1 2078      
    add rdi,3                             ;#00447264: 48:203307 03               uv 80 80  1 2079 80   
    lea rcx,[rbp-440] (symtab[735])       ;#00447268: 48:215215 48FEFFFF         vu 02 20  1 2079      
    mov rsi,[rbp-144] (linetab)           ;#0044726F: 48:213265 70FFFFFF         uv 40 20  1 2080      
    mov rdx,691                           ;#00447276: 48:307302 B3020000         vu 04 00  1 2080      
    call #00441675 (:%pSubse1)            ;#0044727D: 350 F3A3FFFF               v  00 00  1 2081      
    lea rdi,[rbp-376] (symtab[720])       ;#00447282: 48:215275 88FEFFFF         uv 80 20  1 2082      
    mov rcx,[rbp-440] (symtab[735])       ;#00447289: 48:213215 48FEFFFF         vu 02 20  1 2082      
    mov rax,[#00402180] (MB_DEFBUTTON2)   ;#00447290: 48:213005 E9AEFBFF         uv 01 00  1 2083      
    call #0043F67C (:%opMul)              ;#00447297: 350 E083FFFF               v  00 00  1 2083      
    lea rdi,[rbp-368] (symtab[719])       ;#0044729C: 48:215275 90FEFFFF         uv 80 20  1 2084      
    mov rcx,[rbp-512] (symtab[782])       ;#004472A3: 48:213215 00FEFFFF         vu 02 20  1 2084      
    mov rax,[rbp-376] (symtab[720])       ;#004472AA: 48:213205 88FEFFFF         uv 01 20  1 2085      
    call #0043F4AF (:%opAdd)              ;#004472B1: 350 F981FFFF               v  00 00  1 2085      
    mov rdi,[rbp-496] (i)                 ;#004472B6: 48:213275 10FEFFFF         uv 80 20  1 2086      
    add rdi,4                             ;#004472BD: 48:203307 04               uv 80 80  1 2087 80   
    lea rcx,[rbp-440] (symtab[735])       ;#004472C1: 48:215215 48FEFFFF         vu 02 20  1 2087      
    mov rsi,[rbp-144] (linetab)           ;#004472C8: 48:213265 70FFFFFF         uv 40 20  1 2088      
    mov rdx,691                           ;#004472CF: 48:307302 B3020000         vu 04 00  1 2088      
    call #00441675 (:%pSubse1)            ;#004472D6: 350 9AA3FFFF               v  00 00  1 2089      
    lea rdi,[rbp-56] (lti)                ;#004472DB: 48:215175 C8               uv 80 20  1 2090      
    mov rcx,[rbp-368] (symtab[719])       ;#004472DF: 48:213215 90FEFFFF         vu 02 20  1 2090      
    mov rax,[rbp-440] (symtab[735])       ;#004472E6: 48:213205 48FEFFFF         uv 01 20  1 2091      
    call #0043F4BE (:%opAddi)             ;#004472ED: 350 CC81FFFF               v  00 00  1 2091      
;  2632                                     if lti>#7FFFFFFF then
    mov rdi,qword[#004022B8]              ;#004472F2: 48:213075 BFAFFBFF         uv 80 00  1 2092      
    mov rax,[rbp-56] (lti)                ;#004472F9: 48:213105 C8               vu 01 20  1 2092      
    mov rsi,226                           ;#004472FD: 48:307306 E2000000         uv 40 00  1 2093      
    mov rdx,680                           ;#00447304: 48:307302 A8020000         vu 04 00  1 2093      
    call #0043FA81 (:%opJcc)              ;#0044730B: 350 7187FFFF               v  00 00  1 2094      
    jle #00447326                         ;#00447310: 176 14                     v  00 00  1 2095      
;  2633                                         lti -= #100000000 -- (skip < -32,768?? [very rare, if ever])
    lea rdi,[rbp-56] (lti)                ;#00447312: 48:215175 C8               uv 80 20  1 2096      
    mov rcx,[rbp-56] (lti)                ;#00447316: 48:213115 C8               vu 02 20  1 2096      
    mov rax,qword[#00402D28]              ;#0044731A: 48:213005 07BAFBFF         uv 01 00  1 2097      
    call #0043F4EB (:%opSubi)             ;#00447321: 350 C581FFFF               v  00 00  1 2097      
;  2634                                     end if
;  2635                                     skip = 4
    mov qword[rbp-72] (skip),4            ;#00447326: 48:307105 B8 04000000      uv 00 20  1 2098      
    jmp #00447335                         ;#0044732E: 353 05                     v  00 00  1 2098      
;  2636                                 else
;  2637                                     ?9/0    -- (sanity check, should never happen)
    call #00442DD2 (:%pDiv0)              ;#00447330: 350 9DBAFFFF               v  00 00  1 2099      
;  2638                                 end if
;  2639                             end if
;  2640                             if lti<0 then       -- -n lines emitted no code
    mov rsi,[rbp-56] (lti)                ;#00447335: 48:213165 C8               uv 40 20  1 2100      
    cmp rsi,0                             ;#00447339: 48:203376 00               uv 00 40  1 2101 40   
    jge #00447364                         ;#0044733D: 175 25                     v  00 00  1 2101      
;  2641                                 linenxt -= lti
    mov rdi,[rbp-48] (linenxt)            ;#0044733F: 48:213175 D0               uv 80 20  1 2102      
    sub rdi,rsi                           ;#00447343: 48:051367                  uv 80 C0  1 2103 80   
    mov rdx,rdi                           ;#00447346: 48:213327                  uv 04 80  1 2104 80   
    mov [rbp-48] (linenxt),rdi            ;#00447349: 48:211175 D0               vu 00 A0  1 2104      
    shl rdx,1                             ;#0044734D: 48:321342                  u  04 04  1 2105      
    jno #004473E5                         ;#00447350: 017201 8F000000            v  00 00  1 2105      
    lea rdi,[rbp-48] (linenxt)            ;#00447356: 48:215175 D0               uv 80 20  1 2106      
    call #00442DA9 (:%pAddiii)            ;#0044735A: 350 4ABAFFFF               v  00 00  1 2106      
    jmp #004473E5                         ;#0044735F: 351 81000000               v  00 00  1 2107      
;  2642                             else                -- start offset of next line
;  2643                                 tmp = base
    mov rcx,[rbp-184] (base)              ;#00447364: 48:213215 48FFFFFF         uv 02 20  1 2108      
    mov [rbp-192] (tmp),rcx               ;#0044736B: 48:211215 40FFFFFF         uv 00 22  1 2109 02   
;  2644                                 base += lti
    add rcx,rsi                           ;#00447372: 48:001361                  vu 02 42  1 2109      
    mov rdx,rcx                           ;#00447375: 48:213321                  uv 04 02  1 2110      
    mov [rbp-184] (base),rcx              ;#00447378: 48:211215 48FFFFFF         vu 00 22  1 2110      
    shl rdx,1                             ;#0044737F: 48:321342                  u  04 04  1 2111      
    jno #00447390                         ;#00447382: 161 0C                     v  00 00  1 2111      
    lea rdi,[rbp-184] (base)              ;#00447384: 48:215275 48FFFFFF         uv 80 20  1 2112      
    call #00442DA9 (:%pAddiii)            ;#0044738B: 350 19BAFFFF               v  00 00  1 2112      
;  2645                                 lti = tmp
    mov rax,[rbp-192] (tmp)               ;#00447390: 48:213205 40FFFFFF         uv 01 20  1 2113      
    mov [rbp-56] (lti),rax                ;#00447397: 48:211105 C8               uv 00 21  1 2114 01   
;  2646 --                              if returnoffset<=lti then exit end if   -- all done
;  2647                                 if returnoffset<lti then
    mov rdi,rax                           ;#0044739B: 48:211307                  vu 80 01  1 2114      
    mov rax,[rbp-112] (returnoffset)      ;#0044739E: 48:213105 90               uv 01 20  1 2115      
    mov rsi,680                           ;#004473A2: 48:307306 A8020000         vu 40 00  1 2115      
    mov rdx,687                           ;#004473A9: 48:307302 AF020000         uv 04 00  1 2116      
    call #0043FA81 (:%opJcc)              ;#004473B0: 350 CC86FFFF               v  00 00  1 2116      
    jge #004473C4                         ;#004473B5: 175 0D                     v  00 00  1 2117      
;  2648                                     lineno = thisline
    mov rdi,[rbp-64] (thisline)           ;#004473B7: 48:213175 C0               uv 80 20  1 2118      
    mov [rbp-40] (lineno),rdi             ;#004473BB: 48:211175 D8               uv 00 A0  1 2119 80   
;  2649                                     exit
    jmp #00447569                         ;#004473BF: 351 A5010000               v  00 00  1 2119      
;  2650                                 end if  -- all done
;  2651                                 thisline = linenxt
    mov rsi,[rbp-48] (linenxt)            ;#004473C4: 48:213165 D0               uv 40 20  1 2120      
    mov [rbp-64] (thisline),rsi           ;#004473C8: 48:211165 C0               uv 00 60  1 2121 40   
;  2652                                 linenxt += 1
    add rsi,1                             ;#004473CC: 48:203306 01               vu 40 40  1 2121      
    mov rdx,rsi                           ;#004473D0: 48:213326                  uv 04 40  1 2122      
    mov [rbp-48] (linenxt),rsi            ;#004473D3: 48:211165 D0               vu 00 60  1 2122      
    shl rdx,1                             ;#004473D7: 48:321342                  u  04 04  1 2123      
    jno #004473E5                         ;#004473DA: 161 09                     v  00 00  1 2123      
    lea rdi,[rbp-48] (linenxt)            ;#004473DC: 48:215175 D0               uv 80 20  1 2124      
    call #00442DA9 (:%pAddiii)            ;#004473E0: 350 C4B9FFFF               v  00 00  1 2124      
;  2653                             end if
;  2654                         end if
;  2655                     end for
    mov rcx,[rbp-496] (i)                 ;#004473E5: 48:213215 10FEFFFF         uv 02 20  1 2125      
    mov rax,[rbp-456] (symtab[746])       ;#004473EC: 48:213205 38FEFFFF         vu 01 20  1 2125      
    add rcx,1                             ;#004473F3: 48:203301 01               uv 02 02  1 2126      
    cmp rcx,rax                           ;#004473F7: 48:073310                  uv 00 03  1 2127 02   
    mov [rbp-496] (i),rcx                 ;#004473FA: 48:211215 10FEFFFF         vu 00 22  1 2127      
    jle #004470A6                         ;#00447401: 017216 9FFCFFFF            v  00 00  1 2128      
;  2656                 end if
    jmp #00447569                         ;#00447407: 351 5D010000               v  00 00  1 2129      
;  2657             else -- interpreted (raw linetab, a dword-sequence, not converted to deltas/packed)
;  2658                 lineno = sr[S_1stl]
    mov rdi,13                            ;#0044740C: 48:307307 0D000000         uv 80 00  1 2130      
    lea rcx,[rbp-40] (lineno)             ;#00447413: 48:215115 D8               vu 02 20  1 2130      
    mov rsi,[rbp-136] (sr)                ;#00447417: 48:213265 78FFFFFF         uv 40 20  1 2131      
    mov rdx,690                           ;#0044741E: 48:307302 B2020000         vu 04 00  1 2131      
    call #004416F2 (:%pSubse1i)           ;#00447425: 350 C8A2FFFF               v  00 00  1 2132      
;  2659                 lastline = linetab[$]
    mov rdi,-1                            ;#0044742A: 48:307307 FFFFFFFF         uv 80 00  1 2133      
    lea rcx,[rbp-176] (lastline)          ;#00447431: 48:215215 50FFFFFF         vu 02 20  1 2133      
    mov rsi,[rbp-144] (linetab)           ;#00447438: 48:213265 70FFFFFF         uv 40 20  1 2134      
    mov rdx,691                           ;#0044743F: 48:307302 B3020000         vu 04 00  1 2134      
    call #004416F2 (:%pSubse1i)           ;#00447446: 350 A7A2FFFF               v  00 00  1 2135      
;  2660                 if returnoffset<0 or returnoffset>=lastline then
    xor rdi,rdi                           ;#0044744B: 48:061377                  uv 80 80  1 2136      
    mov rax,[rbp-112] (returnoffset)      ;#0044744E: 48:213105 90               vu 01 20  1 2136      
    mov rsi,25                            ;#00447452: 48:307306 19000000         uv 40 00  1 2137      
    mov rdx,687                           ;#00447459: 48:307302 AF020000         vu 04 00  1 2137      
    call #0043FA81 (:%opJcc)              ;#00447460: 350 1C86FFFF               v  00 00  1 2138      
    jl #00447487                          ;#00447465: 174 20                     v  00 00  1 2139      
    mov rdi,[rbp-176] (lastline)          ;#00447467: 48:213275 50FFFFFF         uv 80 20  1 2140      
    mov rax,[rbp-112] (returnoffset)      ;#0044746E: 48:213105 90               vu 01 20  1 2140      
    mov rsi,695                           ;#00447472: 48:307306 B7020000         uv 40 00  1 2141      
    mov rdx,687                           ;#00447479: 48:307302 AF020000         vu 04 00  1 2141      
    call #0043FA81 (:%opJcc)              ;#00447480: 350 FC85FFFF               v  00 00  1 2142      
    jl #00447494                          ;#00447485: 174 0D                     v  00 00  1 2143      
;  2661                     lineno = -1
    mov qword[rbp-40] (lineno),-1         ;#00447487: 48:307105 D8 FFFFFFFF      uv 00 20  1 2144      
    jmp #00447569                         ;#0044748F: 351 D5000000               v  00 00  1 2144      
;  2662                 else
;  2663                     linenxt = lineno
    mov rcx,[rbp-40] (lineno)             ;#00447494: 48:213115 D8               uv 02 20  1 2145      
    mov [rbp-48] (linenxt),rcx            ;#00447498: 48:211115 D0               uv 00 22  1 2146 02   
;  2664                     for i=1 to length(linetab) do
    mov rsi,[rbp-144] (linetab)           ;#0044749C: 48:213265 70FFFFFF         vu 40 20  1 2146      
    mov rdi,[rbx+rsi*4-24]                ;#004474A3: 48:48:213174263 E8         uv 80 48  1 2149    *40*
    mov [rbp-504] (symtab[779]),rdi       ;#004474A9: 48:211275 08FEFFFF         uv 00 A0  1 2150 80   
    mov qword[rbp-520] (i),1              ;#004474B0: 48:307205 F8FDFFFF 01000000 vu 00 20  1 2150      
    cmp rdi,1                             ;#004474BB: 48:201377 01000000         uv 00 80  1 2151      
    jl #00447569                          ;#004474C2: 017214 A1000000            v  00 00  1 2151      
;  2665                         lti = linetab[i]
    mov rdi,[rbp-520] (i)                 ;#004474C8: 48:213275 F8FDFFFF         uv 80 20  1 2152      
    lea rcx,[rbp-56] (lti)                ;#004474CF: 48:215115 C8               vu 02 20  1 2152      
    mov rsi,[rbp-144] (linetab)           ;#004474D3: 48:213265 70FFFFFF         uv 40 20  1 2153      
    mov rdx,691                           ;#004474DA: 48:307302 B3020000         vu 04 00  1 2153      
    call #004416F2 (:%pSubse1i)           ;#004474E1: 350 0CA2FFFF               v  00 00  1 2154      
;  2666                         if lti<0 then       -- -n lines emitted no code
    cmp rax,0                             ;#004474E6: 48:203370 00               uv 00 01  1 2155      
    jge #0044750A                         ;#004474EA: 175 1E                     v  00 00  1 2155      
;  2667                             linenxt -= lti
    mov rcx,[rbp-48] (linenxt)            ;#004474EC: 48:213115 D0               uv 02 20  1 2156      
    sub rcx,rax                           ;#004474F0: 48:051301                  uv 02 03  1 2157 02   
    mov rdx,rcx                           ;#004474F3: 48:213321                  uv 04 02  1 2158 02   
    mov [rbp-48] (linenxt),rcx            ;#004474F6: 48:211115 D0               vu 00 22  1 2158      
    shl rdx,1                             ;#004474FA: 48:321342                  u  04 04  1 2159      
    jno #00447547                         ;#004474FD: 161 48                     v  00 00  1 2159      
    lea rdi,[rbp-48] (linenxt)            ;#004474FF: 48:215175 D0               uv 80 20  1 2160      
    call #00442DA9 (:%pAddiii)            ;#00447503: 350 A1B8FFFF               v  00 00  1 2160      
    jmp #00447547                         ;#00447508: 353 3D                     v  00 00  1 2161      
;  2668                         else                -- start offset of next line
;  2669 --                          if returnoffset<=lti then exit end if   -- all done
;  2670                             if returnoffset<lti then exit end if    -- all done
    mov rdi,rax                           ;#0044750A: 48:211307                  uv 80 01  1 2162      
    mov rax,[rbp-112] (returnoffset)      ;#0044750D: 48:213105 90               vu 01 20  1 2162      
    mov rsi,680                           ;#00447511: 48:307306 A8020000         uv 40 00  1 2163      
    mov rdx,687                           ;#00447518: 48:307302 AF020000         vu 04 00  1 2163      
    call #0043FA81 (:%opJcc)              ;#0044751F: 350 5D85FFFF               v  00 00  1 2164      
    jl #00447569                          ;#00447524: 174 43                     v  00 00  1 2165      
;  2671                             lineno = linenxt
    mov rdi,[rbp-48] (linenxt)            ;#00447526: 48:213175 D0               uv 80 20  1 2166      
    mov [rbp-40] (lineno),rdi             ;#0044752A: 48:211175 D8               uv 00 A0  1 2167 80   
;  2672                             linenxt += 1
    add rdi,1                             ;#0044752E: 48:203307 01               vu 80 80  1 2167      
    mov rdx,rdi                           ;#00447532: 48:213327                  uv 04 80  1 2168      
    mov [rbp-48] (linenxt),rdi            ;#00447535: 48:211175 D0               vu 00 A0  1 2168      
    shl rdx,1                             ;#00447539: 48:321342                  u  04 04  1 2169      
    jno #00447547                         ;#0044753C: 161 09                     v  00 00  1 2169      
    lea rdi,[rbp-48] (linenxt)            ;#0044753E: 48:215175 D0               uv 80 20  1 2170      
    call #00442DA9 (:%pAddiii)            ;#00447542: 350 62B8FFFF               v  00 00  1 2170      
;  2673                         end if
;  2674                     end for
    mov rsi,[rbp-520] (i)                 ;#00447547: 48:213265 F8FDFFFF         uv 40 20  1 2171      
    mov rcx,[rbp-504] (symtab[779])       ;#0044754E: 48:213215 08FEFFFF         vu 02 20  1 2171      
    add rsi,1                             ;#00447555: 48:203306 01               uv 40 40  1 2172      
    cmp rsi,rcx                           ;#00447559: 48:073361                  uv 00 42  1 2173 40   
    mov [rbp-520] (i),rsi                 ;#0044755C: 48:211265 F8FDFFFF         vu 00 60  1 2173      
    jle #004474C8                         ;#00447563: 017216 5FFFFFFF            v  00 00  1 2174      
;  2675                 end if
;  2676             end if
;  2677 
;  2678             if lineno=-1 and find(msg_id,{92,30}) then
    mov rax,[rbp-40] (lineno)             ;#00447569: 48:213105 D8               uv 01 20  1 2175      
    cmp rax,-1                            ;#0044756D: 48:203370 FF               uv 00 01  1 2176 01   
    jne #00447698                         ;#00447571: 017205 21010000            v  00 00  1 2176      
    mov rcx,7                             ;#00447577: 48:307301 07000000         uv 02 00  1 2177      
    mov rdx,75                            ;#0044757E: 48:307302 4B000000         vu 04 00  1 2177      
    call #004428DB (:%opFrame) (find)     ;#00447585: 350 51B3FFFF               v  00 00  1 2178      
    mov rdi,[#00402BA8] (msg_id)          ;#0044758A: 48:213075 17B6FBFF         uv 80 00  1 2179      
    mov [rbp] (x),rdi                     ;#00447591: 48:211175 00               uv 00 A0  1 2180 80   
    mov rcx,qword[#00402D30]              ;#00447595: 48:213015 94B7FBFF         vu 02 00  1 2180      
    mov [rbp-8] (s),rcx                   ;#0044759C: 48:211115 F8               uv 00 22  1 2181      
    add qword[rbx+rcx*4-16],1             ;#004475A0: 48:203104213 F0 01         u  00 0A  3 2183    *02*
    mov qword[retaddr],#004475B3          ;#004475A6: 48:307105 20 B3754400      vu 00 20  1 2185      
    jmp #0043DAD6 (code:find)             ;#004475AE: 351 2365FFFF               v  00 00  1 2186      
    test rax,rax                          ;#004475B3: 48:205300                  uv 00 01  1 2187      
    je #00447698                          ;#004475B6: 017204 DC000000            v  00 00  1 2187      
;  2679 --?-1
;  2680 --              --
;  2681 --              -- If you have opFrame / mov a,b / mov c,d / opCall, where b or d is
;  2682 --              --  unassigned (a,c are parameters of the routine about to be called),
;  2683 --              --  then the e92 will try to locate the failure address within the 
;  2684 --              --  routine about to be called; pop (at most one not yet active) frame 
;  2685 --              --  and try again:
;  2686 --              --
;  2687 --DEV done above, I think: [needs testing in terror.exw!]
;  2688 --              if msg_id=30 then
;  2689 ----DEV:
;  2690 ----                    if c_func(xIsBadReadPtr,{era,1}) then
;  2691 ----                        printf(1,"diag.e: oops, invalid <era>[%08x]\n",era)
;  2692 ----                    els
;  2693 --                  if peek({era,2})=incd_sib then
;  2694 ----DEV:
;  2695 ----                        if c_func(xIsBadReadPtr,{era-5,1}) then
;  2696 ----                            printf(1,"diag.e: oops, invalid <era-5>[%08x]\n",era)
;  2697 ----                        els
;  2698 --                      if peek(era-5)=cmp_eax_imm32 then
;  2699 --                          msg = msgs[92]  -- ie e92vhnbaav, aka
;  2700 --                                  -- "variable %s has not been assigned a value"
;  2701 --                          ep1 = peek4u(era-4)
;  2702 --                          if ep1>0 and ep1<=length(symtab) then
;  2703 --                              si = symtab[ep1]
;  2704 --                              msg = sprintf(msg,si[S_Name..S_Name])
;  2705 --                          else
;  2706 --                              printf(1,"diag.e: oops(2), var no[=%d] out of range\n",ep1) -- See note at top
;  2707 --                          end if
;  2708 --                      end if
;  2709 --                  end if
;  2710 --              end if
;  2711 --              msg_id = 0
;  2712 --              if not retN() then  -- See note at top
;  2713 --                  printf(1,"diag.e: oops, lineno=-1/e92/not retD(), era=#%08x\n",era)
;  2714 --                  exit
;  2715 --              end if
;  2716 --DEV removed 13/5/15 (for test/terror...)
;  2717                 if show_bad_era then
;  2718                     msg2 = sprintf("  (warning: lineno of -1 for era of #%08x)\n",{or_era})
    lea rax,[rbp-488] (symtab[767])       ;#004475BC: 48:215205 18FEFFFF         uv 01 20  1 2188      
    mov rdx,1                             ;#004475C3: 48:307302 01000000         vu 04 00  1 2188      
    push #004475FE                        ;#004475CA: 150 FE754400               uv 00 00  1 2189      
    push rax                              ;#004475CF: 120                        vu 00 01  1 2189      
    mov rsi,[#00402B10] (or_era)          ;#004475D0: 48:213065 39B5FBFF         uv 40 00  1 2190      
    mov r15,h4                            ;#004475D7: 49:277 0000000000000040    vu 8000 00  1 2190      
    cmp rsi,r15                           ;#004475E1: 4C:071376                  uv 00 8040  1 2191      
    jl #004475F1                          ;#004475E4: 174 0B                     v  00 00  1 2191      
    add qword[rbx+rsi*4-16],1             ;#004475E6: 48:203104263 F0 01         u  00 48  3 2192      
    cmp eax,619                           ;#004475EC: 075 6B020000               vu 00 01  1 2194      
    push rsi                              ;#004475F1: 126                        uv 00 40  1 2195      
    mov rdi,[rbp-488] (symtab[767])       ;#004475F2: 48:213275 18FEFFFF         vu 80 20  1 2195      
    jmp #004404BD (:%pMkSq)               ;#004475F9: 351 BF8EFFFF               v  00 00  1 2196      
    mov rcx,33                            ;#004475FE: 48:307301 21000000         uv 02 00  1 2197      
    mov rdx,89                            ;#00447605: 48:307302 59000000         vu 04 00  1 2197      
    call #004428DB (:%opFrame) (sprintf)  ;#0044760C: 350 CAB2FFFF               v  00 00  1 2198      
    mov rax,qword[#00402D38]              ;#00447611: 48:213005 20B7FBFF         uv 01 00  1 2199      
    mov [rbp] (format),rax                ;#00447618: 48:211105 00               uv 00 21  1 2200 01   
    add qword[rbx+rax*4-16],1             ;#0044761C: 48:203104203 F0 01         u  00 09  3 2202    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00447622: 48:213175 28               vu 80 20  1 2204      
    mov rax,[rdi-488]                     ;#00447626: 48:213207 18FEFFFF         uv 01 80  1 2207    *80*
    xor rbx,rbx                           ;#0044762D: 48:061333                  vu 08 08  1 2207      
    mov r15,h4                            ;#00447630: 49:277 0000000000000040    uv 8000 00  1 2208      
    cmp rax,r15                           ;#0044763A: 4C:071370                  uv 00 8001  1 2209 8000   
    jl #0044764A                          ;#0044763D: 174 0B                     v  00 00  1 2209      
    add qword[rbx+rax*4-16],1             ;#0044763F: 48:203104203 F0 01         u  00 09  3 2210      
    cmp eax,767                           ;#00447645: 075 FF020000               vu 00 01  1 2212      
    mov [rbp-8] (args),rax                ;#0044764A: 48:211105 F8               uv 00 21  1 2213      
    mov qword[retaddr],#0044765B          ;#0044764E: 48:307105 20 5B764400      vu 00 20  1 2213      
    jmp #0044E450 (code:sprintf)          ;#00447656: 351 F56D0000               v  00 00  1 2214      
    push rax                              ;#0044765B: 120                        uv 00 01  1 2215      
    mov rcx,[rbp-328] (msg2)              ;#0044765C: 48:213215 B8FEFFFF         vu 02 20  1 2215      
    mov r15,h4                            ;#00447663: 49:277 0000000000000040    uv 8000 00  1 2216      
    cmp rcx,r15                           ;#0044766D: 4C:071371                  uv 00 8002  1 2217 8000   
    jle #00447682                         ;#00447670: 176 10                     v  00 00  1 2217      
    sub qword[rbx+rcx*4-16],1             ;#00447672: 48:203154213 F0 01         u  00 0A  3 2218      
    jne #00447682                         ;#00447678: 165 08                     v  00 00  1 2220      
    mov rdx,rcx                           ;#0044767A: 48:213321                  uv 04 02  1 2221      
    call #004422DA (:%pDealloc)           ;#0044767D: 350 58ACFFFF               v  00 00  1 2221      
    pop dword[rbp-328] (msg2)             ;#00447682: 217205 B8FEFFFF            np 00 20  3 2222      
;  2719                 end if
;  2720                 rtype = 1   -- 1 skip (lineno=-1)
    mov qword[rbp-296] (rtype),1          ;#00447688: 48:307205 D8FEFFFF 01000000 uv 00 20  1 2225      
    jmp #004481E5                         ;#00447693: 351 4D0B0000               v  00 00  1 2225      
;  2721             else
;  2722 --?lineno
;  2723 --?sr
;  2724 --?sr[S_FPno]
;  2725 --?9997
;  2726 --?symtab[T_fileset]
;  2727 --?9998
;  2728                 filename = symtab[T_fileset][sr[S_FPno]][1..2]&lineno
    mov rdi,3                             ;#00447698: 48:307307 03000000         uv 80 00  1 2226      
    lea rcx,[rbp-440] (symtab[735])       ;#0044769F: 48:215215 48FEFFFF         vu 02 20  1 2226      
    mov rsi,[rbp-136] (sr)                ;#004476A6: 48:213265 78FFFFFF         uv 40 20  1 2227      
    mov rdx,690                           ;#004476AD: 48:307302 B2020000         vu 04 00  1 2227      
    call #00441675 (:%pSubse1)            ;#004476B4: 350 BC9FFFFF               v  00 00  1 2228      
    mov rdi,[rbp] (symtab)                ;#004476B9: 48:213175 00               uv 80 20  1 2229      
    mov r15,h4                            ;#004476BD: 49:277 0000000000000040    vu 8000 00  1 2229      
    cmp rdi,r15                           ;#004476C7: 4C:071377                  uv 00 8080  1 2230      
    jne #004476D8                         ;#004476CA: 165 0C                     v  00 00  1 2230      
    mov rsi,673                           ;#004476CC: 48:307306 A1020000         uv 40 00  1 2231      
    call #00442D75 (:%pUnassigned)        ;#004476D3: 350 9DB6FFFF               v  00 00  1 2231      
    lea rdx,[rbp-448] (symtab[736])       ;#004476D8: 48:215225 40FEFFFF         uv 04 20  1 2232      
    mov rcx,3                             ;#004476DF: 48:307301 03000000         vu 02 00  1 2232      
    push #00447707                        ;#004476E6: 150 07774400               uv 00 00  1 2233      
    push rdx                              ;#004476EB: 122                        vu 00 04  1 2233      
    push 2                                ;#004476EC: 152 02                     uv 00 00  1 2234      
    push 1                                ;#004476EE: 152 01                     vu 00 00  1 2234      
    push qword[rbp-440] (symtab[735])     ;#004476F0: 377265 48FEFFFF            np 00 20  2 2235      
    push 17                               ;#004476F6: 152 11                     uv 00 00  1 2237      
    mov rsi,rdi                           ;#004476F8: 48:211376                  vu 40 80  1 2237      
    mov rdx,673                           ;#004476FB: 48:307302 A1020000         uv 04 00  1 2238      
    jmp #00440F1F (:%pSubss)              ;#00447702: 351 1898FFFF               v  00 00  1 2238      
    mov rax,[rbp-448] (symtab[736])       ;#00447707: 48:213205 40FEFFFF         uv 01 20  1 2239      
    mov rcx,[rbp-152] (filename)          ;#0044770E: 48:213215 68FFFFFF         vu 02 20  1 2239      
    mov [rbp-448] (symtab[736]),rbx       ;#00447715: 48:211235 40FEFFFF         uv 00 28  1 2240      
    mov r15,h4                            ;#0044771C: 49:277 0000000000000040    vu 8000 00  1 2240      
    cmp rcx,r15                           ;#00447726: 4C:071371                  uv 00 8002  1 2241      
    mov [rbp-152] (filename),rax          ;#00447729: 48:211205 68FFFFFF         vu 00 21  1 2241      
    jle #00447741                         ;#00447730: 176 0F                     v  00 00  1 2242      
    sub qword[rbx+rcx*4-16],1             ;#00447732: 48:203154213 F0 01         u  00 0A  3 2243      
    jne #00447741                         ;#00447738: 165 07                     v  00 00  1 2245      
    mov edx,ecx                           ;#0044773A: 213321                     uv 04 02  1 2246      
    call #004422DA (:%pDealloc)           ;#0044773C: 350 99ABFFFF               v  00 00  1 2246      
    mov rsi,[rbp-152] (filename)          ;#00447741: 48:213265 68FFFFFF         uv 40 20  1 2247      
    mov r15,h4                            ;#00447748: 49:277 0000000000000040    vu 8000 00  1 2247      
    cmp rsi,r15                           ;#00447752: 4C:071376                  uv 00 8040  1 2248      
    jne #00447763                         ;#00447755: 165 0C                     v  00 00  1 2248      
    mov rsi,692                           ;#00447757: 48:307306 B4020000         uv 40 00  1 2249      
    call #00442D75 (:%pUnassigned)        ;#0044775E: 350 12B6FFFF               v  00 00  1 2249      
    lea rdx,[rbp-152] (filename)          ;#00447763: 48:215225 68FFFFFF         uv 04 20  1 2250      
    lea rdi,[rbp-152] (filename)          ;#0044776A: 48:215275 68FFFFFF         vu 80 20  1 2250      
    lea rcx,[rbp-40] (lineno)             ;#00447771: 48:215115 D8               uv 02 20  1 2251      
    xor rax,rax                           ;#00447775: 48:061300                  vu 01 01  1 2251      
    call #0043FC15 (:%opApnd)             ;#00447778: 350 9884FFFF               v  00 00  1 2252      
;  2729 --?filename
;  2730                 filename[1] = pathset[filename[1]]
    mov rdi,1                             ;#0044777D: 48:307307 01000000         uv 80 00  1 2253      
    lea rcx,[rbp-440] (symtab[735])       ;#00447784: 48:215215 48FEFFFF         vu 02 20  1 2253      
    mov rsi,[rbp-152] (filename)          ;#0044778B: 48:213265 68FFFFFF         uv 40 20  1 2254      
    mov rdx,692                           ;#00447792: 48:307302 B4020000         vu 04 00  1 2254      
    call #00441675 (:%pSubse1)            ;#00447799: 350 D79EFFFF               v  00 00  1 2255      
    mov rdi,[rbp-440] (symtab[735])       ;#0044779E: 48:213275 48FEFFFF         uv 80 20  1 2256      
    lea rcx,[rbp-528] (symtab[787])       ;#004477A5: 48:215215 F0FDFFFF         vu 02 20  1 2256      
    mov rsi,[rbp-160] (pathset)           ;#004477AC: 48:213265 60FFFFFF         uv 40 20  1 2257      
    mov rdx,693                           ;#004477B3: 48:307302 B5020000         vu 04 00  1 2257      
    call #00441675 (:%pSubse1)            ;#004477BA: 350 B69EFFFF               v  00 00  1 2258      
    mov rdi,qword[#00402030]              ;#004477BF: 48:213075 6AA8FBFF         uv 80 00  1 2259      
    mov rcx,[rbp-528] (symtab[787])       ;#004477C6: 48:213215 F0FDFFFF         vu 02 20  1 2259      
    mov rsi,[rbp-152] (filename)          ;#004477CD: 48:213265 68FFFFFF         uv 40 20  1 2260      
    lea rax,[rbp-152] (filename)          ;#004477D4: 48:215205 68FFFFFF         vu 01 20  1 2260      
    call #00440C54 (:%pRepe1)             ;#004477DB: 350 7494FFFF               v  00 00  1 2261      
;  2731 --?filename
;  2732                 put2(sprintf("%s%s:%d",filename))
    mov rcx,33                            ;#004477E0: 48:307301 21000000         uv 02 00  1 2262      
    mov rdx,89                            ;#004477E7: 48:307302 59000000         vu 04 00  1 2262      
    call #004428DB (:%opFrame) (sprintf)  ;#004477EE: 350 E8B0FFFF               v  00 00  1 2263      
    mov rax,qword[#00402D40]              ;#004477F3: 48:213005 46B5FBFF         uv 01 00  1 2264      
    mov [rbp] (format),rax                ;#004477FA: 48:211105 00               uv 00 21  1 2265 01   
    add qword[rbx+rax*4-16],1             ;#004477FE: 48:203104203 F0 01         u  00 09  3 2267    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00447804: 48:213175 28               vu 80 20  1 2269      
    mov rax,[rdi-152]                     ;#00447808: 48:213207 68FFFFFF         uv 01 80  1 2272    *80*
    xor rbx,rbx                           ;#0044780F: 48:061333                  vu 08 08  1 2272      
    mov r15,h4                            ;#00447812: 49:277 0000000000000040    uv 8000 00  1 2273      
    cmp rax,r15                           ;#0044781C: 4C:071370                  uv 00 8001  1 2274 8000   
    jl #0044782C                          ;#0044781F: 174 0B                     v  00 00  1 2274      
    add qword[rbx+rax*4-16],1             ;#00447821: 48:203104203 F0 01         u  00 09  3 2275      
    cmp eax,692                           ;#00447827: 075 B4020000               vu 00 01  1 2277      
    mov [rbp-8] (args),rax                ;#0044782C: 48:211105 F8               uv 00 21  1 2278      
    mov qword[retaddr],#0044783D          ;#00447830: 48:307105 20 3D784400      vu 00 20  1 2278      
    jmp #0044E450 (code:sprintf)          ;#00447838: 351 136C0000               v  00 00  1 2279      
    push rax                              ;#0044783D: 120                        uv 00 01  1 2280      
    mov rdi,[rbp-400] (symtab[725])       ;#0044783E: 48:213275 70FEFFFF         vu 80 20  1 2280      
    mov r15,h4                            ;#00447845: 49:277 0000000000000040    uv 8000 00  1 2281      
    cmp rdi,r15                           ;#0044784F: 4C:071377                  uv 00 8080  1 2282 8000   
    jle #00447864                         ;#00447852: 176 10                     v  00 00  1 2282      
    sub qword[rbx+rdi*4-16],1             ;#00447854: 48:203154273 F0 01         u  00 88  3 2283      
    jne #00447864                         ;#0044785A: 165 08                     v  00 00  1 2285      
    mov rdx,rdi                           ;#0044785C: 48:213327                  uv 04 80  1 2286      
    call #004422DA (:%pDealloc)           ;#0044785F: 350 76AAFFFF               v  00 00  1 2286      
    pop dword[rbp-400] (symtab[725])      ;#00447864: 217205 70FEFFFF            np 00 20  3 2287      
    mov rcx,3                             ;#0044786A: 48:307301 03000000         uv 02 00  1 2290      
    mov rdx,474                           ;#00447871: 48:307302 DA010000         vu 04 00  1 2290      
    call #004428DB (:%opFrame) (put2)     ;#00447878: 350 5EB0FFFF               v  00 00  1 2291      
    mov rdi,[rbp+40] (prevebp)            ;#0044787D: 48:213175 28               uv 80 20  1 2292      
    mov rax,[rdi-400]                     ;#00447881: 48:213207 70FEFFFF         uv 01 80  1 2295 80 *80*
    xor rbx,rbx                           ;#00447888: 48:061333                  vu 08 08  1 2295      
    mov r15,h4                            ;#0044788B: 49:277 0000000000000040    uv 8000 00  1 2296      
    cmp rax,r15                           ;#00447895: 4C:071370                  uv 00 8001  1 2297 8000   
    jl #004478A5                          ;#00447898: 174 0B                     v  00 00  1 2297      
    add qword[rbx+rax*4-16],1             ;#0044789A: 48:203104203 F0 01         u  00 09  3 2298      
    cmp eax,725                           ;#004478A0: 075 D5020000               vu 00 01  1 2300      
    mov [rbp] (emsg),rax                  ;#004478A5: 48:211105 00               uv 00 21  1 2301      
    mov qword[retaddr],#004478B6          ;#004478A9: 48:307105 20 B6784400      vu 00 20  1 2301      
    jmp #0044D150 (code:put2)             ;#004478B1: 351 9A580000               v  00 00  1 2302      
;  2733                 if sr[S_Name]=-1 then
    mov rdi,1                             ;#004478B6: 48:307307 01000000         uv 80 00  1 2303      
    lea rcx,[rbp-528] (symtab[787])       ;#004478BD: 48:215215 F0FDFFFF         vu 02 20  1 2303      
    mov rsi,[rbp-136] (sr)                ;#004478C4: 48:213265 78FFFFFF         uv 40 20  1 2304      
    mov rdx,690                           ;#004478CB: 48:307302 B2020000         vu 04 00  1 2304      
    call #00441675 (:%pSubse1)            ;#004478D2: 350 9E9DFFFF               v  00 00  1 2305      
    mov rcx,[rbp-528] (symtab[787])       ;#004478D7: 48:213215 F0FDFFFF         uv 02 20  1 2306      
    cmp rcx,-1                            ;#004478DE: 48:203371 FF               uv 00 02  1 2307 02   
    jne #0044791A                         ;#004478E2: 165 36                     v  00 00  1 2307      
;  2734 --              if sr[S_Name]=-1 or sr[S_NTyp]=S_Rsvd then
;  2735                     put2("\n")
    mov rcx,3                             ;#004478E4: 48:307301 03000000         uv 02 00  1 2308      
    mov rdx,474                           ;#004478EB: 48:307302 DA010000         vu 04 00  1 2308      
    call #004428DB (:%opFrame) (put2)     ;#004478F2: 350 E4AFFFFF               v  00 00  1 2309      
    mov rdi,qword[#00402600]              ;#004478F7: 48:213075 02ADFBFF         uv 80 00  1 2310      
    mov [rbp] (emsg),rdi                  ;#004478FE: 48:211175 00               uv 00 A0  1 2311 80   
    add qword[rbx+rdi*4-16],1             ;#00447902: 48:203104273 F0 01         u  00 88  3 2313    *80*
    mov qword[retaddr],#00447915          ;#00447908: 48:307105 20 15794400      vu 00 20  1 2315      
    jmp #0044D150 (code:put2)             ;#00447910: 351 3B580000               v  00 00  1 2316      
    jmp #00447AC1                         ;#00447915: 351 A7010000               v  00 00  1 2317      
;  2736                 else
;  2737                     put2(sprintf(" in %s %s()\n",{rtndescs[sr[S_NTyp]-S_Type+1],sr[S_Name]}))
    mov rdi,2                             ;#0044791A: 48:307307 02000000         uv 80 00  1 2318      
    lea rcx,[rbp-528] (symtab[787])       ;#00447921: 48:215215 F0FDFFFF         vu 02 20  1 2318      
    mov rsi,[rbp-136] (sr)                ;#00447928: 48:213265 78FFFFFF         uv 40 20  1 2319      
    mov rdx,690                           ;#0044792F: 48:307302 B2020000         vu 04 00  1 2319      
    call #00441675 (:%pSubse1)            ;#00447936: 350 3A9DFFFF               v  00 00  1 2320      
    lea rdi,[rbp-368] (symtab[719])       ;#0044793B: 48:215275 90FEFFFF         uv 80 20  1 2321      
    mov rcx,[rbp-528] (symtab[787])       ;#00447942: 48:213215 F0FDFFFF         vu 02 20  1 2321      
    mov rax,[#00402AA8] (S_Type)          ;#00447949: 48:213005 58B1FBFF         uv 01 00  1 2322      
    call #0043F4D8 (:%opSub)              ;#00447950: 350 837BFFFF               v  00 00  1 2322      
    lea rdi,[rbp-512] (symtab[782])       ;#00447955: 48:215275 00FEFFFF         uv 80 20  1 2323      
    mov rcx,[rbp-368] (symtab[719])       ;#0044795C: 48:213215 90FEFFFF         vu 02 20  1 2323      
    mov rax,qword[#00402030]              ;#00447963: 48:213005 C6A6FBFF         uv 01 00  1 2324      
    call #0043F4AF (:%opAdd)              ;#0044796A: 350 407BFFFF               v  00 00  1 2324      
    mov rdi,[rbp-512] (symtab[782])       ;#0044796F: 48:213275 00FEFFFF         uv 80 20  1 2325      
    lea rcx,[rbp-528] (symtab[787])       ;#00447976: 48:215215 F0FDFFFF         vu 02 20  1 2325      
    mov rsi,[#00402A40] (rtndescs)        ;#0044797D: 48:213065 BCB0FBFF         uv 40 00  1 2326      
    mov rdx,593                           ;#00447984: 48:307302 51020000         vu 04 00  1 2326      
    call #00441675 (:%pSubse1)            ;#0044798B: 350 E59CFFFF               v  00 00  1 2327      
    mov rdi,1                             ;#00447990: 48:307307 01000000         uv 80 00  1 2328      
    lea rcx,[rbp-440] (symtab[735])       ;#00447997: 48:215215 48FEFFFF         vu 02 20  1 2328      
    mov rsi,[rbp-136] (sr)                ;#0044799E: 48:213265 78FFFFFF         uv 40 20  1 2329      
    mov rdx,690                           ;#004479A5: 48:307302 B2020000         vu 04 00  1 2329      
    call #00441675 (:%pSubse1)            ;#004479AC: 350 C49CFFFF               v  00 00  1 2330      
    lea rax,[rbp-488] (symtab[767])       ;#004479B1: 48:215205 18FEFFFF         uv 01 20  1 2331      
    mov rdx,2                             ;#004479B8: 48:307302 02000000         vu 04 00  1 2331      
    push #004479EB                        ;#004479BF: 150 EB794400               uv 00 00  1 2332      
    push rax                              ;#004479C4: 120                        vu 00 01  1 2332      
    push qword[rbp-440] (symtab[735])     ;#004479C5: 377265 48FEFFFF            np 00 20  2 2333      
    mov [rbp-440] (symtab[735]),rbx       ;#004479CB: 48:211235 48FEFFFF         uv 00 28  1 2335      
    push qword[rbp-528] (symtab[787])     ;#004479D2: 377265 F0FDFFFF            np 00 20  2 2336      
    mov [rbp-528] (symtab[787]),rbx       ;#004479D8: 48:211235 F0FDFFFF         uv 00 28  1 2338      
    mov rdi,[rbp-488] (symtab[767])       ;#004479DF: 48:213275 18FEFFFF         vu 80 20  1 2338      
    jmp #004404BD (:%pMkSq)               ;#004479E6: 351 D28AFFFF               v  00 00  1 2339      
    mov rcx,33                            ;#004479EB: 48:307301 21000000         uv 02 00  1 2340      
    mov rdx,89                            ;#004479F2: 48:307302 59000000         vu 04 00  1 2340      
    call #004428DB (:%opFrame) (sprintf)  ;#004479F9: 350 DDAEFFFF               v  00 00  1 2341      
    mov rcx,qword[#00402D48]              ;#004479FE: 48:213015 43B3FBFF         uv 02 00  1 2342      
    mov [rbp] (format),rcx                ;#00447A05: 48:211115 00               uv 00 22  1 2343 02   
    add qword[rbx+rcx*4-16],1             ;#00447A09: 48:203104213 F0 01         u  00 0A  3 2345    *02*
    mov rdi,[rbp+40] (prevebp)            ;#00447A0F: 48:213175 28               vu 80 20  1 2347      
    mov rax,[rdi-488]                     ;#00447A13: 48:213207 18FEFFFF         uv 01 80  1 2350    *80*
    xor rbx,rbx                           ;#00447A1A: 48:061333                  vu 08 08  1 2350      
    mov r15,h4                            ;#00447A1D: 49:277 0000000000000040    uv 8000 00  1 2351      
    cmp rax,r15                           ;#00447A27: 4C:071370                  uv 00 8001  1 2352 8000   
    jl #00447A37                          ;#00447A2A: 174 0B                     v  00 00  1 2352      
    add qword[rbx+rax*4-16],1             ;#00447A2C: 48:203104203 F0 01         u  00 09  3 2353      
    cmp eax,767                           ;#00447A32: 075 FF020000               vu 00 01  1 2355      
    mov [rbp-8] (args),rax                ;#00447A37: 48:211105 F8               uv 00 21  1 2356      
    mov qword[retaddr],#00447A48          ;#00447A3B: 48:307105 20 487A4400      vu 00 20  1 2356      
    jmp #0044E450 (code:sprintf)          ;#00447A43: 351 086A0000               v  00 00  1 2357      
    push rax                              ;#00447A48: 120                        uv 00 01  1 2358      
    mov rsi,[rbp-400] (symtab[725])       ;#00447A49: 48:213265 70FEFFFF         vu 40 20  1 2358      
    mov r15,h4                            ;#00447A50: 49:277 0000000000000040    uv 8000 00  1 2359      
    cmp rsi,r15                           ;#00447A5A: 4C:071376                  uv 00 8040  1 2360 8000   
    jle #00447A6F                         ;#00447A5D: 176 10                     v  00 00  1 2360      
    sub qword[rbx+rsi*4-16],1             ;#00447A5F: 48:203154263 F0 01         u  00 48  3 2361      
    jne #00447A6F                         ;#00447A65: 165 08                     v  00 00  1 2363      
    mov rdx,rsi                           ;#00447A67: 48:213326                  uv 04 40  1 2364      
    call #004422DA (:%pDealloc)           ;#00447A6A: 350 6BA8FFFF               v  00 00  1 2364      
    pop dword[rbp-400] (symtab[725])      ;#00447A6F: 217205 70FEFFFF            np 00 20  3 2365      
    mov rcx,3                             ;#00447A75: 48:307301 03000000         uv 02 00  1 2368      
    mov rdx,474                           ;#00447A7C: 48:307302 DA010000         vu 04 00  1 2368      
    call #004428DB (:%opFrame) (put2)     ;#00447A83: 350 53AEFFFF               v  00 00  1 2369      
    mov rdi,[rbp+40] (prevebp)            ;#00447A88: 48:213175 28               uv 80 20  1 2370      
    mov rax,[rdi-400]                     ;#00447A8C: 48:213207 70FEFFFF         uv 01 80  1 2373 80 *80*
    xor rbx,rbx                           ;#00447A93: 48:061333                  vu 08 08  1 2373      
    mov r15,h4                            ;#00447A96: 49:277 0000000000000040    uv 8000 00  1 2374      
    cmp rax,r15                           ;#00447AA0: 4C:071370                  uv 00 8001  1 2375 8000   
    jl #00447AB0                          ;#00447AA3: 174 0B                     v  00 00  1 2375      
    add qword[rbx+rax*4-16],1             ;#00447AA5: 48:203104203 F0 01         u  00 09  3 2376      
    cmp eax,725                           ;#00447AAB: 075 D5020000               vu 00 01  1 2378      
    mov [rbp] (emsg),rax                  ;#00447AB0: 48:211105 00               uv 00 21  1 2379      
    mov qword[retaddr],#00447AC1          ;#00447AB4: 48:307105 20 C17A4400      vu 00 20  1 2379      
    jmp #0044D150 (code:put2)             ;#00447ABC: 351 8F560000               v  00 00  1 2380      
;  2738 --?3
;  2739                 end if
;  2740                 if length(msg) then     -- first time only
    lea rdi,[rbp-536] (symtab[790])       ;#00447AC1: 48:215275 E8FDFFFF         uv 80 20  1 2381      
    mov rsi,[rbp-120] (msg)               ;#00447AC8: 48:213165 88               vu 40 20  1 2381      
    mov rdx,688                           ;#00447ACC: 48:307302 B0020000         uv 04 00  1 2382      
    call #0043F28D (:%opLen)              ;#00447AD3: 350 B577FFFF               v  00 00  1 2382      
    test rcx,ecx                          ;#00447AD8: 205311                     uv 00 02  1 2383      
    je #00447BCE                          ;#00447ADA: 017204 EE000000            v  00 00  1 2383      
;  2741                     if length(msg2) then
    mov rdi,[rbp-328] (msg2)              ;#00447AE0: 48:213275 B8FEFFFF         uv 80 20  1 2384      
    mov rcx,[rbx+rdi*4-24]                ;#00447AE7: 48:213114273 E8            uv 02 88  1 2387 80 *80*
    test rcx,ecx                          ;#00447AEC: 205311                     uv 00 02  1 2388 02   
    je #00447B45                          ;#00447AEE: 164 55                     v  00 00  1 2388      
;  2742 --                      put2(msg2)
;  2743                         puts(1,msg2)
    mov rax,1                             ;#00447AF0: 48:307300 01000000         uv 01 00  1 2389      
    mov rdx,rdi                           ;#00447AF7: 48:211372                  vu 04 80  1 2389      
    call #0043E218 (:%opPuts)             ;#00447AFA: 350 1967FFFF               v  00 00  1 2390      
;  2744                         msg2 = ""
    mov rax,qword[#00402240]              ;#00447AFF: 48:213005 3AA7FBFF         uv 01 00  1 2391      
    mov rdx,[rbp-328] (msg2)              ;#00447B06: 48:213225 B8FEFFFF         vu 04 20  1 2391      
    mov r15,h4                            ;#00447B0D: 49:277 0000000000000040    uv 8000 00  1 2392      
    cmp rax,r15                           ;#00447B17: 4C:071370                  uv 00 8001  1 2393 8000   
    jl #00447B22                          ;#00447B1A: 174 06                     v  00 00  1 2393      
    add qword[rbx+rax*4-16],1             ;#00447B1C: 48:203104203 F0 01         u  00 09  3 2394      
    mov [rbp-328] (msg2),rax              ;#00447B22: 48:211205 B8FEFFFF         vu 00 21  1 2396      
    mov r15,h4                            ;#00447B29: 49:277 0000000000000040    uv 8000 00  1 2397      
    cmp rdx,r15                           ;#00447B33: 4C:071372                  uv 00 8004  1 2398 8000   
    jle #00447B45                         ;#00447B36: 176 0D                     v  00 00  1 2398      
    sub qword[rbx+rdx*4-16],1             ;#00447B38: 48:203154223 F0 01         u  00 0C  3 2399      
    jne #00447B45                         ;#00447B3E: 165 05                     v  00 00  1 2401      
    call #004422DA (:%pDealloc)           ;#00447B40: 350 95A7FFFF               v  00 00  1 2402      
;  2745                     end if
;  2746                     put2(msg)
    mov rcx,3                             ;#00447B45: 48:307301 03000000         uv 02 00  1 2403      
    mov rdx,474                           ;#00447B4C: 48:307302 DA010000         vu 04 00  1 2403      
    call #004428DB (:%opFrame) (put2)     ;#00447B53: 350 83ADFFFF               v  00 00  1 2404      
    mov rdi,[rbp+40] (prevebp)            ;#00447B58: 48:213175 28               uv 80 20  1 2405      
    mov rax,[rdi-120]                     ;#00447B5C: 48:213107 88               uv 01 80  1 2408 80 *80*
    xor rbx,rbx                           ;#00447B60: 48:061333                  vu 08 08  1 2408      
    mov r15,h4                            ;#00447B63: 49:277 0000000000000040    uv 8000 00  1 2409      
    cmp rax,r15                           ;#00447B6D: 4C:071370                  uv 00 8001  1 2410 8000   
    jl #00447B7D                          ;#00447B70: 174 0B                     v  00 00  1 2410      
    add qword[rbx+rax*4-16],1             ;#00447B72: 48:203104203 F0 01         u  00 09  3 2411      
    cmp eax,688                           ;#00447B78: 075 B0020000               vu 00 01  1 2413      
    mov [rbp] (emsg),rax                  ;#00447B7D: 48:211105 00               uv 00 21  1 2414      
    mov qword[retaddr],#00447B8E          ;#00447B81: 48:307105 20 8E7B4400      vu 00 20  1 2414      
    jmp #0044D150 (code:put2)             ;#00447B89: 351 C2550000               v  00 00  1 2415      
;  2747                     msg = ""
    mov rsi,qword[#00402240]              ;#00447B8E: 48:213065 ABA6FBFF         uv 40 00  1 2416      
    mov rdx,[rbp-120] (msg)               ;#00447B95: 48:213125 88               vu 04 20  1 2416      
    mov r15,h4                            ;#00447B99: 49:277 0000000000000040    uv 8000 00  1 2417      
    cmp rsi,r15                           ;#00447BA3: 4C:071376                  uv 00 8040  1 2418 8000   
    jl #00447BAE                          ;#00447BA6: 174 06                     v  00 00  1 2418      
    add qword[rbx+rsi*4-16],1             ;#00447BA8: 48:203104263 F0 01         u  00 48  3 2419      
    mov [rbp-120] (msg),rsi               ;#00447BAE: 48:211165 88               vu 00 60  1 2421      
    mov r15,h4                            ;#00447BB2: 49:277 0000000000000040    uv 8000 00  1 2422      
    cmp rdx,r15                           ;#00447BBC: 4C:071372                  uv 00 8004  1 2423 8000   
    jle #00447BCE                         ;#00447BBF: 176 0D                     v  00 00  1 2423      
    sub qword[rbx+rdx*4-16],1             ;#00447BC1: 48:203154223 F0 01         u  00 0C  3 2424      
    jne #00447BCE                         ;#00447BC7: 165 05                     v  00 00  1 2426      
    call #004422DA (:%pDealloc)           ;#00447BC9: 350 0CA7FFFF               v  00 00  1 2427      
;  2748                 end if
;  2749 --?sr
;  2750                 p = sr[S_Parm1]         -- (0 for all top-level subs)
    mov rdi,8                             ;#00447BCE: 48:307307 08000000         uv 80 00  1 2428      
    lea rcx,[rbp-200] (p)                 ;#00447BD5: 48:215215 38FFFFFF         vu 02 20  1 2428      
    mov rsi,[rbp-136] (sr)                ;#00447BDC: 48:213265 78FFFFFF         uv 40 20  1 2429      
    mov rdx,690                           ;#00447BE3: 48:307302 B2020000         vu 04 00  1 2429      
    call #004416F2 (:%pSubse1i)           ;#00447BEA: 350 039BFFFF               v  00 00  1 2430      
;  2751 --?sr
;  2752                 tidx = 0    --DEV can we not use [S_Tidx]??
    mov [rbp-304] (tidx),rbx              ;#00447BEF: 48:211235 D0FEFFFF         uv 00 28  1 2431      
;  2753                 while p do
    mov rcx,[rbp-200] (p)                 ;#00447BF6: 48:213215 38FFFFFF         vu 02 20  1 2431      
    test rcx,rcx                          ;#00447BFD: 48:205311                  uv 00 02  1 2432      
    je #004480A2                          ;#00447C00: 017204 9C040000            v  00 00  1 2432      
;  2754                     if p<1 or p>length(symtab) then
    cmp rcx,1                             ;#00447C06: 48:203371 01               uv 00 02  1 2433      
    jl #00447C33                          ;#00447C0A: 174 27                     v  00 00  1 2433      
    lea rdi,[rbp-544] (symtab[791])       ;#00447C0C: 48:215275 E0FDFFFF         uv 80 20  1 2434      
    mov rsi,[rbp] (symtab)                ;#00447C13: 48:213165 00               vu 40 20  1 2434      
    mov rdx,673                           ;#00447C17: 48:307302 A1020000         uv 04 00  1 2435      
    call #0043F28D (:%opLen)              ;#00447C1E: 350 6A76FFFF               v  00 00  1 2435      
    mov rdi,[rbp-200] (p)                 ;#00447C23: 48:213275 38FFFFFF         uv 80 20  1 2436      
    cmp rdi,rcx                           ;#00447C2A: 48:071317                  uv 00 82  1 2437 80   
    jle #00447CDB                         ;#00447C2D: 017216 A8000000            v  00 00  1 2437      
;  2755                         printf(1,"oops, p(%d) out of bounds(1..%d), pdiagN.e line 2049\n",{p,length(symtab)})
    lea rdi,[rbp-544] (symtab[791])       ;#00447C33: 48:215275 E0FDFFFF         uv 80 20  1 2438      
    mov rsi,[rbp] (symtab)                ;#00447C3A: 48:213165 00               vu 40 20  1 2438      
    mov rdx,673                           ;#00447C3E: 48:307302 A1020000         uv 04 00  1 2439      
    call #0043F28D (:%opLen)              ;#00447C45: 350 4376FFFF               v  00 00  1 2439      
    lea rax,[rbp-488] (symtab[767])       ;#00447C4A: 48:215205 18FEFFFF         uv 01 20  1 2440      
    mov rdx,2                             ;#00447C51: 48:307302 02000000         vu 04 00  1 2440      
    push #00447C71                        ;#00447C58: 150 717C4400               uv 00 00  1 2441      
    push rax                              ;#00447C5D: 120                        vu 00 01  1 2441      
    push rcx                              ;#00447C5E: 121                        uv 00 02  1 2442      
    push qword[rbp-200] (p)               ;#00447C5F: 377265 38FFFFFF            np 00 20  2 2443      
    mov rdi,[rbp-488] (symtab[767])       ;#00447C65: 48:213275 18FEFFFF         uv 80 20  1 2445      
    jmp #004404BD (:%pMkSq)               ;#00447C6C: 351 4C88FFFF               v  00 00  1 2445      
    mov rcx,4                             ;#00447C71: 48:307301 04000000         uv 02 00  1 2446      
    mov rdx,94                            ;#00447C78: 48:307302 5E000000         vu 04 00  1 2446      
    call #004428DB (:%opFrame) (printf)   ;#00447C7F: 350 57ACFFFF               v  00 00  1 2447      
    mov qword[rbp] (fn),1                 ;#00447C84: 48:307105 00 01000000      uv 00 20  1 2448      
    mov rax,qword[#00402D50]              ;#00447C8C: 48:213005 BDB0FBFF         vu 01 00  1 2448      
    mov [rbp-8] (format),rax              ;#00447C93: 48:211105 F8               uv 00 21  1 2449      
    add qword[rbx+rax*4-16],1             ;#00447C97: 48:203104203 F0 01         u  00 09  3 2451    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00447C9D: 48:213175 28               vu 80 20  1 2453      
    mov rax,[rdi-488]                     ;#00447CA1: 48:213207 18FEFFFF         uv 01 80  1 2456    *80*
    xor rbx,rbx                           ;#00447CA8: 48:061333                  vu 08 08  1 2456      
    mov r15,h4                            ;#00447CAB: 49:277 0000000000000040    uv 8000 00  1 2457      
    cmp rax,r15                           ;#00447CB5: 4C:071370                  uv 00 8001  1 2458 8000   
    jl #00447CC5                          ;#00447CB8: 174 0B                     v  00 00  1 2458      
    add qword[rbx+rax*4-16],1             ;#00447CBA: 48:203104203 F0 01         u  00 09  3 2459      
    cmp eax,767                           ;#00447CC0: 075 FF020000               vu 00 01  1 2461      
    mov [rbp-16] (args),rax               ;#00447CC5: 48:211105 F0               uv 00 21  1 2462      
    mov qword[retaddr],#00447CD6          ;#00447CC9: 48:307105 20 D67C4400      vu 00 20  1 2462      
    jmp #00451A31 (code:printf)           ;#00447CD1: 351 5B9D0000               v  00 00  1 2463      
;  2756                         exit
    jmp #004480A2                         ;#00447CD6: 351 C7030000               v  00 00  1 2464      
;  2757                     end if
;  2758                     sp = symtab[p]
    mov r15,h4                            ;#00447CDB: 49:277 0000000000000040    uv 8000 00  1 2465      
    cmp rsi,r15                           ;#00447CE5: 4C:071376                  uv 00 8040  1 2466 8000   
    jne #00447CF6                         ;#00447CE8: 165 0C                     v  00 00  1 2466      
    mov rsi,673                           ;#00447CEA: 48:307306 A1020000         uv 40 00  1 2467      
    call #00442D75 (:%pUnassigned)        ;#00447CF1: 350 7FB0FFFF               v  00 00  1 2467      
    lea rcx,[rbp-16] (sp)                 ;#00447CF6: 48:215115 F0               uv 02 20  1 2468      
    mov rdx,673                           ;#00447CFA: 48:307302 A1020000         vu 04 00  1 2468      
    call #00441675 (:%pSubse1)            ;#00447D01: 350 6F99FFFF               v  00 00  1 2469      
;  2759 --?{sp}
;  2760 --SUG: or si[S_NTyp]!=S_TVar3
;  2761                     if atom(sp) then
    mov rcx,[rbp-16] (sp)                 ;#00447D06: 48:213115 F0               uv 02 20  1 2470      
    mov r15,h4                            ;#00447D0A: 49:277 0000000000000040    vu 8000 00  1 2470      
    cmp rcx,r15                           ;#00447D14: 4C:071371                  uv 00 8002  1 2471      
    jl #00447D20                          ;#00447D17: 174 07                     v  00 00  1 2471      
    cmp byte[rbx+rcx*4-1],#12             ;#00447D19: 200174213 FF 12            u  00 0A  2 2472      
    jne #00447D6D                         ;#00447D1E: 165 4D                     v  00 00  1 2473      
;  2762                         printf(1,"oops, atom(symtab[%d]), pdiagN.e line 2056\n",p)
    mov rcx,4                             ;#00447D20: 48:307301 04000000         uv 02 00  1 2474      
    mov rdx,94                            ;#00447D27: 48:307302 5E000000         vu 04 00  1 2474      
    call #004428DB (:%opFrame) (printf)   ;#00447D2E: 350 A8ABFFFF               v  00 00  1 2475      
    mov qword[rbp] (fn),1                 ;#00447D33: 48:307105 00 01000000      uv 00 20  1 2476      
    mov rax,qword[#00402D58]              ;#00447D3B: 48:213005 16B0FBFF         vu 01 00  1 2476      
    mov [rbp-8] (format),rax              ;#00447D42: 48:211105 F8               uv 00 21  1 2477      
    add qword[rbx+rax*4-16],1             ;#00447D46: 48:203104203 F0 01         u  00 09  3 2479    *01*
    mov rdi,[rbp+40] (prevebp)            ;#00447D4C: 48:213175 28               vu 80 20  1 2481      
    mov rax,[rdi-200]                     ;#00447D50: 48:213207 38FFFFFF         uv 01 80  1 2484    *80*
    mov [rbp-16] (args),rax               ;#00447D57: 48:211105 F0               uv 00 21  1 2485 01   
    mov qword[retaddr],#00447D68          ;#00447D5B: 48:307105 20 687D4400      vu 00 20  1 2485      
    jmp #00451A31 (code:printf)           ;#00447D63: 351 C99C0000               v  00 00  1 2486      
;  2763                         exit
    jmp #004480A2                         ;#00447D68: 351 35030000               v  00 00  1 2487      
;  2764                     end if
;  2765                     name = sp[S_Name]
    mov rdi,1                             ;#00447D6D: 48:307307 01000000         uv 80 00  1 2488      
    lea rcx,[rbp-24] (name)               ;#00447D74: 48:215115 E8               vu 02 20  1 2488      
    mov rsi,[rbp-16] (sp)                 ;#00447D78: 48:213165 F0               uv 40 20  1 2489      
    mov rdx,675                           ;#00447D7C: 48:307302 A3020000         vu 04 00  1 2489      
    call #00441675 (:%pSubse1)            ;#00447D83: 350 ED98FFFF               v  00 00  1 2490      
;  2766                     if sequence(name) then
    mov rdi,[rbp-24] (name)               ;#00447D88: 48:213175 E8               uv 80 20  1 2491      
    mov r15,h4                            ;#00447D8C: 49:277 0000000000000040    vu 8000 00  1 2491      
    cmp rdi,r15                           ;#00447D96: 4C:071377                  uv 00 8080  1 2492      
    jl #00447ECB                          ;#00447D99: 017214 2C010000            v  00 00  1 2492      
    test byte[rbx+rdi*4-1],#80            ;#00447D9F: 366104273 FF 80            u  00 88  2 2493      
    je #00447ECB                          ;#00447DA4: 017204 21010000            v  00 00  1 2494      
;  2767 --                      o = "??"--getValue(p, maxlen, length(name), 0)
;  2768                         {novalue,o} = getTvarValue(tidx)
    mov rcx,4                             ;#00447DAA: 48:307301 04000000         uv 02 00  1 2495      
    mov rdx,631                           ;#00447DB1: 48:307302 77020000         vu 04 00  1 2495      
    call :%opFrame (getTvarValue)         ;#00447DB8: 350 1EABFFFF               v  00 00  1 2496      
    mov rdi,[rbp+40] (prevebp)            ;#00447DBD: 48:213175 28               uv 80 20  1 2497      
    mov rax,[rdi-304]                     ;#00447DC1: 48:213207 D0FEFFFF         uv 01 80  1 2500 80 *80*
    mov [rbp] (tidx),rax                  ;#00447DC8: 48:211105 00               uv 00 21  1 2501 01   
    mov qword[retaddr],#00447DD9          ;#00447DCC: 48:307105 20 D97D4400      vu 00 20  1 2501      
    jmp #0044DC08 (code:getTvarValue)     ;#00447DD4: 351 2F5E0000               v  00 00  1 2502      
    push rax                              ;#00447DD9: 120                        uv 00 01  1 2503      
    mov rcx,[rbp-488] (symtab[767])       ;#00447DDA: 48:213215 18FEFFFF         vu 02 20  1 2503      
    mov r15,h4                            ;#00447DE1: 49:277 0000000000000040    uv 8000 00  1 2504      
    cmp rcx,r15                           ;#00447DEB: 4C:071371                  uv 00 8002  1 2505 8000   
    jle #00447E00                         ;#00447DEE: 176 10                     v  00 00  1 2505      
    sub qword[rbx+rcx*4-16],1             ;#00447DF0: 48:203154213 F0 01         u  00 0A  3 2506      
    jne #00447E00                         ;#00447DF6: 165 08                     v  00 00  1 2508      
    mov rdx,rcx                           ;#00447DF8: 48:213321                  uv 04 02  1 2509      
    call #004422DA (:%pDealloc)           ;#00447DFB: 350 DAA4FFFF               v  00 00  1 2509      
    pop dword[rbp-488] (symtab[767])      ;#00447E00: 217205 18FEFFFF            np 00 20  3 2510      
    mov rdi,2                             ;#00447E06: 48:307307 02000000         uv 80 00  1 2513      
    lea rcx,[rbp-32] (o)                  ;#00447E0D: 48:215115 E0               vu 02 20  1 2513      
    mov rsi,[rbp-488] (symtab[767])       ;#00447E11: 48:213265 18FEFFFF         uv 40 20  1 2514      
    mov rdx,767                           ;#00447E18: 48:307302 FF020000         vu 04 00  1 2514      
    call #00441675 (:%pSubse1)            ;#00447E1F: 350 5198FFFF               v  00 00  1 2515      
    mov rdi,1                             ;#00447E24: 48:307307 01000000         uv 80 00  1 2516      
    lea rcx,[rbp-320] (novalue)           ;#00447E2B: 48:215215 C0FEFFFF         vu 02 20  1 2516      
    mov rsi,[rbp-488] (symtab[767])       ;#00447E32: 48:213265 18FEFFFF         uv 40 20  1 2517      
    mov rdx,767                           ;#00447E39: 48:307302 FF020000         vu 04 00  1 2517      
    call #004416F2 (:%pSubse1i)           ;#00447E40: 350 AD98FFFF               v  00 00  1 2518      
;  2769 --                      if showellipse or lc<maxlen-50 then
;  2770 --                          -- we need a (much) shorter version for on-screen display:
;  2771 --                          o2 = getValue(p,50,length(name), 1)
;  2772 --                          o = sprintf("    %s = %s\n",{name,o})
;  2773 --                          o2 = sprintf("    %s = %s\n",{name,o2})
;  2774 --                          put2x(o2,o)
;  2775 --                      else
;  2776 --                          put2(sprintf("    %s = %s\n",{name,o}))
;  2777 --                      end if
;  2778                         putz(name,o,novalue)
    mov rcx,7                             ;#00447E45: 48:307301 07000000         uv 02 00  1 2519      
    mov rdx,461                           ;#00447E4C: 48:307302 CD010000         vu 04 00  1 2519      
    call #004428DB (:%opFrame) (putz)     ;#00447E53: 350 83AAFFFF               v  00 00  1 2520      
    mov rdi,[rbp+40] (prevebp)            ;#00447E58: 48:213175 28               uv 80 20  1 2521      
    mov rax,[rdi-24]                      ;#00447E5C: 48:213107 E8               uv 01 80  1 2524 80 *80*
    xor rbx,rbx                           ;#00447E60: 48:061333                  vu 08 08  1 2524      
    mov r15,h4                            ;#00447E63: 49:277 0000000000000040    uv 8000 00  1 2525      
    cmp rax,r15                           ;#00447E6D: 4C:071370                  uv 00 8001  1 2526 8000   
    jl #00447E7D                          ;#00447E70: 174 0B                     v  00 00  1 2526      
    add qword[rbx+rax*4-16],1             ;#00447E72: 48:203104203 F0 01         u  00 09  3 2527      
    cmp eax,676                           ;#00447E78: 075 A4020000               vu 00 01  1 2529      
    mov [rbp] (name),rax                  ;#00447E7D: 48:211105 00               uv 00 21  1 2530      
    mov rdi,[rbp+40] (prevebp)            ;#00447E81: 48:213175 28               vu 80 20  1 2530      
    mov rax,[rdi-32]                      ;#00447E85: 48:213107 E0               uv 01 80  1 2533    *80*
    xor rbx,rbx                           ;#00447E89: 48:061333                  vu 08 08  1 2533      
    mov r15,h4                            ;#00447E8C: 49:277 0000000000000040    uv 8000 00  1 2534      
    cmp rax,r15                           ;#00447E96: 4C:071370                  uv 00 8001  1 2535 8000   
    jl #00447EA6                          ;#00447E99: 174 0B                     v  00 00  1 2535      
    add qword[rbx+rax*4-16],1             ;#00447E9B: 48:203104203 F0 01         u  00 09  3 2536      
    cmp eax,677                           ;#00447EA1: 075 A5020000               vu 00 01  1 2538      
    mov [rbp-8] (o),rax                   ;#00447EA6: 48:211105 F8               uv 00 21  1 2539      
    mov rdi,[rbp+40] (prevebp)            ;#00447EAA: 48:213175 28               vu 80 20  1 2539      
    mov rax,[rdi-320]                     ;#00447EAE: 48:213207 C0FEFFFF         uv 01 80  1 2542    *80*
    mov [rbp-16] (novalue),rax            ;#00447EB5: 48:211105 F0               uv 00 21  1 2543 01   
    mov qword[retaddr],#00447EC6          ;#00447EB9: 48:307105 20 C67E4400      vu 00 20  1 2543      
    jmp #0044CCDB (code:putz)             ;#00447EC1: 351 154E0000               v  00 00  1 2544      
    jmp #00448059                         ;#00447EC6: 351 8E010000               v  00 00  1 2545      
;  2779                     elsif name!=-1 then -- should not happen!
    cmp rdi,-1                            ;#00447ECB: 48:203377 FF               uv 00 80  1 2546      
    je #00448059                          ;#00447ECF: 017204 84010000            v  00 00  1 2546      
;  2780 --                      put2(sprintf("    %d[!!] = ???\n",name))
;  2781                         name = sprintf("%d[!!]",name)
    mov rcx,33                            ;#00447ED5: 48:307301 21000000         uv 02 00  1 2547      
    mov rdx,89                            ;#00447EDC: 48:307302 59000000         vu 04 00  1 2547      
    call #004428DB (:%opFrame) (sprintf)  ;#00447EE3: 350 F3A9FFFF               v  00 00  1 2548      
    mov rcx,qword[#00402D60]              ;#00447EE8: 48:213015 71AEFBFF         uv 02 00  1 2549      
    mov [rbp] (format),rcx                ;#00447EEF: 48:211115 00               uv 00 22  1 2550 02   
    add qword[rbx+rcx*4-16],1             ;#00447EF3: 48:203104213 F0 01         u  00 0A  3 2552    *02*
    mov rdi,[rbp+40] (prevebp)            ;#00447EF9: 48:213175 28               vu 80 20  1 2554      
    mov rax,[rdi-24]                      ;#00447EFD: 48:213107 E8               uv 01 80  1 2557    *80*
    mov [rdi-24],r15                      ;#00447F01: 4C:211177 E8               vu 00 8080  1 2557      
    mov [rbp-8] (args),rax                ;#00447F05: 48:211105 F8               uv 00 21  1 2558      
    mov qword[retaddr],#00447F16          ;#00447F09: 48:307105 20 167F4400      vu 00 20  1 2558      
    jmp #0044E450 (code:sprintf)          ;#00447F11: 351 3A650000               v  00 00  1 2559      
    push rax                              ;#00447F16: 120                        uv 00 01  1 2560      
    mov rsi,[rbp-24] (name)               ;#00447F17: 48:213165 E8               vu 40 20  1 2560      
    mov r15,h4                            ;#00447F1B: 49:277 0000000000000040    uv 8000 00  1 2561      
    cmp rsi,r15                           ;#00447F25: 4C:071376                  uv 00 8040  1 2562 8000   
    jle #00447F3A                         ;#00447F28: 176 10                     v  00 00  1 2562      
    sub qword[rbx+rsi*4-16],1             ;#00447F2A: 48:203154263 F0 01         u  00 48  3 2563      
    jne #00447F3A                         ;#00447F30: 165 08                     v  00 00  1 2565      
    mov rdx,rsi                           ;#00447F32: 48:213326                  uv 04 40  1 2566      
    call #004422DA (:%pDealloc)           ;#00447F35: 350 A0A3FFFF               v  00 00  1 2566      
    pop dword[rbp-24] (name)              ;#00447F3A: 217105 E8                  np 00 20  3 2567      
;  2782 --                      o = "??"--getValue(p, maxlen, length(name), 0)
;  2783                         {novalue,o} = getTvarValue(tidx)
    mov rcx,4                             ;#00447F3D: 48:307301 04000000         uv 02 00  1 2570      
    mov rdx,631                           ;#00447F44: 48:307302 77020000         vu 04 00  1 2570      
    call :%opFrame (getTvarValue)         ;#00447F4B: 350 8BA9FFFF               v  00 00  1 2571      
    mov rdi,[rbp+40] (prevebp)            ;#00447F50: 48:213175 28               uv 80 20  1 2572      
    mov rax,[rdi-304]                     ;#00447F54: 48:213207 D0FEFFFF         uv 01 80  1 2575 80 *80*
    mov [rbp] (tidx),rax                  ;#00447F5B: 48:211105 00               uv 00 21  1 2576 01   
    mov qword[retaddr],#00447F6C          ;#00447F5F: 48:307105 20 6C7F4400      vu 00 20  1 2576      
    jmp #0044DC08 (code:getTvarValue)     ;#00447F67: 351 9C5C0000               v  00 00  1 2577      
    push rax                              ;#00447F6C: 120                        uv 00 01  1 2578      
    mov rdi,[rbp-552] (symtab[795])       ;#00447F6D: 48:213275 D8FDFFFF         vu 80 20  1 2578      
    mov r15,h4                            ;#00447F74: 49:277 0000000000000040    uv 8000 00  1 2579      
    cmp rdi,r15                           ;#00447F7E: 4C:071377                  uv 00 8080  1 2580 8000   
    jle #00447F93                         ;#00447F81: 176 10                     v  00 00  1 2580      
    sub qword[rbx+rdi*4-16],1             ;#00447F83: 48:203154273 F0 01         u  00 88  3 2581      
    jne #00447F93                         ;#00447F89: 165 08                     v  00 00  1 2583      
    mov rdx,rdi                           ;#00447F8B: 48:213327                  uv 04 80  1 2584      
    call #004422DA (:%pDealloc)           ;#00447F8E: 350 47A3FFFF               v  00 00  1 2584      
    pop dword[rbp-552] (symtab[795])      ;#00447F93: 217205 D8FDFFFF            np 00 20  3 2585      
    mov rdi,2                             ;#00447F99: 48:307307 02000000         uv 80 00  1 2588      
    lea rcx,[rbp-32] (o)                  ;#00447FA0: 48:215115 E0               vu 02 20  1 2588      
    mov rsi,[rbp-552] (symtab[795])       ;#00447FA4: 48:213265 D8FDFFFF         uv 40 20  1 2589      
    mov rdx,795                           ;#00447FAB: 48:307302 1B030000         vu 04 00  1 2589      
    call #00441675 (:%pSubse1)            ;#00447FB2: 350 BE96FFFF               v  00 00  1 2590      
    mov rdi,1                             ;#00447FB7: 48:307307 01000000         uv 80 00  1 2591      
    lea rcx,[rbp-320] (novalue)           ;#00447FBE: 48:215215 C0FEFFFF         vu 02 20  1 2591      
    mov rsi,[rbp-552] (symtab[795])       ;#00447FC5: 48:213265 D8FDFFFF         uv 40 20  1 2592      
    mov rdx,795                           ;#00447FCC: 48:307302 1B030000         vu 04 00  1 2592      
    call #004416F2 (:%pSubse1i)           ;#00447FD3: 350 1A97FFFF               v  00 00  1 2593      
;  2784 --                      put2(sprintf("    %s = %s\n",{name,o}))
;  2785                         putz(name,o,novalue)
    mov rcx,7                             ;#00447FD8: 48:307301 07000000         uv 02 00  1 2594      
    mov rdx,461                           ;#00447FDF: 48:307302 CD010000         vu 04 00  1 2594      
    call #004428DB (:%opFrame) (putz)     ;#00447FE6: 350 F0A8FFFF               v  00 00  1 2595      
    mov rdi,[rbp+40] (prevebp)            ;#00447FEB: 48:213175 28               uv 80 20  1 2596      
    mov rax,[rdi-24]                      ;#00447FEF: 48:213107 E8               uv 01 80  1 2599 80 *80*
    xor rbx,rbx                           ;#00447FF3: 48:061333                  vu 08 08  1 2599      
    mov r15,h4                            ;#00447FF6: 49:277 0000000000000040    uv 8000 00  1 2600      
    cmp rax,r15                           ;#00448000: 4C:071370                  uv 00 8001  1 2601 8000   
    jl #00448010                          ;#00448003: 174 0B                     v  00 00  1 2601      
    add qword[rbx+rax*4-16],1             ;#00448005: 48:203104203 F0 01         u  00 09  3 2602      
    cmp eax,676                           ;#0044800B: 075 A4020000               vu 00 01  1 2604      
    mov [rbp] (name),rax                  ;#00448010: 48:211105 00               uv 00 21  1 2605      
    mov rdi,[rbp+40] (prevebp)            ;#00448014: 48:213175 28               vu 80 20  1 2605      
    mov rax,[rdi-32]                      ;#00448018: 48:213107 E0               uv 01 80  1 2608    *80*
    xor rbx,rbx                           ;#0044801C: 48:061333                  vu 08 08  1 2608      
    mov r15,h4                            ;#0044801F: 49:277 0000000000000040    uv 8000 00  1 2609      
    cmp rax,r15                           ;#00448029: 4C:071370                  uv 00 8001  1 2610 8000   
    jl #00448039                          ;#0044802C: 174 0B                     v  00 00  1 2610      
    add qword[rbx+rax*4-16],1             ;#0044802E: 48:203104203 F0 01         u  00 09  3 2611      
    cmp eax,677                           ;#00448034: 075 A5020000               vu 00 01  1 2613      
    mov [rbp-8] (o),rax                   ;#00448039: 48:211105 F8               uv 00 21  1 2614      
    mov rdi,[rbp+40] (prevebp)            ;#0044803D: 48:213175 28               vu 80 20  1 2614      
    mov rax,[rdi-320]                     ;#00448041: 48:213207 C0FEFFFF         uv 01 80  1 2617    *80*
    mov [rbp-16] (novalue),rax            ;#00448048: 48:211105 F0               uv 00 21  1 2618 01   
    mov qword[retaddr],#00448059          ;#0044804C: 48:307105 20 59804400      vu 00 20  1 2618      
    jmp #0044CCDB (code:putz)             ;#00448054: 351 824C0000               v  00 00  1 2619      
;  2786                     end if
;  2787                     tidx -= 1
    mov rcx,[rbp-304] (tidx)              ;#00448059: 48:213215 D0FEFFFF         uv 02 20  1 2620      
    sub rcx,1                             ;#00448060: 48:203351 01               uv 02 02  1 2621 02   
    mov rdx,rcx                           ;#00448064: 48:213321                  uv 04 02  1 2622 02   
    mov [rbp-304] (tidx),rcx              ;#00448067: 48:211215 D0FEFFFF         vu 00 22  1 2622      
    shl rdx,1                             ;#0044806E: 48:321342                  u  04 04  1 2623      
    jno #0044807F                         ;#00448071: 161 0C                     v  00 00  1 2623      
    lea rdi,[rbp-304] (tidx)              ;#00448073: 48:215275 D0FEFFFF         uv 80 20  1 2624      
    call #00442DA9 (:%pAddiii)            ;#0044807A: 350 2AADFFFF               v  00 00  1 2624      
;  2788                     p = sp[S_Slink]
    mov rdi,6                             ;#0044807F: 48:307307 06000000         uv 80 00  1 2625      
    lea rcx,[rbp-200] (p)                 ;#00448086: 48:215215 38FFFFFF         vu 02 20  1 2625      
    mov rsi,[rbp-16] (sp)                 ;#0044808D: 48:213165 F0               uv 40 20  1 2626      
    mov rdx,675                           ;#00448091: 48:307302 A3020000         vu 04 00  1 2626      
    call #00441675 (:%pSubse1)            ;#00448098: 350 D895FFFF               v  00 00  1 2627      
;  2789                 end while
    jmp #00447BF6                         ;#0044809D: 351 54FBFFFF               v  00 00  1 2628      
;  2790 --              if not retN() then exit end if
;  2791                 rtype = 2       -- 2 normal
    mov qword[rbp-296] (rtype),2          ;#004480A2: 48:307205 D8FEFFFF 02000000 uv 00 20  1 2629      
;  2792             end if  -- lineno!=-1
    jmp #004481E5                         ;#004480AD: 351 33010000               v  00 00  1 2629      
;  2793         else -- K_wdb
;  2794             if sNTyp<S_Type then
    mov rdi,[rbp-96] (sNTyp)              ;#004480B2: 48:213175 A0               uv 80 20  1 2630      
    cmp rdi,6                             ;#004480B6: 48:203377 06               uv 00 80  1 2631 80   
    jge #004481DA                         ;#004480BA: 017215 1A010000            v  00 00  1 2631      
;  2795                 put2(sprintf("diag.e: symtab[%d] bad S_NTyp[%d]\n",{rtn,sNTyp}))
    mov rcx,[rbp-216] (rtn)               ;#004480C0: 48:213215 28FFFFFF         uv 02 20  1 2632      
    mov r15,h4                            ;#004480C7: 49:277 0000000000000040    vu 8000 00  1 2632      
    cmp rcx,r15                           ;#004480D1: 4C:071371                  uv 00 8002  1 2633      
    jne #004480E2                         ;#004480D4: 165 0C                     v  00 00  1 2633      
    mov rsi,700                           ;#004480D6: 48:307306 BC020000         uv 40 00  1 2634      
    call #00442D75 (:%pUnassigned)        ;#004480DD: 350 93ACFFFF               v  00 00  1 2634      
    lea rax,[rbp-560] (symtab[797])       ;#004480E2: 48:215205 D0FDFFFF         uv 01 20  1 2635      
    mov rdx,2                             ;#004480E9: 48:307302 02000000         vu 04 00  1 2635      
    push #00448104                        ;#004480F0: 150 04814400               uv 00 00  1 2636      
    push rax                              ;#004480F5: 120                        vu 00 01  1 2636      
    push rdi                              ;#004480F6: 127                        uv 00 80  1 2637      
    push rcx                              ;#004480F7: 121                        vu 00 02  1 2637      
    mov rdi,[rbp-560] (symtab[797])       ;#004480F8: 48:213275 D0FDFFFF         uv 80 20  1 2638      
    jmp #004404BD (:%pMkSq)               ;#004480FF: 351 B983FFFF               v  00 00  1 2638      
    mov rcx,33                            ;#00448104: 48:307301 21000000         uv 02 00  1 2639      
    mov rdx,89                            ;#0044810B: 48:307302 59000000         vu 04 00  1 2639      
    call #004428DB (:%opFrame) (sprintf)  ;#00448112: 350 C4A7FFFF               v  00 00  1 2640      
    mov rsi,qword[#00402D68]              ;#00448117: 48:213065 4AACFBFF         uv 40 00  1 2641      
    mov [rbp] (format),rsi                ;#0044811E: 48:211165 00               uv 00 60  1 2642 40   
    add qword[rbx+rsi*4-16],1             ;#00448122: 48:203104263 F0 01         u  00 48  3 2644    *40*
    mov rdi,[rbp+40] (prevebp)            ;#00448128: 48:213175 28               vu 80 20  1 2646      
    mov rax,[rdi-560]                     ;#0044812C: 48:213207 D0FDFFFF         uv 01 80  1 2649    *80*
    xor rbx,rbx                           ;#00448133: 48:061333                  vu 08 08  1 2649      
    mov r15,h4                            ;#00448136: 49:277 0000000000000040    uv 8000 00  1 2650      
    cmp rax,r15                           ;#00448140: 4C:071370                  uv 00 8001  1 2651 8000   
    jl #00448150                          ;#00448143: 174 0B                     v  00 00  1 2651      
    add qword[rbx+rax*4-16],1             ;#00448145: 48:203104203 F0 01         u  00 09  3 2652      
    cmp eax,797                           ;#0044814B: 075 1D030000               vu 00 01  1 2654      
    mov [rbp-8] (args),rax                ;#00448150: 48:211105 F8               uv 00 21  1 2655      
    mov qword[retaddr],#00448161          ;#00448154: 48:307105 20 61814400      vu 00 20  1 2655      
    jmp #0044E450 (code:sprintf)          ;#0044815C: 351 EF620000               v  00 00  1 2656      
    push rax                              ;#00448161: 120                        uv 00 01  1 2657      
    mov rcx,[rbp-400] (symtab[725])       ;#00448162: 48:213215 70FEFFFF         vu 02 20  1 2657      
    mov r15,h4                            ;#00448169: 49:277 0000000000000040    uv 8000 00  1 2658      
    cmp rcx,r15                           ;#00448173: 4C:071371                  uv 00 8002  1 2659 8000   
    jle #00448188                         ;#00448176: 176 10                     v  00 00  1 2659      
    sub qword[rbx+rcx*4-16],1             ;#00448178: 48:203154213 F0 01         u  00 0A  3 2660      
    jne #00448188                         ;#0044817E: 165 08                     v  00 00  1 2662      
    mov rdx,rcx                           ;#00448180: 48:213321                  uv 04 02  1 2663      
    call #004422DA (:%pDealloc)           ;#00448183: 350 52A1FFFF               v  00 00  1 2663      
    pop dword[rbp-400] (symtab[725])      ;#00448188: 217205 70FEFFFF            np 00 20  3 2664      
    mov rcx,3                             ;#0044818E: 48:307301 03000000         uv 02 00  1 2667      
    mov rdx,474                           ;#00448195: 48:307302 DA010000         vu 04 00  1 2667      
    call #004428DB (:%opFrame) (put2)     ;#0044819C: 350 3AA7FFFF               v  00 00  1 2668      
    mov rdi,[rbp+40] (prevebp)            ;#004481A1: 48:213175 28               uv 80 20  1 2669      
    mov rax,[rdi-400]                     ;#004481A5: 48:213207 70FEFFFF         uv 01 80  1 2672 80 *80*
    xor rbx,rbx                           ;#004481AC: 48:061333                  vu 08 08  1 2672      
    mov r15,h4                            ;#004481AF: 49:277 0000000000000040    uv 8000 00  1 2673      
    cmp rax,r15                           ;#004481B9: 4C:071370                  uv 00 8001  1 2674 8000   
    jl #004481C9                          ;#004481BC: 174 0B                     v  00 00  1 2674      
    add qword[rbx+rax*4-16],1             ;#004481BE: 48:203104203 F0 01         u  00 09  3 2675      
    cmp eax,725                           ;#004481C4: 075 D5020000               vu 00 01  1 2677      
    mov [rbp] (emsg),rax                  ;#004481C9: 48:211105 00               uv 00 21  1 2678      
    mov qword[retaddr],#004481DA          ;#004481CD: 48:307105 20 DA814400      vu 00 20  1 2678      
    jmp #0044D150 (code:put2)             ;#004481D5: 351 764F0000               v  00 00  1 2679      
;  2796 --          else
;  2797 --              put2(sprintf("diag.e: symtab[%d] skipped (no debug)\n",{rtn}))
;  2798             end if
;  2799 --          msg_id = 0
;  2800 --          if not retN() then exit end if
;  2801             rtype = 3           -- 3 without debug
    mov qword[rbp-296] (rtype),3          ;#004481DA: 48:307205 D8FEFFFF 03000000 uv 00 20  1 2680      
;  2802         end if  -- K_wdb
;  2803         msg_id = 0
    mov [#00402BA8] (msg_id),rbx          ;#004481E5: 48:211035 BCA9FBFF         vu 00 08  1 2680      
;  2804 end if
;  2805         while 1 do
;  2806             or_ebp = floor(prev_ebp/4)
    mov rdi,[rbp-240] (prev_ebp)          ;#004481EC: 48:213275 10FFFFFF         uv 80 20  1 2681      
    mov r15,h4                            ;#004481F3: 49:277 0000000000000040    vu 8000 00  1 2681      
    cmp rdi,r15                           ;#004481FD: 4C:071377                  uv 00 8080  1 2682      
    jne #0044820E                         ;#00448200: 165 0C                     v  00 00  1 2682      
    mov rsi,703                           ;#00448202: 48:307306 BF020000         uv 40 00  1 2683      
    call #00442D75 (:%pUnassigned)        ;#00448209: 350 67ABFFFF               v  00 00  1 2683      
    lea rdi,[#00402AE8] (or_ebp)          ;#0044820E: 48:215075 D3A8FBFF         uv 80 00  1 2684      
    mov rcx,[rbp-240] (prev_ebp)          ;#00448215: 48:213215 10FFFFFF         vu 02 20  1 2684      
    mov rax,[#004020A8] (D_YEAR)          ;#0044821C: 48:213005 859EFBFF         uv 01 00  1 2685      
    call #0043F5E4 (:%opDivf)             ;#00448223: 350 BC73FFFF               v  00 00  1 2685      
;  2807             or_era = ret_addr-1
    mov rsi,[rbp-232] (ret_addr)          ;#00448228: 48:213265 18FFFFFF         uv 40 20  1 2686      
    mov r15,h4                            ;#0044822F: 49:277 0000000000000040    vu 8000 00  1 2686      
    cmp rsi,r15                           ;#00448239: 4C:071376                  uv 00 8040  1 2687      
    jne #0044824A                         ;#0044823C: 165 0C                     v  00 00  1 2687      
    mov rsi,702                           ;#0044823E: 48:307306 BE020000         uv 40 00  1 2688      
    call #00442D75 (:%pUnassigned)        ;#00448245: 350 2BABFFFF               v  00 00  1 2688      
    lea rdi,[#00402B10] (or_era)          ;#0044824A: 48:215075 BFA8FBFF         uv 80 00  1 2689      
    mov rcx,rsi                           ;#00448251: 48:211361                  vu 02 40  1 2689      
    mov rax,qword[#00402030]              ;#00448254: 48:213005 D59DFBFF         uv 01 00  1 2690      
    call #0043F4D8 (:%opSub)              ;#0044825B: 350 7872FFFF               v  00 00  1 2690      
;  2808             if or_ebp=0 then exit end if
    mov rdi,[#00402AE8] (or_ebp)          ;#00448260: 48:213075 81A8FBFF         uv 80 00  1 2691      
    cmp rdi,0                             ;#00448267: 48:203377 00               uv 00 80  1 2692 80   
    je #0044842D                          ;#0044826B: 017204 BC010000            v  00 00  1 2692      
;  2809             if machine_bits()=32 then
;  2810                 {N,rtn,from_addr,ret_addr,prev_ebp,ebp_root} = peek4u({or_ebp*4+4,6})
;  2811             else -- machine_bits()=64
;  2812                 {N,rtn,from_addr,ret_addr,prev_ebp,ebp_root} = peek8u({or_ebp*4+8,6})
    lea rdi,[rbp-512] (symtab[782])       ;#00448271: 48:215275 00FEFFFF         uv 80 20  1 2693      
    mov rcx,[#00402AE8] (or_ebp)          ;#00448278: 48:213015 69A8FBFF         vu 02 00  1 2693      
    mov rax,[#004020A8] (D_YEAR)          ;#0044827F: 48:213005 229EFBFF         uv 01 00  1 2694      
    call #0043F67C (:%opMul)              ;#00448286: 350 F173FFFF               v  00 00  1 2694      
    lea rdi,[rbp-368] (symtab[719])       ;#0044828B: 48:215275 90FEFFFF         uv 80 20  1 2695      
    mov rcx,[rbp-512] (symtab[782])       ;#00448292: 48:213215 00FEFFFF         vu 02 20  1 2695      
    mov rax,[#004020C8] (D_MINUTE)        ;#00448299: 48:213005 289EFBFF         uv 01 00  1 2696      
    call #0043F4AF (:%opAdd)              ;#004482A0: 350 0A72FFFF               v  00 00  1 2696      
    lea rax,[rbp-560] (symtab[797])       ;#004482A5: 48:215205 D0FDFFFF         uv 01 20  1 2697      
    mov rdx,2                             ;#004482AC: 48:307302 02000000         vu 04 00  1 2697      
    push #004482D4                        ;#004482B3: 150 D4824400               uv 00 00  1 2698      
    push rax                              ;#004482B8: 120                        vu 00 01  1 2698      
    push 6                                ;#004482B9: 152 06                     uv 00 00  1 2699      
    push qword[rbp-368] (symtab[719])     ;#004482BB: 377265 90FEFFFF            np 00 20  2 2700      
    mov [rbp-368] (symtab[719]),rbx       ;#004482C1: 48:211235 90FEFFFF         uv 00 28  1 2702      
    mov rdi,[rbp-560] (symtab[797])       ;#004482C8: 48:213275 D0FDFFFF         vu 80 20  1 2702      
    jmp #004404BD (:%pMkSq)               ;#004482CF: 351 E981FFFF               v  00 00  1 2703      
    lea rdi,[rbp-528] (symtab[787])       ;#004482D4: 48:215275 F0FDFFFF         uv 80 20  1 2704      
    mov rsi,[rbp-560] (symtab[797])       ;#004482DB: 48:213265 D0FDFFFF         vu 40 20  1 2704      
    xor rcx,rcx                           ;#004482E2: 48:061311                  uv 02 02  1 2705      
    mov rdx,8                             ;#004482E5: 48:307302 08000000         vu 04 00  1 2705      
    call #0043ED6C (:%opPeekNx)           ;#004482EC: 350 7B6AFFFF               v  00 00  1 2706      
    mov rdi,6                             ;#004482F1: 48:307307 06000000         uv 80 00  1 2707      
    lea rcx,[rbp-248] (ebp_root)          ;#004482F8: 48:215215 08FFFFFF         vu 02 20  1 2707      
    mov rsi,[rbp-528] (symtab[787])       ;#004482FF: 48:213265 F0FDFFFF         uv 40 20  1 2708      
    mov rdx,787                           ;#00448306: 48:307302 13030000         vu 04 00  1 2708      
    call #00441675 (:%pSubse1)            ;#0044830D: 350 6393FFFF               v  00 00  1 2709      
    mov rdi,5                             ;#00448312: 48:307307 05000000         uv 80 00  1 2710      
    lea rcx,[rbp-240] (prev_ebp)          ;#00448319: 48:215215 10FFFFFF         vu 02 20  1 2710      
    mov rsi,[rbp-528] (symtab[787])       ;#00448320: 48:213265 F0FDFFFF         uv 40 20  1 2711      
    mov rdx,787                           ;#00448327: 48:307302 13030000         vu 04 00  1 2711      
    call #00441675 (:%pSubse1)            ;#0044832E: 350 4293FFFF               v  00 00  1 2712      
    mov rdi,4                             ;#00448333: 48:307307 04000000         uv 80 00  1 2713      
    lea rcx,[rbp-232] (ret_addr)          ;#0044833A: 48:215215 18FFFFFF         vu 02 20  1 2713      
    mov rsi,[rbp-528] (symtab[787])       ;#00448341: 48:213265 F0FDFFFF         uv 40 20  1 2714      
    mov rdx,787                           ;#00448348: 48:307302 13030000         vu 04 00  1 2714      
    call #00441675 (:%pSubse1)            ;#0044834F: 350 2193FFFF               v  00 00  1 2715      
    mov rdi,3                             ;#00448354: 48:307307 03000000         uv 80 00  1 2716      
    lea rcx,[rbp-224] (from_addr)         ;#0044835B: 48:215215 20FFFFFF         vu 02 20  1 2716      
    mov rsi,[rbp-528] (symtab[787])       ;#00448362: 48:213265 F0FDFFFF         uv 40 20  1 2717      
    mov rdx,787                           ;#00448369: 48:307302 13030000         vu 04 00  1 2717      
    call #00441675 (:%pSubse1)            ;#00448370: 350 0093FFFF               v  00 00  1 2718      
    mov rdi,2                             ;#00448375: 48:307307 02000000         uv 80 00  1 2719      
    lea rcx,[rbp-216] (rtn)               ;#0044837C: 48:215215 28FFFFFF         vu 02 20  1 2719      
    mov rsi,[rbp-528] (symtab[787])       ;#00448383: 48:213265 F0FDFFFF         uv 40 20  1 2720      
    mov rdx,787                           ;#0044838A: 48:307302 13030000         vu 04 00  1 2720      
    call #004416F2 (:%pSubse1i)           ;#00448391: 350 5C93FFFF               v  00 00  1 2721      
    mov rdi,1                             ;#00448396: 48:307307 01000000         uv 80 00  1 2722      
    lea rcx,[rbp-208] (N)                 ;#0044839D: 48:215215 30FFFFFF         vu 02 20  1 2722      
    mov rsi,[rbp-528] (symtab[787])       ;#004483A4: 48:213265 F0FDFFFF         uv 40 20  1 2723      
    mov rdx,787                           ;#004483AB: 48:307302 13030000         vu 04 00  1 2723      
    call #004416F2 (:%pSubse1i)           ;#004483B2: 350 3B93FFFF               v  00 00  1 2724      
;  2813             end if
;  2814 --if diagdiag then
;  2815 --          printf(1,"N=%d, rtn=%d, from=#%s, ret=#%s, prevebp=#%s, ebproot=#%s\n",
;  2816 --                 {N,rtn,addrS(from_addr),addrS(ret_addr),addrS(prev_ebp),addrS(ebp_root)})
;  2817 --end if
;  2818 -- (untried [might cause problems with test after loop, which might go away if moved (back) above??])
;  2819             if prev_ebp=0 then exit end if
    mov rcx,[rbp-240] (prev_ebp)          ;#004483B7: 48:213215 10FFFFFF         uv 02 20  1 2725      
    cmp rcx,0                             ;#004483BE: 48:203371 00               uv 00 02  1 2726 02   
    je #0044842D                          ;#004483C2: 164 69                     v  00 00  1 2726      
;  2820             if ret_addr!=0 then
    mov rdi,[rbp-232] (ret_addr)          ;#004483C4: 48:213275 18FFFFFF         uv 80 20  1 2727      
    cmp rdi,0                             ;#004483CB: 48:203377 00               uv 00 80  1 2728 80   
    je #004483ED                          ;#004483CF: 164 1C                     v  00 00  1 2728      
;  2821                 ret_addr -= 1
    lea rdi,[rbp-232] (ret_addr)          ;#004483D1: 48:215275 18FFFFFF         uv 80 20  1 2729      
    mov rcx,[rbp-232] (ret_addr)          ;#004483D8: 48:213215 18FFFFFF         vu 02 20  1 2729      
    mov rax,qword[#00402030]              ;#004483DF: 48:213005 4A9CFBFF         uv 01 00  1 2730      
    call #0043F4D8 (:%opSub)              ;#004483E6: 350 ED70FFFF               v  00 00  1 2730      
;  2822                 exit
    jmp #0044842D                         ;#004483EB: 353 40                     v  00 00  1 2731      
;  2823             end if
;  2824 if prev_ebp!=0 then
    cmp rcx,0                             ;#004483ED: 48:203371 00               uv 00 02  1 2732      
    je #004481EC                          ;#004483F1: 017204 F5FDFFFF            v  00 00  1 2732      
;  2825             put2("(^^^) call_back from Windows/dll/asm\n")
    mov rcx,3                             ;#004483F7: 48:307301 03000000         uv 02 00  1 2733      
    mov rdx,474                           ;#004483FE: 48:307302 DA010000         vu 04 00  1 2733      
    call #004428DB (:%opFrame) (put2)     ;#00448405: 350 D1A4FFFF               v  00 00  1 2734      
    mov rsi,qword[#00402D70]              ;#0044840A: 48:213065 5FA9FBFF         uv 40 00  1 2735      
    mov [rbp] (emsg),rsi                  ;#00448411: 48:211165 00               uv 00 60  1 2736 40   
    add qword[rbx+rsi*4-16],1             ;#00448415: 48:203104263 F0 01         u  00 48  3 2738    *40*
    mov qword[retaddr],#00448428          ;#0044841B: 48:307105 20 28844400      vu 00 20  1 2740      
    jmp #0044D150 (code:put2)             ;#00448423: 351 284D0000               v  00 00  1 2741      
;  2826 end if
;  2827         end while
    jmp #004481EC                         ;#00448428: 351 BFFDFFFF               v  00 00  1 2742      
;  2828         if or_ebp=0 then
    xor rdi,rdi                           ;#0044842D: 48:061377                  uv 80 80  1 2743      
    mov rax,[#00402AE8] (or_ebp)          ;#00448430: 48:213005 B1A6FBFF         vu 01 00  1 2743      
    mov rsi,25                            ;#00448437: 48:307306 19000000         uv 40 00  1 2744      
    mov rdx,614                           ;#0044843E: 48:307302 66020000         vu 04 00  1 2744      
    call #0043FAF6 (:%opJccE)             ;#00448445: 350 AC76FFFF               v  00 00  1 2745      
    jne #0044857D                         ;#0044844A: 017205 2D010000            v  00 00  1 2746      
;  2829             if length(msg2) then
    mov rdi,[rbp-328] (msg2)              ;#00448450: 48:213275 B8FEFFFF         uv 80 20  1 2747      
    mov rcx,[rbx+rdi*4-24]                ;#00448457: 48:213114273 E8            uv 02 88  1 2750 80 *80*
    test rcx,ecx                          ;#0044845C: 205311                     uv 00 02  1 2751 02   
    je #004484F6                          ;#0044845E: 017204 92000000            v  00 00  1 2751      
;  2830                 put2(msg2)
    mov rcx,3                             ;#00448464: 48:307301 03000000         uv 02 00  1 2752      
    mov rdx,474                           ;#0044846B: 48:307302 DA010000         vu 04 00  1 2752      
    call #004428DB (:%opFrame) (put2)     ;#00448472: 350 64A4FFFF               v  00 00  1 2753      
    mov rdi,[rbp+40] (prevebp)            ;#00448477: 48:213175 28               uv 80 20  1 2754      
    mov rax,[rdi-328]                     ;#0044847B: 48:213207 B8FEFFFF         uv 01 80  1 2757 80 *80*
    xor rbx,rbx                           ;#00448482: 48:061333                  vu 08 08  1 2757      
    mov r15,h4                            ;#00448485: 49:277 0000000000000040    uv 8000 00  1 2758      
    cmp rax,r15                           ;#0044848F: 4C:071370                  uv 00 8001  1 2759 8000   
    jl #0044849F                          ;#00448492: 174 0B                     v  00 00  1 2759      
    add qword[rbx+rax*4-16],1             ;#00448494: 48:203104203 F0 01         u  00 09  3 2760      
    cmp eax,714                           ;#0044849A: 075 CA020000               vu 00 01  1 2762      
    mov [rbp] (emsg),rax                  ;#0044849F: 48:211105 00               uv 00 21  1 2763      
    mov qword[retaddr],#004484B0          ;#004484A3: 48:307105 20 B0844400      vu 00 20  1 2763      
    jmp #0044D150 (code:put2)             ;#004484AB: 351 A04C0000               v  00 00  1 2764      
;  2831                 msg2 = ""
    mov rsi,qword[#00402240]              ;#004484B0: 48:213065 899DFBFF         uv 40 00  1 2765      
    mov rdx,[rbp-328] (msg2)              ;#004484B7: 48:213225 B8FEFFFF         vu 04 20  1 2765      
    mov r15,h4                            ;#004484BE: 49:277 0000000000000040    uv 8000 00  1 2766      
    cmp rsi,r15                           ;#004484C8: 4C:071376                  uv 00 8040  1 2767 8000   
    jl #004484D3                          ;#004484CB: 174 06                     v  00 00  1 2767      
    add qword[rbx+rsi*4-16],1             ;#004484CD: 48:203104263 F0 01         u  00 48  3 2768      
    mov [rbp-328] (msg2),rsi              ;#004484D3: 48:211265 B8FEFFFF         vu 00 60  1 2770      
    mov r15,h4                            ;#004484DA: 49:277 0000000000000040    uv 8000 00  1 2771      
    cmp rdx,r15                           ;#004484E4: 4C:071372                  uv 00 8004  1 2772 8000   
    jle #004484F6                         ;#004484E7: 176 0D                     v  00 00  1 2772      
    sub qword[rbx+rdx*4-16],1             ;#004484E9: 48:203154223 F0 01         u  00 0C  3 2773      
    jne #004484F6                         ;#004484EF: 165 05                     v  00 00  1 2775      
    call #004422DA (:%pDealloc)           ;#004484F1: 350 E49DFFFF               v  00 00  1 2776      
;  2832             end if
;  2833             if rtype=1 then -- skip (lineno=-1)
    mov rdi,1                             ;#004484F6: 48:307307 01000000         uv 80 00  1 2777      
    mov rax,[rbp-296] (rtype)             ;#004484FD: 48:213205 D8FEFFFF         vu 01 20  1 2777      
    mov rsi,26                            ;#00448504: 48:307306 1A000000         uv 40 00  1 2778      
    mov rdx,710                           ;#0044850B: 48:307302 C6020000         vu 04 00  1 2778      
    call #0043FAF6 (:%opJccE)             ;#00448512: 350 DF75FFFF               v  00 00  1 2779      
    jne #004485DA                         ;#00448517: 017205 BD000000            v  00 00  1 2780      
;  2834                 printf(1,"diag.e: oops, lineno=-1/e92/not retD(), era=#%08x\n",or_era)
    mov rcx,4                             ;#0044851D: 48:307301 04000000         uv 02 00  1 2781      
    mov rdx,94                            ;#00448524: 48:307302 5E000000         vu 04 00  1 2781      
    call #004428DB (:%opFrame) (printf)   ;#0044852B: 350 ABA3FFFF               v  00 00  1 2782      
    mov qword[rbp] (fn),1                 ;#00448530: 48:307105 00 01000000      uv 00 20  1 2783      
    mov rdi,qword[#00402D78]              ;#00448538: 48:213075 39A8FBFF         vu 80 00  1 2783      
    mov [rbp-8] (format),rdi              ;#0044853F: 48:211175 F8               uv 00 A0  1 2784      
    add qword[rbx+rdi*4-16],1             ;#00448543: 48:203104273 F0 01         u  00 88  3 2786    *80*
    mov rcx,[#00402B10] (or_era)          ;#00448549: 48:213015 C0A5FBFF         vu 02 00  1 2788      
    mov [rbp-16] (args),rcx               ;#00448550: 48:211115 F0               uv 00 22  1 2789      
    mov r15,h4                            ;#00448554: 49:277 0000000000000040    vu 8000 00  1 2789      
    cmp rcx,r15                           ;#0044855E: 4C:071371                  uv 00 8002  1 2790      
    jl #0044856E                          ;#00448561: 174 0B                     v  00 00  1 2790      
    add qword[rbx+rcx*4-16],1             ;#00448563: 48:203104213 F0 01         u  00 0A  3 2791      
    cmp eax,619                           ;#00448569: 075 6B020000               vu 00 01  1 2793      
    mov qword[retaddr],#0044857B          ;#0044856E: 48:307105 20 7B854400      uv 00 20  1 2794      
    jmp #00451A31 (code:printf)           ;#00448576: 351 B6940000               v  00 00  1 2794      
;  2835             end if
;  2836             exit
    jmp #004485DA                         ;#0044857B: 353 5D                     v  00 00  1 2795      
;  2837         end if
;  2838         if rtype = 2 then       -- 2 normal
    mov rdi,2                             ;#0044857D: 48:307307 02000000         uv 80 00  1 2796      
    mov rax,[rbp-296] (rtype)             ;#00448584: 48:213205 D8FEFFFF         vu 01 20  1 2796      
    mov rsi,39                            ;#0044858B: 48:307306 27000000         uv 40 00  1 2797      
    mov rdx,710                           ;#00448592: 48:307302 C6020000         vu 04 00  1 2797      
    call #0043FAF6 (:%opJccE)             ;#00448599: 350 5875FFFF               v  00 00  1 2798      
    jne #00446DB2                         ;#0044859E: 017205 0EE8FFFF            v  00 00  1 2799      
;  2839             put2("... called from ")
    mov rcx,3                             ;#004485A4: 48:307301 03000000         uv 02 00  1 2800      
    mov rdx,474                           ;#004485AB: 48:307302 DA010000         vu 04 00  1 2800      
    call #004428DB (:%opFrame) (put2)     ;#004485B2: 350 24A3FFFF               v  00 00  1 2801      
    mov rsi,qword[#00402D80]              ;#004485B7: 48:213065 C2A7FBFF         uv 40 00  1 2802      
    mov [rbp] (emsg),rsi                  ;#004485BE: 48:211165 00               uv 00 60  1 2803 40   
    add qword[rbx+rsi*4-16],1             ;#004485C2: 48:203104263 F0 01         u  00 48  3 2805    *40*
    mov qword[retaddr],#004485D5          ;#004485C8: 48:307105 20 D5854400      vu 00 20  1 2807      
    jmp #0044D150 (code:put2)             ;#004485D0: 351 7B4B0000               v  00 00  1 2808      
;  2840         end if
;  2841     end while
    jmp #00446DB2                         ;#004485D5: 351 D8E7FFFF               v  00 00  1 2809      
;  2842 puts(1,"\nGlobal & Local Variables\n")
    mov rax,1                             ;#004485DA: 48:307300 01000000         uv 01 00  1 2810      
    mov rdx,qword[#00402D88]              ;#004485E1: 48:213025 A0A7FBFF         vu 04 00  1 2810      
    call #0043E218 (:%opPuts)             ;#004485E8: 350 2B5CFFFF               v  00 00  1 2811      
;  2843     if fn!=-1 then
    mov rdi,-1                            ;#004485ED: 48:307307 FFFFFFFF         uv 80 00  1 2812      
    mov rax,[#00402618] (fn)              ;#004485F4: 48:213005 1DA0FBFF         vu 01 00  1 2812      
    mov rsi,24                            ;#004485FB: 48:307306 18000000         uv 40 00  1 2813      
    mov rdx,387                           ;#00448602: 48:307302 83010000         vu 04 00  1 2813      
    call #0043FAF6 (:%opJccE)             ;#00448609: 350 E874FFFF               v  00 00  1 2814      
    je #00448C0F                          ;#0044860E: 017204 FB050000            v  00 00  1 2815      
;  2844         puts(fn,"\nGlobal & Local Variables\n")
    mov rax,[#00402618] (fn)              ;#00448614: 48:213005 FD9FFBFF         uv 01 00  1 2816      
    mov rdx,qword[#00402D88]              ;#0044861B: 48:213025 66A7FBFF         vu 04 00  1 2816      
    call #0043E218 (:%opPuts)             ;#00448622: 350 F15BFFFF               v  00 00  1 2817      
;  2845         fileno = 0
    mov [rbp-80] (fileno),rbx             ;#00448627: 48:211135 B0               uv 00 28  1 2818      
;  2846 
;  2847         for i=T_const1+1 to length(symtab) do
    lea rdi,[rbp-544] (symtab[791])       ;#0044862B: 48:215275 E0FDFFFF         vu 80 20  1 2818      
    mov rsi,[rbp] (symtab)                ;#00448632: 48:213165 00               uv 40 20  1 2819      
    mov rdx,673                           ;#00448636: 48:307302 A1020000         vu 04 00  1 2819      
    call #0043F28D (:%opLen)              ;#0044863D: 350 4B6CFFFF               v  00 00  1 2820      
    mov qword[rbp-568] (i),27             ;#00448642: 48:307205 C8FDFFFF 1B000000 uv 00 20  1 2821      
    cmp rcx,27                            ;#0044864D: 48:201371 1B000000         vu 00 02  1 2821      
    jl #00448AC5                          ;#00448654: 017214 6B040000            v  00 00  1 2822      
;  2848             si = symtab[i]
    mov rdi,[rbp] (symtab)                ;#0044865A: 48:213175 00               uv 80 20  1 2823      
    mov r15,h4                            ;#0044865E: 49:277 0000000000000040    vu 8000 00  1 2823      
    cmp rdi,r15                           ;#00448668: 4C:071377                  uv 00 8080  1 2824      
    jne #00448679                         ;#0044866B: 165 0C                     v  00 00  1 2824      
    mov rsi,673                           ;#0044866D: 48:307306 A1020000         uv 40 00  1 2825      
    call #00442D75 (:%pUnassigned)        ;#00448674: 350 FCA6FFFF               v  00 00  1 2825      
    mov rdi,[rbp-568] (i)                 ;#00448679: 48:213275 C8FDFFFF         uv 80 20  1 2826      
    lea rcx,[rbp-8] (si)                  ;#00448680: 48:215115 F8               vu 02 20  1 2826      
    mov rsi,[rbp] (symtab)                ;#00448684: 48:213165 00               uv 40 20  1 2827      
    mov rdx,673                           ;#00448688: 48:307302 A1020000         vu 04 00  1 2827      
    call #00441675 (:%pSubse1)            ;#0044868F: 350 E18FFFFF               v  00 00  1 2828      
;  2849             if sequence(si) then                            -- might not be dumped (unused)
    mov rax,[rbp-8] (si)                  ;#00448694: 48:213105 F8               uv 01 20  1 2829      
    mov r15,h4                            ;#00448698: 49:277 0000000000000040    vu 8000 00  1 2829      
    cmp rax,r15                           ;#004486A2: 4C:071370                  uv 00 8001  1 2830      
    jl #00448AA3                          ;#004486A5: 017214 F8030000            v  00 00  1 2830      
    test byte[rbx+rax*4-1],#80            ;#004486AB: 366104203 FF 80            u  00 09  2 2831      
    je #00448AA3                          ;#004486B0: 017204 ED030000            v  00 00  1 2832      
;  2850                 name = si[S_Name]
    mov rdi,1                             ;#004486B6: 48:307307 01000000         uv 80 00  1 2833      
    lea rcx,[rbp-24] (name)               ;#004486BD: 48:215115 E8               vu 02 20  1 2833      
    mov rsi,rax                           ;#004486C1: 48:211306                  uv 40 01  1 2834      
    mov rdx,674                           ;#004486C4: 48:307302 A2020000         vu 04 00  1 2834      
    call #00441675 (:%pSubse1)            ;#004486CB: 350 A58FFFFF               v  00 00  1 2835      
;  2851 --SUG and consts?
;  2852                 if equal(si[S_NTyp],S_GVar2)
    mov rdi,2                             ;#004486D0: 48:307307 02000000         uv 80 00  1 2836      
    lea rcx,[rbp-440] (symtab[735])       ;#004486D7: 48:215215 48FEFFFF         vu 02 20  1 2836      
    mov rsi,[rbp-8] (si)                  ;#004486DE: 48:213165 F8               uv 40 20  1 2837      
    mov rdx,674                           ;#004486E2: 48:307302 A2020000         vu 04 00  1 2837      
    call #00441675 (:%pSubse1)            ;#004486E9: 350 878FFFFF               v  00 00  1 2838      
    mov rcx,[rbp-440] (symtab[735])       ;#004486EE: 48:213215 48FEFFFF         uv 02 20  1 2839      
    cmp rcx,2                             ;#004486F5: 48:203371 02               uv 00 02  1 2840 02   
    jne #00448AA3                         ;#004486F9: 017205 A4030000            v  00 00  1 2840      
;  2853                 and (swod or and_bits(si[S_State],K_wdb))   -- skip without debug items
    mov rdi,4                             ;#004486FF: 48:307307 04000000         uv 80 00  1 2841      
    lea rcx,[rbp-440] (symtab[735])       ;#00448706: 48:215215 48FEFFFF         vu 02 20  1 2841      
    mov rsi,[rbp-8] (si)                  ;#0044870D: 48:213165 F8               uv 40 20  1 2842      
    mov rdx,674                           ;#00448711: 48:307302 A2020000         vu 04 00  1 2842      
    call #00441675 (:%pSubse1)            ;#00448718: 350 588FFFFF               v  00 00  1 2843      
    lea rdi,[rbp-576] (symtab[804])       ;#0044871D: 48:215275 C0FDFFFF         uv 80 20  1 2844      
    mov rcx,[rbp-440] (symtab[735])       ;#00448724: 48:213215 48FEFFFF         vu 02 20  1 2844      
    mov rax,[#00402AB0] (K_wdb)           ;#0044872B: 48:213005 7EA3FBFF         uv 01 00  1 2845      
    call #0043F6C1 (:%opAndBits)          ;#00448732: 350 8A6FFFFF               v  00 00  1 2845      
    mov rdi,[rbp-576] (symtab[804])       ;#00448737: 48:213275 C0FDFFFF         uv 80 20  1 2846      
    test rdi,rdi                          ;#0044873E: 48:205377                  uv 00 80  1 2847 80   
    je #00448AA3                          ;#00448741: 017204 5C030000            v  00 00  1 2847      
;  2854                 and sequence(name) then                     -- skip unnamed items
    mov rsi,[rbp-24] (name)               ;#00448747: 48:213165 E8               uv 40 20  1 2848      
    mov r15,h4                            ;#0044874B: 49:277 0000000000000040    vu 8000 00  1 2848      
    cmp rsi,r15                           ;#00448755: 4C:071376                  uv 00 8040  1 2849      
    jl #00448AA3                          ;#00448758: 017214 45030000            v  00 00  1 2849      
    test byte[rbx+rsi*4-1],#80            ;#0044875E: 366104263 FF 80            u  00 48  2 2850      
    je #00448AA3                          ;#00448763: 017204 3A030000            v  00 00  1 2851      
;  2855                     fpno = si[S_FPno]
    mov rdi,3                             ;#00448769: 48:307307 03000000         uv 80 00  1 2852      
    lea rcx,[rbp-88] (fpno)               ;#00448770: 48:215115 A8               vu 02 20  1 2852      
    mov rsi,[rbp-8] (si)                  ;#00448774: 48:213165 F8               uv 40 20  1 2853      
    mov rdx,674                           ;#00448778: 48:307302 A2020000         vu 04 00  1 2853      
    call #004416F2 (:%pSubse1i)           ;#0044877F: 350 6E8FFFFF               v  00 00  1 2854      
;  2856                     if fileno!=fpno then
    mov rcx,[rbp-80] (fileno)             ;#00448784: 48:213115 B0               uv 02 20  1 2855      
    cmp rcx,rax                           ;#00448788: 48:071301                  uv 00 03  1 2856 02   
    je #004488A9                          ;#0044878B: 017204 18010000            v  00 00  1 2856      
;  2857                         fileno = fpno
    mov [rbp-80] (fileno),rax             ;#00448791: 48:211105 B0               uv 00 21  1 2857      
;  2858                         filename = symtab[T_fileset][fileno][1..2]
    mov rdi,[rbp] (symtab)                ;#00448795: 48:213175 00               vu 80 20  1 2857      
    mov r15,h4                            ;#00448799: 49:277 0000000000000040    uv 8000 00  1 2858      
    cmp rdi,r15                           ;#004487A3: 4C:071377                  uv 00 8080  1 2859 8000   
    jne #004487B4                         ;#004487A6: 165 0C                     v  00 00  1 2859      
    mov rsi,673                           ;#004487A8: 48:307306 A1020000         uv 40 00  1 2860      
    call #00442D75 (:%pUnassigned)        ;#004487AF: 350 C1A5FFFF               v  00 00  1 2860      
    lea rdx,[rbp-152] (filename)          ;#004487B4: 48:215225 68FFFFFF         uv 04 20  1 2861      
    mov rcx,3                             ;#004487BB: 48:307301 03000000         vu 02 00  1 2861      
    push #004487DE                        ;#004487C2: 150 DE874400               uv 00 00  1 2862      
    push rdx                              ;#004487C7: 122                        vu 00 04  1 2862      
    push 2                                ;#004487C8: 152 02                     uv 00 00  1 2863      
    push 1                                ;#004487CA: 152 01                     vu 00 00  1 2863      
    push rax                              ;#004487CC: 120                        uv 00 01  1 2864      
    push 17                               ;#004487CD: 152 11                     vu 00 00  1 2864      
    mov rsi,rdi                           ;#004487CF: 48:211376                  uv 40 80  1 2865      
    mov rdx,673                           ;#004487D2: 48:307302 A1020000         vu 04 00  1 2865      
    jmp #00440F1F (:%pSubss)              ;#004487D9: 351 4187FFFF               v  00 00  1 2866      
;  2859                         filename[1] = pathset[filename[1]]
    mov rdi,1                             ;#004487DE: 48:307307 01000000         uv 80 00  1 2867      
    lea rcx,[rbp-440] (symtab[735])       ;#004487E5: 48:215215 48FEFFFF         vu 02 20  1 2867      
    mov rsi,[rbp-152] (filename)          ;#004487EC: 48:213265 68FFFFFF         uv 40 20  1 2868      
    mov rdx,692                           ;#004487F3: 48:307302 B4020000         vu 04 00  1 2868      
    call #00441675 (:%pSubse1)            ;#004487FA: 350 768EFFFF               v  00 00  1 2869      
    mov rdi,[rbp-440] (symtab[735])       ;#004487FF: 48:213275 48FEFFFF         uv 80 20  1 2870      
    lea rcx,[rbp-584] (symtab[805])       ;#00448806: 48:215215 B8FDFFFF         vu 02 20  1 2870      
    mov rsi,[rbp-160] (pathset)           ;#0044880D: 48:213265 60FFFFFF         uv 40 20  1 2871      
    mov rdx,693                           ;#00448814: 48:307302 B5020000         vu 04 00  1 2871      
    call #00441675 (:%pSubse1)            ;#0044881B: 350 558EFFFF               v  00 00  1 2872      
    mov rdi,qword[#00402030]              ;#00448820: 48:213075 0998FBFF         uv 80 00  1 2873      
    mov rcx,[rbp-584] (symtab[805])       ;#00448827: 48:213215 B8FDFFFF         vu 02 20  1 2873      
    mov rsi,[rbp-152] (filename)          ;#0044882E: 48:213265 68FFFFFF         uv 40 20  1 2874      
    lea rax,[rbp-152] (filename)          ;#00448835: 48:215205 68FFFFFF         vu 01 20  1 2874      
    call #00440C54 (:%pRepe1)             ;#0044883C: 350 1384FFFF               v  00 00  1 2875      
;  2860                         printf(fn,"\n %s%s:\n",filename)
    mov rcx,4                             ;#00448841: 48:307301 04000000         uv 02 00  1 2876      
    mov rdx,94                            ;#00448848: 48:307302 5E000000         vu 04 00  1 2876      
    call #004428DB (:%opFrame) (printf)   ;#0044884F: 350 87A0FFFF               v  00 00  1 2877      
    mov rax,[#00402618] (fn)              ;#00448854: 48:213005 BD9DFBFF         uv 01 00  1 2878      
    mov [rbp] (fn),rax                    ;#0044885B: 48:211105 00               uv 00 21  1 2879 01   
    mov rdi,qword[#00402D98]              ;#0044885F: 48:213075 32A5FBFF         vu 80 00  1 2879      
    mov [rbp-8] (format),rdi              ;#00448866: 48:211175 F8               uv 00 A0  1 2880      
    add qword[rbx+rdi*4-16],1             ;#0044886A: 48:203104273 F0 01         u  00 88  3 2882    *80*
    mov rdi,[rbp+40] (prevebp)            ;#00448870: 48:213175 28               vu 80 20  1 2884      
    mov rax,[rdi-152]                     ;#00448874: 48:213207 68FFFFFF         uv 01 80  1 2887    *80*
    xor rbx,rbx                           ;#0044887B: 48:061333                  vu 08 08  1 2887      
    mov r15,h4                            ;#0044887E: 49:277 0000000000000040    uv 8000 00  1 2888      
    cmp rax,r15                           ;#00448888: 4C:071370                  uv 00 8001  1 2889 8000   
    jl #00448898                          ;#0044888B: 174 0B                     v  00 00  1 2889      
    add qword[rbx+rax*4-16],1             ;#0044888D: 48:203104203 F0 01         u  00 09  3 2890      
    cmp eax,692                           ;#00448893: 075 B4020000               vu 00 01  1 2892      
    mov [rbp-16] (args),rax               ;#00448898: 48:211105 F0               uv 00 21  1 2893      
    mov qword[retaddr],#004488A9          ;#0044889C: 48:307105 20 A9884400      vu 00 20  1 2893      
    jmp #00451A31 (code:printf)           ;#004488A4: 351 88910000               v  00 00  1 2894      
;  2861                     end if
;  2862                     {novalue,o} = getGvarValue(si[S_Slink])
    mov rdi,6                             ;#004488A9: 48:307307 06000000         uv 80 00  1 2895      
    lea rcx,[rbp-584] (symtab[805])       ;#004488B0: 48:215215 B8FDFFFF         vu 02 20  1 2895      
    mov rsi,[rbp-8] (si)                  ;#004488B7: 48:213165 F8               uv 40 20  1 2896      
    mov rdx,674                           ;#004488BB: 48:307302 A2020000         vu 04 00  1 2896      
    call #00441675 (:%pSubse1)            ;#004488C2: 350 AE8DFFFF               v  00 00  1 2897      
    mov rcx,4                             ;#004488C7: 48:307301 04000000         uv 02 00  1 2898      
    mov rdx,625                           ;#004488CE: 48:307302 71020000         vu 04 00  1 2898      
    call :%opFrame (getGvarValue)         ;#004488D5: 350 01A0FFFF               v  00 00  1 2899      
    mov rdi,[rbp+40] (prevebp)            ;#004488DA: 48:213175 28               uv 80 20  1 2900      
    mov rax,[rdi-584]                     ;#004488DE: 48:213207 B8FDFFFF         uv 01 80  1 2903 80 *80*
    xor rbx,rbx                           ;#004488E5: 48:061333                  vu 08 08  1 2903      
    mov r15,h4                            ;#004488E8: 49:277 0000000000000040    uv 8000 00  1 2904      
    cmp rax,r15                           ;#004488F2: 4C:071370                  uv 00 8001  1 2905 8000   
    jl #00448902                          ;#004488F5: 174 0B                     v  00 00  1 2905      
    add qword[rbx+rax*4-16],1             ;#004488F7: 48:203104203 F0 01         u  00 09  3 2906      
    cmp eax,805                           ;#004488FD: 075 25030000               vu 00 01  1 2908      
    mov [rbp] (gidx),rax                  ;#00448902: 48:211105 00               uv 00 21  1 2909      
    mov qword[retaddr],#00448913          ;#00448906: 48:307105 20 13894400      vu 00 20  1 2909      
    jmp #0044DD19 (code:getGvarValue)     ;#0044890E: 351 06540000               v  00 00  1 2910      
    push rax                              ;#00448913: 120                        uv 00 01  1 2911      
    mov rcx,[rbp-560] (symtab[797])       ;#00448914: 48:213215 D0FDFFFF         vu 02 20  1 2911      
    mov r15,h4                            ;#0044891B: 49:277 0000000000000040    uv 8000 00  1 2912      
    cmp rcx,r15                           ;#00448925: 4C:071371                  uv 00 8002  1 2913 8000   
    jle #0044893A                         ;#00448928: 176 10                     v  00 00  1 2913      
    sub qword[rbx+rcx*4-16],1             ;#0044892A: 48:203154213 F0 01         u  00 0A  3 2914      
    jne #0044893A                         ;#00448930: 165 08                     v  00 00  1 2916      
    mov rdx,rcx                           ;#00448932: 48:213321                  uv 04 02  1 2917      
    call #004422DA (:%pDealloc)           ;#00448935: 350 A099FFFF               v  00 00  1 2917      
    pop dword[rbp-560] (symtab[797])      ;#0044893A: 217205 D0FDFFFF            np 00 20  3 2918      
    mov rdi,2                             ;#00448940: 48:307307 02000000         uv 80 00  1 2921      
    lea rcx,[rbp-32] (o)                  ;#00448947: 48:215115 E0               vu 02 20  1 2921      
    mov rsi,[rbp-560] (symtab[797])       ;#0044894B: 48:213265 D0FDFFFF         uv 40 20  1 2922      
    mov rdx,797                           ;#00448952: 48:307302 1D030000         vu 04 00  1 2922      
    call #00441675 (:%pSubse1)            ;#00448959: 350 178DFFFF               v  00 00  1 2923      
    mov rdi,1                             ;#0044895E: 48:307307 01000000         uv 80 00  1 2924      
    lea rcx,[rbp-320] (novalue)           ;#00448965: 48:215215 C0FEFFFF         vu 02 20  1 2924      
    mov rsi,[rbp-560] (symtab[797])       ;#0044896C: 48:213265 D0FDFFFF         uv 40 20  1 2925      
    mov rdx,797                           ;#00448973: 48:307302 1D030000         vu 04 00  1 2925      
    call #004416F2 (:%pSubse1i)           ;#0044897A: 350 738DFFFF               v  00 00  1 2926      
;  2863                     if novalue then
    test rax,rax                          ;#0044897F: 48:205300                  uv 00 01  1 2927      
    je #00448A31                          ;#00448982: 017204 A9000000            v  00 00  1 2927      
;  2864                         printf(fn,"    %s = <novalue>\n",{name})
    lea rax,[rbp-592] (symtab[808])       ;#00448988: 48:215205 B0FDFFFF         uv 01 20  1 2928      
    mov rdx,1                             ;#0044898F: 48:307302 01000000         vu 04 00  1 2928      
    push #004489C7                        ;#00448996: 150 C7894400               uv 00 00  1 2929      
    push rax                              ;#0044899B: 120                        vu 00 01  1 2929      
    mov rdi,[rbp-24] (name)               ;#0044899C: 48:213175 E8               uv 80 20  1 2930      
    mov r15,h4                            ;#004489A0: 49:277 0000000000000040    vu 8000 00  1 2930      
    cmp rdi,r15                           ;#004489AA: 4C:071377                  uv 00 8080  1 2931      
    jl #004489BA                          ;#004489AD: 174 0B                     v  00 00  1 2931      
    add qword[rbx+rdi*4-16],1             ;#004489AF: 48:203104273 F0 01         u  00 88  3 2932      
    cmp eax,676                           ;#004489B5: 075 A4020000               vu 00 01  1 2934      
    push rdi                              ;#004489BA: 127                        uv 00 80  1 2935      
    mov rdi,[rbp-592] (symtab[808])       ;#004489BB: 48:213275 B0FDFFFF         vu 80 20  1 2935      
    jmp #004404BD (:%pMkSq)               ;#004489C2: 351 F67AFFFF               v  00 00  1 2936      
    mov rcx,4                             ;#004489C7: 48:307301 04000000         uv 02 00  1 2937      
    mov rdx,94                            ;#004489CE: 48:307302 5E000000         vu 04 00  1 2937      
    call #004428DB (:%opFrame) (printf)   ;#004489D5: 350 019FFFFF               v  00 00  1 2938      
    mov rcx,[#00402618] (fn)              ;#004489DA: 48:213015 379CFBFF         uv 02 00  1 2939      
    mov [rbp] (fn),rcx                    ;#004489E1: 48:211115 00               uv 00 22  1 2940 02   
    mov rsi,qword[#00402DA0]              ;#004489E5: 48:213065 B4A3FBFF         vu 40 00  1 2940      
    mov [rbp-8] (format),rsi              ;#004489EC: 48:211165 F8               uv 00 60  1 2941      
    add qword[rbx+rsi*4-16],1             ;#004489F0: 48:203104263 F0 01         u  00 48  3 2943    *40*
    mov rdi,[rbp+40] (prevebp)            ;#004489F6: 48:213175 28               vu 80 20  1 2945      
    mov rax,[rdi-592]                     ;#004489FA: 48:213207 B0FDFFFF         uv 01 80  1 2948    *80*
    xor rbx,rbx                           ;#00448A01: 48:061333                  vu 08 08  1 2948      
    mov r15,h4                            ;#00448A04: 49:277 0000000000000040    uv 8000 00  1 2949      
    cmp rax,r15                           ;#00448A0E: 4C:071370                  uv 00 8001  1 2950 8000   
    jl #00448A1E                          ;#00448A11: 174 0B                     v  00 00  1 2950      
    add qword[rbx+rax*4-16],1             ;#00448A13: 48:203104203 F0 01         u  00 09  3 2951      
    cmp eax,808                           ;#00448A19: 075 28030000               vu 00 01  1 2953      
    mov [rbp-16] (args),rax               ;#00448A1E: 48:211105 F0               uv 00 21  1 2954      
    mov qword[retaddr],#00448A2F          ;#00448A22: 48:307105 20 2F8A4400      vu 00 20  1 2954      
    jmp #00451A31 (code:printf)           ;#00448A2A: 351 02900000               v  00 00  1 2955      
    jmp #00448AA3                         ;#00448A2F: 353 72                     v  00 00  1 2956      
;  2865                     else
;  2866                         clever_dump(name, o)
    mov rcx,9                             ;#00448A31: 48:307301 09000000         uv 02 00  1 2957      
    mov rdx,447                           ;#00448A38: 48:307302 BF010000         vu 04 00  1 2957      
    call :%opFrame (clever_dump)          ;#00448A3F: 350 979EFFFF               v  00 00  1 2958      
    mov rdi,[rbp+40] (prevebp)            ;#00448A44: 48:213175 28               uv 80 20  1 2959      
    mov rax,[rdi-24]                      ;#00448A48: 48:213107 E8               uv 01 80  1 2962 80 *80*
    xor rbx,rbx                           ;#00448A4C: 48:061333                  vu 08 08  1 2962      
    mov r15,h4                            ;#00448A4F: 49:277 0000000000000040    uv 8000 00  1 2963      
    cmp rax,r15                           ;#00448A59: 4C:071370                  uv 00 8001  1 2964 8000   
    jl #00448A69                          ;#00448A5C: 174 0B                     v  00 00  1 2964      
    add qword[rbx+rax*4-16],1             ;#00448A5E: 48:203104203 F0 01         u  00 09  3 2965      
    cmp eax,676                           ;#00448A64: 075 A4020000               vu 00 01  1 2967      
    mov [rbp] (name),rax                  ;#00448A69: 48:211105 00               uv 00 21  1 2968      
    mov rdi,[rbp+40] (prevebp)            ;#00448A6D: 48:213175 28               vu 80 20  1 2968      
    mov rax,[rdi-32]                      ;#00448A71: 48:213107 E0               uv 01 80  1 2971    *80*
    xor rbx,rbx                           ;#00448A75: 48:061333                  vu 08 08  1 2971      
    mov r15,h4                            ;#00448A78: 49:277 0000000000000040    uv 8000 00  1 2972      
    cmp rax,r15                           ;#00448A82: 4C:071370                  uv 00 8001  1 2973 8000   
    jl #00448A92                          ;#00448A85: 174 0B                     v  00 00  1 2973      
    add qword[rbx+rax*4-16],1             ;#00448A87: 48:203104203 F0 01         u  00 09  3 2974      
    cmp eax,677                           ;#00448A8D: 075 A5020000               vu 00 01  1 2976      
    mov [rbp-8] (o),rax                   ;#00448A92: 48:211105 F8               uv 00 21  1 2977      
    mov qword[retaddr],#00448AA3          ;#00448A96: 48:307105 20 A38A4400      vu 00 20  1 2977      
    jmp #0044AAD9 (code:clever_dump)      ;#00448A9E: 351 36200000               v  00 00  1 2978      
;  2867                     end if
;  2868                 end if
;  2869             end if
;  2870         end for
    mov rdi,[rbp-568] (i)                 ;#00448AA3: 48:213275 C8FDFFFF         uv 80 20  1 2979      
    mov rcx,[rbp-544] (symtab[791])       ;#00448AAA: 48:213215 E0FDFFFF         vu 02 20  1 2979      
    add rdi,1                             ;#00448AB1: 48:203307 01               uv 80 80  1 2980      
    cmp rdi,rcx                           ;#00448AB5: 48:073371                  uv 00 82  1 2981 80   
    mov [rbp-568] (i),rdi                 ;#00448AB8: 48:211275 C8FDFFFF         vu 00 A0  1 2981      
    jle #0044865A                         ;#00448ABF: 017216 95FBFFFF            v  00 00  1 2982      
;  2871 
;  2872         if not batchmode then
    mov rsi,[#00402678] (batchmode)       ;#00448AC5: 48:213065 AC9BFBFF         uv 40 00  1 2983      
    test rsi,rsi                          ;#00448ACC: 48:205366                  uv 00 40  1 2984 40   
    jne #00448BFD                         ;#00448ACF: 017205 28010000            v  00 00  1 2984      
;  2873             puts(1,"\n")
    mov rax,1                             ;#00448AD5: 48:307300 01000000         uv 01 00  1 2985      
    mov rdx,qword[#00402600]              ;#00448ADC: 48:213025 1D9BFBFF         vu 04 00  1 2985      
    call #0043E218 (:%opPuts)             ;#00448AE3: 350 3057FFFF               v  00 00  1 2986      
;  2874 --DEV
;  2875 --          #isginfo{crash_msg,0b1001,0,0,integer,0} -- (verify compiler is working properly)
;  2876 --          #isginfo{crash_msg,0b1001,0,0,integer,3} -- (verify compiler is working properly)
;  2877             if atom(crash_msg) and fn!=-1 then
    mov rax,[#00402670] (crash_msg)       ;#00448AE8: 48:213005 819BFBFF         uv 01 00  1 2987      
    mov r15,h4                            ;#00448AEF: 49:277 0000000000000040    vu 8000 00  1 2987      
    cmp rax,r15                           ;#00448AF9: 4C:071370                  uv 00 8001  1 2988      
    jg #00448BFD                          ;#00448AFC: 017217 FB000000            v  00 00  1 2988      
    mov rcx,[#00402618] (fn)              ;#00448B02: 48:213015 0F9BFBFF         uv 02 00  1 2989      
    cmp rcx,-1                            ;#00448B09: 48:203371 FF               uv 00 02  1 2990 02   
    je #00448BFD                          ;#00448B0D: 017204 EA000000            v  00 00  1 2990      
;  2878                 if atom(crashfile) then
    mov rdi,[#00402B88] (crashfile)       ;#00448B13: 48:213075 6EA0FBFF         uv 80 00  1 2991      
    mov r15,h4                            ;#00448B1A: 49:277 0000000000000040    vu 8000 00  1 2991      
    cmp rdi,r15                           ;#00448B24: 4C:071377                  uv 00 8080  1 2992      
    jl #00448B34                          ;#00448B27: 174 0B                     v  00 00  1 2992      
    cmp byte[rbx+rdi*4-1],#12             ;#00448B29: 200174273 FF 12            u  00 88  2 2993      
    jne #00448BC0                         ;#00448B2E: 017205 8C000000            v  00 00  1 2994      
;  2879                     puts(1,"--> see "&current_dir()&"\\ex.err\n")
    mov rcx,4                             ;#00448B34: 48:307301 04000000         uv 02 00  1 2995      
    mov rdx,83                            ;#00448B3B: 48:307302 53000000         vu 04 00  1 2995      
    call :%opFrame (current_dir)          ;#00448B42: 350 949DFFFF               v  00 00  1 2996      
    mov qword[retaddr],#00448B54          ;#00448B47: 48:307105 20 548B4400      uv 00 20  1 2997      
    jmp #00448C57 (code:current_dir)      ;#00448B4F: 351 03010000               v  00 00  1 2997      
    push rax                              ;#00448B54: 120                        uv 00 01  1 2998      
    mov rsi,[rbp-448] (symtab[736])       ;#00448B55: 48:213265 40FEFFFF         vu 40 20  1 2998      
    mov r15,h4                            ;#00448B5C: 49:277 0000000000000040    uv 8000 00  1 2999      
    cmp rsi,r15                           ;#00448B66: 4C:071376                  uv 00 8040  1 3000 8000   
    jle #00448B7B                         ;#00448B69: 176 10                     v  00 00  1 3000      
    sub qword[rbx+rsi*4-16],1             ;#00448B6B: 48:203154263 F0 01         u  00 48  3 3001      
    jne #00448B7B                         ;#00448B71: 165 08                     v  00 00  1 3003      
    mov rdx,rsi                           ;#00448B73: 48:213326                  uv 04 40  1 3004      
    call #004422DA (:%pDealloc)           ;#00448B76: 350 5F97FFFF               v  00 00  1 3004      
    pop dword[rbp-448] (symtab[736])      ;#00448B7B: 217205 40FEFFFF            np 00 20  3 3005      
    mov rcx,3                             ;#00448B81: 48:307301 03000000         uv 02 00  1 3008      
    push #00448BAB                        ;#00448B88: 150 AB8B4400               vu 00 00  1 3008      
    push qword[#00402DB0]                 ;#00448B8D: 377065 1DA2FBFF            np 00 00  2 3009      
    push qword[rbp-448] (symtab[736])     ;#00448B93: 377265 40FEFFFF            np 00 20  2 3011      
    push qword[#00402DA8]                 ;#00448B99: 377065 09A2FBFF            np 00 00  2 3013      
    lea rax,[rbp-600] (symtab[811])       ;#00448B9F: 48:215205 A8FDFFFF         uv 01 20  1 3015      
    jmp #004402C2 (:%opConcatN)           ;#00448BA6: 351 1777FFFF               v  00 00  1 3015      
    mov rax,1                             ;#00448BAB: 48:307300 01000000         uv 01 00  1 3016      
    mov rdx,[rbp-600] (symtab[811])       ;#00448BB2: 48:213225 A8FDFFFF         vu 04 20  1 3016      
    call #0043E218 (:%opPuts)             ;#00448BB9: 350 5A56FFFF               v  00 00  1 3017      
;  2880 --              elsif not find(crashfile,{"NUL","/dev/null"}) then
    jmp #00448BFD                         ;#00448BBE: 353 3D                     v  00 00  1 3018      
;  2881                 else -- (above not necessary, fn would be -1)
;  2882                     puts(1,"--> see "&crashfile&"\n")
    mov rcx,3                             ;#00448BC0: 48:307301 03000000         uv 02 00  1 3019      
    push #00448BEA                        ;#00448BC7: 150 EA8B4400               vu 00 00  1 3019      
    push qword[#00402600]                 ;#00448BCC: 377065 2E9AFBFF            np 00 00  2 3020      
    push qword[#00402B88] (crashfile)     ;#00448BD2: 377065 B09FFBFF            np 00 00  2 3022      
    push qword[#00402DA8]                 ;#00448BD8: 377065 CAA1FBFF            np 00 00  2 3024      
    lea rax,[rbp-600] (symtab[811])       ;#00448BDE: 48:215205 A8FDFFFF         uv 01 20  1 3026      
    jmp #004402C2 (:%opConcatN)           ;#00448BE5: 351 D876FFFF               v  00 00  1 3026      
    mov rax,1                             ;#00448BEA: 48:307300 01000000         uv 01 00  1 3027      
    mov rdx,[rbp-600] (symtab[811])       ;#00448BF1: 48:213225 A8FDFFFF         vu 04 20  1 3027      
    call #0043E218 (:%opPuts)             ;#00448BF8: 350 1B56FFFF               v  00 00  1 3028      
;  2883                 end if
;  2884             end if
;  2885         end if
;  2886 --DEV if interperting, leave this open and have p.exw/main() dump Warnings() to it:
;  2887         if fn!=-1 then
    mov rax,[#00402618] (fn)              ;#00448BFD: 48:213005 149AFBFF         uv 01 00  1 3029      
    cmp rax,-1                            ;#00448C04: 48:203370 FF               uv 00 01  1 3030 01   
    je #00448C0F                          ;#00448C08: 164 05                     v  00 00  1 3030      
;  2888             close(fn)
    call #0043E8F2 (:%opClose)            ;#00448C0A: 350 E35CFFFF               v  00 00  1 3031      
;  2889         end if
;  2890     end if
;  2891     close(-9)
    mov rax,qword[#00402DB8]              ;#00448C0F: 48:213005 A2A1FBFF         uv 01 00  1 3032      
    call #0043E8F2 (:%opClose)            ;#00448C16: 350 D75CFFFF               v  00 00  1 3032      
;  2892     if not batchmode then
    mov rcx,[#00402678] (batchmode)       ;#00448C1B: 48:213015 569AFBFF         uv 02 00  1 3033      
    test rcx,rcx                          ;#00448C22: 48:205311                  uv 00 02  1 3034 02   
    jne #00448C46                         ;#00448C25: 165 1F                     v  00 00  1 3034      
;  2893 --?batchmode
;  2894         puts(1,"Press Enter...")
    mov rax,1                             ;#00448C27: 48:307300 01000000         uv 01 00  1 3035      
    mov rdx,qword[#00402DC0]              ;#00448C2E: 48:213025 8BA1FBFF         vu 04 00  1 3035      
    call #0043E218 (:%opPuts)             ;#00448C35: 350 DE55FFFF               v  00 00  1 3036      
;  2895         if wait_key() then end if
    lea rdi,[rbp-576] (symtab[804])       ;#00448C3A: 48:215275 C0FDFFFF         uv 80 20  1 3037      
    call #0043E7A5 (:%opWaitKey)          ;#00448C41: 350 5F5BFFFF               v  00 00  1 3037      
;  2896 --      abort(abortcode)
;  2897     end if
;  2898     abort(abortcode)
    mov rax,[rbp-288] (abortcode)         ;#00448C46: 48:213205 E0FEFFFF         uv 01 20  1 3038      
    call #00442B33 (:%opAbort)            ;#00448C4D: 350 E19EFFFF               v  00 00  1 3038      
;  2899 --?batchmode
;  2900     --
;  2901     -- PS if you're looking for puts(1,"\nPress Enter[, or d for diagnostics]..."),
;  2902     --    it is not in here but in pmsgs.e
;  2903     --
    jmp #0044298D (:%opRetf)              ;#00448C52: 351 369DFFFF               v  00 00  1 3039      
;  2904 end procedure
;  2905 
;  2906 --  return batchmode
;  2907 --end function
;  2908 
;  2909 --/*
;  2910 atom diagcb
;  2911     diagcb = call_back(routine_id("diag"))
;  2912 #ilASM{lea edi,[diagcb]
;  2913        call %opCrshRtn} -- save [edi]
;  2914 --*/
;  2915 
;  2916 --DEV./SUG:
;  2917 --/*
;  2918     #ilASM{ :%opErrf    -- use the called from address in the frame
;  2919                 mov esi,[or_ebp*4+12] (except esi is ep2)
;  2920             :%opErr     -- called from address in esi
;  2921           }
;  2922 --*/
;  2923 
;  2924 
;  2925  -- Low Level Integration
;  2926  ------------------------
;  2927 --
;  2928 --  1) Exceptions (via pFEH.e/:!fehDiag). For :!iDiag see next.
;  2929 --      Exceptions are often preferred for performance reasons, for example:
;  2930 --  --?     cmp esi,h4  -- (not always necessary)
;  2931 --  --?     jl :doInt   --   "    "        "
;  2932 --  --?     je :!iDiag  -- (branch misprediction likely!)
;  2933 --        :!opXXe94vhnbaavesi
;  2934 --          cmp byte[ebx+esi*4-1],#12   -- float
;  2935 --          jcc ???     -- (branch misprediction!!)
;  2936 --      Catching an exception at :!opXXe94vhnbaavesi (when esi==h4 aka unassigned) is 
;  2937 --       obviously faster (by which I mean when no exception/fatal error occurs) than
;  2938 --       always performing a conditional jump that is almost never taken, and in many 
;  2939 --       cases the test that it would otherwise need can also be omitted. Further, on
;  2940 --       some processors with limited branch prediction granularity, having jumps so
;  2941 --       close is something that should be avoided if at all possible. However (OTOH)
;  2942 --       it may need additional setup (eg var no in some other register) that negates 
;  2943 --       any such gains/omissions, in which case direct call may be better. While a
;  2944 --       heavily used opcode such as opMove or opJcc can show significant benefits
;  2945 --       from even a single clock saving, if it is easier on the lesser used opcodes
;  2946 --       to setup regs/era etc, take the hit for maintainability sake and go direct.
;  2947 --      Bang labels (:!) are used so that if a particular source (eg pSubse.e) is not
;  2948 --       loaded, a cmp edx,:!opSubse1ipRe92a just quietly resolves to cmp edx,0.
;  2949 --       Likewise we use :!fehDiag (and :!iDiag) so things will compile cleanly under 
;  2950 --       -nodiag (and resolve to jmp 0, ie continue at next instruction, eg an int3).
;  2951 --      It is up to the programmer to ensure all such label names are unique, with
;  2952 --       the compiler throwing errors for any possible clash (unlike hll globals,
;  2953 --       there is no way to use namespaces, so any clashes are always errors).
;  2954 --      Typically the code below (just above ::alset) converts exception addresses to
;  2955 --      exception codes, and diag() figures out ep1/2/era etc as needed for that code.
;  2956 --      However, just as long as it is consistent, it doesn't matter who does it.
;  2957 --
;  2958 --  2) Direct call (via :!iDiag)
;  2959 --      Other times you may as well just call the error handler directly, eg type
;  2960 --       check errors, divide by zero, badretf, etc. There may even be a small gain
;  2961 --       from test/extra-setup/jmp, over extra-setup/no-test-but-catch-exceptions.
;  2962 --       It is obviously easier to setup regs/era near the point of failure rather
;  2963 --       than in here, hidden amongst possibly hundreds of similar blobs of code.
;  2964 --      As above, diag() has to figure out ep1/2/era etc for that code, hence it is
;  2965 --       generally unwise to mix exception and direct handling for the same number.
;  2966 --       However, it is also perfectly reasonable to apply ad-hoc standards, such 
;  2967 --       as ep1 in or_ecx, ep2 in or_edi in direct/exception logic below, before
;  2968 --       invoking diag(), just as long as that also knows the score, and of course
;  2969 --       any such ad-hoc standards would be entirely exception-code-specific.
;  2970 --      Before invoking :!iDiag the exception code should be stored in al, and the
;  2971 --       effective return address in edx, so obviously move eax/edx to other regs 
;  2972 --       first, if they are going to be needed.
;  2973 --      A call :!iDiag should be followed by int3 to avoid confusion under -nodiag.
;  2974 --       (If you don't use -nodiag you can ignore that, if you do, you want an OS
;  2975 --        level fault rather than stumbling blindly on. Try/catch, if it is ever 
;  2976 --        implemented, will handle things before they get anywhere near here.)
;  2977 --
;  2978 --  3) Testing
;  2979 --      If should go without saying that there is absolutely nowhere else in Phix,
;  2980 --       by quite some margin, that needs such diligent and thorough testing as any
;  2981 --       modifications made here. I know there are hundreds of exception codes, and
;  2982 --       hundreds of bang labels, but they all need long and hard thought as to how
;  2983 --       each and every one of them could ever possibly trigger. Without any doubt,
;  2984 --       some of them will already have been missed, so don't make things worse.
;  2985 --      Anything that needs fixing should also get a new entry in test/terror.exw,
;  2986 --       assuming that completely missed the bug and passed with flying colours.
;  2987 --
;  2988 
;  2989 --DEV initD issues? (spotted in passing)
;  2990 constant a32h4 = #40000000,
;  2991          a64h4 = #4000000000000000
;  2992 
;  2993     #ilASM{ jmp :%opRetf
                    jmp #0044298D (:%opRetf)  ;#00442DE8: 351 A0FBFFFF               v  00 00  1   1      
;  2994 
;  2995 --/*
;  2996 procedure :!diagFrame(:%)
;  2997 end procedure -- (for Edita/CtrlQ)
;  2998 --*/
;  2999     :!diagFrame
;  3000 ---------------
;  3001         -- stub provision for pemit2.e, see there for an explanation, which
;  3002         --  will also involve you looking over the :!rbidscb calls above,
;  3003         --  where you will also find the outermost save/restore of [ds+8].
;  3004         [32]
;  3005             mov eax,[ds+8]          -- symtab
;  3006             mov esi,[eax+84]        -- symtab[T_EBP=22]
;  3007             test esi,esi
;  3008             jz @f   -- ?? (pemit2.e was setting rbldrqd too early)
;  3009             -- in case it helps, the next two lines should work just as well:
;  3010 --          mov eax,[symtab]
;  3011 --          mov edx,[ebp+eax*4+84]  -- symtab[T_EBP]
;  3012 --          mov eax,[ebx+edx*4]     -- symtab[T_EBP][1] = ebp4
;  3013 --          mov ecx,[ebx+edx*4+4]   -- symtab[T_EBP][2] = esp4
;  3014             mov esi,[ebx+esi*4+8]   -- symtab[T_EBP][3] = pst4
;  3015 --          shl eax,2
;  3016 --          shl ecx,2
;  3017             shl esi,2
;  3018 --          mov ebp,eax             -- restore ebp
;  3019 --          mov esp,ecx             -- restore esp
;  3020             mov [ds+8],esi          -- restore symtabptr
;  3021           @@:
;  3022             push dword[esp]                         -- (leave the ret addr on stack)
;  3023 --          mov [ds+8],eax
;  3024         [64]
;  3025             mov rax,[ds+8]          -- symtab
                    mov rax,qword[#00402008]  ;#00442DED: 48:213005 14F2FBFF         uv 01 00  1   2      
;  3026             mov rsi,[rax+168]       -- symtab[T_EBP=22]
                    mov rsi,[rax+168]     ;#00442DF4: 48:213260 A8000000         uv 40 01  1   5 01 *01*
;  3027             test rsi,rsi
                    test rsi,rsi          ;#00442DFB: 48:205366                  uv 00 40  1   6 40   
;  3028             jz @f
                    jz #00442E0F          ;#00442DFE: 164 0F                     v  00 00  1   6      
;  3029             mov rsi,[rbx+rsi*4+16]  -- symtab[T_EBP][3] = pst4
                    mov rsi,[rbx+rsi*4+16]  ;#00442E00: 48:213164263 10            uv 40 48  1   7      
;  3030             shl rsi,2
                    shl rsi,2             ;#00442E05: 48:301346 02               u  40 40  1   8      
;  3031             mov [ds+8],rsi          -- restore symtabptr
                    mov dword[#00402008],esi  ;#00442E09: 211065 F9F1FBFF            uv 00 40  1   9 40   
;  3032           @@:
;  3033             push qword[rsp]                         -- (leave the ret addr on stack)
                    push qword[rsp]       ;#00442E0F: 48:377064044               np 00 10  2  10      
;  3034 --          mov [ds+8],rax
;  3035         []
;  3036             call :%opFrame
                    call #004428DB (:%opFrame)  ;#00442E13: 350 C3FAFFFF               v  00 00  1  12      
;  3037             ret
                    ret                   ;#00442E18: 303                        np 00 00  2  13      
;  3038 
;  3039 
;  3040 --/*
;  3041 procedure :%crash_message(:%)
;  3042 end procedure -- (for Edita/CtrlQ)
;  3043 --*/
;  3044     :%pCrashMsg
;  3045 ---------------
;  3046         -- note there is a separate hll crash() routine,
;  3047         --  see builtins\pCrash.e for details
;  3048         [32]
;  3049             -- calling convention
;  3050             --  mov eax,[msg]       -- (should be a string)
;  3051             --  mov esi,msg         -- (var no, if msg can be unassigned)
;  3052             --  call :%pCrashMsg    -- (save eax)
;  3053             mov edx,[crash_msg]
;  3054             cmp eax,h4
;  3055             mov [crash_msg],eax
;  3056             jl @f
;  3057 --DEV exception here mapped to ... (or je)
;  3058                 add dword[ebx+eax*4-8],1
;  3059           @@:
;  3060             cmp edx,h4
;  3061             jle @f
;  3062                 sub dword[ebx+edx*4-8],1
;  3063                 jne @f
;  3064                 push dword[esp]
;  3065                 call :%pDealloc0
;  3066         [64]
;  3067             -- calling convention
;  3068             --  mov rax,[cm]
;  3069             --  mov rsi,cm          -- (var no, if cm can be unassigned)
;  3070             --  call :%pCrashMsg    -- (save eax)
;  3071             mov r15,h4
                    mov r15,h4            ;#00442E19: 49:277 0000000000000040    uv 8000 00  1  15      
;  3072             mov rdx,[crash_msg]
                    mov rdx,[#00402670] (crash_msg)  ;#00442E23: 48:213025 46F8FBFF         vu 04 00  1  15      
;  3073             cmp rax,r15
                    cmp rax,r15           ;#00442E2A: 49:073307                  uv 00 8001  1  16      
;  3074             mov [crash_msg],rax
                    mov [#00402670] (crash_msg),rax  ;#00442E2D: 48:211005 3CF8FBFF         vu 00 01  1  16      
;  3075             jl @f
                    jl #00442E3C          ;#00442E34: 174 06                     v  00 00  1  17      
;  3076 --DEV exception here mapped to ...
;  3077                 add qword[rbx+rax*4-16],1
                        add qword[rbx+rax*4-16],1  ;#00442E36: 48:203104203 F0 01         u  00 09  3  18      
;  3078           @@:
;  3079             cmp rdx,r15
                    cmp rdx,r15           ;#00442E3C: 49:073327                  vu 00 8004  1  20      
;  3080             jle @f
                    jle #00442E52         ;#00442E3F: 176 11                     v  00 00  1  21      
;  3081                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#00442E41: 48:203154223 F0 01         u  00 0C  3  22      
;  3082                 jne @f
                        jne #00442E52     ;#00442E47: 165 09                     v  00 00  1  24      
;  3083                 push qword[rsp]
                        push qword[rsp]   ;#00442E49: 48:377064044               np 00 10  2  25      
;  3084                 call :%pDealloc0
                        call #004422DE (:%pDealloc0)  ;#00442E4D: 350 8CF4FFFF               v  00 00  1  27      
;  3085         []
;  3086           @@:
;  3087             ret
                    ret                   ;#00442E52: 303                        np 00 00  2  28      
;  3088 
;  3089 --DEV dead
;  3090 ----/*
;  3091 --procedure :%pCrash(:%)
;  3092 --end procedure -- (for Edita/CtrlQ)
;  3093 ----*/
;  3094 --  :%pCrash
;  3095 --------------
;  3096 --      -- note there is a separate hll crash(fmt,data={}) routine,
;  3097 --      --  which is not part of the optable.
;  3098 --      [32]
;  3099 --          -- calling convention
;  3100 --          --  mov eax,[msg]           -- (opUnassigned)
;  3101 --          --  call :%pCrash           -- crash(msg)
;  3102 --          add dword[ebx+eax*4-8],1    -- incref
;  3103 --          mov edx,[??]
;  3104 --          mov [crash_msg],eax
;  3105 --          cmp edx,h4
;  3106 --          jle @f
;  3107 --              sub dword[ebx+edx*4-8],1
;  3108 --              jnz @f
;  3109 --              call :%pDealloc
;  3110 --        @@:
;  3111 --      [64]
;  3112 ----DEV
;  3113 ----            cmp eax,h4
;  3114 ----            jl @f
;  3115 ----            cmp dword[ebx+eax*4-12],0
;  3116 ----            je :%pCrash1
;  3117 --      []
;  3118 --          int3
;  3119 --          ret
;  3120 --
;  3121 ----/*
;  3122 --procedure :%pCrash1(:%)
;  3123 --end procedure -- (for Edita/CtrlQ)
;  3124 ----*/
;  3125 --  :%pCrash1   -- dead too
;  3126 ---------------
;  3127 --      [32]
;  3128 --          -- calling convention
;  3129 --          --  mov eax,[fmt]       -- (opUnassigned)
;  3130 --          --  call :%pCrash1      -- crash(eax)
;  3131 ----            call :%pCrashMsg
;  3132 --      []
;  3133 --          int3
;  3134 --          ret
;  3135 
;  3136 --/*
;  3137 procedure :%pCrashFile(:%)
;  3138 end procedure -- (for Edita/CtrlQ)
;  3139 --*/
;  3140     :%pCrashFile
;  3141 ----------------
;  3142         [32]
;  3143             -- calling convention
;  3144             --  mov eax,[file_path]
;  3145             --  mov esi,file_path   -- (var no, if cm can be unassigned)
;  3146             --  call :%pCrashFile   -- crash_file(eax)
;  3147 --DEV
;  3148         []
;  3149             int3
                    int3                  ;#00442E53: 314                        np 00 00 13  30      
;  3150             ret
                    ret                   ;#00442E54: 303                        np 00 00  2  43      
;  3151 
;  3152 --global procedure crash_file(object file_path)
;  3153 ---- Specify a file path name in place of "ex.err" where you want
;  3154 ---- any diagnostic information to be written.
;  3155 ---- May be called multiple times, at the point of a crash the
;  3156 ---- last value passed to this routine is used.
;  3157 ---- A value of "" turns off diagnostics completely.
;  3158 ---- A value of "NUL" or "/dev/null" displays messages to screen
;  3159 ---- but does not create an ex.err file.
;  3160 ---- A value of 0 restores default handling.
;  3161 ---- 
;  3162 --  crashfile = file_path
;  3163 --end procedure
;  3164 
;  3165 --/*
;  3166 procedure :!SetBatchMode(:%)
;  3167 end procedure -- (for Edita/CtrlQ)
;  3168 --*/
;  3169     :!SetBatchMode
;  3170         [32]
;  3171             mov eax,[esp]
;  3172             mov [batchmode],1
;  3173             jmp eax
;  3174         [64]
;  3175             mov rax,[rsp]
                    mov rax,[rsp]         ;#00442E55: 48:213004044               uv 01 10  1  45      
;  3176             mov [batchmode],1
                    mov qword[#00402678] (batchmode),1  ;#00442E59: 48:307005 14F8FBFF 01000000 vu 00 00  1  45      
;  3177             jmp rax
                    jmp rax               ;#00442E64: 377340                     np 00 01  2  46      
;  3178         []
;  3179 
;  3180 --/*
;  3181 procedure :!iDiag(:%)
;  3182 end procedure -- (for Edita/CtrlQ)
;  3183 --*/
;  3184     :!iDiag
;  3185 -----------
;  3186         -- Invoked directly from point of error, al set to msg_id. 
;  3187         -- Instead of ecx,edx being the exception code and address,
;  3188         -- edx contains the era (effective return address), and 
;  3189         -- ep1,ep2 (if used) are error code dependent, but will be 
;  3190         -- in the other registers (so save them all).
;  3191         [32]
;  3192             and eax,#FF         -- error code (1..255)
;  3193             mov [msg_id],eax
;  3194             mov eax,edi         -- (store edi before we trash it!)
;  3195             lea edi,[or_edi]
;  3196             call :%pStoreMint   -- [or_edi]:=edi, as float if rqd
;  3197             mov eax,ecx
;  3198             lea edi,[or_ecx]
;  3199             call :%pStoreMint   -- [or_ecx]:=ecx
;  3200             xor eax,eax         -- edx is not available, unless first moved!
;  3201             lea edi,[or_edx]
;  3202             call :%pStoreMint   -- [or_edx]:=0
;  3203             mov eax,edx         -- era
;  3204             lea edi,[or_era]
;  3205             call :%pStoreMint   -- [or_era]:=edx
;  3206             mov eax,ebp
;  3207             shr eax,2
;  3208             mov [or_ebp],eax    -- [or_ebp]:=ebp/4
;  3209             mov eax,esp
;  3210             lea edi,[or_esp]
;  3211             call :%pStoreMint   -- [or_esp]:=esp
;  3212             mov eax,esi
;  3213             lea edi,[or_esi]
;  3214             call :%pStoreMint   -- [or_esi]:=esi
;  3215 --?
;  3216             xor eax,eax
;  3217             lea edi,[xceptn]
;  3218             call :%pStoreMint   -- [xceptn]:=0
;  3219             lea edi,[xcepta]
;  3220             call :%pStoreMint   -- [xcepta]:=0
;  3221         [64]
;  3222             and rax,#FF
                    and rax,255           ;#00442E66: 48:201340 FF000000         uv 01 01  1  48      
;  3223             mov [msg_id],rax    -- error code (1..255)
                    mov [#00402BA8] (msg_id),rax  ;#00442E6D: 48:211005 34FDFBFF         uv 00 01  1  49 01   
;  3224             mov rax,rdi
                    mov rax,rdi           ;#00442E74: 48:213307                  vu 01 80  1  49      
;  3225             lea rdi,[or_edi]
                    lea rdi,[#00402B28] (or_edi)  ;#00442E77: 48:215075 AAFCFBFF         uv 80 00  1  50      
;  3226             call :%pStoreMint   -- [or_edi]:=rdi, as float if rqd
                    call #0044228A (:%pStoreMint)  ;#00442E7E: 350 07F4FFFF               v  00 00  1  50      
;  3227             mov rax,rcx
                    mov rax,rcx           ;#00442E83: 48:213301                  uv 01 02  1  51      
;  3228             lea rdi,[or_ecx]
                    lea rdi,[#00402B08] (or_ecx)  ;#00442E86: 48:215075 7BFCFBFF         vu 80 00  1  51      
;  3229             call :%pStoreMint   -- [or_ecx]:=rcx
                    call #0044228A (:%pStoreMint)  ;#00442E8D: 350 F8F3FFFF               v  00 00  1  52      
;  3230             xor rax,rax         -- rdx is not available, unless first moved!
                    xor rax,rax           ;#00442E92: 48:061300                  uv 01 01  1  53      
;  3231             lea edi,[or_edx]
                    lea edi,[#00402B18] (or_edx)  ;#00442E95: 215075 7DFCFBFF            vu 80 00  1  53      
;  3232             call :%pStoreMint   -- [or_edx]:=0
                    call #0044228A (:%pStoreMint)  ;#00442E9B: 350 EAF3FFFF               v  00 00  1  54      
;  3233             mov rax,rdx         -- era
                    mov rax,rdx           ;#00442EA0: 48:213302                  uv 01 04  1  55      
;  3234             lea rdi,[or_era]
                    lea rdi,[#00402B10] (or_era)  ;#00442EA3: 48:215075 66FCFBFF         vu 80 00  1  55      
;  3235             call :%pStoreMint   -- [or_era]:=rdx
                    call #0044228A (:%pStoreMint)  ;#00442EAA: 350 DBF3FFFF               v  00 00  1  56      
;  3236             mov rax,rbp
                    mov rax,rbp           ;#00442EAF: 48:213305                  uv 01 20  1  57      
;  3237             shr rax,2
                    shr rax,2             ;#00442EB2: 48:301350 02               u  01 01  1  58      
;  3238             mov [or_ebp],rax    -- [or_ebp]:=rbp/4
                    mov [#00402AE8] (or_ebp),rax  ;#00442EB6: 48:211005 2BFCFBFF         uv 00 01  1  59 01   
;  3239             mov rax,rsp
                    mov rax,rsp           ;#00442EBD: 48:213304                  vu 01 10  1  59      
;  3240             lea rdi,[or_esp]
                    lea rdi,[#00402AF0] (or_esp)  ;#00442EC0: 48:215075 29FCFBFF         uv 80 00  1  60      
;  3241             call :%pStoreMint   -- [or_esp]:=rsp
                    call #0044228A (:%pStoreMint)  ;#00442EC7: 350 BEF3FFFF               v  00 00  1  60      
;  3242             mov rax,rsi
                    mov rax,rsi           ;#00442ECC: 48:213306                  uv 01 40  1  61      
;  3243             lea rdi,[or_esi]
                    lea rdi,[#00402B20] (or_esi)  ;#00442ECF: 48:215075 4AFCFBFF         vu 80 00  1  61      
;  3244             call :%pStoreMint   -- [or_esi]:=rsi
                    call #0044228A (:%pStoreMint)  ;#00442ED6: 350 AFF3FFFF               v  00 00  1  62      
;  3245 --?
;  3246             xor rax,rax
                    xor rax,rax           ;#00442EDB: 48:061300                  uv 01 01  1  63      
;  3247             lea rdi,[xceptn]
                    lea rdi,[#00402AF8] (xceptn)  ;#00442EDE: 48:215075 13FCFBFF         vu 80 00  1  63      
;  3248             call :%pStoreMint   -- [xceptn]:=0
                    call #0044228A (:%pStoreMint)  ;#00442EE5: 350 A0F3FFFF               v  00 00  1  64      
;  3249             lea rdi,[xcepta]
                    lea rdi,[#00402B00] (xcepta)  ;#00442EEA: 48:215075 0FFCFBFF         uv 80 00  1  65      
;  3250             call :%pStoreMint   -- [xcepta]:=0
                    call #0044228A (:%pStoreMint)  ;#00442EF1: 350 94F3FFFF               v  00 00  1  65      
;  3251         []
;  3252             cmp [diaglooping],0
                    cmp qword[#00402B90] (diaglooping),0  ;#00442EF6: 48:203075 92FCFBFF 00      u  00 00  2  66      
;  3253             je @f
                    je #004432D8          ;#00442EFE: 017204 D4030000            v  00 00  1  67      
;  3254                 [32]
;  3255                     mov edi,[ecode]             -- "diag looping, error code is "
;  3256                     call :%puts1
;  3257                     mov edx,[msg_id]
;  3258                     push 0
;  3259 --                  call :%puthex32a
;  3260                     call :%putsint
;  3261                     mov edi,[erais]             -- ", erais #"
;  3262                     call :%puts1
;  3263                     mov edx,[or_era]
;  3264                     push 1
;  3265                     call :%puthex32
;  3266                     mov eax,1
;  3267                 [64]
;  3268                     mov rdi,[ecode]             -- "diag looping, error code is "
                            mov rdi,[#00402B98] (ecode)  ;#00442F04: 48:213075 8DFCFBFF         uv 80 00  1  68      
;  3269                     call :%puts1
                            call #00442B92 (:%puts1)  ;#00442F0B: 350 82FCFFFF               v  00 00  1  68      
;  3270                     mov rdx,[msg_id]
                            mov rdx,[#00402BA8] (msg_id)  ;#00442F10: 48:213025 91FCFBFF         uv 04 00  1  69      
;  3271                     push 0
                            push 0        ;#00442F17: 152 00                     vu 00 00  1  69      
;  3272 --                  call :%puthex32a
;  3273                     call :%putsint
                            call #00442CA2 (:%putsint)  ;#00442F19: 350 84FDFFFF               v  00 00  1  70      
;  3274                     mov rdi,[erais]             -- ", erais #"
                            mov rdi,[#00402BA0] (erais)  ;#00442F1E: 48:213075 7BFCFBFF         uv 80 00  1  71      
;  3275                     call :%puts1
                            call #00442B92 (:%puts1)  ;#00442F25: 350 68FCFFFF               v  00 00  1  71      
;  3276                     mov rdx,[or_era]
                            mov rdx,[#00402B10] (or_era)  ;#00442F2A: 48:213025 DFFBFBFF         uv 04 00  1  72      
;  3277                     push 1
                            push 1        ;#00442F31: 152 01                     vu 00 00  1  72      
;  3278                     call :%puthex32
                            call #00442BFC (:%puthex32)  ;#00442F33: 350 C4FCFFFF               v  00 00  1  73      
;  3279                     mov rax,1
                            mov rax,1     ;#00442F38: 48:307300 01000000         uv 01 00  1  74      
;  3280                 []
;  3281 --                  add [diaglooping],1
;  3282 --                  cmp [diaglooping],2
;  3283                     mov ecx,[diaglooping]
                            mov ecx,[#00402B90] (diaglooping)  ;#00442F3F: 213015 4BFCFBFF            vu 02 00  1  74      
;  3284                     add ecx,1
                            add ecx,1     ;#00442F45: 203301 01                  uv 02 02  1  75      
;  3285                     mov [diaglooping],ecx
                            mov [#00402B90] (diaglooping),ecx  ;#00442F48: 211015 42FCFBFF            uv 00 02  1  76 02   
;  3286                     cmp ecx,2
                            cmp ecx,2     ;#00442F4E: 203371 02                  vu 00 02  1  76      
;  3287                     je @f
                            je #004432D8  ;#00442F51: 017204 81030000            v  00 00  1  77      
;  3288                         jmp :%opAbort
                                jmp #00442B33 (:%opAbort)  ;#00442F57: 351 D7FBFFFF               v  00 00  1  78      
;  3289           @@:               
;  3290             jmp :alset
                    jmp #004432D8         ;#00442F5C: 351 77030000               v  00 00  1  79      
;  3291 
;  3292 
;  3293     ::DiagLooping -- (because jne does not support memory operand)
;  3294         [32]
;  3295             jmp dword[esp]
;  3296         [64]
;  3297             jmp qword[rsp]
                    jmp qword[rsp]        ;#00442F61: 377044044                  np 00 10  2  80      
;  3298         []
;  3299 
;  3300 --/*
;  3301 procedure :!fehDiag(:%)
;  3302 end procedure -- (for Edita/CtrlQ)
;  3303 --*/
;  3304     :!fehDiag
;  3305 ----------
;  3306             -- from pFEH.e (and nowhere else), msg_id not yet known
;  3307             -- Aside: the context record offsets really belong in pFEH.e, but
;  3308             --        the (local hll variables) or_ecx, etc belong in here.
;  3309             cmp [diaglooping],2
                    cmp qword[#00402B90] (diaglooping),2  ;#00442F64: 48:203075 24FCFBFF 02      u  00 00  2  82      
;  3310             jge :DiagLooping
                    jge #00442F61         ;#00442F6C: 175 F3                     v  00 00  1  83      
;  3311         [PE32]
;  3312             --  esi is context record (an annoted copy can be found in pFEH.e)
;  3313             --  edx is exception address
;  3314             --  ecx is exception code
;  3315             -- (ebp already reset, and ebx zeroed)
;  3316             mov eax,ecx         -- exception code
;  3317             lea edi,[xceptn]
;  3318             call :%pStoreMint
;  3319             mov eax,edx         -- exception address
;  3320             lea edi,[xcepta]
;  3321             call :%pStoreMint
;  3322             lea edi,[or_era]    -- (may get replaced)
;  3323             call :%pStoreMint
;  3324             mov eax,[esi+172]   -- ecx
;  3325             lea edi,[or_ecx]
;  3326             call :%pStoreMint
;  3327             mov eax,[esi+168]   -- edx
;  3328             lea edi,[or_edx]
;  3329             call :%pStoreMint
;  3330             mov eax,[esi+156]   -- edi
;  3331             lea edi,[or_edi]
;  3332             call :%pStoreMint
;  3333             mov eax,[esi+180]   -- ebp
;  3334             shr eax,2
;  3335             mov [or_ebp],eax
;  3336             mov eax,[esi+196]   -- esp
;  3337             lea edi,[or_esp]
;  3338             call :%pStoreMint
;  3339             mov eax,[esi+160]   -- esi
;  3340             lea edi,[or_esi]
;  3341             call :%pStoreMint
;  3342 --156 or_edi            dd ?
;  3343 --160 or_esi            dd ?
;  3344 --164 or_ebx            dd ?
;  3345 --168 or_edx            dd ?
;  3346 --172 or_ecx            dd ?
;  3347 --176 or_eax            dd ?
;  3348 --180 or_ebp            dd ?
;  3349 --184 or_eip            dd ?
;  3350 --196 or_esp            dd ?
;  3351 --          mov esp,[esi+196]   -- (restore) [already done in pFEH.e]
;  3352 --          mov ebp,[esi+180]   -- (restore) [already done in pFEH.e]
;  3353             xor eax,eax
;  3354         [PE64]
;  3355             --  rsi is context record (an annoted copy can be found in pFEH.e)
;  3356             --  rdx is exception address
;  3357             --  rcx is exception code
;  3358             -- (rbp already reset, and rbx zeroed)
;  3359             mov rax,rcx         -- exception code
                    mov rax,rcx           ;#00442F6E: 48:213301                  uv 01 02  1  84      
;  3360             lea rdi,[xceptn]
                    lea rdi,[#00402AF8] (xceptn)  ;#00442F71: 48:215075 80FBFBFF         vu 80 00  1  84      
;  3361             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00442F78: 350 0DF3FFFF               v  00 00  1  85      
;  3362             mov rax,rdx         -- exception address
                    mov rax,rdx           ;#00442F7D: 48:213302                  uv 01 04  1  86      
;  3363             lea rdi,[xcepta]
                    lea rdi,[#00402B00] (xcepta)  ;#00442F80: 48:215075 79FBFBFF         vu 80 00  1  86      
;  3364             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00442F87: 350 FEF2FFFF               v  00 00  1  87      
;  3365             lea rdi,[or_era]    -- (may get replaced)
                    lea rdi,[#00402B10] (or_era)  ;#00442F8C: 48:215075 7DFBFBFF         uv 80 00  1  88      
;  3366             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00442F93: 350 F2F2FFFF               v  00 00  1  88      
;  3367             mov rax,[rsi+128]   -- rcx
                    mov rax,[rsi+128]     ;#00442F98: 48:213206 80000000         uv 01 40  1  89      
;  3368             lea rdi,[or_ecx]
                    lea rdi,[#00402B08] (or_ecx)  ;#00442F9F: 48:215075 62FBFBFF         vu 80 00  1  89      
;  3369             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00442FA6: 350 DFF2FFFF               v  00 00  1  90      
;  3370             mov rax,[rsi+136]   -- rdx
                    mov rax,[rsi+136]     ;#00442FAB: 48:213206 88000000         uv 01 40  1  91      
;  3371             lea rdi,[or_edx]
                    lea rdi,[#00402B18] (or_edx)  ;#00442FB2: 48:215075 5FFBFBFF         vu 80 00  1  91      
;  3372             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00442FB9: 350 CCF2FFFF               v  00 00  1  92      
;  3373 --/*
;  3374 120 DWORD64 Rax;
;  3375 128 DWORD64 Rcx;
;  3376 136 DWORD64 Rdx;
;  3377 144 DWORD64 Rbx;
;  3378 152 DWORD64 Rsp;
;  3379 160 DWORD64 Rbp;
;  3380 168 DWORD64 Rsi;
;  3381 176 DWORD64 Rdi;
;  3382 184 DWORD64 R8;
;  3383 192 DWORD64 R9;
;  3384 200 DWORD64 R10;
;  3385 208 DWORD64 R11;
;  3386 216 DWORD64 R12;
;  3387 224 DWORD64 R13;
;  3388 232 DWORD64 R14;
;  3389 240 DWORD64 R15;
;  3390 248 DWORD64 Rip;
;  3391 --*/
;  3392             mov rax,[rsi+176]   -- rdi
                    mov rax,[rsi+176]     ;#00442FBE: 48:213206 B0000000         uv 01 40  1  93      
;  3393             lea rdi,[or_edi]
                    lea rdi,[#00402B28] (or_edi)  ;#00442FC5: 48:215075 5CFBFBFF         vu 80 00  1  93      
;  3394             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00442FCC: 350 B9F2FFFF               v  00 00  1  94      
;  3395             mov rax,[rsi+160]   -- ebp
                    mov rax,[rsi+160]     ;#00442FD1: 48:213206 A0000000         uv 01 40  1  95      
;  3396             shr rax,2
                    shr rax,2             ;#00442FD8: 48:301350 02               u  01 01  1  96      
;  3397             mov [or_ebp],rax
                    mov [#00402AE8] (or_ebp),rax  ;#00442FDC: 48:211005 05FBFBFF         uv 00 01  1  97 01   
;  3398             mov rax,[rsi+152]   -- esp
                    mov rax,[rsi+152]     ;#00442FE3: 48:213206 98000000         vu 01 40  1  97      
;  3399             lea rdi,[or_esp]
                    lea rdi,[#00402AF0] (or_esp)  ;#00442FEA: 48:215075 FFFAFBFF         uv 80 00  1  98      
;  3400             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00442FF1: 350 94F2FFFF               v  00 00  1  98      
;  3401             mov rax,[rsi+168]   -- esi
                    mov rax,[rsi+168]     ;#00442FF6: 48:213206 A8000000         uv 01 40  1  99      
;  3402             lea rdi,[or_esi]
                    lea rdi,[#00402B20] (or_esi)  ;#00442FFD: 48:215075 1CFBFBFF         vu 80 00  1  99      
;  3403             call :%pStoreMint
                    call #0044228A (:%pStoreMint)  ;#00443004: 350 81F2FFFF               v  00 00  1 100      
;  3404 --          mov rsp,[esi+152]   -- (already done in pFEH.e)
;  3405 --          mov rbp,[rsi+160]   -- (already done in pFEH.e)
;  3406             xor rax,rax
                    xor rax,rax           ;#00443009: 48:061300                  uv 01 01  1 101      
;  3407             mov r15,h4
                    mov r15,h4            ;#0044300C: 49:277 0000000000000040    vu 8000 00  1 101      
;  3408         [ELF32]
;  3409             pop al
;  3410         [ELF64]
;  3411             pop al
;  3412         []
;  3413 
;  3414 --/*
;  3415 procedure AddressMapping()
;  3416 end procedure -- (for Edita/CtrlQ)
;  3417 --*/
;  3418  -- Address Mapping
;  3419  ------------------
;  3420             -- (all label addresses are expected to be <1G)
;  3421             -- (DEV factor out common code once it all works,
;  3422             --      and once terror.exw is up and running.)
;  3423             mov al,1
                    mov al,1              ;#00443016: 260 01                     uv 01 00  1 102      
;  3424 --          mov al,2    -- now via :!iDiag
;  3425 --          cmp edx,:%e02atdb0
;  3426 --          je :alset
;  3427             cmp edx,:!opJnotxe92b
                    cmp edx,#0043B2AE     ;#00443018: 201372 AEB24300            vu 00 04  1 102      
;  3428             jne @f
                    jne #0044303D         ;#0044301E: 165 1D                     v  00 00  1 103      
;  3429               [32]
;  3430                 mov eax,[esp+4]
;  3431               [64]
;  3432                 mov rax,[rsp+8]
                        mov rax,[rsp+8]   ;#00443020: 48:213104044 08            uv 01 10  1 104      
;  3433               []
;  3434                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#00443025: 215075 E5FAFBFF            vu 80 00  1 104      
;  3435                 sub eax,1
                        sub eax,1         ;#0044302B: 203350 01                  uv 01 01  1 105      
;  3436                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#0044302E: 350 57F2FFFF               v  00 00  1 105      
;  3437                 mov eax,106         -- e106ioob(edi,edx) or e94vhnbaav(ecx)
                        mov eax,106       ;#00443033: 270 6A000000               uv 01 00  1 106      
;  3438                 jmp :setal
                        jmp #004432CA     ;#00443038: 351 8D020000               v  00 00  1 106      
;  3439           @@:
;  3440             cmp edx,:!Jccp2Intp3Ref
                    cmp edx,#0043FAD3     ;#0044303D: 201372 D3FA4300            uv 00 04  1 107      
;  3441             jne @f
                    jne #00443062         ;#00443043: 165 1D                     v  00 00  1 107      
;  3442               [32]
;  3443                 mov eax,[esp+4]
;  3444               [64]
;  3445                 mov rax,[rsp+8]
                        mov rax,[rsp+8]   ;#00443045: 48:213104044 08            uv 01 10  1 108      
;  3446               []
;  3447                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#0044304A: 215075 C0FAFBFF            vu 80 00  1 108      
;  3448                 sub eax,1
                        sub eax,1         ;#00443050: 203350 01                  uv 01 01  1 109      
;  3449                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#00443053: 350 32F2FFFF               v  00 00  1 109      
;  3450                 mov eax,92          -- e92vhnbaav(esi)
                        mov eax,92        ;#00443058: 270 5C000000               uv 01 00  1 110      
;  3451                 jmp :setal
                        jmp #004432CA     ;#0044305D: 351 68020000               v  00 00  1 110      
;  3452           @@:
;  3453             cmp edx,:!opXore92a
                    cmp edx,#0043F2E3     ;#00443062: 201372 E3F24300            uv 00 04  1 111      
;  3454             jne @f
                    jne #00443087         ;#00443068: 165 1D                     v  00 00  1 111      
;  3455               [32]
;  3456                 mov eax,[esp+4]
;  3457               [64]
;  3458                 mov rax,[rsp+8]
                        mov rax,[rsp+8]   ;#0044306A: 48:213104044 08            uv 01 10  1 112      
;  3459               []
;  3460                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#0044306F: 215075 9BFAFBFF            vu 80 00  1 112      
;  3461                 sub eax,1
                        sub eax,1         ;#00443075: 203350 01                  uv 01 01  1 113      
;  3462                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#00443078: 350 0DF2FFFF               v  00 00  1 113      
;  3463                 mov eax,91          -- e91vhnbaav(ecx) (ecx is var no)
                        mov eax,91        ;#0044307D: 270 5B000000               uv 01 00  1 114      
;  3464                 jmp :setal
                        jmp #004432CA     ;#00443082: 351 43020000               v  00 00  1 114      
;  3465           @@:
;  3466             cmp edx,:%opPpndSA
                    cmp edx,#0043FC32     ;#00443087: 201372 32FC4300            uv 00 04  1 115      
;  3467             jne @f
                    jne #004430AC         ;#0044308D: 165 1D                     v  00 00  1 115      
;  3468               [32]
;  3469                 mov eax,[esp+20]
;  3470               [64]
;  3471                 mov rax,[rsp+40]
                        mov rax,[rsp+40]  ;#0044308F: 48:213104044 28            uv 01 10  1 116      
;  3472               []
;  3473                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#00443094: 215075 76FAFBFF            vu 80 00  1 116      
;  3474                 sub eax,1
                        sub eax,1         ;#0044309A: 203350 01                  uv 01 01  1 117      
;  3475                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#0044309D: 350 E8F1FFFF               v  00 00  1 117      
;  3476                 mov eax,93          -- e93vhnbaav(edi) (edi is var no)
                        mov eax,93        ;#004430A2: 270 5D000000               uv 01 00  1 118      
;  3477                 jmp :setal
                        jmp #004432CA     ;#004430A7: 351 1E020000               v  00 00  1 118      
;  3478           @@:
;  3479 
;  3480             cmp edx,:!opLene36or92
                    cmp edx,#0043F297     ;#004430AC: 201372 97F24300            uv 00 04  1 119      
;  3481             jne @f
                    jne #004430E6         ;#004430B2: 165 32                     v  00 00  1 119      
;  3482               [32]
;  3483                 mov edi,[a32h4]
;  3484                 mov eax,[or_esi]
;  3485               [64]
;  3486                 mov rdi,[a64h4]
                        mov rdi,[#00402C08] (a64h4)  ;#004430B4: 48:213075 4DFBFBFF         uv 80 00  1 120      
;  3487                 mov rax,[or_esi]
                        mov rax,[#00402B20] (or_esi)  ;#004430BB: 48:213005 5EFAFBFF         vu 01 00  1 120      
;  3488               []
;  3489                 call :%opJccE
                        call #0043FAF6 (:%opJccE)  ;#004430C2: 350 2FCAFFFF               v  00 00  1 121      
;  3490                 je :e94vhnbaavedx
                        je #0044312B      ;#004430C7: 164 62                     v  00 00  1 122      
;  3491               [32]
;  3492                 mov eax,[esp+4]
;  3493               [64]
;  3494                 mov rax,[rsp+8]
                        mov rax,[rsp+8]   ;#004430C9: 48:213104044 08            uv 01 10  1 123      
;  3495               []
;  3496                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#004430CE: 215075 3CFAFBFF            vu 80 00  1 123      
;  3497                 sub eax,1
                        sub eax,1         ;#004430D4: 203350 01                  uv 01 01  1 124      
;  3498                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#004430D7: 350 AEF1FFFF               v  00 00  1 124      
;  3499                 mov eax,36          -- e36loaaind
                        mov eax,36        ;#004430DC: 270 24000000               uv 01 00  1 125      
;  3500                 jmp :setal
                        jmp #004432CA     ;#004430E1: 351 E4010000               v  00 00  1 125      
;  3501           @@:
;  3502             cmp edx,:!pSubsse94
                    cmp edx,#00440F21     ;#004430E6: 201372 210F4400            uv 00 04  1 126      
;  3503             jne @f
                    jne #004430FB         ;#004430EC: 165 0D                     v  00 00  1 126      
;  3504               [32]
;  3505                 mov ecx,[or_ecx]
;  3506 --              shl ecx,2
;  3507 --              add esp,ecx
;  3508                 lea esp,[esp+ecx*4+4]
;  3509               [64]
;  3510                 mov rcx,[or_ecx]
                        mov rcx,[#00402B08] (or_ecx)  ;#004430EE: 48:213015 13FAFBFF         uv 02 00  1 127      
;  3511                 lea rsp,[rsp+rcx*8*8]
                        lea rsp,[rsp+rcx*8]  ;#004430F5: 48:215044314               uv 10 12  1 130 02 *02*
;  3512               []
;  3513                 jmp :e94vhnbaavedx
                        jmp #0044312B     ;#004430F9: 353 30                     v  00 00  1 130      
;  3514           @@:
;  3515             cmp edx,:!opSubse1ipRe92a
                    cmp edx,0             ;#004430FB: 201372 00000000            uv 00 04  1 131      
;  3516             je :e94vhnbaavedx
                    je #0044312B          ;#00443101: 164 28                     v  00 00  1 131      
;  3517             cmp edx,:!Jccp2NotInt
                    cmp edx,#0043FAA1     ;#00443103: 201372 A1FA4300            uv 00 04  1 132      
;  3518             je :e94vhnbaavedx
                    je #0044312B          ;#00443109: 164 20                     v  00 00  1 132      
;  3519             cmp edx,:!Jife92
                    cmp edx,#0043FB40     ;#0044310B: 201372 40FB4300            uv 00 04  1 133      
;  3520             je :e94vhnbaavedx
                    je #0044312B          ;#00443111: 164 18                     v  00 00  1 133      
;  3521             cmp edx,:!opJnotxe92a
                    cmp edx,#0043B296     ;#00443113: 201372 96B24300            uv 00 04  1 134      
;  3522             je :e94vhnbaavedx
                    je #0044312B          ;#00443119: 164 10                     v  00 00  1 134      
;  3523             cmp edx,:!opXore92b
                    cmp edx,#0043F305     ;#0044311B: 201372 05F34300            uv 00 04  1 135      
;  3524             je :e94vhnbaavedx
                    je #0044312B          ;#00443121: 164 08                     v  00 00  1 135      
;  3525             cmp edx,:%pSubsss
                    cmp edx,#00441212     ;#00443123: 201372 12124400            uv 00 04  1 136      
;  3526             jne @f
                    jne #00443148         ;#00443129: 165 1D                     v  00 00  1 136      
;  3527           ::e94vhnbaavedx
;  3528               [32]
;  3529                 mov eax,[esp+4]
;  3530               [64]
;  3531                 mov rax,[rsp+8]
                        mov rax,[rsp+8]   ;#0044312B: 48:213104044 08            uv 01 10  1 137      
;  3532               []
;  3533                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#00443130: 215075 DAF9FBFF            vu 80 00  1 137      
;  3534                 sub eax,1
                        sub eax,1         ;#00443136: 203350 01                  uv 01 01  1 138      
;  3535                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#00443139: 350 4CF1FFFF               v  00 00  1 138      
;  3536                 mov eax,94          -- e94vhnbaav(edx)
                        mov eax,94        ;#0044313E: 270 5E000000               uv 01 00  1 139      
;  3537                 jmp :setal
                        jmp #004432CA     ;#00443143: 351 82010000               v  00 00  1 139      
;  3538           @@:
;  3539 --/*
;  3540 --;  2352           mov ecx,[esp+8]         -- pTCB/4
;  3541 --                  mov [edi+ecx*4+20],esi  ;#004D2FEE: 211164217 14               uv 00 C2  1 651      
;  3542 --
;  3543 --;  2378           mov rcx,[rsp+64]        -- pTCB/4
;  3544 --;  2391           mov [rcx*4+rdi+32],rsi  -- pTCB[idx]:=this.pNext
;  3545 --
;  3546 --;  1876       mov eax,[esi*4+edi+20]  -- pTCB.pFree[idx]
;  3547 --;  1878       jnz :!blockfound
;  3548 --*/
;  3549             cmp edx,:!blockfound
                    cmp edx,#00441F45     ;#00443148: 201372 451F4400            uv 00 04  1 140      
;  3550             je :e32hcblockfound
                    je #00443160          ;#0044314E: 164 10                     v  00 00  1 140      
;  3551 --cmp edx,:!blockfound4
;  3552 --je :e32hcblockfound
;  3553             cmp edx,:!blockfoundC0000005
                    cmp edx,#00441F60     ;#00443150: 201372 601F4400            uv 00 04  1 141      
;  3554             je :e32hcblockfound
                    je #00443160          ;#00443156: 164 08                     v  00 00  1 141      
;  3555             cmp edx,:!bf_midchain
                    cmp edx,#00441F75     ;#00443158: 201372 751F4400            uv 00 04  1 142      
;  3556             jne @f
                    jne #0044317D         ;#0044315E: 165 1D                     v  00 00  1 142      
;  3557           ::e32hcblockfound
;  3558                 -- memory corruption problem
;  3559               [32]
;  3560 --              mov eax,[esp+12]    -- return address (of :%pGetPool call)
;  3561 --              mov eax,[esp+12]
;  3562                 mov eax,[esp+16]
;  3563               [64]
;  3564 --              mov rax,[rsp+8*11]  -- return address (of :%pGetPool call)
;  3565 --              mov rax,[rsp+80]
;  3566                 mov rax,[rsp+88]
                        mov rax,[rsp+88]  ;#00443160: 48:213104044 58            uv 01 10  1 143      
;  3567               []
;  3568 --              cmp edx,
;  3569 --pAllocStr
;  3570 --pAllocSeq
;  3571 --pStoreFlt
;  3572 --pAlloc
;  3573 --newVSB
;  3574 --allocate()
;  3575                 lea edi,[or_edi]
                        lea edi,[#00402B28] (or_edi)  ;#00443165: 215075 BDF9FBFF            vu 80 00  1 143      
;  3576 --              lea edi,[or_era]
;  3577                 sub eax,1
                        sub eax,1         ;#0044316B: 203350 01                  uv 01 01  1 144      
;  3578                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#0044316E: 350 17F1FFFF               v  00 00  1 144      
;  3579 --              mov [or_ecx],1
;  3580                 mov eax,32          -- e32hc(era,edi)
                        mov eax,32        ;#00443173: 270 20000000               uv 01 00  1 145      
;  3581                 jmp :setal
                        jmp #004432CA     ;#00443178: 351 4D010000               v  00 00  1 145      
;  3582           @@:
;  3583             cmp edx,:!GetPoolnotTCBa
                    cmp edx,#00441BFB     ;#0044317D: 201372 FB1B4400            uv 00 04  1 146      
;  3584             jne @f
                    jne #004431A2         ;#00443183: 165 1D                     v  00 00  1 146      
;  3585               [32]
;  3586 --              mov eax,[esp+8]
;  3587                 mov eax,[esp+12]
;  3588               [64]
;  3589 --              mov rax,[rsp+80]
;  3590                 mov rax,[rsp+88]
                        mov rax,[rsp+88]  ;#00443185: 48:213104044 58            uv 01 10  1 147      
;  3591               []
;  3592 --              lea edi,[or_era]
;  3593                 lea edi,[or_edi]
                        lea edi,[#00402B28] (or_edi)  ;#0044318A: 215075 98F9FBFF            vu 80 00  1 147      
;  3594                 sub eax,1
                        sub eax,1         ;#00443190: 203350 01                  uv 01 01  1 148      
;  3595                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#00443193: 350 F2F0FFFF               v  00 00  1 148      
;  3596                 mov eax,32          -- e32hc(era,edi)
                        mov eax,32        ;#00443198: 270 20000000               uv 01 00  1 149      
;  3597                 jmp :setal
                        jmp #004432CA     ;#0044319D: 351 28010000               v  00 00  1 149      
;  3598           @@:
;  3599             cmp edx,:!FreePoole32a
                    cmp edx,#00442011     ;#004431A2: 201372 11204400            uv 00 04  1 150      
;  3600             jne @f
                    jne #004431C7         ;#004431A8: 165 1D                     v  00 00  1 150      
;  3601               [32]
;  3602                 mov eax,[esp+4]
;  3603               [64]
;  3604                 mov rax,[rsp+8]
                        mov rax,[rsp+8]   ;#004431AA: 48:213104044 08            uv 01 10  1 151      
;  3605               []
;  3606                 lea edi,[or_edi]
                        lea edi,[#00402B28] (or_edi)  ;#004431AF: 215075 73F9FBFF            vu 80 00  1 151      
;  3607                 sub eax,1
                        sub eax,1         ;#004431B5: 203350 01                  uv 01 01  1 152      
;  3608                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#004431B8: 350 CDF0FFFF               v  00 00  1 152      
;  3609                 mov eax,32          -- e32hc(era,edi)
                        mov eax,32        ;#004431BD: 270 20000000               uv 01 00  1 153      
;  3610                 jmp :setal
                        jmp #004432CA     ;#004431C2: 351 03010000               v  00 00  1 153      
;  3611           @@:
;  3612             [32]
;  3613             cmp edx,:!opPeek1xMLE
;  3614             je :e99atom
;  3615             cmp edx,:!opPeek2xMLE
;  3616             je :e99atom
;  3617             cmp edx,:!opPeek4xMLE
;  3618             je :e99atom
;  3619             cmp edx,:!opPeek8xsMLE
;  3620             je :e99atom
;  3621             cmp edx,:!opPeek8xuMLE
;  3622             jne @f
;  3623               ::e99atom
;  3624 --              mov eax,[esp+8]
;  3625                 mov eax,[esp+12]
;  3626                 lea edi,[or_era]
;  3627                 sub eax,1
;  3628                 call :%pStoreMint
;  3629                 mov eax,99          -- e99ipma
;  3630                 jmp :setal
;  3631           @@:
;  3632             cmp edx,:!opPeek1xsMLE
;  3633             je :e99seq
;  3634             cmp edx,:!opPeek2xsMLE
;  3635             je :e99seq
;  3636             cmp edx,:!opPeek4xsMLE
;  3637             je :e99seq
;  3638             cmp edx,:!opPeek8xsMLE2
;  3639             je :e99seq
;  3640             cmp edx,:!opPeek8xuMLE2
;  3641             jne @f
;  3642               ::e99seq
;  3643 --              mov eax,[esp+16]
;  3644                 mov eax,[esp+20]
;  3645                 lea edi,[or_era]
;  3646                 sub eax,1
;  3647                 call :%pStoreMint
;  3648                 mov eax,99          -- e99ipma
;  3649                 jmp :setal
;  3650             [64]
;  3651             cmp edx,:!opPeek1xMLE64
                    cmp edx,#0043EDA9     ;#004431C7: 201372 A9ED4300            uv 00 04  1 154      
;  3652             je :e99atom
                    je #004431EF          ;#004431CD: 164 20                     v  00 00  1 154      
;  3653             cmp edx,:!opPeek2xMLE64
                    cmp edx,#0043EDC6     ;#004431CF: 201372 C6ED4300            uv 00 04  1 155      
;  3654             je :e99atom
                    je #004431EF          ;#004431D5: 164 18                     v  00 00  1 155      
;  3655             cmp edx,:!opPeek4xMLE64
                    cmp edx,#0043EDE2     ;#004431D7: 201372 E2ED4300            uv 00 04  1 156      
;  3656             je :e99atom
                    je #004431EF          ;#004431DD: 164 10                     v  00 00  1 156      
;  3657             cmp edx,:!opPeek8xsMLE64
                    cmp edx,0             ;#004431DF: 201372 00000000            uv 00 04  1 157      
;  3658             je :e99atom
                    je #004431EF          ;#004431E5: 164 08                     v  00 00  1 157      
;  3659             cmp edx,:!opPeek8xuMLE64
                    cmp edx,0             ;#004431E7: 201372 00000000            uv 00 04  1 158      
;  3660             jne @f
                    jne #0044320D         ;#004431ED: 165 1E                     v  00 00  1 158      
;  3661               ::e99atom
;  3662 --              mov rax,[rsp+16]
;  3663                 mov rax,[rsp+24]
                        mov rax,[rsp+24]  ;#004431EF: 48:213104044 18            uv 01 10  1 159      
;  3664                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#004431F4: 215075 16F9FBFF            vu 80 00  1 159      
;  3665                 sub rax,1
                        sub rax,1         ;#004431FA: 48:203350 01               uv 01 01  1 160      
;  3666                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#004431FE: 350 87F0FFFF               v  00 00  1 160      
;  3667                 mov eax,99          -- e99ipma
                        mov eax,99        ;#00443203: 270 63000000               uv 01 00  1 161      
;  3668                 jmp :setal
                        jmp #004432CA     ;#00443208: 351 BD000000               v  00 00  1 161      
;  3669           @@:
;  3670             cmp edx,:!opPeek1xsMLE64
                    cmp edx,#0043EEF9     ;#0044320D: 201372 F9EE4300            uv 00 04  1 162      
;  3671             je :e99seq
                    je #00443235          ;#00443213: 164 20                     v  00 00  1 162      
;  3672             cmp edx,:!opPeek2xsMLE64
                    cmp edx,#0043EF14     ;#00443215: 201372 14EF4300            uv 00 04  1 163      
;  3673             je :e99seq
                    je #00443235          ;#0044321B: 164 18                     v  00 00  1 163      
;  3674             cmp edx,:!opPeek4xsMLE64
                    cmp edx,#0043EF28     ;#0044321D: 201372 28EF4300            uv 00 04  1 164      
;  3675             je :e99seq
                    je #00443235          ;#00443223: 164 10                     v  00 00  1 164      
;  3676             cmp edx,:!opPeek8xsMLE264
                    cmp edx,#0043EF47     ;#00443225: 201372 47EF4300            uv 00 04  1 165      
;  3677             je :e99seq
                    je #00443235          ;#0044322B: 164 08                     v  00 00  1 165      
;  3678             cmp edx,:!opPeek8xuMLE264
                    cmp edx,#0043EF4B     ;#0044322D: 201372 4BEF4300            uv 00 04  1 166      
;  3679             jne @f
                    jne #00443250         ;#00443233: 165 1B                     v  00 00  1 166      
;  3680               ::e99seq
;  3681 --              mov rax,[rsp+32]
;  3682                 mov rax,[rsp+40]
                        mov rax,[rsp+40]  ;#00443235: 48:213104044 28            uv 01 10  1 167      
;  3683                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#0044323A: 215075 D0F8FBFF            vu 80 00  1 167      
;  3684                 sub rax,1
                        sub rax,1         ;#00443240: 48:203350 01               uv 01 01  1 168      
;  3685                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#00443244: 350 41F0FFFF               v  00 00  1 168      
;  3686                 mov eax,99          -- e99ipma
                        mov eax,99        ;#00443249: 270 63000000               uv 01 00  1 169      
;  3687                 jmp :setal
                        jmp #004432CA     ;#0044324E: 353 7A                     v  00 00  1 169      
;  3688             []
;  3689           @@:
;  3690             cmp edx,:!PokeN1E30
                    cmp edx,#0043EFFF     ;#00443250: 201372 FFEF4300            uv 00 04  1 170      
;  3691             je :e100ipma
                    je #004432B0          ;#00443256: 164 58                     v  00 00  1 170      
;  3692             cmp edx,:!PokeN2E30
                    cmp edx,#0043F008     ;#00443258: 201372 08F04300            uv 00 04  1 171      
;  3693             je :e100ipma
                    je #004432B0          ;#0044325E: 164 50                     v  00 00  1 171      
;  3694             cmp edx,:!PokeN4E30
                    cmp edx,#0043F012     ;#00443260: 201372 12F04300            uv 00 04  1 172      
;  3695             je :e100ipma
                    je #004432B0          ;#00443266: 164 48                     v  00 00  1 172      
;  3696             cmp edx,:!PokeN8E30
                    cmp edx,#0043F01F     ;#00443268: 201372 1FF04300            uv 00 04  1 173      
;  3697             je :e100ipma
                    je #004432B0          ;#0044326E: 164 40                     v  00 00  1 173      
;  3698             cmp edx,:!Poke1SeqE30
                    cmp edx,#0043F06F     ;#00443270: 201372 6FF04300            uv 00 04  1 174      
;  3699             je :e100ipma
                    je #004432B0          ;#00443276: 164 38                     v  00 00  1 174      
;  3700             cmp edx,:!Poke2SeqE30
                    cmp edx,#0043F078     ;#00443278: 201372 78F04300            uv 00 04  1 175      
;  3701             je :e100ipma
                    je #004432B0          ;#0044327E: 164 30                     v  00 00  1 175      
;  3702             cmp edx,:!Poke3SeqE30
                    cmp edx,0             ;#00443280: 201372 00000000            uv 00 04  1 176      
;  3703             je :e100ipma
                    je #004432B0          ;#00443286: 164 28                     v  00 00  1 176      
;  3704             cmp edx,:!Poke8SeqE30
                    cmp edx,#0043F08F     ;#00443288: 201372 8FF04300            uv 00 04  1 177      
;  3705             je :e100ipma
                    je #004432B0          ;#0044328E: 164 20                     v  00 00  1 177      
;  3706             [32]
;  3707             cmp edx,:!Poke1SeqE30a
;  3708             je :e100ipma
;  3709             []
;  3710             cmp edx,:!PokeN1StrE30
                    cmp edx,#0043F0A9     ;#00443290: 201372 A9F04300            uv 00 04  1 178      
;  3711             je :e100ipma
                    je #004432B0          ;#00443296: 164 18                     v  00 00  1 178      
;  3712             cmp edx,:!PokeN2StrE30
                    cmp edx,#0043F0B6     ;#00443298: 201372 B6F04300            uv 00 04  1 179      
;  3713             je :e100ipma
                    je #004432B0          ;#0044329E: 164 10                     v  00 00  1 179      
;  3714             cmp edx,:!PokeN4StrE30
                    cmp edx,#0043F0C0     ;#004432A0: 201372 C0F04300            uv 00 04  1 180      
;  3715             je :e100ipma
                    je #004432B0          ;#004432A6: 164 08                     v  00 00  1 180      
;  3716             cmp edx,:!PokeN8StrE30
                    cmp edx,#0043F0CD     ;#004432A8: 201372 CDF04300            uv 00 04  1 181      
;  3717             jne @f
                    jne #004432C8         ;#004432AE: 165 18                     v  00 00  1 181      
;  3718               ::e100ipma
;  3719             [32]
;  3720                 mov eax,[esp+4]
;  3721                 lea edi,[or_era]
;  3722                 sub eax,1
;  3723             [64]
;  3724                 mov rax,[rsp+8]
                        mov rax,[rsp+8]   ;#004432B0: 48:213104044 08            uv 01 10  1 182      
;  3725                 lea edi,[or_era]
                        lea edi,[#00402B10] (or_era)  ;#004432B5: 215075 55F8FBFF            vu 80 00  1 182      
;  3726                 sub rax,1
                        sub rax,1         ;#004432BB: 48:203350 01               uv 01 01  1 183      
;  3727             []
;  3728                 call :%pStoreMint
                        call #0044228A (:%pStoreMint)  ;#004432BF: 350 C6EFFFFF               v  00 00  1 183      
;  3729                 mov al,100          -- e100ipma
                        mov al,100        ;#004432C4: 260 64                     uv 01 00  1 184      
;  3730                 jmp :setal
                        jmp #004432CA     ;#004432C6: 353 02                     v  00 00  1 184      
;  3731           @@:
;  3732             mov al,30
                    mov al,30             ;#004432C8: 260 1E                     uv 01 00  1 185      
;  3733     ::setal
;  3734         [32]
;  3735             and eax,#FF
;  3736             mov [msg_id],eax
;  3737         [64]
;  3738             and rax,#FF
                    and rax,255           ;#004432CA: 48:201340 FF000000         uv 01 01  1 186 01   
;  3739             mov [msg_id],rax
                    mov [#00402BA8] (msg_id),rax  ;#004432D1: 48:211005 D0F8FBFF         uv 00 01  1 187 01   
;  3740         []
;  3741 
;  3742     ::alset
;  3743         call :%NoCleanup
                call #00442B27 (:%NoCleanup)  ;#004432D8: 350 4AF8FFFF               v  00 00  1 187      
;  3744           }
;  3745 --puts(1,"uh0?\n")
;  3746     if diagdiag>0 then
;  3747         if xceptn=0 then
    xor rdi,rdi                           ;#004432DD: 48:061377                  uv 80 80  1 188      
    mov rax,[#00402AF8] (xceptn)          ;#004432E0: 48:213005 11F8FBFF         vu 01 00  1 188      
    mov rsi,25                            ;#004432E7: 48:307306 19000000         uv 40 00  1 189      
    mov rdx,616                           ;#004432EE: 48:307302 68020000         vu 04 00  1 189      
    call #0043FAF6 (:%opJccE)             ;#004432F5: 350 FCC7FFFF               v  00 00  1 190      
    jne #00443417                         ;#004432FA: 017205 17010000            v  00 00  1 191      
;  3748             printf(1,"error code %d, or_era=#%08x, or_ebp=#%08x, or_esp=#%08x\n",
;  3749                    {msg_id,or_era,or_ebp*4,or_esp})
    mov rdi,[#00402AE8] (or_ebp)          ;#00443300: 48:213075 E1F7FBFF         uv 80 00  1 192      
    mov r15,h4                            ;#00443307: 49:277 0000000000000040    vu 8000 00  1 192      
    cmp rdi,r15                           ;#00443311: 4C:071377                  uv 00 8080  1 193      
    jne #00443322                         ;#00443314: 165 0C                     v  00 00  1 193      
    mov rsi,614                           ;#00443316: 48:307306 66020000         uv 40 00  1 194      
    call #00442D75 (:%pUnassigned)        ;#0044331D: 350 53FAFFFF               v  00 00  1 194      
    lea rdi,qword[#00402DD0]              ;#00443322: 48:215075 A7FAFBFF         uv 80 00  1 195      
    mov rcx,[#00402AE8] (or_ebp)          ;#00443329: 48:213015 B8F7FBFF         vu 02 00  1 195      
    mov rax,[#004020A8] (D_YEAR)          ;#00443330: 48:213005 71EDFBFF         uv 01 00  1 196      
    call #0043F67C (:%opMul)              ;#00443337: 350 40C3FFFF               v  00 00  1 196      
    lea rax,qword[#00402DD8]              ;#0044333C: 48:215005 95FAFBFF         uv 01 00  1 197      
    mov rdx,4                             ;#00443343: 48:307302 04000000         vu 04 00  1 197      
    push #004433C8                        ;#0044334A: 150 C8334400               uv 00 00  1 198      
    push rax                              ;#0044334F: 120                        vu 00 01  1 198      
    mov rsi,[#00402AF0] (or_esp)          ;#00443350: 48:213065 99F7FBFF         uv 40 00  1 199      
    mov r15,h4                            ;#00443357: 49:277 0000000000000040    vu 8000 00  1 199      
    cmp rsi,r15                           ;#00443361: 4C:071376                  uv 00 8040  1 200      
    jl #00443371                          ;#00443364: 174 0B                     v  00 00  1 200      
    add qword[rbx+rsi*4-16],1             ;#00443366: 48:203104263 F0 01         u  00 48  3 201      
    cmp eax,615                           ;#0044336C: 075 67020000               vu 00 01  1 203      
    push rsi                              ;#00443371: 126                        uv 00 40  1 204      
    mov rdi,qword[#00402DD0]              ;#00443372: 48:213075 57FAFBFF         vu 80 00  1 204      
    mov r15,h4                            ;#00443379: 49:277 0000000000000040    uv 8000 00  1 205      
    cmp rdi,r15                           ;#00443383: 4C:071377                  uv 00 8080  1 206 8000   
    jl #00443393                          ;#00443386: 174 0B                     v  00 00  1 206      
    add qword[rbx+rdi*4-16],1             ;#00443388: 48:203104273 F0 01         u  00 88  3 207      
    cmp eax,815                           ;#0044338E: 075 2F030000               vu 00 01  1 209      
    push rdi                              ;#00443393: 127                        uv 00 80  1 210      
    mov rcx,[#00402B10] (or_era)          ;#00443394: 48:213015 75F7FBFF         vu 02 00  1 210      
    mov r15,h4                            ;#0044339B: 49:277 0000000000000040    uv 8000 00  1 211      
    cmp rcx,r15                           ;#004433A5: 4C:071371                  uv 00 8002  1 212 8000   
    jl #004433B5                          ;#004433A8: 174 0B                     v  00 00  1 212      
    add qword[rbx+rcx*4-16],1             ;#004433AA: 48:203104213 F0 01         u  00 0A  3 213      
    cmp eax,619                           ;#004433B0: 075 6B020000               vu 00 01  1 215      
    push rcx                              ;#004433B5: 121                        uv 00 02  1 216      
    push qword[#00402BA8] (msg_id)        ;#004433B6: 377065 ECF7FBFF            np 00 00  2 217      
    mov rdi,qword[#00402DD8]              ;#004433BC: 48:213075 15FAFBFF         uv 80 00  1 219      
    jmp #004404BD (:%pMkSq)               ;#004433C3: 351 F5D0FFFF               v  00 00  1 219      
    mov rcx,4                             ;#004433C8: 48:307301 04000000         uv 02 00  1 220      
    mov rdx,94                            ;#004433CF: 48:307302 5E000000         vu 04 00  1 220      
    call #004428DB (:%opFrame) (printf)   ;#004433D6: 350 00F5FFFF               v  00 00  1 221      
    mov qword[rbp] (fn),1                 ;#004433DB: 48:307105 00 01000000      uv 00 20  1 222      
    mov rax,qword[#00402DC8]              ;#004433E3: 48:213005 DEF9FBFF         vu 01 00  1 222      
    mov [rbp-8] (format),rax              ;#004433EA: 48:211105 F8               uv 00 21  1 223      
    add qword[rbx+rax*4-16],1             ;#004433EE: 48:203104203 F0 01         u  00 09  3 225    *01*
    mov rsi,qword[#00402DD8]              ;#004433F4: 48:213065 DDF9FBFF         vu 40 00  1 227      
    mov [rbp-16] (args),rsi               ;#004433FB: 48:211165 F0               uv 00 60  1 228      
    add qword[rbx+rsi*4-16],1             ;#004433FF: 48:203104263 F0 01         u  00 48  3 230    *40*
    mov qword[retaddr],#00443412          ;#00443405: 48:307105 20 12344400      vu 00 20  1 232      
    jmp #00451A31 (code:printf)           ;#0044340D: 351 1FE60000               v  00 00  1 233      
    jmp #00443560                         ;#00443412: 351 49010000               v  00 00  1 234      
;  3750         else
;  3751             printf(1,"exception #%08x at #%08x, or_era=#%08x, or_ebp=#%08x, or_esp=#%08x\n",
;  3752                    {xceptn,xcepta,or_era,or_ebp*4,or_esp})
    mov rcx,[#00402AE8] (or_ebp)          ;#00443417: 48:213015 CAF6FBFF         uv 02 00  1 235      
    mov r15,h4                            ;#0044341E: 49:277 0000000000000040    vu 8000 00  1 235      
    cmp rcx,r15                           ;#00443428: 4C:071371                  uv 00 8002  1 236      
    jne #00443439                         ;#0044342B: 165 0C                     v  00 00  1 236      
    mov rsi,614                           ;#0044342D: 48:307306 66020000         uv 40 00  1 237      
    call #00442D75 (:%pUnassigned)        ;#00443434: 350 3CF9FFFF               v  00 00  1 237      
    lea rdi,qword[#00402DE8]              ;#00443439: 48:215075 A8F9FBFF         uv 80 00  1 238      
    mov rax,[#004020A8] (D_YEAR)          ;#00443440: 48:213005 61ECFBFF         vu 01 00  1 238      
    call #0043F67C (:%opMul)              ;#00443447: 350 30C2FFFF               v  00 00  1 239      
    lea rax,qword[#00402DF0]              ;#0044344C: 48:215005 9DF9FBFF         uv 01 00  1 240      
    mov rdx,5                             ;#00443453: 48:307302 05000000         vu 04 00  1 240      
    push #00443516                        ;#0044345A: 150 16354400               uv 00 00  1 241      
    push rax                              ;#0044345F: 120                        vu 00 01  1 241      
    mov rdi,[#00402AF0] (or_esp)          ;#00443460: 48:213075 89F6FBFF         uv 80 00  1 242      
    mov r15,h4                            ;#00443467: 49:277 0000000000000040    vu 8000 00  1 242      
    cmp rdi,r15                           ;#00443471: 4C:071377                  uv 00 8080  1 243      
    jl #00443481                          ;#00443474: 174 0B                     v  00 00  1 243      
    add qword[rbx+rdi*4-16],1             ;#00443476: 48:203104273 F0 01         u  00 88  3 244      
    cmp eax,615                           ;#0044347C: 075 67020000               vu 00 01  1 246      
    push rdi                              ;#00443481: 127                        uv 00 80  1 247      
    mov rsi,qword[#00402DE8]              ;#00443482: 48:213065 5FF9FBFF         vu 40 00  1 247      
    mov r15,h4                            ;#00443489: 49:277 0000000000000040    uv 8000 00  1 248      
    cmp rsi,r15                           ;#00443493: 4C:071376                  uv 00 8040  1 249 8000   
    jl #004434A3                          ;#00443496: 174 0B                     v  00 00  1 249      
    add qword[rbx+rsi*4-16],1             ;#00443498: 48:203104263 F0 01         u  00 48  3 250      
    cmp eax,818                           ;#0044349E: 075 32030000               vu 00 01  1 252      
    push rsi                              ;#004434A3: 126                        uv 00 40  1 253      
    mov rcx,[#00402B10] (or_era)          ;#004434A4: 48:213015 65F6FBFF         vu 02 00  1 253      
    mov r15,h4                            ;#004434AB: 49:277 0000000000000040    uv 8000 00  1 254      
    cmp rcx,r15                           ;#004434B5: 4C:071371                  uv 00 8002  1 255 8000   
    jl #004434C5                          ;#004434B8: 174 0B                     v  00 00  1 255      
    add qword[rbx+rcx*4-16],1             ;#004434BA: 48:203104213 F0 01         u  00 0A  3 256      
    cmp eax,619                           ;#004434C0: 075 6B020000               vu 00 01  1 258      
    push rcx                              ;#004434C5: 121                        uv 00 02  1 259      
    mov rax,[#00402B00] (xcepta)          ;#004434C6: 48:213005 33F6FBFF         vu 01 00  1 259      
    mov r15,h4                            ;#004434CD: 49:277 0000000000000040    uv 8000 00  1 260      
    cmp rax,r15                           ;#004434D7: 4C:071370                  uv 00 8001  1 261 8000   
    jl #004434E7                          ;#004434DA: 174 0B                     v  00 00  1 261      
    add qword[rbx+rax*4-16],1             ;#004434DC: 48:203104203 F0 01         u  00 09  3 262      
    cmp eax,617                           ;#004434E2: 075 69020000               vu 00 01  1 264      
    push rax                              ;#004434E7: 120                        uv 00 01  1 265      
    mov rdi,[#00402AF8] (xceptn)          ;#004434E8: 48:213075 09F6FBFF         vu 80 00  1 265      
    mov r15,h4                            ;#004434EF: 49:277 0000000000000040    uv 8000 00  1 266      
    cmp rdi,r15                           ;#004434F9: 4C:071377                  uv 00 8080  1 267 8000   
    jl #00443509                          ;#004434FC: 174 0B                     v  00 00  1 267      
    add qword[rbx+rdi*4-16],1             ;#004434FE: 48:203104273 F0 01         u  00 88  3 268      
    cmp eax,616                           ;#00443504: 075 68020000               vu 00 01  1 270      
    push rdi                              ;#00443509: 127                        uv 00 80  1 271      
    mov rdi,qword[#00402DF0]              ;#0044350A: 48:213075 DFF8FBFF         vu 80 00  1 271      
    jmp #004404BD (:%pMkSq)               ;#00443511: 351 A7CFFFFF               v  00 00  1 272      
    mov rcx,4                             ;#00443516: 48:307301 04000000         uv 02 00  1 273      
    mov rdx,94                            ;#0044351D: 48:307302 5E000000         vu 04 00  1 273      
    call #004428DB (:%opFrame) (printf)   ;#00443524: 350 B2F3FFFF               v  00 00  1 274      
    mov qword[rbp] (fn),1                 ;#00443529: 48:307105 00 01000000      uv 00 20  1 275      
    mov rsi,qword[#00402DE0]              ;#00443531: 48:213065 A8F8FBFF         vu 40 00  1 275      
    mov [rbp-8] (format),rsi              ;#00443538: 48:211165 F8               uv 00 60  1 276      
    add qword[rbx+rsi*4-16],1             ;#0044353C: 48:203104263 F0 01         u  00 48  3 278    *40*
    mov rcx,qword[#00402DF0]              ;#00443542: 48:213015 A7F8FBFF         vu 02 00  1 280      
    mov [rbp-16] (args),rcx               ;#00443549: 48:211115 F0               uv 00 22  1 281      
    add qword[rbx+rcx*4-16],1             ;#0044354D: 48:203104213 F0 01         u  00 0A  3 283    *02*
    mov qword[retaddr],#00443560          ;#00443553: 48:307105 20 60354400      vu 00 20  1 285      
    jmp #00451A31 (code:printf)           ;#0044355B: 351 D1E40000               v  00 00  1 286      
;  3753         end if
;  3754 -->++ (regs)
;  3755         printf(1,"stack(#%08x): %08x, %08x, %08x, %08x\n",or_esp&peek4u({or_esp,4}))
    lea rax,qword[#00402E00]              ;#00443560: 48:215005 99F8FBFF         uv 01 00  1 287      
    mov rdx,2                             ;#00443567: 48:307302 02000000         vu 04 00  1 287      
    push #004435A4                        ;#0044356E: 150 A4354400               uv 00 00  1 288      
    push rax                              ;#00443573: 120                        vu 00 01  1 288      
    push 4                                ;#00443574: 152 04                     uv 00 00  1 289      
    mov rax,[#00402AF0] (or_esp)          ;#00443576: 48:213005 73F5FBFF         vu 01 00  1 289      
    mov r15,h4                            ;#0044357D: 49:277 0000000000000040    uv 8000 00  1 290      
    cmp rax,r15                           ;#00443587: 4C:071370                  uv 00 8001  1 291 8000   
    jl #00443597                          ;#0044358A: 174 0B                     v  00 00  1 291      
    add qword[rbx+rax*4-16],1             ;#0044358C: 48:203104203 F0 01         u  00 09  3 292      
    cmp eax,615                           ;#00443592: 075 67020000               vu 00 01  1 294      
    push rax                              ;#00443597: 120                        uv 00 01  1 295      
    mov rdi,qword[#00402E00]              ;#00443598: 48:213075 61F8FBFF         vu 80 00  1 295      
    jmp #004404BD (:%pMkSq)               ;#0044359F: 351 19CFFFFF               v  00 00  1 296      
    lea rdi,qword[#00402E08]              ;#004435A4: 48:215075 5DF8FBFF         uv 80 00  1 297      
    mov rsi,qword[#00402E00]              ;#004435AB: 48:213065 4EF8FBFF         vu 40 00  1 297      
    xor rcx,rcx                           ;#004435B2: 48:061311                  uv 02 02  1 298      
    mov rdx,4                             ;#004435B5: 48:307302 04000000         vu 04 00  1 298      
    call #0043ED6C (:%opPeekNx)           ;#004435BC: 350 ABB7FFFF               v  00 00  1 299      
    mov rcx,[#00402AF0] (or_esp)          ;#004435C1: 48:213015 28F5FBFF         uv 02 00  1 300      
    mov r15,h4                            ;#004435C8: 49:277 0000000000000040    vu 8000 00  1 300      
    cmp rcx,r15                           ;#004435D2: 4C:071371                  uv 00 8002  1 301      
    jne #004435E3                         ;#004435D5: 165 0C                     v  00 00  1 301      
    mov rsi,615                           ;#004435D7: 48:307306 67020000         uv 40 00  1 302      
    call #00442D75 (:%pUnassigned)        ;#004435DE: 350 92F7FFFF               v  00 00  1 302      
    lea rdx,qword[#00402E10]              ;#004435E3: 48:215025 26F8FBFF         uv 04 00  1 303      
    lea rdi,[#00402AF0] (or_esp)          ;#004435EA: 48:215075 FFF4FBFF         vu 80 00  1 303      
    lea rcx,qword[#00402E08]              ;#004435F1: 48:215015 10F8FBFF         uv 02 00  1 304      
    call #00440021 (:%opConcat)           ;#004435F8: 350 24CAFFFF               v  00 00  1 304      
    mov rcx,4                             ;#004435FD: 48:307301 04000000         uv 02 00  1 305      
    mov rdx,94                            ;#00443604: 48:307302 5E000000         vu 04 00  1 305      
    call #004428DB (:%opFrame) (printf)   ;#0044360B: 350 CBF2FFFF               v  00 00  1 306      
    mov qword[rbp] (fn),1                 ;#00443610: 48:307105 00 01000000      uv 00 20  1 307      
    mov rax,qword[#00402DF8]              ;#00443618: 48:213005 D9F7FBFF         vu 01 00  1 307      
    mov [rbp-8] (format),rax              ;#0044361F: 48:211105 F8               uv 00 21  1 308      
    add qword[rbx+rax*4-16],1             ;#00443623: 48:203104203 F0 01         u  00 09  3 310    *01*
    mov rdi,qword[#00402E10]              ;#00443629: 48:213075 E0F7FBFF         vu 80 00  1 312      
    mov [rbp-16] (args),rdi               ;#00443630: 48:211175 F0               uv 00 A0  1 313      
    add qword[rbx+rdi*4-16],1             ;#00443634: 48:203104273 F0 01         u  00 88  3 315    *80*
    mov qword[retaddr],#00443647          ;#0044363A: 48:307105 20 47364400      vu 00 20  1 317      
    jmp #00451A31 (code:printf)           ;#00443642: 351 EAE30000               v  00 00  1 318      
;  3756         printf(1,"stack(#%08x): %08x, %08x, %08x, %08x\n",or_esp+16&peek4u({or_esp+16,4}))
    mov rsi,[#00402AF0] (or_esp)          ;#00443647: 48:213065 A2F4FBFF         uv 40 00  1 319      
    mov r15,h4                            ;#0044364E: 49:277 0000000000000040    vu 8000 00  1 319      
    cmp rsi,r15                           ;#00443658: 4C:071376                  uv 00 8040  1 320      
    jne #00443669                         ;#0044365B: 165 0C                     v  00 00  1 320      
    mov rsi,615                           ;#0044365D: 48:307306 67020000         uv 40 00  1 321      
    call #00442D75 (:%pUnassigned)        ;#00443664: 350 0CF7FFFF               v  00 00  1 321      
    lea rdi,qword[#00402E18]              ;#00443669: 48:215075 A8F7FBFF         uv 80 00  1 322      
    mov rcx,rsi                           ;#00443670: 48:211361                  vu 02 40  1 322      
    mov rax,[#00402100] (BLINKING)        ;#00443673: 48:213005 86EAFBFF         uv 01 00  1 323      
    call #0043F4AF (:%opAdd)              ;#0044367A: 350 30BEFFFF               v  00 00  1 323      
    lea rdi,qword[#00402E20]              ;#0044367F: 48:215075 9AF7FBFF         uv 80 00  1 324      
    mov rcx,[#00402AF0] (or_esp)          ;#00443686: 48:213015 63F4FBFF         vu 02 00  1 324      
    mov rax,[#00402100] (BLINKING)        ;#0044368D: 48:213005 6CEAFBFF         uv 01 00  1 325      
    call #0043F4AF (:%opAdd)              ;#00443694: 350 16BEFFFF               v  00 00  1 325      
    lea rax,qword[#00402E28]              ;#00443699: 48:215005 88F7FBFF         uv 01 00  1 326      
    mov rdx,2                             ;#004436A0: 48:307302 02000000         vu 04 00  1 326      
    push #004436DD                        ;#004436A7: 150 DD364400               uv 00 00  1 327      
    push rax                              ;#004436AC: 120                        vu 00 01  1 327      
    push 4                                ;#004436AD: 152 04                     uv 00 00  1 328      
    mov rdi,qword[#00402E20]              ;#004436AF: 48:213075 6AF7FBFF         vu 80 00  1 328      
    mov r15,h4                            ;#004436B6: 49:277 0000000000000040    uv 8000 00  1 329      
    cmp rdi,r15                           ;#004436C0: 4C:071377                  uv 00 8080  1 330 8000   
    jl #004436D0                          ;#004436C3: 174 0B                     v  00 00  1 330      
    add qword[rbx+rdi*4-16],1             ;#004436C5: 48:203104273 F0 01         u  00 88  3 331      
    cmp eax,825                           ;#004436CB: 075 39030000               vu 00 01  1 333      
    push rdi                              ;#004436D0: 127                        uv 00 80  1 334      
    mov rdi,qword[#00402E28]              ;#004436D1: 48:213075 50F7FBFF         vu 80 00  1 334      
    jmp #004404BD (:%pMkSq)               ;#004436D8: 351 E0CDFFFF               v  00 00  1 335      
    lea rdi,qword[#00402E30]              ;#004436DD: 48:215075 4CF7FBFF         uv 80 00  1 336      
    mov rsi,qword[#00402E28]              ;#004436E4: 48:213065 3DF7FBFF         vu 40 00  1 336      
    xor rcx,rcx                           ;#004436EB: 48:061311                  uv 02 02  1 337      
    mov rdx,4                             ;#004436EE: 48:307302 04000000         vu 04 00  1 337      
    call #0043ED6C (:%opPeekNx)           ;#004436F5: 350 72B6FFFF               v  00 00  1 338      
    lea rdx,qword[#00402E38]              ;#004436FA: 48:215025 37F7FBFF         uv 04 00  1 339      
    lea rdi,qword[#00402E18]              ;#00443701: 48:215075 10F7FBFF         vu 80 00  1 339      
    lea rcx,qword[#00402E30]              ;#00443708: 48:215015 21F7FBFF         uv 02 00  1 340      
    call #00440021 (:%opConcat)           ;#0044370F: 350 0DC9FFFF               v  00 00  1 340      
    mov rcx,4                             ;#00443714: 48:307301 04000000         uv 02 00  1 341      
    mov rdx,94                            ;#0044371B: 48:307302 5E000000         vu 04 00  1 341      
    call #004428DB (:%opFrame) (printf)   ;#00443722: 350 B4F1FFFF               v  00 00  1 342      
    mov qword[rbp] (fn),1                 ;#00443727: 48:307105 00 01000000      uv 00 20  1 343      
    mov rcx,qword[#00402DF8]              ;#0044372F: 48:213015 C2F6FBFF         vu 02 00  1 343      
    mov [rbp-8] (format),rcx              ;#00443736: 48:211115 F8               uv 00 22  1 344      
    add qword[rbx+rcx*4-16],1             ;#0044373A: 48:203104213 F0 01         u  00 0A  3 346    *02*
    mov rax,qword[#00402E38]              ;#00443740: 48:213005 F1F6FBFF         vu 01 00  1 348      
    mov [rbp-16] (args),rax               ;#00443747: 48:211105 F0               uv 00 21  1 349      
    add qword[rbx+rax*4-16],1             ;#0044374B: 48:203104203 F0 01         u  00 09  3 351    *01*
    mov qword[retaddr],#0044375E          ;#00443751: 48:307105 20 5E374400      vu 00 20  1 353      
    jmp #00451A31 (code:printf)           ;#00443759: 351 D3E20000               v  00 00  1 354      
;  3757         printf(1,"stack(#%08x): %08x, %08x, %08x, %08x\n",or_esp+32&peek4u({or_esp+32,4}))
    lea rdi,qword[#00402E40]              ;#0044375E: 48:215075 DBF6FBFF         uv 80 00  1 355      
    mov rcx,[#00402AF0] (or_esp)          ;#00443765: 48:213015 84F3FBFF         vu 02 00  1 355      
    mov rax,[MB_ICONQUESTION]             ;#0044376C: 48:213005 FDE9FBFF         uv 01 00  1 356      
    call #0043F4AF (:%opAdd)              ;#00443773: 350 37BDFFFF               v  00 00  1 356      
    lea rdi,qword[#00402E48]              ;#00443778: 48:215075 C9F6FBFF         uv 80 00  1 357      
    mov rcx,[#00402AF0] (or_esp)          ;#0044377F: 48:213015 6AF3FBFF         vu 02 00  1 357      
    mov rax,[MB_ICONQUESTION]             ;#00443786: 48:213005 E3E9FBFF         uv 01 00  1 358      
    call #0043F4AF (:%opAdd)              ;#0044378D: 350 1DBDFFFF               v  00 00  1 358      
    lea rax,qword[#00402E50]              ;#00443792: 48:215005 B7F6FBFF         uv 01 00  1 359      
    mov rdx,2                             ;#00443799: 48:307302 02000000         vu 04 00  1 359      
    push #004437D6                        ;#004437A0: 150 D6374400               uv 00 00  1 360      
    push rax                              ;#004437A5: 120                        vu 00 01  1 360      
    push 4                                ;#004437A6: 152 04                     uv 00 00  1 361      
    mov rdi,qword[#00402E48]              ;#004437A8: 48:213075 99F6FBFF         vu 80 00  1 361      
    mov r15,h4                            ;#004437AF: 49:277 0000000000000040    uv 8000 00  1 362      
    cmp rdi,r15                           ;#004437B9: 4C:071377                  uv 00 8080  1 363 8000   
    jl #004437C9                          ;#004437BC: 174 0B                     v  00 00  1 363      
    add qword[rbx+rdi*4-16],1             ;#004437BE: 48:203104273 F0 01         u  00 88  3 364      
    cmp eax,830                           ;#004437C4: 075 3E030000               vu 00 01  1 366      
    push rdi                              ;#004437C9: 127                        uv 00 80  1 367      
    mov rdi,qword[#00402E50]              ;#004437CA: 48:213075 7FF6FBFF         vu 80 00  1 367      
    jmp #004404BD (:%pMkSq)               ;#004437D1: 351 E7CCFFFF               v  00 00  1 368      
    lea rdi,qword[#00402E58]              ;#004437D6: 48:215075 7BF6FBFF         uv 80 00  1 369      
    mov rsi,qword[#00402E50]              ;#004437DD: 48:213065 6CF6FBFF         vu 40 00  1 369      
    xor rcx,rcx                           ;#004437E4: 48:061311                  uv 02 02  1 370      
    mov rdx,4                             ;#004437E7: 48:307302 04000000         vu 04 00  1 370      
    call #0043ED6C (:%opPeekNx)           ;#004437EE: 350 79B5FFFF               v  00 00  1 371      
    lea rdx,qword[#00402E60]              ;#004437F3: 48:215025 66F6FBFF         uv 04 00  1 372      
    lea rdi,qword[#00402E40]              ;#004437FA: 48:215075 3FF6FBFF         vu 80 00  1 372      
    lea rcx,qword[#00402E58]              ;#00443801: 48:215015 50F6FBFF         uv 02 00  1 373      
    call #00440021 (:%opConcat)           ;#00443808: 350 14C8FFFF               v  00 00  1 373      
    mov rcx,4                             ;#0044380D: 48:307301 04000000         uv 02 00  1 374      
    mov rdx,94                            ;#00443814: 48:307302 5E000000         vu 04 00  1 374      
    call #004428DB (:%opFrame) (printf)   ;#0044381B: 350 BBF0FFFF               v  00 00  1 375      
    mov qword[rbp] (fn),1                 ;#00443820: 48:307105 00 01000000      uv 00 20  1 376      
    mov rcx,qword[#00402DF8]              ;#00443828: 48:213015 C9F5FBFF         vu 02 00  1 376      
    mov [rbp-8] (format),rcx              ;#0044382F: 48:211115 F8               uv 00 22  1 377      
    add qword[rbx+rcx*4-16],1             ;#00443833: 48:203104213 F0 01         u  00 0A  3 379    *02*
    mov rax,qword[#00402E60]              ;#00443839: 48:213005 20F6FBFF         vu 01 00  1 381      
    mov [rbp-16] (args),rax               ;#00443840: 48:211105 F0               uv 00 21  1 382      
    add qword[rbx+rax*4-16],1             ;#00443844: 48:203104203 F0 01         u  00 09  3 384    *01*
    mov qword[retaddr],#00443857          ;#0044384A: 48:307105 20 57384400      vu 00 20  1 386      
    jmp #00451A31 (code:printf)           ;#00443852: 351 DAE10000               v  00 00  1 387      
;  3758         printf(1,"stack(#%08x): %08x, %08x, %08x, %08x\n",or_esp+48&peek4u({or_esp+48,4}))
    lea rdi,qword[#00402E68]              ;#00443857: 48:215075 0AF6FBFF         uv 80 00  1 388      
    mov rcx,[#00402AF0] (or_esp)          ;#0044385E: 48:213015 8BF2FBFF         vu 02 00  1 388      
    mov rax,[MB_ICONEXCLAMATION]          ;#00443865: 48:213005 0CE9FBFF         uv 01 00  1 389      
    call #0043F4AF (:%opAdd)              ;#0044386C: 350 3EBCFFFF               v  00 00  1 389      
    lea rdi,qword[#00402E70]              ;#00443871: 48:215075 F8F5FBFF         uv 80 00  1 390      
    mov rcx,[#00402AF0] (or_esp)          ;#00443878: 48:213015 71F2FBFF         vu 02 00  1 390      
    mov rax,[MB_ICONEXCLAMATION]          ;#0044387F: 48:213005 F2E8FBFF         uv 01 00  1 391      
    call #0043F4AF (:%opAdd)              ;#00443886: 350 24BCFFFF               v  00 00  1 391      
    lea rax,qword[#00402E78]              ;#0044388B: 48:215005 E6F5FBFF         uv 01 00  1 392      
    mov rdx,2                             ;#00443892: 48:307302 02000000         vu 04 00  1 392      
    push #004438CF                        ;#00443899: 150 CF384400               uv 00 00  1 393      
    push rax                              ;#0044389E: 120                        vu 00 01  1 393      
    push 4                                ;#0044389F: 152 04                     uv 00 00  1 394      
    mov rdi,qword[#00402E70]              ;#004438A1: 48:213075 C8F5FBFF         vu 80 00  1 394      
    mov r15,h4                            ;#004438A8: 49:277 0000000000000040    uv 8000 00  1 395      
    cmp rdi,r15                           ;#004438B2: 4C:071377                  uv 00 8080  1 396 8000   
    jl #004438C2                          ;#004438B5: 174 0B                     v  00 00  1 396      
    add qword[rbx+rdi*4-16],1             ;#004438B7: 48:203104273 F0 01         u  00 88  3 397      
    cmp eax,835                           ;#004438BD: 075 43030000               vu 00 01  1 399      
    push rdi                              ;#004438C2: 127                        uv 00 80  1 400      
    mov rdi,qword[#00402E78]              ;#004438C3: 48:213075 AEF5FBFF         vu 80 00  1 400      
    jmp #004404BD (:%pMkSq)               ;#004438CA: 351 EECBFFFF               v  00 00  1 401      
    lea rdi,qword[#00402E80]              ;#004438CF: 48:215075 AAF5FBFF         uv 80 00  1 402      
    mov rsi,qword[#00402E78]              ;#004438D6: 48:213065 9BF5FBFF         vu 40 00  1 402      
    xor rcx,rcx                           ;#004438DD: 48:061311                  uv 02 02  1 403      
    mov rdx,4                             ;#004438E0: 48:307302 04000000         vu 04 00  1 403      
    call #0043ED6C (:%opPeekNx)           ;#004438E7: 350 80B4FFFF               v  00 00  1 404      
    lea rdx,qword[#00402E88]              ;#004438EC: 48:215025 95F5FBFF         uv 04 00  1 405      
    lea rdi,qword[#00402E68]              ;#004438F3: 48:215075 6EF5FBFF         vu 80 00  1 405      
    lea rcx,qword[#00402E80]              ;#004438FA: 48:215015 7FF5FBFF         uv 02 00  1 406      
    call #00440021 (:%opConcat)           ;#00443901: 350 1BC7FFFF               v  00 00  1 406      
    mov rcx,4                             ;#00443906: 48:307301 04000000         uv 02 00  1 407      
    mov rdx,94                            ;#0044390D: 48:307302 5E000000         vu 04 00  1 407      
    call #004428DB (:%opFrame) (printf)   ;#00443914: 350 C2EFFFFF               v  00 00  1 408      
    mov qword[rbp] (fn),1                 ;#00443919: 48:307105 00 01000000      uv 00 20  1 409      
    mov rcx,qword[#00402DF8]              ;#00443921: 48:213015 D0F4FBFF         vu 02 00  1 409      
    mov [rbp-8] (format),rcx              ;#00443928: 48:211115 F8               uv 00 22  1 410      
    add qword[rbx+rcx*4-16],1             ;#0044392C: 48:203104213 F0 01         u  00 0A  3 412    *02*
    mov rax,qword[#00402E88]              ;#00443932: 48:213005 4FF5FBFF         vu 01 00  1 414      
    mov [rbp-16] (args),rax               ;#00443939: 48:211105 F0               uv 00 21  1 415      
    add qword[rbx+rax*4-16],1             ;#0044393D: 48:203104203 F0 01         u  00 09  3 417    *01*
    mov qword[retaddr],#00443950          ;#00443943: 48:307105 20 50394400      vu 00 20  1 419      
    jmp #00451A31 (code:printf)           ;#0044394B: 351 E1E00000               v  00 00  1 420      
;  3759     end if
;  3760 
;  3761     diag()
    mov rcx,76                            ;#00443950: 48:307301 4C000000         uv 02 00  1 421      
    mov rdx,672                           ;#00443957: 48:307302 A0020000         vu 04 00  1 421      
    call #004428DB (:%opFrame) (diag)     ;#0044395E: 350 78EFFFFF               v  00 00  1 422      
    mov qword[retaddr],#00443970          ;#00443963: 48:307105 20 70394400      uv 00 20  1 423      
    jmp #004439B9 (code:diag)             ;#0044396B: 351 49000000               v  00 00  1 423      
;  3762     -- control does not return... [DEV]
;  3763 puts(1,"uh? (pdiagN.e line 3496)\n")
    mov rax,1                             ;#00443970: 48:307300 01000000         uv 01 00  1 424      
    mov rdx,qword[#00402E90]              ;#00443977: 48:213025 12F5FBFF         vu 04 00  1 424      
    call #0043E218 (:%opPuts)             ;#0044397E: 350 95A8FFFF               v  00 00  1 425      
;  3764 --DEV standard problem... must fix this one day...
;  3765     msg_id += 1
    mov rdi,[#00402BA8] (msg_id)          ;#00443983: 48:213075 1EF2FBFF         uv 80 00  1 426      
    add rdi,1                             ;#0044398A: 48:203307 01               uv 80 80  1 427 80   
    mov rdx,rdi                           ;#0044398E: 48:213327                  uv 04 80  1 428 80   
    mov [#00402BA8] (msg_id),rdi          ;#00443991: 48:211075 10F2FBFF         vu 00 80  1 428      
    shl rdx,1                             ;#00443998: 48:321342                  u  04 04  1 429      
    jno #004439A9                         ;#0044399B: 161 0C                     v  00 00  1 429      
    lea rdi,[#00402BA8] (msg_id)          ;#0044399D: 48:215075 04F2FBFF         uv 80 00  1 430      
    call #00442DA9 (:%pAddiii)            ;#004439A4: 350 00F4FFFF               v  00 00  1 430      
;  3766     batchmode = 1
    mov qword[#00402678] (batchmode),1    ;#004439A9: 48:307005 C4ECFBFF 01000000 uv 00 00  1 431      
;  3767 --  xceptn += 1
;  3768 --  #ilASM{
;  3769 --      [32]
;  3770 --          mov eax,[esp]
;  3771 ----            mov edx,[batchmode]
;  3772 --          jmp eax
;  3773 --      [64]
;  3774 --          mov rax,[rsp]
;  3775 ----            mov rdx,[batchmode]
;  3776 --          jmp rax
;  3777 --      []
;  3778 --        }
;  3779 
;  3780 
;  3781 --end of new code
;  3782 --===============
;  3783 ---- "without debug" stops the run-time update of line and file info, and
;  3784 ---- this program from dumping local vars, which in this case would be [DEV?]
;  3785 ---- just crash_rtn, crash_msg, crashfile, and stoploop. While it remains
;  3786 ---- quite sensible to specify this here, it should be perfectly OK to 
;  3787 ---- turn it back on for a while rather than play completely in the dark.
;  3788 ---- If you get any problems, comment this line out, suffer the 4 extra 
;  3789 ---- lines in your .err, some pretty wierd and wacky misleading line nos
;  3790 ---- (eg the line in this source rather than where the user app actually 
;  3791 ----  crashed), and hopefully/maybe get a better clue where it 
;  3792 ---- (this, ie pdiag.e) went wrong ;-)):
;  3793 --
;  3794 ----/**/without debug -- Phix: disables all debug/diagnostic stuff!
;  3795 --------/**/with debug
;  3796 --without type_check
;  3797 ------with trace
;  3798 --
;  3799 --
;  3800 ----without trace   -- NB no effect under "without debug"
;  3801 ----with trace      -- NB no effect under "without debug"
;  3802 --
;  3803 --
;  3804 ---- TODO: 
;  3805 ---- "Traced lines leading up to the failure:", eg:
;  3806 ----
;  3807 ----C:\Program Files\Phix\test.exw:6    procedure d(sequence s)
;  3808 ----C:\Program Files\Phix\test.exw:8        d(s[2..length(s)-1])
;  3809 ----C:\Program Files\Phix\test.exw:6    procedure d(sequence s)
;  3810 ----C:\Program Files\Phix\test.exw:8        d(s[2..length(s)-1])
;  3811 ----
;  3812 ---- (Personally, though, I've never found that much use)
;  3813 --
;  3814 --constant binderrs = {
;  3815 --"infile is not string",                   --1 --*
;  3816 --"error opening infile (p.exe)",           --2 -- in use? hard disk problems?
;  3817 --"error seeking to infile eof",                --3 --          ""
;  3818 --"error allocating sizeof(p.exe|new.exe)", --4 -- insufficient memory? (2MB should be plenty!)
;  3819 --"error reading p.exe",                        --5 -- as 2,3
;  3820 --"MZ header not found",                        --6 -- p.exe corrupt? hard disk problems?
;  3821 --"PE header not found",                        --7 -- ""               ""
;  3822 --"subvers not atom",                       --8 --*
;  3823 --"length(optable)!=length(opNames)",       --9 -- [details already shown]
;  3824 --"calcsize!=dumpsize",                     --10 -- serious! will need soure to reproduce
;  3825 --"incorrect image size",                   --11    ""
;  3826 --"outfile not string",                     --12 --*
;  3827 --"error writing new.exe",                  --13 -- in use? hard disk problems?
;  3828 --"sig not sequence"}                       --14 --*
;  3829 ---- items marked --* should not happen (unless p.exw sources badly hacked)
;  3830 --
;  3831 --
;  3832 --constant rtndescs = {"type","function", "procedure"}
;  3833 --
;  3834 --object crash_rtn crash_rtn = -1
;  3835 --object crashfile crashfile = -1
;  3836 --
;  3837 --integer stoploop      -- this is independently tested for in the backend...
;  3838 --      stoploop = 0        --  (but it does not hurt any to re-test it here)
;  3839 --
;  3840 --function diag(integer msg_id)
;  3841 -- removed from e01:
;  3842     -- Note: since the diag routine uses some of the builtins,
;  3843     --  then eg object o o="fred" getc(o) will not generate 
;  3844     -- 'type check error, fn is "fred"', but instead
;  3845     -- 'type check error, getc parameter fn is wrong'. [?DEV I may have fixed this since?]
;  3846     --  [as opposed to getc("fred"), which causes compile-time error]
;  3847     -- When you see "builtin parameter", look up the routine
;  3848     --  in the documentation to find out exactly which 
;  3849     --  parameter it is referring to.
;  3850     -- For more details, also see variable builtinparamwrong.
;  3851 --integer builtinparamwrong
;  3852 --integer k, rtn, callee, fileno, pathno, noofparams, i2, i3, i4, km1, km2, km3, kp1
;  3853 --integer lineno
;  3854 --object si, codeseg, o, o2, name
;  3855 --integer tidx, idx
;  3856 --integer pn
;  3857 --object linetab
;  3858 --integer line
;  3859 --object ugh --DEV!
;  3860 --
;  3861 ------  puts(1,"diag called...\n")
;  3862 --------/**/if getc(0) then end if
;  3863 --  if stoploop then
;  3864 --      -- this is independently tested for in the backend...
;  3865 --      --  (flag is intended to catch errors in pdiag.e itself)
;  3866 ----        puts(1,"diag looping!\n")
;  3867 --      puts(1,"diag looping!\n")
;  3868 ----        stoploop = 2
;  3869 ----    elsif stoploop=2 then
;  3870 ----        puts(1,"diag re-looping!\n")
;  3871 --      return 0
;  3872 ----        if getc(0) then end if
;  3873 ----        abort(0)
;  3874 ----    else
;  3875 --  end if
;  3876 --  stoploop=1
;  3877 --
;  3878 ------  puts(1,"diag called2...\n")
;  3879 --
;  3880 --  if equal(crashfile,"") then return 0 end if
;  3881 ----    if equal(crashfile,"") then abort(1) end if
;  3882 --
;  3883 --  builtinparamwrong = 0
;  3884 --  callcount = 0
;  3885 --  if find(crashfile,{"NUL","/dev/null"}) then
;  3886 --      pn = -1
;  3887 ----DEV: if we can't open .err, display to screen anyway...
;  3888 ----        [I think we're OK, but not tested, let me know if it works as it should]
;  3889 --  elsif crashfile!=-1 then
;  3890 --      pn = open(crashfile,"w")
;  3891 --  else
;  3892 --      pn = open("p.err","w")
;  3893 --  end if
;  3894 --
;  3895 --  while 1 do
;  3896 --      while 1 do
;  3897 --              callcount += 1
;  3898 --                  if msg_id<=length(msgs) then
;  3899 --                      i2 = ep1  i3 = ep2
;  3900 --                      elsif msg_id = 108 then
;  3901 --                          -- position error [%08x]
;  3902 --                          o = {i2}
;  3903 --                      elsif msg_id = 98 then
;  3904 --                          -- flush error [%08x]
;  3905 --                          -- add human-readables for common ones as follows:
;  3906 --                          -- (see eg arwen/Constants.ew, ERROR_INVALID_HANDLE etc)
;  3907 ----                            if i2=? then
;  3908 ----                                o = {i2," desc"}
;  3909 ----                            elsif i2=? then
;  3910 ----                                o = {i2," desc"}
;  3911 ----                            else
;  3912 --                              o = {i2,""}
;  3913 ----                            end if
;  3914 --                      elsif msg_id = 62
;  3915 --                         or msg_id = 58
;  3916 --                         or msg_id = 7 then
;  3917 --                          -- file number %d is not open
;  3918 --                          -- invalid file number (%d)
;  3919 --                          -- slice start is less than 1 (%d)
;  3920 --                          o = {i2}
;  3921 --                      elsif msg_id = 6
;  3922 --                         or msg_id = 106 then
;  3923 --                          -- index %d out of bounds, assigning to sequence length %d
;  3924 --                          -- index %d out of bounds, reading from sequence length %d
;  3925 --                          o = {i2,i3}
;  3926 --                      elsif msg_id >= 9 
;  3927 --                        and msg_id <= 11 then
;  3928 --                          -- slice length is negative (%d..%d)
;  3929 --                          -- slice starts past end of sequence (%d > %d)
;  3930 --                          -- slice ends past end of sequence (%d > %d)
;  3931 --                          o = {i2,i3}
;  3932 --                      elsif msg_id = 116 then
;  3933 --                          -- routine requires %d parameters, not %d
;  3934 --                          o = {i2,i3}
;  3935 --                      elsif msg_id = 1
;  3936 --                      or msg_id = 110 then
;  3937 --                          if symtab[i2][S_NTyp] = S_TVar3 then
;  3938 --                              i4 = -symtab[i2][S_Tidx]
;  3939 --                          else
;  3940 --                              o = symtab[i2][S_value] (DEV)
;  3941 --                          end if
;  3942 --                          if i3=0 then
;  3943 --                              o = {"<diag.e: oops, i3 is zero>",o}
;  3944 --                          elsif builtinparamwrong then
;  3945 --                              o = {symtab[builtinparamwrong][S_Name]&" parameter "&
;  3946 ----DEV: (testme!)
;  3947 ----                                     symtab[i3][S_Name],"wrong"}
;  3948 --                                   symtab[i3][S_Name],o}
;  3949 --                          else
;  3950 --                              o = {symtab[i3][S_Name],o}
;  3951 --                          end if
;  3952 --
;  3953 --                      elsif msg_id = 93 then
;  3954 --                          -- bind error %d (%s)
;  3955 --                          o = {i2,binderrs[i2]}
;  3956 --                      else
;  3957 --                          o = 0
;  3958 --                      end if
;  3959 --                      put2(pn,msgs[msg_id],o)
;  3960 --                  else
;  3961 --                      put2(pn,"unknown error code %d\n",{msg_id})
;  3962 --                  end if
;  3963 --
;  3964 --          elsif msg_id=1 then
;  3965 --              -- Instead of 'type check error, fn is "fred"', for
;  3966 --              -- the builtins, which we are likely to use all the
;  3967 --              -- time and hence trash any "current value", output
;  3968 --              -- 'type check error, builtin parameter fn is wrong'
;  3969 --              --  (user is expected to lookup "fn" in the docs)
;  3970 --              -- FWIW, RDS Eu tends to output routine-specific
;  3971 --              -- messages, eg "first parameter to match must be 
;  3972 --              -- a sequence", "file number is not an integer",
;  3973 --              -- and likwise not show any "current value".
;  3974 --              builtinparamwrong=rtn
;  3975 --          end if
;  3976 --
;  3977 --flush(pn)
;  3978 --      end while
;  3979 --  end while
;  3980 --flush(pn)
;  3981 --
;  3982 --  if pn!=-1 and callcount>100 then
;  3983 --      printf(pn,"  (skipping %d levels)\n",callcount-100)
;  3984 --  end if
;  3985 ------  puts(1,"hey7!\n")
;  3986 --
;  3987 --  fileno = 0
;  3988 --
;  3989 --  if pn!=-1 then
;  3990 --      puts(pn,"\nGlobal & Local Variables\n")
;  3991 --
;  3992 --      for i=1 to length(symtab) do
;  3993 --      end for
;  3994 --      puts(1,"\n")
;  3995 --      close(pn)
;  3996 --  end if
;  3997 --  if crash_rtn!=-1 then
;  3998 ----DEV setup 2nd p_crash.err file.. [better: use the old asm stubs to screen]
;  3999 --      for i=length(crash_rtn) to 1 by -1 do
;  4000 --          if call_func(crash_rtn[i],{0}) then exit end if
;  4001 --      end for
;  4002 --  end if
;  4003 ----puts(1,"done!\n")
;  4004 ----abort(1)
;  4005 ----if getc(0) then end if
;  4006 ----if stoploop then abort(1) end if
;  4007 --  stoploop = 0
;  4008 --  return 0
;  4009 --end function
;  4010 --
;  4011 ----DEV this needs to be moved to asm?:
;  4012 --global procedure crash_routine(integer proc)
;  4013 ---- specify the routine id of a Phix procedure to call in the
;  4014 ---- event that Phix must shut down your program due to an error.
;  4015 --  if crash_rtn=-1 then
;  4016 --      crash_rtn = {proc}
;  4017 --  else
;  4018 --      crash_rtn = append(crash_rtn,proc)
;  4019 --  end if
;  4020 --end procedure
;  4021 --
;  4022 --
;  4023 --procedure setup()
;  4024 --  diagcb = routine_id("diag") --  if diagcb <= 0 then puts(1,"diagcb <= 0\n") abort(1) end if
;  4025 ----?diagcb
;  4026 --  diagcb = call_back(diagcb)  --  if diagcb = -1 then puts(1,"callback = -1\n") abort(1) end if
;  4027 ----?diagcb
;  4028 --
;  4029 --  #ilASM{mov edi,[diagcb]
;  4030 --         call %opCrshRtn}
;  4031 --end procedure
;  4032 --if 01 then
;  4033 --setup()
;  4034 --end if
;  4035 --
;  4036 
;  4037 --          #ilASM{ jmp :%pRetf     -- (there's one of these at every eof)
;  4038 --                  :%somelabel
;  4039 --                }
;  4040 --          puts(1,"hello from somelabel\n")  -- [keep this short/simple]
;  4041 --          #ilASM{ ret }
;  4042 --          <EOF>
;  4043 
;  4044 
;  4045 --  #ilASM{ jmp :fin
;  4046 ----        [32]
;  4047 ----DEV:
;  4048 --          :%e01tcfAddiii
;  4049 ----            :%e02atdb0  -- (DEV moved to pUnassigned for now)
;  4050 ----            :%pUnassigned   -- aka e92vhnbaavesiesp
;  4051 --              -- var no(?) in esi
;  4052 ----            :%pRTErn
;  4053 ----?       :%pRTErf
;  4054 --              -- errorcode in al
;  4055 --              -- ep1 in e/rdi
;  4056 --              -- ep2 in e/rsi
;  4057 ----?           -- use the called from address ([e/rbp+12/24])[? just let without debug take care of it... ?]
;  4058 ----?           -- note that e/rbp may need to be specially set by the callee (eg to ebp_prev),
;  4059 ----?           --  since there is no point in say pfileioN.e reporting errors in iofatal().
;  4060 ----                mov e??,[ebp+12]    -- called from address
;  4061 ----                mov r??,[rbp+24]    -- called from address
;  4062 --          int3
;  4063 ----        [64]
;  4064 ----            pop al
;  4065 ----        []
;  4066 --          ::fin
;  4067 --        }
;C:\Program Files (x86)\Phix\builtins\VM\pprntfN.e:
;==================================================
;     1 --
;     2 -- pprntfN.e
;     3 -- =========
;     4 --
;     5 -- The Phix sprintf() function.
;     6 -- This file is automatically included by the compiler if (and only if) needed.
;     7 -- Compared to the C version, this is just over twice as slow, which is rather
;     8 -- surprising (I expected it would be around 8 to 10 times slower). I suspect
;     9 -- the biggest overhead is allocating space for the result (string), which is
;    10 -- pretty much going to be the same for the C and Phix routines. This may be
;    11 -- converted to asm at a later date, but not until it has been completely
;    12 -- bug- and enhancement- free for at least six months.
;    13 --
;    14 --
;    15 -- **************************************
;    16 -- **** WARNING: FRAGILE CODE AHEAD! ****
;    17 -- **************************************
;    18 --  Test changes exhaustively before rebuilding p.exe!
;    19 --  In particular, take care with type string; subtle changes (such as a
;    20 --  missing floor()) can make the back-end expand a string to a sequence
;    21 --  (which is something prepend, as opposed to append, /always/ does)
;    22 --  which causes a fatal error, eg see 'elsif format[i]='s' then'.
;    23 
;    24 --!/**/without debug -- remove to debug (just keeps ex.err clutter-free)
;    25 --!/**/with debug
;    26 --  NB the "without debug" in both pdiag.e and ppp.e overshadow the one
;    27 --      here; use "with debug" and/or "-nodiag" to get a listing.
;    28 
;    29 --without trace -- ditto
;    30 
;    31 -- Bugfix history:
;    32 --  14/01/06. Did not handle negative numbers ("sign" added).
;    33 --  09/03/06. printed 2700000000 as "27".
;    34 --  22/05/06. precision errors on big numbers.
;    35 --  19/08/07. nzdigitprinted flag added. [ummm?]
;    36 --  19/06/08. bug with trailing 0s in 'g'.
;    37 --  20/03/09. moved exp to end for K_noclr reasons.
;    38 --  05/03/12. made thread-safe (no file-level vars) [DEV multiple returns rqd?]
;    39 
;    40 include builtins\VM\pUnassigned.e   -- :%pRTErn (DEV/temp)
;    41 
;    42 --/* Not required for Phix (string is builtin):
;    43 type string(object o) return sequence(o) end type
;    44 --*/
;    45 
;    46 function round(string result, atom f, integer exp, integer charflag, integer digit)--, integer minfieldwidth)
    mov rdi,[rbp] (result)                ;#00451360: 48:213175 00               uv 80 20  1   1      
    mov r15,h4                            ;#00451364: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0045136E: 4C:071377                  uv 00 8080  1   2      
    jl #0045137A                          ;#00451371: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rdi*4-1],#82             ;#00451373: 200174273 FF 82            u  00 88  2   3      
    je #00451386                          ;#00451378: 164 0C                     v  00 00  1   4      
    mov rcx,103                           ;#0045137A: 48:307301 67000000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#00451381: 350 D216FFFF               v  00 00  1   5      
;    47 --
;    48 -- Apply rounding to partially printed float, if required
;    49 --
;    50 integer tmp
;    51 integer dot, dotm1
;    52 --?result   --DOH, infinite loop! (use puts(1,<string>) instead!)
;    53     if exp>=1 then
    mov rcx,[rbp-16] (exp)                ;#00451386: 48:213115 F0               uv 02 20  1   6      
    cmp rcx,1                             ;#0045138A: 48:203371 01               uv 00 02  1   7 02   
    jl #004513B1                          ;#0045138E: 174 21                     v  00 00  1   7      
;    54         f /= power(10,exp)
    lea rdi,[rbp-64] (symtab[111])        ;#00451390: 48:215175 C0               uv 80 20  1   8      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00451394: 48:213005 4D0DFBFF         vu 01 00  1   8      
    call #0043B324 (:%opPow)              ;#0045139B: 350 849FFEFF               v  00 00  1   9      
    lea rdi,[rbp-8] (f)                   ;#004513A0: 48:215175 F8               uv 80 20  1  10      
    mov rcx,[rbp-8] (f)                   ;#004513A4: 48:213115 F8               vu 02 20  1  10      
    mov rax,[rbp-64] (symtab[111])        ;#004513A8: 48:213105 C0               uv 01 20  1  11      
    call #0043F564 (:%opDiv)              ;#004513AC: 350 B3E1FEFF               v  00 00  1  11      
;    55     end if
;    56 --DEV and_bits(digit,1) = remainder(digit,2). =1 pointless in both cases.
;    57     if f>5 or (f=5 and remainder(digit,2)=1) then
    mov rdi,5                             ;#004513B1: 48:307307 05000000         uv 80 00  1  12      
    mov rax,[rbp-8] (f)                   ;#004513B8: 48:213105 F8               vu 01 20  1  12      
    mov rsi,42                            ;#004513BC: 48:307306 2A000000         uv 40 00  1  13      
    mov rdx,104                           ;#004513C3: 48:307302 68000000         vu 04 00  1  13      
    call #0043FA81 (:%opJcc)              ;#004513CA: 350 B2E6FEFF               v  00 00  1  14      
    jg #00451401                          ;#004513CF: 177 30                     v  00 00  1  15      
    mov rsi,[rbp-8] (f)                   ;#004513D1: 48:213165 F8               uv 40 20  1  16      
    cmp rsi,5                             ;#004513D5: 48:203376 05               uv 00 40  1  17 40   
    jne #004515E1                         ;#004513D9: 017205 02020000            v  00 00  1  17      
    lea rdi,[rbp-64] (symtab[111])        ;#004513DF: 48:215175 C0               uv 80 20  1  18      
    mov rax,[rbp-32] (digit)              ;#004513E3: 48:213105 E0               vu 01 20  1  18      
    mov rcx,[#00402098] (WIN32)           ;#004513E7: 48:213015 AA0CFBFF         uv 02 00  1  19      
    call #0043F1F5 (:%opRmdr)             ;#004513EE: 350 02DEFEFF               v  00 00  1  19      
    mov rdi,[rbp-64] (symtab[111])        ;#004513F3: 48:213175 C0               uv 80 20  1  20      
    cmp rdi,1                             ;#004513F7: 48:203377 01               uv 00 80  1  21 80   
    jne #004515E1                         ;#004513FB: 017205 E0010000            v  00 00  1  21      
;    58         for i=length(result) to 1 by -1 do
    mov rsi,[rbp] (result)                ;#00451401: 48:213165 00               uv 40 20  1  22      
    mov rax,[rbx+rsi*4-24]                ;#00451405: 48:48:213104263 E8         uv 01 48  1  25 40 *40*
    mov [rbp-72] (symtab[112]),rax        ;#0045140B: 48:211105 B8               uv 00 21  1  26 01   
    mov [rbp-80] (i),rax                  ;#0045140F: 48:211105 B0               vu 00 21  1  26      
    cmp rax,1                             ;#00451413: 48:075 01000000            uv 00 01  1  27      
    jl #004515E1                          ;#00451419: 017214 C2010000            v  00 00  1  27      
;    59             dot = result[i]
    mov rdi,[rbp-80] (i)                  ;#0045141F: 48:213175 B0               uv 80 20  1  28      
    mov rsi,[rbp] (result)                ;#00451423: 48:213165 00               vu 40 20  1  28      
    mov rdx,103                           ;#00451427: 48:307302 67000000         uv 04 00  1  29      
    call #00441762 (:%pSubse1is)          ;#0045142E: 350 2F03FFFF               v  00 00  1  29      
    mov [rbp-48] (dot),rax                ;#00451433: 48:211105 D0               uv 00 21  1  30      
;    60             if dot='9' then
    cmp rax,57                            ;#00451437: 48:203370 39               vu 00 01  1  30      
    jne #00451456                         ;#0045143B: 165 19                     v  00 00  1  31      
;    61                 result[i] = '0'
    mov rdi,[rbp-80] (i)                  ;#0045143D: 48:213175 B0               uv 80 20  1  32      
    mov rcx,48                            ;#00451441: 48:307301 30000000         vu 02 00  1  32      
    mov rsi,[rbp] (result)                ;#00451448: 48:213165 00               uv 40 20  1  33      
    mov rax,rbp                           ;#0045144C: 48:213305                  vu 01 20  1  33      
    call #00440EB1 (:%pRepe1is)           ;#0045144F: 350 5DFAFEFF               v  00 00  1  34      
    jmp #004514A6                         ;#00451454: 353 50                     v  00 00  1  35      
;    62             elsif dot!='.' then
    cmp rax,46                            ;#00451456: 48:203370 2E               uv 00 01  1  36      
    je #004514A6                          ;#0045145A: 164 4A                     v  00 00  1  36      
;    63 --              result[i] += 1      --DEV 26/9/9: try dot += 1 result[i] = dot... (better type info)
;    64                 dot += 1
    add rax,1                             ;#0045145C: 48:203300 01               uv 01 01  1  37      
    mov [rbp-48] (dot),rax                ;#00451460: 48:211105 D0               uv 00 21  1  38 01   
;    65                 result[i] = dot
    mov rcx,rax                           ;#00451464: 48:211301                  vu 02 01  1  38      
    mov rdi,[rbp-80] (i)                  ;#00451467: 48:213175 B0               uv 80 20  1  39      
    mov rsi,[rbp] (result)                ;#0045146B: 48:213165 00               vu 40 20  1  39      
    mov rax,rbp                           ;#0045146F: 48:213305                  uv 01 20  1  40      
    call #00440C54 (:%pRepe1)             ;#00451472: 350 DDF7FEFF               v  00 00  1  40      
    mov rax,[rbp] (result)                ;#00451477: 48:213105 00               uv 01 20  1  41      
    mov r15,h4                            ;#0045147B: 49:277 0000000000000040    vu 8000 00  1  41      
    cmp rax,r15                           ;#00451485: 4C:071370                  uv 00 8001  1  42      
    jl #00451495                          ;#00451488: 174 0B                     v  00 00  1  42      
    cmp byte[rbx+rax*4-1],#82             ;#0045148A: 200174203 FF 82            u  00 09  2  43      
    je #004515E1                          ;#0045148F: 017204 4C010000            v  00 00  1  44      
    mov rcx,103                           ;#00451495: 48:307301 67000000         uv 02 00  1  45      
    call #00442A58 (:%opTchkFail)         ;#0045149C: 350 B715FFFF               v  00 00  1  45      
;    66                 exit
    jmp #004515E1                         ;#004514A1: 351 3B010000               v  00 00  1  46      
;    67             end if
;    68             if i=1 then
    mov rcx,[rbp-80] (i)                  ;#004514A6: 48:213115 B0               uv 02 20  1  47      
    cmp rcx,1                             ;#004514AA: 48:203371 01               uv 00 02  1  48 02   
    jne #004515C5                         ;#004514AE: 017205 11010000            v  00 00  1  48      
;    69 --DEV: (oldschool, from when prepend string did not work) [prepend always yields T_Seq now anyways] [DEV: lies, 28/3/2014]
;    70 --              result = prepend(result,'1')
;    71                 result = "1"&result
    mov rdx,rbp                           ;#004514B4: 48:213325                  uv 04 20  1  49      
    lea rdi,qword[#004021C8]              ;#004514B7: 48:215075 0A0DFBFF         vu 80 00  1  49      
    mov rcx,rbp                           ;#004514BE: 48:213315                  uv 02 20  1  50      
    call #00440021 (:%opConcat)           ;#004514C1: 350 5BEBFEFF               v  00 00  1  50      
;    72                 if charflag!='f' then
    mov rdi,[rbp-24] (charflag)           ;#004514C6: 48:213175 E8               uv 80 20  1  51      
    cmp rdi,102                           ;#004514CA: 48:203377 66               uv 00 80  1  52 80   
    je #004515C5                          ;#004514CE: 017204 F1000000            v  00 00  1  52      
;    73                     dot = find('.',result)
    mov rcx,7                             ;#004514D4: 48:307301 07000000         uv 02 00  1  53      
    mov rdx,75                            ;#004514DB: 48:307302 4B000000         vu 04 00  1  53      
    call #004428DB (:%opFrame) (find)     ;#004514E2: 350 F413FFFF               v  00 00  1  54      
    mov qword[rbp] (x),46                 ;#004514E7: 48:307105 00 2E000000      uv 00 20  1  55      
    mov rdi,[rbp+40] (prevebp)            ;#004514EF: 48:213175 28               vu 80 20  1  55      
    mov rax,[rdi]                         ;#004514F3: 48:213007                  uv 01 80  1  58    *80*
    xor rbx,rbx                           ;#004514F6: 48:061333                  vu 08 08  1  58      
    mov r15,h4                            ;#004514F9: 49:277 0000000000000040    uv 8000 00  1  59      
    cmp rax,r15                           ;#00451503: 4C:071370                  uv 00 8001  1  60 8000   
    jl #00451513                          ;#00451506: 174 0B                     v  00 00  1  60      
    add qword[rbx+rax*4-16],1             ;#00451508: 48:203104203 F0 01         u  00 09  3  61      
    cmp eax,103                           ;#0045150E: 075 67000000               vu 00 01  1  63      
    mov [rbp-8] (s),rax                   ;#00451513: 48:211105 F8               uv 00 21  1  64      
    mov qword[retaddr],#00451524          ;#00451517: 48:307105 20 24154500      vu 00 20  1  64      
    jmp #0043DAD6 (code:find)             ;#0045151F: 351 B2C5FEFF               v  00 00  1  65      
    mov [rbp-48] (dot),rax                ;#00451524: 48:211105 D0               uv 00 21  1  66      
;    74                     if dot then
    test rax,rax                          ;#00451528: 48:205300                  vu 00 01  1  66      
    je #004515C5                          ;#0045152B: 017204 94000000            v  00 00  1  67      
;    75                         dotm1 = dot-1
    sub rax,1                             ;#00451531: 48:203350 01               uv 01 01  1  68      
    mov [rbp-56] (dotm1),rax              ;#00451535: 48:211105 C8               uv 00 21  1  69 01   
;    76                         result[dot] = result[dotm1]
    mov rdi,rax                           ;#00451539: 48:211307                  vu 80 01  1  69      
    mov rsi,[rbp] (result)                ;#0045153C: 48:213165 00               uv 40 20  1  70      
    mov rdx,103                           ;#00451540: 48:307302 67000000         vu 04 00  1  70      
    call #00441762 (:%pSubse1is)          ;#00451547: 350 1602FFFF               v  00 00  1  71      
    mov [rbp-88] (symtab[118]),rax        ;#0045154C: 48:211105 A8               uv 00 21  1  72      
    mov rcx,rax                           ;#00451550: 48:211301                  vu 02 01  1  72      
    mov rdi,[rbp-48] (dot)                ;#00451553: 48:213175 D0               uv 80 20  1  73      
    mov rsi,[rbp] (result)                ;#00451557: 48:213165 00               vu 40 20  1  73      
    mov rax,rbp                           ;#0045155B: 48:213305                  uv 01 20  1  74      
    call #00440C54 (:%pRepe1)             ;#0045155E: 350 F1F6FEFF               v  00 00  1  74      
    mov rax,[rbp] (result)                ;#00451563: 48:213105 00               uv 01 20  1  75      
    mov r15,h4                            ;#00451567: 49:277 0000000000000040    vu 8000 00  1  75      
    cmp rax,r15                           ;#00451571: 4C:071370                  uv 00 8001  1  76      
    jl #0045157D                          ;#00451574: 174 07                     v  00 00  1  76      
    cmp byte[rbx+rax*4-1],#82             ;#00451576: 200174203 FF 82            u  00 09  2  77      
    je #00451589                          ;#0045157B: 164 0C                     v  00 00  1  78      
    mov rcx,103                           ;#0045157D: 48:307301 67000000         uv 02 00  1  79      
    call #00442A58 (:%opTchkFail)         ;#00451584: 350 CF14FFFF               v  00 00  1  79      
;    77 --                      result[dotm1] = '.'
;    78                         result[dotm1] = '!'
    mov rsi,rax                           ;#00451589: 48:211306                  uv 40 01  1  80      
    mov rdi,[rbp-56] (dotm1)              ;#0045158C: 48:213175 C8               vu 80 20  1  80      
    mov rcx,33                            ;#00451590: 48:307301 21000000         uv 02 00  1  81      
    mov rax,rbp                           ;#00451597: 48:213305                  vu 01 20  1  81      
    call #00440C54 (:%pRepe1)             ;#0045159A: 350 B5F6FEFF               v  00 00  1  82      
    mov rcx,[rbp] (result)                ;#0045159F: 48:213115 00               uv 02 20  1  83      
    mov r15,h4                            ;#004515A3: 49:277 0000000000000040    vu 8000 00  1  83      
    cmp rcx,r15                           ;#004515AD: 4C:071371                  uv 00 8002  1  84      
    jl #004515B9                          ;#004515B0: 174 07                     v  00 00  1  84      
    cmp byte[rbx+rcx*4-1],#82             ;#004515B2: 200174213 FF 82            u  00 0A  2  85      
    je #004515C5                          ;#004515B7: 164 0C                     v  00 00  1  86      
    mov rcx,103                           ;#004515B9: 48:307301 67000000         uv 02 00  1  87      
    call #00442A58 (:%opTchkFail)         ;#004515C0: 350 9314FFFF               v  00 00  1  87      
;    79 --DEV gives bounds error...
;    80 --DEV I suppose we should check it is a '0' as well.
;    81 --                      result = result[1..length(result)-1]
;    82 --                      exp += 1
;    83                     end if
;    84                 end if
;    85             end if
;    86         end for
    mov rax,[rbp-80] (i)                  ;#004515C5: 48:213105 B0               uv 01 20  1  88      
    mov rdx,1                             ;#004515C9: 48:307302 01000000         vu 04 00  1  88      
    add rax,-1                            ;#004515D0: 48:203300 FF               uv 01 01  1  89      
    cmp rax,rdx                           ;#004515D4: 48:073302                  uv 00 05  1  90 01   
    mov [rbp-80] (i),rax                  ;#004515D7: 48:211105 B0               vu 00 21  1  90      
    jge #0045141F                         ;#004515DB: 017215 3EFEFFFF            v  00 00  1  91      
;    87     end if
;    88 --  if charflag='g' then
;    89 --  if charflag='g' and find('.',result) then   -- find '.' added 9/3/6
;    90     if charflag='g' 
    mov rsi,[rbp-24] (charflag)           ;#004515E1: 48:213165 E8               uv 40 20  1  92      
    cmp rsi,103                           ;#004515E5: 48:203376 67               uv 00 40  1  93 40   
    jne #00451741                         ;#004515E9: 017205 52010000            v  00 00  1  93      
;    91     and (find('.',result) or find('!',result)) then
    mov rcx,7                             ;#004515EF: 48:307301 07000000         uv 02 00  1  94      
    mov rdx,75                            ;#004515F6: 48:307302 4B000000         vu 04 00  1  94      
    call #004428DB (:%opFrame) (find)     ;#004515FD: 350 D912FFFF               v  00 00  1  95      
    mov qword[rbp] (x),46                 ;#00451602: 48:307105 00 2E000000      uv 00 20  1  96      
    mov rdi,[rbp+40] (prevebp)            ;#0045160A: 48:213175 28               vu 80 20  1  96      
    mov rax,[rdi]                         ;#0045160E: 48:213007                  uv 01 80  1  99    *80*
    xor rbx,rbx                           ;#00451611: 48:061333                  vu 08 08  1  99      
    mov r15,h4                            ;#00451614: 49:277 0000000000000040    uv 8000 00  1 100      
    cmp rax,r15                           ;#0045161E: 4C:071370                  uv 00 8001  1 101 8000   
    jl #0045162E                          ;#00451621: 174 0B                     v  00 00  1 101      
    add qword[rbx+rax*4-16],1             ;#00451623: 48:203104203 F0 01         u  00 09  3 102      
    cmp eax,103                           ;#00451629: 075 67000000               vu 00 01  1 104      
    mov [rbp-8] (s),rax                   ;#0045162E: 48:211105 F8               uv 00 21  1 105      
    mov qword[retaddr],#0045163F          ;#00451632: 48:307105 20 3F164500      vu 00 20  1 105      
    jmp #0043DAD6 (code:find)             ;#0045163A: 351 97C4FEFF               v  00 00  1 106      
    test rax,rax                          ;#0045163F: 48:205300                  uv 00 01  1 107      
    jne #0045169D                         ;#00451642: 165 59                     v  00 00  1 107      
    mov rcx,7                             ;#00451644: 48:307301 07000000         uv 02 00  1 108      
    mov rdx,75                            ;#0045164B: 48:307302 4B000000         vu 04 00  1 108      
    call #004428DB (:%opFrame) (find)     ;#00451652: 350 8412FFFF               v  00 00  1 109      
    mov qword[rbp] (x),33                 ;#00451657: 48:307105 00 21000000      uv 00 20  1 110      
    mov rdi,[rbp+40] (prevebp)            ;#0045165F: 48:213175 28               vu 80 20  1 110      
    mov rax,[rdi]                         ;#00451663: 48:213007                  uv 01 80  1 113    *80*
    xor rbx,rbx                           ;#00451666: 48:061333                  vu 08 08  1 113      
    mov r15,h4                            ;#00451669: 49:277 0000000000000040    uv 8000 00  1 114      
    cmp rax,r15                           ;#00451673: 4C:071370                  uv 00 8001  1 115 8000   
    jl #00451683                          ;#00451676: 174 0B                     v  00 00  1 115      
    add qword[rbx+rax*4-16],1             ;#00451678: 48:203104203 F0 01         u  00 09  3 116      
    cmp eax,103                           ;#0045167E: 075 67000000               vu 00 01  1 118      
    mov [rbp-8] (s),rax                   ;#00451683: 48:211105 F8               uv 00 21  1 119      
    mov qword[retaddr],#00451694          ;#00451687: 48:307105 20 94164500      vu 00 20  1 119      
    jmp #0043DAD6 (code:find)             ;#0045168F: 351 42C4FEFF               v  00 00  1 120      
    test rax,rax                          ;#00451694: 48:205300                  uv 00 01  1 121      
    je #00451741                          ;#00451697: 017204 A4000000            v  00 00  1 121      
;    92         tmp = length(result)
    mov rdi,[rbp] (result)                ;#0045169D: 48:213175 00               uv 80 20  1 122      
    mov rcx,[rbx+rdi*4-24]                ;#004516A1: 48:48:213114273 E8         uv 02 88  1 125 80 *80*
    mov [rbp-40] (tmp),rcx                ;#004516A7: 48:211115 D8               uv 00 22  1 126 02   
;    93 --14/1/15:
;    94 --      while tmp>1 and tmp>minfieldwidth do
;    95         while tmp>1 do
    mov rsi,[rbp-40] (tmp)                ;#004516AB: 48:213165 D8               vu 40 20  1 126      
    cmp rsi,1                             ;#004516AF: 48:203376 01               uv 00 40  1 127      
    jle #0045171C                         ;#004516B3: 176 67                     v  00 00  1 127      
;    96             dot = result[tmp]
    mov rdi,rsi                           ;#004516B5: 48:211367                  uv 80 40  1 128      
    mov rsi,[rbp] (result)                ;#004516B8: 48:213165 00               vu 40 20  1 128      
    mov rdx,103                           ;#004516BC: 48:307302 67000000         uv 04 00  1 129      
    call #00441762 (:%pSubse1is)          ;#004516C3: 350 9A00FFFF               v  00 00  1 129      
    mov [rbp-48] (dot),rax                ;#004516C8: 48:211105 D0               uv 00 21  1 130      
;    97             if dot='.' 
    cmp rax,46                            ;#004516CC: 48:203370 2E               vu 00 01  1 130      
    je #004516D8                          ;#004516D0: 164 06                     v  00 00  1 131      
;    98             or dot='!' then
    cmp rax,33                            ;#004516D2: 48:203370 21               uv 00 01  1 132      
    jne #004516F7                         ;#004516D6: 165 1F                     v  00 00  1 132      
;    99                 tmp -= 1
    mov rdi,[rbp-40] (tmp)                ;#004516D8: 48:213175 D8               uv 80 20  1 133      
    sub rdi,1                             ;#004516DC: 48:203357 01               uv 80 80  1 134 80   
    mov rdx,rdi                           ;#004516E0: 48:213327                  uv 04 80  1 135 80   
    mov [rbp-40] (tmp),rdi                ;#004516E3: 48:211175 D8               vu 00 A0  1 135      
    shl rdx,1                             ;#004516E7: 48:321342                  u  04 04  1 136      
    jno #0045171C                         ;#004516EA: 161 30                     v  00 00  1 136      
    lea rdi,[rbp-40] (tmp)                ;#004516EC: 48:215175 D8               uv 80 20  1 137      
    call #00442DA9 (:%pAddiii)            ;#004516F0: 350 B416FFFF               v  00 00  1 137      
;   100                 exit
    jmp #0045171C                         ;#004516F5: 353 25                     v  00 00  1 138      
;   101             end if
;   102             if dot!='0' then exit end if
    cmp rax,48                            ;#004516F7: 48:203370 30               uv 00 01  1 139      
    jne #0045171C                         ;#004516FB: 165 1F                     v  00 00  1 139      
;   103             tmp -= 1
    mov rcx,[rbp-40] (tmp)                ;#004516FD: 48:213115 D8               uv 02 20  1 140      
    sub rcx,1                             ;#00451701: 48:203351 01               uv 02 02  1 141 02   
    mov rdx,rcx                           ;#00451705: 48:213321                  uv 04 02  1 142 02   
    mov [rbp-40] (tmp),rcx                ;#00451708: 48:211115 D8               vu 00 22  1 142      
    shl rdx,1                             ;#0045170C: 48:321342                  u  04 04  1 143      
    jno #004516AB                         ;#0045170F: 161 9A                     v  00 00  1 143      
    lea rdi,[rbp-40] (tmp)                ;#00451711: 48:215175 D8               uv 80 20  1 144      
    call #00442DA9 (:%pAddiii)            ;#00451715: 350 8F16FFFF               v  00 00  1 144      
;   104         end while
    jmp #004516AB                         ;#0045171A: 353 8F                     v  00 00  1 145      
;   105         result = result[1..tmp]
    mov rdx,rbp                           ;#0045171C: 48:213325                  uv 04 20  1 146      
    mov rcx,1                             ;#0045171F: 48:307301 01000000         vu 02 00  1 146      
    push #00451741                        ;#00451726: 150 41174500               uv 00 00  1 147      
    push rdx                              ;#0045172B: 122                        vu 00 04  1 147      
    push qword[rbp-40] (tmp)              ;#0045172C: 377165 D8                  np 00 20  2 148      
    push 1                                ;#0045172F: 152 01                     uv 00 00  1 150      
    mov rsi,[rbp] (result)                ;#00451731: 48:213165 00               vu 40 20  1 150      
    mov rdx,103                           ;#00451735: 48:307302 67000000         uv 04 00  1 151      
    jmp #00440F1F (:%pSubss)              ;#0045173C: 351 DEF7FEFF               v  00 00  1 151      
;   106     end if
;   107     return result
    mov rax,[rbp] (result)                ;#00451741: 48:213105 00               uv 01 20  1 152      
    mov [rbp] (result),rbx                ;#00451745: 48:211135 00               vu 00 28  1 152      
    jmp #0044298D (:%opRetf)              ;#00451749: 351 3F12FFFF               v  00 00  1 153      
;   108 end function
;   109 
;   110 integer init2
;   111         init2 = 0
;   112 
;   113 atom inf,nan
;   114 
;   115 -- do we still need these?? (yes)
;   116 function Nan() -- thread-safe alternative to "nan"
;   117 string res
;   118     res = repeat('n',3)
    mov rdi,rbp                           ;#0045196E: 48:213375                  uv 80 20  1   1      
    mov rax,110                           ;#00451971: 48:307300 6E000000         vu 01 00  1   1      
    mov rcx,3                             ;#00451978: 48:307301 03000000         uv 02 00  1   2      
    call #0043B1E1 (:%opRepCh)            ;#0045197F: 350 5D98FEFF               v  00 00  1   2      
;   119     res[2] = 'a'
    mov rdi,[#00402098] (WIN32)           ;#00451984: 48:213075 0D07FBFF         uv 80 00  1   3      
    mov rcx,97                            ;#0045198B: 48:307301 61000000         vu 02 00  1   3      
    mov rsi,[rbp] (res)                   ;#00451992: 48:213165 00               uv 40 20  1   4      
    mov rax,rbp                           ;#00451996: 48:213305                  vu 01 20  1   4      
    call #00440EB1 (:%pRepe1is)           ;#00451999: 350 13F5FEFF               v  00 00  1   5      
;   120     return res
    mov rax,[rbp] (res)                   ;#0045199E: 48:213105 00               uv 01 20  1   6      
    mov [rbp] (res),rbx                   ;#004519A2: 48:211135 00               vu 00 28  1   6      
    jmp #0044298D (:%opRetf)              ;#004519A6: 351 E20FFFFF               v  00 00  1   7      
;   121 end function
;   122 
;   123 function Inf() -- thread-safe alternative to "inf"
;   124 string res
;   125     res = repeat('i',3)
    mov rdi,rbp                           ;#00451917: 48:213375                  uv 80 20  1   1      
    mov rax,105                           ;#0045191A: 48:307300 69000000         vu 01 00  1   1      
    mov rcx,3                             ;#00451921: 48:307301 03000000         uv 02 00  1   2      
    call #0043B1E1 (:%opRepCh)            ;#00451928: 350 B498FEFF               v  00 00  1   2      
;   126     res[2] = 'n'
    mov rdi,[#00402098] (WIN32)           ;#0045192D: 48:213075 6407FBFF         uv 80 00  1   3      
    mov rcx,110                           ;#00451934: 48:307301 6E000000         vu 02 00  1   3      
    mov rsi,[rbp] (res)                   ;#0045193B: 48:213165 00               uv 40 20  1   4      
    mov rax,rbp                           ;#0045193F: 48:213305                  vu 01 20  1   4      
    call #00440EB1 (:%pRepe1is)           ;#00451942: 350 6AF5FEFF               v  00 00  1   5      
;   127     res[3] = 'f'
    mov rdi,[#004020A0] (LINUX)           ;#00451947: 48:213075 5207FBFF         uv 80 00  1   6      
    mov rcx,102                           ;#0045194E: 48:307301 66000000         vu 02 00  1   6      
    mov rsi,[rbp] (res)                   ;#00451955: 48:213165 00               uv 40 20  1   7      
    mov rax,rbp                           ;#00451959: 48:213305                  vu 01 20  1   7      
    call #00440EB1 (:%pRepe1is)           ;#0045195C: 350 50F5FEFF               v  00 00  1   8      
;   128     return res
    mov rax,[rbp] (res)                   ;#00451961: 48:213105 00               uv 01 20  1   9      
    mov [rbp] (res),rbx                   ;#00451965: 48:211135 00               vu 00 28  1   9      
    jmp #0044298D (:%opRetf)              ;#00451969: 351 1F10FFFF               v  00 00  1  10      
;   129 end function
;   130 
;   131 function sprintf2(atom pf, integer charflag, integer showplus, integer minfieldwidth, integer precision)
    mov rdi,[rbp] (pf)                    ;#0044FD4F: 48:213175 00               uv 80 20  1   1      
    mov r15,h4                            ;#0044FD53: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0044FD5D: 4C:071377                  uv 00 8080  1   2      
    jl #0044FD75                          ;#0044FD60: 174 13                     v  00 00  1   2      
    cmp byte[rbx+rdi*4-1],#12             ;#0044FD62: 200174273 FF 12            u  00 88  2   3      
    je #0044FD75                          ;#0044FD67: 164 0C                     v  00 00  1   4      
    mov rcx,135                           ;#0044FD69: 48:307301 87000000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044FD70: 350 E32CFFFF               v  00 00  1   5      
    mov rcx,[rbp-8] (charflag)            ;#0044FD75: 48:213115 F8               uv 02 20  1   6      
    mov r15,h4                            ;#0044FD79: 49:277 0000000000000040    vu 8000 00  1   6      
    cmp rcx,r15                           ;#0044FD83: 4C:071371                  uv 00 8002  1   7      
    jl #0044FD94                          ;#0044FD86: 174 0C                     v  00 00  1   7      
    mov rcx,136                           ;#0044FD88: 48:307301 88000000         uv 02 00  1   8      
    call #00442A58 (:%opTchkFail)         ;#0044FD8F: 350 C42CFFFF               v  00 00  1   8      
    mov rsi,[rbp-32] (precision)          ;#0044FD94: 48:213165 E0               uv 40 20  1   9      
    mov r15,h4                            ;#0044FD98: 49:277 0000000000000040    vu 8000 00  1   9      
    cmp rsi,r15                           ;#0044FDA2: 4C:071376                  uv 00 8040  1  10      
    jl #0044FDB3                          ;#0044FDA5: 174 0C                     v  00 00  1  10      
    mov rcx,139                           ;#0044FDA7: 48:307301 8B000000         uv 02 00  1  11      
    call #00442A58 (:%opTchkFail)         ;#0044FDAE: 350 A52CFFFF               v  00 00  1  11      
;   132 integer dotdone, nzdigitprinted
;   133 string reve
;   134 integer revelen
;   135 integer expadj
;   136 integer capE    -- 'e' or 'E'
;   137 integer ewk
;   138 integer tmp
;   139 integer digit
;   140 atom f, fwk, epwr
;   141 string result
;   142 integer exp, k
;   143 
;   144 --?result   --DOH, infinite loop! (use puts(1,<string>) instead!)
;   145     f = pf
    mov [rbp-112] (f),rdi                 ;#0044FDB3: 48:211175 90               uv 00 A0  1  12      
    mov r15,h4                            ;#0044FDB7: 49:277 0000000000000040    vu 8000 00  1  12      
    cmp rdi,r15                           ;#0044FDC1: 4C:071377                  uv 00 8080  1  13      
    jl #0044FDCC                          ;#0044FDC4: 174 06                     v  00 00  1  13      
    add qword[rbx+rdi*4-16],1             ;#0044FDC6: 48:203104273 F0 01         u  00 88  3  14      
;   146 --  result = ""
;   147     result = repeat(' ',0)
    lea rdi,[rbp-136] (result)            ;#0044FDCC: 48:215275 78FFFFFF         vu 80 20  1  16      
    mov rax,32                            ;#0044FDD3: 48:307300 20000000         uv 01 00  1  17      
    mov rcx,0                             ;#0044FDDA: 48:307301 00000000         vu 02 00  1  17      
    call #0043B1E1 (:%opRepCh)            ;#0044FDE1: 350 FBB3FEFF               v  00 00  1  18      
;   148     dotdone = 0
    mov [rbp-40] (dotdone),rbx            ;#0044FDE6: 48:211135 D8               uv 00 28  1  19      
;   149     nzdigitprinted = 0
    mov [rbp-48] (nzdigitprinted),rbx     ;#0044FDEA: 48:211135 D0               vu 00 28  1  19      
;   150     if f=nan then
    mov rdi,[#004021F8] (nan)             ;#0044FDEE: 48:213075 0324FBFF         uv 80 00  1  20      
    mov rax,[rbp-112] (f)                 ;#0044FDF5: 48:213105 90               vu 01 20  1  20      
    mov rsi,123                           ;#0044FDF9: 48:307306 7B000000         uv 40 00  1  21      
    mov rdx,149                           ;#0044FE00: 48:307302 95000000         vu 04 00  1  21      
    call #0043FAF6 (:%opJccE)             ;#0044FE07: 350 EAFCFEFF               v  00 00  1  22      
    jne #0044FE33                         ;#0044FE0C: 165 25                     v  00 00  1  23      
;   151 --DEV not thread safe
;   152 --      return "nan"
;   153         return Nan()
    mov rcx,1                             ;#0044FE0E: 48:307301 01000000         uv 02 00  1  24      
    mov rdx,125                           ;#0044FE15: 48:307302 7D000000         vu 04 00  1  24      
    call #004428DB (:%opFrame) (Nan)      ;#0044FE1C: 350 BA2AFFFF               v  00 00  1  25      
    mov qword[retaddr],#0044FE2E          ;#0044FE21: 48:307105 20 2EFE4400      uv 00 20  1  26      
    jmp #0045196E (code:Nan)              ;#0044FE29: 351 401B0000               v  00 00  1  26      
    jmp #0044298D (:%opRetf)              ;#0044FE2E: 351 5A2BFFFF               v  00 00  1  27      
;   154     end if
;   155     if f<0 then
    xor rdi,rdi                           ;#0044FE33: 48:061377                  uv 80 80  1  28      
    mov rax,[rbp-112] (f)                 ;#0044FE36: 48:213105 90               vu 01 20  1  28      
    mov rsi,25                            ;#0044FE3A: 48:307306 19000000         uv 40 00  1  29      
    mov rdx,149                           ;#0044FE41: 48:307302 95000000         vu 04 00  1  29      
    call #0043FA81 (:%opJcc)              ;#0044FE48: 350 34FCFEFF               v  00 00  1  30      
    jge #0044FE78                         ;#0044FE4D: 175 29                     v  00 00  1  31      
;   156 --      result = "-"
;   157         result = repeat('-',1)
    lea rdi,[rbp-136] (result)            ;#0044FE4F: 48:215275 78FFFFFF         uv 80 20  1  32      
    mov rax,45                            ;#0044FE56: 48:307300 2D000000         vu 01 00  1  32      
    mov rcx,1                             ;#0044FE5D: 48:307301 01000000         uv 02 00  1  33      
    call #0043B1E1 (:%opRepCh)            ;#0044FE64: 350 78B3FEFF               v  00 00  1  33      
;   158         f = -f
    lea rdi,[rbp-112] (f)                 ;#0044FE69: 48:215175 90               uv 80 20  1  34      
    mov rcx,[rbp-112] (f)                 ;#0044FE6D: 48:213115 90               vu 02 20  1  34      
    call #0043F746 (:%opUminus)           ;#0044FE71: 350 D0F8FEFF               v  00 00  1  35      
    jmp #0044FE9B                         ;#0044FE76: 353 23                     v  00 00  1  36      
;   159     elsif showplus then
    mov rsi,[rbp-16] (showplus)           ;#0044FE78: 48:213165 F0               uv 40 20  1  37      
    test rsi,rsi                          ;#0044FE7C: 48:205366                  uv 00 40  1  38 40   
    je #0044FE9B                          ;#0044FE7F: 164 1A                     v  00 00  1  38      
;   160 --      result = "+"
;   161         result = repeat('+',1)
    lea rdi,[rbp-136] (result)            ;#0044FE81: 48:215275 78FFFFFF         uv 80 20  1  39      
    mov rax,43                            ;#0044FE88: 48:307300 2B000000         vu 01 00  1  39      
    mov rcx,1                             ;#0044FE8F: 48:307301 01000000         uv 02 00  1  40      
    call #0043B1E1 (:%opRepCh)            ;#0044FE96: 350 46B3FEFF               v  00 00  1  40      
;   162     end if
;   163     exp = 0
    mov [rbp-144] (exp),rbx               ;#0044FE9B: 48:211235 70FFFFFF         uv 00 28  1  41      
;   164     if f=nan then
    mov rdi,[#004021F8] (nan)             ;#0044FEA2: 48:213075 4F23FBFF         vu 80 00  1  41      
    mov rax,[rbp-112] (f)                 ;#0044FEA9: 48:213105 90               uv 01 20  1  42      
    mov rsi,123                           ;#0044FEAD: 48:307306 7B000000         vu 40 00  1  42      
    mov rdx,149                           ;#0044FEB4: 48:307302 95000000         uv 04 00  1  43      
    call #0043FAF6 (:%opJccE)             ;#0044FEBB: 350 36FCFEFF               v  00 00  1  43      
    jne #0044FF3C                         ;#0044FEC0: 165 7A                     v  00 00  1  44      
;   165 --      return result&"nan"
;   166         return result&Nan()
    mov rcx,1                             ;#0044FEC2: 48:307301 01000000         uv 02 00  1  45      
    mov rdx,125                           ;#0044FEC9: 48:307302 7D000000         vu 04 00  1  45      
    call #004428DB (:%opFrame) (Nan)      ;#0044FED0: 350 062AFFFF               v  00 00  1  46      
    mov qword[retaddr],#0044FEE2          ;#0044FED5: 48:307105 20 E2FE4400      uv 00 20  1  47      
    jmp #0045196E (code:Nan)              ;#0044FEDD: 351 8C1A0000               v  00 00  1  47      
    push rax                              ;#0044FEE2: 120                        uv 00 01  1  48      
    mov rcx,[rbp-160] (symtab[157])       ;#0044FEE3: 48:213215 60FFFFFF         vu 02 20  1  48      
    mov r15,h4                            ;#0044FEEA: 49:277 0000000000000040    uv 8000 00  1  49      
    cmp rcx,r15                           ;#0044FEF4: 4C:071371                  uv 00 8002  1  50 8000   
    jle #0044FF09                         ;#0044FEF7: 176 10                     v  00 00  1  50      
    sub qword[rbx+rcx*4-16],1             ;#0044FEF9: 48:203154213 F0 01         u  00 0A  3  51      
    jne #0044FF09                         ;#0044FEFF: 165 08                     v  00 00  1  53      
    mov rdx,rcx                           ;#0044FF01: 48:213321                  uv 04 02  1  54      
    call #004422DA (:%pDealloc)           ;#0044FF04: 350 D123FFFF               v  00 00  1  54      
    pop dword[rbp-160] (symtab[157])      ;#0044FF09: 217205 60FFFFFF            np 00 20  3  55      
    lea rdx,[rbp-168] (symtab[158])       ;#0044FF0F: 48:215225 58FFFFFF         uv 04 20  1  58      
    lea rdi,[rbp-136] (result)            ;#0044FF16: 48:215275 78FFFFFF         vu 80 20  1  58      
    lea rcx,[rbp-160] (symtab[157])       ;#0044FF1D: 48:215215 60FFFFFF         uv 02 20  1  59      
    call #00440021 (:%opConcat)           ;#0044FF24: 350 F800FFFF               v  00 00  1  59      
    mov rax,[rbp-168] (symtab[158])       ;#0044FF29: 48:213205 58FFFFFF         uv 01 20  1  60      
    mov [rbp-168] (symtab[158]),rbx       ;#0044FF30: 48:211235 58FFFFFF         vu 00 28  1  60      
    jmp #0044298D (:%opRetf)              ;#0044FF37: 351 512AFFFF               v  00 00  1  61      
;   167     end if
;   168     if f=inf then
    mov rdi,[#004021F0] (inf)             ;#0044FF3C: 48:213075 AD22FBFF         uv 80 00  1  62      
    mov rax,[rbp-112] (f)                 ;#0044FF43: 48:213105 90               vu 01 20  1  62      
    mov rsi,122                           ;#0044FF47: 48:307306 7A000000         uv 40 00  1  63      
    mov rdx,149                           ;#0044FF4E: 48:307302 95000000         vu 04 00  1  63      
    call #0043FAF6 (:%opJccE)             ;#0044FF55: 350 9CFBFEFF               v  00 00  1  64      
    jne #0044FFD6                         ;#0044FF5A: 165 7A                     v  00 00  1  65      
;   169 --      return result&"inf"
;   170         return result&Inf()
    mov rcx,1                             ;#0044FF5C: 48:307301 01000000         uv 02 00  1  66      
    mov rdx,130                           ;#0044FF63: 48:307302 82000000         vu 04 00  1  66      
    call #004428DB (:%opFrame) (Inf)      ;#0044FF6A: 350 6C29FFFF               v  00 00  1  67      
    mov qword[retaddr],#0044FF7C          ;#0044FF6F: 48:307105 20 7CFF4400      uv 00 20  1  68      
    jmp #00451917 (code:Inf)              ;#0044FF77: 351 9B190000               v  00 00  1  68      
    push rax                              ;#0044FF7C: 120                        uv 00 01  1  69      
    mov rsi,[rbp-168] (symtab[158])       ;#0044FF7D: 48:213265 58FFFFFF         vu 40 20  1  69      
    mov r15,h4                            ;#0044FF84: 49:277 0000000000000040    uv 8000 00  1  70      
    cmp rsi,r15                           ;#0044FF8E: 4C:071376                  uv 00 8040  1  71 8000   
    jle #0044FFA3                         ;#0044FF91: 176 10                     v  00 00  1  71      
    sub qword[rbx+rsi*4-16],1             ;#0044FF93: 48:203154263 F0 01         u  00 48  3  72      
    jne #0044FFA3                         ;#0044FF99: 165 08                     v  00 00  1  74      
    mov rdx,rsi                           ;#0044FF9B: 48:213326                  uv 04 40  1  75      
    call #004422DA (:%pDealloc)           ;#0044FF9E: 350 3723FFFF               v  00 00  1  75      
    pop dword[rbp-168] (symtab[158])      ;#0044FFA3: 217205 58FFFFFF            np 00 20  3  76      
    lea rdx,[rbp-160] (symtab[157])       ;#0044FFA9: 48:215225 60FFFFFF         uv 04 20  1  79      
    lea rdi,[rbp-136] (result)            ;#0044FFB0: 48:215275 78FFFFFF         vu 80 20  1  79      
    lea rcx,[rbp-168] (symtab[158])       ;#0044FFB7: 48:215215 58FFFFFF         uv 02 20  1  80      
    call #00440021 (:%opConcat)           ;#0044FFBE: 350 5E00FFFF               v  00 00  1  80      
    mov rax,[rbp-160] (symtab[157])       ;#0044FFC3: 48:213205 60FFFFFF         uv 01 20  1  81      
    mov [rbp-160] (symtab[157]),rbx       ;#0044FFCA: 48:211235 60FFFFFF         vu 00 28  1  81      
    jmp #0044298D (:%opRetf)              ;#0044FFD1: 351 B729FFFF               v  00 00  1  82      
;   171     end if
;   172     if f>=10 then
    mov rdi,10                            ;#0044FFD6: 48:307307 0A000000         uv 80 00  1  83      
    mov rax,[rbp-112] (f)                 ;#0044FFDD: 48:213105 90               vu 01 20  1  83      
    mov rsi,49                            ;#0044FFE1: 48:307306 31000000         uv 40 00  1  84      
    mov rdx,149                           ;#0044FFE8: 48:307302 95000000         vu 04 00  1  84      
    call #0043FA81 (:%opJcc)              ;#0044FFEF: 350 8DFAFEFF               v  00 00  1  85      
    jl #00450075                          ;#0044FFF4: 174 7F                     v  00 00  1  86      
;   173         fwk = f
    mov rcx,[rbp-112] (f)                 ;#0044FFF6: 48:213115 90               uv 02 20  1  87      
    mov [rbp-120] (fwk),rcx               ;#0044FFFA: 48:211115 88               uv 00 22  1  88 02   
    mov r15,h4                            ;#0044FFFE: 49:277 0000000000000040    vu 8000 00  1  88      
    cmp rcx,r15                           ;#00450008: 4C:071371                  uv 00 8002  1  89      
    jl #00450013                          ;#0045000B: 174 06                     v  00 00  1  89      
    add qword[rbx+rcx*4-16],1             ;#0045000D: 48:203104213 F0 01         u  00 0A  3  90      
;   174         while fwk>=10 do
    mov rdi,10                            ;#00450013: 48:307307 0A000000         vu 80 00  1  92      
    mov rax,[rbp-120] (fwk)               ;#0045001A: 48:213105 88               uv 01 20  1  93      
    mov rsi,49                            ;#0045001E: 48:307306 31000000         vu 40 00  1  93      
    mov rdx,150                           ;#00450025: 48:307302 96000000         uv 04 00  1  94      
    call #0043FA81 (:%opJcc)              ;#0045002C: 350 50FAFEFF               v  00 00  1  94      
    jl #004500DA                          ;#00450031: 017214 A3000000            v  00 00  1  95      
;   175             exp += 1
    mov rdi,[rbp-144] (exp)               ;#00450037: 48:213275 70FFFFFF         uv 80 20  1  96      
    add rdi,1                             ;#0045003E: 48:203307 01               uv 80 80  1  97 80   
    mov rdx,rdi                           ;#00450042: 48:213327                  uv 04 80  1  98 80   
    mov [rbp-144] (exp),rdi               ;#00450045: 48:211275 70FFFFFF         vu 00 A0  1  98      
    shl rdx,1                             ;#0045004C: 48:321342                  u  04 04  1  99      
    jno #0045005D                         ;#0045004F: 161 0C                     v  00 00  1  99      
    lea rdi,[rbp-144] (exp)               ;#00450051: 48:215275 70FFFFFF         uv 80 20  1 100      
    call #00442DA9 (:%pAddiii)            ;#00450058: 350 4C2DFFFF               v  00 00  1 100      
;   176             fwk /= 10
    lea rdi,[rbp-120] (fwk)               ;#0045005D: 48:215175 88               uv 80 20  1 101      
    mov rcx,[rbp-120] (fwk)               ;#00450061: 48:213115 88               vu 02 20  1 101      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450065: 48:213005 7C20FBFF         uv 01 00  1 102      
    call #0043F564 (:%opDiv)              ;#0045006C: 350 F3F4FEFF               v  00 00  1 102      
;   177         end while
    jmp #00450013                         ;#00450071: 353 A0                     v  00 00  1 103      
    jmp #004500DA                         ;#00450073: 353 65                     v  00 00  1 104      
;   178     else
;   179         while f<1 and f!=0 do
    mov rdi,1                             ;#00450075: 48:307307 01000000         uv 80 00  1 105      
    mov rax,[rbp-112] (f)                 ;#0045007C: 48:213105 90               vu 01 20  1 105      
    mov rsi,26                            ;#00450080: 48:307306 1A000000         uv 40 00  1 106      
    mov rdx,149                           ;#00450087: 48:307302 95000000         vu 04 00  1 106      
    call #0043FA81 (:%opJcc)              ;#0045008E: 350 EEF9FEFF               v  00 00  1 107      
    jge #004500DA                         ;#00450093: 175 45                     v  00 00  1 108      
    mov rsi,[rbp-112] (f)                 ;#00450095: 48:213165 90               uv 40 20  1 109      
    cmp rsi,0                             ;#00450099: 48:203376 00               uv 00 40  1 110 40   
    je #004500DA                          ;#0045009D: 164 3B                     v  00 00  1 110      
;   180             exp -= 1
    mov rdi,[rbp-144] (exp)               ;#0045009F: 48:213275 70FFFFFF         uv 80 20  1 111      
    sub rdi,1                             ;#004500A6: 48:203357 01               uv 80 80  1 112 80   
    mov rdx,rdi                           ;#004500AA: 48:213327                  uv 04 80  1 113 80   
    mov [rbp-144] (exp),rdi               ;#004500AD: 48:211275 70FFFFFF         vu 00 A0  1 113      
    shl rdx,1                             ;#004500B4: 48:321342                  u  04 04  1 114      
    jno #004500C5                         ;#004500B7: 161 0C                     v  00 00  1 114      
    lea rdi,[rbp-144] (exp)               ;#004500B9: 48:215275 70FFFFFF         uv 80 20  1 115      
    call #00442DA9 (:%pAddiii)            ;#004500C0: 350 E42CFFFF               v  00 00  1 115      
;   181             f *= 10
    lea rdi,[rbp-112] (f)                 ;#004500C5: 48:215175 90               uv 80 20  1 116      
    mov rcx,rsi                           ;#004500C9: 48:211361                  vu 02 40  1 116      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#004500CC: 48:213005 1520FBFF         uv 01 00  1 117      
    call #0043F67C (:%opMul)              ;#004500D3: 350 A4F5FEFF               v  00 00  1 117      
;   182         end while
    jmp #00450075                         ;#004500D8: 353 9B                     v  00 00  1 118      
;   183     end if
;   184     capE = 'e'
    mov qword[rbp-80] (capE),101          ;#004500DA: 48:307105 B0 65000000      uv 00 20  1 119      
;   185     if charflag<'a' then
    mov rcx,[rbp-8] (charflag)            ;#004500E2: 48:213115 F8               vu 02 20  1 119      
    cmp rcx,97                            ;#004500E6: 48:203371 61               uv 00 02  1 120      
    jge #0045010D                         ;#004500EA: 175 21                     v  00 00  1 120      
;   186         charflag += 32
    add rcx,32                            ;#004500EC: 48:203301 20               uv 02 02  1 121      
    mov rdx,rcx                           ;#004500F0: 48:213321                  uv 04 02  1 122 02   
    mov [rbp-8] (charflag),rcx            ;#004500F3: 48:211115 F8               vu 00 22  1 122      
    shl rdx,1                             ;#004500F7: 48:321342                  u  04 04  1 123      
    jno #00450105                         ;#004500FA: 161 09                     v  00 00  1 123      
    lea rdi,[rbp-8] (charflag)            ;#004500FC: 48:215175 F8               uv 80 20  1 124      
    call #00442DA9 (:%pAddiii)            ;#00450100: 350 A42CFFFF               v  00 00  1 124      
;   187         capE = 'E'
    mov qword[rbp-80] (capE),69           ;#00450105: 48:307105 B0 45000000      uv 00 20  1 125      
;   188     end if
;   189 --  if charflag='e' or (charflag='g' and (exp>9 or exp<-4)) then
;   190     if charflag='e' or (charflag='g' and (exp>precision or exp<-4)) then
    cmp rcx,101                           ;#0045010D: 48:203371 65               vu 00 02  1 125      
    je #00450137                          ;#00450111: 164 24                     v  00 00  1 126      
    cmp rcx,103                           ;#00450113: 48:203371 67               uv 00 02  1 127      
    jne #00450ADF                         ;#00450117: 017205 C2090000            v  00 00  1 127      
    mov rdi,[rbp-144] (exp)               ;#0045011D: 48:213275 70FFFFFF         uv 80 20  1 128      
    mov rsi,[rbp-32] (precision)          ;#00450124: 48:213165 E0               vu 40 20  1 128      
    cmp rdi,rsi                           ;#00450128: 48:071367                  uv 00 C0  1 129      
    jg #00450137                          ;#0045012B: 177 0A                     v  00 00  1 129      
    cmp rdi,-4                            ;#0045012D: 48:203377 FC               uv 00 80  1 130      
    jge #00450ADF                         ;#00450131: 017215 A8090000            v  00 00  1 130      
;   191         ewk = exp
    mov rax,[rbp-144] (exp)               ;#00450137: 48:213205 70FFFFFF         uv 01 20  1 131      
    mov [rbp-88] (ewk),rax                ;#0045013E: 48:211105 A8               uv 00 21  1 132 01   
;   192         if exp>0 then
    cmp rax,0                             ;#00450142: 48:203370 00               vu 00 01  1 132      
    jle #004501ED                         ;#00450146: 017216 A1000000            v  00 00  1 133      
;   193             epwr = power(10,exp)
    lea rdi,[rbp-128] (epwr)              ;#0045014C: 48:215175 80               uv 80 20  1 134      
    mov rcx,rax                           ;#00450150: 48:211301                  vu 02 01  1 134      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450153: 48:213005 8E1FFBFF         uv 01 00  1 135      
    call #0043B324 (:%opPow)              ;#0045015A: 350 C5B1FEFF               v  00 00  1 135      
;   194             fwk = 0--epwr
    mov rdx,[rbp-120] (fwk)               ;#0045015F: 48:213125 88               uv 04 20  1 136      
    mov r15,h4                            ;#00450163: 49:277 0000000000000040    vu 8000 00  1 136      
    cmp rdx,r15                           ;#0045016D: 4C:071372                  uv 00 8004  1 137      
    mov [rbp-120] (fwk),rbx               ;#00450170: 48:211135 88               vu 00 28  1 137      
    jle #00450183                         ;#00450174: 176 0D                     v  00 00  1 138      
    sub qword[rbx+rdx*4-16],1             ;#00450176: 48:203154223 F0 01         u  00 0C  3 139      
    jne #00450183                         ;#0045017C: 165 05                     v  00 00  1 141      
    call #004422DA (:%pDealloc)           ;#0045017E: 350 5721FFFF               v  00 00  1 142      
;   195             digit = 0
    mov [rbp-104] (digit),rbx             ;#00450183: 48:211135 98               uv 00 28  1 143      
;   196             while f>=fwk+epwr do
    lea rdi,[rbp-176] (symtab[161])       ;#00450187: 48:215275 50FFFFFF         vu 80 20  1 143      
    mov rcx,[rbp-120] (fwk)               ;#0045018E: 48:213115 88               uv 02 20  1 144      
    mov rax,[rbp-128] (epwr)              ;#00450192: 48:213105 80               vu 01 20  1 144      
    call #0043F4AF (:%opAdd)              ;#00450196: 350 14F3FEFF               v  00 00  1 145      
    mov rdi,[rbp-176] (symtab[161])       ;#0045019B: 48:213275 50FFFFFF         uv 80 20  1 146      
    mov rax,[rbp-112] (f)                 ;#004501A2: 48:213105 90               vu 01 20  1 146      
    mov rsi,161                           ;#004501A6: 48:307306 A1000000         uv 40 00  1 147      
    mov rdx,149                           ;#004501AD: 48:307302 95000000         vu 04 00  1 147      
    call #0043FA81 (:%opJcc)              ;#004501B4: 350 C8F8FEFF               v  00 00  1 148      
    jl #00450215                          ;#004501B9: 174 5A                     v  00 00  1 149      
;   197                 fwk += epwr
    lea rdi,[rbp-120] (fwk)               ;#004501BB: 48:215175 88               uv 80 20  1 150      
    mov rcx,[rbp-120] (fwk)               ;#004501BF: 48:213115 88               vu 02 20  1 150      
    mov rax,[rbp-128] (epwr)              ;#004501C3: 48:213105 80               uv 01 20  1 151      
    call #0043F4AF (:%opAdd)              ;#004501C7: 350 E3F2FEFF               v  00 00  1 151      
;   198                 digit += 1
    mov rsi,[rbp-104] (digit)             ;#004501CC: 48:213165 98               uv 40 20  1 152      
    add rsi,1                             ;#004501D0: 48:203306 01               uv 40 40  1 153 40   
    mov rdx,rsi                           ;#004501D4: 48:213326                  uv 04 40  1 154 40   
    mov [rbp-104] (digit),rsi             ;#004501D7: 48:211165 98               vu 00 60  1 154      
    shl rdx,1                             ;#004501DB: 48:321342                  u  04 04  1 155      
    jno #00450187                         ;#004501DE: 161 A7                     v  00 00  1 155      
    lea rdi,[rbp-104] (digit)             ;#004501E0: 48:215175 98               uv 80 20  1 156      
    call #00442DA9 (:%pAddiii)            ;#004501E4: 350 C02BFFFF               v  00 00  1 156      
;   199             end while
    jmp #00450187                         ;#004501E9: 353 9C                     v  00 00  1 157      
    jmp #00450215                         ;#004501EB: 353 28                     v  00 00  1 158      
;   200         else
;   201             digit = floor(f)
    lea rdi,[rbp-104] (digit)             ;#004501ED: 48:215175 98               uv 80 20  1 159      
    mov rax,[rbp-112] (f)                 ;#004501F1: 48:213105 90               vu 01 20  1 159      
    call #0043F81C (:%opFloor)            ;#004501F5: 350 22F6FEFF               v  00 00  1 160      
    mov r15,h4                            ;#004501FA: 49:277 0000000000000040    uv 8000 00  1 161      
    cmp rax,r15                           ;#00450204: 4C:071370                  uv 00 8001  1 162 8000   
    jl #00450215                          ;#00450207: 174 0C                     v  00 00  1 162      
    mov rcx,148                           ;#00450209: 48:307301 94000000         uv 02 00  1 163      
    call #00442A58 (:%opTchkFail)         ;#00450210: 350 4328FFFF               v  00 00  1 163      
;   202         end if
;   203         result &= digit+'0'
    mov rdi,[rbp-104] (digit)             ;#00450215: 48:213175 98               uv 80 20  1 164      
    mov r15,h4                            ;#00450219: 49:277 0000000000000040    vu 8000 00  1 164      
    cmp rdi,r15                           ;#00450223: 4C:071377                  uv 00 8080  1 165      
    jne #00450234                         ;#00450226: 165 0C                     v  00 00  1 165      
    mov rsi,148                           ;#00450228: 48:307306 94000000         uv 40 00  1 166      
    call #00442D75 (:%pUnassigned)        ;#0045022F: 350 412BFFFF               v  00 00  1 166      
    lea rdi,[rbp-176] (symtab[161])       ;#00450234: 48:215275 50FFFFFF         uv 80 20  1 167      
    mov rcx,[rbp-104] (digit)             ;#0045023B: 48:213115 98               vu 02 20  1 167      
    mov rax,[MB_ICONEXCLAMATION]          ;#0045023F: 48:213005 321FFBFF         uv 01 00  1 168      
    call #0043F4AF (:%opAdd)              ;#00450246: 350 64F2FEFF               v  00 00  1 168      
    lea rdx,[rbp-136] (result)            ;#0045024B: 48:215225 78FFFFFF         uv 04 20  1 169      
    lea rdi,[rbp-136] (result)            ;#00450252: 48:215275 78FFFFFF         vu 80 20  1 169      
    lea rcx,[rbp-176] (symtab[161])       ;#00450259: 48:215215 50FFFFFF         uv 02 20  1 170      
    xor rax,rax                           ;#00450260: 48:061300                  vu 01 01  1 170      
    call #0043FC15 (:%opApnd)             ;#00450263: 350 ADF9FEFF               v  00 00  1 171      
    mov rsi,[rbp-136] (result)            ;#00450268: 48:213265 78FFFFFF         uv 40 20  1 172      
    mov r15,h4                            ;#0045026F: 49:277 0000000000000040    vu 8000 00  1 172      
    cmp rsi,r15                           ;#00450279: 4C:071376                  uv 00 8040  1 173      
    jl #00450285                          ;#0045027C: 174 07                     v  00 00  1 173      
    cmp byte[rbx+rsi*4-1],#82             ;#0045027E: 200174263 FF 82            u  00 48  2 174      
    je #00450291                          ;#00450283: 164 0C                     v  00 00  1 175      
    mov rcx,152                           ;#00450285: 48:307301 98000000         uv 02 00  1 176      
    call #00442A58 (:%opTchkFail)         ;#0045028C: 350 C727FFFF               v  00 00  1 176      
;   204         expadj = 1
    mov qword[rbp-72] (expadj),1          ;#00450291: 48:307105 B8 01000000      uv 00 20  1 177      
;   205         if precision>0 then
    mov rdi,[rbp-32] (precision)          ;#00450299: 48:213175 E0               vu 80 20  1 177      
    cmp rdi,0                             ;#0045029D: 48:203377 00               uv 00 80  1 178      
    jle #00450526                         ;#004502A1: 017216 7F020000            v  00 00  1 178      
;   206             result &= '.'
    lea rdx,[rbp-136] (result)            ;#004502A7: 48:215225 78FFFFFF         uv 04 20  1 179      
    lea rdi,[rbp-136] (result)            ;#004502AE: 48:215275 78FFFFFF         vu 80 20  1 179      
    lea rcx,qword[#004021C0]              ;#004502B5: 48:215015 041FFBFF         uv 02 00  1 180      
    xor rax,rax                           ;#004502BC: 48:061300                  vu 01 01  1 180      
    call #0043FC15 (:%opApnd)             ;#004502BF: 350 51F9FEFF               v  00 00  1 181      
    mov rcx,[rbp-136] (result)            ;#004502C4: 48:213215 78FFFFFF         uv 02 20  1 182      
    mov r15,h4                            ;#004502CB: 49:277 0000000000000040    vu 8000 00  1 182      
    cmp rcx,r15                           ;#004502D5: 4C:071371                  uv 00 8002  1 183      
    jl #004502E1                          ;#004502D8: 174 07                     v  00 00  1 183      
    cmp byte[rbx+rcx*4-1],#82             ;#004502DA: 200174213 FF 82            u  00 0A  2 184      
    je #004502ED                          ;#004502DF: 164 0C                     v  00 00  1 185      
    mov rcx,152                           ;#004502E1: 48:307301 98000000         uv 02 00  1 186      
    call #00442A58 (:%opTchkFail)         ;#004502E8: 350 6B27FFFF               v  00 00  1 186      
;   207             dotdone = 1
    mov qword[rbp-40] (dotdone),1         ;#004502ED: 48:307105 D8 01000000      uv 00 20  1 187      
;   208             for i=1 to precision do
    mov rax,[rbp-32] (precision)          ;#004502F5: 48:213105 E0               vu 01 20  1 187      
    mov [rbp-184] (symtab[162]),rax       ;#004502F9: 48:211205 48FFFFFF         uv 00 21  1 188      
    mov qword[rbp-192] (i),1              ;#00450300: 48:307205 40FFFFFF 01000000 vu 00 20  1 188      
    lea rdx,[rax+1]                       ;#0045030B: 48:215120 01               uv 04 01  1 189      
    shl rdx,1                             ;#0045030F: 48:321342                  u  04 04  1 190      
    jno #00450329                         ;#00450312: 161 15                     v  00 00  1 190      
    mov al,121                            ;#00450314: 260 79                     uv 01 00  1 191      
    mov rdi,162                           ;#00450316: 48:307307 A2000000         vu 80 00  1 191      
    mov rsi,26                            ;#0045031D: 48:307306 1A000000         uv 40 00  1 192      
    call #00442DC8 (:%pRTErn)             ;#00450324: 350 9F2AFFFF               v  00 00  1 192      
    cmp rax,1                             ;#00450329: 48:075 01000000            uv 00 01  1 193      
    jl #0045058C                          ;#0045032F: 017214 57020000            v  00 00  1 193      
;   209                 if ewk>0 then
    mov rsi,[rbp-88] (ewk)                ;#00450335: 48:213165 A8               uv 40 20  1 194      
    cmp rsi,0                             ;#00450339: 48:203376 00               uv 00 40  1 195 40   
    jle #00450435                         ;#0045033D: 017216 F2000000            v  00 00  1 195      
;   210                     f -= fwk
    mov rdi,[rbp-120] (fwk)               ;#00450343: 48:213175 88               uv 80 20  1 196      
    mov r15,h4                            ;#00450347: 49:277 0000000000000040    vu 8000 00  1 196      
    cmp rdi,r15                           ;#00450351: 4C:071377                  uv 00 8080  1 197      
    jne #00450362                         ;#00450354: 165 0C                     v  00 00  1 197      
    mov rsi,150                           ;#00450356: 48:307306 96000000         uv 40 00  1 198      
    call #00442D75 (:%pUnassigned)        ;#0045035D: 350 132AFFFF               v  00 00  1 198      
    lea rdi,[rbp-112] (f)                 ;#00450362: 48:215175 90               uv 80 20  1 199      
    mov rcx,[rbp-112] (f)                 ;#00450366: 48:213115 90               vu 02 20  1 199      
    mov rax,[rbp-120] (fwk)               ;#0045036A: 48:213105 88               uv 01 20  1 200      
    call #0043F4D8 (:%opSub)              ;#0045036E: 350 65F1FEFF               v  00 00  1 200      
;   211                     ewk -= 1
    mov rsi,[rbp-88] (ewk)                ;#00450373: 48:213165 A8               uv 40 20  1 201      
    sub rsi,1                             ;#00450377: 48:203356 01               uv 40 40  1 202 40   
    mov rdx,rsi                           ;#0045037B: 48:213326                  uv 04 40  1 203 40   
    mov [rbp-88] (ewk),rsi                ;#0045037E: 48:211165 A8               vu 00 60  1 203      
    shl rdx,1                             ;#00450382: 48:321342                  u  04 04  1 204      
    jno #00450390                         ;#00450385: 161 09                     v  00 00  1 204      
    lea rdi,[rbp-88] (ewk)                ;#00450387: 48:215175 A8               uv 80 20  1 205      
    call #00442DA9 (:%pAddiii)            ;#0045038B: 350 192AFFFF               v  00 00  1 205      
;   212                     epwr = power(10,ewk)
    lea rdi,[rbp-128] (epwr)              ;#00450390: 48:215175 80               uv 80 20  1 206      
    mov rcx,rsi                           ;#00450394: 48:211361                  vu 02 40  1 206      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450397: 48:213005 4A1DFBFF         uv 01 00  1 207      
    call #0043B324 (:%opPow)              ;#0045039E: 350 81AFFEFF               v  00 00  1 207      
;   213                     fwk = 0--epwr
    mov rdx,[rbp-120] (fwk)               ;#004503A3: 48:213125 88               uv 04 20  1 208      
    mov r15,h4                            ;#004503A7: 49:277 0000000000000040    vu 8000 00  1 208      
    cmp rdx,r15                           ;#004503B1: 4C:071372                  uv 00 8004  1 209      
    mov [rbp-120] (fwk),rbx               ;#004503B4: 48:211135 88               vu 00 28  1 209      
    jle #004503C7                         ;#004503B8: 176 0D                     v  00 00  1 210      
    sub qword[rbx+rdx*4-16],1             ;#004503BA: 48:203154223 F0 01         u  00 0C  3 211      
    jne #004503C7                         ;#004503C0: 165 05                     v  00 00  1 213      
    call #004422DA (:%pDealloc)           ;#004503C2: 350 131FFFFF               v  00 00  1 214      
;   214                     digit = 0
    mov [rbp-104] (digit),rbx             ;#004503C7: 48:211135 98               uv 00 28  1 215      
;   215                     while f>=fwk+epwr do
    lea rdi,[rbp-176] (symtab[161])       ;#004503CB: 48:215275 50FFFFFF         vu 80 20  1 215      
    mov rcx,[rbp-120] (fwk)               ;#004503D2: 48:213115 88               uv 02 20  1 216      
    mov rax,[rbp-128] (epwr)              ;#004503D6: 48:213105 80               vu 01 20  1 216      
    call #0043F4AF (:%opAdd)              ;#004503DA: 350 D0F0FEFF               v  00 00  1 217      
    mov rdi,[rbp-176] (symtab[161])       ;#004503DF: 48:213275 50FFFFFF         uv 80 20  1 218      
    mov rax,[rbp-112] (f)                 ;#004503E6: 48:213105 90               vu 01 20  1 218      
    mov rsi,161                           ;#004503EA: 48:307306 A1000000         uv 40 00  1 219      
    mov rdx,149                           ;#004503F1: 48:307302 95000000         vu 04 00  1 219      
    call #0043FA81 (:%opJcc)              ;#004503F8: 350 84F6FEFF               v  00 00  1 220      
    jl #00450488                          ;#004503FD: 017214 85000000            v  00 00  1 221      
;   216                         fwk += epwr
    lea rdi,[rbp-120] (fwk)               ;#00450403: 48:215175 88               uv 80 20  1 222      
    mov rcx,[rbp-120] (fwk)               ;#00450407: 48:213115 88               vu 02 20  1 222      
    mov rax,[rbp-128] (epwr)              ;#0045040B: 48:213105 80               uv 01 20  1 223      
    call #0043F4AF (:%opAdd)              ;#0045040F: 350 9BF0FEFF               v  00 00  1 223      
;   217                         digit += 1
    mov rsi,[rbp-104] (digit)             ;#00450414: 48:213165 98               uv 40 20  1 224      
    add rsi,1                             ;#00450418: 48:203306 01               uv 40 40  1 225 40   
    mov rdx,rsi                           ;#0045041C: 48:213326                  uv 04 40  1 226 40   
    mov [rbp-104] (digit),rsi             ;#0045041F: 48:211165 98               vu 00 60  1 226      
    shl rdx,1                             ;#00450423: 48:321342                  u  04 04  1 227      
    jno #004503CB                         ;#00450426: 161 A3                     v  00 00  1 227      
    lea rdi,[rbp-104] (digit)             ;#00450428: 48:215175 98               uv 80 20  1 228      
    call #00442DA9 (:%pAddiii)            ;#0045042C: 350 7829FFFF               v  00 00  1 228      
;   218                     end while
    jmp #004503CB                         ;#00450431: 353 98                     v  00 00  1 229      
    jmp #00450488                         ;#00450433: 353 53                     v  00 00  1 230      
;   219                 else
;   220                     f = (f-digit)*10
    lea rdi,[rbp-176] (symtab[161])       ;#00450435: 48:215275 50FFFFFF         uv 80 20  1 231      
    mov rcx,[rbp-112] (f)                 ;#0045043C: 48:213115 90               vu 02 20  1 231      
    mov rax,[rbp-104] (digit)             ;#00450440: 48:213105 98               uv 01 20  1 232      
    call #0043F4D8 (:%opSub)              ;#00450444: 350 8FF0FEFF               v  00 00  1 232      
    lea rdi,[rbp-112] (f)                 ;#00450449: 48:215175 90               uv 80 20  1 233      
    mov rcx,[rbp-176] (symtab[161])       ;#0045044D: 48:213215 50FFFFFF         vu 02 20  1 233      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450454: 48:213005 8D1CFBFF         uv 01 00  1 234      
    call #0043F67C (:%opMul)              ;#0045045B: 350 1CF2FEFF               v  00 00  1 234      
;   221                     digit = floor(f)
    lea rdi,[rbp-104] (digit)             ;#00450460: 48:215175 98               uv 80 20  1 235      
    mov rax,[rbp-112] (f)                 ;#00450464: 48:213105 90               vu 01 20  1 235      
    call #0043F81C (:%opFloor)            ;#00450468: 350 AFF3FEFF               v  00 00  1 236      
    mov r15,h4                            ;#0045046D: 49:277 0000000000000040    uv 8000 00  1 237      
    cmp rax,r15                           ;#00450477: 4C:071370                  uv 00 8001  1 238 8000   
    jl #00450488                          ;#0045047A: 174 0C                     v  00 00  1 238      
    mov rcx,148                           ;#0045047C: 48:307301 94000000         uv 02 00  1 239      
    call #00442A58 (:%opTchkFail)         ;#00450483: 350 D025FFFF               v  00 00  1 239      
;   222                 end if
;   223                 result &= digit+'0'
    lea rdi,[rbp-176] (symtab[161])       ;#00450488: 48:215275 50FFFFFF         uv 80 20  1 240      
    mov rcx,[rbp-104] (digit)             ;#0045048F: 48:213115 98               vu 02 20  1 240      
    mov rax,[MB_ICONEXCLAMATION]          ;#00450493: 48:213005 DE1CFBFF         uv 01 00  1 241      
    call #0043F4AF (:%opAdd)              ;#0045049A: 350 10F0FEFF               v  00 00  1 241      
    lea rdx,[rbp-136] (result)            ;#0045049F: 48:215225 78FFFFFF         uv 04 20  1 242      
    lea rdi,[rbp-136] (result)            ;#004504A6: 48:215275 78FFFFFF         vu 80 20  1 242      
    lea rcx,[rbp-176] (symtab[161])       ;#004504AD: 48:215215 50FFFFFF         uv 02 20  1 243      
    xor rax,rax                           ;#004504B4: 48:061300                  vu 01 01  1 243      
    call #0043FC15 (:%opApnd)             ;#004504B7: 350 59F7FEFF               v  00 00  1 244      
    mov rdi,[rbp-136] (result)            ;#004504BC: 48:213275 78FFFFFF         uv 80 20  1 245      
    mov r15,h4                            ;#004504C3: 49:277 0000000000000040    vu 8000 00  1 245      
    cmp rdi,r15                           ;#004504CD: 4C:071377                  uv 00 8080  1 246      
    jl #004504D9                          ;#004504D0: 174 07                     v  00 00  1 246      
    cmp byte[rbx+rdi*4-1],#82             ;#004504D2: 200174273 FF 82            u  00 88  2 247      
    je #004504E5                          ;#004504D7: 164 0C                     v  00 00  1 248      
    mov rcx,152                           ;#004504D9: 48:307301 98000000         uv 02 00  1 249      
    call #00442A58 (:%opTchkFail)         ;#004504E0: 350 7325FFFF               v  00 00  1 249      
;   224                 expadj += 1
    mov rsi,[rbp-72] (expadj)             ;#004504E5: 48:213165 B8               uv 40 20  1 250      
    add rsi,1                             ;#004504E9: 48:203306 01               uv 40 40  1 251 40   
    mov rdx,rsi                           ;#004504ED: 48:213326                  uv 04 40  1 252 40   
    mov [rbp-72] (expadj),rsi             ;#004504F0: 48:211165 B8               vu 00 60  1 252      
    shl rdx,1                             ;#004504F4: 48:321342                  u  04 04  1 253      
    jno #00450502                         ;#004504F7: 161 09                     v  00 00  1 253      
    lea rdi,[rbp-72] (expadj)             ;#004504F9: 48:215175 B8               uv 80 20  1 254      
    call #00442DA9 (:%pAddiii)            ;#004504FD: 350 A728FFFF               v  00 00  1 254      
;   225             end for
    mov rcx,[rbp-192] (i)                 ;#00450502: 48:213215 40FFFFFF         uv 02 20  1 255      
    mov rax,[rbp-184] (symtab[162])       ;#00450509: 48:213205 48FFFFFF         vu 01 20  1 255      
    add rcx,1                             ;#00450510: 48:203301 01               uv 02 02  1 256      
    cmp rcx,rax                           ;#00450514: 48:073310                  uv 00 03  1 257 02   
    mov [rbp-192] (i),rcx                 ;#00450517: 48:211215 40FFFFFF         vu 00 22  1 257      
    jle #00450335                         ;#0045051E: 017216 11FEFFFF            v  00 00  1 258      
    jmp #0045058C                         ;#00450524: 353 66                     v  00 00  1 259      
;   226         else
;   227             if ewk>0 then
    mov rdi,[rbp-88] (ewk)                ;#00450526: 48:213175 A8               uv 80 20  1 260      
    cmp rdi,0                             ;#0045052A: 48:203377 00               uv 00 80  1 261 80   
    jle #00450561                         ;#0045052E: 176 31                     v  00 00  1 261      
;   228                 f -= fwk
    mov rsi,[rbp-120] (fwk)               ;#00450530: 48:213165 88               uv 40 20  1 262      
    mov r15,h4                            ;#00450534: 49:277 0000000000000040    vu 8000 00  1 262      
    cmp rsi,r15                           ;#0045053E: 4C:071376                  uv 00 8040  1 263      
    jne #0045054F                         ;#00450541: 165 0C                     v  00 00  1 263      
    mov rsi,150                           ;#00450543: 48:307306 96000000         uv 40 00  1 264      
    call #00442D75 (:%pUnassigned)        ;#0045054A: 350 2628FFFF               v  00 00  1 264      
    lea rdi,[rbp-112] (f)                 ;#0045054F: 48:215175 90               uv 80 20  1 265      
    mov rcx,[rbp-112] (f)                 ;#00450553: 48:213115 90               vu 02 20  1 265      
    mov rax,rsi                           ;#00450557: 48:211360                  uv 01 40  1 266      
    call #0043F4D8 (:%opSub)              ;#0045055A: 350 79EFFEFF               v  00 00  1 266      
    jmp #0045058C                         ;#0045055F: 353 2B                     v  00 00  1 267      
;   229             else
;   230                 f = (f-digit)*10
    lea rdi,[rbp-176] (symtab[161])       ;#00450561: 48:215275 50FFFFFF         uv 80 20  1 268      
    mov rcx,[rbp-112] (f)                 ;#00450568: 48:213115 90               vu 02 20  1 268      
    mov rax,[rbp-104] (digit)             ;#0045056C: 48:213105 98               uv 01 20  1 269      
    call #0043F4D8 (:%opSub)              ;#00450570: 350 63EFFEFF               v  00 00  1 269      
    lea rdi,[rbp-112] (f)                 ;#00450575: 48:215175 90               uv 80 20  1 270      
    mov rcx,[rbp-176] (symtab[161])       ;#00450579: 48:213215 50FFFFFF         vu 02 20  1 270      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450580: 48:213005 611BFBFF         uv 01 00  1 271      
    call #0043F67C (:%opMul)              ;#00450587: 350 F0F0FEFF               v  00 00  1 271      
;   231             end if
;   232         end if
;   233         exp -= expadj
    mov rdi,[rbp-144] (exp)               ;#0045058C: 48:213275 70FFFFFF         uv 80 20  1 272      
    mov rsi,[rbp-72] (expadj)             ;#00450593: 48:213165 B8               vu 40 20  1 272      
    sub rdi,rsi                           ;#00450597: 48:051367                  uv 80 C0  1 273      
    mov rdx,rdi                           ;#0045059A: 48:213327                  uv 04 80  1 274 80   
    mov [rbp-144] (exp),rdi               ;#0045059D: 48:211275 70FFFFFF         vu 00 A0  1 274      
    shl rdx,1                             ;#004505A4: 48:321342                  u  04 04  1 275      
    jno #004505B5                         ;#004505A7: 161 0C                     v  00 00  1 275      
    lea rdi,[rbp-144] (exp)               ;#004505A9: 48:215275 70FFFFFF         uv 80 20  1 276      
    call #00442DA9 (:%pAddiii)            ;#004505B0: 350 F427FFFF               v  00 00  1 276      
;   234         result = round(result,f,exp,charflag,digit)--,minfieldwidth)
    mov rcx,12                            ;#004505B5: 48:307301 0C000000         uv 02 00  1 277      
    mov rdx,102                           ;#004505BC: 48:307302 66000000         vu 04 00  1 277      
    call #004428DB (:%opFrame) (round)    ;#004505C3: 350 1323FFFF               v  00 00  1 278      
    mov rdi,[rbp+40] (prevebp)            ;#004505C8: 48:213175 28               uv 80 20  1 279      
    mov rax,[rdi-136]                     ;#004505CC: 48:213207 78FFFFFF         uv 01 80  1 282 80 *80*
    mov [rdi-136],r15                     ;#004505D3: 4C:211277 78FFFFFF         vu 00 8080  1 282      
    mov [rbp] (result),rax                ;#004505DA: 48:211105 00               uv 00 21  1 283      
    mov rdi,[rbp+40] (prevebp)            ;#004505DE: 48:213175 28               vu 80 20  1 283      
    mov rax,[rdi-112]                     ;#004505E2: 48:213107 90               uv 01 80  1 286    *80*
    xor rbx,rbx                           ;#004505E6: 48:061333                  vu 08 08  1 286      
    mov r15,h4                            ;#004505E9: 49:277 0000000000000040    uv 8000 00  1 287      
    cmp rax,r15                           ;#004505F3: 4C:071370                  uv 00 8001  1 288 8000   
    jl #00450603                          ;#004505F6: 174 0B                     v  00 00  1 288      
    add qword[rbx+rax*4-16],1             ;#004505F8: 48:203104203 F0 01         u  00 09  3 289      
    cmp eax,149                           ;#004505FE: 075 95000000               vu 00 01  1 291      
    mov [rbp-8] (f),rax                   ;#00450603: 48:211105 F8               uv 00 21  1 292      
    mov rdi,[rbp+40] (prevebp)            ;#00450607: 48:213175 28               vu 80 20  1 292      
    mov rax,[rdi-144]                     ;#0045060B: 48:213207 70FFFFFF         uv 01 80  1 295    *80*
    mov [rbp-16] (exp),rax                ;#00450612: 48:211105 F0               uv 00 21  1 296 01   
    mov rdi,[rbp+40] (prevebp)            ;#00450616: 48:213175 28               vu 80 20  1 296      
    mov rax,[rdi-8]                       ;#0045061A: 48:213107 F8               uv 01 80  1 299    *80*
    mov [rbp-24] (charflag),rax           ;#0045061E: 48:211105 E8               uv 00 21  1 300 01   
    mov rdi,[rbp+40] (prevebp)            ;#00450622: 48:213175 28               vu 80 20  1 300      
    mov rax,[rdi-104]                     ;#00450626: 48:213107 98               uv 01 80  1 303    *80*
    mov [rbp-32] (digit),rax              ;#0045062A: 48:211105 E0               uv 00 21  1 304 01   
    mov qword[retaddr],#0045063B          ;#0045062E: 48:307105 20 3B064500      vu 00 20  1 304      
    jmp #00451360 (code:round)            ;#00450636: 351 250D0000               v  00 00  1 305      
    push rax                              ;#0045063B: 120                        uv 00 01  1 306      
    mov rcx,[rbp-136] (result)            ;#0045063C: 48:213215 78FFFFFF         vu 02 20  1 306      
    mov r15,h4                            ;#00450643: 49:277 0000000000000040    uv 8000 00  1 307      
    cmp rcx,r15                           ;#0045064D: 4C:071371                  uv 00 8002  1 308 8000   
    jle #00450662                         ;#00450650: 176 10                     v  00 00  1 308      
    sub qword[rbx+rcx*4-16],1             ;#00450652: 48:203154213 F0 01         u  00 0A  3 309      
    jne #00450662                         ;#00450658: 165 08                     v  00 00  1 311      
    mov rdx,rcx                           ;#0045065A: 48:213321                  uv 04 02  1 312      
    call #004422DA (:%pDealloc)           ;#0045065D: 350 781CFFFF               v  00 00  1 312      
    pop dword[rbp-136] (result)           ;#00450662: 217205 78FFFFFF            np 00 20  3 313      
;   235         k = find('!',result)
    mov rcx,7                             ;#00450668: 48:307301 07000000         uv 02 00  1 316      
    mov rdx,75                            ;#0045066F: 48:307302 4B000000         vu 04 00  1 316      
    call #004428DB (:%opFrame) (find)     ;#00450676: 350 6022FFFF               v  00 00  1 317      
    mov qword[rbp] (x),33                 ;#0045067B: 48:307105 00 21000000      uv 00 20  1 318      
    mov rdi,[rbp+40] (prevebp)            ;#00450683: 48:213175 28               vu 80 20  1 318      
    mov rax,[rdi-136]                     ;#00450687: 48:213207 78FFFFFF         uv 01 80  1 321    *80*
    xor rbx,rbx                           ;#0045068E: 48:061333                  vu 08 08  1 321      
    mov r15,h4                            ;#00450691: 49:277 0000000000000040    uv 8000 00  1 322      
    cmp rax,r15                           ;#0045069B: 4C:071370                  uv 00 8001  1 323 8000   
    jl #004506AB                          ;#0045069E: 174 0B                     v  00 00  1 323      
    add qword[rbx+rax*4-16],1             ;#004506A0: 48:203104203 F0 01         u  00 09  3 324      
    cmp eax,152                           ;#004506A6: 075 98000000               vu 00 01  1 326      
    mov [rbp-8] (s),rax                   ;#004506AB: 48:211105 F8               uv 00 21  1 327      
    mov qword[retaddr],#004506BC          ;#004506AF: 48:307105 20 BC064500      vu 00 20  1 327      
    jmp #0043DAD6 (code:find)             ;#004506B7: 351 1AD4FEFF               v  00 00  1 328      
    mov [rbp-152] (k),rax                 ;#004506BC: 48:211205 68FFFFFF         uv 00 21  1 329      
;   236         if k then
    test rax,rax                          ;#004506C3: 48:205300                  vu 00 01  1 329      
    je #00450769                          ;#004506C6: 017204 9D000000            v  00 00  1 330      
;   237             if k=length(result) then
    mov rsi,[rbp-136] (result)            ;#004506CC: 48:213265 78FFFFFF         uv 40 20  1 331      
    mov rdi,[rbx+rsi*4-24]                ;#004506D3: 48:48:213174263 E8         uv 80 48  1 334 40 *40*
    cmp rax,rdi                           ;#004506D9: 48:071370                  uv 00 81  1 335 80   
    jne #00450704                         ;#004506DC: 165 26                     v  00 00  1 335      
;   238                 result = result[1..-2]
    lea rdx,[rbp-136] (result)            ;#004506DE: 48:215225 78FFFFFF         uv 04 20  1 336      
    mov rcx,1                             ;#004506E5: 48:307301 01000000         vu 02 00  1 336      
    push #00450702                        ;#004506EC: 150 02074500               uv 00 00  1 337      
    push rdx                              ;#004506F1: 122                        vu 00 04  1 337      
    push -2                               ;#004506F2: 152 FE                     uv 00 00  1 338      
    push 1                                ;#004506F4: 152 01                     vu 00 00  1 338      
    mov rdx,152                           ;#004506F6: 48:307302 98000000         uv 04 00  1 339      
    jmp #00440F1F (:%pSubss)              ;#004506FD: 351 1D08FFFF               v  00 00  1 339      
    jmp #00450743                         ;#00450702: 353 3F                     v  00 00  1 340      
;   239             else
;   240                 result[k] = '.'
    mov rdi,rax                           ;#00450704: 48:211307                  uv 80 01  1 341      
    mov rcx,46                            ;#00450707: 48:307301 2E000000         vu 02 00  1 341      
    lea rax,[rbp-136] (result)            ;#0045070E: 48:215205 78FFFFFF         uv 01 20  1 342      
    call #00440C54 (:%pRepe1)             ;#00450715: 350 3A05FFFF               v  00 00  1 342      
    mov rcx,[rbp-136] (result)            ;#0045071A: 48:213215 78FFFFFF         uv 02 20  1 343      
    mov r15,h4                            ;#00450721: 49:277 0000000000000040    vu 8000 00  1 343      
    cmp rcx,r15                           ;#0045072B: 4C:071371                  uv 00 8002  1 344      
    jl #00450737                          ;#0045072E: 174 07                     v  00 00  1 344      
    cmp byte[rbx+rcx*4-1],#82             ;#00450730: 200174213 FF 82            u  00 0A  2 345      
    je #00450743                          ;#00450735: 164 0C                     v  00 00  1 346      
    mov rcx,152                           ;#00450737: 48:307301 98000000         uv 02 00  1 347      
    call #00442A58 (:%opTchkFail)         ;#0045073E: 350 1523FFFF               v  00 00  1 347      
;   241             end if
;   242             exp += 1
    mov rsi,[rbp-144] (exp)               ;#00450743: 48:213265 70FFFFFF         uv 40 20  1 348      
    add rsi,1                             ;#0045074A: 48:203306 01               uv 40 40  1 349 40   
    mov rdx,rsi                           ;#0045074E: 48:213326                  uv 04 40  1 350 40   
    mov [rbp-144] (exp),rsi               ;#00450751: 48:211265 70FFFFFF         vu 00 60  1 350      
    shl rdx,1                             ;#00450758: 48:321342                  u  04 04  1 351      
    jno #00450769                         ;#0045075B: 161 0C                     v  00 00  1 351      
    lea rdi,[rbp-144] (exp)               ;#0045075D: 48:215275 70FFFFFF         uv 80 20  1 352      
    call #00442DA9 (:%pAddiii)            ;#00450764: 350 4026FFFF               v  00 00  1 352      
;   243         end if
;   244         exp += expadj
    mov rax,[rbp-144] (exp)               ;#00450769: 48:213205 70FFFFFF         uv 01 20  1 353      
    mov rdi,[rbp-72] (expadj)             ;#00450770: 48:213175 B8               vu 80 20  1 353      
    add rax,rdi                           ;#00450774: 48:001370                  uv 01 81  1 354      
    mov rdx,rax                           ;#00450777: 48:213320                  uv 04 01  1 355 01   
    mov [rbp-144] (exp),rax               ;#0045077A: 48:211205 70FFFFFF         vu 00 21  1 355      
    shl rdx,1                             ;#00450781: 48:321342                  u  04 04  1 356      
    jno #00450792                         ;#00450784: 161 0C                     v  00 00  1 356      
    lea rdi,[rbp-144] (exp)               ;#00450786: 48:215275 70FFFFFF         uv 80 20  1 357      
    call #00442DA9 (:%pAddiii)            ;#0045078D: 350 1726FFFF               v  00 00  1 357      
;   245         result &= capE
    lea rdx,[rbp-136] (result)            ;#00450792: 48:215225 78FFFFFF         uv 04 20  1 358      
    lea rdi,[rbp-136] (result)            ;#00450799: 48:215275 78FFFFFF         vu 80 20  1 358      
    lea rcx,[rbp-80] (capE)               ;#004507A0: 48:215115 B0               uv 02 20  1 359      
    xor rax,rax                           ;#004507A4: 48:061300                  vu 01 01  1 359      
    call #0043FC15 (:%opApnd)             ;#004507A7: 350 69F4FEFF               v  00 00  1 360      
    mov rcx,[rbp-136] (result)            ;#004507AC: 48:213215 78FFFFFF         uv 02 20  1 361      
    mov r15,h4                            ;#004507B3: 49:277 0000000000000040    vu 8000 00  1 361      
    cmp rcx,r15                           ;#004507BD: 4C:071371                  uv 00 8002  1 362      
    jl #004507C9                          ;#004507C0: 174 07                     v  00 00  1 362      
    cmp byte[rbx+rcx*4-1],#82             ;#004507C2: 200174213 FF 82            u  00 0A  2 363      
    je #004507D5                          ;#004507C7: 164 0C                     v  00 00  1 364      
    mov rcx,152                           ;#004507C9: 48:307301 98000000         uv 02 00  1 365      
    call #00442A58 (:%opTchkFail)         ;#004507D0: 350 8322FFFF               v  00 00  1 365      
;   246         if exp<0 then
    mov rsi,[rbp-144] (exp)               ;#004507D5: 48:213265 70FFFFFF         uv 40 20  1 366      
    cmp rsi,0                             ;#004507DC: 48:203376 00               uv 00 40  1 367 40   
    jge #0045084F                         ;#004507E0: 175 6D                     v  00 00  1 367      
;   247             result &= '-'
    lea rdx,[rbp-136] (result)            ;#004507E2: 48:215225 78FFFFFF         uv 04 20  1 368      
    lea rdi,[rbp-136] (result)            ;#004507E9: 48:215275 78FFFFFF         vu 80 20  1 368      
    lea rcx,qword[#00402218]              ;#004507F0: 48:215015 211AFBFF         uv 02 00  1 369      
    xor rax,rax                           ;#004507F7: 48:061300                  vu 01 01  1 369      
    call #0043FC15 (:%opApnd)             ;#004507FA: 350 16F4FEFF               v  00 00  1 370      
    mov rdi,[rbp-136] (result)            ;#004507FF: 48:213275 78FFFFFF         uv 80 20  1 371      
    mov r15,h4                            ;#00450806: 49:277 0000000000000040    vu 8000 00  1 371      
    cmp rdi,r15                           ;#00450810: 4C:071377                  uv 00 8080  1 372      
    jl #0045081C                          ;#00450813: 174 07                     v  00 00  1 372      
    cmp byte[rbx+rdi*4-1],#82             ;#00450815: 200174273 FF 82            u  00 88  2 373      
    je #00450828                          ;#0045081A: 164 0C                     v  00 00  1 374      
    mov rcx,152                           ;#0045081C: 48:307301 98000000         uv 02 00  1 375      
    call #00442A58 (:%opTchkFail)         ;#00450823: 350 3022FFFF               v  00 00  1 375      
;   248             exp = 0-exp
    mov rax,[rbp-144] (exp)               ;#00450828: 48:213205 70FFFFFF         uv 01 20  1 376      
    xor rdx,rdx                           ;#0045082F: 48:061322                  vu 04 04  1 376      
    sub rdx,rax                           ;#00450832: 48:051302                  uv 04 05  1 377      
    mov [rbp-144] (exp),rdx               ;#00450835: 48:211225 70FFFFFF         uv 00 24  1 378 04   
    shl rdx,1                             ;#0045083C: 48:321342                  u  04 04  1 379      
    jno #00450895                         ;#0045083F: 161 54                     v  00 00  1 379      
    lea rdi,[rbp-144] (exp)               ;#00450841: 48:215275 70FFFFFF         uv 80 20  1 380      
    call #00442DA9 (:%pAddiii)            ;#00450848: 350 5C25FFFF               v  00 00  1 380      
    jmp #00450895                         ;#0045084D: 353 46                     v  00 00  1 381      
;   249         else
;   250             result &= '+'
    lea rdx,[rbp-136] (result)            ;#0045084F: 48:215225 78FFFFFF         uv 04 20  1 382      
    lea rdi,[rbp-136] (result)            ;#00450856: 48:215275 78FFFFFF         vu 80 20  1 382      
    lea rcx,qword[#00402220]              ;#0045085D: 48:215015 BC19FBFF         uv 02 00  1 383      
    xor rax,rax                           ;#00450864: 48:061300                  vu 01 01  1 383      
    call #0043FC15 (:%opApnd)             ;#00450867: 350 A9F3FEFF               v  00 00  1 384      
    mov rcx,[rbp-136] (result)            ;#0045086C: 48:213215 78FFFFFF         uv 02 20  1 385      
    mov r15,h4                            ;#00450873: 49:277 0000000000000040    vu 8000 00  1 385      
    cmp rcx,r15                           ;#0045087D: 4C:071371                  uv 00 8002  1 386      
    jl #00450889                          ;#00450880: 174 07                     v  00 00  1 386      
    cmp byte[rbx+rcx*4-1],#82             ;#00450882: 200174213 FF 82            u  00 0A  2 387      
    je #00450895                          ;#00450887: 164 0C                     v  00 00  1 388      
    mov rcx,152                           ;#00450889: 48:307301 98000000         uv 02 00  1 389      
    call #00442A58 (:%opTchkFail)         ;#00450890: 350 C321FFFF               v  00 00  1 389      
;   251         end if
;   252         if exp=0 then
    mov rsi,[rbp-144] (exp)               ;#00450895: 48:213265 70FFFFFF         uv 40 20  1 390      
    cmp rsi,0                             ;#0045089C: 48:203376 00               uv 00 40  1 391 40   
    jne #004508B8                         ;#004508A0: 165 16                     v  00 00  1 391      
;   253             reve = "0"
    mov rdi,qword[#00402238]              ;#004508A2: 48:213075 8F19FBFF         uv 80 00  1 392      
    mov [rbp-56] (reve),rdi               ;#004508A9: 48:211175 C8               uv 00 A0  1 393 80   
    add qword[rbx+rdi*4-16],1             ;#004508AD: 48:203104273 F0 01         u  00 88  3 395    *80*
    jmp #00450AA4                         ;#004508B3: 351 EC010000               v  00 00  1 397      
;   254         else
;   255 --          reve = ""
;   256             reve = repeat(' ',0)
    lea rdi,[rbp-56] (reve)               ;#004508B8: 48:215175 C8               uv 80 20  1 398      
    mov rax,32                            ;#004508BC: 48:307300 20000000         vu 01 00  1 398      
    mov rcx,0                             ;#004508C3: 48:307301 00000000         uv 02 00  1 399      
    call #0043B1E1 (:%opRepCh)            ;#004508CA: 350 12A9FEFF               v  00 00  1 399      
;   257             while exp do
    mov rax,[rbp-144] (exp)               ;#004508CF: 48:213205 70FFFFFF         uv 01 20  1 400      
    test rax,rax                          ;#004508D6: 48:205300                  uv 00 01  1 401 01   
    je #0045097B                          ;#004508D9: 017204 9C000000            v  00 00  1 401      
;   258                 reve = append(reve,floor(remainder(exp,10)+'0'))
    lea rdi,[rbp-176] (symtab[161])       ;#004508DF: 48:215275 50FFFFFF         uv 80 20  1 402      
    mov rcx,[#004020E8] (BRIGHT_GREEN)    ;#004508E6: 48:213015 FB17FBFF         vu 02 00  1 402      
    call #0043F1F5 (:%opRmdr)             ;#004508ED: 350 03E9FEFF               v  00 00  1 403      
    lea rdi,[rbp-208] (symtab[166])       ;#004508F2: 48:215275 30FFFFFF         uv 80 20  1 404      
    mov rcx,[rbp-176] (symtab[161])       ;#004508F9: 48:213215 50FFFFFF         vu 02 20  1 404      
    mov rax,[MB_ICONEXCLAMATION]          ;#00450900: 48:213005 7118FBFF         uv 01 00  1 405      
    call #0043F4AF (:%opAdd)              ;#00450907: 350 A3EBFEFF               v  00 00  1 405      
    lea rdi,[rbp-176] (symtab[161])       ;#0045090C: 48:215275 50FFFFFF         uv 80 20  1 406      
    mov rax,[rbp-208] (symtab[166])       ;#00450913: 48:213205 30FFFFFF         vu 01 20  1 406      
    call #0043F81C (:%opFloor)            ;#0045091A: 350 FDEEFEFF               v  00 00  1 407      
    lea rdx,[rbp-56] (reve)               ;#0045091F: 48:215125 C8               uv 04 20  1 408      
    lea rdi,[rbp-56] (reve)               ;#00450923: 48:215175 C8               vu 80 20  1 408      
    lea rcx,[rbp-176] (symtab[161])       ;#00450927: 48:215215 50FFFFFF         uv 02 20  1 409      
    xor rax,rax                           ;#0045092E: 48:061300                  vu 01 01  1 409      
    call #0043FC15 (:%opApnd)             ;#00450931: 350 DFF2FEFF               v  00 00  1 410      
    mov rsi,[rbp-56] (reve)               ;#00450936: 48:213165 C8               uv 40 20  1 411      
    mov r15,h4                            ;#0045093A: 49:277 0000000000000040    vu 8000 00  1 411      
    cmp rsi,r15                           ;#00450944: 4C:071376                  uv 00 8040  1 412      
    jl #00450950                          ;#00450947: 174 07                     v  00 00  1 412      
    cmp byte[rbx+rsi*4-1],#82             ;#00450949: 200174263 FF 82            u  00 48  2 413      
    je #0045095C                          ;#0045094E: 164 0C                     v  00 00  1 414      
    mov rcx,142                           ;#00450950: 48:307301 8E000000         uv 02 00  1 415      
    call #00442A58 (:%opTchkFail)         ;#00450957: 350 FC20FFFF               v  00 00  1 415      
;   259                 exp = floor(exp/10)
    lea rdi,[rbp-144] (exp)               ;#0045095C: 48:215275 70FFFFFF         uv 80 20  1 416      
    mov rcx,[rbp-144] (exp)               ;#00450963: 48:213215 70FFFFFF         vu 02 20  1 416      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#0045096A: 48:213005 7717FBFF         uv 01 00  1 417      
    call #0043F5E4 (:%opDivf)             ;#00450971: 350 6EECFEFF               v  00 00  1 417      
;   260             end while
    jmp #004508CF                         ;#00450976: 351 54FFFFFF               v  00 00  1 418      
;   261             revelen = length(reve)
    mov rdi,[rbp-56] (reve)               ;#0045097B: 48:213175 C8               uv 80 20  1 419      
    mov rsi,[rbx+rdi*4-24]                ;#0045097F: 48:48:213164273 E8         uv 40 88  1 422 80 *80*
    mov [rbp-64] (revelen),rsi            ;#00450985: 48:211165 C0               uv 00 60  1 423 40   
;   262             for j=1 to revelen do
    mov [rbp-216] (symtab[167]),rsi       ;#00450989: 48:211265 28FFFFFF         vu 00 60  1 423      
    mov qword[rbp-224] (j),1              ;#00450990: 48:307205 20FFFFFF 01000000 uv 00 20  1 424      
    cmp rsi,1                             ;#0045099B: 48:201376 01000000         vu 00 40  1 424      
    jl #00450AA4                          ;#004509A2: 017214 FC000000            v  00 00  1 425      
;   263                 if j>=revelen then exit end if
    mov rcx,[rbp-224] (j)                 ;#004509A8: 48:213215 20FFFFFF         uv 02 20  1 426      
    mov rax,[rbp-64] (revelen)            ;#004509AF: 48:213105 C0               vu 01 20  1 426      
    cmp rcx,rax                           ;#004509B3: 48:071301                  uv 00 03  1 427      
    jge #00450AA4                         ;#004509B6: 017215 E8000000            v  00 00  1 427      
;   264                 tmp = reve[j]
    mov rdi,rcx                           ;#004509BC: 48:211317                  uv 80 02  1 428      
    mov rsi,[rbp-56] (reve)               ;#004509BF: 48:213165 C8               vu 40 20  1 428      
    mov rdx,142                           ;#004509C3: 48:307302 8E000000         uv 04 00  1 429      
    call #00441762 (:%pSubse1is)          ;#004509CA: 350 930DFFFF               v  00 00  1 429      
    mov [rbp-96] (tmp),rax                ;#004509CF: 48:211105 A0               uv 00 21  1 430      
;   265                 reve[j] = reve[revelen]
    mov rdi,[rbp-64] (revelen)            ;#004509D3: 48:213175 C0               vu 80 20  1 430      
    mov rsi,[rbp-56] (reve)               ;#004509D7: 48:213165 C8               uv 40 20  1 431      
    mov rdx,142                           ;#004509DB: 48:307302 8E000000         vu 04 00  1 431      
    call #00441762 (:%pSubse1is)          ;#004509E2: 350 7B0DFFFF               v  00 00  1 432      
    mov [rbp-200] (symtab[164]),rax       ;#004509E7: 48:211205 38FFFFFF         uv 00 21  1 433      
    mov rcx,rax                           ;#004509EE: 48:211301                  vu 02 01  1 433      
    mov rdi,[rbp-224] (j)                 ;#004509F1: 48:213275 20FFFFFF         uv 80 20  1 434      
    mov rsi,[rbp-56] (reve)               ;#004509F8: 48:213165 C8               vu 40 20  1 434      
    lea rax,[rbp-56] (reve)               ;#004509FC: 48:215105 C8               uv 01 20  1 435      
    call #00440C54 (:%pRepe1)             ;#00450A00: 350 4F02FFFF               v  00 00  1 435      
    mov rax,[rbp-56] (reve)               ;#00450A05: 48:213105 C8               uv 01 20  1 436      
    mov r15,h4                            ;#00450A09: 49:277 0000000000000040    vu 8000 00  1 436      
    cmp rax,r15                           ;#00450A13: 4C:071370                  uv 00 8001  1 437      
    jl #00450A1F                          ;#00450A16: 174 07                     v  00 00  1 437      
    cmp byte[rbx+rax*4-1],#82             ;#00450A18: 200174203 FF 82            u  00 09  2 438      
    je #00450A2B                          ;#00450A1D: 164 0C                     v  00 00  1 439      
    mov rcx,142                           ;#00450A1F: 48:307301 8E000000         uv 02 00  1 440      
    call #00442A58 (:%opTchkFail)         ;#00450A26: 350 2D20FFFF               v  00 00  1 440      
;   266                 reve[revelen] = tmp
    mov rsi,rax                           ;#00450A2B: 48:211306                  uv 40 01  1 441      
    mov rdi,[rbp-64] (revelen)            ;#00450A2E: 48:213175 C0               vu 80 20  1 441      
    mov rcx,[rbp-96] (tmp)                ;#00450A32: 48:213115 A0               uv 02 20  1 442      
    lea rax,[rbp-56] (reve)               ;#00450A36: 48:215105 C8               vu 01 20  1 442      
    call #00440C54 (:%pRepe1)             ;#00450A3A: 350 1502FFFF               v  00 00  1 443      
    mov rax,[rbp-56] (reve)               ;#00450A3F: 48:213105 C8               uv 01 20  1 444      
    mov r15,h4                            ;#00450A43: 49:277 0000000000000040    vu 8000 00  1 444      
    cmp rax,r15                           ;#00450A4D: 4C:071370                  uv 00 8001  1 445      
    jl #00450A59                          ;#00450A50: 174 07                     v  00 00  1 445      
    cmp byte[rbx+rax*4-1],#82             ;#00450A52: 200174203 FF 82            u  00 09  2 446      
    je #00450A65                          ;#00450A57: 164 0C                     v  00 00  1 447      
    mov rcx,142                           ;#00450A59: 48:307301 8E000000         uv 02 00  1 448      
    call #00442A58 (:%opTchkFail)         ;#00450A60: 350 F31FFFFF               v  00 00  1 448      
;   267                 revelen -= 1
    mov rsi,[rbp-64] (revelen)            ;#00450A65: 48:213165 C0               uv 40 20  1 449      
    sub rsi,1                             ;#00450A69: 48:203356 01               uv 40 40  1 450 40   
    mov rdx,rsi                           ;#00450A6D: 48:213326                  uv 04 40  1 451 40   
    mov [rbp-64] (revelen),rsi            ;#00450A70: 48:211165 C0               vu 00 60  1 451      
    shl rdx,1                             ;#00450A74: 48:321342                  u  04 04  1 452      
    jno #00450A82                         ;#00450A77: 161 09                     v  00 00  1 452      
    lea rdi,[rbp-64] (revelen)            ;#00450A79: 48:215175 C0               uv 80 20  1 453      
    call #00442DA9 (:%pAddiii)            ;#00450A7D: 350 2723FFFF               v  00 00  1 453      
;   268             end for
    mov rdi,[rbp-224] (j)                 ;#00450A82: 48:213275 20FFFFFF         uv 80 20  1 454      
    mov rcx,[rbp-216] (symtab[167])       ;#00450A89: 48:213215 28FFFFFF         vu 02 20  1 454      
    add rdi,1                             ;#00450A90: 48:203307 01               uv 80 80  1 455      
    cmp rdi,rcx                           ;#00450A94: 48:073371                  uv 00 82  1 456 80   
    mov [rbp-224] (j),rdi                 ;#00450A97: 48:211275 20FFFFFF         vu 00 A0  1 456      
    jle #004509A8                         ;#00450A9E: 017216 04FFFFFF            v  00 00  1 457      
;   269         end if
;   270         result &= reve
    mov rax,[rbp-56] (reve)               ;#00450AA4: 48:213105 C8               uv 01 20  1 458      
    mov r15,h4                            ;#00450AA8: 49:277 0000000000000040    vu 8000 00  1 458      
    cmp rax,r15                           ;#00450AB2: 4C:071370                  uv 00 8001  1 459      
    jne #00450AC3                         ;#00450AB5: 165 0C                     v  00 00  1 459      
    mov rsi,142                           ;#00450AB7: 48:307306 8E000000         uv 40 00  1 460      
    call #00442D75 (:%pUnassigned)        ;#00450ABE: 350 B222FFFF               v  00 00  1 460      
    lea rdx,[rbp-136] (result)            ;#00450AC3: 48:215225 78FFFFFF         uv 04 20  1 461      
    lea rdi,[rbp-136] (result)            ;#00450ACA: 48:215275 78FFFFFF         vu 80 20  1 461      
    lea rcx,[rbp-56] (reve)               ;#00450AD1: 48:215115 C8               uv 02 20  1 462      
    call #00440021 (:%opConcat)           ;#00450AD5: 350 47F5FEFF               v  00 00  1 462      
    jmp #0045134D                         ;#00450ADA: 351 6E080000               v  00 00  1 463      
;   271     else
;   272         digit = 0
    mov [rbp-104] (digit),rbx             ;#00450ADF: 48:211135 98               uv 00 28  1 464      
;   273         if exp<-1 then
    mov rsi,[rbp-144] (exp)               ;#00450AE3: 48:213265 70FFFFFF         vu 40 20  1 464      
    cmp rsi,-1                            ;#00450AEA: 48:203376 FF               uv 00 40  1 465      
    jge #00450C84                         ;#00450AEE: 017215 90010000            v  00 00  1 465      
;   274 --DEV not thread safe
;   275 --          result &= "0."
;   276             result &= '0'
    lea rdx,[rbp-136] (result)            ;#00450AF4: 48:215225 78FFFFFF         uv 04 20  1 466      
    lea rdi,[rbp-136] (result)            ;#00450AFB: 48:215275 78FFFFFF         vu 80 20  1 466      
    lea rcx,[MB_ICONEXCLAMATION]          ;#00450B02: 48:215015 6F16FBFF         uv 02 00  1 467      
    xor rax,rax                           ;#00450B09: 48:061300                  vu 01 01  1 467      
    call #0043FC15 (:%opApnd)             ;#00450B0C: 350 04F1FEFF               v  00 00  1 468      
    mov rcx,[rbp-136] (result)            ;#00450B11: 48:213215 78FFFFFF         uv 02 20  1 469      
    mov r15,h4                            ;#00450B18: 49:277 0000000000000040    vu 8000 00  1 469      
    cmp rcx,r15                           ;#00450B22: 4C:071371                  uv 00 8002  1 470      
    jl #00450B2E                          ;#00450B25: 174 07                     v  00 00  1 470      
    cmp byte[rbx+rcx*4-1],#82             ;#00450B27: 200174213 FF 82            u  00 0A  2 471      
    je #00450B3A                          ;#00450B2C: 164 0C                     v  00 00  1 472      
    mov rcx,152                           ;#00450B2E: 48:307301 98000000         uv 02 00  1 473      
    call #00442A58 (:%opTchkFail)         ;#00450B35: 350 1E1FFFFF               v  00 00  1 473      
;   277             if charflag!='g' or f!=0 then
    mov rdi,[rbp-8] (charflag)            ;#00450B3A: 48:213175 F8               uv 80 20  1 474      
    cmp rdi,103                           ;#00450B3E: 48:203377 67               uv 00 80  1 475 80   
    jne #00450B52                         ;#00450B42: 165 0E                     v  00 00  1 475      
    mov rax,[rbp-112] (f)                 ;#00450B44: 48:213105 90               uv 01 20  1 476      
    cmp rax,0                             ;#00450B48: 48:203370 00               uv 00 01  1 477 01   
    je #00450C84                          ;#00450B4C: 017204 32010000            v  00 00  1 477      
;   278                 result &= '.'
    lea rdx,[rbp-136] (result)            ;#00450B52: 48:215225 78FFFFFF         uv 04 20  1 478      
    lea rdi,[rbp-136] (result)            ;#00450B59: 48:215275 78FFFFFF         vu 80 20  1 478      
    lea rcx,qword[#004021C0]              ;#00450B60: 48:215015 5916FBFF         uv 02 00  1 479      
    xor rax,rax                           ;#00450B67: 48:061300                  vu 01 01  1 479      
    call #0043FC15 (:%opApnd)             ;#00450B6A: 350 A6F0FEFF               v  00 00  1 480      
    mov rsi,[rbp-136] (result)            ;#00450B6F: 48:213265 78FFFFFF         uv 40 20  1 481      
    mov r15,h4                            ;#00450B76: 49:277 0000000000000040    vu 8000 00  1 481      
    cmp rsi,r15                           ;#00450B80: 4C:071376                  uv 00 8040  1 482      
    jl #00450B8C                          ;#00450B83: 174 07                     v  00 00  1 482      
    cmp byte[rbx+rsi*4-1],#82             ;#00450B85: 200174263 FF 82            u  00 48  2 483      
    je #00450B98                          ;#00450B8A: 164 0C                     v  00 00  1 484      
    mov rcx,152                           ;#00450B8C: 48:307301 98000000         uv 02 00  1 485      
    call #00442A58 (:%opTchkFail)         ;#00450B93: 350 C01EFFFF               v  00 00  1 485      
;   279                 dotdone = 1
    mov qword[rbp-40] (dotdone),1         ;#00450B98: 48:307105 D8 01000000      uv 00 20  1 486      
;   280                 while exp<-1
    mov rcx,[rbp-144] (exp)               ;#00450BA0: 48:213215 70FFFFFF         vu 02 20  1 486      
    cmp rcx,-1                            ;#00450BA7: 48:203371 FF               uv 00 02  1 487      
    jge #00450C84                         ;#00450BAB: 017215 D3000000            v  00 00  1 487      
;   281                   and (charflag!='g' or f!=0) do
    mov rdi,[rbp-8] (charflag)            ;#00450BB1: 48:213175 F8               uv 80 20  1 488      
    cmp rdi,103                           ;#00450BB5: 48:203377 67               uv 00 80  1 489 80   
    jne #00450BC9                         ;#00450BB9: 165 0E                     v  00 00  1 489      
    mov rax,[rbp-112] (f)                 ;#00450BBB: 48:213105 90               uv 01 20  1 490      
    cmp rax,0                             ;#00450BBF: 48:203370 00               uv 00 01  1 491 01   
    je #00450C84                          ;#00450BC3: 017204 BB000000            v  00 00  1 491      
;   282                     exp += 1
    add rcx,1                             ;#00450BC9: 48:203301 01               uv 02 02  1 492      
    mov rdx,rcx                           ;#00450BCD: 48:213321                  uv 04 02  1 493 02   
    mov [rbp-144] (exp),rcx               ;#00450BD0: 48:211215 70FFFFFF         vu 00 22  1 493      
    shl rdx,1                             ;#00450BD7: 48:321342                  u  04 04  1 494      
    jno #00450BE8                         ;#00450BDA: 161 0C                     v  00 00  1 494      
    lea rdi,[rbp-144] (exp)               ;#00450BDC: 48:215275 70FFFFFF         uv 80 20  1 495      
    call #00442DA9 (:%pAddiii)            ;#00450BE3: 350 C121FFFF               v  00 00  1 495      
;   283                     if precision then
    mov rsi,[rbp-32] (precision)          ;#00450BE8: 48:213165 E0               uv 40 20  1 496      
    test rsi,rsi                          ;#00450BEC: 48:205366                  uv 00 40  1 497 40   
    je #00450C6B                          ;#00450BEF: 164 7A                     v  00 00  1 497      
;   284                         result &= '0'
    lea rdx,[rbp-136] (result)            ;#00450BF1: 48:215225 78FFFFFF         uv 04 20  1 498      
    lea rdi,[rbp-136] (result)            ;#00450BF8: 48:215275 78FFFFFF         vu 80 20  1 498      
    lea rcx,[MB_ICONEXCLAMATION]          ;#00450BFF: 48:215015 7215FBFF         uv 02 00  1 499      
    xor rax,rax                           ;#00450C06: 48:061300                  vu 01 01  1 499      
    call #0043FC15 (:%opApnd)             ;#00450C09: 350 07F0FEFF               v  00 00  1 500      
    mov rdi,[rbp-136] (result)            ;#00450C0E: 48:213275 78FFFFFF         uv 80 20  1 501      
    mov r15,h4                            ;#00450C15: 49:277 0000000000000040    vu 8000 00  1 501      
    cmp rdi,r15                           ;#00450C1F: 4C:071377                  uv 00 8080  1 502      
    jl #00450C2B                          ;#00450C22: 174 07                     v  00 00  1 502      
    cmp byte[rbx+rdi*4-1],#82             ;#00450C24: 200174273 FF 82            u  00 88  2 503      
    je #00450C37                          ;#00450C29: 164 0C                     v  00 00  1 504      
    mov rcx,152                           ;#00450C2B: 48:307301 98000000         uv 02 00  1 505      
    call #00442A58 (:%opTchkFail)         ;#00450C32: 350 211EFFFF               v  00 00  1 505      
;   285                         if minfieldwidth>0 then
    mov rax,[rbp-24] (minfieldwidth)      ;#00450C37: 48:213105 E8               uv 01 20  1 506      
    cmp rax,0                             ;#00450C3B: 48:203370 00               uv 00 01  1 507 01   
    jle #00450BA0                         ;#00450C3F: 017216 5BFFFFFF            v  00 00  1 507      
;   286                             precision -= 1
    mov rcx,[rbp-32] (precision)          ;#00450C45: 48:213115 E0               uv 02 20  1 508      
    sub rcx,1                             ;#00450C49: 48:203351 01               uv 02 02  1 509 02   
    mov rdx,rcx                           ;#00450C4D: 48:213321                  uv 04 02  1 510 02   
    mov [rbp-32] (precision),rcx          ;#00450C50: 48:211115 E0               vu 00 22  1 510      
    shl rdx,1                             ;#00450C54: 48:321342                  u  04 04  1 511      
    jno #00450BA0                         ;#00450C57: 017201 43FFFFFF            v  00 00  1 511      
    lea rdi,[rbp-32] (precision)          ;#00450C5D: 48:215175 E0               uv 80 20  1 512      
    call #00442DA9 (:%pAddiii)            ;#00450C61: 350 4321FFFF               v  00 00  1 512      
;   287                         end if
    jmp #00450BA0                         ;#00450C66: 351 35FFFFFF               v  00 00  1 513      
;   288                     else
;   289                         f /= 10
    lea rdi,[rbp-112] (f)                 ;#00450C6B: 48:215175 90               uv 80 20  1 514      
    mov rcx,[rbp-112] (f)                 ;#00450C6F: 48:213115 90               vu 02 20  1 514      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450C73: 48:213005 6E14FBFF         uv 01 00  1 515      
    call #0043F564 (:%opDiv)              ;#00450C7A: 350 E5E8FEFF               v  00 00  1 515      
;   290                     end if
;   291                 end while
    jmp #00450BA0                         ;#00450C7F: 351 1CFFFFFF               v  00 00  1 516      
;   292             end if
;   293         end if
;   294 
;   295         while 1 do
;   296             if exp=-1 then
    mov rsi,[rbp-144] (exp)               ;#00450C84: 48:213265 70FFFFFF         uv 40 20  1 517      
    cmp rsi,-1                            ;#00450C8B: 48:203376 FF               uv 00 40  1 518 40   
    jne #00450EE4                         ;#00450C8F: 017205 4F020000            v  00 00  1 518      
;   297                 if precision>0 then
    mov rdi,[rbp-32] (precision)          ;#00450C95: 48:213175 E0               uv 80 20  1 519      
    cmp rdi,0                             ;#00450C99: 48:203377 00               uv 00 80  1 520 80   
    jle #004510E4                         ;#00450C9D: 017216 41040000            v  00 00  1 520      
;   298                     if not dotdone then
    mov rcx,[rbp-40] (dotdone)            ;#00450CA3: 48:213115 D8               uv 02 20  1 521      
    test rcx,rcx                          ;#00450CA7: 48:205311                  uv 00 02  1 522 02   
    jne #00450DB6                         ;#00450CAA: 017205 06010000            v  00 00  1 522      
;   299                         if charflag='g' then
    mov rax,[rbp-8] (charflag)            ;#00450CB0: 48:213105 F8               uv 01 20  1 523      
    cmp rax,103                           ;#00450CB4: 48:203370 67               uv 00 01  1 524 01   
    jne #00450CC8                         ;#00450CB8: 165 0E                     v  00 00  1 524      
;   300                             if f=0 then exit end if
    mov rsi,[rbp-112] (f)                 ;#00450CBA: 48:213165 90               uv 40 20  1 525      
    cmp rsi,0                             ;#00450CBE: 48:203376 00               uv 00 40  1 526 40   
    je #004510E4                          ;#00450CC2: 017204 1C040000            v  00 00  1 526      
;   301                         end if
;   302                         if find(result,{"","-","+"}) then
    mov rcx,7                             ;#00450CC8: 48:307301 07000000         uv 02 00  1 527      
    mov rdx,75                            ;#00450CCF: 48:307302 4B000000         vu 04 00  1 527      
    call #004428DB (:%opFrame) (find)     ;#00450CD6: 350 001CFFFF               v  00 00  1 528      
    mov rdi,[rbp+40] (prevebp)            ;#00450CDB: 48:213175 28               uv 80 20  1 529      
    mov rax,[rdi-136]                     ;#00450CDF: 48:213207 78FFFFFF         uv 01 80  1 532 80 *80*
    xor rbx,rbx                           ;#00450CE6: 48:061333                  vu 08 08  1 532      
    mov r15,h4                            ;#00450CE9: 49:277 0000000000000040    uv 8000 00  1 533      
    cmp rax,r15                           ;#00450CF3: 4C:071370                  uv 00 8001  1 534 8000   
    jl #00450D03                          ;#00450CF6: 174 0B                     v  00 00  1 534      
    add qword[rbx+rax*4-16],1             ;#00450CF8: 48:203104203 F0 01         u  00 09  3 535      
    cmp eax,152                           ;#00450CFE: 075 98000000               vu 00 01  1 537      
    mov [rbp] (x),rax                     ;#00450D03: 48:211105 00               uv 00 21  1 538      
    mov rdi,qword[#00402258]              ;#00450D07: 48:213075 4A15FBFF         vu 80 00  1 538      
    mov [rbp-8] (s),rdi                   ;#00450D0E: 48:211175 F8               uv 00 A0  1 539      
    add qword[rbx+rdi*4-16],1             ;#00450D12: 48:203104273 F0 01         u  00 88  3 541    *80*
    mov qword[retaddr],#00450D25          ;#00450D18: 48:307105 20 250D4500      vu 00 20  1 543      
    jmp #0043DAD6 (code:find)             ;#00450D20: 351 B1CDFEFF               v  00 00  1 544      
    test rax,rax                          ;#00450D25: 48:205300                  uv 00 01  1 545      
    je #00450D70                          ;#00450D28: 164 46                     v  00 00  1 545      
;   303 --DEV not thread safe
;   304 --                          result &= "0."
;   305                             result &= '0'
    lea rdx,[rbp-136] (result)            ;#00450D2A: 48:215225 78FFFFFF         uv 04 20  1 546      
    lea rdi,[rbp-136] (result)            ;#00450D31: 48:215275 78FFFFFF         vu 80 20  1 546      
    lea rcx,[MB_ICONEXCLAMATION]          ;#00450D38: 48:215015 3914FBFF         uv 02 00  1 547      
    xor rax,rax                           ;#00450D3F: 48:061300                  vu 01 01  1 547      
    call #0043FC15 (:%opApnd)             ;#00450D42: 350 CEEEFEFF               v  00 00  1 548      
    mov rcx,[rbp-136] (result)            ;#00450D47: 48:213215 78FFFFFF         uv 02 20  1 549      
    mov r15,h4                            ;#00450D4E: 49:277 0000000000000040    vu 8000 00  1 549      
    cmp rcx,r15                           ;#00450D58: 4C:071371                  uv 00 8002  1 550      
    jl #00450D64                          ;#00450D5B: 174 07                     v  00 00  1 550      
    cmp byte[rbx+rcx*4-1],#82             ;#00450D5D: 200174213 FF 82            u  00 0A  2 551      
    je #00450D70                          ;#00450D62: 164 0C                     v  00 00  1 552      
    mov rcx,152                           ;#00450D64: 48:307301 98000000         uv 02 00  1 553      
    call #00442A58 (:%opTchkFail)         ;#00450D6B: 350 E81CFFFF               v  00 00  1 553      
;   306 --                      else
;   307 --                          result &= '.'
;   308                         end if
;   309                         result &= '.'
    lea rdx,[rbp-136] (result)            ;#00450D70: 48:215225 78FFFFFF         uv 04 20  1 554      
    lea rdi,[rbp-136] (result)            ;#00450D77: 48:215275 78FFFFFF         vu 80 20  1 554      
    lea rcx,qword[#004021C0]              ;#00450D7E: 48:215015 3B14FBFF         uv 02 00  1 555      
    xor rax,rax                           ;#00450D85: 48:061300                  vu 01 01  1 555      
    call #0043FC15 (:%opApnd)             ;#00450D88: 350 88EEFEFF               v  00 00  1 556      
    mov rsi,[rbp-136] (result)            ;#00450D8D: 48:213265 78FFFFFF         uv 40 20  1 557      
    mov r15,h4                            ;#00450D94: 49:277 0000000000000040    vu 8000 00  1 557      
    cmp rsi,r15                           ;#00450D9E: 4C:071376                  uv 00 8040  1 558      
    jl #00450DAA                          ;#00450DA1: 174 07                     v  00 00  1 558      
    cmp byte[rbx+rsi*4-1],#82             ;#00450DA3: 200174263 FF 82            u  00 48  2 559      
    je #00450DB6                          ;#00450DA8: 164 0C                     v  00 00  1 560      
    mov rcx,152                           ;#00450DAA: 48:307301 98000000         uv 02 00  1 561      
    call #00442A58 (:%opTchkFail)         ;#00450DB1: 350 A21CFFFF               v  00 00  1 561      
;   310                     end if
;   311                     for j=1 to precision do
    mov rax,[rbp-32] (precision)          ;#00450DB6: 48:213105 E0               uv 01 20  1 562      
    mov [rbp-232] (symtab[173]),rax       ;#00450DBA: 48:211205 18FFFFFF         uv 00 21  1 563 01   
    mov qword[rbp-240] (j),1              ;#00450DC1: 48:307205 10FFFFFF 01000000 vu 00 20  1 563      
    lea rdx,[rax+1]                       ;#00450DCC: 48:215120 01               uv 04 01  1 564      
    shl rdx,1                             ;#00450DD0: 48:321342                  u  04 04  1 565      
    jno #00450DEA                         ;#00450DD3: 161 15                     v  00 00  1 565      
    mov al,121                            ;#00450DD5: 260 79                     uv 01 00  1 566      
    mov rdi,173                           ;#00450DD7: 48:307307 AD000000         vu 80 00  1 566      
    mov rsi,26                            ;#00450DDE: 48:307306 1A000000         uv 40 00  1 567      
    call #00442DC8 (:%pRTErn)             ;#00450DE5: 350 DE1FFFFF               v  00 00  1 567      
    cmp rax,1                             ;#00450DEA: 48:075 01000000            uv 00 01  1 568      
    jl #004510E4                          ;#00450DF0: 017214 EE020000            v  00 00  1 568      
;   312                         digit = floor(f)
    lea rdi,[rbp-104] (digit)             ;#00450DF6: 48:215175 98               uv 80 20  1 569      
    mov rax,[rbp-112] (f)                 ;#00450DFA: 48:213105 90               vu 01 20  1 569      
    call #0043F81C (:%opFloor)            ;#00450DFE: 350 19EAFEFF               v  00 00  1 570      
    mov r15,h4                            ;#00450E03: 49:277 0000000000000040    uv 8000 00  1 571      
    cmp rax,r15                           ;#00450E0D: 4C:071370                  uv 00 8001  1 572 8000   
    jl #00450E1E                          ;#00450E10: 174 0C                     v  00 00  1 572      
    mov rcx,148                           ;#00450E12: 48:307301 94000000         uv 02 00  1 573      
    call #00442A58 (:%opTchkFail)         ;#00450E19: 350 3A1CFFFF               v  00 00  1 573      
;   313                         result &= digit+'0'
    lea rdi,[rbp-176] (symtab[161])       ;#00450E1E: 48:215275 50FFFFFF         uv 80 20  1 574      
    mov rcx,rax                           ;#00450E25: 48:211301                  vu 02 01  1 574      
    mov rax,[MB_ICONEXCLAMATION]          ;#00450E28: 48:213005 4913FBFF         uv 01 00  1 575      
    call #0043F4AF (:%opAdd)              ;#00450E2F: 350 7BE6FEFF               v  00 00  1 575      
    lea rdx,[rbp-136] (result)            ;#00450E34: 48:215225 78FFFFFF         uv 04 20  1 576      
    lea rdi,[rbp-136] (result)            ;#00450E3B: 48:215275 78FFFFFF         vu 80 20  1 576      
    lea rcx,[rbp-176] (symtab[161])       ;#00450E42: 48:215215 50FFFFFF         uv 02 20  1 577      
    xor rax,rax                           ;#00450E49: 48:061300                  vu 01 01  1 577      
    call #0043FC15 (:%opApnd)             ;#00450E4C: 350 C4EDFEFF               v  00 00  1 578      
    mov rdi,[rbp-136] (result)            ;#00450E51: 48:213275 78FFFFFF         uv 80 20  1 579      
    mov r15,h4                            ;#00450E58: 49:277 0000000000000040    vu 8000 00  1 579      
    cmp rdi,r15                           ;#00450E62: 4C:071377                  uv 00 8080  1 580      
    jl #00450E6E                          ;#00450E65: 174 07                     v  00 00  1 580      
    cmp byte[rbx+rdi*4-1],#82             ;#00450E67: 200174273 FF 82            u  00 88  2 581      
    je #00450E7A                          ;#00450E6C: 164 0C                     v  00 00  1 582      
    mov rcx,152                           ;#00450E6E: 48:307301 98000000         uv 02 00  1 583      
    call #00442A58 (:%opTchkFail)         ;#00450E75: 350 DE1BFFFF               v  00 00  1 583      
;   314                         f = (f-digit)*10
    lea rdi,[rbp-176] (symtab[161])       ;#00450E7A: 48:215275 50FFFFFF         uv 80 20  1 584      
    mov rcx,[rbp-112] (f)                 ;#00450E81: 48:213115 90               vu 02 20  1 584      
    mov rax,[rbp-104] (digit)             ;#00450E85: 48:213105 98               uv 01 20  1 585      
    call #0043F4D8 (:%opSub)              ;#00450E89: 350 4AE6FEFF               v  00 00  1 585      
    lea rdi,[rbp-112] (f)                 ;#00450E8E: 48:215175 90               uv 80 20  1 586      
    mov rcx,[rbp-176] (symtab[161])       ;#00450E92: 48:213215 50FFFFFF         vu 02 20  1 586      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450E99: 48:213005 4812FBFF         uv 01 00  1 587      
    call #0043F67C (:%opMul)              ;#00450EA0: 350 D7E7FEFF               v  00 00  1 587      
;   315                         if charflag='g' then
    mov rsi,[rbp-8] (charflag)            ;#00450EA5: 48:213165 F8               uv 40 20  1 588      
    cmp rsi,103                           ;#00450EA9: 48:203376 67               uv 00 40  1 589 40   
    jne #00450EBD                         ;#00450EAD: 165 0E                     v  00 00  1 589      
;   316                             if f=0 then exit end if
    mov rdi,[rbp-112] (f)                 ;#00450EAF: 48:213175 90               uv 80 20  1 590      
    cmp rdi,0                             ;#00450EB3: 48:203377 00               uv 00 80  1 591 80   
    je #004510E4                          ;#00450EB7: 017204 27020000            v  00 00  1 591      
;   317                         end if
;   318                     end for
    mov rcx,[rbp-240] (j)                 ;#00450EBD: 48:213215 10FFFFFF         uv 02 20  1 592      
    mov rax,[rbp-232] (symtab[173])       ;#00450EC4: 48:213205 18FFFFFF         vu 01 20  1 592      
    add rcx,1                             ;#00450ECB: 48:203301 01               uv 02 02  1 593      
    cmp rcx,rax                           ;#00450ECF: 48:073310                  uv 00 03  1 594 02   
    mov [rbp-240] (j),rcx                 ;#00450ED2: 48:211215 10FFFFFF         vu 00 22  1 594      
    jle #00450DF6                         ;#00450ED9: 017216 17FFFFFF            v  00 00  1 595      
;   319                 end if
;   320                 exit
    jmp #004510E4                         ;#00450EDF: 351 00020000               v  00 00  1 596      
;   321             end if
;   322             if exp>=1 then
    cmp rsi,1                             ;#00450EE4: 48:203376 01               uv 00 40  1 597      
    jl #00450FA0                          ;#00450EE8: 017214 B2000000            v  00 00  1 597      
;   323                 epwr = power(10,exp)
    lea rdi,[rbp-128] (epwr)              ;#00450EEE: 48:215175 80               uv 80 20  1 598      
    mov rcx,rsi                           ;#00450EF2: 48:211361                  vu 02 40  1 598      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450EF5: 48:213005 EC11FBFF         uv 01 00  1 599      
    call #0043B324 (:%opPow)              ;#00450EFC: 350 23A4FEFF               v  00 00  1 599      
;   324                 fwk = 0--epwr
    mov rdx,[rbp-120] (fwk)               ;#00450F01: 48:213125 88               uv 04 20  1 600      
    mov r15,h4                            ;#00450F05: 49:277 0000000000000040    vu 8000 00  1 600      
    cmp rdx,r15                           ;#00450F0F: 4C:071372                  uv 00 8004  1 601      
    mov [rbp-120] (fwk),rbx               ;#00450F12: 48:211135 88               vu 00 28  1 601      
    jle #00450F25                         ;#00450F16: 176 0D                     v  00 00  1 602      
    sub qword[rbx+rdx*4-16],1             ;#00450F18: 48:203154223 F0 01         u  00 0C  3 603      
    jne #00450F25                         ;#00450F1E: 165 05                     v  00 00  1 605      
    call #004422DA (:%pDealloc)           ;#00450F20: 350 B513FFFF               v  00 00  1 606      
;   325                 digit = 0
    mov [rbp-104] (digit),rbx             ;#00450F25: 48:211135 98               uv 00 28  1 607      
;   326                 while f>=fwk+epwr do
    lea rdi,[rbp-176] (symtab[161])       ;#00450F29: 48:215275 50FFFFFF         vu 80 20  1 607      
    mov rcx,[rbp-120] (fwk)               ;#00450F30: 48:213115 88               uv 02 20  1 608      
    mov rax,[rbp-128] (epwr)              ;#00450F34: 48:213105 80               vu 01 20  1 608      
    call #0043F4AF (:%opAdd)              ;#00450F38: 350 72E5FEFF               v  00 00  1 609      
    mov rdi,[rbp-176] (symtab[161])       ;#00450F3D: 48:213275 50FFFFFF         uv 80 20  1 610      
    mov rax,[rbp-112] (f)                 ;#00450F44: 48:213105 90               vu 01 20  1 610      
    mov rsi,161                           ;#00450F48: 48:307306 A1000000         uv 40 00  1 611      
    mov rdx,149                           ;#00450F4F: 48:307302 95000000         vu 04 00  1 611      
    call #0043FA81 (:%opJcc)              ;#00450F56: 350 26EBFEFF               v  00 00  1 612      
    jl #00450F8D                          ;#00450F5B: 174 30                     v  00 00  1 613      
;   327                     fwk += epwr
    lea rdi,[rbp-120] (fwk)               ;#00450F5D: 48:215175 88               uv 80 20  1 614      
    mov rcx,[rbp-120] (fwk)               ;#00450F61: 48:213115 88               vu 02 20  1 614      
    mov rax,[rbp-128] (epwr)              ;#00450F65: 48:213105 80               uv 01 20  1 615      
    call #0043F4AF (:%opAdd)              ;#00450F69: 350 41E5FEFF               v  00 00  1 615      
;   328                     digit += 1
    mov rsi,[rbp-104] (digit)             ;#00450F6E: 48:213165 98               uv 40 20  1 616      
    add rsi,1                             ;#00450F72: 48:203306 01               uv 40 40  1 617 40   
    mov rdx,rsi                           ;#00450F76: 48:213326                  uv 04 40  1 618 40   
    mov [rbp-104] (digit),rsi             ;#00450F79: 48:211165 98               vu 00 60  1 618      
    shl rdx,1                             ;#00450F7D: 48:321342                  u  04 04  1 619      
    jno #00450F29                         ;#00450F80: 161 A7                     v  00 00  1 619      
    lea rdi,[rbp-104] (digit)             ;#00450F82: 48:215175 98               uv 80 20  1 620      
    call #00442DA9 (:%pAddiii)            ;#00450F86: 350 1E1EFFFF               v  00 00  1 620      
;   329                 end while
    jmp #00450F29                         ;#00450F8B: 353 9C                     v  00 00  1 621      
;   330                 f -= fwk    --epwr
    lea rdi,[rbp-112] (f)                 ;#00450F8D: 48:215175 90               uv 80 20  1 622      
    mov rcx,[rbp-112] (f)                 ;#00450F91: 48:213115 90               vu 02 20  1 622      
    mov rax,[rbp-120] (fwk)               ;#00450F95: 48:213105 88               uv 01 20  1 623      
    call #0043F4D8 (:%opSub)              ;#00450F99: 350 3AE5FEFF               v  00 00  1 623      
    jmp #00450FEF                         ;#00450F9E: 353 4F                     v  00 00  1 624      
;   331             else
;   332                 digit = floor(f)
    lea rdi,[rbp-104] (digit)             ;#00450FA0: 48:215175 98               uv 80 20  1 625      
    mov rax,[rbp-112] (f)                 ;#00450FA4: 48:213105 90               vu 01 20  1 625      
    call #0043F81C (:%opFloor)            ;#00450FA8: 350 6FE8FEFF               v  00 00  1 626      
    mov r15,h4                            ;#00450FAD: 49:277 0000000000000040    uv 8000 00  1 627      
    cmp rax,r15                           ;#00450FB7: 4C:071370                  uv 00 8001  1 628 8000   
    jl #00450FC8                          ;#00450FBA: 174 0C                     v  00 00  1 628      
    mov rcx,148                           ;#00450FBC: 48:307301 94000000         uv 02 00  1 629      
    call #00442A58 (:%opTchkFail)         ;#00450FC3: 350 901AFFFF               v  00 00  1 629      
;   333                 f = (f-digit)*10
    lea rdi,[rbp-176] (symtab[161])       ;#00450FC8: 48:215275 50FFFFFF         uv 80 20  1 630      
    mov rcx,[rbp-112] (f)                 ;#00450FCF: 48:213115 90               vu 02 20  1 630      
    call #0043F4D8 (:%opSub)              ;#00450FD3: 350 00E5FEFF               v  00 00  1 631      
    lea rdi,[rbp-112] (f)                 ;#00450FD8: 48:215175 90               uv 80 20  1 632      
    mov rcx,[rbp-176] (symtab[161])       ;#00450FDC: 48:213215 50FFFFFF         vu 02 20  1 632      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#00450FE3: 48:213005 FE10FBFF         uv 01 00  1 633      
    call #0043F67C (:%opMul)              ;#00450FEA: 350 8DE6FEFF               v  00 00  1 633      
;   334             end if
;   335             result &= digit+'0'
    lea rdi,[rbp-176] (symtab[161])       ;#00450FEF: 48:215275 50FFFFFF         uv 80 20  1 634      
    mov rcx,[rbp-104] (digit)             ;#00450FF6: 48:213115 98               vu 02 20  1 634      
    mov rax,[MB_ICONEXCLAMATION]          ;#00450FFA: 48:213005 7711FBFF         uv 01 00  1 635      
    call #0043F4AF (:%opAdd)              ;#00451001: 350 A9E4FEFF               v  00 00  1 635      
    lea rdx,[rbp-136] (result)            ;#00451006: 48:215225 78FFFFFF         uv 04 20  1 636      
    lea rdi,[rbp-136] (result)            ;#0045100D: 48:215275 78FFFFFF         vu 80 20  1 636      
    lea rcx,[rbp-176] (symtab[161])       ;#00451014: 48:215215 50FFFFFF         uv 02 20  1 637      
    xor rax,rax                           ;#0045101B: 48:061300                  vu 01 01  1 637      
    call #0043FC15 (:%opApnd)             ;#0045101E: 350 F2EBFEFF               v  00 00  1 638      
    mov rdi,[rbp-136] (result)            ;#00451023: 48:213275 78FFFFFF         uv 80 20  1 639      
    mov r15,h4                            ;#0045102A: 49:277 0000000000000040    vu 8000 00  1 639      
    cmp rdi,r15                           ;#00451034: 4C:071377                  uv 00 8080  1 640      
    jl #00451040                          ;#00451037: 174 07                     v  00 00  1 640      
    cmp byte[rbx+rdi*4-1],#82             ;#00451039: 200174273 FF 82            u  00 88  2 641      
    je #0045104C                          ;#0045103E: 164 0C                     v  00 00  1 642      
    mov rcx,152                           ;#00451040: 48:307301 98000000         uv 02 00  1 643      
    call #00442A58 (:%opTchkFail)         ;#00451047: 350 0C1AFFFF               v  00 00  1 643      
;   336             if digit then
    mov rsi,[rbp-104] (digit)             ;#0045104C: 48:213165 98               uv 40 20  1 644      
    test rsi,rsi                          ;#00451050: 48:205366                  uv 00 40  1 645 40   
    je #0045105D                          ;#00451053: 164 08                     v  00 00  1 645      
;   337                 nzdigitprinted = 1
    mov qword[rbp-48] (nzdigitprinted),1  ;#00451055: 48:307105 D0 01000000      uv 00 20  1 646      
;   338             end if
;   339             exp -= 1
    mov rcx,[rbp-144] (exp)               ;#0045105D: 48:213215 70FFFFFF         vu 02 20  1 646      
    sub rcx,1                             ;#00451064: 48:203351 01               uv 02 02  1 647      
    mov rdx,rcx                           ;#00451068: 48:213321                  uv 04 02  1 648 02   
    mov [rbp-144] (exp),rcx               ;#0045106B: 48:211215 70FFFFFF         vu 00 22  1 648      
    shl rdx,1                             ;#00451072: 48:321342                  u  04 04  1 649      
    jno #00451083                         ;#00451075: 161 0C                     v  00 00  1 649      
    lea rdi,[rbp-144] (exp)               ;#00451077: 48:215275 70FFFFFF         uv 80 20  1 650      
    call #00442DA9 (:%pAddiii)            ;#0045107E: 350 261DFFFF               v  00 00  1 650      
;   340             if charflag='g' then
    mov rax,[rbp-8] (charflag)            ;#00451083: 48:213105 F8               uv 01 20  1 651      
    cmp rax,103                           ;#00451087: 48:203370 67               uv 00 01  1 652 01   
    jne #00450C84                         ;#0045108B: 017205 F3FBFFFF            v  00 00  1 652      
;   341                 if length(result)>=minfieldwidth and f=0 then exit end if
    mov rdi,[rbp-136] (result)            ;#00451091: 48:213275 78FFFFFF         uv 80 20  1 653      
    mov rsi,[rbx+rdi*4-24]                ;#00451098: 48:48:213164273 E8         uv 40 88  1 656 80 *80*
    mov rcx,[rbp-24] (minfieldwidth)      ;#0045109E: 48:213115 E8               vu 02 20  1 656      
    cmp rsi,rcx                           ;#004510A2: 48:071316                  uv 00 42  1 657      
    jl #004510B1                          ;#004510A5: 174 0A                     v  00 00  1 657      
    mov rax,[rbp-112] (f)                 ;#004510A7: 48:213105 90               uv 01 20  1 658      
    cmp rax,0                             ;#004510AB: 48:203370 00               uv 00 01  1 659 01   
    je #004510E4                          ;#004510AF: 164 33                     v  00 00  1 659      
;   342 --DEV: try printf(1,"%6.2f\n%6.2g\n",96.5)
;   343 -- (same results as RDS Eu, but that does not necessarily make it right!)
;   344 -- Possible fix is to remove this line...(19/8 put the new flag test round it instead)
;   345                 if nzdigitprinted then
    mov rdi,[rbp-48] (nzdigitprinted)     ;#004510B1: 48:213175 D0               uv 80 20  1 660      
    test rdi,rdi                          ;#004510B5: 48:205377                  uv 00 80  1 661 80   
    je #00450C84                          ;#004510B8: 017204 C6FBFFFF            v  00 00  1 661      
;   346                     precision -= 1
    mov rsi,[rbp-32] (precision)          ;#004510BE: 48:213165 E0               uv 40 20  1 662      
    sub rsi,1                             ;#004510C2: 48:203356 01               uv 40 40  1 663 40   
    mov rdx,rsi                           ;#004510C6: 48:213326                  uv 04 40  1 664 40   
    mov [rbp-32] (precision),rsi          ;#004510C9: 48:211165 E0               vu 00 60  1 664      
    shl rdx,1                             ;#004510CD: 48:321342                  u  04 04  1 665      
    jno #00450C84                         ;#004510D0: 017201 AEFBFFFF            v  00 00  1 665      
    lea rdi,[rbp-32] (precision)          ;#004510D6: 48:215175 E0               uv 80 20  1 666      
    call #00442DA9 (:%pAddiii)            ;#004510DA: 350 CA1CFFFF               v  00 00  1 666      
;   347                 end if
;   348             end if
;   349         end while
    jmp #00450C84                         ;#004510DF: 351 A0FBFFFF               v  00 00  1 667      
;   350         if length(result)=0 then
    mov rcx,[rbp-136] (result)            ;#004510E4: 48:213215 78FFFFFF         uv 02 20  1 668      
    mov rax,[rbx+rcx*4-24]                ;#004510EB: 48:48:213104213 E8         uv 01 0A  1 671 02 *02*
    cmp rax,0                             ;#004510F1: 48:203370 00               uv 00 01  1 672 01   
    jne #00451111                         ;#004510F5: 165 1A                     v  00 00  1 672      
;   351 --          result = "0"
;   352             result = repeat('0',1)
    lea rdi,[rbp-136] (result)            ;#004510F7: 48:215275 78FFFFFF         uv 80 20  1 673      
    mov rax,48                            ;#004510FE: 48:307300 30000000         vu 01 00  1 673      
    mov rcx,1                             ;#00451105: 48:307301 01000000         uv 02 00  1 674      
    call #0043B1E1 (:%opRepCh)            ;#0045110C: 350 D0A0FEFF               v  00 00  1 674      
;   353         end if
;   354         result = round(result,f,exp,charflag,digit)--,minfieldwidth)
    mov rcx,12                            ;#00451111: 48:307301 0C000000         uv 02 00  1 675      
    mov rdx,102                           ;#00451118: 48:307302 66000000         vu 04 00  1 675      
    call #004428DB (:%opFrame) (round)    ;#0045111F: 350 B717FFFF               v  00 00  1 676      
    mov rdi,[rbp+40] (prevebp)            ;#00451124: 48:213175 28               uv 80 20  1 677      
    mov rax,[rdi-136]                     ;#00451128: 48:213207 78FFFFFF         uv 01 80  1 680 80 *80*
    mov [rdi-136],r15                     ;#0045112F: 4C:211277 78FFFFFF         vu 00 8080  1 680      
    mov [rbp] (result),rax                ;#00451136: 48:211105 00               uv 00 21  1 681      
    mov rdi,[rbp+40] (prevebp)            ;#0045113A: 48:213175 28               vu 80 20  1 681      
    mov rax,[rdi-112]                     ;#0045113E: 48:213107 90               uv 01 80  1 684    *80*
    xor rbx,rbx                           ;#00451142: 48:061333                  vu 08 08  1 684      
    mov r15,h4                            ;#00451145: 49:277 0000000000000040    uv 8000 00  1 685      
    cmp rax,r15                           ;#0045114F: 4C:071370                  uv 00 8001  1 686 8000   
    jl #0045115F                          ;#00451152: 174 0B                     v  00 00  1 686      
    add qword[rbx+rax*4-16],1             ;#00451154: 48:203104203 F0 01         u  00 09  3 687      
    cmp eax,149                           ;#0045115A: 075 95000000               vu 00 01  1 689      
    mov [rbp-8] (f),rax                   ;#0045115F: 48:211105 F8               uv 00 21  1 690      
    mov rdi,[rbp+40] (prevebp)            ;#00451163: 48:213175 28               vu 80 20  1 690      
    mov rax,[rdi-144]                     ;#00451167: 48:213207 70FFFFFF         uv 01 80  1 693    *80*
    mov [rbp-16] (exp),rax                ;#0045116E: 48:211105 F0               uv 00 21  1 694 01   
    mov rdi,[rbp+40] (prevebp)            ;#00451172: 48:213175 28               vu 80 20  1 694      
    mov rax,[rdi-8]                       ;#00451176: 48:213107 F8               uv 01 80  1 697    *80*
    mov [rbp-24] (charflag),rax           ;#0045117A: 48:211105 E8               uv 00 21  1 698 01   
    mov rdi,[rbp+40] (prevebp)            ;#0045117E: 48:213175 28               vu 80 20  1 698      
    mov rax,[rdi-104]                     ;#00451182: 48:213107 98               uv 01 80  1 701    *80*
    mov [rbp-32] (digit),rax              ;#00451186: 48:211105 E0               uv 00 21  1 702 01   
    mov qword[retaddr],#00451197          ;#0045118A: 48:307105 20 97114500      vu 00 20  1 702      
    jmp #00451360 (code:round)            ;#00451192: 351 C9010000               v  00 00  1 703      
    push rax                              ;#00451197: 120                        uv 00 01  1 704      
    mov rdi,[rbp-136] (result)            ;#00451198: 48:213275 78FFFFFF         vu 80 20  1 704      
    mov r15,h4                            ;#0045119F: 49:277 0000000000000040    uv 8000 00  1 705      
    cmp rdi,r15                           ;#004511A9: 4C:071377                  uv 00 8080  1 706 8000   
    jle #004511BE                         ;#004511AC: 176 10                     v  00 00  1 706      
    sub qword[rbx+rdi*4-16],1             ;#004511AE: 48:203154273 F0 01         u  00 88  3 707      
    jne #004511BE                         ;#004511B4: 165 08                     v  00 00  1 709      
    mov rdx,rdi                           ;#004511B6: 48:213327                  uv 04 80  1 710      
    call #004422DA (:%pDealloc)           ;#004511B9: 350 1C11FFFF               v  00 00  1 710      
    pop dword[rbp-136] (result)           ;#004511BE: 217205 78FFFFFF            np 00 20  3 711      
;   355         k = find('!',result)
    mov rcx,7                             ;#004511C4: 48:307301 07000000         uv 02 00  1 714      
    mov rdx,75                            ;#004511CB: 48:307302 4B000000         vu 04 00  1 714      
    call #004428DB (:%opFrame) (find)     ;#004511D2: 350 0417FFFF               v  00 00  1 715      
    mov qword[rbp] (x),33                 ;#004511D7: 48:307105 00 21000000      uv 00 20  1 716      
    mov rdi,[rbp+40] (prevebp)            ;#004511DF: 48:213175 28               vu 80 20  1 716      
    mov rax,[rdi-136]                     ;#004511E3: 48:213207 78FFFFFF         uv 01 80  1 719    *80*
    xor rbx,rbx                           ;#004511EA: 48:061333                  vu 08 08  1 719      
    mov r15,h4                            ;#004511ED: 49:277 0000000000000040    uv 8000 00  1 720      
    cmp rax,r15                           ;#004511F7: 4C:071370                  uv 00 8001  1 721 8000   
    jl #00451207                          ;#004511FA: 174 0B                     v  00 00  1 721      
    add qword[rbx+rax*4-16],1             ;#004511FC: 48:203104203 F0 01         u  00 09  3 722      
    cmp eax,152                           ;#00451202: 075 98000000               vu 00 01  1 724      
    mov [rbp-8] (s),rax                   ;#00451207: 48:211105 F8               uv 00 21  1 725      
    mov qword[retaddr],#00451218          ;#0045120B: 48:307105 20 18124500      vu 00 20  1 725      
    jmp #0043DAD6 (code:find)             ;#00451213: 351 BEC8FEFF               v  00 00  1 726      
    mov [rbp-152] (k),rax                 ;#00451218: 48:211205 68FFFFFF         uv 00 21  1 727      
;   356         if k then
    test rax,rax                          ;#0045121F: 48:205300                  vu 00 01  1 727      
    je #004512C5                          ;#00451222: 017204 9D000000            v  00 00  1 728      
;   357             if k=length(result) then
    mov rsi,[rbp-136] (result)            ;#00451228: 48:213265 78FFFFFF         uv 40 20  1 729      
    mov rcx,[rbx+rsi*4-24]                ;#0045122F: 48:48:213114263 E8         uv 02 48  1 732 40 *40*
    cmp rax,rcx                           ;#00451235: 48:071310                  uv 00 03  1 733 02   
    jne #00451260                         ;#00451238: 165 26                     v  00 00  1 733      
;   358                 result = result[1..-2]
    lea rdx,[rbp-136] (result)            ;#0045123A: 48:215225 78FFFFFF         uv 04 20  1 734      
    mov rcx,1                             ;#00451241: 48:307301 01000000         vu 02 00  1 734      
    push #0045125E                        ;#00451248: 150 5E124500               uv 00 00  1 735      
    push rdx                              ;#0045124D: 122                        vu 00 04  1 735      
    push -2                               ;#0045124E: 152 FE                     uv 00 00  1 736      
    push 1                                ;#00451250: 152 01                     vu 00 00  1 736      
    mov rdx,152                           ;#00451252: 48:307302 98000000         uv 04 00  1 737      
    jmp #00440F1F (:%pSubss)              ;#00451259: 351 C1FCFEFF               v  00 00  1 737      
    jmp #0045129F                         ;#0045125E: 353 3F                     v  00 00  1 738      
;   359             else
;   360                 result[k] = '.'
    mov rdi,rax                           ;#00451260: 48:211307                  uv 80 01  1 739      
    mov rcx,46                            ;#00451263: 48:307301 2E000000         vu 02 00  1 739      
    lea rax,[rbp-136] (result)            ;#0045126A: 48:215205 78FFFFFF         uv 01 20  1 740      
    call #00440C54 (:%pRepe1)             ;#00451271: 350 DEF9FEFF               v  00 00  1 740      
    mov rcx,[rbp-136] (result)            ;#00451276: 48:213215 78FFFFFF         uv 02 20  1 741      
    mov r15,h4                            ;#0045127D: 49:277 0000000000000040    vu 8000 00  1 741      
    cmp rcx,r15                           ;#00451287: 4C:071371                  uv 00 8002  1 742      
    jl #00451293                          ;#0045128A: 174 07                     v  00 00  1 742      
    cmp byte[rbx+rcx*4-1],#82             ;#0045128C: 200174213 FF 82            u  00 0A  2 743      
    je #0045129F                          ;#00451291: 164 0C                     v  00 00  1 744      
    mov rcx,152                           ;#00451293: 48:307301 98000000         uv 02 00  1 745      
    call #00442A58 (:%opTchkFail)         ;#0045129A: 350 B917FFFF               v  00 00  1 745      
;   361             end if
;   362             exp += 1
    mov rsi,[rbp-144] (exp)               ;#0045129F: 48:213265 70FFFFFF         uv 40 20  1 746      
    add rsi,1                             ;#004512A6: 48:203306 01               uv 40 40  1 747 40   
    mov rdx,rsi                           ;#004512AA: 48:213326                  uv 04 40  1 748 40   
    mov [rbp-144] (exp),rsi               ;#004512AD: 48:211265 70FFFFFF         vu 00 60  1 748      
    shl rdx,1                             ;#004512B4: 48:321342                  u  04 04  1 749      
    jno #004512C5                         ;#004512B7: 161 0C                     v  00 00  1 749      
    lea rdi,[rbp-144] (exp)               ;#004512B9: 48:215275 70FFFFFF         uv 80 20  1 750      
    call #00442DA9 (:%pAddiii)            ;#004512C0: 350 E41AFFFF               v  00 00  1 750      
;   363         end if
;   364         if exp>-1 then
    mov rax,[rbp-144] (exp)               ;#004512C5: 48:213205 70FFFFFF         uv 01 20  1 751      
    cmp rax,-1                            ;#004512CC: 48:203370 FF               uv 00 01  1 752 01   
    jle #0045134D                         ;#004512D0: 176 7B                     v  00 00  1 752      
;   365             while exp>-1 do
    mov rdi,[rbp-144] (exp)               ;#004512D2: 48:213275 70FFFFFF         uv 80 20  1 753      
    cmp rdi,-1                            ;#004512D9: 48:203377 FF               uv 00 80  1 754 80   
    jle #0045134D                         ;#004512DD: 176 6E                     v  00 00  1 754      
;   366                 result &= '0'
    lea rdx,[rbp-136] (result)            ;#004512DF: 48:215225 78FFFFFF         uv 04 20  1 755      
    lea rdi,[rbp-136] (result)            ;#004512E6: 48:215275 78FFFFFF         vu 80 20  1 755      
    lea rcx,[MB_ICONEXCLAMATION]          ;#004512ED: 48:215015 840EFBFF         uv 02 00  1 756      
    xor rax,rax                           ;#004512F4: 48:061300                  vu 01 01  1 756      
    call #0043FC15 (:%opApnd)             ;#004512F7: 350 19E9FEFF               v  00 00  1 757      
    mov rcx,[rbp-136] (result)            ;#004512FC: 48:213215 78FFFFFF         uv 02 20  1 758      
    mov r15,h4                            ;#00451303: 49:277 0000000000000040    vu 8000 00  1 758      
    cmp rcx,r15                           ;#0045130D: 4C:071371                  uv 00 8002  1 759      
    jl #00451319                          ;#00451310: 174 07                     v  00 00  1 759      
    cmp byte[rbx+rcx*4-1],#82             ;#00451312: 200174213 FF 82            u  00 0A  2 760      
    je #00451325                          ;#00451317: 164 0C                     v  00 00  1 761      
    mov rcx,152                           ;#00451319: 48:307301 98000000         uv 02 00  1 762      
    call #00442A58 (:%opTchkFail)         ;#00451320: 350 3317FFFF               v  00 00  1 762      
;   367                 exp -= 1
    mov rsi,[rbp-144] (exp)               ;#00451325: 48:213265 70FFFFFF         uv 40 20  1 763      
    sub rsi,1                             ;#0045132C: 48:203356 01               uv 40 40  1 764 40   
    mov rdx,rsi                           ;#00451330: 48:213326                  uv 04 40  1 765 40   
    mov [rbp-144] (exp),rsi               ;#00451333: 48:211265 70FFFFFF         vu 00 60  1 765      
    shl rdx,1                             ;#0045133A: 48:321342                  u  04 04  1 766      
    jno #004512D2                         ;#0045133D: 161 93                     v  00 00  1 766      
    lea rdi,[rbp-144] (exp)               ;#0045133F: 48:215275 70FFFFFF         uv 80 20  1 767      
    call #00442DA9 (:%pAddiii)            ;#00451346: 350 5E1AFFFF               v  00 00  1 767      
;   368             end while
    jmp #004512D2                         ;#0045134B: 353 85                     v  00 00  1 768      
;   369         end if
;   370     end if
;   371     return result
    mov rax,[rbp-136] (result)            ;#0045134D: 48:213205 78FFFFFF         uv 01 20  1 769      
    mov [rbp-136] (result),rbx            ;#00451354: 48:211235 78FFFFFF         vu 00 28  1 769      
    jmp #0044298D (:%opRetf)              ;#0045135B: 351 2D16FFFF               v  00 00  1 770      
;   372 end function
;   373 
;   374 procedure badfmt()
;   375 --/**/  #ilASM{ mov al,69                       -- Phix
    mov al,69                             ;#004519AB: 260 45                     uv 01 00  1   1      
;   376 --!/**/         xor edi,edi     -- ep1 unused   -- Phix
;   377 --!/**/         xor esi,esi     -- ep2 unused   -- Phix
;   378 --DEV (this is :%pRTErn:, see also pfileioN.e for ebp/calledfrom etc)
;   379 --      pop edx -- era
;   380 --      sub edx,1
;   381 --      jmp :!iDiag
;   382 --      int3
;   383 --/**/          call :%pRTErn } -- fatal error  -- Phix
    call #00442DC8 (:%pRTErn)             ;#004519AD: 350 1614FFFF               v  00 00  1   1      
;   384 --/**/                                  --/*    -- Phix
;   385         puts(1,"error in format string\n")      -- RDS
;   386         if getc(0) then end if                  -- RDS
;   387         abort(1)                                -- RDS --*/
    jmp #0044298D (:%opRetf)              ;#004519B2: 351 D60FFFFF               v  00 00  1   2      
;   388 end procedure
;   389 
;   390 function useFlatString(sequence args, integer nxt, sequence format, integer i)
;   391 -- permit printf(1,"%s","Hello") to work as {"Hello"} - but only if:
;   392 -- 1) this is the first % (nxt=1)
;   393 -- 2) there are no more %'s in the format, except for %%
;   394 -- 3) args is a flat string
;   395 object o
;   396     if nxt!=1 then return 0 end if
    mov rdi,[rbp-8] (nxt)                 ;#0045174E: 48:213175 F8               uv 80 20  1   1      
    cmp rdi,1                             ;#00451752: 48:203377 01               uv 00 80  1   2 80   
    je #00451760                          ;#00451756: 164 08                     v  00 00  1   2      
    xor rax,rax                           ;#00451758: 48:061300                  uv 01 01  1   3      
    jmp #0044298D (:%opRetf)              ;#0045175B: 351 2D12FFFF               v  00 00  1   3      
;   397     for j=i+1 to length(format) do
    lea rdi,[rbp-40] (symtab[183])        ;#00451760: 48:215175 D8               uv 80 20  1   4      
    mov rcx,[rbp-24] (i)                  ;#00451764: 48:213115 E8               vu 02 20  1   4      
    mov rax,qword[#00402030]              ;#00451768: 48:213005 C108FBFF         uv 01 00  1   5      
    call #0043F4AF (:%opAdd)              ;#0045176F: 350 3BDDFEFF               v  00 00  1   5      
    mov rsi,[rbp-16] (format)             ;#00451774: 48:213165 F0               uv 40 20  1   6      
    mov rdi,[rbx+rsi*4-24]                ;#00451778: 48:48:213174263 E8         uv 80 48  1   9 40 *40*
    mov [rbp-48] (symtab[184]),rdi        ;#0045177E: 48:211175 D0               uv 00 A0  1  10 80   
    mov rdx,[rbp-56] (j)                  ;#00451782: 48:213125 C8               vu 04 20  1  10      
    mov r15,h4                            ;#00451786: 49:277 0000000000000040    uv 8000 00  1  11      
    cmp rdx,r15                           ;#00451790: 4C:071372                  uv 00 8004  1  12 8000   
    jle #004517A2                         ;#00451793: 176 0D                     v  00 00  1  12      
    sub qword[rbx+rdx*4-16],1             ;#00451795: 48:203154223 F0 01         u  00 0C  3  13      
    jne #004517A2                         ;#0045179B: 165 05                     v  00 00  1  15      
    call #004422DA (:%pDealloc)           ;#0045179D: 350 380BFFFF               v  00 00  1  16      
    mov rcx,[rbp-40] (symtab[183])        ;#004517A2: 48:213115 D8               uv 02 20  1  17      
    mov r15,h4                            ;#004517A6: 49:277 0000000000000040    vu 8000 00  1  17      
    cmp rcx,r15                           ;#004517B0: 4C:071371                  uv 00 8002  1  18      
    jl #004517CA                          ;#004517B3: 174 15                     v  00 00  1  18      
    mov al,120                            ;#004517B5: 260 78                     uv 01 00  1  19      
    mov rdi,183                           ;#004517B7: 48:307307 B7000000         vu 80 00  1  19      
    mov rsi,1                             ;#004517BE: 48:307306 01000000         uv 40 00  1  20      
    call #00442DC8 (:%pRTErn)             ;#004517C5: 350 FE15FFFF               v  00 00  1  20      
    mov [rbp-56] (j),rcx                  ;#004517CA: 48:211115 C8               uv 00 22  1  21      
    cmp rcx,rdi                           ;#004517CE: 48:073317                  vu 00 82  1  21      
    jg #0045184E                          ;#004517D1: 177 7B                     v  00 00  1  22      
;   398         if format[j]='%' then
    mov rdi,[rbp-56] (j)                  ;#004517D3: 48:213175 C8               uv 80 20  1  23      
    mov rsi,[rbp-16] (format)             ;#004517D7: 48:213165 F0               vu 40 20  1  23      
    mov rdx,180                           ;#004517DB: 48:307302 B4000000         uv 04 00  1  24      
    call #00441762 (:%pSubse1is)          ;#004517E2: 350 7BFFFEFF               v  00 00  1  24      
    cmp rax,37                            ;#004517E7: 48:203370 25               uv 00 01  1  25      
    jne #00451839                         ;#004517EB: 165 4C                     v  00 00  1  25      
;   399             if j=length(format) or format[j+1]!='%' then return 0 end if
    mov rcx,[rbp-16] (format)             ;#004517ED: 48:213115 F0               uv 02 20  1  26      
    mov rdi,[rbx+rcx*4-24]                ;#004517F1: 48:48:213174213 E8         uv 80 0A  1  29 02 *02*
    mov rsi,[rbp-56] (j)                  ;#004517F7: 48:213165 C8               vu 40 20  1  29      
    cmp rsi,rdi                           ;#004517FB: 48:071376                  uv 00 C0  1  30      
    je #00451831                          ;#004517FE: 164 31                     v  00 00  1  30      
    add rsi,1                             ;#00451800: 48:203306 01               uv 40 40  1  31      
    mov rdx,rsi                           ;#00451804: 48:213326                  uv 04 40  1  32 40   
    mov [rbp-72] (symtab[188]),rsi        ;#00451807: 48:211165 B8               vu 00 60  1  32      
    shl rdx,1                             ;#0045180B: 48:321342                  u  04 04  1  33      
    jno #00451819                         ;#0045180E: 161 09                     v  00 00  1  33      
    lea rdi,[rbp-72] (symtab[188])        ;#00451810: 48:215175 B8               uv 80 20  1  34      
    call #00442DA9 (:%pAddiii)            ;#00451814: 350 9015FFFF               v  00 00  1  34      
    mov rdi,rsi                           ;#00451819: 48:211367                  uv 80 40  1  35      
    mov rsi,rcx                           ;#0045181C: 48:211316                  vu 40 02  1  35      
    mov rdx,180                           ;#0045181F: 48:307302 B4000000         uv 04 00  1  36      
    call #00441762 (:%pSubse1is)          ;#00451826: 350 37FFFEFF               v  00 00  1  36      
    cmp rax,37                            ;#0045182B: 48:203370 25               uv 00 01  1  37      
    je #00451839                          ;#0045182F: 164 08                     v  00 00  1  37      
    xor rax,rax                           ;#00451831: 48:061300                  uv 01 01  1  38      
    jmp #0044298D (:%opRetf)              ;#00451834: 351 5411FFFF               v  00 00  1  38      
;   400         end if
;   401     end for
    mov rdi,[rbp-56] (j)                  ;#00451839: 48:213175 C8               uv 80 20  1  39      
    mov rsi,[rbp-48] (symtab[184])        ;#0045183D: 48:213165 D0               vu 40 20  1  39      
    add rdi,1                             ;#00451841: 48:203307 01               uv 80 80  1  40      
    cmp rdi,rsi                           ;#00451845: 48:073376                  uv 00 C0  1  41 80   
    mov [rbp-56] (j),rdi                  ;#00451848: 48:211175 C8               vu 00 A0  1  41      
    jle #004517D3                         ;#0045184C: 176 85                     v  00 00  1  42      
;   402     for j=1 to length(args) do
    lea rdi,[rbp-72] (symtab[188])        ;#0045184E: 48:215175 B8               uv 80 20  1  43      
    mov rsi,[rbp] (args)                  ;#00451852: 48:213165 00               vu 40 20  1  43      
    mov rdx,178                           ;#00451856: 48:307302 B2000000         uv 04 00  1  44      
    call #0043F28D (:%opLen)              ;#0045185D: 350 2BDAFEFF               v  00 00  1  44      
    mov qword[rbp-80] (j),1               ;#00451862: 48:307105 B0 01000000      uv 00 20  1  45      
    mov rcx,[rbp-72] (symtab[188])        ;#0045186A: 48:213115 B8               vu 02 20  1  45      
    cmp rcx,1                             ;#0045186E: 48:201371 01000000         uv 00 02  1  46      
    jl #0045190B                          ;#00451875: 017214 90000000            v  00 00  1  46      
;   403         o = args[j]
    mov rdi,[rbp-80] (j)                  ;#0045187B: 48:213175 B0               uv 80 20  1  47      
    lea rcx,[rbp-32] (o)                  ;#0045187F: 48:215115 E0               vu 02 20  1  47      
    mov rsi,[rbp] (args)                  ;#00451883: 48:213165 00               uv 40 20  1  48      
    mov rdx,178                           ;#00451887: 48:307302 B2000000         vu 04 00  1  48      
    call #00441675 (:%pSubse1)            ;#0045188E: 350 E2FDFEFF               v  00 00  1  49      
;   404         if not integer(o) then return 0 end if
    mov rax,[rbp-32] (o)                  ;#00451893: 48:213105 E0               uv 01 20  1  50      
    mov r15,h4                            ;#00451897: 49:277 0000000000000040    vu 8000 00  1  50      
    cmp rax,r15                           ;#004518A1: 4C:071370                  uv 00 8001  1  51      
    jl #004518AE                          ;#004518A4: 174 08                     v  00 00  1  51      
    xor rax,rax                           ;#004518A6: 48:061300                  uv 01 01  1  52      
    jmp #0044298D (:%opRetf)              ;#004518A9: 351 DF10FFFF               v  00 00  1  52      
;   405         if o<1 or o>255 then return 0 end if
    mov rdi,1                             ;#004518AE: 48:307307 01000000         uv 80 00  1  53      
    mov rsi,26                            ;#004518B5: 48:307306 1A000000         vu 40 00  1  53      
    mov rdx,182                           ;#004518BC: 48:307302 B6000000         uv 04 00  1  54      
    call #0043FA81 (:%opJcc)              ;#004518C3: 350 B9E1FEFF               v  00 00  1  54      
    jl #004518EA                          ;#004518C8: 174 20                     v  00 00  1  55      
    mov rdi,255                           ;#004518CA: 48:307307 FF000000         uv 80 00  1  56      
    mov rax,[rbp-32] (o)                  ;#004518D1: 48:213105 E0               vu 01 20  1  56      
    mov rsi,190                           ;#004518D5: 48:307306 BE000000         uv 40 00  1  57      
    mov rdx,182                           ;#004518DC: 48:307302 B6000000         vu 04 00  1  57      
    call #0043FA81 (:%opJcc)              ;#004518E3: 350 99E1FEFF               v  00 00  1  58      
    jle #004518F2                         ;#004518E8: 176 08                     v  00 00  1  59      
    xor rax,rax                           ;#004518EA: 48:061300                  uv 01 01  1  60      
    jmp #0044298D (:%opRetf)              ;#004518ED: 351 9B10FFFF               v  00 00  1  60      
;   406     end for
    mov rcx,[rbp-80] (j)                  ;#004518F2: 48:213115 B0               uv 02 20  1  61      
    mov rdi,[rbp-72] (symtab[188])        ;#004518F6: 48:213175 B8               vu 80 20  1  61      
    add rcx,1                             ;#004518FA: 48:203301 01               uv 02 02  1  62      
    cmp rcx,rdi                           ;#004518FE: 48:073317                  uv 00 82  1  63 02   
    mov [rbp-80] (j),rcx                  ;#00451901: 48:211115 B0               vu 00 22  1  63      
    jle #0045187B                         ;#00451905: 017216 70FFFFFF            v  00 00  1  64      
;   407     return 1
    mov rax,1                             ;#0045190B: 48:307300 01000000         uv 01 00  1  65      
    jmp #0044298D (:%opRetf)              ;#00451912: 351 7610FFFF               v  00 00  1  65      
;   408 end function
;   409 
;   410 string hexchar
;   411 sequence bases
;   412 
;   413 --without trace
;   414 global function sprintf(sequence format, object args)
;   415 integer i, fi, fidx
;   416 integer nxt
;   417 string result, r1
;   418 object o, oj
;   419 atom work
;   420 integer base, sign, r1len, hc
;   421 integer lowerHex
;   422 --?result   --DOH, infinite loop! (use puts(1,<string>) instead!)
;   423 integer zerofill
;   424 integer leftjustify
;   425 integer showplus
;   426 integer showcommas
;   427 integer minfieldwidth
;   428 --      minfieldwidth = 0
;   429 integer precision
;   430 --      precision = 0
;   431 integer tmp
;   432 
;   433     if not init2 then
    mov rsi,[#004021E8] (init2)           ;#0044E450: 48:213065 913DFBFF         uv 40 00  1   1      
    test rsi,rsi                          ;#0044E457: 48:205366                  uv 00 40  1   2 40   
    jne #0044E566                         ;#0044E45A: 017205 06010000            v  00 00  1   2      
;   434 -- [DEV] technically this isn't thread safe... (code shown commented out should be enough, once those routines work)
;   435 --      enter_cs()
;   436         inf = 1e300*1e300
    mov rdi,qword[#00402288]              ;#0044E460: 48:213075 213EFBFF         uv 80 00  1   3      
    mov rdx,[#004021F0] (inf)             ;#0044E467: 48:213025 823DFBFF         vu 04 00  1   3      
    mov r15,h4                            ;#0044E46E: 49:277 0000000000000040    uv 8000 00  1   4      
    cmp rdi,r15                           ;#0044E478: 4C:071377                  uv 00 8080  1   5 8000   
    jl #0044E483                          ;#0044E47B: 174 06                     v  00 00  1   5      
    add qword[rbx+rdi*4-16],1             ;#0044E47D: 48:203104273 F0 01         u  00 88  3   6      
    mov [#004021F0] (inf),rdi             ;#0044E483: 48:211075 663DFBFF         vu 00 80  1   8      
    mov r15,h4                            ;#0044E48A: 49:277 0000000000000040    uv 8000 00  1   9      
    cmp rdx,r15                           ;#0044E494: 4C:071372                  uv 00 8004  1  10 8000   
    jle #0044E4A6                         ;#0044E497: 176 0D                     v  00 00  1  10      
    sub qword[rbx+rdx*4-16],1             ;#0044E499: 48:203154223 F0 01         u  00 0C  3  11      
    jne #0044E4A6                         ;#0044E49F: 165 05                     v  00 00  1  13      
    call #004422DA (:%pDealloc)           ;#0044E4A1: 350 343EFFFF               v  00 00  1  14      
;   437         -- Erm, this one is a bit bizarre...
;   438         -- On the one hand it seems RDS Eu does not support nan properly, but then it somehow does...
;   439         -- If you try testing for nan, it seems to go all pear-shaped, but avoiding the tests
;   440         --  seems to make it happy again, and yet print "nan" and "inf" like a good little boy...
;   441         -- Of course, you shouldn't be using this code on RDS Eu anyway.
;   442         --
;   443 --/**/  nan = -(inf/inf)        --/* Phix
    lea rdi,[rbp-184] (symtab[218])       ;#0044E4A6: 48:215275 48FFFFFF         uv 80 20  1  15      
    mov rcx,[#004021F0] (inf)             ;#0044E4AD: 48:213015 3C3DFBFF         vu 02 00  1  15      
    mov rax,rcx                           ;#0044E4B4: 48:211310                  uv 01 02  1  16      
    call #0043F564 (:%opDiv)              ;#0044E4B7: 350 A810FFFF               v  00 00  1  16      
    lea rdi,[#004021F8] (nan)             ;#0044E4BC: 48:215075 353DFBFF         uv 80 00  1  17      
    mov rcx,[rbp-184] (symtab[218])       ;#0044E4C3: 48:213215 48FFFFFF         vu 02 20  1  17      
    call #0043F746 (:%opUminus)           ;#0044E4CA: 350 7712FFFF               v  00 00  1  18      
;   444         nan = 3.245673689e243   --   RDS --*/
;   445 
;   446         bases = {10,16,8,2}
    mov rax,qword[#00402290]              ;#0044E4CF: 48:213005 BA3DFBFF         uv 01 00  1  19      
    mov rdx,[#00402278] (bases)           ;#0044E4D6: 48:213025 9B3DFBFF         vu 04 00  1  19      
    mov r15,h4                            ;#0044E4DD: 49:277 0000000000000040    uv 8000 00  1  20      
    cmp rax,r15                           ;#0044E4E7: 4C:071370                  uv 00 8001  1  21 8000   
    jl #0044E4F2                          ;#0044E4EA: 174 06                     v  00 00  1  21      
    add qword[rbx+rax*4-16],1             ;#0044E4EC: 48:203104203 F0 01         u  00 09  3  22      
    mov [#00402278] (bases),rax           ;#0044E4F2: 48:211005 7F3DFBFF         vu 00 01  1  24      
    mov r15,h4                            ;#0044E4F9: 49:277 0000000000000040    uv 8000 00  1  25      
    cmp rdx,r15                           ;#0044E503: 4C:071372                  uv 00 8004  1  26 8000   
    jle #0044E515                         ;#0044E506: 176 0D                     v  00 00  1  26      
    sub qword[rbx+rdx*4-16],1             ;#0044E508: 48:203154223 F0 01         u  00 0C  3  27      
    jne #0044E515                         ;#0044E50E: 165 05                     v  00 00  1  29      
    call #004422DA (:%pDealloc)           ;#0044E510: 350 C53DFFFF               v  00 00  1  30      
;   447         hexchar = "0123456789ABCDEFabcdef"
    mov rsi,qword[#00402298]              ;#0044E515: 48:213065 7C3DFBFF         uv 40 00  1  31      
    mov rdx,[#00402270] (hexchar)         ;#0044E51C: 48:213025 4D3DFBFF         vu 04 00  1  31      
    mov r15,h4                            ;#0044E523: 49:277 0000000000000040    uv 8000 00  1  32      
    cmp rsi,r15                           ;#0044E52D: 4C:071376                  uv 00 8040  1  33 8000   
    jl #0044E538                          ;#0044E530: 174 06                     v  00 00  1  33      
    add qword[rbx+rsi*4-16],1             ;#0044E532: 48:203104263 F0 01         u  00 48  3  34      
    mov [#00402270] (hexchar),rsi         ;#0044E538: 48:211065 313DFBFF         vu 00 40  1  36      
    mov r15,h4                            ;#0044E53F: 49:277 0000000000000040    uv 8000 00  1  37      
    cmp rdx,r15                           ;#0044E549: 4C:071372                  uv 00 8004  1  38 8000   
    jle #0044E55B                         ;#0044E54C: 176 0D                     v  00 00  1  38      
    sub qword[rbx+rdx*4-16],1             ;#0044E54E: 48:203154223 F0 01         u  00 0C  3  39      
    jne #0044E55B                         ;#0044E554: 165 05                     v  00 00  1  41      
    call #004422DA (:%pDealloc)           ;#0044E556: 350 7F3DFFFF               v  00 00  1  42      
;   448 --      leave_cs()
;   449         init2 = 1
    mov qword[#004021E8] (init2),1        ;#0044E55B: 48:307005 823CFBFF 01000000 uv 00 00  1  43      
;   450     end if
;   451     nxt = 1
    mov qword[rbp-40] (nxt),1             ;#0044E566: 48:307105 D8 01000000      vu 00 20  1  43      
;   452 --  result = ""
;   453     result = repeat(' ',0)
    lea rdi,[rbp-48] (result)             ;#0044E56E: 48:215175 D0               uv 80 20  1  44      
    mov rax,32                            ;#0044E572: 48:307300 20000000         vu 01 00  1  44      
    mov rcx,0                             ;#0044E579: 48:307301 00000000         uv 02 00  1  45      
    call #0043B1E1 (:%opRepCh)            ;#0044E580: 350 5CCCFEFF               v  00 00  1  45      
;   454     i = 1
    mov qword[rbp-16] (i),1               ;#0044E585: 48:307105 F0 01000000      uv 00 20  1  46      
;   455     while i<=length(format) do
    mov rdi,[rbp] (format)                ;#0044E58D: 48:213175 00               vu 80 20  1  46      
    mov rcx,[rbx+rdi*4-24]                ;#0044E591: 48:48:213114273 E8         uv 02 88  1  49    *80*
    mov rax,[rbp-16] (i)                  ;#0044E597: 48:213105 F0               vu 01 20  1  49      
    cmp rax,rcx                           ;#0044E59B: 48:071310                  uv 00 03  1  50      
    jg #0044FD42                          ;#0044E59E: 017217 9E170000            v  00 00  1  50      
;   456         fi = format[i]
    mov rdi,rax                           ;#0044E5A4: 48:211307                  uv 80 01  1  51      
    mov rsi,[rbp] (format)                ;#0044E5A7: 48:213165 00               vu 40 20  1  51      
    mov rdx,193                           ;#0044E5AB: 48:307302 C1000000         uv 04 00  1  52      
    call #00441762 (:%pSubse1is)          ;#0044E5B2: 350 AB31FFFF               v  00 00  1  52      
    mov [rbp-24] (fi),rax                 ;#0044E5B7: 48:211105 E8               uv 00 21  1  53      
;   457         if fi='%' then
    cmp rax,37                            ;#0044E5BB: 48:203370 25               vu 00 01  1  53      
    jne #0044FCE2                         ;#0044E5BF: 017205 1D170000            v  00 00  1  54      
;   458             i += 1
    mov rdi,[rbp-16] (i)                  ;#0044E5C5: 48:213175 F0               uv 80 20  1  55      
    add rdi,1                             ;#0044E5C9: 48:203307 01               uv 80 80  1  56 80   
    mov rdx,rdi                           ;#0044E5CD: 48:213327                  uv 04 80  1  57 80   
    mov [rbp-16] (i),rdi                  ;#0044E5D0: 48:211175 F0               vu 00 A0  1  57      
    shl rdx,1                             ;#0044E5D4: 48:321342                  u  04 04  1  58      
    jno #0044E5E2                         ;#0044E5D7: 161 09                     v  00 00  1  58      
    lea rdi,[rbp-16] (i)                  ;#0044E5D9: 48:215175 F0               uv 80 20  1  59      
    call #00442DA9 (:%pAddiii)            ;#0044E5DD: 350 C747FFFF               v  00 00  1  59      
;   459             if i>length(format) then badfmt() end if
    mov rcx,[rbp] (format)                ;#0044E5E2: 48:213115 00               uv 02 20  1  60      
    mov rsi,[rbx+rcx*4-24]                ;#0044E5E6: 48:48:213164213 E8         uv 40 0A  1  63 02 *02*
    mov rax,[rbp-16] (i)                  ;#0044E5EC: 48:213105 F0               vu 01 20  1  63      
    cmp rax,rsi                           ;#0044E5F0: 48:071360                  uv 00 41  1  64      
    jle #0044E611                         ;#0044E5F3: 176 1C                     v  00 00  1  64      
    xor rcx,rcx                           ;#0044E5F5: 48:061311                  uv 02 02  1  65      
    mov rdx,175                           ;#0044E5F8: 48:307302 AF000000         vu 04 00  1  65      
    call #004428DB (:%opFrame) (badfmt)   ;#0044E5FF: 350 D742FFFF               v  00 00  1  66      
    mov qword[retaddr],#0044E611          ;#0044E604: 48:307105 20 11E64400      uv 00 20  1  67      
    jmp #004519AB (code:badfmt)           ;#0044E60C: 351 9A330000               v  00 00  1  67      
;   460             fi = format[i]
    mov rdi,[rbp-16] (i)                  ;#0044E611: 48:213175 F0               uv 80 20  1  68      
    mov rsi,[rbp] (format)                ;#0044E615: 48:213165 00               vu 40 20  1  68      
    mov rdx,193                           ;#0044E619: 48:307302 C1000000         uv 04 00  1  69      
    call #00441762 (:%pSubse1is)          ;#0044E620: 350 3D31FFFF               v  00 00  1  69      
    mov [rbp-24] (fi),rax                 ;#0044E625: 48:211105 E8               uv 00 21  1  70      
;   461             if fi='%' then
    cmp rax,37                            ;#0044E629: 48:203370 25               vu 00 01  1  70      
    jne #0044E675                         ;#0044E62D: 165 46                     v  00 00  1  71      
;   462                 result &= '%'
    lea rdx,[rbp-48] (result)             ;#0044E62F: 48:215125 D0               uv 04 20  1  72      
    lea rdi,[rbp-48] (result)             ;#0044E633: 48:215175 D0               vu 80 20  1  72      
    lea rcx,qword[#00402260]              ;#0044E637: 48:215015 223CFBFF         uv 02 00  1  73      
    xor rax,rax                           ;#0044E63E: 48:061300                  vu 01 01  1  73      
    call #0043FC15 (:%opApnd)             ;#0044E641: 350 CF15FFFF               v  00 00  1  74      
    mov rcx,[rbp-48] (result)             ;#0044E646: 48:213115 D0               uv 02 20  1  75      
    mov r15,h4                            ;#0044E64A: 49:277 0000000000000040    vu 8000 00  1  75      
    cmp rcx,r15                           ;#0044E654: 4C:071371                  uv 00 8002  1  76      
    jl #0044E664                          ;#0044E657: 174 0B                     v  00 00  1  76      
    cmp byte[rbx+rcx*4-1],#82             ;#0044E659: 200174213 FF 82            u  00 0A  2  77      
    je #0044FD1C                          ;#0044E65E: 017204 B8160000            v  00 00  1  78      
    mov rcx,199                           ;#0044E664: 48:307301 C7000000         uv 02 00  1  79      
    call #00442A58 (:%opTchkFail)         ;#0044E66B: 350 E843FFFF               v  00 00  1  79      
    jmp #0044FD1C                         ;#0044E670: 351 A7160000               v  00 00  1  80      
;   463             else
;   464                 zerofill = 0
    mov [rbp-128] (zerofill),rbx          ;#0044E675: 48:211135 80               uv 00 28  1  81      
;   465                 leftjustify = 0
    mov [rbp-136] (leftjustify),rbx       ;#0044E679: 48:211235 78FFFFFF         vu 00 28  1  81      
;   466                 showplus = 0
    mov [rbp-144] (showplus),rbx          ;#0044E680: 48:211235 70FFFFFF         uv 00 28  1  82      
;   467                 showcommas = 0
    mov [rbp-152] (showcommas),rbx        ;#0044E687: 48:211235 68FFFFFF         vu 00 28  1  82      
;   468                 if fi='0' then
    cmp rax,48                            ;#0044E68E: 48:203370 30               uv 00 01  1  83      
    jne #0044E6C2                         ;#0044E692: 165 2E                     v  00 00  1  83      
;   469                     zerofill = 1
    mov qword[rbp-128] (zerofill),1       ;#0044E694: 48:307105 80 01000000      uv 00 20  1  84      
;   470                     i += 1
    mov rdi,[rbp-16] (i)                  ;#0044E69C: 48:213175 F0               vu 80 20  1  84      
    add rdi,1                             ;#0044E6A0: 48:203307 01               uv 80 80  1  85      
    mov rdx,rdi                           ;#0044E6A4: 48:213327                  uv 04 80  1  86 80   
    mov [rbp-16] (i),rdi                  ;#0044E6A7: 48:211175 F0               vu 00 A0  1  86      
    shl rdx,1                             ;#0044E6AB: 48:321342                  u  04 04  1  87      
    jno #0044E750                         ;#0044E6AE: 017201 9C000000            v  00 00  1  87      
    lea rdi,[rbp-16] (i)                  ;#0044E6B4: 48:215175 F0               uv 80 20  1  88      
    call #00442DA9 (:%pAddiii)            ;#0044E6B8: 350 EC46FFFF               v  00 00  1  88      
    jmp #0044E750                         ;#0044E6BD: 351 8E000000               v  00 00  1  89      
;   471                 elsif fi='-' then
    cmp rax,45                            ;#0044E6C2: 48:203370 2D               uv 00 01  1  90      
    jne #0044E6F2                         ;#0044E6C6: 165 2A                     v  00 00  1  90      
;   472                     leftjustify = 1
    mov qword[rbp-136] (leftjustify),1    ;#0044E6C8: 48:307205 78FFFFFF 01000000 uv 00 20  1  91      
;   473                     i += 1
    mov rsi,[rbp-16] (i)                  ;#0044E6D3: 48:213165 F0               vu 40 20  1  91      
    add rsi,1                             ;#0044E6D7: 48:203306 01               uv 40 40  1  92      
    mov rdx,rsi                           ;#0044E6DB: 48:213326                  uv 04 40  1  93 40   
    mov [rbp-16] (i),rsi                  ;#0044E6DE: 48:211165 F0               vu 00 60  1  93      
    shl rdx,1                             ;#0044E6E2: 48:321342                  u  04 04  1  94      
    jno #0044E750                         ;#0044E6E5: 161 69                     v  00 00  1  94      
    lea rdi,[rbp-16] (i)                  ;#0044E6E7: 48:215175 F0               uv 80 20  1  95      
    call #00442DA9 (:%pAddiii)            ;#0044E6EB: 350 B946FFFF               v  00 00  1  95      
    jmp #0044E750                         ;#0044E6F0: 353 5E                     v  00 00  1  96      
;   474                 elsif fi='+' then
    cmp rax,43                            ;#0044E6F2: 48:203370 2B               uv 00 01  1  97      
    jne #0044E722                         ;#0044E6F6: 165 2A                     v  00 00  1  97      
;   475                     showplus = 1
    mov qword[rbp-144] (showplus),1       ;#0044E6F8: 48:307205 70FFFFFF 01000000 uv 00 20  1  98      
;   476                     i += 1
    mov rcx,[rbp-16] (i)                  ;#0044E703: 48:213115 F0               vu 02 20  1  98      
    add rcx,1                             ;#0044E707: 48:203301 01               uv 02 02  1  99      
    mov rdx,rcx                           ;#0044E70B: 48:213321                  uv 04 02  1 100 02   
    mov [rbp-16] (i),rcx                  ;#0044E70E: 48:211115 F0               vu 00 22  1 100      
    shl rdx,1                             ;#0044E712: 48:321342                  u  04 04  1 101      
    jno #0044E750                         ;#0044E715: 161 39                     v  00 00  1 101      
    lea rdi,[rbp-16] (i)                  ;#0044E717: 48:215175 F0               uv 80 20  1 102      
    call #00442DA9 (:%pAddiii)            ;#0044E71B: 350 8946FFFF               v  00 00  1 102      
    jmp #0044E750                         ;#0044E720: 353 2E                     v  00 00  1 103      
;   477                 elsif fi=',' then
    cmp rax,44                            ;#0044E722: 48:203370 2C               uv 00 01  1 104      
    jne #0044E750                         ;#0044E726: 165 28                     v  00 00  1 104      
;   478                     showcommas = 3
    mov qword[rbp-152] (showcommas),3     ;#0044E728: 48:307205 68FFFFFF 03000000 uv 00 20  1 105      
;   479                     i+=1
    mov rdi,[rbp-16] (i)                  ;#0044E733: 48:213175 F0               vu 80 20  1 105      
    add rdi,1                             ;#0044E737: 48:203307 01               uv 80 80  1 106      
    mov rdx,rdi                           ;#0044E73B: 48:213327                  uv 04 80  1 107 80   
    mov [rbp-16] (i),rdi                  ;#0044E73E: 48:211175 F0               vu 00 A0  1 107      
    shl rdx,1                             ;#0044E742: 48:321342                  u  04 04  1 108      
    jno #0044E750                         ;#0044E745: 161 09                     v  00 00  1 108      
    lea rdi,[rbp-16] (i)                  ;#0044E747: 48:215175 F0               uv 80 20  1 109      
    call #00442DA9 (:%pAddiii)            ;#0044E74B: 350 5946FFFF               v  00 00  1 109      
;   480                 end if
;   481                 if i>length(format) then badfmt() end if
    mov rsi,[rbp] (format)                ;#0044E750: 48:213165 00               uv 40 20  1 110      
    mov rcx,[rbx+rsi*4-24]                ;#0044E754: 48:48:213114263 E8         uv 02 48  1 113 40 *40*
    mov rax,[rbp-16] (i)                  ;#0044E75A: 48:213105 F0               vu 01 20  1 113      
    cmp rax,rcx                           ;#0044E75E: 48:071310                  uv 00 03  1 114      
    jle #0044E77F                         ;#0044E761: 176 1C                     v  00 00  1 114      
    xor rcx,rcx                           ;#0044E763: 48:061311                  uv 02 02  1 115      
    mov rdx,175                           ;#0044E766: 48:307302 AF000000         vu 04 00  1 115      
    call #004428DB (:%opFrame) (badfmt)   ;#0044E76D: 350 6941FFFF               v  00 00  1 116      
    mov qword[retaddr],#0044E77F          ;#0044E772: 48:307105 20 7FE74400      uv 00 20  1 117      
    jmp #004519AB (code:badfmt)           ;#0044E77A: 351 2C320000               v  00 00  1 117      
;   482                 minfieldwidth = 0
    mov [rbp-160] (minfieldwidth),rbx     ;#0044E77F: 48:211235 60FFFFFF         uv 00 28  1 118      
;   483                 while 1 do
;   484                     fi = format[i]
    mov rdi,[rbp-16] (i)                  ;#0044E786: 48:213175 F0               vu 80 20  1 118      
    mov rsi,[rbp] (format)                ;#0044E78A: 48:213165 00               uv 40 20  1 119      
    mov rdx,193                           ;#0044E78E: 48:307302 C1000000         vu 04 00  1 119      
    call #00441762 (:%pSubse1is)          ;#0044E795: 350 C82FFFFF               v  00 00  1 120      
    mov [rbp-24] (fi),rax                 ;#0044E79A: 48:211105 E8               uv 00 21  1 121      
;   485                     if fi<'0' or fi>'9' then exit end if
    cmp rax,48                            ;#0044E79E: 48:203370 30               vu 00 01  1 121      
    jl #0044E852                          ;#0044E7A2: 017214 AA000000            v  00 00  1 122      
    cmp rax,57                            ;#0044E7A8: 48:203370 39               uv 00 01  1 123      
    jg #0044E852                          ;#0044E7AC: 017217 A0000000            v  00 00  1 123      
;   486                     minfieldwidth = minfieldwidth*10+fi-'0'
    lea rdi,[rbp-184] (symtab[218])       ;#0044E7B2: 48:215275 48FFFFFF         uv 80 20  1 124      
    mov rcx,[rbp-160] (minfieldwidth)     ;#0044E7B9: 48:213215 60FFFFFF         vu 02 20  1 124      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#0044E7C0: 48:213005 2139FBFF         uv 01 00  1 125      
    call #0043F67C (:%opMul)              ;#0044E7C7: 350 B00EFFFF               v  00 00  1 125      
    lea rdi,[rbp-200] (symtab[223])       ;#0044E7CC: 48:215275 38FFFFFF         uv 80 20  1 126      
    mov rcx,[rbp-184] (symtab[218])       ;#0044E7D3: 48:213215 48FFFFFF         vu 02 20  1 126      
    mov rax,[rbp-24] (fi)                 ;#0044E7DA: 48:213105 E8               uv 01 20  1 127      
    call #0043F4AF (:%opAdd)              ;#0044E7DE: 350 CC0CFFFF               v  00 00  1 127      
    lea rdi,[rbp-160] (minfieldwidth)     ;#0044E7E3: 48:215275 60FFFFFF         uv 80 20  1 128      
    mov rcx,[rbp-200] (symtab[223])       ;#0044E7EA: 48:213215 38FFFFFF         vu 02 20  1 128      
    mov rax,[MB_ICONEXCLAMATION]          ;#0044E7F1: 48:213005 8039FBFF         uv 01 00  1 129      
    call #0043F4EB (:%opSubi)             ;#0044E7F8: 350 EE0CFFFF               v  00 00  1 129      
;   487                     i += 1
    mov rdi,[rbp-16] (i)                  ;#0044E7FD: 48:213175 F0               uv 80 20  1 130      
    add rdi,1                             ;#0044E801: 48:203307 01               uv 80 80  1 131 80   
    mov rdx,rdi                           ;#0044E805: 48:213327                  uv 04 80  1 132 80   
    mov [rbp-16] (i),rdi                  ;#0044E808: 48:211175 F0               vu 00 A0  1 132      
    shl rdx,1                             ;#0044E80C: 48:321342                  u  04 04  1 133      
    jno #0044E81A                         ;#0044E80F: 161 09                     v  00 00  1 133      
    lea rdi,[rbp-16] (i)                  ;#0044E811: 48:215175 F0               uv 80 20  1 134      
    call #00442DA9 (:%pAddiii)            ;#0044E815: 350 8F45FFFF               v  00 00  1 134      
;   488                     if i>length(format) then badfmt() end if
    mov rsi,[rbp] (format)                ;#0044E81A: 48:213165 00               uv 40 20  1 135      
    mov rcx,[rbx+rsi*4-24]                ;#0044E81E: 48:48:213114263 E8         uv 02 48  1 138 40 *40*
    mov rax,[rbp-16] (i)                  ;#0044E824: 48:213105 F0               vu 01 20  1 138      
    cmp rax,rcx                           ;#0044E828: 48:071310                  uv 00 03  1 139      
    jle #0044E786                         ;#0044E82B: 017216 55FFFFFF            v  00 00  1 139      
    xor rcx,rcx                           ;#0044E831: 48:061311                  uv 02 02  1 140      
    mov rdx,175                           ;#0044E834: 48:307302 AF000000         vu 04 00  1 140      
    call #004428DB (:%opFrame) (badfmt)   ;#0044E83B: 350 9B40FFFF               v  00 00  1 141      
    mov qword[retaddr],#0044E84D          ;#0044E840: 48:307105 20 4DE84400      uv 00 20  1 142      
    jmp #004519AB (code:badfmt)           ;#0044E848: 351 5E310000               v  00 00  1 142      
;   489                 end while
    jmp #0044E786                         ;#0044E84D: 351 34FFFFFF               v  00 00  1 143      
;   490                 precision = -1
    mov qword[rbp-168] (precision),-1     ;#0044E852: 48:307205 58FFFFFF FFFFFFFF uv 00 20  1 144      
;   491                 if fi='.' then
    cmp rax,46                            ;#0044E85D: 48:203370 2E               vu 00 01  1 144      
    jne #0044E986                         ;#0044E861: 017205 1F010000            v  00 00  1 145      
;   492                     i += 1
    mov rdi,[rbp-16] (i)                  ;#0044E867: 48:213175 F0               uv 80 20  1 146      
    add rdi,1                             ;#0044E86B: 48:203307 01               uv 80 80  1 147 80   
    mov rdx,rdi                           ;#0044E86F: 48:213327                  uv 04 80  1 148 80   
    mov [rbp-16] (i),rdi                  ;#0044E872: 48:211175 F0               vu 00 A0  1 148      
    shl rdx,1                             ;#0044E876: 48:321342                  u  04 04  1 149      
    jno #0044E884                         ;#0044E879: 161 09                     v  00 00  1 149      
    lea rdi,[rbp-16] (i)                  ;#0044E87B: 48:215175 F0               uv 80 20  1 150      
    call #00442DA9 (:%pAddiii)            ;#0044E87F: 350 2545FFFF               v  00 00  1 150      
;   493                     if i>length(format) then badfmt() end if
    mov rsi,[rbp] (format)                ;#0044E884: 48:213165 00               uv 40 20  1 151      
    mov rcx,[rbx+rsi*4-24]                ;#0044E888: 48:48:213114263 E8         uv 02 48  1 154 40 *40*
    mov rax,[rbp-16] (i)                  ;#0044E88E: 48:213105 F0               vu 01 20  1 154      
    cmp rax,rcx                           ;#0044E892: 48:071310                  uv 00 03  1 155      
    jle #0044E8B3                         ;#0044E895: 176 1C                     v  00 00  1 155      
    xor rcx,rcx                           ;#0044E897: 48:061311                  uv 02 02  1 156      
    mov rdx,175                           ;#0044E89A: 48:307302 AF000000         vu 04 00  1 156      
    call #004428DB (:%opFrame) (badfmt)   ;#0044E8A1: 350 3540FFFF               v  00 00  1 157      
    mov qword[retaddr],#0044E8B3          ;#0044E8A6: 48:307105 20 B3E84400      uv 00 20  1 158      
    jmp #004519AB (code:badfmt)           ;#0044E8AE: 351 F8300000               v  00 00  1 158      
;   494                     precision = 0
    mov [rbp-168] (precision),rbx         ;#0044E8B3: 48:211235 58FFFFFF         uv 00 28  1 159      
;   495                     while 1 do
;   496                         fi = format[i]
    mov rdi,[rbp-16] (i)                  ;#0044E8BA: 48:213175 F0               vu 80 20  1 159      
    mov rsi,[rbp] (format)                ;#0044E8BE: 48:213165 00               uv 40 20  1 160      
    mov rdx,193                           ;#0044E8C2: 48:307302 C1000000         vu 04 00  1 160      
    call #00441762 (:%pSubse1is)          ;#0044E8C9: 350 942EFFFF               v  00 00  1 161      
    mov [rbp-24] (fi),rax                 ;#0044E8CE: 48:211105 E8               uv 00 21  1 162      
;   497                         if fi<'0' or fi>'9' then exit end if
    cmp rax,48                            ;#0044E8D2: 48:203370 30               vu 00 01  1 162      
    jl #0044E986                          ;#0044E8D6: 017214 AA000000            v  00 00  1 163      
    cmp rax,57                            ;#0044E8DC: 48:203370 39               uv 00 01  1 164      
    jg #0044E986                          ;#0044E8E0: 017217 A0000000            v  00 00  1 164      
;   498                         precision = precision*10+fi-'0'
    lea rdi,[rbp-200] (symtab[223])       ;#0044E8E6: 48:215275 38FFFFFF         uv 80 20  1 165      
    mov rcx,[rbp-168] (precision)         ;#0044E8ED: 48:213215 58FFFFFF         vu 02 20  1 165      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#0044E8F4: 48:213005 ED37FBFF         uv 01 00  1 166      
    call #0043F67C (:%opMul)              ;#0044E8FB: 350 7C0DFFFF               v  00 00  1 166      
    lea rdi,[rbp-184] (symtab[218])       ;#0044E900: 48:215275 48FFFFFF         uv 80 20  1 167      
    mov rcx,[rbp-200] (symtab[223])       ;#0044E907: 48:213215 38FFFFFF         vu 02 20  1 167      
    mov rax,[rbp-24] (fi)                 ;#0044E90E: 48:213105 E8               uv 01 20  1 168      
    call #0043F4AF (:%opAdd)              ;#0044E912: 350 980BFFFF               v  00 00  1 168      
    lea rdi,[rbp-168] (precision)         ;#0044E917: 48:215275 58FFFFFF         uv 80 20  1 169      
    mov rcx,[rbp-184] (symtab[218])       ;#0044E91E: 48:213215 48FFFFFF         vu 02 20  1 169      
    mov rax,[MB_ICONEXCLAMATION]          ;#0044E925: 48:213005 4C38FBFF         uv 01 00  1 170      
    call #0043F4EB (:%opSubi)             ;#0044E92C: 350 BA0BFFFF               v  00 00  1 170      
;   499                         i += 1
    mov rdi,[rbp-16] (i)                  ;#0044E931: 48:213175 F0               uv 80 20  1 171      
    add rdi,1                             ;#0044E935: 48:203307 01               uv 80 80  1 172 80   
    mov rdx,rdi                           ;#0044E939: 48:213327                  uv 04 80  1 173 80   
    mov [rbp-16] (i),rdi                  ;#0044E93C: 48:211175 F0               vu 00 A0  1 173      
    shl rdx,1                             ;#0044E940: 48:321342                  u  04 04  1 174      
    jno #0044E94E                         ;#0044E943: 161 09                     v  00 00  1 174      
    lea rdi,[rbp-16] (i)                  ;#0044E945: 48:215175 F0               uv 80 20  1 175      
    call #00442DA9 (:%pAddiii)            ;#0044E949: 350 5B44FFFF               v  00 00  1 175      
;   500                         if i>length(format) then badfmt() end if
    mov rsi,[rbp] (format)                ;#0044E94E: 48:213165 00               uv 40 20  1 176      
    mov rcx,[rbx+rsi*4-24]                ;#0044E952: 48:48:213114263 E8         uv 02 48  1 179 40 *40*
    mov rax,[rbp-16] (i)                  ;#0044E958: 48:213105 F0               vu 01 20  1 179      
    cmp rax,rcx                           ;#0044E95C: 48:071310                  uv 00 03  1 180      
    jle #0044E8BA                         ;#0044E95F: 017216 55FFFFFF            v  00 00  1 180      
    xor rcx,rcx                           ;#0044E965: 48:061311                  uv 02 02  1 181      
    mov rdx,175                           ;#0044E968: 48:307302 AF000000         vu 04 00  1 181      
    call #004428DB (:%opFrame) (badfmt)   ;#0044E96F: 350 673FFFFF               v  00 00  1 182      
    mov qword[retaddr],#0044E981          ;#0044E974: 48:307105 20 81E94400      uv 00 20  1 183      
    jmp #004519AB (code:badfmt)           ;#0044E97C: 351 2A300000               v  00 00  1 183      
;   501                     end while
    jmp #0044E8BA                         ;#0044E981: 351 34FFFFFF               v  00 00  1 184      
;   502                 end if
;   503 
;   504                 lowerHex = 0
    mov [rbp-120] (lowerHex),rbx          ;#0044E986: 48:211135 88               uv 00 28  1 185      
;   505                 -- 23/2/10 'b' added
;   506                 fidx = find(fi,"dxobscefgEXG")
    mov rcx,7                             ;#0044E98A: 48:307301 07000000         vu 02 00  1 185      
    mov rdx,75                            ;#0044E991: 48:307302 4B000000         uv 04 00  1 186      
    call #004428DB (:%opFrame) (find)     ;#0044E998: 350 3E3FFFFF               v  00 00  1 186      
    mov rdi,[rbp+40] (prevebp)            ;#0044E99D: 48:213175 28               uv 80 20  1 187      
    mov rax,[rdi-24]                      ;#0044E9A1: 48:213107 E8               uv 01 80  1 190 80 *80*
    mov [rbp] (x),rax                     ;#0044E9A5: 48:211105 00               uv 00 21  1 191 01   
    mov rdi,qword[#004022A8]              ;#0044E9A9: 48:213075 F838FBFF         vu 80 00  1 191      
    mov [rbp-8] (s),rdi                   ;#0044E9B0: 48:211175 F8               uv 00 A0  1 192      
    add qword[rbx+rdi*4-16],1             ;#0044E9B4: 48:203104273 F0 01         u  00 88  3 194    *80*
    mov qword[retaddr],#0044E9C7          ;#0044E9BA: 48:307105 20 C7E94400      vu 00 20  1 196      
    jmp #0043DAD6 (code:find)             ;#0044E9C2: 351 0FF1FEFF               v  00 00  1 197      
    mov [rbp-32] (fidx),rax               ;#0044E9C7: 48:211105 E0               uv 00 21  1 198      
;   507                 if fidx=11 then -- 'X'
    cmp rax,11                            ;#0044E9CB: 48:203370 0B               vu 00 01  1 198      
    jne #0044E9E1                         ;#0044E9CF: 165 10                     v  00 00  1 199      
;   508                     --
;   509                     -- Yup, I know it's a wee bit confusing, but for compatibility
;   510                     --  reasons, %x is upper case hex and %X is lower case hex!
;   511                     -- Assuming any objections from the backwards compatibility crowd 
;   512                     --  are drowned out by many more from the logical behaviour crowd,
;   513                     --  set lowerHex to 1/0 rather than the 0/1 it is now.
;   514                     --
;   515                     lowerHex = 1
    mov qword[rbp-120] (lowerHex),1       ;#0044E9D1: 48:307105 88 01000000      uv 00 20  1 200      
;   516                     fidx = 2
    mov qword[rbp-32] (fidx),2            ;#0044E9D9: 48:307105 E0 02000000      vu 00 20  1 200      
;   517                 end if
;   518 
;   519                 if fidx=0
    mov rsi,[rbp-32] (fidx)               ;#0044E9E1: 48:213165 E0               uv 40 20  1 201      
    cmp rsi,0                             ;#0044E9E5: 48:203376 00               uv 00 40  1 202 40   
    je #0044EA3A                          ;#0044E9E9: 164 4F                     v  00 00  1 202      
;   520                 or (showcommas and find(fi,"df")=0) then
    mov rcx,[rbp-152] (showcommas)        ;#0044E9EB: 48:213215 68FFFFFF         uv 02 20  1 203      
    test rcx,rcx                          ;#0044E9F2: 48:205311                  uv 00 02  1 204 02   
    je #0044EA56                          ;#0044E9F5: 164 5F                     v  00 00  1 204      
    mov rcx,7                             ;#0044E9F7: 48:307301 07000000         uv 02 00  1 205      
    mov rdx,75                            ;#0044E9FE: 48:307302 4B000000         vu 04 00  1 205      
    call #004428DB (:%opFrame) (find)     ;#0044EA05: 350 D13EFFFF               v  00 00  1 206      
    mov rdi,[rbp+40] (prevebp)            ;#0044EA0A: 48:213175 28               uv 80 20  1 207      
    mov rax,[rdi-24]                      ;#0044EA0E: 48:213107 E8               uv 01 80  1 210 80 *80*
    mov [rbp] (x),rax                     ;#0044EA12: 48:211105 00               uv 00 21  1 211 01   
    mov rdi,qword[#004022B0]              ;#0044EA16: 48:213075 9338FBFF         vu 80 00  1 211      
    mov [rbp-8] (s),rdi                   ;#0044EA1D: 48:211175 F8               uv 00 A0  1 212      
    add qword[rbx+rdi*4-16],1             ;#0044EA21: 48:203104273 F0 01         u  00 88  3 214    *80*
    mov qword[retaddr],#0044EA34          ;#0044EA27: 48:307105 20 34EA4400      vu 00 20  1 216      
    jmp #0043DAD6 (code:find)             ;#0044EA2F: 351 A2F0FEFF               v  00 00  1 217      
    cmp rax,0                             ;#0044EA34: 48:203370 00               uv 00 01  1 218      
    jne #0044EA56                         ;#0044EA38: 165 1C                     v  00 00  1 218      
;   521                     badfmt()
    xor rcx,rcx                           ;#0044EA3A: 48:061311                  uv 02 02  1 219      
    mov rdx,175                           ;#0044EA3D: 48:307302 AF000000         vu 04 00  1 219      
    call #004428DB (:%opFrame) (badfmt)   ;#0044EA44: 350 923EFFFF               v  00 00  1 220      
    mov qword[retaddr],#0044EA56          ;#0044EA49: 48:307105 20 56EA4400      uv 00 20  1 221      
    jmp #004519AB (code:badfmt)           ;#0044EA51: 351 552F0000               v  00 00  1 221      
;   522                 end if
;   523                 if not atom(args) and nxt>length(args) then
    mov rsi,[rbp-8] (args)                ;#0044EA56: 48:213165 F8               uv 40 20  1 222      
    mov r15,h4                            ;#0044EA5A: 49:277 0000000000000040    vu 8000 00  1 222      
    cmp rsi,r15                           ;#0044EA64: 4C:071376                  uv 00 8040  1 223      
    jl #0044EA86                          ;#0044EA67: 174 1D                     v  00 00  1 223      
    cmp byte[rbx+rsi*4-1],#12             ;#0044EA69: 200174263 FF 12            u  00 48  2 224      
    je #0044EA86                          ;#0044EA6E: 164 16                     v  00 00  1 225      
    mov rcx,[rbx+rsi*4-24]                ;#0044EA70: 48:48:213114263 E8         uv 02 48  1 226      
    mov rax,[rbp-40] (nxt)                ;#0044EA76: 48:213105 D8               vu 01 20  1 226      
    cmp rax,rcx                           ;#0044EA7A: 48:071310                  uv 00 03  1 227      
    jle #0044EA86                         ;#0044EA7D: 176 07                     v  00 00  1 227      
;   524 --/**/              #ilASM{
;   525 --!/**/                 [32]
;   526 --/**/                      mov al,70                           -- Phix
    mov al,70                             ;#0044EA7F: 260 46                     uv 01 00  1 228      
;   527 --!/**/                     xor edi,edi         -- ep1 unused   -- Phix
;   528 --!/**/                     xor esi,esi         -- ep2 unused   -- Phix
;   529 --!/**/                 [64]
;   530 --/**/                      call :%pRTErn }     -- fatal error  -- Phix
    call #00442DC8 (:%pRTErn)             ;#0044EA81: 350 4243FFFF               v  00 00  1 228      
;   531 --/**/                                                  --/*    -- Phix
;   532                     puts(1,"insufficient values for sprintf\n") -- RDS
;   533                     if getc(0) then end if                      -- RDS
;   534                     abort(1)                                    -- RDS --*/
;   535                 end if
;   536                 if fidx<=4 then -- dxob
    mov rdi,[rbp-32] (fidx)               ;#0044EA86: 48:213175 E0               uv 80 20  1 229      
    cmp rdi,4                             ;#0044EA8A: 48:203377 04               uv 00 80  1 230 80   
    jg #0044F37B                          ;#0044EA8E: 017217 E7080000            v  00 00  1 230      
;   537                     base = bases[fidx]  --{10,16,8,2}
    mov rsi,[#00402278] (bases)           ;#0044EA94: 48:213065 DD37FBFF         uv 40 00  1 231      
    mov r15,h4                            ;#0044EA9B: 49:277 0000000000000040    vu 8000 00  1 231      
    cmp rsi,r15                           ;#0044EAA5: 4C:071376                  uv 00 8040  1 232      
    jne #0044EAB6                         ;#0044EAA8: 165 0C                     v  00 00  1 232      
    mov rsi,192                           ;#0044EAAA: 48:307306 C0000000         uv 40 00  1 233      
    call #00442D75 (:%pUnassigned)        ;#0044EAB1: 350 BF42FFFF               v  00 00  1 233      
    mov rdx,192                           ;#0044EAB6: 48:307302 C0000000         uv 04 00  1 234      
    call #00441744 (:%pSubse1ip)          ;#0044EABD: 350 822CFFFF               v  00 00  1 234      
    mov [rbp-88] (base),rax               ;#0044EAC2: 48:211105 A8               uv 00 21  1 235      
;   538                     o = args
    mov rcx,[rbp-8] (args)                ;#0044EAC6: 48:213115 F8               vu 02 20  1 235      
    mov rdx,[rbp-64] (o)                  ;#0044EACA: 48:213125 C0               uv 04 20  1 236      
    mov r15,h4                            ;#0044EACE: 49:277 0000000000000040    vu 8000 00  1 236      
    cmp rcx,r15                           ;#0044EAD8: 4C:071371                  uv 00 8002  1 237      
    jl #0044EAE3                          ;#0044EADB: 174 06                     v  00 00  1 237      
    add qword[rbx+rcx*4-16],1             ;#0044EADD: 48:203104213 F0 01         u  00 0A  3 238      
    mov [rbp-64] (o),rcx                  ;#0044EAE3: 48:211115 C0               vu 00 22  1 240      
    mov r15,h4                            ;#0044EAE7: 49:277 0000000000000040    uv 8000 00  1 241      
    cmp rdx,r15                           ;#0044EAF1: 4C:071372                  uv 00 8004  1 242 8000   
    jle #0044EB03                         ;#0044EAF4: 176 0D                     v  00 00  1 242      
    sub qword[rbx+rdx*4-16],1             ;#0044EAF6: 48:203154223 F0 01         u  00 0C  3 243      
    jne #0044EB03                         ;#0044EAFC: 165 05                     v  00 00  1 245      
    call #004422DA (:%pDealloc)           ;#0044EAFE: 350 D737FFFF               v  00 00  1 246      
;   539                     work = 0
    mov rdx,[rbp-80] (work)               ;#0044EB03: 48:213125 B0               uv 04 20  1 247      
    mov r15,h4                            ;#0044EB07: 49:277 0000000000000040    vu 8000 00  1 247      
    cmp rdx,r15                           ;#0044EB11: 4C:071372                  uv 00 8004  1 248      
    mov [rbp-80] (work),rbx               ;#0044EB14: 48:211135 B0               vu 00 28  1 248      
    jle #0044EB27                         ;#0044EB18: 176 0D                     v  00 00  1 249      
    sub qword[rbx+rdx*4-16],1             ;#0044EB1A: 48:203154223 F0 01         u  00 0C  3 250      
    jne #0044EB27                         ;#0044EB20: 165 05                     v  00 00  1 252      
    call #004422DA (:%pDealloc)           ;#0044EB22: 350 B337FFFF               v  00 00  1 253      
;   540                     if atom(o) then
    mov rdi,[rbp-64] (o)                  ;#0044EB27: 48:213175 C0               uv 80 20  1 254      
    mov r15,h4                            ;#0044EB2B: 49:277 0000000000000040    vu 8000 00  1 254      
    cmp rdi,r15                           ;#0044EB35: 4C:071377                  uv 00 8080  1 255      
    jl #0044EB45                          ;#0044EB38: 174 0B                     v  00 00  1 255      
    cmp byte[rbx+rdi*4-1],#12             ;#0044EB3A: 200174273 FF 12            u  00 88  2 256      
    jne #0044EBD6                         ;#0044EB3F: 017205 91000000            v  00 00  1 257      
;   541                         if o!=nan and o!=-nan and o!=inf then
    mov rdi,[#004021F8] (nan)             ;#0044EB45: 48:213075 AC36FBFF         uv 80 00  1 258      
    mov rax,[rbp-64] (o)                  ;#0044EB4C: 48:213105 C0               vu 01 20  1 258      
    mov rsi,123                           ;#0044EB50: 48:307306 7B000000         uv 40 00  1 259      
    mov rdx,201                           ;#0044EB57: 48:307302 C9000000         vu 04 00  1 259      
    call #0043FAF6 (:%opJccE)             ;#0044EB5E: 350 930FFFFF               v  00 00  1 260      
    je #0044ECB5                          ;#0044EB63: 017204 4C010000            v  00 00  1 261      
    lea rdi,[rbp-184] (symtab[218])       ;#0044EB69: 48:215275 48FFFFFF         uv 80 20  1 262      
    mov rcx,[#004021F8] (nan)             ;#0044EB70: 48:213015 8136FBFF         vu 02 00  1 262      
    call #0043F746 (:%opUminus)           ;#0044EB77: 350 CA0BFFFF               v  00 00  1 263      
    mov rdi,[rbp-184] (symtab[218])       ;#0044EB7C: 48:213275 48FFFFFF         uv 80 20  1 264      
    mov rax,[rbp-64] (o)                  ;#0044EB83: 48:213105 C0               vu 01 20  1 264      
    mov rsi,218                           ;#0044EB87: 48:307306 DA000000         uv 40 00  1 265      
    mov rdx,201                           ;#0044EB8E: 48:307302 C9000000         vu 04 00  1 265      
    call #0043FAF6 (:%opJccE)             ;#0044EB95: 350 5C0FFFFF               v  00 00  1 266      
    je #0044ECB5                          ;#0044EB9A: 017204 15010000            v  00 00  1 267      
    mov rdi,[#004021F0] (inf)             ;#0044EBA0: 48:213075 4936FBFF         uv 80 00  1 268      
    mov rax,[rbp-64] (o)                  ;#0044EBA7: 48:213105 C0               vu 01 20  1 268      
    mov rsi,122                           ;#0044EBAB: 48:307306 7A000000         uv 40 00  1 269      
    mov rdx,201                           ;#0044EBB2: 48:307302 C9000000         vu 04 00  1 269      
    call #0043FAF6 (:%opJccE)             ;#0044EBB9: 350 380FFFFF               v  00 00  1 270      
    je #0044ECB5                          ;#0044EBBE: 017204 F1000000            v  00 00  1 271      
;   542                             work = floor(o)
    lea rdi,[rbp-80] (work)               ;#0044EBC4: 48:215175 B0               uv 80 20  1 272      
    mov rax,[rbp-64] (o)                  ;#0044EBC8: 48:213105 C0               vu 01 20  1 272      
    call #0043F81C (:%opFloor)            ;#0044EBCC: 350 4B0CFFFF               v  00 00  1 273      
;   543                         end if
    jmp #0044ECB5                         ;#0044EBD1: 351 DF000000               v  00 00  1 274      
;   544                     else
;   545                         o = args[nxt]
    mov rdi,[rbp-40] (nxt)                ;#0044EBD6: 48:213175 D8               uv 80 20  1 275      
    lea rcx,[rbp-64] (o)                  ;#0044EBDA: 48:215115 C0               vu 02 20  1 275      
    mov rsi,[rbp-8] (args)                ;#0044EBDE: 48:213165 F8               uv 40 20  1 276      
    mov rdx,194                           ;#0044EBE2: 48:307302 C2000000         vu 04 00  1 276      
    call #00441675 (:%pSubse1)            ;#0044EBE9: 350 872AFFFF               v  00 00  1 277      
;   546                         if atom(o) then
    mov rcx,[rbp-64] (o)                  ;#0044EBEE: 48:213115 C0               uv 02 20  1 278      
    mov r15,h4                            ;#0044EBF2: 49:277 0000000000000040    vu 8000 00  1 278      
    cmp rcx,r15                           ;#0044EBFC: 4C:071371                  uv 00 8002  1 279      
    jl #0044EC0C                          ;#0044EBFF: 174 0B                     v  00 00  1 279      
    cmp byte[rbx+rcx*4-1],#12             ;#0044EC01: 200174213 FF 12            u  00 0A  2 280      
    jne #0044EC91                         ;#0044EC06: 017205 85000000            v  00 00  1 281      
;   547                             if o!=nan and o!=-nan and o!=inf then
    mov rdi,[#004021F8] (nan)             ;#0044EC0C: 48:213075 E535FBFF         uv 80 00  1 282      
    mov rax,rcx                           ;#0044EC13: 48:211310                  vu 01 02  1 282      
    mov rsi,123                           ;#0044EC16: 48:307306 7B000000         uv 40 00  1 283      
    mov rdx,201                           ;#0044EC1D: 48:307302 C9000000         vu 04 00  1 283      
    call #0043FAF6 (:%opJccE)             ;#0044EC24: 350 CD0EFFFF               v  00 00  1 284      
    je #0044ECB5                          ;#0044EC29: 017204 86000000            v  00 00  1 285      
    lea rdi,[rbp-184] (symtab[218])       ;#0044EC2F: 48:215275 48FFFFFF         uv 80 20  1 286      
    mov rcx,[#004021F8] (nan)             ;#0044EC36: 48:213015 BB35FBFF         vu 02 00  1 286      
    call #0043F746 (:%opUminus)           ;#0044EC3D: 350 040BFFFF               v  00 00  1 287      
    mov rdi,[rbp-184] (symtab[218])       ;#0044EC42: 48:213275 48FFFFFF         uv 80 20  1 288      
    mov rax,[rbp-64] (o)                  ;#0044EC49: 48:213105 C0               vu 01 20  1 288      
    mov rsi,218                           ;#0044EC4D: 48:307306 DA000000         uv 40 00  1 289      
    mov rdx,201                           ;#0044EC54: 48:307302 C9000000         vu 04 00  1 289      
    call #0043FAF6 (:%opJccE)             ;#0044EC5B: 350 960EFFFF               v  00 00  1 290      
    je #0044ECB5                          ;#0044EC60: 164 53                     v  00 00  1 291      
    mov rdi,[#004021F0] (inf)             ;#0044EC62: 48:213075 8735FBFF         uv 80 00  1 292      
    mov rax,[rbp-64] (o)                  ;#0044EC69: 48:213105 C0               vu 01 20  1 292      
    mov rsi,122                           ;#0044EC6D: 48:307306 7A000000         uv 40 00  1 293      
    mov rdx,201                           ;#0044EC74: 48:307302 C9000000         vu 04 00  1 293      
    call #0043FAF6 (:%opJccE)             ;#0044EC7B: 350 760EFFFF               v  00 00  1 294      
    je #0044ECB5                          ;#0044EC80: 164 33                     v  00 00  1 295      
;   548                                 work = floor(o)
    lea rdi,[rbp-80] (work)               ;#0044EC82: 48:215175 B0               uv 80 20  1 296      
    mov rax,[rbp-64] (o)                  ;#0044EC86: 48:213105 C0               vu 01 20  1 296      
    call #0043F81C (:%opFloor)            ;#0044EC8A: 350 8D0BFFFF               v  00 00  1 297      
;   549                             end if
    jmp #0044ECB5                         ;#0044EC8F: 353 24                     v  00 00  1 298      
;   550                         else
;   551                             o = 0
    mov rdx,[rbp-64] (o)                  ;#0044EC91: 48:213125 C0               uv 04 20  1 299      
    mov r15,h4                            ;#0044EC95: 49:277 0000000000000040    vu 8000 00  1 299      
    cmp rdx,r15                           ;#0044EC9F: 4C:071372                  uv 00 8004  1 300      
    mov [rbp-64] (o),rbx                  ;#0044ECA2: 48:211135 C0               vu 00 28  1 300      
    jle #0044ECB5                         ;#0044ECA6: 176 0D                     v  00 00  1 301      
    sub qword[rbx+rdx*4-16],1             ;#0044ECA8: 48:203154223 F0 01         u  00 0C  3 302      
    jne #0044ECB5                         ;#0044ECAE: 165 05                     v  00 00  1 304      
    call #004422DA (:%pDealloc)           ;#0044ECB0: 350 2536FFFF               v  00 00  1 305      
;   552                         end if
;   553                     end if
;   554                     if work then
    mov rsi,[rbp-80] (work)               ;#0044ECB5: 48:213165 B0               uv 40 20  1 306      
    test rsi,rsi                          ;#0044ECB9: 48:205366                  uv 00 40  1 307 40   
    je #0044F14B                          ;#0044ECBC: 017204 89040000            v  00 00  1 307      
;   555                         sign = 0
    mov [rbp-96] (sign),rbx               ;#0044ECC2: 48:211135 A0               uv 00 28  1 308      
;   556                         if work<0 then
    xor rdi,rdi                           ;#0044ECC6: 48:061377                  vu 80 80  1 308      
    mov rax,rsi                           ;#0044ECC9: 48:211360                  uv 01 40  1 309      
    mov rsi,25                            ;#0044ECCC: 48:307306 19000000         vu 40 00  1 309      
    mov rdx,203                           ;#0044ECD3: 48:307302 CB000000         uv 04 00  1 310      
    call #0043FA81 (:%opJcc)              ;#0044ECDA: 350 A20DFFFF               v  00 00  1 310      
    jge #0044ED37                         ;#0044ECDF: 175 56                     v  00 00  1 311      
;   557                             sign = 1
    mov qword[rbp-96] (sign),1            ;#0044ECE1: 48:307105 A0 01000000      uv 00 20  1 312      
;   558                             if base=10 then
    mov rcx,[rbp-88] (base)               ;#0044ECE9: 48:213115 A8               vu 02 20  1 312      
    cmp rcx,10                            ;#0044ECED: 48:203371 0A               uv 00 02  1 313      
    jne #0044ED09                         ;#0044ECF1: 165 16                     v  00 00  1 313      
;   559                                 work = 0-work
    lea rdi,[rbp-80] (work)               ;#0044ECF3: 48:215175 B0               uv 80 20  1 314      
    mov rcx,qword[#00402028]              ;#0044ECF7: 48:213015 2A33FBFF         vu 02 00  1 314      
    mov rax,[rbp-80] (work)               ;#0044ECFE: 48:213105 B0               uv 01 20  1 315      
    call #0043F4D8 (:%opSub)              ;#0044ED02: 350 D107FFFF               v  00 00  1 315      
    jmp #0044ED37                         ;#0044ED07: 353 2E                     v  00 00  1 316      
;   560                             else
;   561 --DEV 
;   562 --if machine_bits()=64 then
;   563 --                              work = and_bits(work,#7FFFFFFFFFFFFFFF)+#8000000000000000
;   564 --else
;   565                                 work = and_bits(work,#7FFFFFFF)+#80000000
    lea rdi,[rbp-184] (symtab[218])       ;#0044ED09: 48:215275 48FFFFFF         uv 80 20  1 317      
    mov rcx,[rbp-80] (work)               ;#0044ED10: 48:213115 B0               vu 02 20  1 317      
    mov rax,qword[#004022B8]              ;#0044ED14: 48:213005 9D35FBFF         uv 01 00  1 318      
    call #0043F6C1 (:%opAndBits)          ;#0044ED1B: 350 A109FFFF               v  00 00  1 318      
    lea rdi,[rbp-80] (work)               ;#0044ED20: 48:215175 B0               uv 80 20  1 319      
    mov rcx,[rbp-184] (symtab[218])       ;#0044ED24: 48:213215 48FFFFFF         vu 02 20  1 319      
    mov rax,qword[#004022C0]              ;#0044ED2B: 48:213005 8E35FBFF         uv 01 00  1 320      
    call #0043F4AF (:%opAdd)              ;#0044ED32: 350 7807FFFF               v  00 00  1 320      
;   566 --end if
;   567                             end if
;   568                         end if
;   569 --                      r1 = ""
;   570                         r1 = repeat(' ',0)
    lea rdi,[rbp-56] (r1)                 ;#0044ED37: 48:215175 C8               uv 80 20  1 321      
    mov rax,32                            ;#0044ED3B: 48:307300 20000000         vu 01 00  1 321      
    mov rcx,0                             ;#0044ED42: 48:307301 00000000         uv 02 00  1 322      
    call #0043B1E1 (:%opRepCh)            ;#0044ED49: 350 93C4FEFF               v  00 00  1 322      
;   571                         while work do
    mov rdi,[rbp-80] (work)               ;#0044ED4E: 48:213175 B0               uv 80 20  1 323      
    test rdi,rdi                          ;#0044ED52: 48:205377                  uv 00 80  1 324 80   
    je #0044EEE6                          ;#0044ED55: 017204 8B010000            v  00 00  1 324      
;   572                             -- NB: The result of prepend is always a sequence, 
;   573                             --      for performance reasons. Hence use append 
;   574                             --      to build it backwards, then reverse it.
;   575                             hc = floor(remainder(work,base)+1)
    lea rdi,[rbp-184] (symtab[218])       ;#0044ED5B: 48:215275 48FFFFFF         uv 80 20  1 325      
    mov rax,[rbp-80] (work)               ;#0044ED62: 48:213105 B0               vu 01 20  1 325      
    mov rcx,[rbp-88] (base)               ;#0044ED66: 48:213115 A8               uv 02 20  1 326      
    call #0043F1F5 (:%opRmdr)             ;#0044ED6A: 350 8604FFFF               v  00 00  1 326      
    lea rdi,[rbp-200] (symtab[223])       ;#0044ED6F: 48:215275 38FFFFFF         uv 80 20  1 327      
    mov rcx,[rbp-184] (symtab[218])       ;#0044ED76: 48:213215 48FFFFFF         vu 02 20  1 327      
    mov rax,qword[#00402030]              ;#0044ED7D: 48:213005 AC32FBFF         uv 01 00  1 328      
    call #0043F4AF (:%opAdd)              ;#0044ED84: 350 2607FFFF               v  00 00  1 328      
    lea rdi,[rbp-112] (hc)                ;#0044ED89: 48:215175 90               uv 80 20  1 329      
    mov rax,[rbp-200] (symtab[223])       ;#0044ED8D: 48:213205 38FFFFFF         vu 01 20  1 329      
    call #0043F81C (:%opFloor)            ;#0044ED94: 350 830AFFFF               v  00 00  1 330      
    mov r15,h4                            ;#0044ED99: 49:277 0000000000000040    uv 8000 00  1 331      
    cmp rax,r15                           ;#0044EDA3: 4C:071370                  uv 00 8001  1 332 8000   
    jl #0044EDB4                          ;#0044EDA6: 174 0C                     v  00 00  1 332      
    mov rcx,207                           ;#0044EDA8: 48:307301 CF000000         uv 02 00  1 333      
    call #00442A58 (:%opTchkFail)         ;#0044EDAF: 350 A43CFFFF               v  00 00  1 333      
;   576 --20/3/2013:
;   577 --                          if hc=0 then exit end if
;   578                             if lowerHex and hc>10 then
    mov rsi,[rbp-120] (lowerHex)          ;#0044EDB4: 48:213165 88               uv 40 20  1 334      
    test rsi,rsi                          ;#0044EDB8: 48:205366                  uv 00 40  1 335 40   
    je #0044EDDC                          ;#0044EDBB: 164 1F                     v  00 00  1 335      
    cmp rax,10                            ;#0044EDBD: 48:203370 0A               uv 00 01  1 336      
    jle #0044EDDC                         ;#0044EDC1: 176 19                     v  00 00  1 336      
;   579                                 hc += 6
    add rax,6                             ;#0044EDC3: 48:203300 06               uv 01 01  1 337      
    mov rdx,rax                           ;#0044EDC7: 48:213320                  uv 04 01  1 338 01   
    mov [rbp-112] (hc),rax                ;#0044EDCA: 48:211105 90               vu 00 21  1 338      
    shl rdx,1                             ;#0044EDCE: 48:321342                  u  04 04  1 339      
    jno #0044EDDC                         ;#0044EDD1: 161 09                     v  00 00  1 339      
    lea rdi,[rbp-112] (hc)                ;#0044EDD3: 48:215175 90               uv 80 20  1 340      
    call #00442DA9 (:%pAddiii)            ;#0044EDD7: 350 CD3FFFFF               v  00 00  1 340      
;   580                             end if
;   581                             if showcommas and showcommas=length(r1) then
    mov rdi,[rbp-152] (showcommas)        ;#0044EDDC: 48:213275 68FFFFFF         uv 80 20  1 341      
    test rdi,rdi                          ;#0044EDE3: 48:205377                  uv 00 80  1 342 80   
    je #0044EE5A                          ;#0044EDE6: 164 72                     v  00 00  1 342      
    mov rcx,[rbp-56] (r1)                 ;#0044EDE8: 48:213115 C8               uv 02 20  1 343      
    mov rsi,[rbx+rcx*4-24]                ;#0044EDEC: 48:48:213164213 E8         uv 40 0A  1 346 02 *02*
    cmp rdi,rsi                           ;#0044EDF2: 48:071367                  uv 00 C0  1 347 40   
    jne #0044EE5A                         ;#0044EDF5: 165 63                     v  00 00  1 347      
;   582                                 r1 = append(r1,',')
    lea rdx,[rbp-56] (r1)                 ;#0044EDF7: 48:215125 C8               uv 04 20  1 348      
    lea rdi,[rbp-56] (r1)                 ;#0044EDFB: 48:215175 C8               vu 80 20  1 348      
    lea rcx,qword[#004022A0]              ;#0044EDFF: 48:215015 9A34FBFF         uv 02 00  1 349      
    xor rax,rax                           ;#0044EE06: 48:061300                  vu 01 01  1 349      
    call #0043FC15 (:%opApnd)             ;#0044EE09: 350 070EFFFF               v  00 00  1 350      
    mov rax,[rbp-56] (r1)                 ;#0044EE0E: 48:213105 C8               uv 01 20  1 351      
    mov r15,h4                            ;#0044EE12: 49:277 0000000000000040    vu 8000 00  1 351      
    cmp rax,r15                           ;#0044EE1C: 4C:071370                  uv 00 8001  1 352      
    jl #0044EE28                          ;#0044EE1F: 174 07                     v  00 00  1 352      
    cmp byte[rbx+rax*4-1],#82             ;#0044EE21: 200174203 FF 82            u  00 09  2 353      
    je #0044EE34                          ;#0044EE26: 164 0C                     v  00 00  1 354      
    mov rcx,200                           ;#0044EE28: 48:307301 C8000000         uv 02 00  1 355      
    call #00442A58 (:%opTchkFail)         ;#0044EE2F: 350 243CFFFF               v  00 00  1 355      
;   583                                 showcommas += 4
    mov rcx,[rbp-152] (showcommas)        ;#0044EE34: 48:213215 68FFFFFF         uv 02 20  1 356      
    add rcx,4                             ;#0044EE3B: 48:203301 04               uv 02 02  1 357 02   
    mov rdx,rcx                           ;#0044EE3F: 48:213321                  uv 04 02  1 358 02   
    mov [rbp-152] (showcommas),rcx        ;#0044EE42: 48:211215 68FFFFFF         vu 00 22  1 358      
    shl rdx,1                             ;#0044EE49: 48:321342                  u  04 04  1 359      
    jno #0044EE5A                         ;#0044EE4C: 161 0C                     v  00 00  1 359      
    lea rdi,[rbp-152] (showcommas)        ;#0044EE4E: 48:215275 68FFFFFF         uv 80 20  1 360      
    call #00442DA9 (:%pAddiii)            ;#0044EE55: 350 4F3FFFFF               v  00 00  1 360      
;   584                             end if
;   585                             r1 = append(r1,hexchar[hc])
    mov rsi,[#00402270] (hexchar)         ;#0044EE5A: 48:213065 0F34FBFF         uv 40 00  1 361      
    mov r15,h4                            ;#0044EE61: 49:277 0000000000000040    vu 8000 00  1 361      
    cmp rsi,r15                           ;#0044EE6B: 4C:071376                  uv 00 8040  1 362      
    jne #0044EE7C                         ;#0044EE6E: 165 0C                     v  00 00  1 362      
    mov rsi,191                           ;#0044EE70: 48:307306 BF000000         uv 40 00  1 363      
    call #00442D75 (:%pUnassigned)        ;#0044EE77: 350 F93EFFFF               v  00 00  1 363      
    mov rdi,[rbp-112] (hc)                ;#0044EE7C: 48:213175 90               uv 80 20  1 364      
    mov rdx,191                           ;#0044EE80: 48:307302 BF000000         vu 04 00  1 364      
    call #00441762 (:%pSubse1is)          ;#0044EE87: 350 D628FFFF               v  00 00  1 365      
    mov [rbp-192] (symtab[221]),rax       ;#0044EE8C: 48:211205 40FFFFFF         uv 00 21  1 366      
    lea rdx,[rbp-56] (r1)                 ;#0044EE93: 48:215125 C8               vu 04 20  1 366      
    lea rdi,[rbp-56] (r1)                 ;#0044EE97: 48:215175 C8               uv 80 20  1 367      
    lea rcx,[rbp-192] (symtab[221])       ;#0044EE9B: 48:215215 40FFFFFF         vu 02 20  1 367      
    xor rax,rax                           ;#0044EEA2: 48:061300                  uv 01 01  1 368      
    call #0043FC15 (:%opApnd)             ;#0044EEA5: 350 6B0DFFFF               v  00 00  1 368      
    mov rcx,[rbp-56] (r1)                 ;#0044EEAA: 48:213115 C8               uv 02 20  1 369      
    mov r15,h4                            ;#0044EEAE: 49:277 0000000000000040    vu 8000 00  1 369      
    cmp rcx,r15                           ;#0044EEB8: 4C:071371                  uv 00 8002  1 370      
    jl #0044EEC4                          ;#0044EEBB: 174 07                     v  00 00  1 370      
    cmp byte[rbx+rcx*4-1],#82             ;#0044EEBD: 200174213 FF 82            u  00 0A  2 371      
    je #0044EED0                          ;#0044EEC2: 164 0C                     v  00 00  1 372      
    mov rcx,200                           ;#0044EEC4: 48:307301 C8000000         uv 02 00  1 373      
    call #00442A58 (:%opTchkFail)         ;#0044EECB: 350 883BFFFF               v  00 00  1 373      
;   586                             -- this is ok, ^ , hexchar[] is equally valid for 
;   587                             --  base 16/10/8/2 (just less chars get used).
;   588                             work = floor(work/base)
    lea rdi,[rbp-80] (work)               ;#0044EED0: 48:215175 B0               uv 80 20  1 374      
    mov rcx,[rbp-80] (work)               ;#0044EED4: 48:213115 B0               vu 02 20  1 374      
    mov rax,[rbp-88] (base)               ;#0044EED8: 48:213105 A8               uv 01 20  1 375      
    call #0043F5E4 (:%opDivf)             ;#0044EEDC: 350 0307FFFF               v  00 00  1 375      
;   589                         end while
    jmp #0044ED4E                         ;#0044EEE1: 351 68FEFFFF               v  00 00  1 376      
;   590                         if sign then
    mov rdi,[rbp-96] (sign)               ;#0044EEE6: 48:213175 A0               uv 80 20  1 377      
    test rdi,rdi                          ;#0044EEEA: 48:205377                  uv 00 80  1 378 80   
    je #0044F018                          ;#0044EEED: 017204 25010000            v  00 00  1 378      
;   591 if base=10 then
    mov rsi,[rbp-88] (base)               ;#0044EEF3: 48:213165 A8               uv 40 20  1 379      
    cmp rsi,10                            ;#0044EEF7: 48:203376 0A               uv 00 40  1 380 40   
    jne #0044EF43                         ;#0044EEFB: 165 46                     v  00 00  1 380      
;   592                             r1 = append(r1,'-')
    lea rdx,[rbp-56] (r1)                 ;#0044EEFD: 48:215125 C8               uv 04 20  1 381      
    lea rdi,[rbp-56] (r1)                 ;#0044EF01: 48:215175 C8               vu 80 20  1 381      
    lea rcx,qword[#00402218]              ;#0044EF05: 48:215015 0C33FBFF         uv 02 00  1 382      
    xor rax,rax                           ;#0044EF0C: 48:061300                  vu 01 01  1 382      
    call #0043FC15 (:%opApnd)             ;#0044EF0F: 350 010DFFFF               v  00 00  1 383      
    mov rcx,[rbp-56] (r1)                 ;#0044EF14: 48:213115 C8               uv 02 20  1 384      
    mov r15,h4                            ;#0044EF18: 49:277 0000000000000040    vu 8000 00  1 384      
    cmp rcx,r15                           ;#0044EF22: 4C:071371                  uv 00 8002  1 385      
    jl #0044EF32                          ;#0044EF25: 174 0B                     v  00 00  1 385      
    cmp byte[rbx+rcx*4-1],#82             ;#0044EF27: 200174213 FF 82            u  00 0A  2 386      
    je #0044F018                          ;#0044EF2C: 017204 E6000000            v  00 00  1 387      
    mov rcx,200                           ;#0044EF32: 48:307301 C8000000         uv 02 00  1 388      
    call #00442A58 (:%opTchkFail)         ;#0044EF39: 350 1A3BFFFF               v  00 00  1 388      
    jmp #0044F018                         ;#0044EF3E: 351 D5000000               v  00 00  1 389      
;   593 elsif minfieldwidth>length(r1) then
    mov rax,[rbp-56] (r1)                 ;#0044EF43: 48:213105 C8               uv 01 20  1 390      
    mov rdi,[rbx+rax*4-24]                ;#0044EF47: 48:48:213174203 E8         uv 80 09  1 393 01 *01*
    mov rsi,[rbp-160] (minfieldwidth)     ;#0044EF4D: 48:213265 60FFFFFF         vu 40 20  1 393      
    cmp rsi,rdi                           ;#0044EF54: 48:071376                  uv 00 C0  1 394      
    jle #0044F018                         ;#0044EF57: 017216 BB000000            v  00 00  1 394      
;   594                             r1 &= repeat(hexchar[base],minfieldwidth-length(r1))
    mov rcx,[#00402270] (hexchar)         ;#0044EF5D: 48:213015 0C33FBFF         uv 02 00  1 395      
    mov r15,h4                            ;#0044EF64: 49:277 0000000000000040    vu 8000 00  1 395      
    cmp rcx,r15                           ;#0044EF6E: 4C:071371                  uv 00 8002  1 396      
    jne #0044EF7F                         ;#0044EF71: 165 0C                     v  00 00  1 396      
    mov rsi,191                           ;#0044EF73: 48:307306 BF000000         uv 40 00  1 397      
    call #00442D75 (:%pUnassigned)        ;#0044EF7A: 350 F63DFFFF               v  00 00  1 397      
    mov rdi,[rbp-88] (base)               ;#0044EF7F: 48:213175 A8               uv 80 20  1 398      
    mov rsi,rcx                           ;#0044EF83: 48:211316                  vu 40 02  1 398      
    mov rdx,191                           ;#0044EF86: 48:307302 BF000000         uv 04 00  1 399      
    call #00441762 (:%pSubse1is)          ;#0044EF8D: 350 D027FFFF               v  00 00  1 399      
    mov [rbp-192] (symtab[221]),rax       ;#0044EF92: 48:211205 40FFFFFF         uv 00 21  1 400      
    mov rsi,[rbp-56] (r1)                 ;#0044EF99: 48:213165 C8               vu 40 20  1 400      
    mov rdi,[rbx+rsi*4-24]                ;#0044EF9D: 48:48:213174263 E8         uv 80 48  1 403    *40*
    mov [rbp-208] (symtab[228]),rdi       ;#0044EFA3: 48:211275 30FFFFFF         uv 00 A0  1 404 80   
    lea rdi,[rbp-200] (symtab[223])       ;#0044EFAA: 48:215275 38FFFFFF         vu 80 20  1 404      
    mov rcx,[rbp-160] (minfieldwidth)     ;#0044EFB1: 48:213215 60FFFFFF         uv 02 20  1 405      
    mov rax,[rbp-208] (symtab[228])       ;#0044EFB8: 48:213205 30FFFFFF         vu 01 20  1 405      
    call #0043F4D8 (:%opSub)              ;#0044EFBF: 350 1405FFFF               v  00 00  1 406      
    lea rdi,[rbp-216] (symtab[229])       ;#0044EFC4: 48:215275 28FFFFFF         uv 80 20  1 407      
    mov rax,[rbp-192] (symtab[221])       ;#0044EFCB: 48:213205 40FFFFFF         vu 01 20  1 407      
    mov rcx,[rbp-200] (symtab[223])       ;#0044EFD2: 48:213215 38FFFFFF         uv 02 20  1 408      
    call #0043B1F3 (:%opRepeat)           ;#0044EFD9: 350 15C2FEFF               v  00 00  1 408      
    lea rdx,[rbp-56] (r1)                 ;#0044EFDE: 48:215125 C8               uv 04 20  1 409      
    lea rdi,[rbp-56] (r1)                 ;#0044EFE2: 48:215175 C8               vu 80 20  1 409      
    lea rcx,[rbp-216] (symtab[229])       ;#0044EFE6: 48:215215 28FFFFFF         uv 02 20  1 410      
    call #00440021 (:%opConcat)           ;#0044EFED: 350 2F10FFFF               v  00 00  1 410      
    mov rsi,[rbp-56] (r1)                 ;#0044EFF2: 48:213165 C8               uv 40 20  1 411      
    mov r15,h4                            ;#0044EFF6: 49:277 0000000000000040    vu 8000 00  1 411      
    cmp rsi,r15                           ;#0044F000: 4C:071376                  uv 00 8040  1 412      
    jl #0044F00C                          ;#0044F003: 174 07                     v  00 00  1 412      
    cmp byte[rbx+rsi*4-1],#82             ;#0044F005: 200174263 FF 82            u  00 48  2 413      
    je #0044F018                          ;#0044F00A: 164 0C                     v  00 00  1 414      
    mov rcx,200                           ;#0044F00C: 48:307301 C8000000         uv 02 00  1 415      
    call #00442A58 (:%opTchkFail)         ;#0044F013: 350 403AFFFF               v  00 00  1 415      
;   595 end if
;   596                         end if
;   597                         r1len = length(r1)
    mov rdi,[rbp-56] (r1)                 ;#0044F018: 48:213175 C8               uv 80 20  1 416      
    mov rax,[rbx+rdi*4-24]                ;#0044F01C: 48:48:213104273 E8         uv 01 88  1 419 80 *80*
    mov [rbp-104] (r1len),rax             ;#0044F022: 48:211105 98               uv 00 21  1 420 01   
;   598                         -- as promised, reverse it:
;   599                         for j=1 to r1len do     -- stops at mid-point[-1]
    mov [rbp-224] (symtab[230]),rax       ;#0044F026: 48:211205 20FFFFFF         vu 00 21  1 420      
    mov qword[rbp-232] (j),1              ;#0044F02D: 48:307205 18FFFFFF 01000000 uv 00 20  1 421      
    cmp rax,1                             ;#0044F038: 48:075 01000000            vu 00 01  1 421      
    jl #0044FB4A                          ;#0044F03E: 017214 060B0000            v  00 00  1 422      
;   600                             if j>=r1len then exit end if
    mov rcx,[rbp-232] (j)                 ;#0044F044: 48:213215 18FFFFFF         uv 02 20  1 423      
    mov rsi,[rbp-104] (r1len)             ;#0044F04B: 48:213165 98               vu 40 20  1 423      
    cmp rcx,rsi                           ;#0044F04F: 48:071361                  uv 00 42  1 424      
    jge #0044FB4A                         ;#0044F052: 017215 F20A0000            v  00 00  1 424      
;   601                             tmp = r1[j]
    mov rdi,rcx                           ;#0044F058: 48:211317                  uv 80 02  1 425      
    mov rsi,[rbp-56] (r1)                 ;#0044F05B: 48:213165 C8               vu 40 20  1 425      
    mov rdx,200                           ;#0044F05F: 48:307302 C8000000         uv 04 00  1 426      
    call #00441762 (:%pSubse1is)          ;#0044F066: 350 F726FFFF               v  00 00  1 426      
    mov [rbp-176] (tmp),rax               ;#0044F06B: 48:211205 50FFFFFF         uv 00 21  1 427      
;   602                             r1[j] = r1[r1len]
    mov rdi,[rbp-104] (r1len)             ;#0044F072: 48:213175 98               vu 80 20  1 427      
    mov rsi,[rbp-56] (r1)                 ;#0044F076: 48:213165 C8               uv 40 20  1 428      
    mov rdx,200                           ;#0044F07A: 48:307302 C8000000         vu 04 00  1 428      
    call #00441762 (:%pSubse1is)          ;#0044F081: 350 DC26FFFF               v  00 00  1 429      
    mov [rbp-192] (symtab[221]),rax       ;#0044F086: 48:211205 40FFFFFF         uv 00 21  1 430      
    mov rcx,rax                           ;#0044F08D: 48:211301                  vu 02 01  1 430      
    mov rdi,[rbp-232] (j)                 ;#0044F090: 48:213275 18FFFFFF         uv 80 20  1 431      
    mov rsi,[rbp-56] (r1)                 ;#0044F097: 48:213165 C8               vu 40 20  1 431      
    lea rax,[rbp-56] (r1)                 ;#0044F09B: 48:215105 C8               uv 01 20  1 432      
    call #00440C54 (:%pRepe1)             ;#0044F09F: 350 B01BFFFF               v  00 00  1 432      
    mov rax,[rbp-56] (r1)                 ;#0044F0A4: 48:213105 C8               uv 01 20  1 433      
    mov r15,h4                            ;#0044F0A8: 49:277 0000000000000040    vu 8000 00  1 433      
    cmp rax,r15                           ;#0044F0B2: 4C:071370                  uv 00 8001  1 434      
    jl #0044F0BE                          ;#0044F0B5: 174 07                     v  00 00  1 434      
    cmp byte[rbx+rax*4-1],#82             ;#0044F0B7: 200174203 FF 82            u  00 09  2 435      
    je #0044F0CA                          ;#0044F0BC: 164 0C                     v  00 00  1 436      
    mov rcx,200                           ;#0044F0BE: 48:307301 C8000000         uv 02 00  1 437      
    call #00442A58 (:%opTchkFail)         ;#0044F0C5: 350 8E39FFFF               v  00 00  1 437      
;   603                             r1[r1len] = tmp
    mov rsi,rax                           ;#0044F0CA: 48:211306                  uv 40 01  1 438      
    mov rdi,[rbp-104] (r1len)             ;#0044F0CD: 48:213175 98               vu 80 20  1 438      
    mov rcx,[rbp-176] (tmp)               ;#0044F0D1: 48:213215 50FFFFFF         uv 02 20  1 439      
    lea rax,[rbp-56] (r1)                 ;#0044F0D8: 48:215105 C8               vu 01 20  1 439      
    call #00440C54 (:%pRepe1)             ;#0044F0DC: 350 731BFFFF               v  00 00  1 440      
    mov rax,[rbp-56] (r1)                 ;#0044F0E1: 48:213105 C8               uv 01 20  1 441      
    mov r15,h4                            ;#0044F0E5: 49:277 0000000000000040    vu 8000 00  1 441      
    cmp rax,r15                           ;#0044F0EF: 4C:071370                  uv 00 8001  1 442      
    jl #0044F0FB                          ;#0044F0F2: 174 07                     v  00 00  1 442      
    cmp byte[rbx+rax*4-1],#82             ;#0044F0F4: 200174203 FF 82            u  00 09  2 443      
    je #0044F107                          ;#0044F0F9: 164 0C                     v  00 00  1 444      
    mov rcx,200                           ;#0044F0FB: 48:307301 C8000000         uv 02 00  1 445      
    call #00442A58 (:%opTchkFail)         ;#0044F102: 350 5139FFFF               v  00 00  1 445      
;   604                             r1len -= 1
    mov rsi,[rbp-104] (r1len)             ;#0044F107: 48:213165 98               uv 40 20  1 446      
    sub rsi,1                             ;#0044F10B: 48:203356 01               uv 40 40  1 447 40   
    mov rdx,rsi                           ;#0044F10F: 48:213326                  uv 04 40  1 448 40   
    mov [rbp-104] (r1len),rsi             ;#0044F112: 48:211165 98               vu 00 60  1 448      
    shl rdx,1                             ;#0044F116: 48:321342                  u  04 04  1 449      
    jno #0044F124                         ;#0044F119: 161 09                     v  00 00  1 449      
    lea rdi,[rbp-104] (r1len)             ;#0044F11B: 48:215175 98               uv 80 20  1 450      
    call #00442DA9 (:%pAddiii)            ;#0044F11F: 350 853CFFFF               v  00 00  1 450      
;   605                         end for
    mov rdi,[rbp-232] (j)                 ;#0044F124: 48:213275 18FFFFFF         uv 80 20  1 451      
    mov rcx,[rbp-224] (symtab[230])       ;#0044F12B: 48:213215 20FFFFFF         vu 02 20  1 451      
    add rdi,1                             ;#0044F132: 48:203307 01               uv 80 80  1 452      
    cmp rdi,rcx                           ;#0044F136: 48:073371                  uv 00 82  1 453 80   
    mov [rbp-232] (j),rdi                 ;#0044F139: 48:211275 18FFFFFF         vu 00 A0  1 453      
    jle #0044F044                         ;#0044F140: 017216 FEFEFFFF            v  00 00  1 454      
    jmp #0044FB4A                         ;#0044F146: 351 FF090000               v  00 00  1 455      
;   606                     else
;   607 --DEV not thread safe:
;   608                         if o=nan then
    mov rdi,[#004021F8] (nan)             ;#0044F14B: 48:213075 A630FBFF         uv 80 00  1 456      
    mov rax,[rbp-64] (o)                  ;#0044F152: 48:213105 C0               vu 01 20  1 456      
    mov rsi,123                           ;#0044F156: 48:307306 7B000000         uv 40 00  1 457      
    mov rdx,201                           ;#0044F15D: 48:307302 C9000000         vu 04 00  1 457      
    call #0043FAF6 (:%opJccE)             ;#0044F164: 350 8D09FFFF               v  00 00  1 458      
    jne #0044F1B7                         ;#0044F169: 165 4C                     v  00 00  1 459      
;   609 --                          r1 = "nan"
;   610                             r1 = Nan()
    mov rcx,1                             ;#0044F16B: 48:307301 01000000         uv 02 00  1 460      
    mov rdx,125                           ;#0044F172: 48:307302 7D000000         vu 04 00  1 460      
    call #004428DB (:%opFrame) (Nan)      ;#0044F179: 350 5D37FFFF               v  00 00  1 461      
    mov qword[retaddr],#0044F18B          ;#0044F17E: 48:307105 20 8BF14400      uv 00 20  1 462      
    jmp #0045196E (code:Nan)              ;#0044F186: 351 E3270000               v  00 00  1 462      
    push rax                              ;#0044F18B: 120                        uv 00 01  1 463      
    mov rsi,[rbp-56] (r1)                 ;#0044F18C: 48:213165 C8               vu 40 20  1 463      
    mov r15,h4                            ;#0044F190: 49:277 0000000000000040    uv 8000 00  1 464      
    cmp rsi,r15                           ;#0044F19A: 4C:071376                  uv 00 8040  1 465 8000   
    jle #0044F1AF                         ;#0044F19D: 176 10                     v  00 00  1 465      
    sub qword[rbx+rsi*4-16],1             ;#0044F19F: 48:203154263 F0 01         u  00 48  3 466      
    jne #0044F1AF                         ;#0044F1A5: 165 08                     v  00 00  1 468      
    mov rdx,rsi                           ;#0044F1A7: 48:213326                  uv 04 40  1 469      
    call #004422DA (:%pDealloc)           ;#0044F1AA: 350 2B31FFFF               v  00 00  1 469      
    pop dword[rbp-56] (r1)                ;#0044F1AF: 217105 C8                  np 00 20  3 470      
    jmp #0044FB4A                         ;#0044F1B2: 351 93090000               v  00 00  1 473      
;   611                         elsif o=-nan then
    mov rcx,[#004021F8] (nan)             ;#0044F1B7: 48:213015 3A30FBFF         uv 02 00  1 474      
    mov r15,h4                            ;#0044F1BE: 49:277 0000000000000040    vu 8000 00  1 474      
    cmp rcx,r15                           ;#0044F1C8: 4C:071371                  uv 00 8002  1 475      
    jne #0044F1D9                         ;#0044F1CB: 165 0C                     v  00 00  1 475      
    mov rsi,123                           ;#0044F1CD: 48:307306 7B000000         uv 40 00  1 476      
    call #00442D75 (:%pUnassigned)        ;#0044F1D4: 350 9C3BFFFF               v  00 00  1 476      
    lea rdi,[rbp-200] (symtab[223])       ;#0044F1D9: 48:215275 38FFFFFF         uv 80 20  1 477      
    call #0043F746 (:%opUminus)           ;#0044F1E0: 350 6105FFFF               v  00 00  1 477      
    mov rdi,[rbp-200] (symtab[223])       ;#0044F1E5: 48:213275 38FFFFFF         uv 80 20  1 478      
    mov rax,[rbp-64] (o)                  ;#0044F1EC: 48:213105 C0               vu 01 20  1 478      
    mov rsi,223                           ;#0044F1F0: 48:307306 DF000000         uv 40 00  1 479      
    mov rdx,201                           ;#0044F1F7: 48:307302 C9000000         vu 04 00  1 479      
    call #0043FAF6 (:%opJccE)             ;#0044F1FE: 350 F308FFFF               v  00 00  1 480      
    jne #0044F2F3                         ;#0044F203: 017205 EA000000            v  00 00  1 481      
;   612 --                          r1 = "-nan"
;   613                             r1 = '-'&Nan()
    mov rcx,1                             ;#0044F209: 48:307301 01000000         uv 02 00  1 482      
    mov rdx,125                           ;#0044F210: 48:307302 7D000000         vu 04 00  1 482      
    call #004428DB (:%opFrame) (Nan)      ;#0044F217: 350 BF36FFFF               v  00 00  1 483      
    mov qword[retaddr],#0044F229          ;#0044F21C: 48:307105 20 29F24400      uv 00 20  1 484      
    jmp #0045196E (code:Nan)              ;#0044F224: 351 45270000               v  00 00  1 484      
    push rax                              ;#0044F229: 120                        uv 00 01  1 485      
    mov rsi,[rbp-240] (symtab[232])       ;#0044F22A: 48:213265 10FFFFFF         vu 40 20  1 485      
    mov r15,h4                            ;#0044F231: 49:277 0000000000000040    uv 8000 00  1 486      
    cmp rsi,r15                           ;#0044F23B: 4C:071376                  uv 00 8040  1 487 8000   
    jle #0044F250                         ;#0044F23E: 176 10                     v  00 00  1 487      
    sub qword[rbx+rsi*4-16],1             ;#0044F240: 48:203154263 F0 01         u  00 48  3 488      
    jne #0044F250                         ;#0044F246: 165 08                     v  00 00  1 490      
    mov rdx,rsi                           ;#0044F248: 48:213326                  uv 04 40  1 491      
    call #004422DA (:%pDealloc)           ;#0044F24B: 350 8A30FFFF               v  00 00  1 491      
    pop dword[rbp-240] (symtab[232])      ;#0044F250: 217205 10FFFFFF            np 00 20  3 492      
    mov rcx,[rbp-240] (symtab[232])       ;#0044F256: 48:213215 10FFFFFF         uv 02 20  1 495      
    mov rdi,[rbp-56] (r1)                 ;#0044F25D: 48:213175 C8               vu 80 20  1 495      
    mov [rbp-240] (symtab[232]),rbx       ;#0044F261: 48:211235 10FFFFFF         uv 00 28  1 496      
    mov r15,h4                            ;#0044F268: 49:277 0000000000000040    vu 8000 00  1 496      
    cmp rdi,r15                           ;#0044F272: 4C:071377                  uv 00 8080  1 497      
    mov [rbp-56] (r1),rcx                 ;#0044F275: 48:211115 C8               vu 00 22  1 497      
    jle #0044F28A                         ;#0044F279: 176 0F                     v  00 00  1 498      
    sub qword[rbx+rdi*4-16],1             ;#0044F27B: 48:203154273 F0 01         u  00 88  3 499      
    jne #0044F28A                         ;#0044F281: 165 07                     v  00 00  1 501      
    mov edx,edi                           ;#0044F283: 213327                     uv 04 80  1 502      
    call #004422DA (:%pDealloc)           ;#0044F285: 350 5030FFFF               v  00 00  1 502      
    mov rax,[rbp-56] (r1)                 ;#0044F28A: 48:213105 C8               uv 01 20  1 503      
    mov r15,h4                            ;#0044F28E: 49:277 0000000000000040    vu 8000 00  1 503      
    cmp rax,r15                           ;#0044F298: 4C:071370                  uv 00 8001  1 504      
    jne #0044F2A9                         ;#0044F29B: 165 0C                     v  00 00  1 504      
    mov rsi,200                           ;#0044F29D: 48:307306 C8000000         uv 40 00  1 505      
    call #00442D75 (:%pUnassigned)        ;#0044F2A4: 350 CC3AFFFF               v  00 00  1 505      
    lea rdx,[rbp-56] (r1)                 ;#0044F2A9: 48:215125 C8               uv 04 20  1 506      
    lea rdi,[rbp-56] (r1)                 ;#0044F2AD: 48:215175 C8               vu 80 20  1 506      
    lea rcx,qword[#00402218]              ;#0044F2B1: 48:215015 602FFBFF         uv 02 00  1 507      
    mov rax,1                             ;#0044F2B8: 48:307300 01000000         vu 01 00  1 507      
    call #0043FC15 (:%opApnd)             ;#0044F2BF: 350 5109FFFF               v  00 00  1 508      
    mov rsi,[rbp-56] (r1)                 ;#0044F2C4: 48:213165 C8               uv 40 20  1 509      
    mov r15,h4                            ;#0044F2C8: 49:277 0000000000000040    vu 8000 00  1 509      
    cmp rsi,r15                           ;#0044F2D2: 4C:071376                  uv 00 8040  1 510      
    jl #0044F2E2                          ;#0044F2D5: 174 0B                     v  00 00  1 510      
    cmp byte[rbx+rsi*4-1],#82             ;#0044F2D7: 200174263 FF 82            u  00 48  2 511      
    je #0044FB4A                          ;#0044F2DC: 017204 68080000            v  00 00  1 512      
    mov rcx,200                           ;#0044F2E2: 48:307301 C8000000         uv 02 00  1 513      
    call #00442A58 (:%opTchkFail)         ;#0044F2E9: 350 6A37FFFF               v  00 00  1 513      
    jmp #0044FB4A                         ;#0044F2EE: 351 57080000               v  00 00  1 514      
;   614                         elsif o=inf then
    mov rdi,[#004021F0] (inf)             ;#0044F2F3: 48:213075 F62EFBFF         uv 80 00  1 515      
    mov rax,[rbp-64] (o)                  ;#0044F2FA: 48:213105 C0               vu 01 20  1 515      
    mov rsi,122                           ;#0044F2FE: 48:307306 7A000000         uv 40 00  1 516      
    mov rdx,201                           ;#0044F305: 48:307302 C9000000         vu 04 00  1 516      
    call #0043FAF6 (:%opJccE)             ;#0044F30C: 350 E507FFFF               v  00 00  1 517      
    jne #0044F35F                         ;#0044F311: 165 4C                     v  00 00  1 518      
;   615 --                          r1 = "inf"
;   616                             r1 = Inf()
    mov rcx,1                             ;#0044F313: 48:307301 01000000         uv 02 00  1 519      
    mov rdx,130                           ;#0044F31A: 48:307302 82000000         vu 04 00  1 519      
    call #004428DB (:%opFrame) (Inf)      ;#0044F321: 350 B535FFFF               v  00 00  1 520      
    mov qword[retaddr],#0044F333          ;#0044F326: 48:307105 20 33F34400      uv 00 20  1 521      
    jmp #00451917 (code:Inf)              ;#0044F32E: 351 E4250000               v  00 00  1 521      
    push rax                              ;#0044F333: 120                        uv 00 01  1 522      
    mov rcx,[rbp-56] (r1)                 ;#0044F334: 48:213115 C8               vu 02 20  1 522      
    mov r15,h4                            ;#0044F338: 49:277 0000000000000040    uv 8000 00  1 523      
    cmp rcx,r15                           ;#0044F342: 4C:071371                  uv 00 8002  1 524 8000   
    jle #0044F357                         ;#0044F345: 176 10                     v  00 00  1 524      
    sub qword[rbx+rcx*4-16],1             ;#0044F347: 48:203154213 F0 01         u  00 0A  3 525      
    jne #0044F357                         ;#0044F34D: 165 08                     v  00 00  1 527      
    mov rdx,rcx                           ;#0044F34F: 48:213321                  uv 04 02  1 528      
    call #004422DA (:%pDealloc)           ;#0044F352: 350 832FFFFF               v  00 00  1 528      
    pop dword[rbp-56] (r1)                ;#0044F357: 217105 C8                  np 00 20  3 529      
    jmp #0044FB4A                         ;#0044F35A: 351 EB070000               v  00 00  1 532      
;   617                         else
;   618 --                          r1 = "0"
;   619                             r1 = repeat('0',1)
    lea rdi,[rbp-56] (r1)                 ;#0044F35F: 48:215175 C8               uv 80 20  1 533      
    mov rax,48                            ;#0044F363: 48:307300 30000000         vu 01 00  1 533      
    mov rcx,1                             ;#0044F36A: 48:307301 01000000         uv 02 00  1 534      
    call #0043B1E1 (:%opRepCh)            ;#0044F371: 350 6BBEFEFF               v  00 00  1 534      
;   620                         end if
;   621                     end if
    jmp #0044FB4A                         ;#0044F376: 351 CF070000               v  00 00  1 535      
;   622                 elsif fidx<=6 then  -- 's' or 'c'
    cmp rdi,6                             ;#0044F37B: 48:203377 06               uv 00 80  1 536      
    jg #0044F86D                          ;#0044F37F: 017217 E8040000            v  00 00  1 536      
;   623                     if atom(args) then
    mov rsi,[rbp-8] (args)                ;#0044F385: 48:213165 F8               uv 40 20  1 537      
    mov r15,h4                            ;#0044F389: 49:277 0000000000000040    vu 8000 00  1 537      
    cmp rsi,r15                           ;#0044F393: 4C:071376                  uv 00 8040  1 538      
    jl #0044F39F                          ;#0044F396: 174 07                     v  00 00  1 538      
    cmp byte[rbx+rsi*4-1],#12             ;#0044F398: 200174263 FF 12            u  00 48  2 539      
    jne #0044F3E5                         ;#0044F39D: 165 46                     v  00 00  1 540      
;   624                         o = args
    mov rdx,[rbp-64] (o)                  ;#0044F39F: 48:213125 C0               uv 04 20  1 541      
    mov r15,h4                            ;#0044F3A3: 49:277 0000000000000040    vu 8000 00  1 541      
    cmp rsi,r15                           ;#0044F3AD: 4C:071376                  uv 00 8040  1 542      
    jl #0044F3B8                          ;#0044F3B0: 174 06                     v  00 00  1 542      
    add qword[rbx+rsi*4-16],1             ;#0044F3B2: 48:203104263 F0 01         u  00 48  3 543      
    mov [rbp-64] (o),rsi                  ;#0044F3B8: 48:211165 C0               vu 00 60  1 545      
    mov r15,h4                            ;#0044F3BC: 49:277 0000000000000040    uv 8000 00  1 546      
    cmp rdx,r15                           ;#0044F3C6: 4C:071372                  uv 00 8004  1 547 8000   
    jle #0044F50A                         ;#0044F3C9: 017216 3B010000            v  00 00  1 547      
    sub qword[rbx+rdx*4-16],1             ;#0044F3CF: 48:203154223 F0 01         u  00 0C  3 548      
    jne #0044F50A                         ;#0044F3D5: 017205 2F010000            v  00 00  1 550      
    call #004422DA (:%pDealloc)           ;#0044F3DB: 350 FA2EFFFF               v  00 00  1 551      
    jmp #0044F50A                         ;#0044F3E0: 351 25010000               v  00 00  1 552      
;   625                     elsif useFlatString(args,nxt,format,i) then
    mov rcx,11                            ;#0044F3E5: 48:307301 0B000000         uv 02 00  1 553      
    mov rdx,177                           ;#0044F3EC: 48:307302 B1000000         vu 04 00  1 553      
    call :%opFrame (useFlatString)        ;#0044F3F3: 350 E334FFFF               v  00 00  1 554      
    mov rdi,[rbp+40] (prevebp)            ;#0044F3F8: 48:213175 28               uv 80 20  1 555      
    mov rax,[rdi-8]                       ;#0044F3FC: 48:213107 F8               uv 01 80  1 558 80 *80*
    xor rbx,rbx                           ;#0044F400: 48:061333                  vu 08 08  1 558      
    mov r15,h4                            ;#0044F403: 49:277 0000000000000040    uv 8000 00  1 559      
    cmp rax,r15                           ;#0044F40D: 4C:071370                  uv 00 8001  1 560 8000   
    jl #0044F41D                          ;#0044F410: 174 0B                     v  00 00  1 560      
    add qword[rbx+rax*4-16],1             ;#0044F412: 48:203104203 F0 01         u  00 09  3 561      
    cmp eax,194                           ;#0044F418: 075 C2000000               vu 00 01  1 563      
    mov [rbp] (args),rax                  ;#0044F41D: 48:211105 00               uv 00 21  1 564      
    mov rdi,[rbp+40] (prevebp)            ;#0044F421: 48:213175 28               vu 80 20  1 564      
    mov rax,[rdi-40]                      ;#0044F425: 48:213107 D8               uv 01 80  1 567    *80*
    mov [rbp-8] (nxt),rax                 ;#0044F429: 48:211105 F8               uv 00 21  1 568 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044F42D: 48:213175 28               vu 80 20  1 568      
    mov rax,[rdi]                         ;#0044F431: 48:213007                  uv 01 80  1 571    *80*
    xor rbx,rbx                           ;#0044F434: 48:061333                  vu 08 08  1 571      
    mov r15,h4                            ;#0044F437: 49:277 0000000000000040    uv 8000 00  1 572      
    cmp rax,r15                           ;#0044F441: 4C:071370                  uv 00 8001  1 573 8000   
    jl #0044F451                          ;#0044F444: 174 0B                     v  00 00  1 573      
    add qword[rbx+rax*4-16],1             ;#0044F446: 48:203104203 F0 01         u  00 09  3 574      
    cmp eax,193                           ;#0044F44C: 075 C1000000               vu 00 01  1 576      
    mov [rbp-16] (format),rax             ;#0044F451: 48:211105 F0               uv 00 21  1 577      
    mov rdi,[rbp+40] (prevebp)            ;#0044F455: 48:213175 28               vu 80 20  1 577      
    mov rax,[rdi-16]                      ;#0044F459: 48:213107 F0               uv 01 80  1 580    *80*
    mov [rbp-24] (i),rax                  ;#0044F45D: 48:211105 E8               uv 00 21  1 581 01   
    mov qword[retaddr],#0044F46E          ;#0044F461: 48:307105 20 6EF44400      vu 00 20  1 581      
    jmp #0045174E (code:useFlatString)    ;#0044F469: 351 E0220000               v  00 00  1 582      
    test rax,rax                          ;#0044F46E: 48:205300                  uv 00 01  1 583      
    je #0044F4F2                          ;#0044F471: 164 7F                     v  00 00  1 583      
;   626                         o = args
    mov rcx,[rbp-8] (args)                ;#0044F473: 48:213115 F8               uv 02 20  1 584      
    mov rdx,[rbp-64] (o)                  ;#0044F477: 48:213125 C0               vu 04 20  1 584      
    mov r15,h4                            ;#0044F47B: 49:277 0000000000000040    uv 8000 00  1 585      
    cmp rcx,r15                           ;#0044F485: 4C:071371                  uv 00 8002  1 586 8000   
    jl #0044F490                          ;#0044F488: 174 06                     v  00 00  1 586      
    add qword[rbx+rcx*4-16],1             ;#0044F48A: 48:203104213 F0 01         u  00 0A  3 587      
    mov [rbp-64] (o),rcx                  ;#0044F490: 48:211115 C0               vu 00 22  1 589      
    mov r15,h4                            ;#0044F494: 49:277 0000000000000040    uv 8000 00  1 590      
    cmp rdx,r15                           ;#0044F49E: 4C:071372                  uv 00 8004  1 591 8000   
    jle #0044F4B0                         ;#0044F4A1: 176 0D                     v  00 00  1 591      
    sub qword[rbx+rdx*4-16],1             ;#0044F4A3: 48:203154223 F0 01         u  00 0C  3 592      
    jne #0044F4B0                         ;#0044F4A9: 165 05                     v  00 00  1 594      
    call #004422DA (:%pDealloc)           ;#0044F4AB: 350 2A2EFFFF               v  00 00  1 595      
;   627                         args = {}
    mov rdi,qword[#004022C8]              ;#0044F4B0: 48:213075 112EFBFF         uv 80 00  1 596      
    mov rdx,[rbp-8] (args)                ;#0044F4B7: 48:213125 F8               vu 04 20  1 596      
    mov r15,h4                            ;#0044F4BB: 49:277 0000000000000040    uv 8000 00  1 597      
    cmp rdi,r15                           ;#0044F4C5: 4C:071377                  uv 00 8080  1 598 8000   
    jl #0044F4D0                          ;#0044F4C8: 174 06                     v  00 00  1 598      
    add qword[rbx+rdi*4-16],1             ;#0044F4CA: 48:203104273 F0 01         u  00 88  3 599      
    mov [rbp-8] (args),rdi                ;#0044F4D0: 48:211175 F8               vu 00 A0  1 601      
    mov r15,h4                            ;#0044F4D4: 49:277 0000000000000040    uv 8000 00  1 602      
    cmp rdx,r15                           ;#0044F4DE: 4C:071372                  uv 00 8004  1 603 8000   
    jle #0044F50A                         ;#0044F4E1: 176 27                     v  00 00  1 603      
    sub qword[rbx+rdx*4-16],1             ;#0044F4E3: 48:203154223 F0 01         u  00 0C  3 604      
    jne #0044F50A                         ;#0044F4E9: 165 1F                     v  00 00  1 606      
    call #004422DA (:%pDealloc)           ;#0044F4EB: 350 EA2DFFFF               v  00 00  1 607      
    jmp #0044F50A                         ;#0044F4F0: 353 18                     v  00 00  1 608      
;   628                     else
;   629                         o = args[nxt]
    mov rdi,[rbp-40] (nxt)                ;#0044F4F2: 48:213175 D8               uv 80 20  1 609      
    lea rcx,[rbp-64] (o)                  ;#0044F4F6: 48:215115 C0               vu 02 20  1 609      
    mov rsi,[rbp-8] (args)                ;#0044F4FA: 48:213165 F8               uv 40 20  1 610      
    mov rdx,194                           ;#0044F4FE: 48:307302 C2000000         vu 04 00  1 610      
    call #00441675 (:%pSubse1)            ;#0044F505: 350 6B21FFFF               v  00 00  1 611      
;   630                     end if
;   631                     if atom(o) then
    mov rax,[rbp-64] (o)                  ;#0044F50A: 48:213105 C0               uv 01 20  1 612      
    mov r15,h4                            ;#0044F50E: 49:277 0000000000000040    vu 8000 00  1 612      
    cmp rax,r15                           ;#0044F518: 4C:071370                  uv 00 8001  1 613      
    jne #0044F529                         ;#0044F51B: 165 0C                     v  00 00  1 613      
    mov rsi,201                           ;#0044F51D: 48:307306 C9000000         uv 40 00  1 614      
    call #00442D75 (:%pUnassigned)        ;#0044F524: 350 4C38FFFF               v  00 00  1 614      
    mov rcx,201                           ;#0044F529: 48:307301 C9000000         uv 02 00  1 615      
    call #0043FBB0 (:%opAtom0)            ;#0044F530: 350 7B06FFFF               v  00 00  1 615      
    test rdx,edx                          ;#0044F535: 205322                     uv 00 04  1 616      
    je #0044F5DE                          ;#0044F537: 017204 A1000000            v  00 00  1 616      
;   632                         r1 = " "
    mov rcx,qword[#004022D0]              ;#0044F53D: 48:213015 8C2DFBFF         uv 02 00  1 617      
    mov rdx,[rbp-56] (r1)                 ;#0044F544: 48:213125 C8               vu 04 20  1 617      
    mov r15,h4                            ;#0044F548: 49:277 0000000000000040    uv 8000 00  1 618      
    cmp rcx,r15                           ;#0044F552: 4C:071371                  uv 00 8002  1 619 8000   
    jl #0044F55D                          ;#0044F555: 174 06                     v  00 00  1 619      
    add qword[rbx+rcx*4-16],1             ;#0044F557: 48:203104213 F0 01         u  00 0A  3 620      
    mov [rbp-56] (r1),rcx                 ;#0044F55D: 48:211115 C8               vu 00 22  1 622      
    mov r15,h4                            ;#0044F561: 49:277 0000000000000040    uv 8000 00  1 623      
    cmp rdx,r15                           ;#0044F56B: 4C:071372                  uv 00 8004  1 624 8000   
    jle #0044F57D                         ;#0044F56E: 176 0D                     v  00 00  1 624      
    sub qword[rbx+rdx*4-16],1             ;#0044F570: 48:203154223 F0 01         u  00 0C  3 625      
    jne #0044F57D                         ;#0044F576: 165 05                     v  00 00  1 627      
    call #004422DA (:%pDealloc)           ;#0044F578: 350 5D2DFFFF               v  00 00  1 628      
;   633                         r1[1] = and_bits(#FF,o) -- (nb: keeps r1 a string)
    lea rdi,[rbp-192] (symtab[221])       ;#0044F57D: 48:215275 40FFFFFF         uv 80 20  1 629      
    mov rcx,qword[#00402268]              ;#0044F584: 48:213015 DD2CFBFF         vu 02 00  1 629      
    mov rax,[rbp-64] (o)                  ;#0044F58B: 48:213105 C0               uv 01 20  1 630      
    call #0043F6C1 (:%opAndBits)          ;#0044F58F: 350 2D01FFFF               v  00 00  1 630      
    mov rdi,qword[#00402030]              ;#0044F594: 48:213075 952AFBFF         uv 80 00  1 631      
    mov rcx,[rbp-192] (symtab[221])       ;#0044F59B: 48:213215 40FFFFFF         vu 02 20  1 631      
    mov rsi,[rbp-56] (r1)                 ;#0044F5A2: 48:213165 C8               uv 40 20  1 632      
    lea rax,[rbp-56] (r1)                 ;#0044F5A6: 48:215105 C8               vu 01 20  1 632      
    call #00440C54 (:%pRepe1)             ;#0044F5AA: 350 A516FFFF               v  00 00  1 633      
    mov rax,[rbp-56] (r1)                 ;#0044F5AF: 48:213105 C8               uv 01 20  1 634      
    mov r15,h4                            ;#0044F5B3: 49:277 0000000000000040    vu 8000 00  1 634      
    cmp rax,r15                           ;#0044F5BD: 4C:071370                  uv 00 8001  1 635      
    jl #0044F5CD                          ;#0044F5C0: 174 0B                     v  00 00  1 635      
    cmp byte[rbx+rax*4-1],#82             ;#0044F5C2: 200174203 FF 82            u  00 09  2 636      
    je #0044FB4A                          ;#0044F5C7: 017204 7D050000            v  00 00  1 637      
    mov rcx,200                           ;#0044F5CD: 48:307301 C8000000         uv 02 00  1 638      
    call #00442A58 (:%opTchkFail)         ;#0044F5D4: 350 7F34FFFF               v  00 00  1 638      
    jmp #0044FB4A                         ;#0044F5D9: 351 6C050000               v  00 00  1 639      
;   634                     elsif fidx=6 then -- 'c'
    mov rdi,[rbp-32] (fidx)               ;#0044F5DE: 48:213175 E0               uv 80 20  1 640      
    cmp rdi,6                             ;#0044F5E2: 48:203377 06               uv 00 80  1 641 80   
    jne #0044F5F4                         ;#0044F5E6: 165 0C                     v  00 00  1 641      
;   635 --/**/                  #ilASM{ mov al,76                           -- Phix
    mov al,76                             ;#0044F5E8: 260 4C                     uv 01 00  1 642      
;   636 --!/**/                         xor edi,edi         -- ep1 unused   -- Phix
;   637 --!/**/                         xor esi,esi         -- ep2 unused   -- Phix
;   638 --/**/                          call :%pRTErn }     -- fatal error  -- Phix
    call #00442DC8 (:%pRTErn)             ;#0044F5EA: 350 D937FFFF               v  00 00  1 642      
;   639 --/**/                                                      --/*    -- Phix
;   640                         puts(1,"%c requires an atom value\n")       -- RDS
;   641                         if getc(0) then end if                      -- RDS
;   642                         abort(1)                                    -- RDS --*/
    jmp #0044FB4A                         ;#0044F5EF: 351 56050000               v  00 00  1 643      
;   643                     elsif not string(o) then
    mov r15,h4                            ;#0044F5F4: 49:277 0000000000000040    uv 8000 00  1 644      
    cmp rax,r15                           ;#0044F5FE: 4C:071370                  uv 00 8001  1 645 8000   
    jne #0044F60F                         ;#0044F601: 165 0C                     v  00 00  1 645      
    mov rsi,201                           ;#0044F603: 48:307306 C9000000         uv 40 00  1 646      
    call #00442D75 (:%pUnassigned)        ;#0044F60A: 350 6637FFFF               v  00 00  1 646      
    mov rcx,201                           ;#0044F60F: 48:307301 C9000000         uv 02 00  1 647      
    call #0043FBCE (:%opStr0)             ;#0044F616: 350 B305FFFF               v  00 00  1 647      
    test rdx,edx                          ;#0044F61B: 205322                     uv 00 04  1 648      
    jne #0044F7B1                         ;#0044F61D: 017205 8E010000            v  00 00  1 648      
;   644                         if precision!=-1 and precision<length(o) then
    mov rcx,[rbp-168] (precision)         ;#0044F623: 48:213215 58FFFFFF         uv 02 20  1 649      
    cmp rcx,-1                            ;#0044F62A: 48:203371 FF               uv 00 02  1 650 02   
    je #0044F66B                          ;#0044F62E: 164 3B                     v  00 00  1 650      
    lea rdi,[rbp-192] (symtab[221])       ;#0044F630: 48:215275 40FFFFFF         uv 80 20  1 651      
    mov rsi,rax                           ;#0044F637: 48:211306                  vu 40 01  1 651      
    mov rdx,201                           ;#0044F63A: 48:307302 C9000000         uv 04 00  1 652      
    call #0043F28D (:%opLen)              ;#0044F641: 350 47FCFEFF               v  00 00  1 652      
    mov rdi,[rbp-168] (precision)         ;#0044F646: 48:213275 58FFFFFF         uv 80 20  1 653      
    cmp rdi,rcx                           ;#0044F64D: 48:071317                  uv 00 82  1 654 80   
    jge #0044F66B                         ;#0044F650: 175 19                     v  00 00  1 654      
;   645                             r1 = repeat(' ',precision)
    lea rdi,[rbp-56] (r1)                 ;#0044F652: 48:215175 C8               uv 80 20  1 655      
    mov rax,32                            ;#0044F656: 48:307300 20000000         vu 01 00  1 655      
    mov rcx,[rbp-168] (precision)         ;#0044F65D: 48:213215 58FFFFFF         uv 02 20  1 656      
    call #0043B1E1 (:%opRepCh)            ;#0044F664: 350 78BBFEFF               v  00 00  1 656      
    jmp #0044F692                         ;#0044F669: 353 27                     v  00 00  1 657      
;   646                         else
;   647                             r1 = repeat(' ',length(o))
    lea rdi,[rbp-192] (symtab[221])       ;#0044F66B: 48:215275 40FFFFFF         uv 80 20  1 658      
    mov rsi,[rbp-64] (o)                  ;#0044F672: 48:213165 C0               vu 40 20  1 658      
    mov rdx,201                           ;#0044F676: 48:307302 C9000000         uv 04 00  1 659      
    call #0043F28D (:%opLen)              ;#0044F67D: 350 0BFCFEFF               v  00 00  1 659      
    lea rdi,[rbp-56] (r1)                 ;#0044F682: 48:215175 C8               uv 80 20  1 660      
    mov rax,32                            ;#0044F686: 48:307300 20000000         vu 01 00  1 660      
    call #0043B1E1 (:%opRepCh)            ;#0044F68D: 350 4FBBFEFF               v  00 00  1 661      
;   648                         end if
;   649                         for j=1 to length(r1) do
    lea rdi,[rbp-192] (symtab[221])       ;#0044F692: 48:215275 40FFFFFF         uv 80 20  1 662      
    mov rsi,[rbp-56] (r1)                 ;#0044F699: 48:213165 C8               vu 40 20  1 662      
    mov rdx,200                           ;#0044F69D: 48:307302 C8000000         uv 04 00  1 663      
    call #0043F28D (:%opLen)              ;#0044F6A4: 350 E4FBFEFF               v  00 00  1 663      
    mov qword[rbp-248] (j),1              ;#0044F6A9: 48:307205 08FFFFFF 01000000 uv 00 20  1 664      
    cmp rcx,1                             ;#0044F6B4: 48:201371 01000000         vu 00 02  1 664      
    jl #0044FB4A                          ;#0044F6BB: 017214 89040000            v  00 00  1 665      
;   650                             oj = o[j]
    mov rax,[rbp-64] (o)                  ;#0044F6C1: 48:213105 C0               uv 01 20  1 666      
    mov r15,h4                            ;#0044F6C5: 49:277 0000000000000040    vu 8000 00  1 666      
    cmp rax,r15                           ;#0044F6CF: 4C:071370                  uv 00 8001  1 667      
    jne #0044F6E0                         ;#0044F6D2: 165 0C                     v  00 00  1 667      
    mov rsi,201                           ;#0044F6D4: 48:307306 C9000000         uv 40 00  1 668      
    call #00442D75 (:%pUnassigned)        ;#0044F6DB: 350 9536FFFF               v  00 00  1 668      
    mov rdi,[rbp-248] (j)                 ;#0044F6E0: 48:213275 08FFFFFF         uv 80 20  1 669      
    lea rcx,[rbp-72] (oj)                 ;#0044F6E7: 48:215115 B8               vu 02 20  1 669      
    mov rsi,rax                           ;#0044F6EB: 48:211306                  uv 40 01  1 670      
    mov rdx,201                           ;#0044F6EE: 48:307302 C9000000         vu 04 00  1 670      
    call #00441675 (:%pSubse1)            ;#0044F6F5: 350 7B1FFFFF               v  00 00  1 671      
;   651                             if not integer(oj) then
    mov rsi,[rbp-72] (oj)                 ;#0044F6FA: 48:213165 B8               uv 40 20  1 672      
    mov r15,h4                            ;#0044F6FE: 49:277 0000000000000040    vu 8000 00  1 672      
    cmp rsi,r15                           ;#0044F708: 4C:071376                  uv 00 8040  1 673      
    jl #0044F714                          ;#0044F70B: 174 07                     v  00 00  1 673      
;   652 --                          if not integer(oj) or oj<#07 or oj>#FF then
;   653 --/**/                          #ilASM{ mov al,65                               -- Phix
    mov al,65                             ;#0044F70D: 260 41                     uv 01 00  1 674      
;   654 --!/**/                                 xor edi,edi         -- ep1 unused       -- Phix
;   655 --!/**/                                 xor esi,esi         -- ep2 unused       -- Phix
;   656 --/**/                                  call :%pRTErn }     -- fatal error      -- Phix
    call #00442DC8 (:%pRTErn)             ;#0044F70F: 350 B436FFFF               v  00 00  1 674      
;   657 --/**/                                                                  --/*    -- Phix
;   658                                 puts(1,"sequence found in character string\n")  -- RDS
;   659                                 if getc(0) then end if                          -- RDS
;   660                                 abort(1)                                        -- RDS --*/
;   661                             end if
;   662 --                          r1[j] = oj
;   663                             r1[j] = and_bits(oj,#FF)
    lea rdi,[rbp-208] (symtab[228])       ;#0044F714: 48:215275 30FFFFFF         uv 80 20  1 675      
    mov rcx,[rbp-72] (oj)                 ;#0044F71B: 48:213115 B8               vu 02 20  1 675      
    mov rax,qword[#00402268]              ;#0044F71F: 48:213005 422BFBFF         uv 01 00  1 676      
    call #0043F6C1 (:%opAndBits)          ;#0044F726: 350 96FFFEFF               v  00 00  1 676      
    mov rdi,[rbp-56] (r1)                 ;#0044F72B: 48:213175 C8               uv 80 20  1 677      
    mov r15,h4                            ;#0044F72F: 49:277 0000000000000040    vu 8000 00  1 677      
    cmp rdi,r15                           ;#0044F739: 4C:071377                  uv 00 8080  1 678      
    jne #0044F74A                         ;#0044F73C: 165 0C                     v  00 00  1 678      
    mov rsi,200                           ;#0044F73E: 48:307306 C8000000         uv 40 00  1 679      
    call #00442D75 (:%pUnassigned)        ;#0044F745: 350 2B36FFFF               v  00 00  1 679      
    mov rsi,rdi                           ;#0044F74A: 48:211376                  uv 40 80  1 680      
    mov rdi,[rbp-248] (j)                 ;#0044F74D: 48:213275 08FFFFFF         vu 80 20  1 680      
    mov rcx,[rbp-208] (symtab[228])       ;#0044F754: 48:213215 30FFFFFF         uv 02 20  1 681      
    lea rax,[rbp-56] (r1)                 ;#0044F75B: 48:215105 C8               vu 01 20  1 681      
    call #00440C54 (:%pRepe1)             ;#0044F75F: 350 F014FFFF               v  00 00  1 682      
    mov rax,[rbp-56] (r1)                 ;#0044F764: 48:213105 C8               uv 01 20  1 683      
    mov r15,h4                            ;#0044F768: 49:277 0000000000000040    vu 8000 00  1 683      
    cmp rax,r15                           ;#0044F772: 4C:071370                  uv 00 8001  1 684      
    jl #0044F77E                          ;#0044F775: 174 07                     v  00 00  1 684      
    cmp byte[rbx+rax*4-1],#82             ;#0044F777: 200174203 FF 82            u  00 09  2 685      
    je #0044F78A                          ;#0044F77C: 164 0C                     v  00 00  1 686      
    mov rcx,200                           ;#0044F77E: 48:307301 C8000000         uv 02 00  1 687      
    call #00442A58 (:%opTchkFail)         ;#0044F785: 350 CE32FFFF               v  00 00  1 687      
;   664                         end for
    mov rsi,[rbp-248] (j)                 ;#0044F78A: 48:213265 08FFFFFF         uv 40 20  1 688      
    mov rdi,[rbp-192] (symtab[221])       ;#0044F791: 48:213275 40FFFFFF         vu 80 20  1 688      
    add rsi,1                             ;#0044F798: 48:203306 01               uv 40 40  1 689      
    cmp rsi,rdi                           ;#0044F79C: 48:073367                  uv 00 C0  1 690 40   
    mov [rbp-248] (j),rsi                 ;#0044F79F: 48:211265 08FFFFFF         vu 00 60  1 690      
    jle #0044F6C1                         ;#0044F7A6: 017216 15FFFFFF            v  00 00  1 691      
    jmp #0044FB4A                         ;#0044F7AC: 351 99030000               v  00 00  1 692      
;   665                     else
;   666                         if precision!=-1 and precision<length(o) then
    mov rcx,[rbp-168] (precision)         ;#0044F7B1: 48:213215 58FFFFFF         uv 02 20  1 693      
    cmp rcx,-1                            ;#0044F7B8: 48:203371 FF               uv 00 02  1 694 02   
    je #0044F81E                          ;#0044F7BC: 164 60                     v  00 00  1 694      
    lea rdi,[rbp-208] (symtab[228])       ;#0044F7BE: 48:215275 30FFFFFF         uv 80 20  1 695      
    mov rsi,rax                           ;#0044F7C5: 48:211306                  vu 40 01  1 695      
    mov rdx,201                           ;#0044F7C8: 48:307302 C9000000         uv 04 00  1 696      
    call #0043F28D (:%opLen)              ;#0044F7CF: 350 B9FAFEFF               v  00 00  1 696      
    mov rdi,[rbp-168] (precision)         ;#0044F7D4: 48:213275 58FFFFFF         uv 80 20  1 697      
    cmp rdi,rcx                           ;#0044F7DB: 48:071317                  uv 00 82  1 698 80   
    jge #0044F81E                         ;#0044F7DE: 175 3E                     v  00 00  1 698      
;   667                             r1 = o[1..precision]
    mov r15,h4                            ;#0044F7E0: 49:277 0000000000000040    uv 8000 00  1 699      
    cmp rsi,r15                           ;#0044F7EA: 4C:071376                  uv 00 8040  1 700 8000   
    jne #0044F7FB                         ;#0044F7ED: 165 0C                     v  00 00  1 700      
    mov rsi,201                           ;#0044F7EF: 48:307306 C9000000         uv 40 00  1 701      
    call #00442D75 (:%pUnassigned)        ;#0044F7F6: 350 7A35FFFF               v  00 00  1 701      
    lea rax,[rbp-56] (r1)                 ;#0044F7FB: 48:215105 C8               uv 01 20  1 702      
    mov rdi,1                             ;#0044F7FF: 48:307307 01000000         vu 80 00  1 702      
    mov rcx,[rbp-168] (precision)         ;#0044F806: 48:213215 58FFFFFF         uv 02 20  1 703      
    mov rdx,201                           ;#0044F80D: 48:307302 C9000000         vu 04 00  1 703      
    call #00441212 (:%pSubsss)            ;#0044F814: 350 F919FFFF               v  00 00  1 704      
    jmp #0044FB4A                         ;#0044F819: 351 2C030000               v  00 00  1 705      
;   668                         else
;   669                             r1 = o
    mov rax,[rbp-64] (o)                  ;#0044F81E: 48:213105 C0               uv 01 20  1 706      
    mov rdx,[rbp-56] (r1)                 ;#0044F822: 48:213125 C8               vu 04 20  1 706      
    mov r15,h4                            ;#0044F826: 49:277 0000000000000040    uv 8000 00  1 707      
    cmp rax,r15                           ;#0044F830: 4C:071370                  uv 00 8001  1 708 8000   
    jl #0044F840                          ;#0044F833: 174 0B                     v  00 00  1 708      
    add qword[rbx+rax*4-16],1             ;#0044F835: 48:203104203 F0 01         u  00 09  3 709      
    cmp eax,201                           ;#0044F83B: 075 C9000000               vu 00 01  1 711      
    mov [rbp-56] (r1),rax                 ;#0044F840: 48:211105 C8               uv 00 21  1 712      
    mov r15,h4                            ;#0044F844: 49:277 0000000000000040    vu 8000 00  1 712      
    cmp rdx,r15                           ;#0044F84E: 4C:071372                  uv 00 8004  1 713      
    jle #0044FB4A                         ;#0044F851: 017216 F3020000            v  00 00  1 713      
    sub qword[rbx+rdx*4-16],1             ;#0044F857: 48:203154223 F0 01         u  00 0C  3 714      
    jne #0044FB4A                         ;#0044F85D: 017205 E7020000            v  00 00  1 716      
    call #004422DA (:%pDealloc)           ;#0044F863: 350 722AFFFF               v  00 00  1 717      
;   670                         end if
;   671                     end if
    jmp #0044FB4A                         ;#0044F868: 351 DD020000               v  00 00  1 718      
;   672                 else    -- efg/EG
;   673                     if precision=-1 then
    mov rdi,[rbp-168] (precision)         ;#0044F86D: 48:213275 58FFFFFF         uv 80 20  1 719      
    cmp rdi,-1                            ;#0044F874: 48:203377 FF               uv 00 80  1 720 80   
    jne #0044F887                         ;#0044F878: 165 0D                     v  00 00  1 720      
;   674                         precision = 6
    mov qword[rbp-168] (precision),6      ;#0044F87A: 48:307205 58FFFFFF 06000000 uv 00 20  1 721      
;   675 --                  elsif precision>16 then
;   676 --                      precision = 16
    jmp #0044F898                         ;#0044F885: 353 11                     v  00 00  1 721      
;   677                     else
;   678                         if machine_bits()=32 then
;   679                             if precision>16 then
;   680                                 precision = 16
;   681                             end if
;   682                         else -- machine_bits()=64
;   683                             if precision>20 then
    cmp rdi,20                            ;#0044F887: 48:203377 14               uv 00 80  1 722      
    jle #0044F898                         ;#0044F88B: 176 0B                     v  00 00  1 722      
;   684                                 precision = 20
    mov qword[rbp-168] (precision),20     ;#0044F88D: 48:307205 58FFFFFF 14000000 uv 00 20  1 723      
;   685                             end if
;   686                         end if
;   687                     end if
;   688                     if atom(args) then
    mov rcx,[rbp-8] (args)                ;#0044F898: 48:213115 F8               vu 02 20  1 723      
    mov r15,h4                            ;#0044F89C: 49:277 0000000000000040    uv 8000 00  1 724      
    cmp rcx,r15                           ;#0044F8A6: 4C:071371                  uv 00 8002  1 725 8000   
    jl #0044F8B2                          ;#0044F8A9: 174 07                     v  00 00  1 725      
    cmp byte[rbx+rcx*4-1],#12             ;#0044F8AB: 200174213 FF 12            u  00 0A  2 726      
    jne #0044F8ED                         ;#0044F8B0: 165 3B                     v  00 00  1 727      
;   689                         o = args
    mov rdx,[rbp-64] (o)                  ;#0044F8B2: 48:213125 C0               uv 04 20  1 728      
    mov r15,h4                            ;#0044F8B6: 49:277 0000000000000040    vu 8000 00  1 728      
    cmp rcx,r15                           ;#0044F8C0: 4C:071371                  uv 00 8002  1 729      
    jl #0044F8CB                          ;#0044F8C3: 174 06                     v  00 00  1 729      
    add qword[rbx+rcx*4-16],1             ;#0044F8C5: 48:203104213 F0 01         u  00 0A  3 730      
    mov [rbp-64] (o),rcx                  ;#0044F8CB: 48:211115 C0               vu 00 22  1 732      
    mov r15,h4                            ;#0044F8CF: 49:277 0000000000000040    uv 8000 00  1 733      
    cmp rdx,r15                           ;#0044F8D9: 4C:071372                  uv 00 8004  1 734 8000   
    jle #0044F943                         ;#0044F8DC: 176 65                     v  00 00  1 734      
    sub qword[rbx+rdx*4-16],1             ;#0044F8DE: 48:203154223 F0 01         u  00 0C  3 735      
    jne #0044F943                         ;#0044F8E4: 165 5D                     v  00 00  1 737      
    call #004422DA (:%pDealloc)           ;#0044F8E6: 350 EF29FFFF               v  00 00  1 738      
    jmp #0044F943                         ;#0044F8EB: 353 56                     v  00 00  1 739      
;   690                     else
;   691                         o = args[nxt]
    mov rdi,[rbp-40] (nxt)                ;#0044F8ED: 48:213175 D8               uv 80 20  1 740      
    lea rcx,[rbp-64] (o)                  ;#0044F8F1: 48:215115 C0               vu 02 20  1 740      
    mov rsi,[rbp-8] (args)                ;#0044F8F5: 48:213165 F8               uv 40 20  1 741      
    mov rdx,194                           ;#0044F8F9: 48:307302 C2000000         vu 04 00  1 741      
    call #00441675 (:%pSubse1)            ;#0044F900: 350 701DFFFF               v  00 00  1 742      
;   692                         if not atom(o) then
    mov rax,[rbp-64] (o)                  ;#0044F905: 48:213105 C0               uv 01 20  1 743      
    mov r15,h4                            ;#0044F909: 49:277 0000000000000040    vu 8000 00  1 743      
    cmp rax,r15                           ;#0044F913: 4C:071370                  uv 00 8001  1 744      
    jl #0044F943                          ;#0044F916: 174 2B                     v  00 00  1 744      
    cmp byte[rbx+rax*4-1],#12             ;#0044F918: 200174203 FF 12            u  00 09  2 745      
    je #0044F943                          ;#0044F91D: 164 24                     v  00 00  1 746      
;   693                             o = 0
    mov rdx,[rbp-64] (o)                  ;#0044F91F: 48:213125 C0               uv 04 20  1 747      
    mov r15,h4                            ;#0044F923: 49:277 0000000000000040    vu 8000 00  1 747      
    cmp rdx,r15                           ;#0044F92D: 4C:071372                  uv 00 8004  1 748      
    mov [rbp-64] (o),rbx                  ;#0044F930: 48:211135 C0               vu 00 28  1 748      
    jle #0044F943                         ;#0044F934: 176 0D                     v  00 00  1 749      
    sub qword[rbx+rdx*4-16],1             ;#0044F936: 48:203154223 F0 01         u  00 0C  3 750      
    jne #0044F943                         ;#0044F93C: 165 05                     v  00 00  1 752      
    call #004422DA (:%pDealloc)           ;#0044F93E: 350 9729FFFF               v  00 00  1 753      
;   694                         end if
;   695                     end if
;   696                     r1 = sprintf2(o,fi,showplus,minfieldwidth,precision)
    mov rcx,31                            ;#0044F943: 48:307301 1F000000         uv 02 00  1 754      
    mov rdx,134                           ;#0044F94A: 48:307302 86000000         vu 04 00  1 754      
    call :%opFrame (sprintf2)             ;#0044F951: 350 852FFFFF               v  00 00  1 755      
    mov rdi,[rbp+40] (prevebp)            ;#0044F956: 48:213175 28               uv 80 20  1 756      
    mov rax,[rdi-64]                      ;#0044F95A: 48:213107 C0               uv 01 80  1 759 80 *80*
    xor rbx,rbx                           ;#0044F95E: 48:061333                  vu 08 08  1 759      
    mov r15,h4                            ;#0044F961: 49:277 0000000000000040    uv 8000 00  1 760      
    cmp rax,r15                           ;#0044F96B: 4C:071370                  uv 00 8001  1 761 8000   
    jl #0044F97B                          ;#0044F96E: 174 0B                     v  00 00  1 761      
    add qword[rbx+rax*4-16],1             ;#0044F970: 48:203104203 F0 01         u  00 09  3 762      
    cmp eax,201                           ;#0044F976: 075 C9000000               vu 00 01  1 764      
    mov [rbp] (pf),rax                    ;#0044F97B: 48:211105 00               uv 00 21  1 765      
    mov rdi,[rbp+40] (prevebp)            ;#0044F97F: 48:213175 28               vu 80 20  1 765      
    mov rax,[rdi-24]                      ;#0044F983: 48:213107 E8               uv 01 80  1 768    *80*
    mov [rbp-8] (charflag),rax            ;#0044F987: 48:211105 F8               uv 00 21  1 769 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044F98B: 48:213175 28               vu 80 20  1 769      
    mov rax,[rdi-144]                     ;#0044F98F: 48:213207 70FFFFFF         uv 01 80  1 772    *80*
    mov [rbp-16] (showplus),rax           ;#0044F996: 48:211105 F0               uv 00 21  1 773 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044F99A: 48:213175 28               vu 80 20  1 773      
    mov rax,[rdi-160]                     ;#0044F99E: 48:213207 60FFFFFF         uv 01 80  1 776    *80*
    mov [rbp-24] (minfieldwidth),rax      ;#0044F9A5: 48:211105 E8               uv 00 21  1 777 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044F9A9: 48:213175 28               vu 80 20  1 777      
    mov rax,[rdi-168]                     ;#0044F9AD: 48:213207 58FFFFFF         uv 01 80  1 780    *80*
    mov [rbp-32] (precision),rax          ;#0044F9B4: 48:211105 E0               uv 00 21  1 781 01   
    mov qword[retaddr],#0044F9C5          ;#0044F9B8: 48:307105 20 C5F94400      vu 00 20  1 781      
    jmp #0044FD4F (code:sprintf2)         ;#0044F9C0: 351 8A030000               v  00 00  1 782      
    push rax                              ;#0044F9C5: 120                        uv 00 01  1 783      
    mov rcx,[rbp-56] (r1)                 ;#0044F9C6: 48:213115 C8               vu 02 20  1 783      
    mov r15,h4                            ;#0044F9CA: 49:277 0000000000000040    uv 8000 00  1 784      
    cmp rcx,r15                           ;#0044F9D4: 4C:071371                  uv 00 8002  1 785 8000   
    jle #0044F9E9                         ;#0044F9D7: 176 10                     v  00 00  1 785      
    sub qword[rbx+rcx*4-16],1             ;#0044F9D9: 48:203154213 F0 01         u  00 0A  3 786      
    jne #0044F9E9                         ;#0044F9DF: 165 08                     v  00 00  1 788      
    mov rdx,rcx                           ;#0044F9E1: 48:213321                  uv 04 02  1 789      
    call #004422DA (:%pDealloc)           ;#0044F9E4: 350 F128FFFF               v  00 00  1 789      
    pop dword[rbp-56] (r1)                ;#0044F9E9: 217105 C8                  np 00 20  3 790      
;   697                     if showcommas then -- ('f' only)
    mov rdi,[rbp-152] (showcommas)        ;#0044F9EC: 48:213275 68FFFFFF         uv 80 20  1 793      
    test rdi,rdi                          ;#0044F9F3: 48:205377                  uv 00 80  1 794 80   
    je #0044FB4A                          ;#0044F9F6: 017204 4E010000            v  00 00  1 794      
;   698                         showcommas = find('.',r1)
    mov rcx,7                             ;#0044F9FC: 48:307301 07000000         uv 02 00  1 795      
    mov rdx,75                            ;#0044FA03: 48:307302 4B000000         vu 04 00  1 795      
    call #004428DB (:%opFrame) (find)     ;#0044FA0A: 350 CC2EFFFF               v  00 00  1 796      
    mov qword[rbp] (x),46                 ;#0044FA0F: 48:307105 00 2E000000      uv 00 20  1 797      
    mov rdi,[rbp+40] (prevebp)            ;#0044FA17: 48:213175 28               vu 80 20  1 797      
    mov rax,[rdi-56]                      ;#0044FA1B: 48:213107 C8               uv 01 80  1 800    *80*
    xor rbx,rbx                           ;#0044FA1F: 48:061333                  vu 08 08  1 800      
    mov r15,h4                            ;#0044FA22: 49:277 0000000000000040    uv 8000 00  1 801      
    cmp rax,r15                           ;#0044FA2C: 4C:071370                  uv 00 8001  1 802 8000   
    jl #0044FA3C                          ;#0044FA2F: 174 0B                     v  00 00  1 802      
    add qword[rbx+rax*4-16],1             ;#0044FA31: 48:203104203 F0 01         u  00 09  3 803      
    cmp eax,200                           ;#0044FA37: 075 C8000000               vu 00 01  1 805      
    mov [rbp-8] (s),rax                   ;#0044FA3C: 48:211105 F8               uv 00 21  1 806      
    mov qword[retaddr],#0044FA4D          ;#0044FA40: 48:307105 20 4DFA4400      vu 00 20  1 806      
    jmp #0043DAD6 (code:find)             ;#0044FA48: 351 89E0FEFF               v  00 00  1 807      
    mov [rbp-152] (showcommas),rax        ;#0044FA4D: 48:211205 68FFFFFF         uv 00 21  1 808      
;   699                         if showcommas=0 then showcommas = length(r1)+1 end if
    cmp rax,0                             ;#0044FA54: 48:203370 00               vu 00 01  1 808      
    jne #0044FA8A                         ;#0044FA58: 165 30                     v  00 00  1 809      
    mov rsi,[rbp-56] (r1)                 ;#0044FA5A: 48:213165 C8               uv 40 20  1 810      
    mov rcx,[rbx+rsi*4-24]                ;#0044FA5E: 48:48:213114263 E8         uv 02 48  1 813 40 *40*
    mov [rbp-208] (symtab[228]),rcx       ;#0044FA64: 48:211215 30FFFFFF         uv 00 22  1 814 02   
    add rcx,1                             ;#0044FA6B: 48:203301 01               vu 02 02  1 814      
    mov rdx,rcx                           ;#0044FA6F: 48:213321                  uv 04 02  1 815      
    mov [rbp-152] (showcommas),rcx        ;#0044FA72: 48:211215 68FFFFFF         vu 00 22  1 815      
    shl rdx,1                             ;#0044FA79: 48:321342                  u  04 04  1 816      
    jno #0044FA8A                         ;#0044FA7C: 161 0C                     v  00 00  1 816      
    lea rdi,[rbp-152] (showcommas)        ;#0044FA7E: 48:215275 68FFFFFF         uv 80 20  1 817      
    call #00442DA9 (:%pAddiii)            ;#0044FA85: 350 1F33FFFF               v  00 00  1 817      
;   700                         while showcommas>4 do
    mov rdi,[rbp-152] (showcommas)        ;#0044FA8A: 48:213275 68FFFFFF         uv 80 20  1 818      
    cmp rdi,4                             ;#0044FA91: 48:203377 04               uv 00 80  1 819 80   
    jle #0044FB4A                         ;#0044FA95: 017216 AF000000            v  00 00  1 819      
;   701                             showcommas -= 3
    sub rdi,3                             ;#0044FA9B: 48:203357 03               uv 80 80  1 820      
    mov rdx,rdi                           ;#0044FA9F: 48:213327                  uv 04 80  1 821 80   
    mov [rbp-152] (showcommas),rdi        ;#0044FAA2: 48:211275 68FFFFFF         vu 00 A0  1 821      
    shl rdx,1                             ;#0044FAA9: 48:321342                  u  04 04  1 822      
    jno #0044FABA                         ;#0044FAAC: 161 0C                     v  00 00  1 822      
    lea rdi,[rbp-152] (showcommas)        ;#0044FAAE: 48:215275 68FFFFFF         uv 80 20  1 823      
    call #00442DA9 (:%pAddiii)            ;#0044FAB5: 350 EF32FFFF               v  00 00  1 823      
;   702                             r1 = r1[1..showcommas-1]&','&r1[showcommas..length(r1)]
    lea rdi,[rbp-200] (symtab[223])       ;#0044FABA: 48:215275 38FFFFFF         uv 80 20  1 824      
    mov rcx,[rbp-152] (showcommas)        ;#0044FAC1: 48:213215 68FFFFFF         vu 02 20  1 824      
    mov rax,qword[#00402030]              ;#0044FAC8: 48:213005 6125FBFF         uv 01 00  1 825      
    call #0043F4D8 (:%opSub)              ;#0044FACF: 350 04FAFEFF               v  00 00  1 825      
    lea rax,[rbp-240] (symtab[232])       ;#0044FAD4: 48:215205 10FFFFFF         uv 01 20  1 826      
    mov rdi,1                             ;#0044FADB: 48:307307 01000000         vu 80 00  1 826      
    mov rcx,[rbp-200] (symtab[223])       ;#0044FAE2: 48:213215 38FFFFFF         uv 02 20  1 827      
    mov rsi,[rbp-56] (r1)                 ;#0044FAE9: 48:213165 C8               vu 40 20  1 827      
    mov rdx,200                           ;#0044FAED: 48:307302 C8000000         uv 04 00  1 828      
    call #00441212 (:%pSubsss)            ;#0044FAF4: 350 1917FFFF               v  00 00  1 828      
    lea rax,[rbp-256] (symtab[237])       ;#0044FAF9: 48:215205 00FFFFFF         uv 01 20  1 829      
    mov rdi,[rbp-152] (showcommas)        ;#0044FB00: 48:213275 68FFFFFF         vu 80 20  1 829      
    mov rcx,-1                            ;#0044FB07: 48:307301 FFFFFFFF         uv 02 00  1 830      
    mov rsi,[rbp-56] (r1)                 ;#0044FB0E: 48:213165 C8               vu 40 20  1 830      
    mov rdx,200                           ;#0044FB12: 48:307302 C8000000         uv 04 00  1 831      
    call #00441212 (:%pSubsss)            ;#0044FB19: 350 F416FFFF               v  00 00  1 831      
    mov rcx,3                             ;#0044FB1E: 48:307301 03000000         uv 02 00  1 832      
    push #0044FB45                        ;#0044FB25: 150 45FB4400               vu 00 00  1 832      
    push qword[rbp-256] (symtab[237])     ;#0044FB2A: 377265 00FFFFFF            np 00 20  2 833      
    push qword[#004022A0]                 ;#0044FB30: 377065 6A27FBFF            np 00 00  2 835      
    push qword[rbp-240] (symtab[232])     ;#0044FB36: 377265 10FFFFFF            np 00 20  2 837      
    lea rax,[rbp-56] (r1)                 ;#0044FB3C: 48:215105 C8               uv 01 20  1 839      
    jmp #004402C2 (:%opConcatN)           ;#0044FB40: 351 7D07FFFF               v  00 00  1 839      
;   703                         end while
    jmp #0044FA8A                         ;#0044FB45: 351 40FFFFFF               v  00 00  1 840      
;   704                     end if
;   705                 end if
;   706                 minfieldwidth -= length(r1)
    lea rdi,[rbp-208] (symtab[228])       ;#0044FB4A: 48:215275 30FFFFFF         uv 80 20  1 841      
    mov rsi,[rbp-56] (r1)                 ;#0044FB51: 48:213165 C8               vu 40 20  1 841      
    mov rdx,200                           ;#0044FB55: 48:307302 C8000000         uv 04 00  1 842      
    call #0043F28D (:%opLen)              ;#0044FB5C: 350 2CF7FEFF               v  00 00  1 842      
    mov rax,[rbp-160] (minfieldwidth)     ;#0044FB61: 48:213205 60FFFFFF         uv 01 20  1 843      
    sub rax,rcx                           ;#0044FB68: 48:051310                  uv 01 03  1 844 01   
    mov rdx,rax                           ;#0044FB6B: 48:213320                  uv 04 01  1 845 01   
    mov [rbp-160] (minfieldwidth),rax     ;#0044FB6E: 48:211205 60FFFFFF         vu 00 21  1 845      
    shl rdx,1                             ;#0044FB75: 48:321342                  u  04 04  1 846      
    jno #0044FB86                         ;#0044FB78: 161 0C                     v  00 00  1 846      
    lea rdi,[rbp-160] (minfieldwidth)     ;#0044FB7A: 48:215275 60FFFFFF         uv 80 20  1 847      
    call #00442DA9 (:%pAddiii)            ;#0044FB81: 350 2332FFFF               v  00 00  1 847      
;   707                 if minfieldwidth>0 then
    cmp rax,0                             ;#0044FB86: 48:203370 00               uv 00 01  1 848      
    jle #0044FC93                         ;#0044FB8A: 017216 03010000            v  00 00  1 848      
;   708                     if zerofill then
    mov rdi,[rbp-128] (zerofill)          ;#0044FB90: 48:213175 80               uv 80 20  1 849      
    test rdi,rdi                          ;#0044FB94: 48:205377                  uv 00 80  1 850 80   
    je #0044FBEB                          ;#0044FB97: 164 52                     v  00 00  1 850      
;   709                         r1 = repeat('0',minfieldwidth)&r1
    lea rdi,[rbp-240] (symtab[232])       ;#0044FB99: 48:215275 10FFFFFF         uv 80 20  1 851      
    mov rax,48                            ;#0044FBA0: 48:307300 30000000         vu 01 00  1 851      
    mov rcx,[rbp-160] (minfieldwidth)     ;#0044FBA7: 48:213215 60FFFFFF         uv 02 20  1 852      
    call #0043B1E1 (:%opRepCh)            ;#0044FBAE: 350 2EB6FEFF               v  00 00  1 852      
    mov rsi,[rbp-56] (r1)                 ;#0044FBB3: 48:213165 C8               uv 40 20  1 853      
    mov r15,h4                            ;#0044FBB7: 49:277 0000000000000040    vu 8000 00  1 853      
    cmp rsi,r15                           ;#0044FBC1: 4C:071376                  uv 00 8040  1 854      
    jne #0044FBD2                         ;#0044FBC4: 165 0C                     v  00 00  1 854      
    mov rsi,200                           ;#0044FBC6: 48:307306 C8000000         uv 40 00  1 855      
    call #00442D75 (:%pUnassigned)        ;#0044FBCD: 350 A331FFFF               v  00 00  1 855      
    lea rdx,[rbp-56] (r1)                 ;#0044FBD2: 48:215125 C8               uv 04 20  1 856      
    lea rdi,[rbp-240] (symtab[232])       ;#0044FBD6: 48:215275 10FFFFFF         vu 80 20  1 856      
    lea rcx,[rbp-56] (r1)                 ;#0044FBDD: 48:215115 C8               uv 02 20  1 857      
    call #00440021 (:%opConcat)           ;#0044FBE1: 350 3B04FFFF               v  00 00  1 857      
    jmp #0044FC93                         ;#0044FBE6: 351 A8000000               v  00 00  1 858      
;   710                     elsif leftjustify then
    mov rax,[rbp-136] (leftjustify)       ;#0044FBEB: 48:213205 78FFFFFF         uv 01 20  1 859      
    test rax,rax                          ;#0044FBF2: 48:205300                  uv 00 01  1 860 01   
    je #0044FC46                          ;#0044FBF5: 164 4F                     v  00 00  1 860      
;   711                         r1 = r1&repeat(' ',minfieldwidth)
    lea rdi,[rbp-240] (symtab[232])       ;#0044FBF7: 48:215275 10FFFFFF         uv 80 20  1 861      
    mov rax,32                            ;#0044FBFE: 48:307300 20000000         vu 01 00  1 861      
    mov rcx,[rbp-160] (minfieldwidth)     ;#0044FC05: 48:213215 60FFFFFF         uv 02 20  1 862      
    call #0043B1E1 (:%opRepCh)            ;#0044FC0C: 350 D0B5FEFF               v  00 00  1 862      
    mov rdi,[rbp-56] (r1)                 ;#0044FC11: 48:213175 C8               uv 80 20  1 863      
    mov r15,h4                            ;#0044FC15: 49:277 0000000000000040    vu 8000 00  1 863      
    cmp rdi,r15                           ;#0044FC1F: 4C:071377                  uv 00 8080  1 864      
    jne #0044FC30                         ;#0044FC22: 165 0C                     v  00 00  1 864      
    mov rsi,200                           ;#0044FC24: 48:307306 C8000000         uv 40 00  1 865      
    call #00442D75 (:%pUnassigned)        ;#0044FC2B: 350 4531FFFF               v  00 00  1 865      
    lea rdx,[rbp-56] (r1)                 ;#0044FC30: 48:215125 C8               uv 04 20  1 866      
    lea rdi,[rbp-56] (r1)                 ;#0044FC34: 48:215175 C8               vu 80 20  1 866      
    lea rcx,[rbp-240] (symtab[232])       ;#0044FC38: 48:215215 10FFFFFF         uv 02 20  1 867      
    call #00440021 (:%opConcat)           ;#0044FC3F: 350 DD03FFFF               v  00 00  1 867      
    jmp #0044FC93                         ;#0044FC44: 353 4D                     v  00 00  1 868      
;   712                     else
;   713                         r1 = repeat(' ',minfieldwidth)&r1
    lea rdi,[rbp-240] (symtab[232])       ;#0044FC46: 48:215275 10FFFFFF         uv 80 20  1 869      
    mov rax,32                            ;#0044FC4D: 48:307300 20000000         vu 01 00  1 869      
    mov rcx,[rbp-160] (minfieldwidth)     ;#0044FC54: 48:213215 60FFFFFF         uv 02 20  1 870      
    call #0043B1E1 (:%opRepCh)            ;#0044FC5B: 350 81B5FEFF               v  00 00  1 870      
    mov rsi,[rbp-56] (r1)                 ;#0044FC60: 48:213165 C8               uv 40 20  1 871      
    mov r15,h4                            ;#0044FC64: 49:277 0000000000000040    vu 8000 00  1 871      
    cmp rsi,r15                           ;#0044FC6E: 4C:071376                  uv 00 8040  1 872      
    jne #0044FC7F                         ;#0044FC71: 165 0C                     v  00 00  1 872      
    mov rsi,200                           ;#0044FC73: 48:307306 C8000000         uv 40 00  1 873      
    call #00442D75 (:%pUnassigned)        ;#0044FC7A: 350 F630FFFF               v  00 00  1 873      
    lea rdx,[rbp-56] (r1)                 ;#0044FC7F: 48:215125 C8               uv 04 20  1 874      
    lea rdi,[rbp-240] (symtab[232])       ;#0044FC83: 48:215275 10FFFFFF         vu 80 20  1 874      
    lea rcx,[rbp-56] (r1)                 ;#0044FC8A: 48:215115 C8               uv 02 20  1 875      
    call #00440021 (:%opConcat)           ;#0044FC8E: 350 8E03FFFF               v  00 00  1 875      
;   714                     end if
;   715                 end if
;   716                 result &= r1
    mov rax,[rbp-56] (r1)                 ;#0044FC93: 48:213105 C8               uv 01 20  1 876      
    mov r15,h4                            ;#0044FC97: 49:277 0000000000000040    vu 8000 00  1 876      
    cmp rax,r15                           ;#0044FCA1: 4C:071370                  uv 00 8001  1 877      
    jne #0044FCB2                         ;#0044FCA4: 165 0C                     v  00 00  1 877      
    mov rsi,200                           ;#0044FCA6: 48:307306 C8000000         uv 40 00  1 878      
    call #00442D75 (:%pUnassigned)        ;#0044FCAD: 350 C330FFFF               v  00 00  1 878      
    lea rdx,[rbp-48] (result)             ;#0044FCB2: 48:215125 D0               uv 04 20  1 879      
    lea rdi,[rbp-48] (result)             ;#0044FCB6: 48:215175 D0               vu 80 20  1 879      
    lea rcx,[rbp-56] (r1)                 ;#0044FCBA: 48:215115 C8               uv 02 20  1 880      
    call #00440021 (:%opConcat)           ;#0044FCBE: 350 5E03FFFF               v  00 00  1 880      
;   717                 nxt += 1
    mov rdi,[rbp-40] (nxt)                ;#0044FCC3: 48:213175 D8               uv 80 20  1 881      
    add rdi,1                             ;#0044FCC7: 48:203307 01               uv 80 80  1 882 80   
    mov rdx,rdi                           ;#0044FCCB: 48:213327                  uv 04 80  1 883 80   
    mov [rbp-40] (nxt),rdi                ;#0044FCCE: 48:211175 D8               vu 00 A0  1 883      
    shl rdx,1                             ;#0044FCD2: 48:321342                  u  04 04  1 884      
    jno #0044FD1C                         ;#0044FCD5: 161 45                     v  00 00  1 884      
    lea rdi,[rbp-40] (nxt)                ;#0044FCD7: 48:215175 D8               uv 80 20  1 885      
    call #00442DA9 (:%pAddiii)            ;#0044FCDB: 350 C930FFFF               v  00 00  1 885      
;   718             end if
    jmp #0044FD1C                         ;#0044FCE0: 353 3A                     v  00 00  1 886      
;   719         else
;   720 --puts(1,"?{result,fi}\n")
;   721 --?{result,fi}
;   722             result &= fi
    lea rdx,[rbp-48] (result)             ;#0044FCE2: 48:215125 D0               uv 04 20  1 887      
    lea rdi,[rbp-48] (result)             ;#0044FCE6: 48:215175 D0               vu 80 20  1 887      
    lea rcx,[rbp-24] (fi)                 ;#0044FCEA: 48:215115 E8               uv 02 20  1 888      
    xor rax,rax                           ;#0044FCEE: 48:061300                  vu 01 01  1 888      
    call #0043FC15 (:%opApnd)             ;#0044FCF1: 350 1FFFFEFF               v  00 00  1 889      
    mov rcx,[rbp-48] (result)             ;#0044FCF6: 48:213115 D0               uv 02 20  1 890      
    mov r15,h4                            ;#0044FCFA: 49:277 0000000000000040    vu 8000 00  1 890      
    cmp rcx,r15                           ;#0044FD04: 4C:071371                  uv 00 8002  1 891      
    jl #0044FD10                          ;#0044FD07: 174 07                     v  00 00  1 891      
    cmp byte[rbx+rcx*4-1],#82             ;#0044FD09: 200174213 FF 82            u  00 0A  2 892      
    je #0044FD1C                          ;#0044FD0E: 164 0C                     v  00 00  1 893      
    mov rcx,199                           ;#0044FD10: 48:307301 C7000000         uv 02 00  1 894      
    call #00442A58 (:%opTchkFail)         ;#0044FD17: 350 3C2DFFFF               v  00 00  1 894      
;   723 --?result
;   724         end if
;   725         i += 1
    mov rsi,[rbp-16] (i)                  ;#0044FD1C: 48:213165 F0               uv 40 20  1 895      
    add rsi,1                             ;#0044FD20: 48:203306 01               uv 40 40  1 896 40   
    mov rdx,rsi                           ;#0044FD24: 48:213326                  uv 04 40  1 897 40   
    mov [rbp-16] (i),rsi                  ;#0044FD27: 48:211165 F0               vu 00 60  1 897      
    shl rdx,1                             ;#0044FD2B: 48:321342                  u  04 04  1 898      
    jno #0044E58D                         ;#0044FD2E: 017201 59E8FFFF            v  00 00  1 898      
    lea rdi,[rbp-16] (i)                  ;#0044FD34: 48:215175 F0               uv 80 20  1 899      
    call #00442DA9 (:%pAddiii)            ;#0044FD38: 350 6C30FFFF               v  00 00  1 899      
;   726     end while
    jmp #0044E58D                         ;#0044FD3D: 351 4BE8FFFF               v  00 00  1 900      
;   727 --DEV this should be a warning??? (Interpret mode only!)
;   728 --  if not atom(args) and nxt<=length(args) then
;   729 ----/**/    #ilASM{ mov al,105                              -- Phix
;   730 ----!/**/           xor edi,edi         -- ep1 unused       -- Phix
;   731 ----!/**/           xor esi,esi         -- ep2 unused       -- Phix
;   732 ----/**/            call :%pRTErn }     -- fatal error      -- Phix
;   733 ----/**/                                            --/*    -- Phix
;   734 --      puts(1,"not enough format strings to print data\n") -- RDS
;   735 --      if getc(0) then end if                              -- RDS
;   736 --      abort(1)                                            -- RDS --*/
;   737 --  end if
;   738     return result
    mov rax,[rbp-48] (result)             ;#0044FD42: 48:213105 D0               uv 01 20  1 901      
    mov [rbp-48] (result),rbx             ;#0044FD46: 48:211135 D0               vu 00 28  1 901      
    jmp #0044298D (:%opRetf)              ;#0044FD4A: 351 3E2CFFFF               v  00 00  1 902      
;   739 end function
;   740 
;   741 --DEV move this (once newEmit is done) [better yet put itin the optable]
;   742 -- note: printf is now defined in pfileioN.e
;   743 global procedure printf(integer fn, sequence format, 
;   744 --/**/                              object args={}) --/*
    mov rsi,[rbp-16] (args)               ;#00451A31: 48:213165 F0               uv 40 20  1   1      
    mov r15,h4                            ;#00451A35: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#00451A3F: 4C:071376                  uv 00 8040  1   2      
    jne #00451A5A                         ;#00451A42: 165 16                     v  00 00  1   2      
    mov rsi,qword[#004022C8]              ;#00451A44: 48:213065 7D08FBFF         uv 40 00  1   3      
    mov [rbp-16] (args),rsi               ;#00451A4B: 48:211165 F0               uv 00 60  1   4 40   
    add qword[rbx+rsi*4-16],1             ;#00451A4F: 48:203104263 F0 01         u  00 48  3   6    *40*
    cmp eax,233                           ;#00451A55: 075 E9000000               vu 00 01  1   8      
;   745                                     object args)    --*/
;   746     puts(fn,sprintf(format,args))
    mov rcx,33                            ;#00451A5A: 48:307301 21000000         uv 02 00  1   9      
    mov rdx,89                            ;#00451A61: 48:307302 59000000         vu 04 00  1   9      
    call #004428DB (:%opFrame) (sprintf)  ;#00451A68: 350 6E0EFFFF               v  00 00  1  10      
    mov rdi,[rbp+40] (prevebp)            ;#00451A6D: 48:213175 28               uv 80 20  1  11      
    mov rax,[rdi-8]                       ;#00451A71: 48:213107 F8               uv 01 80  1  14 80 *80*
    xor rbx,rbx                           ;#00451A75: 48:061333                  vu 08 08  1  14      
    mov r15,h4                            ;#00451A78: 49:277 0000000000000040    uv 8000 00  1  15      
    cmp rax,r15                           ;#00451A82: 4C:071370                  uv 00 8001  1  16 8000   
    jl #00451A92                          ;#00451A85: 174 0B                     v  00 00  1  16      
    add qword[rbx+rax*4-16],1             ;#00451A87: 48:203104203 F0 01         u  00 09  3  17      
    cmp eax,239                           ;#00451A8D: 075 EF000000               vu 00 01  1  19      
    mov [rbp] (format),rax                ;#00451A92: 48:211105 00               uv 00 21  1  20      
    mov rdi,[rbp+40] (prevebp)            ;#00451A96: 48:213175 28               vu 80 20  1  20      
    mov rax,[rdi-16]                      ;#00451A9A: 48:213107 F0               uv 01 80  1  23    *80*
    xor rbx,rbx                           ;#00451A9E: 48:061333                  vu 08 08  1  23      
    mov r15,h4                            ;#00451AA1: 49:277 0000000000000040    uv 8000 00  1  24      
    cmp rax,r15                           ;#00451AAB: 4C:071370                  uv 00 8001  1  25 8000   
    jl #00451ABB                          ;#00451AAE: 174 0B                     v  00 00  1  25      
    add qword[rbx+rax*4-16],1             ;#00451AB0: 48:203104203 F0 01         u  00 09  3  26      
    cmp eax,240                           ;#00451AB6: 075 F0000000               vu 00 01  1  28      
    mov [rbp-8] (args),rax                ;#00451ABB: 48:211105 F8               uv 00 21  1  29      
    mov qword[retaddr],#00451ACC          ;#00451ABF: 48:307105 20 CC1A4500      vu 00 20  1  29      
    jmp #0044E450 (code:sprintf)          ;#00451AC7: 351 84C9FFFF               v  00 00  1  30      
    push rax                              ;#00451ACC: 120                        uv 00 01  1  31      
    mov rcx,[rbp-24] (symtab[241])        ;#00451ACD: 48:213115 E8               vu 02 20  1  31      
    mov r15,h4                            ;#00451AD1: 49:277 0000000000000040    uv 8000 00  1  32      
    cmp rcx,r15                           ;#00451ADB: 4C:071371                  uv 00 8002  1  33 8000   
    jle #00451AF0                         ;#00451ADE: 176 10                     v  00 00  1  33      
    sub qword[rbx+rcx*4-16],1             ;#00451AE0: 48:203154213 F0 01         u  00 0A  3  34      
    jne #00451AF0                         ;#00451AE6: 165 08                     v  00 00  1  36      
    mov rdx,rcx                           ;#00451AE8: 48:213321                  uv 04 02  1  37      
    call #004422DA (:%pDealloc)           ;#00451AEB: 350 EA07FFFF               v  00 00  1  37      
    pop dword[rbp-24] (symtab[241])       ;#00451AF0: 217105 E8                  np 00 20  3  38      
    mov rax,[rbp] (fn)                    ;#00451AF3: 48:213105 00               uv 01 20  1  41      
    mov rdx,[rbp-24] (symtab[241])        ;#00451AF7: 48:213125 E8               vu 04 20  1  41      
    call #0043E218 (:%opPuts)             ;#00451AFB: 350 18C7FEFF               v  00 00  1  42      
    jmp #0044298D (:%opRetf)              ;#00451B00: 351 880EFFFF               v  00 00  1  43      
;   747 end procedure
;   748 
;   749 
;C:\Program Files (x86)\Phix\builtins\VM\pUnassigned.e:
;======================================================
;     1 --
;     2 -- pUnassigned.e
;     3 --
;     4 --  Temp. (move to pFEH?)
;     5 
;     6 include builtins\VM\puts1.e         -- low-level console i/o
;     7 --DEV?
;     8 --include builtins\VM\pStack.e
;     9 
;    10 constant eBadRetf = "eBadRetf called, return address is #\n"
;    11 
;    12 --#ilASM{ jmp :%opRetf
;    13 #ilASM{ jmp :!opCallOnceYeNot
                jmp :!opCallOnceYeNot     ;#00442D70: 351 6D000000               v  00 00  1   1      
;    14 
;    15     :%pUnassigned   -- aka e92vhnbaavesiesp
;    16 -----------------
;    17         -- esi is var no for e92,
;    18         -- edi is var no for type check error 
;    19         -- [ie: if [esi]==h4 then (jz/jnz valid)
;    20         --          varname(esi)&" has not been assigned a value"
;    21         --      else
;    22         --          "type check error:"&varname(edi)&" is "&sprint([edi])
;    23         --           (in which case [esi] and [edi] should be the same, btw)
;    24         --      end if]
;    25     [32]
;    26         pop edx
;    27     [64]
;    28         pop rdx
                pop rdx                   ;#00442D75: 48:132                     uv 04 00  1   2      
;    29     []
;    30         jne @f
                jne #00442D84             ;#00442D77: 165 0B                     v  00 00  1   2      
;    31             -- [var]==h4, esi is varno
;    32             mov al,92   -- e92vhnbaav(esi)
                    mov al,92             ;#00442D79: 260 5C                     uv 01 00  1   3      
;    33             sub edx,1
                    sub edx,1             ;#00442D7B: 203352 01                  vu 04 04  1   3      
;    34             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00442D7E: 351 E3000000               v  00 00  1   4      
;    35             int3
                    int3                  ;#00442D83: 314                        np 00 00 13   5      
;    36       @@:
;    37             -- type check error (edi is varno)
;    38 --          mov al,110  -- e110tce(ecx)
;    39             mov al,1    -- e01tcf(ecx)
                    mov al,1              ;#00442D84: 260 01                     uv 01 00  1  18      
;    40             mov ecx,edi -- DEV (minor)
                    mov ecx,edi           ;#00442D86: 213317                     vu 02 80  1  18      
;    41             sub edx,1
                    sub edx,1             ;#00442D88: 203352 01                  uv 04 04  1  19      
;    42             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00442D8B: 351 D6000000               v  00 00  1  19      
;    43             int3
                    int3                  ;#00442D90: 314                        np 00 00 13  20      
;    44 
;    45 --/*
;    46   @@:
;    47     sub eax,1
;    48     mov [ep1],esi
;    49     mov [era],eax
;    50     mov al,92
;    51     jmp enumbset
;    52 
;    53     trc e92movti
;    54 e92movti:
;    55 ;;!!    trc e92movti    // wrecks the jz below!
;    56 ;   reg = loadReg(p2)                               -- mov reg,[p2]
;    57 ;   cmp_h4(reg)                                     -- cmp reg,h4
;    58 ;   storeReg(reg,p1,1,0)                            -- mov [p1],reg
;    59 ;   emitHex2(jl_rel8,?5)                            -- jl @f
;    60 ;   mov esi,p2 (if reg can be = h4)                 276         BE imm32        mov esi,imm32
;    61 ;   mov edx,p1                                      272         BA imm32        mov edx,imm32
;    62 ;   call e92movti                                   350         E8 rel32        call rel32
;    63 
;    64 ;   mov eax,[esp]
;    65 ;   mov esi,[eax-21]
;    66 ;   jz e92vhnbaavesiesp     ; variable has not been assigned a value...
;    67     pop eax
;    68     jz @b                   ; variable has not been assigned a value...
;    69     ;
;    70     ; else type check error:
;    71     ;
;    72 ;   mov edx,[eax-11]
;    73 ;   sub eax,1
;    74     mov [ep1],edx
;    75     mov [era],eax
;    76 ;if newEBP (this may be a better idea!)
;    77 ;   mov al,1    -- (old code)
;    78 ;else
;    79     mov al,110 -- (old code)
;    80 ;end if
;    81     jmp enumbset
;    82 --*/
;    83     :%pBadRetf
;    84         [32]
;    85             mov edi,[eBadRetf]          -- "eBadRetf called, return address is #"
;    86             call :%puts1
;    87             mov edx,[esp]
;    88             push 1                      -- cr
;    89             call :%puthex32
;    90         [64]
;    91             mov rdi,[eBadRetf]          -- "eBadRetf called, return address is #"
                    mov rdi,[#004021B0] (eBadRetf)  ;#00442D91: 48:213075 18F4FBFF         uv 80 00  1  33      
;    92             call :%puts1
                    call #00442B92 (:%puts1)  ;#00442D98: 350 F5FDFFFF               v  00 00  1  33      
;    93             mov rdx,[rsp]
                    mov rdx,[rsp]         ;#00442D9D: 48:213024044               uv 04 10  1  34      
;    94             push 1                      -- cr
                    push 1                ;#00442DA1: 152 01                     vu 00 00  1  34      
;    95             call :%puthex64
                    call #00442C4C (:%puthex64)  ;#00442DA3: 350 A4FEFFFF               v  00 00  1  35      
;    96         []
;    97             int3
                    int3                  ;#00442DA8: 314                        np 00 00 13  36      
;    98 
;    99     :%pAddiii
;   100     [32]
;   101         -- [edi] has blown 31-bit int; store as float and typecheck
;   102         pop edx
;   103         fild dword[edi]
;   104         sub edx,1
;   105         mov [edi],ebx
;   106         -- edi is ep2, edx is era
;   107         mov ecx,edi
;   108     [64]
;   109         -- [rdi] has blown 63-bit int; store as float and typecheck
;   110         pop rdx
                pop rdx                   ;#00442DA9: 48:132                     uv 04 00  1  49      
;   111         fild qword[rdi]
                fild qword[rdi]           ;#00442DAB: 337057                     np 00 80  3  50      
;   112         sub rdx,1
                sub rdx,1                 ;#00442DAD: 48:203352 01               uv 04 04  1  53      
;   113         mov [rdi],rbx
                mov [rdi],rbx             ;#00442DB1: 48:211037                  vu 00 88  1  53      
;   114         -- rdi is ep2, rdx is era
;   115         mov rcx,rdi
                mov rcx,rdi               ;#00442DB4: 48:213317                  uv 02 80  1  54      
;   116     []
;   117         call :%pStoreFlt
                call #004421B0 (:%pStoreFlt)  ;#00442DB7: 350 F4F3FFFF               v  00 00  1  54      
;   118         mov al,110  -- e110tce(ecx)
                mov al,110                ;#00442DBC: 260 6E                     uv 01 00  1  55      
;   119 --      mov al,1    -- e01tcf(ecx)
;   120     [32]
;   121         mov ecx,edi
;   122     [64]
;   123         mov rcx,rdi
                mov rcx,rdi               ;#00442DBE: 48:213317                  vu 02 80  1  55      
;   124     []
;   125         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#00442DC1: 351 A0000000               v  00 00  1  56      
;   126         int3
                int3                      ;#00442DC6: 314                        np 00 00 13  57      
;   127 
;   128     :%pDiviii
;   129         int3
                int3                      ;#00442DC7: 314                        np 00 00 13  70      
;   130 --  :%pRTErf
;   131 --      int3
;   132     :%pRTErn
;   133         -- error code in al,
;   134         -- ep1 in edi,
;   135         -- ep2 in esi
;   136         pop edx -- era
                pop rdx                   ;#00442DC8: 132                        uv 04 00  1  83      
;   137         sub edx,1
                sub edx,1                 ;#00442DC9: 203352 01                  uv 04 04  1  84 04   
;   138         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#00442DCC: 351 95000000               v  00 00  1  84      
;   139         int3
                int3                      ;#00442DD1: 314                        np 00 00 13  85      
;   140     :%pDiv0 
;   141 --      int3
;   142     :%e02atdb0
;   143 --      int3
;   144 --or
;   145 --!/*
;   146     [32]
;   147         pop edx
;   148 --      mov edi,ebp
;   149 --      mov esi,esp
;   150         mov al,2
;   151         add edx,-1
;   152     [64]
;   153         pop rdx
                pop rdx                   ;#00442DD2: 48:132                     uv 04 00  1  98      
;   154 --      mov rdi,rbp
;   155 --      mov rsi,rsp
;   156         mov al,2
                mov al,2                  ;#00442DD4: 260 02                     vu 01 00  1  98      
;   157         add rdx,-1
                add rdx,-1                ;#00442DD6: 48:203302 FF               uv 04 04  1  99      
;   158     []
;   159         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#00442DDA: 351 87000000               v  00 00  1  99      
;   160         int3
                int3                      ;#00442DDF: 314                        np 00 00 13 100      
;   161 --!*/
;   162 
;   163     :%e01tcfDivi2   -- (opDivi2)
;   164         int3
                int3                      ;#00442DE0: 314                        np 00 00 13 113      
;   165 --;calling convention:
;   166 --; mov eax,[p2]
;   167 --; mov edx,p1
;   168 --; sar eax,1
;   169 --; jnc @f
;   170 --; call :%e01tcfDivi2  -- type check error, <p1> is xxx.5
;   171     :%e01tcfediMul -- (opMuliii)
;   172         int3
                int3                      ;#00442DE1: 314                        np 00 00 13 126      
;   173 --;calling convention:
;   174 --; mov ecx,[p3]
;   175 --; mov eax,[p2]
;   176 --; imul ecx
;   177 --; mov edi,p1
;   178 --; mov ecx,edx
;   179 --; cdq ; eax-> edx:eax
;   180 --; cmp ecx,edx ; blown 32 bits?
;   181 --; je @f
;   182 --; call :%e01tcfediMul
;   183 --; mov esi,eax
;   184 --; shl esi,1
;   185 --; jo (call :%e01tcfediMul) ; blown 31 bits?
;   186 --; mov [edi],eax
;   187 
;   188     :!opCallOnceYeNot
;   189 -- (new error code)
;   190         int3
                int3                      ;#00442DE2: 314                        np 00 00 13 139      
;   191 
;   192       }
;   193 
    jmp #0044298D (:%opRetf)              ;#00442DE3: 351 A5FBFFFF               v  00 00  1 152      
;C:\Program Files (x86)\Phix\builtins\VM\puts1.e:
;================================================
;     1 --
;     2 -- puts1.e
;     3 -- =======
;     4 --
;     5 --  Low-level simplistic console i/o
;     6 --
;     7 --  These routines exist so that we can output some simple console messages before all of
;     8 --  pHeap.e/pStack.e/pprntfN.e/psprintN.e/pfileioN.e/pMath.e/pSubseN.e/pSubssN.e/pJcc.e
;     9 --  pRmdr.e/pRepeN.e/pRepsN.e/pApnd.e etc are working or if they get broken in some way.
;    10 --
;    11 --  See ..\puts1h.e for hll wrapper routines/hints on invoking these from inline assembly.
;    12 --  Note that unlike this, ..\puts1h.e requires an explicit include statement before use.
;    13 --  Also note the original version of this file was deliberately split into puts1/puts1h
;    14 --  so that this can be put into the optable (:%labels only) and the latter left out.
;    15 --
;    16 --      in here         in puts1h.e
;    17 --      =======         ===========
;    18 --      :%puts1         puts1(s)        equivalent to     puts(1,s)
;    19 --                                                        puts(1,raw(edi|rdi)[1..$])
;    20 --      :%puts1ediesi                                     puts(1,*edi[1..esi])  -- (32-bit name)
;    21 --      :%puts1rdirsi                                     puts(1,*rdi[1..rsi])  -- (64-bit name)
;    22 --      :%puthex32a     puthex32(a)     equivalent to     printf(1,"%08x\n",{a})
;    23 --      :%puthex32                                        printf(1,"%08x\n",{edx|and_bits(rdx,#FFFFFFFF)})
;    24 --      :%puthex64                                        printf(1,"%08x\n",{edx:eax|rdx})
;    25 --      :%putsint       putsint(i)      equivalent to     printf(1,"%d\n",{i})
;    26 --                                                        printf(1,"%d\n",{edx|and_bits(rdx,#FFFFFFFF)})
;    27 --      :%getc0         getc0()         equivalent to     {} = getc(0), aka if getc(0) then end if
;    28 --
;    29 --  These routines are used by the likes of pFEH.e and pdiagN.e and therefore form part of
;    30 --  the runtime VM. That means they are always automatically available and further that an
;    31 --  explicit "include builtins\VM\puts1.e" may be quietly ignored when interpreting - any
;    32 --  changes may need a "p -cp" round before coming into effect. It may be easier to make a
;    33 --  copy of this that you can edit/test rather than edit/compile(/compile)/test, though I
;    34 --  would urge you to carefully rename all the global labels in the test copy.
;    35 --
;    36 --  This file was chosen for use in the first steps to getting the optable to work, and
;    37 --  also a key factor in deciding to use :!opCallOnceYeNot instead of :%opRetf/::fin.
;    38 --
;    39 
;    40 --/*
;    41 This will not work on RDS Eu/OpenEuphoria!!
;    42 --*/
;    43 
;    44 --include builtins\VM\pStack.e
;    45 include builtins\VM\pUnassigned.e   -- :!opCallOnceYeNot
;    46 
;    47 --#ilASM{ jmp :%opRetf
;    48 --#ilASM{ jmp :fin
;    49 #ilASM{ jmp :!opCallOnceYeNot
                jmp :!opCallOnceYeNot     ;#00442B8D: 351 50020000               v  00 00  1   1      
;    50 
;    51 --/*
;    52 procedure :%puts1(:%)
;    53 end procedure -- (for Edita/CtrlQ)
;    54 --*/
;    55       :%puts1
;    56 -------------
;    57         [32]
;    58             -- edi loaded
;    59             xor ebx,ebx
;    60             mov esi,[ebx+edi*4-12]          -- length
;    61             shl edi,2                       -- ref->raw
;    62 
;    63 --/*
;    64 procedure :%puts1ediesi(:%)
;    65 end procedure -- (for Edita/CtrlQ)
;    66 --*/
;    67       :%puts1ediesi     -- (edi=raw text, esi=length)
;    68 -------------------
;    69         [PE32]
;    70             push -11                        -- nStdHandle (p1) (-11=STD_OUTPUT_HANDLE)
;    71             call "kernel32.dll","GetStdHandle"
;    72             push ebx                        -- lpOverlapped (NULL)
;    73             push esp                        -- lpNumberOfBytesWritten
;    74             push esi                        -- nNumberOfBytesToWrite
;    75             push edi                        -- lpBuffer
;    76             push eax                        -- hFile,
;    77             call "kernel32.dll","WriteFile"
;    78         [ELF32]
;    79             mov eax,4               -- sys_write(ebx=int fd,ecx=char *buf,edx=int len)
;    80             mov edx,esi             -- length (p3)
;    81             mov ecx,edi             -- raw(hw) (p2)
;    82             mov ebx,1               -- stdout (p1)
;    83             int 0x80
;    84             xor ebx,ebx             -- (common requirement)
;    85 
;    86         [64]
;    87             -- rdi loaded
;    88             xor rbx,rbx
                    xor rbx,rbx           ;#00442B92: 48:061333                  uv 08 08  1   2      
;    89             mov rsi,[rbx+rdi*4-24]          -- length
                    mov rsi,[rbx+rdi*4-24]  ;#00442B95: 48:213164273 E8            uv 40 88  1   5 08 *08*
;    90             shl rdi,2
                    shl rdi,2             ;#00442B9A: 48:301347 02               u  80 80  1   6      
;    91 
;    92 --/*
;    93 procedure :%puts1rdirsi(:%)
;    94 end procedure -- (for Edita/CtrlQ)
;    95 --*/
;    96       :%puts1rdirsi     -- (rdi=raw text, rsi=length)
;    97 -------------------
;    98         [PE64]
;    99             mov rcx,rsp -- put 2 copies of rsp onto the stack...
                    mov rcx,rsp           ;#00442B9E: 48:213314                  vu 02 10  1   6      
;   100             push rsp
                    push rsp              ;#00442BA1: 48:124                     uv 00 10  1   7      
;   101             push rcx
                    push rcx              ;#00442BA3: 48:121                     vu 00 02  1   7      
;   102             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#00442BA5: 48:203314 08               uv 10 10  1   8      
;   103                         -- if on entry rsp was xxx8: both copies remain on the stack
;   104                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;   105                         -- obviously rsp is now xxx8, whatever alignment we started with
;   106             sub rsp,8*7                     -- 5 params and space for target of r9, plus align
                    sub rsp,56            ;#00442BA9: 48:203354 38               uv 10 10  1   9 10   
;   107             mov ecx,-11                     -- DWORD nStdHandle (p1) (--11=STD_OUTPUT_HANDLE)
                    mov ecx,-11           ;#00442BAD: 271 F5FFFFFF               vu 02 00  1   9      
;   108             call "kernel32.dll","GetStdHandle"
                    call [#004010B8] (GetStdHandle)  ;#00442BB2: 377025 00E5FBFF            np 00 00  2  10      
;   109             mov qword[rsp+4*8],rbx          -- LPOVERLAPPED lpOverlapped (p5) (rbx=NULL)
                    mov [rsp+32],rbx      ;#00442BB8: 48:211134044 20            uv 00 18  1  12      
;   110             lea r9,[rsp+5*8]                -- LPDWORD lpNumberOfBytesWritten (p4)
                    lea r9,[rsp+40]       ;#00442BBD: 4C:215114044 28            vu 200 10  1  12      
;   111             mov r8,rsi                      -- DWORD nNumberOfBytesToWrite (p3)
                    mov r8,rsi            ;#00442BC2: 4C:213306                  uv 100 40  1  13      
;   112             mov rdx,rdi                     -- LPCVOID lpBuffer (p2)
                    mov rdx,rdi           ;#00442BC5: 48:213327                  vu 04 80  1  13      
;   113             mov rcx,rax                     -- HANDLE hFile (p1)
                    mov rcx,rax           ;#00442BC8: 48:213310                  uv 02 01  1  14      
;   114             call "kernel32.dll","WriteFile"
                    call [#00401150] (WriteFile)  ;#00442BCB: 377025 7FE5FBFF            np 00 00  2  15      
;   115 --          add rsp,8*7
;   116 --          pop rsp     -- restore, equivalent to rsp += (either #08 or #10)
;   117             mov rsp,[rsp+8*7]   -- equivalent to add/pop
                    mov rsp,[rsp+56]      ;#00442BD1: 48:213144044 38            uv 10 10  1  17      
;   118         [ELF64]
;   119             mov rdx,rsi             -- length(hw)
;   120             mov rsi,rdi             -- raw(hw)
;   121             mov rdi,1               -- stdout
;   122             mov rax,1               -- sys_write(rdi=unsigned int fd,rsi=const char *buf,rdx=size_t count)
;   123             syscall
;   124         []
;   125             ret
                    ret                   ;#00442BD6: 303                        np 00 00  2  18      
;   126 
;   127 --/*
;   128 procedure :%puthex32a(:%)
;   129 end procedure -- (for Edita/CtrlQ)
;   130 --*/
;   131     :%puthex32a
;   132 ---------------
;   133         [32]
;   134             -- edx loaded (with an integer or phix atom)
;   135             xor ebx,ebx
;   136             sub esp,16      -- build "00000000\r\n" on the stack
;   137             cmp edx,h4
;   138             jl @f
;   139                 fld qword[ebx+edx*4]
;   140                 fistp qword[esp]
;   141                 mov edx,[esp]
;   142           @@:
;   143             mov edi,esp
;   144             jmp @f
;   145         [64]
;   146             -- rdx loaded (with an integer or phix atom)
;   147             xor rbx,rbx
                    xor rbx,rbx           ;#00442BD7: 48:061333                  uv 08 08  1  20      
;   148             mov r15,h4
                    mov r15,h4            ;#00442BDA: 49:277 0000000000000040    vu 8000 00  1  20      
;   149             sub rsp,16      -- ditto (8 digits), also keeps stack (mis)aligned
                    sub rsp,16            ;#00442BE4: 48:203354 10               uv 10 10  1  21      
;   150             cmp rdx,r15
                    cmp rdx,r15           ;#00442BE8: 49:073327                  vu 00 8004  1  21      
;   151             jl @f
                    jl #00442BF7          ;#00442BEB: 174 0A                     v  00 00  1  22      
;   152                 fld tbyte[rbx+rdx*4]
                        fld tbyte[rbx+rdx*4]  ;#00442BED: 333054223                  np 00 0C  3  23      
;   153                 fistp qword[rsp]
                        fistp qword[rsp]  ;#00442BF0: 337074044                  np 00 10  6  26      
;   154                 mov rdx,[rsp]
                        mov rdx,[rsp]     ;#00442BF3: 48:213024044               uv 04 10  1  32      
;   155           @@:
;   156             mov rdi,rsp
                    mov rdi,rsp           ;#00442BF7: 48:213374                  vu 80 10  1  32      
;   157             jmp @f
                    jmp #00442C00         ;#00442BFA: 353 04                     v  00 00  1  33      
;   158         []
;   159 
;   160 --/*
;   161 procedure :%puthex32(:%)
;   162 end procedure -- (for Edita/CtrlQ)
;   163 --*/
;   164     :%puthex32
;   165 --------------
;   166         [32]
;   167             -- edx loaded (with an absolute 32bit value)
;   168             sub esp,16      -- build "00000000\r\n" on the stack
;   169           @@:
;   170             mov edi,esp
;   171         [64]
;   172             -- rdx loaded (but only the edx part gets printed)
;   173             sub rsp,16      -- ditto (8 digits), also keeps stack (mis)aligned
                    sub rsp,16            ;#00442BFC: 48:203354 10               uv 10 10  1  34      
;   174           @@:
;   175             mov rdi,rsp
                    mov rdi,rsp           ;#00442C00: 48:213374                  uv 80 10  1  35 10   
;   176         []
;   177             mov ecx,8
                    mov ecx,8             ;#00442C03: 271 08000000               vu 02 00  1  35      
;   178           ::loop8
;   179             xor eax,eax
                    xor eax,eax           ;#00442C08: 061300                     uv 01 01  1  36      
;   180             shld eax,edx,4  -- peel off top nibble
                    shld rax,edx,4        ;#00442C0A: 017244320 04               np 05 05  4  37      
;   181             shl edx,4       -- discard ""/get next nibble into place
                    shl edx,4             ;#00442C0E: 301342 04                  u  04 04  1  41      
;   182             add al,0x37     -- + 'A'-9
                    add al,55             ;#00442C11: 200300 37                  vu 01 01  1  41      
;   183             cmp al,0x41     -- cmp 'A'
                    cmp al,65             ;#00442C14: 200370 41                  uv 00 01  1  42      
;   184             jge @f
                    jge #00442C1C         ;#00442C17: 175 03                     v  00 00  1  42      
;   185                 sub al,7    -- map '7'..'@' to '0'..'9' (or something like that)
                        sub al,7          ;#00442C19: 200350 07                  uv 01 01  1  43      
;   186           @@:
;   187             stosb
                    stosb                 ;#00442C1C: 252                        np 80 81  3  44      
;   188             sub ecx,1
                    sub ecx,1             ;#00442C1D: 203351 01                  uv 02 02  1  47      
;   189             jnz :loop8
                    jnz #00442C08         ;#00442C20: 165 E6                     v  00 00  1  47      
;   190             mov word[edi],0x0D0A
                    mov word[rdi], word 3338  ;#00442C22: 146:307007 0A0D            uv 00 80  1  48      
;   191         [32]
;   192             mov edi,esp
;   193             mov esi,10
;   194             cmp dword[esp+20],0 -- putcr
;   195             jne @f
;   196                 mov esi,8
;   197           @@:
;   198             call :%puts1ediesi
;   199             add esp,16
;   200             ret 4
;   201         [64]
;   202             mov rdi,rsp
                    mov rdi,rsp           ;#00442C27: 48:213374                  vu 80 10  1  48      
;   203             mov rsi,10
                    mov rsi,10            ;#00442C2A: 48:307306 0A000000         uv 40 00  1  49      
;   204             cmp qword[rsp+24],0
                    cmp qword[rsp+24],0   ;#00442C31: 48:203174044 18 00         u  00 10  2  50      
;   205             jne @f
                    jne #00442C40         ;#00442C37: 165 07                     v  00 00  1  51      
;   206                 mov rsi,8
                        mov rsi,8         ;#00442C39: 48:307306 08000000         uv 40 00  1  52      
;   207           @@:
;   208             call :%puts1rdirsi
                    call #00442B9E (:%puts1rdirsi)  ;#00442C40: 350 59FFFFFF               v  00 00  1  52      
;   209             add rsp,16
                    add rsp,16            ;#00442C45: 48:203304 10               uv 10 10  1  53      
;   210             ret 8
                    ret 8                 ;#00442C49: 302 0800                   np 00 00  3  54      
;   211         []
;   212 
;   213 --/*
;   214 procedure :%puthex64(:%)
;   215 end procedure -- (for Edita/CtrlQ)
;   216 --*/
;   217     :%puthex64
;   218 --------------
;   219         [32]    
;   220             -- edx:eax loaded (hi-dword in edx, lo-dword in eax)
;   221             sub esp,32
;   222             mov edi,esp
;   223             mov esi,16
;   224           ::loop16edxeax
;   225             xor ecx,ecx
;   226             shld ecx,edx,4  -- peel off top nibble
;   227             shld edx,eax,4  -- peel off top nibble
;   228             shl eax,4       -- discard ""/get next nibble into place
;   229             add cl,0x37     -- + 'A'-9
;   230             cmp cl,0x41     -- cmp 'A'
;   231             jge @f
;   232                 sub cl,7    -- map '7'..'@' to '0'..'9' (or something like that)
;   233           @@:
;   234             mov [edi],cl
;   235             add edi,1
;   236             sub esi,1
;   237             jnz :loop16edxeax
;   238             mov word[edi],0x0D0A
;   239             mov edi,esp
;   240             mov esi,18
;   241             cmp dword[esp+36],0
;   242             jne @f
;   243                 mov esi,16
;   244           @@:
;   245             call :%puts1ediesi
;   246             add esp,32
;   247             ret 4
;   248 
;   249         [64]
;   250             -- rdx loaded   -- (or, to show the lo-dword of rdx, aka edx, use :%puthex32)
;   251             sub rsp,32
                    sub rsp,32            ;#00442C4C: 48:203354 20               uv 10 10  1  57      
;   252             mov rdi,rsp
                    mov rdi,rsp           ;#00442C50: 48:213374                  uv 80 10  1  58 10   
;   253             mov rcx,16
                    mov rcx,16            ;#00442C53: 48:307301 10000000         vu 02 00  1  58      
;   254           ::loop16
;   255             xor rax,rax
                    xor rax,rax           ;#00442C5A: 48:061300                  uv 01 01  1  59      
;   256             shld rax,rdx,4  -- peel off top nibble
                    shld rax,rdx,4        ;#00442C5D: 48:017244320 04            np 05 05  4  60      
;   257             shl rdx,4       -- discard ""/get next nibble into place
                    shl rdx,4             ;#00442C62: 48:301342 04               u  04 04  1  64      
;   258             add al,0x37     -- + 'A'-9
                    add al,55             ;#00442C66: 200300 37                  vu 01 01  1  64      
;   259             cmp al,0x41     -- cmp 'A'
                    cmp al,65             ;#00442C69: 200370 41                  uv 00 01  1  65      
;   260             jge @f
                    jge #00442C71         ;#00442C6C: 175 03                     v  00 00  1  65      
;   261                 sub al,7    -- map '7'..'@' to '0'..'9' (or something like that)
                        sub al,7          ;#00442C6E: 200350 07                  uv 01 01  1  66      
;   262           @@:
;   263             stosb
                    stosb                 ;#00442C71: 252                        np 80 81  3  67      
;   264             sub rcx,1
                    sub rcx,1             ;#00442C72: 48:203351 01               uv 02 02  1  70      
;   265             jnz :loop16
                    jnz #00442C5A         ;#00442C76: 165 E2                     v  00 00  1  70      
;   266             mov word[rdi],0x0D0A
                    mov word[rdi], word 3338  ;#00442C78: 146:307007 0A0D            uv 00 80  1  71      
;   267             mov rdi,rsp
                    mov rdi,rsp           ;#00442C7D: 48:213374                  vu 80 10  1  71      
;   268             mov rsi,18
                    mov rsi,#12           ;#00442C80: 48:307306 12000000         uv 40 00  1  72      
;   269 --          cmp qword[rsp+24],0
;   270             cmp qword[rsp+40],0
                    cmp qword[rsp+40],0   ;#00442C87: 48:203174044 28 00         u  00 10  2  73      
;   271             jne @f
                    jne #00442C96         ;#00442C8D: 165 07                     v  00 00  1  74      
;   272                 mov rsi,16
                        mov rsi,16        ;#00442C8F: 48:307306 10000000         uv 40 00  1  75      
;   273           @@:
;   274             call :%puts1rdirsi
                    call #00442B9E (:%puts1rdirsi)  ;#00442C96: 350 03FFFFFF               v  00 00  1  75      
;   275             add rsp,32
                    add rsp,32            ;#00442C9B: 48:203304 20               uv 10 10  1  76      
;   276             ret 8
                    ret 8                 ;#00442C9F: 302 0800                   np 00 00  3  77      
;   277         []
;   278 
;   279 --/*
;   280 procedure :%putsint(:%)
;   281 end procedure -- (for Edita/CtrlQ)
;   282 --*/
;   283     :%putsint
;   284 -------------
;   285             -- eax loaded, putscr on stack
;   286             sub esp,16      -- build "[-]nnn\r\n" on the stack
                    sub esp,16            ;#00442CA2: 203354 10                  uv 10 10  1  80      
;   287             mov edi,esp
                    mov edi,esp           ;#00442CA5: 213374                     uv 80 10  1  81 10   
;   288             cmp eax,0
                    cmp eax,0             ;#00442CA7: 203370 00                  vu 00 01  1  81      
;   289             jge @f
                    jge #00442CB4         ;#00442CAA: 175 08                     v  00 00  1  82      
;   290                 neg eax
                        neg eax           ;#00442CAC: 367330                     np 01 01  1  83      
;   291                 mov byte[edi],'-'
                        mov [rdi], byte 45  ;#00442CAE: 306007 2D                  uv 00 80  1  84      
;   292                 add edi,1
                        add edi,1         ;#00442CB1: 203307 01                  vu 80 80  1  84      
;   293           @@:
;   294             mov ecx,1000000000  -- repeatedly divided by 10 until it is 1, as we get each digit.
                    mov ecx,1000000000    ;#00442CB4: 271 00CA9A3B               uv 02 00  1  85      
;   295             xor edx,edx         -- edx:=0
                    xor edx,edx           ;#00442CB9: 061322                     vu 04 04  1  85      
;   296             xor esi,esi         -- clear esi, the 'some digits have already been printed' flag.
                    xor esi,esi           ;#00442CBB: 061366                     uv 40 40  1  86      
;   297           @@:
;   298             div ecx             -- eax:=eax/ecx, (so eax=top digit) edx:=remainder
                    div ecx               ;#00442CBD: 367361                     np 05 07 41  87      
;   299             push edx            -- save remainder
                    push rdx              ;#00442CBF: 122                        uv 00 04  1 128      
;   300             cmp ecx,1           -- always print the last digit
                    cmp ecx,1             ;#00442CC0: 203371 01                  vu 00 02  1 128      
;   301             je :display_digit
                    je #00442CD0          ;#00442CC3: 164 0B                     v  00 00  1 129      
;   302             test esi,esi        -- or if any have already been printed
                    test rsi,esi          ;#00442CC5: 205366                     uv 00 40  1 130      
;   303             jnz :display_digit
                    jnz #00442CD0         ;#00442CC7: 165 07                     v  00 00  1 130      
;   304 --          test al,al          -- or if this digit is not zero (ie eax)
;   305             test eax,eax        -- or if this digit is not zero (ie eax)
                    test rax,eax          ;#00442CC9: 205300                     uv 00 01  1 131      
;   306             jz :digit_skip
                    jz #00442CD4          ;#00442CCB: 164 07                     v  00 00  1 131      
;   307 --          not esi             -- set flag indicating a digit has been printed
;   308             or esi,1            -- set flag indicating a digit has been printed
                    or esi,1              ;#00442CCD: 203316 01                  uv 40 40  1 132      
;   309           ::display_digit
;   310             add al,0x30         -- +'0'
                    add al,48             ;#00442CD0: 200300 30                  vu 01 01  1 132      
;   311             stosb
                    stosb                 ;#00442CD3: 252                        np 80 81  3 133      
;   312           ::digit_skip
;   313             mov eax,ecx         -- all divisions must occur in eax
                    mov eax,ecx           ;#00442CD4: 213301                     uv 01 02  1 136      
;   314             xor edx,edx         -- zero edx
                    xor edx,edx           ;#00442CD6: 061322                     vu 04 04  1 136      
;   315             mov ecx,10
                    mov ecx,10            ;#00442CD8: 271 0A000000               uv 02 00  1 137      
;   316             div ecx             -- eax:=eax/10
                    div ecx               ;#00442CDD: 367361                     np 05 07 41 138      
;   317             mov ecx,eax         -- save the new, smaller, divisor
                    mov ecx,eax           ;#00442CDF: 213310                     uv 02 01  1 179      
;   318             pop eax             -- restore the saved remainder back to eax
                    pop rax               ;#00442CE1: 130                        vu 01 00  1 179      
;   319             test ecx,ecx        -- all done?
                    test rcx,ecx          ;#00442CE2: 205311                     uv 00 02  1 180      
;   320             jnz @b
                    jnz #00442CBD         ;#00442CE4: 165 D7                     v  00 00  1 180      
;   321         [32]
;   322             mov eax,[esp+20]    -- putcr
;   323         [64]
;   324             mov rax,[rsp+24]    -- putcr
                    mov rax,[rsp+24]      ;#00442CE6: 48:213104044 18            uv 01 10  1 181      
;   325         []
;   326             mov ecx,edi
                    mov ecx,edi           ;#00442CEB: 213317                     vu 02 80  1 181      
;   327             test eax,eax
                    test rax,eax          ;#00442CED: 205300                     uv 00 01  1 182      
;   328             jz @f
                    jz #00442CF9          ;#00442CEF: 164 08                     v  00 00  1 182      
;   329                 add ecx,2
                        add ecx,2         ;#00442CF1: 203301 02                  uv 02 02  1 183      
;   330                 mov word[edi],0x0D0A
                        mov word[rdi], word 3338  ;#00442CF4: 146:307007 0A0D            vu 00 80  1 183      
;   331           @@:
;   332             sub ecx,esp
                    sub ecx,esp           ;#00442CF9: 051341                     uv 02 12  1 184      
;   333         [32]
;   334             mov edi,esp
;   335             mov esi,ecx -- (improve me, once working)
;   336             call :%puts1ediesi
;   337             add esp,16
;   338             ret 4
;   339         [64]
;   340             mov rdi,rsp
                    mov rdi,rsp           ;#00442CFB: 48:213374                  vu 80 10  1 184      
;   341             mov rsi,rcx
                    mov rsi,rcx           ;#00442CFE: 48:213361                  uv 40 02  1 185      
;   342             call :%puts1rdirsi
                    call #00442B9E (:%puts1rdirsi)  ;#00442D01: 350 98FEFFFF               v  00 00  1 185      
;   343 --          add rsp,24
;   344             add rsp,16
                    add rsp,16            ;#00442D06: 48:203304 10               uv 10 10  1 186      
;   345             ret 8
                    ret 8                 ;#00442D0A: 302 0800                   np 00 00  3 187      
;   346         []
;   347 
;   348 --/*
;   349 procedure :%getc0(:%)
;   350 end procedure -- (for Edita/CtrlQ)
;   351 --*/
;   352     :%getc0
;   353 -----------
;   354         [PE32]
;   355             push -10                        -- nStdHandle (p1) (-10=STD_INPUT_HANDLE)
;   356             call "kernel32.dll","GetStdHandle"
;   357 -- 23/4/15:
;   358             push eax                        -- save
;   359             push 1                          -- fdwMode (1=ENABLE_PROCESSED_INPUT)
;   360             push eax                        -- hConsole
;   361             call "kernel32.dll","SetConsoleMode"
;   362             pop eax                         -- restore
;   363 
;   364             push ebx            -- reserve space for buffer (1 byte realy)
;   365             mov esi,esp
;   366             push ebx            -- reserve space for NumberOfBytesRead
;   367             mov edi,esp
;   368             push ebx                        -- lpOverlapped
;   369             push edi                        -- lpNumberOfBytesRead
;   370             push dword 1                    -- nNumberOfBytesToRead (1)
;   371             push esi                        -- lbBuffer
;   372             push eax                        -- hFile
;   373             call "kernel32.dll","ReadFile"
;   374             add esp,8
;   375         [ELF32]
;   376             push ebx                -- char *buf (1 byte)
;   377             mov eax,3               -- sys_read(ebx=int fd,ecx=char *buf,edx=int len)
;   378             mov edx,1               -- length (p3)
;   379             lea ecx,[esp+4]         -- buf (p2)
;   380             mov ebx,0               -- stdin (p1)
;   381             int 0x80
;   382             xor ebx,ebx             -- (common requirement)
;   383             add esp,4
;   384         [PE64]
;   385             mov rcx,rsp -- put 2 copies of rsp onto the stack...
                    mov rcx,rsp           ;#00442D0D: 48:213314                  uv 02 10  1 190      
;   386             push rsp
                    push rsp              ;#00442D10: 48:124                     vu 00 10  1 190      
;   387             push rcx
                    push rcx              ;#00442D12: 48:121                     uv 00 02  1 191      
;   388             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#00442D14: 48:203314 08               vu 10 10  1 191      
;   389                         -- if on entry rsp was xxx8: both copies remain on the stack
;   390                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;   391                         -- obviously rsp is now xxx8, whatever alignment we started with
;   392             sub rsp,8*7                     -- 5 params plus buffer and bytesread (no align rqd)
                    sub rsp,56            ;#00442D18: 48:203354 38               uv 10 10  1 192      
;   393             mov ecx,-10                     -- DWORD nStdHandle (p1) (-10=STD_INPUT_HANDLE)
                    mov ecx,-10           ;#00442D1C: 271 F6FFFFFF               vu 02 00  1 192      
;   394             call "kernel32.dll","GetStdHandle"
                    call [#004010B8] (GetStdHandle)  ;#00442D21: 377025 91E3FBFF            np 00 00  2 193      
;   395 
;   396 -- 23/4/15:
;   397             mov [rsp+5*8],rax               -- save
                    mov [rsp+40],rax      ;#00442D27: 48:211104044 28            uv 00 11  1 195      
;   398             mov rdx,1                       -- fdwMode (1=ENABLE_PROCESSED_INPUT)
                    mov rdx,1             ;#00442D2C: 48:307302 01000000         vu 04 00  1 195      
;   399             mov rcx,rax                     -- hConsole
                    mov rcx,rax           ;#00442D33: 48:213310                  uv 02 01  1 196      
;   400             call "kernel32.dll","SetConsoleMode"
                    call [#00401110] (SetConsoleMode)  ;#00442D36: 377025 D4E3FBFF            np 00 00  2 197      
;   401             mov rax,[rsp+5*8]               -- restore
                    mov rax,[rsp+40]      ;#00442D3C: 48:213104044 28            uv 01 10  1 199      
;   402 
;   403             mov [rsp+5*8],rbx               -- lbBuffer (zero the high bits)
                    mov [rsp+40],rbx      ;#00442D41: 48:211134044 28            vu 00 18  1 199      
;   404             mov qword[rsp+4*8],rbx          -- LPOVERLAPPED lpOverlapped (p5) (rbx=NULL)
                    mov [rsp+32],rbx      ;#00442D46: 48:211134044 20            uv 00 18  1 200      
;   405             lea r9,[rsp+6*8]                -- LPDWORD lpNumberOfBytesRead (p4)
                    lea r9,[rsp+48]       ;#00442D4B: 4C:215114044 30            vu 200 10  1 200      
;   406             mov r8,1                        -- nNumberOfBytesToRead (p3) (1)
                    mov r8,1              ;#00442D50: 49:307300 01000000         uv 100 00  1 201      
;   407             lea rdx,[rsp+5*8]               -- lbBuffer (p2)
                    lea rdx,[rsp+40]      ;#00442D57: 48:215124044 28            vu 04 10  1 201      
;   408             mov rcx,rax                     -- hFile (p1)
                    mov rcx,rax           ;#00442D5C: 48:213310                  uv 02 01  1 202      
;   409             call "kernel32.dll","ReadFile"
                    call [#00401100] (ReadFile)  ;#00442D5F: 377025 9BE3FBFF            np 00 00  2 203      
;   410 --          add rsp,8*7
;   411 --          pop rsp     -- restore, equivalent to rsp += (either #08 or #10)
;   412             mov rsp,[rsp+8*7]   -- equivalent to add/pop
                    mov rsp,[rsp+56]      ;#00442D65: 48:213144044 38            uv 10 10  1 205      
;   413         [ELF64]
;   414             push rbx                -- char *buf (1 byte)
;   415             mov rdx,10              -- length (p3)
;   416             mov rsi,rsp             -- buf (p2)
;   417             mov rdi,0               -- stdin
;   418             mov rax,0               -- sys_read(rdi=unsigned int fd,rsi=char *buf,rdx=size_t count)
;   419             syscall
;   420             add rsp,8
;   421         []
;   422             ret
                    ret                   ;#00442D6A: 303                        np 00 00  2 206      
;   423 --::fin
;   424     }
;   425 
;   426 
    jmp #0044298D (:%opRetf)              ;#00442D6B: 351 1DFCFFFF               v  00 00  1 208      
;C:\Program Files (x86)\Phix\builtins\VM\psprintN.e:
;===================================================
;     1 --
;     2 -- psprintN.e
;     3 -- =========
;     4 --
;     5 -- Phix: implementation of sprint() and print().
;     6 --
;     7 --without debug -- (NB: do not use this on RDS Eu/OpenEuphoria)
;     8                 -- Normally do NOT explicitly "include psprint.e"; 
;     9                 --  instead treat sprint()/print() as say length(),
;    10                 --  and just let compiler auto-include this file.
;    11                 -- Occasionally you may want an explicit include, 
;    12                 --  eg for namespace or routine_id purposes, which
;    13                 --  is fine except for RDS Eu incompatibility, so
;    14                 --  an "--/**/include builtins\psprint.e" may be better(?).
;    15 
;    16 include pprntfN.e
;    17 
;    18 --constant tnr = "tnr"
;    19 --constant tnr = "tnr\\\"\'\0"
;    20 constant tnr = "tnr\\\"\'0"
;    21 function allascii(string x)
    mov rdi,[rbp] (x)                     ;#0044DA46: 48:213175 00               uv 80 20  1   1      
    mov r15,h4                            ;#0044DA4A: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0044DA54: 4C:071377                  uv 00 8080  1   2      
    jl #0044DA60                          ;#0044DA57: 174 07                     v  00 00  1   2      
    cmp byte[rbx+rdi*4-1],#82             ;#0044DA59: 200174273 FF 82            u  00 88  2   3      
    je #0044DA6C                          ;#0044DA5E: 164 0C                     v  00 00  1   4      
    mov rcx,245                           ;#0044DA60: 48:307301 F5000000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044DA67: 350 EC4FFFFF               v  00 00  1   5      
;    22 -- Phix allows "strings" to hold binary data, so double check 
;    23 -- before printing it as a string.
;    24 integer c
;    25     for i=length(x) to 1 by -1 do
    mov rcx,[rbx+rdi*4-24]                ;#0044DA6C: 48:48:213114273 E8         uv 02 88  1   6      
    mov [rbp-16] (symtab[247]),rcx        ;#0044DA72: 48:211115 F0               uv 00 22  1   7 02   
    mov [rbp-24] (i),rcx                  ;#0044DA76: 48:211115 E8               vu 00 22  1   7      
    cmp rcx,1                             ;#0044DA7A: 48:201371 01000000         uv 00 02  1   8      
    jl #0044DBD2                          ;#0044DA81: 017214 4B010000            v  00 00  1   8      
;    26         c = x[i]
    mov rdi,[rbp-24] (i)                  ;#0044DA87: 48:213175 E8               uv 80 20  1   9      
    mov rsi,[rbp] (x)                     ;#0044DA8B: 48:213165 00               vu 40 20  1   9      
    mov rdx,245                           ;#0044DA8F: 48:307302 F5000000         uv 04 00  1  10      
    call #00441762 (:%pSubse1is)          ;#0044DA96: 350 C73CFFFF               v  00 00  1  10      
    mov [rbp-8] (c),rax                   ;#0044DA9B: 48:211105 F8               uv 00 21  1  11      
;    27 --31/1/15:
;    28 --      if c<' ' then
;    29         if c<' ' or c>#7E or find(c,"\\\"\'") then
    cmp rax,32                            ;#0044DA9F: 48:203370 20               vu 00 01  1  11      
    jl #0044DAF1                          ;#0044DAA3: 174 4C                     v  00 00  1  12      
    cmp rax,126                           ;#0044DAA5: 48:203370 7E               uv 00 01  1  13      
    jg #0044DAF1                          ;#0044DAA9: 177 46                     v  00 00  1  13      
    mov rcx,7                             ;#0044DAAB: 48:307301 07000000         uv 02 00  1  14      
    mov rdx,75                            ;#0044DAB2: 48:307302 4B000000         vu 04 00  1  14      
    call #004428DB (:%opFrame) (find)     ;#0044DAB9: 350 1D4EFFFF               v  00 00  1  15      
    mov rdi,[rbp+40] (prevebp)            ;#0044DABE: 48:213175 28               uv 80 20  1  16      
    mov rax,[rdi-8]                       ;#0044DAC2: 48:213107 F8               uv 01 80  1  19 80 *80*
    mov [rbp] (x),rax                     ;#0044DAC6: 48:211105 00               uv 00 21  1  20 01   
    mov rcx,qword[#004022F0]              ;#0044DACA: 48:213015 1F48FBFF         vu 02 00  1  20      
    mov [rbp-8] (s),rcx                   ;#0044DAD1: 48:211115 F8               uv 00 22  1  21      
    add qword[rbx+rcx*4-16],1             ;#0044DAD5: 48:203104213 F0 01         u  00 0A  3  23    *02*
    mov qword[retaddr],#0044DAE8          ;#0044DADB: 48:307105 20 E8DA4400      vu 00 20  1  25      
    jmp #0043DAD6 (code:find)             ;#0044DAE3: 351 EEFFFEFF               v  00 00  1  26      
    test rax,rax                          ;#0044DAE8: 48:205300                  uv 00 01  1  27      
    je #0044DBB6                          ;#0044DAEB: 017204 C5000000            v  00 00  1  27      
;    30 --          c = find(c,"\t\n\r")
;    31             c = find(c,"\t\n\r\\\"\'\0")
    mov rcx,7                             ;#0044DAF1: 48:307301 07000000         uv 02 00  1  28      
    mov rdx,75                            ;#0044DAF8: 48:307302 4B000000         vu 04 00  1  28      
    call #004428DB (:%opFrame) (find)     ;#0044DAFF: 350 D74DFFFF               v  00 00  1  29      
    mov rdi,[rbp+40] (prevebp)            ;#0044DB04: 48:213175 28               uv 80 20  1  30      
    mov rax,[rdi-8]                       ;#0044DB08: 48:213107 F8               uv 01 80  1  33 80 *80*
    mov [rbp] (x),rax                     ;#0044DB0C: 48:211105 00               uv 00 21  1  34 01   
    mov rdi,qword[#004022F8]              ;#0044DB10: 48:213075 E147FBFF         vu 80 00  1  34      
    mov [rbp-8] (s),rdi                   ;#0044DB17: 48:211175 F8               uv 00 A0  1  35      
    add qword[rbx+rdi*4-16],1             ;#0044DB1B: 48:203104273 F0 01         u  00 88  3  37    *80*
    mov qword[retaddr],#0044DB2E          ;#0044DB21: 48:307105 20 2EDB4400      vu 00 20  1  39      
    jmp #0043DAD6 (code:find)             ;#0044DB29: 351 A8FFFEFF               v  00 00  1  40      
    mov [rbp-8] (c),rax                   ;#0044DB2E: 48:211105 F8               uv 00 21  1  41      
;    32             if c then
    test rax,rax                          ;#0044DB32: 48:205300                  vu 00 01  1  41      
    je #0044DBAA                          ;#0044DB35: 164 73                     v  00 00  1  42      
;    33                 x[i..i] = '\\'&tnr[c]   -- NB does not work on RDS Eu/OpenEuphoria
    mov rdi,rax                           ;#0044DB37: 48:211307                  uv 80 01  1  43      
    mov rsi,[#004022E0] (tnr)             ;#0044DB3A: 48:213065 9F47FBFF         vu 40 00  1  43      
    mov rdx,242                           ;#0044DB41: 48:307302 F2000000         uv 04 00  1  44      
    call #00441762 (:%pSubse1is)          ;#0044DB48: 350 153CFFFF               v  00 00  1  44      
    mov [rbp-32] (symtab[253]),rax        ;#0044DB4D: 48:211105 E0               uv 00 21  1  45      
    lea rdx,[rbp-40] (symtab[254])        ;#0044DB51: 48:215125 D8               vu 04 20  1  45      
    lea rdi,qword[#00402300]              ;#0044DB55: 48:215075 A447FBFF         uv 80 00  1  46      
    lea rcx,[rbp-32] (symtab[253])        ;#0044DB5C: 48:215115 E0               vu 02 20  1  46      
    call #00440021 (:%opConcat)           ;#0044DB60: 350 BC24FFFF               v  00 00  1  47      
    mov rcx,1                             ;#0044DB65: 48:307301 01000000         uv 02 00  1  48      
    push #0044DB82                        ;#0044DB6C: 150 82DB4400               vu 00 00  1  48      
    push qword[rbp-40] (symtab[254])      ;#0044DB71: 377165 D8                  np 00 20  2  49      
    push qword[rbp-24] (i)                ;#0044DB74: 377165 E8                  np 00 20  2  51      
    push qword[rbp-24] (i)                ;#0044DB77: 377165 E8                  np 00 20  2  53      
    mov rax,rbp                           ;#0044DB7A: 48:213305                  uv 01 20  1  55      
    jmp #00440524 (:%pReps)               ;#0044DB7D: 351 A229FFFF               v  00 00  1  55      
    mov rcx,[rbp] (x)                     ;#0044DB82: 48:213115 00               uv 02 20  1  56      
    mov r15,h4                            ;#0044DB86: 49:277 0000000000000040    vu 8000 00  1  56      
    cmp rcx,r15                           ;#0044DB90: 4C:071371                  uv 00 8002  1  57      
    jl #0044DB9C                          ;#0044DB93: 174 07                     v  00 00  1  57      
    cmp byte[rbx+rcx*4-1],#82             ;#0044DB95: 200174213 FF 82            u  00 0A  2  58      
    je #0044DBB6                          ;#0044DB9A: 164 1A                     v  00 00  1  59      
    mov rcx,245                           ;#0044DB9C: 48:307301 F5000000         uv 02 00  1  60      
    call #00442A58 (:%opTchkFail)         ;#0044DBA3: 350 B04EFFFF               v  00 00  1  60      
    jmp #0044DBB6                         ;#0044DBA8: 353 0C                     v  00 00  1  61      
;    34             else
;    35                 return 0
    mov rax,0                             ;#0044DBAA: 48:307300 00000000         uv 01 00  1  62      
    jmp #0044298D (:%opRetf)              ;#0044DBB1: 351 D74DFFFF               v  00 00  1  62      
;    36             end if
;    37         end if
;    38     end for
    mov rdi,[rbp-24] (i)                  ;#0044DBB6: 48:213175 E8               uv 80 20  1  63      
    mov rdx,1                             ;#0044DBBA: 48:307302 01000000         vu 04 00  1  63      
    add rdi,-1                            ;#0044DBC1: 48:203307 FF               uv 80 80  1  64      
    cmp rdi,rdx                           ;#0044DBC5: 48:073372                  uv 00 84  1  65 80   
    mov [rbp-24] (i),rdi                  ;#0044DBC8: 48:211175 E8               vu 00 A0  1  65      
    jge #0044DA87                         ;#0044DBCC: 017215 B5FEFFFF            v  00 00  1  66      
;    39     return '\"'&x&'\"'
    mov rcx,3                             ;#0044DBD2: 48:307301 03000000         uv 02 00  1  67      
    push #0044DBF6                        ;#0044DBD9: 150 F6DB4400               vu 00 00  1  67      
    push qword[#00402308]                 ;#0044DBDE: 377065 2447FBFF            np 00 00  2  68      
    push qword[rbp] (x)                   ;#0044DBE4: 377165 00                  np 00 20  2  70      
    push qword[#00402308]                 ;#0044DBE7: 377065 1B47FBFF            np 00 00  2  72      
    lea rax,[rbp-48] (symtab[256])        ;#0044DBED: 48:215105 D0               uv 01 20  1  74      
    jmp #004402C2 (:%opConcatN)           ;#0044DBF1: 351 CC26FFFF               v  00 00  1  74      
    mov rax,[rbp-48] (symtab[256])        ;#0044DBF6: 48:213105 D0               uv 01 20  1  75      
    mov [rbp-48] (symtab[256]),rbx        ;#0044DBFA: 48:211135 D0               vu 00 28  1  75      
    jmp #0044298D (:%opRetf)              ;#0044DBFE: 351 8A4DFFFF               v  00 00  1  76      
;    40 --  return x
    call #00442D91 (:%pBadRetf)           ;#0044DC03: 350 8951FFFF               v  00 00  1  77      
;    41 end function
;    42 
;    43 --global function sprint(object x)
;    44 global function sprint(object x, integer l=-1, integer nest=0)
    mov rdi,[rbp-8] (l)                   ;#0044D2DF: 48:213175 F8               uv 80 20  1   1      
    mov r15,h4                            ;#0044D2E3: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0044D2ED: 4C:071377                  uv 00 8080  1   2      
    jne #0044D2FC                         ;#0044D2F0: 165 0A                     v  00 00  1   2      
    mov qword[rbp-8] (l),-1               ;#0044D2F2: 48:307105 F8 FFFFFFFF      uv 00 20  1   3      
    jmp #0044D30A                         ;#0044D2FA: 353 0E                     v  00 00  1   3      
    jl #0044D30A                          ;#0044D2FC: 174 0C                     v  00 00  1   4      
    mov rcx,258                           ;#0044D2FE: 48:307301 02010000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0044D305: 350 4E57FFFF               v  00 00  1   5      
    mov rsi,[rbp-16] (nest)               ;#0044D30A: 48:213165 F0               uv 40 20  1   6      
    mov r15,h4                            ;#0044D30E: 49:277 0000000000000040    vu 8000 00  1   6      
    cmp rsi,r15                           ;#0044D318: 4C:071376                  uv 00 8040  1   7      
    jne #0044D323                         ;#0044D31B: 165 06                     v  00 00  1   7      
    mov [rbp-16] (nest),rbx               ;#0044D31D: 48:211135 F0               uv 00 28  1   8      
    jmp #0044D331                         ;#0044D321: 353 0E                     v  00 00  1   8      
    jl #0044D331                          ;#0044D323: 174 0C                     v  00 00  1   9      
    mov rcx,259                           ;#0044D325: 48:307301 03010000         uv 02 00  1  10      
    call #00442A58 (:%opTchkFail)         ;#0044D32C: 350 2757FFFF               v  00 00  1  10      
;    45 -- Return the string representation of any data object. 
;    46 -- This is the same as the output from print(1, x) or '?', 
;    47 --  but returned as a string sequence rather than printed.
;    48 -- Alternative: see ppp.e (ppf/ppOpt/ppExf).
;    49 object s, xi
;    50 
;    51     if atom(x) then
    mov rcx,[rbp] (x)                     ;#0044D331: 48:213115 00               uv 02 20  1  11      
    mov r15,h4                            ;#0044D335: 49:277 0000000000000040    vu 8000 00  1  11      
    cmp rcx,r15                           ;#0044D33F: 4C:071371                  uv 00 8002  1  12      
    jl #0044D34F                          ;#0044D342: 174 0B                     v  00 00  1  12      
    cmp byte[rbx+rcx*4-1],#12             ;#0044D344: 200174213 FF 12            u  00 0A  2  13      
    jne #0044D50E                         ;#0044D349: 017205 BF010000            v  00 00  1  14      
;    52 --      return sprintf("%.10g", x)
;    53         s = sprintf("%.10g", x)
    mov rcx,33                            ;#0044D34F: 48:307301 21000000         uv 02 00  1  15      
    mov rdx,89                            ;#0044D356: 48:307302 59000000         vu 04 00  1  15      
    call #004428DB (:%opFrame) (sprintf)  ;#0044D35D: 350 7955FFFF               v  00 00  1  16      
    mov rax,qword[#00402310]              ;#0044D362: 48:213005 A74FFBFF         uv 01 00  1  17      
    mov [rbp] (format),rax                ;#0044D369: 48:211105 00               uv 00 21  1  18 01   
    add qword[rbx+rax*4-16],1             ;#0044D36D: 48:203104203 F0 01         u  00 09  3  20    *01*
    mov rdi,[rbp+40] (prevebp)            ;#0044D373: 48:213175 28               vu 80 20  1  22      
    mov rax,[rdi]                         ;#0044D377: 48:213007                  uv 01 80  1  25    *80*
    xor rbx,rbx                           ;#0044D37A: 48:061333                  vu 08 08  1  25      
    mov r15,h4                            ;#0044D37D: 49:277 0000000000000040    uv 8000 00  1  26      
    cmp rax,r15                           ;#0044D387: 4C:071370                  uv 00 8001  1  27 8000   
    jl #0044D397                          ;#0044D38A: 174 0B                     v  00 00  1  27      
    add qword[rbx+rax*4-16],1             ;#0044D38C: 48:203104203 F0 01         u  00 09  3  28      
    cmp eax,257                           ;#0044D392: 075 01010000               vu 00 01  1  30      
    mov [rbp-8] (args),rax                ;#0044D397: 48:211105 F8               uv 00 21  1  31      
    mov qword[retaddr],#0044D3A8          ;#0044D39B: 48:307105 20 A8D34400      vu 00 20  1  31      
    jmp #0044E450 (code:sprintf)          ;#0044D3A3: 351 A8100000               v  00 00  1  32      
    mov [rbp-24] (s),rax                  ;#0044D3A8: 48:211105 E8               uv 00 21  1  33      
;    54         if not integer(x)
    mov rdi,[rbp] (x)                     ;#0044D3AC: 48:213175 00               vu 80 20  1  33      
    mov r15,h4                            ;#0044D3B0: 49:277 0000000000000040    uv 8000 00  1  34      
    cmp rdi,r15                           ;#0044D3BA: 4C:071377                  uv 00 8080  1  35 8000   
    jl #0044D501                          ;#0044D3BD: 017214 3E010000            v  00 00  1  35      
;    55         and integer(floor(x))
    lea rdi,[rbp-40] (symtab[263])        ;#0044D3C3: 48:215175 D8               uv 80 20  1  36      
    mov rax,[rbp] (x)                     ;#0044D3C7: 48:213105 00               vu 01 20  1  36      
    call #0043F81C (:%opFloor)            ;#0044D3CB: 350 4C24FFFF               v  00 00  1  37      
    mov rsi,[rbp-40] (symtab[263])        ;#0044D3D0: 48:213165 D8               uv 40 20  1  38      
    mov r15,h4                            ;#0044D3D4: 49:277 0000000000000040    vu 8000 00  1  38      
    cmp rsi,r15                           ;#0044D3DE: 4C:071376                  uv 00 8040  1  39      
    jg #0044D501                          ;#0044D3E1: 017217 1A010000            v  00 00  1  39      
;    56         and not find('.',s)
    mov rcx,7                             ;#0044D3E7: 48:307301 07000000         uv 02 00  1  40      
    mov rdx,75                            ;#0044D3EE: 48:307302 4B000000         vu 04 00  1  40      
    call #004428DB (:%opFrame) (find)     ;#0044D3F5: 350 E154FFFF               v  00 00  1  41      
    mov qword[rbp] (x),46                 ;#0044D3FA: 48:307105 00 2E000000      uv 00 20  1  42      
    mov rdi,[rbp+40] (prevebp)            ;#0044D402: 48:213175 28               vu 80 20  1  42      
    mov rax,[rdi-24]                      ;#0044D406: 48:213107 E8               uv 01 80  1  45    *80*
    xor rbx,rbx                           ;#0044D40A: 48:061333                  vu 08 08  1  45      
    mov r15,h4                            ;#0044D40D: 49:277 0000000000000040    uv 8000 00  1  46      
    cmp rax,r15                           ;#0044D417: 4C:071370                  uv 00 8001  1  47 8000   
    jl #0044D427                          ;#0044D41A: 174 0B                     v  00 00  1  47      
    add qword[rbx+rax*4-16],1             ;#0044D41C: 48:203104203 F0 01         u  00 09  3  48      
    cmp eax,260                           ;#0044D422: 075 04010000               vu 00 01  1  50      
    mov [rbp-8] (s),rax                   ;#0044D427: 48:211105 F8               uv 00 21  1  51      
    mov qword[retaddr],#0044D438          ;#0044D42B: 48:307105 20 38D44400      vu 00 20  1  51      
    jmp #0043DAD6 (code:find)             ;#0044D433: 351 9E06FFFF               v  00 00  1  52      
    test rax,rax                          ;#0044D438: 48:205300                  uv 00 01  1  53      
    jne #0044D501                         ;#0044D43B: 017205 C0000000            v  00 00  1  53      
;    57         and not find('e',s)         -- eg 1e308
    mov rcx,7                             ;#0044D441: 48:307301 07000000         uv 02 00  1  54      
    mov rdx,75                            ;#0044D448: 48:307302 4B000000         vu 04 00  1  54      
    call #004428DB (:%opFrame) (find)     ;#0044D44F: 350 8754FFFF               v  00 00  1  55      
    mov qword[rbp] (x),101                ;#0044D454: 48:307105 00 65000000      uv 00 20  1  56      
    mov rdi,[rbp+40] (prevebp)            ;#0044D45C: 48:213175 28               vu 80 20  1  56      
    mov rax,[rdi-24]                      ;#0044D460: 48:213107 E8               uv 01 80  1  59    *80*
    xor rbx,rbx                           ;#0044D464: 48:061333                  vu 08 08  1  59      
    mov r15,h4                            ;#0044D467: 49:277 0000000000000040    uv 8000 00  1  60      
    cmp rax,r15                           ;#0044D471: 4C:071370                  uv 00 8001  1  61 8000   
    jl #0044D481                          ;#0044D474: 174 0B                     v  00 00  1  61      
    add qword[rbx+rax*4-16],1             ;#0044D476: 48:203104203 F0 01         u  00 09  3  62      
    cmp eax,260                           ;#0044D47C: 075 04010000               vu 00 01  1  64      
    mov [rbp-8] (s),rax                   ;#0044D481: 48:211105 F8               uv 00 21  1  65      
    mov qword[retaddr],#0044D492          ;#0044D485: 48:307105 20 92D44400      vu 00 20  1  65      
    jmp #0043DAD6 (code:find)             ;#0044D48D: 351 4406FFFF               v  00 00  1  66      
    test rax,rax                          ;#0044D492: 48:205300                  uv 00 01  1  67      
    jne #0044D501                         ;#0044D495: 165 6A                     v  00 00  1  67      
;    58         and not find('n',s) then    -- (inf/nan)
    mov rcx,7                             ;#0044D497: 48:307301 07000000         uv 02 00  1  68      
    mov rdx,75                            ;#0044D49E: 48:307302 4B000000         vu 04 00  1  68      
    call #004428DB (:%opFrame) (find)     ;#0044D4A5: 350 3154FFFF               v  00 00  1  69      
    mov qword[rbp] (x),110                ;#0044D4AA: 48:307105 00 6E000000      uv 00 20  1  70      
    mov rdi,[rbp+40] (prevebp)            ;#0044D4B2: 48:213175 28               vu 80 20  1  70      
    mov rax,[rdi-24]                      ;#0044D4B6: 48:213107 E8               uv 01 80  1  73    *80*
    xor rbx,rbx                           ;#0044D4BA: 48:061333                  vu 08 08  1  73      
    mov r15,h4                            ;#0044D4BD: 49:277 0000000000000040    uv 8000 00  1  74      
    cmp rax,r15                           ;#0044D4C7: 4C:071370                  uv 00 8001  1  75 8000   
    jl #0044D4D7                          ;#0044D4CA: 174 0B                     v  00 00  1  75      
    add qword[rbx+rax*4-16],1             ;#0044D4CC: 48:203104203 F0 01         u  00 09  3  76      
    cmp eax,260                           ;#0044D4D2: 075 04010000               vu 00 01  1  78      
    mov [rbp-8] (s),rax                   ;#0044D4D7: 48:211105 F8               uv 00 21  1  79      
    mov qword[retaddr],#0044D4E8          ;#0044D4DB: 48:307105 20 E8D44400      vu 00 20  1  79      
    jmp #0043DAD6 (code:find)             ;#0044D4E3: 351 EE05FFFF               v  00 00  1  80      
    test rax,rax                          ;#0044D4E8: 48:205300                  uv 00 01  1  81      
    jne #0044D501                         ;#0044D4EB: 165 14                     v  00 00  1  81      
;    59             -- make sure you can tell 5 and 5.00000000001 
;    60             --  apart in ex.err, trace, ?x, and the like.
;    61             s &= ".0"
    lea rdx,[rbp-24] (s)                  ;#0044D4ED: 48:215125 E8               uv 04 20  1  82      
    lea rdi,[rbp-24] (s)                  ;#0044D4F1: 48:215175 E8               vu 80 20  1  82      
    lea rcx,qword[#00402318]              ;#0044D4F5: 48:215015 1C4EFBFF         uv 02 00  1  83      
    call #00440021 (:%opConcat)           ;#0044D4FC: 350 202BFFFF               v  00 00  1  83      
;    62         end if
;    63         return s
    mov rax,[rbp-24] (s)                  ;#0044D501: 48:213105 E8               uv 01 20  1  84      
    mov [rbp-24] (s),rbx                  ;#0044D505: 48:211135 E8               vu 00 28  1  84      
    jmp #0044298D (:%opRetf)              ;#0044D509: 351 7F54FFFF               v  00 00  1  85      
;    64     end if
;    65 --  if string(x) then
;    66 
;    67 --      s = allascii(x)
;    68 --      if string(s) then return s end if
;    69 --  end if
;    70     if l!=-1 and length(x)>l then
    mov rcx,[rbp-8] (l)                   ;#0044D50E: 48:213115 F8               uv 02 20  1  86      
    cmp rcx,-1                            ;#0044D512: 48:203371 FF               uv 00 02  1  87 02   
    je #0044D64B                          ;#0044D516: 017204 2F010000            v  00 00  1  87      
    lea rdi,[rbp-48] (symtab[265])        ;#0044D51C: 48:215175 D0               uv 80 20  1  88      
    mov rsi,[rbp] (x)                     ;#0044D520: 48:213165 00               vu 40 20  1  88      
    mov rdx,257                           ;#0044D524: 48:307302 01010000         uv 04 00  1  89      
    call #0043F28D (:%opLen)              ;#0044D52B: 350 5D1DFFFF               v  00 00  1  89      
    mov rdi,[rbp-8] (l)                   ;#0044D530: 48:213175 F8               uv 80 20  1  90      
    cmp rcx,rdi                           ;#0044D534: 48:071371                  uv 00 82  1  91 80   
    jle #0044D64B                         ;#0044D537: 017216 0E010000            v  00 00  1  91      
;    71         x = x[1..l]
    mov rdx,rbp                           ;#0044D53D: 48:213325                  uv 04 20  1  92      
    mov rcx,1                             ;#0044D540: 48:307301 01000000         vu 02 00  1  92      
    push #0044D55C                        ;#0044D547: 150 5CD54400               uv 00 00  1  93      
    push rdx                              ;#0044D54C: 122                        vu 00 04  1  93      
    push rdi                              ;#0044D54D: 127                        uv 00 80  1  94      
    push 1                                ;#0044D54E: 152 01                     vu 00 00  1  94      
    mov rdx,257                           ;#0044D550: 48:307302 01010000         uv 04 00  1  95      
    jmp #00440F1F (:%pSubss)              ;#0044D557: 351 C339FFFF               v  00 00  1  95      
;    72         if string(x) then
    mov rax,[rbp] (x)                     ;#0044D55C: 48:213105 00               uv 01 20  1  96      
    cmp byte[rbx+rax*4-1],#82             ;#0044D560: 200174203 FF 82            u  00 09  2  99    *01*
    jne #0044D6FB                         ;#0044D565: 017205 90010000            v  00 00  1 100      
;    73             s = allascii(x[1..l-4])
    lea rdi,[rbp-40] (symtab[263])        ;#0044D56B: 48:215175 D8               uv 80 20  1 101      
    mov rcx,[rbp-8] (l)                   ;#0044D56F: 48:213115 F8               vu 02 20  1 101      
    mov rax,[#004020A8] (D_YEAR)          ;#0044D573: 48:213005 2E4BFBFF         uv 01 00  1 102      
    call #0043F4D8 (:%opSub)              ;#0044D57A: 350 591FFFFF               v  00 00  1 102      
    lea rax,[rbp-56] (symtab[266])        ;#0044D57F: 48:215105 C8               uv 01 20  1 103      
    mov rdi,1                             ;#0044D583: 48:307307 01000000         vu 80 00  1 103      
    mov rcx,[rbp-40] (symtab[263])        ;#0044D58A: 48:213115 D8               uv 02 20  1 104      
    mov rsi,[rbp] (x)                     ;#0044D58E: 48:213165 00               vu 40 20  1 104      
    mov rdx,257                           ;#0044D592: 48:307302 01010000         uv 04 00  1 105      
    call #00441212 (:%pSubsss)            ;#0044D599: 350 743CFFFF               v  00 00  1 105      
    mov rcx,7                             ;#0044D59E: 48:307301 07000000         uv 02 00  1 106      
    mov rdx,244                           ;#0044D5A5: 48:307302 F4000000         vu 04 00  1 106      
    call :%opFrame (allascii)             ;#0044D5AC: 350 2A53FFFF               v  00 00  1 107      
    mov rdi,[rbp+40] (prevebp)            ;#0044D5B1: 48:213175 28               uv 80 20  1 108      
    mov rax,[rdi-56]                      ;#0044D5B5: 48:213107 C8               uv 01 80  1 111 80 *80*
    xor rbx,rbx                           ;#0044D5B9: 48:061333                  vu 08 08  1 111      
    mov r15,h4                            ;#0044D5BC: 49:277 0000000000000040    uv 8000 00  1 112      
    cmp rax,r15                           ;#0044D5C6: 4C:071370                  uv 00 8001  1 113 8000   
    jl #0044D5D6                          ;#0044D5C9: 174 0B                     v  00 00  1 113      
    add qword[rbx+rax*4-16],1             ;#0044D5CB: 48:203104203 F0 01         u  00 09  3 114      
    cmp eax,266                           ;#0044D5D1: 075 0A010000               vu 00 01  1 116      
    mov [rbp] (x),rax                     ;#0044D5D6: 48:211105 00               uv 00 21  1 117      
    mov qword[retaddr],#0044D5E7          ;#0044D5DA: 48:307105 20 E7D54400      vu 00 20  1 117      
    jmp #0044DA46 (code:allascii)         ;#0044D5E2: 351 5F040000               v  00 00  1 118      
    push rax                              ;#0044D5E7: 120                        uv 00 01  1 119      
    mov rdi,[rbp-24] (s)                  ;#0044D5E8: 48:213175 E8               vu 80 20  1 119      
    mov r15,h4                            ;#0044D5EC: 49:277 0000000000000040    uv 8000 00  1 120      
    cmp rdi,r15                           ;#0044D5F6: 4C:071377                  uv 00 8080  1 121 8000   
    jle #0044D60B                         ;#0044D5F9: 176 10                     v  00 00  1 121      
    sub qword[rbx+rdi*4-16],1             ;#0044D5FB: 48:203154273 F0 01         u  00 88  3 122      
    jne #0044D60B                         ;#0044D601: 165 08                     v  00 00  1 124      
    mov rdx,rdi                           ;#0044D603: 48:213327                  uv 04 80  1 125      
    call #004422DA (:%pDealloc)           ;#0044D606: 350 CF4CFFFF               v  00 00  1 125      
    pop dword[rbp-24] (s)                 ;#0044D60B: 217105 E8                  np 00 20  3 126      
;    74             if string(s) then return s&".." end if
    mov rcx,[rbp-24] (s)                  ;#0044D60E: 48:213115 E8               uv 02 20  1 129      
    mov r15,h4                            ;#0044D612: 49:277 0000000000000040    vu 8000 00  1 129      
    cmp rcx,r15                           ;#0044D61C: 4C:071371                  uv 00 8002  1 130      
    jl #0044D6FB                          ;#0044D61F: 017214 D6000000            v  00 00  1 130      
    lea rdx,[rbp-56] (symtab[266])        ;#0044D625: 48:215125 C8               uv 04 20  1 131      
    lea rdi,[rbp-24] (s)                  ;#0044D629: 48:215175 E8               vu 80 20  1 131      
    lea rcx,qword[#00402320]              ;#0044D62D: 48:215015 EC4CFBFF         uv 02 00  1 132      
    call #00440021 (:%opConcat)           ;#0044D634: 350 E829FFFF               v  00 00  1 132      
    mov rax,[rbp-56] (symtab[266])        ;#0044D639: 48:213105 C8               uv 01 20  1 133      
    mov [rbp-56] (symtab[266]),rbx        ;#0044D63D: 48:211135 C8               vu 00 28  1 133      
    jmp #0044298D (:%opRetf)              ;#0044D641: 351 4753FFFF               v  00 00  1 134      
;    75         end if
    jmp #0044D6FB                         ;#0044D646: 351 B0000000               v  00 00  1 135      
;    76     elsif string(x) then
    mov rsi,[rbp] (x)                     ;#0044D64B: 48:213165 00               uv 40 20  1 136      
    mov r15,h4                            ;#0044D64F: 49:277 0000000000000040    vu 8000 00  1 136      
    cmp rsi,r15                           ;#0044D659: 4C:071376                  uv 00 8040  1 137      
    jl #0044D6FB                          ;#0044D65C: 017214 99000000            v  00 00  1 137      
    cmp byte[rbx+rsi*4-1],#82             ;#0044D662: 200174263 FF 82            u  00 48  2 138      
    jne #0044D6FB                         ;#0044D667: 017205 8E000000            v  00 00  1 139      
;    77         s = allascii(x)
    mov rcx,7                             ;#0044D66D: 48:307301 07000000         uv 02 00  1 140      
    mov rdx,244                           ;#0044D674: 48:307302 F4000000         vu 04 00  1 140      
    call :%opFrame (allascii)             ;#0044D67B: 350 5B52FFFF               v  00 00  1 141      
    mov rdi,[rbp+40] (prevebp)            ;#0044D680: 48:213175 28               uv 80 20  1 142      
    mov rax,[rdi]                         ;#0044D684: 48:213007                  uv 01 80  1 145 80 *80*
    xor rbx,rbx                           ;#0044D687: 48:061333                  vu 08 08  1 145      
    mov r15,h4                            ;#0044D68A: 49:277 0000000000000040    uv 8000 00  1 146      
    cmp rax,r15                           ;#0044D694: 4C:071370                  uv 00 8001  1 147 8000   
    jl #0044D6A4                          ;#0044D697: 174 0B                     v  00 00  1 147      
    add qword[rbx+rax*4-16],1             ;#0044D699: 48:203104203 F0 01         u  00 09  3 148      
    cmp eax,257                           ;#0044D69F: 075 01010000               vu 00 01  1 150      
    mov [rbp] (x),rax                     ;#0044D6A4: 48:211105 00               uv 00 21  1 151      
    mov qword[retaddr],#0044D6B5          ;#0044D6A8: 48:307105 20 B5D64400      vu 00 20  1 151      
    jmp #0044DA46 (code:allascii)         ;#0044D6B0: 351 91030000               v  00 00  1 152      
    push rax                              ;#0044D6B5: 120                        uv 00 01  1 153      
    mov rdi,[rbp-24] (s)                  ;#0044D6B6: 48:213175 E8               vu 80 20  1 153      
    mov r15,h4                            ;#0044D6BA: 49:277 0000000000000040    uv 8000 00  1 154      
    cmp rdi,r15                           ;#0044D6C4: 4C:071377                  uv 00 8080  1 155 8000   
    jle #0044D6D9                         ;#0044D6C7: 176 10                     v  00 00  1 155      
    sub qword[rbx+rdi*4-16],1             ;#0044D6C9: 48:203154273 F0 01         u  00 88  3 156      
    jne #0044D6D9                         ;#0044D6CF: 165 08                     v  00 00  1 158      
    mov rdx,rdi                           ;#0044D6D1: 48:213327                  uv 04 80  1 159      
    call #004422DA (:%pDealloc)           ;#0044D6D4: 350 014CFFFF               v  00 00  1 159      
    pop dword[rbp-24] (s)                 ;#0044D6D9: 217105 E8                  np 00 20  3 160      
;    78         if string(s) then return s end if
    mov rcx,[rbp-24] (s)                  ;#0044D6DC: 48:213115 E8               uv 02 20  1 163      
    mov r15,h4                            ;#0044D6E0: 49:277 0000000000000040    vu 8000 00  1 163      
    cmp rcx,r15                           ;#0044D6EA: 4C:071371                  uv 00 8002  1 164      
    jl #0044D6FB                          ;#0044D6ED: 174 0C                     v  00 00  1 164      
    mov rax,rcx                           ;#0044D6EF: 48:211310                  uv 01 02  1 165      
    mov [rbp-24] (s),rbx                  ;#0044D6F2: 48:211135 E8               vu 00 28  1 165      
    jmp #0044298D (:%opRetf)              ;#0044D6F6: 351 9252FFFF               v  00 00  1 166      
;    79     end if
;    80     s = "{"
    mov rsi,qword[#00402328]              ;#0044D6FB: 48:213065 264CFBFF         uv 40 00  1 167      
    mov rdx,[rbp-24] (s)                  ;#0044D702: 48:213125 E8               vu 04 20  1 167      
    mov r15,h4                            ;#0044D706: 49:277 0000000000000040    uv 8000 00  1 168      
    cmp rsi,r15                           ;#0044D710: 4C:071376                  uv 00 8040  1 169 8000   
    jl #0044D71B                          ;#0044D713: 174 06                     v  00 00  1 169      
    add qword[rbx+rsi*4-16],1             ;#0044D715: 48:203104263 F0 01         u  00 48  3 170      
    mov [rbp-24] (s),rsi                  ;#0044D71B: 48:211165 E8               vu 00 60  1 172      
    mov r15,h4                            ;#0044D71F: 49:277 0000000000000040    uv 8000 00  1 173      
    cmp rdx,r15                           ;#0044D729: 4C:071372                  uv 00 8004  1 174 8000   
    jle #0044D73B                         ;#0044D72C: 176 0D                     v  00 00  1 174      
    sub qword[rbx+rdx*4-16],1             ;#0044D72E: 48:203154223 F0 01         u  00 0C  3 175      
    jne #0044D73B                         ;#0044D734: 165 05                     v  00 00  1 177      
    call #004422DA (:%pDealloc)           ;#0044D736: 350 9F4BFFFF               v  00 00  1 178      
;    81     for i=1 to length(x) do
    lea rdi,[rbp-48] (symtab[265])        ;#0044D73B: 48:215175 D0               uv 80 20  1 179      
    mov rsi,[rbp] (x)                     ;#0044D73F: 48:213165 00               vu 40 20  1 179      
    mov rdx,257                           ;#0044D743: 48:307302 01010000         uv 04 00  1 180      
    call #0043F28D (:%opLen)              ;#0044D74A: 350 3E1BFFFF               v  00 00  1 180      
    mov qword[rbp-64] (i),1               ;#0044D74F: 48:307105 C0 01000000      uv 00 20  1 181      
    cmp rcx,1                             ;#0044D757: 48:201371 01000000         vu 00 02  1 181      
    jl #0044DA25                          ;#0044D75E: 017214 C1020000            v  00 00  1 182      
;    82 --      s &= sprint(x[i])
;    83         xi = x[i]
    mov rdi,[rbp-64] (i)                  ;#0044D764: 48:213175 C0               uv 80 20  1 183      
    lea rcx,[rbp-32] (xi)                 ;#0044D768: 48:215115 E0               vu 02 20  1 183      
    mov rsi,[rbp] (x)                     ;#0044D76C: 48:213165 00               uv 40 20  1 184      
    mov rdx,257                           ;#0044D770: 48:307302 01010000         vu 04 00  1 184      
    call #00441675 (:%pSubse1)            ;#0044D777: 350 F93EFFFF               v  00 00  1 185      
;    84         if l=-1 then
    mov rax,[rbp-8] (l)                   ;#0044D77C: 48:213105 F8               uv 01 20  1 186      
    cmp rax,-1                            ;#0044D780: 48:203370 FF               uv 00 01  1 187 01   
    jne #0044D810                         ;#0044D784: 017205 86000000            v  00 00  1 187      
;    85             s &= sprint(xi)
    mov rcx,11                            ;#0044D78A: 48:307301 0B000000         uv 02 00  1 188      
    mov rdx,91                            ;#0044D791: 48:307302 5B000000         vu 04 00  1 188      
    call #004428DB (:%opFrame) (sprint)   ;#0044D798: 350 3E51FFFF               v  00 00  1 189      
    mov rdi,[rbp+40] (prevebp)            ;#0044D79D: 48:213175 28               uv 80 20  1 190      
    mov rax,[rdi-32]                      ;#0044D7A1: 48:213107 E0               uv 01 80  1 193 80 *80*
    xor rbx,rbx                           ;#0044D7A5: 48:061333                  vu 08 08  1 193      
    mov r15,h4                            ;#0044D7A8: 49:277 0000000000000040    uv 8000 00  1 194      
    cmp rax,r15                           ;#0044D7B2: 4C:071370                  uv 00 8001  1 195 8000   
    jl #0044D7C2                          ;#0044D7B5: 174 0B                     v  00 00  1 195      
    add qword[rbx+rax*4-16],1             ;#0044D7B7: 48:203104203 F0 01         u  00 09  3 196      
    cmp eax,261                           ;#0044D7BD: 075 05010000               vu 00 01  1 198      
    mov [rbp] (x),rax                     ;#0044D7C2: 48:211105 00               uv 00 21  1 199      
    mov qword[retaddr],#0044D7D3          ;#0044D7C6: 48:307105 20 D3D74400      vu 00 20  1 199      
    jmp #0044D2DF (code:sprint)           ;#0044D7CE: 351 0CFBFFFF               v  00 00  1 200      
    push rax                              ;#0044D7D3: 120                        uv 00 01  1 201      
    mov rcx,[rbp-56] (symtab[266])        ;#0044D7D4: 48:213115 C8               vu 02 20  1 201      
    mov r15,h4                            ;#0044D7D8: 49:277 0000000000000040    uv 8000 00  1 202      
    cmp rcx,r15                           ;#0044D7E2: 4C:071371                  uv 00 8002  1 203 8000   
    jle #0044D7F7                         ;#0044D7E5: 176 10                     v  00 00  1 203      
    sub qword[rbx+rcx*4-16],1             ;#0044D7E7: 48:203154213 F0 01         u  00 0A  3 204      
    jne #0044D7F7                         ;#0044D7ED: 165 08                     v  00 00  1 206      
    mov rdx,rcx                           ;#0044D7EF: 48:213321                  uv 04 02  1 207      
    call #004422DA (:%pDealloc)           ;#0044D7F2: 350 E34AFFFF               v  00 00  1 207      
    pop dword[rbp-56] (symtab[266])       ;#0044D7F7: 217105 C8                  np 00 20  3 208      
    lea rdx,[rbp-24] (s)                  ;#0044D7FA: 48:215125 E8               uv 04 20  1 211      
    lea rdi,[rbp-24] (s)                  ;#0044D7FE: 48:215175 E8               vu 80 20  1 211      
    lea rcx,[rbp-56] (symtab[266])        ;#0044D802: 48:215115 C8               uv 02 20  1 212      
    call #00440021 (:%opConcat)           ;#0044D806: 350 1628FFFF               v  00 00  1 212      
    jmp #0044D9DB                         ;#0044D80B: 351 CB010000               v  00 00  1 213      
;    86         else
;    87             if l>length(s) then
    lea rdi,[rbp-72] (symtab[270])        ;#0044D810: 48:215175 B8               uv 80 20  1 214      
    mov rsi,[rbp-24] (s)                  ;#0044D814: 48:213165 E8               vu 40 20  1 214      
    mov rdx,260                           ;#0044D818: 48:307302 04010000         uv 04 00  1 215      
    call #0043F28D (:%opLen)              ;#0044D81F: 350 691AFFFF               v  00 00  1 215      
    cmp rax,rcx                           ;#0044D824: 48:071310                  uv 00 03  1 216      
    jle #0044D934                         ;#0044D827: 017216 07010000            v  00 00  1 216      
;    88                 s &= sprint(xi,l-length(s),nest+1)
    lea rdi,[rbp-72] (symtab[270])        ;#0044D82D: 48:215175 B8               uv 80 20  1 217      
    mov rdx,260                           ;#0044D831: 48:307302 04010000         vu 04 00  1 217      
    call #0043F28D (:%opLen)              ;#0044D838: 350 501AFFFF               v  00 00  1 218      
    lea rdi,[rbp-40] (symtab[263])        ;#0044D83D: 48:215175 D8               uv 80 20  1 219      
    mov rcx,rax                           ;#0044D841: 48:211301                  vu 02 01  1 219      
    mov rax,[rbp-72] (symtab[270])        ;#0044D844: 48:213105 B8               uv 01 20  1 220      
    call #0043F4D8 (:%opSub)              ;#0044D848: 350 8B1CFFFF               v  00 00  1 220      
    lea rdi,[rbp-80] (symtab[271])        ;#0044D84D: 48:215175 B0               uv 80 20  1 221      
    mov rcx,[rbp-16] (nest)               ;#0044D851: 48:213115 F0               vu 02 20  1 221      
    mov rax,qword[#00402030]              ;#0044D855: 48:213005 D447FBFF         uv 01 00  1 222      
    call #0043F4AF (:%opAdd)              ;#0044D85C: 350 4E1CFFFF               v  00 00  1 222      
    mov rcx,11                            ;#0044D861: 48:307301 0B000000         uv 02 00  1 223      
    mov rdx,91                            ;#0044D868: 48:307302 5B000000         vu 04 00  1 223      
    call #004428DB (:%opFrame) (sprint)   ;#0044D86F: 350 6750FFFF               v  00 00  1 224      
    mov rdi,[rbp+40] (prevebp)            ;#0044D874: 48:213175 28               uv 80 20  1 225      
    mov rax,[rdi-32]                      ;#0044D878: 48:213107 E0               uv 01 80  1 228 80 *80*
    xor rbx,rbx                           ;#0044D87C: 48:061333                  vu 08 08  1 228      
    mov r15,h4                            ;#0044D87F: 49:277 0000000000000040    uv 8000 00  1 229      
    cmp rax,r15                           ;#0044D889: 4C:071370                  uv 00 8001  1 230 8000   
    jl #0044D899                          ;#0044D88C: 174 0B                     v  00 00  1 230      
    add qword[rbx+rax*4-16],1             ;#0044D88E: 48:203104203 F0 01         u  00 09  3 231      
    cmp eax,261                           ;#0044D894: 075 05010000               vu 00 01  1 233      
    mov [rbp] (x),rax                     ;#0044D899: 48:211105 00               uv 00 21  1 234      
    mov rdi,[rbp+40] (prevebp)            ;#0044D89D: 48:213175 28               vu 80 20  1 234      
    mov rax,[rdi-40]                      ;#0044D8A1: 48:213107 D8               uv 01 80  1 237    *80*
    xor rbx,rbx                           ;#0044D8A5: 48:061333                  vu 08 08  1 237      
    mov r15,h4                            ;#0044D8A8: 49:277 0000000000000040    uv 8000 00  1 238      
    cmp rax,r15                           ;#0044D8B2: 4C:071370                  uv 00 8001  1 239 8000   
    jl #0044D8C2                          ;#0044D8B5: 174 0B                     v  00 00  1 239      
    add qword[rbx+rax*4-16],1             ;#0044D8B7: 48:203104203 F0 01         u  00 09  3 240      
    cmp eax,263                           ;#0044D8BD: 075 07010000               vu 00 01  1 242      
    mov [rbp-8] (l),rax                   ;#0044D8C2: 48:211105 F8               uv 00 21  1 243      
    mov rdi,[rbp+40] (prevebp)            ;#0044D8C6: 48:213175 28               vu 80 20  1 243      
    mov rax,[rdi-80]                      ;#0044D8CA: 48:213107 B0               uv 01 80  1 246    *80*
    xor rbx,rbx                           ;#0044D8CE: 48:061333                  vu 08 08  1 246      
    mov r15,h4                            ;#0044D8D1: 49:277 0000000000000040    uv 8000 00  1 247      
    cmp rax,r15                           ;#0044D8DB: 4C:071370                  uv 00 8001  1 248 8000   
    jl #0044D8EB                          ;#0044D8DE: 174 0B                     v  00 00  1 248      
    add qword[rbx+rax*4-16],1             ;#0044D8E0: 48:203104203 F0 01         u  00 09  3 249      
    cmp eax,271                           ;#0044D8E6: 075 0F010000               vu 00 01  1 251      
    mov [rbp-16] (nest),rax               ;#0044D8EB: 48:211105 F0               uv 00 21  1 252      
    mov qword[retaddr],#0044D8FC          ;#0044D8EF: 48:307105 20 FCD84400      vu 00 20  1 252      
    jmp #0044D2DF (code:sprint)           ;#0044D8F7: 351 E3F9FFFF               v  00 00  1 253      
    push rax                              ;#0044D8FC: 120                        uv 00 01  1 254      
    mov rdi,[rbp-56] (symtab[266])        ;#0044D8FD: 48:213175 C8               vu 80 20  1 254      
    mov r15,h4                            ;#0044D901: 49:277 0000000000000040    uv 8000 00  1 255      
    cmp rdi,r15                           ;#0044D90B: 4C:071377                  uv 00 8080  1 256 8000   
    jle #0044D920                         ;#0044D90E: 176 10                     v  00 00  1 256      
    sub qword[rbx+rdi*4-16],1             ;#0044D910: 48:203154273 F0 01         u  00 88  3 257      
    jne #0044D920                         ;#0044D916: 165 08                     v  00 00  1 259      
    mov rdx,rdi                           ;#0044D918: 48:213327                  uv 04 80  1 260      
    call #004422DA (:%pDealloc)           ;#0044D91B: 350 BA49FFFF               v  00 00  1 260      
    pop dword[rbp-56] (symtab[266])       ;#0044D920: 217105 C8                  np 00 20  3 261      
    lea rdx,[rbp-24] (s)                  ;#0044D923: 48:215125 E8               uv 04 20  1 264      
    lea rdi,[rbp-24] (s)                  ;#0044D927: 48:215175 E8               vu 80 20  1 264      
    lea rcx,[rbp-56] (symtab[266])        ;#0044D92B: 48:215115 C8               uv 02 20  1 265      
    call #00440021 (:%opConcat)           ;#0044D92F: 350 ED26FFFF               v  00 00  1 265      
;    89             end if
;    90             if length(s)>=l then
    lea rdi,[rbp-72] (symtab[270])        ;#0044D934: 48:215175 B8               uv 80 20  1 266      
    mov rsi,[rbp-24] (s)                  ;#0044D938: 48:213165 E8               vu 40 20  1 266      
    mov rdx,260                           ;#0044D93C: 48:307302 04010000         uv 04 00  1 267      
    call #0043F28D (:%opLen)              ;#0044D943: 350 4519FFFF               v  00 00  1 267      
    mov rax,[rbp-8] (l)                   ;#0044D948: 48:213105 F8               uv 01 20  1 268      
    cmp rcx,rax                           ;#0044D94C: 48:071301                  uv 00 03  1 269 01   
    jl #0044D9DB                          ;#0044D94F: 017214 86000000            v  00 00  1 269      
;    91                 if nest=0 then
    mov rdi,[rbp-16] (nest)               ;#0044D955: 48:213175 F0               uv 80 20  1 270      
    cmp rdi,0                             ;#0044D959: 48:203377 00               uv 00 80  1 271 80   
    jne #0044D9AE                         ;#0044D95D: 165 4F                     v  00 00  1 271      
;    92                     s = s[1..l-2]
    lea rdi,[rbp-40] (symtab[263])        ;#0044D95F: 48:215175 D8               uv 80 20  1 272      
    mov rcx,rax                           ;#0044D963: 48:211301                  vu 02 01  1 272      
    mov rax,[#00402098] (WIN32)           ;#0044D966: 48:213005 2B47FBFF         uv 01 00  1 273      
    call #0043F4D8 (:%opSub)              ;#0044D96D: 350 661BFFFF               v  00 00  1 273      
    lea rdx,[rbp-24] (s)                  ;#0044D972: 48:215125 E8               uv 04 20  1 274      
    mov rcx,1                             ;#0044D976: 48:307301 01000000         vu 02 00  1 274      
    push #0044D998                        ;#0044D97D: 150 98D94400               uv 00 00  1 275      
    push rdx                              ;#0044D982: 122                        vu 00 04  1 275      
    push qword[rbp-40] (symtab[263])      ;#0044D983: 377165 D8                  np 00 20  2 276      
    push 1                                ;#0044D986: 152 01                     uv 00 00  1 278      
    mov rsi,[rbp-24] (s)                  ;#0044D988: 48:213165 E8               vu 40 20  1 278      
    mov rdx,260                           ;#0044D98C: 48:307302 04010000         uv 04 00  1 279      
    jmp #00440F1F (:%pSubss)              ;#0044D993: 351 8735FFFF               v  00 00  1 279      
;    93                     s &= ".."
    lea rdx,[rbp-24] (s)                  ;#0044D998: 48:215125 E8               uv 04 20  1 280      
    lea rdi,[rbp-24] (s)                  ;#0044D99C: 48:215175 E8               vu 80 20  1 280      
    lea rcx,qword[#00402320]              ;#0044D9A0: 48:215015 7949FBFF         uv 02 00  1 281      
    call #00440021 (:%opConcat)           ;#0044D9A7: 350 7526FFFF               v  00 00  1 281      
    jmp #0044D9CE                         ;#0044D9AC: 353 20                     v  00 00  1 282      
;    94                 else
;    95                     s = s[1..l]
    lea rdx,[rbp-24] (s)                  ;#0044D9AE: 48:215125 E8               uv 04 20  1 283      
    mov rcx,1                             ;#0044D9B2: 48:307301 01000000         vu 02 00  1 283      
    push #0044D9CE                        ;#0044D9B9: 150 CED94400               uv 00 00  1 284      
    push rdx                              ;#0044D9BE: 122                        vu 00 04  1 284      
    push rax                              ;#0044D9BF: 120                        uv 00 01  1 285      
    push 1                                ;#0044D9C0: 152 01                     vu 00 00  1 285      
    mov rdx,260                           ;#0044D9C2: 48:307302 04010000         uv 04 00  1 286      
    jmp #00440F1F (:%pSubss)              ;#0044D9C9: 351 5135FFFF               v  00 00  1 286      
;    96                 end if
;    97                 return s
    mov rax,[rbp-24] (s)                  ;#0044D9CE: 48:213105 E8               uv 01 20  1 287      
    mov [rbp-24] (s),rbx                  ;#0044D9D2: 48:211135 E8               vu 00 28  1 287      
    jmp #0044298D (:%opRetf)              ;#0044D9D6: 351 B24FFFFF               v  00 00  1 288      
;    98             end if
;    99         end if
;   100         if i<length(x) then
    lea rdi,[rbp-72] (symtab[270])        ;#0044D9DB: 48:215175 B8               uv 80 20  1 289      
    mov rsi,[rbp] (x)                     ;#0044D9DF: 48:213165 00               vu 40 20  1 289      
    mov rdx,257                           ;#0044D9E3: 48:307302 01010000         uv 04 00  1 290      
    call #0043F28D (:%opLen)              ;#0044D9EA: 350 9E18FFFF               v  00 00  1 290      
    mov rdi,[rbp-64] (i)                  ;#0044D9EF: 48:213175 C0               uv 80 20  1 291      
    cmp rdi,rcx                           ;#0044D9F3: 48:071317                  uv 00 82  1 292 80   
    jge #0044DA0C                         ;#0044D9F6: 175 14                     v  00 00  1 292      
;   101             s &= ','
    lea rdx,[rbp-24] (s)                  ;#0044D9F8: 48:215125 E8               uv 04 20  1 293      
    lea rdi,[rbp-24] (s)                  ;#0044D9FC: 48:215175 E8               vu 80 20  1 293      
    lea rcx,qword[#004022A0]              ;#0044DA00: 48:215015 9948FBFF         uv 02 00  1 294      
    call #00440021 (:%opConcat)           ;#0044DA07: 350 1526FFFF               v  00 00  1 294      
;   102         end if
;   103     end for
    mov rax,[rbp-64] (i)                  ;#0044DA0C: 48:213105 C0               uv 01 20  1 295      
    mov rsi,[rbp-48] (symtab[265])        ;#0044DA10: 48:213165 D0               vu 40 20  1 295      
    add rax,1                             ;#0044DA14: 48:203300 01               uv 01 01  1 296      
    cmp rax,rsi                           ;#0044DA18: 48:073306                  uv 00 41  1 297 01   
    mov [rbp-64] (i),rax                  ;#0044DA1B: 48:211105 C0               vu 00 21  1 297      
    jle #0044D764                         ;#0044DA1F: 017216 3FFDFFFF            v  00 00  1 298      
;   104     s &= "}"
    lea rdx,[rbp-24] (s)                  ;#0044DA25: 48:215125 E8               uv 04 20  1 299      
    lea rdi,[rbp-24] (s)                  ;#0044DA29: 48:215175 E8               vu 80 20  1 299      
    lea rcx,qword[#00402330]              ;#0044DA2D: 48:215015 FC48FBFF         uv 02 00  1 300      
    call #00440021 (:%opConcat)           ;#0044DA34: 350 E825FFFF               v  00 00  1 300      
;   105     return s
    mov rax,[rbp-24] (s)                  ;#0044DA39: 48:213105 E8               uv 01 20  1 301      
    mov [rbp-24] (s),rbx                  ;#0044DA3D: 48:211135 E8               vu 00 28  1 301      
    jmp #0044298D (:%opRetf)              ;#0044DA41: 351 474FFFFF               v  00 00  1 302      
;   106 end function
;   107 
;   108 --DEV move this to pfileioN.e:
;   109 global procedure print(integer fn, object x, integer l=-1)
;   110 -- Print a string representation of any data object.
;   111 -- Alternative: see ppp.e (pp/ppOpt/ppEx).
;   112     puts(fn,sprint(x,l))
;   113 end procedure
;C:\Program Files (x86)\Phix\builtins\pcurrdir.e:
;================================================
;     1 --
;     2 -- pcurrdir.e
;     3 -- ==========
;     4 --
;     5 --  Implements current_dir(). This is automatically included when needed; 
;     6 --  there should be no need to manually include this file.
;     7 --
;     8 --  This was originally coded in asm, however on Windows XP (at least), if
;     9 --  you are in C:\Program Files\Phix and run command.com, it twitches the
;    10 --  directory to C:\PROGRA~1\Phix (as shown in the command prompt window,
;    11 --  nothing whatsoever to do with Phix/c_func, but pure Windows XP stuff).
;    12 --  Even typing exit, to quit command.com and return to cmd.exe, leaves it 
;    13 --  "twitched". I know you really should not use command.com on XP, but 
;    14 --  stuff happens. Anyway, the upshot is that calls to current_dir() should 
;    15 --  never return the latter (C:\PROGRA~1\Phix), therefore we ought to use 
;    16 --  get_proper_path internally, and hence this was recoded in hll.
;    17 --
;    18 --/*
;    19 NB: this is Phix only; it will not work on and may even crash RDS Eu (an 8-bit string thing)
;    20 --*/
;    21 --without debug
;    22 include builtins\pgetpath.e -- not strictly necessary, but why not.
;    23 ----/**/include builtins\pcfunc.e -- not strictly necessary, but why not.
;    24 --include builtins\VM\pgetpathN.e -- not strictly necessary, but why not. [DEAD]
;    25 --include builtins\VM\pcfuncN.e -- not strictly necessary, but why not.
;    26 
;    27 integer init = 0
;    28 atom kernel32, xGetCurrentDirectory
;    29 
;    30 global function current_dir()
;    31 integer l
;    32 --string res
;    33 sequence res    --DEV
;    34     if not init then
    mov rdi,[#004023A8] (init)            ;#00448C57: 48:213075 4A97FBFF         uv 80 00  1   1      
    test rdi,rdi                          ;#00448C5E: 48:205377                  uv 00 80  1   2 80   
    jne #00448D41                         ;#00448C61: 017205 DA000000            v  00 00  1   2      
;    35 --DEV requires locking as per pprintf.e?
;    36         kernel32 = open_dll("kernel32.dll")
    mov rcx,6                             ;#00448C67: 48:307301 06000000         uv 02 00  1   3      
    mov rdx,81                            ;#00448C6E: 48:307302 51000000         vu 04 00  1   3      
    call :%opFrame (open_dll)             ;#00448C75: 350 619CFFFF               v  00 00  1   4      
    mov rsi,qword[#004023C0]              ;#00448C7A: 48:213065 3F97FBFF         uv 40 00  1   5      
    mov [rbp] (filename),rsi              ;#00448C81: 48:211165 00               uv 00 60  1   6 40   
    add qword[rbx+rsi*4-16],1             ;#00448C85: 48:203104263 F0 01         u  00 48  3   8    *40*
    mov qword[retaddr],#00448C98          ;#00448C8B: 48:307105 20 988C4400      vu 00 20  1  10      
    jmp #0044A882 (code:open_dll)         ;#00448C93: 351 EA1B0000               v  00 00  1  11      
    push rax                              ;#00448C98: 120                        uv 00 01  1  12      
    mov rcx,[#004023B0] (kernel32)        ;#00448C99: 48:213015 1097FBFF         vu 02 00  1  12      
    mov r15,h4                            ;#00448CA0: 49:277 0000000000000040    uv 8000 00  1  13      
    cmp rcx,r15                           ;#00448CAA: 4C:071371                  uv 00 8002  1  14 8000   
    jle #00448CBF                         ;#00448CAD: 176 10                     v  00 00  1  14      
    sub qword[rbx+rcx*4-16],1             ;#00448CAF: 48:203154213 F0 01         u  00 0A  3  15      
    jne #00448CBF                         ;#00448CB5: 165 08                     v  00 00  1  17      
    mov rdx,rcx                           ;#00448CB7: 48:213321                  uv 04 02  1  18      
    call #004422DA (:%pDealloc)           ;#00448CBA: 350 1B96FFFF               v  00 00  1  18      
    pop [#004023B0] (kernel32)            ;#00448CBF: 217005 EB96FBFF            np 00 00  3  19      
;    37 --#without reformat
;    38         xGetCurrentDirectory = define_c_func(kernel32, "GetCurrentDirectoryA",
;    39             {C_INT,  -- DWORD nBufferLength // size, in characters, of directory buffer 
;    40              C_PTR}, -- LPTSTR lpBuffer     // address of buffer for current directory
;    41             C_INT)   -- DWORD
    mov rcx,16                            ;#00448CC5: 48:307301 10000000         uv 02 00  1  22      
    mov rdx,73                            ;#00448CCC: 48:307302 49000000         vu 04 00  1  22      
    call :%opFrame (define_c_func)        ;#00448CD3: 350 039CFFFF               v  00 00  1  23      
    mov rax,[#004023B0] (kernel32)        ;#00448CD8: 48:213005 D196FBFF         uv 01 00  1  24      
    mov [rbp] (lib),rax                   ;#00448CDF: 48:211105 00               uv 00 21  1  25 01   
    mov r15,h4                            ;#00448CE3: 49:277 0000000000000040    vu 8000 00  1  25      
    cmp rax,r15                           ;#00448CED: 4C:071370                  uv 00 8001  1  26      
    jl #00448CF8                          ;#00448CF0: 174 06                     v  00 00  1  26      
    add qword[rbx+rax*4-16],1             ;#00448CF2: 48:203104203 F0 01         u  00 09  3  27      
    mov rdi,qword[#004023C8]              ;#00448CF8: 48:213075 C996FBFF         vu 80 00  1  29      
    mov [rbp-8] (fname),rdi               ;#00448CFF: 48:211175 F8               uv 00 A0  1  30      
    add qword[rbx+rdi*4-16],1             ;#00448D03: 48:203104273 F0 01         u  00 88  3  32    *80*
    mov rsi,qword[#004023D0]              ;#00448D09: 48:213065 C096FBFF         vu 40 00  1  34      
    mov [rbp-16] (args),rsi               ;#00448D10: 48:211165 F0               uv 00 60  1  35      
    add qword[rbx+rsi*4-16],1             ;#00448D14: 48:203104263 F0 01         u  00 48  3  37    *40*
    mov qword[return_type],16777220       ;#00448D1A: 48:307105 E8 04000001      vu 00 20  1  39      
    mov qword[retaddr],#00448D2F          ;#00448D22: 48:307105 20 2F8D4400      uv 00 20  1  40      
    jmp #0044A3A8 (code:define_c_func)    ;#00448D2A: 351 79160000               v  00 00  1  40      
    mov [xGetCurrentDirectory],rax        ;#00448D2F: 48:211005 8296FBFF         uv 00 01  1  41      
;    42 --#with reformat
;    43         init = 1
    mov qword[#004023A8] (init),1         ;#00448D36: 48:307005 6796FBFF 01000000 vu 00 00  1  41      
;    44     end if
;    45     l = c_func(xGetCurrentDirectory,{0,NULL})
    mov rcx,10                            ;#00448D41: 48:307301 0A000000         uv 02 00  1  42      
    mov rdx,79                            ;#00448D48: 48:307302 4F000000         vu 04 00  1  42      
    call #004428DB (:%opFrame) (c_func)   ;#00448D4F: 350 879BFFFF               v  00 00  1  43      
    mov rcx,[xGetCurrentDirectory]        ;#00448D54: 48:213015 5D96FBFF         uv 02 00  1  44      
    mov [rbp] (rid),rcx                   ;#00448D5B: 48:211115 00               uv 00 22  1  45 02   
    mov r15,h4                            ;#00448D5F: 49:277 0000000000000040    vu 8000 00  1  45      
    cmp rcx,r15                           ;#00448D69: 4C:071371                  uv 00 8002  1  46      
    jne #00448D81                         ;#00448D6C: 165 13                     v  00 00  1  46      
    mov rsi,307                           ;#00448D6E: 48:307306 33010000         uv 40 00  1  47      
    mov rdi,1251                          ;#00448D75: 48:307307 E3040000         vu 80 00  1  47      
    call #00442D75 (:%pUnassigned)        ;#00448D7C: 350 F49FFFFF               v  00 00  1  48      
    mov rdi,qword[#004023D8]              ;#00448D81: 48:213075 5096FBFF         uv 80 00  1  49      
    mov [rbp-8] (args),rdi                ;#00448D88: 48:211175 F8               uv 00 A0  1  50 80   
    add qword[rbx+rdi*4-16],1             ;#00448D8C: 48:203104273 F0 01         u  00 88  3  52    *80*
    mov qword[retaddr],#00448D9F          ;#00448D92: 48:307105 20 9F8D4400      vu 00 20  1  54      
    jmp #00449946 (code:c_func)           ;#00448D9A: 351 A70B0000               v  00 00  1  55      
    mov [rbp] (l),rax                     ;#00448D9F: 48:211105 00               uv 00 21  1  56      
    mov r15,h4                            ;#00448DA3: 49:277 0000000000000040    vu 8000 00  1  56      
    cmp rax,r15                           ;#00448DAD: 4C:071370                  uv 00 8001  1  57      
    jl #00448DC5                          ;#00448DB0: 174 13                     v  00 00  1  57      
    mov rsi,78                            ;#00448DB2: 48:307306 4E000000         uv 40 00  1  58      
    mov rdi,308                           ;#00448DB9: 48:307307 34010000         vu 80 00  1  58      
    call #00442D75 (:%pUnassigned)        ;#00448DC0: 350 B09FFFFF               v  00 00  1  59      
;    46     if l=0 then return "" end if
    cmp rax,0                             ;#00448DC5: 48:203370 00               uv 00 01  1  60      
    jne #00448DDD                         ;#00448DC9: 165 12                     v  00 00  1  60      
    mov rax,qword[#00402240]              ;#00448DCB: 48:213005 6E94FBFF         uv 01 00  1  61      
    add qword[rbx+rax*4-16],1             ;#00448DD2: 48:203104203 F0 01         u  00 09  3  64    *01*
    jmp #0044298D (:%opRetf)              ;#00448DD8: 351 B09BFFFF               v  00 00  1  66      
;    47     res = repeat(' ',l-1)
    lea rdi,[rbp-16] (symtab[314])        ;#00448DDD: 48:215175 F0               uv 80 20  1  67      
    mov rcx,rax                           ;#00448DE1: 48:211301                  vu 02 01  1  67      
    mov rax,qword[#00402030]              ;#00448DE4: 48:213005 4592FBFF         uv 01 00  1  68      
    call #0043F4D8 (:%opSub)              ;#00448DEB: 350 E866FFFF               v  00 00  1  68      
    lea rdi,[rbp-8] (res)                 ;#00448DF0: 48:215175 F8               uv 80 20  1  69      
    mov rax,32                            ;#00448DF4: 48:307300 20000000         vu 01 00  1  69      
    mov rcx,[rbp-16] (symtab[314])        ;#00448DFB: 48:213115 F0               uv 02 20  1  70      
    call #0043B1E1 (:%opRepCh)            ;#00448DFF: 350 DD23FFFF               v  00 00  1  70      
;    48     l = c_func(xGetCurrentDirectory,{l,res})
    lea rax,[rbp-24] (symtab[315])        ;#00448E04: 48:215105 E8               uv 01 20  1  71      
    mov rdx,2                             ;#00448E08: 48:307302 02000000         vu 04 00  1  71      
    push #00448E40                        ;#00448E0F: 150 408E4400               uv 00 00  1  72      
    push rax                              ;#00448E14: 120                        vu 00 01  1  72      
    mov rsi,[rbp-8] (res)                 ;#00448E15: 48:213165 F8               uv 40 20  1  73      
    mov r15,h4                            ;#00448E19: 49:277 0000000000000040    vu 8000 00  1  73      
    cmp rsi,r15                           ;#00448E23: 4C:071376                  uv 00 8040  1  74      
    jl #00448E33                          ;#00448E26: 174 0B                     v  00 00  1  74      
    add qword[rbx+rsi*4-16],1             ;#00448E28: 48:203104263 F0 01         u  00 48  3  75      
    cmp eax,309                           ;#00448E2E: 075 35010000               vu 00 01  1  77      
    push rsi                              ;#00448E33: 126                        uv 00 40  1  78      
    push qword[rbp] (l)                   ;#00448E34: 377165 00                  np 00 20  2  79      
    mov rdi,[rbp-24] (symtab[315])        ;#00448E37: 48:213175 E8               uv 80 20  1  81      
    jmp #004404BD (:%pMkSq)               ;#00448E3B: 351 7D76FFFF               v  00 00  1  81      
    mov rcx,10                            ;#00448E40: 48:307301 0A000000         uv 02 00  1  82      
    mov rdx,79                            ;#00448E47: 48:307302 4F000000         vu 04 00  1  82      
    call #004428DB (:%opFrame) (c_func)   ;#00448E4E: 350 889AFFFF               v  00 00  1  83      
    mov rax,[xGetCurrentDirectory]        ;#00448E53: 48:213005 5E95FBFF         uv 01 00  1  84      
    mov [rbp] (rid),rax                   ;#00448E5A: 48:211105 00               uv 00 21  1  85 01   
    mov rdi,[rbp+40] (prevebp)            ;#00448E5E: 48:213175 28               vu 80 20  1  85      
    mov rax,[rdi-24]                      ;#00448E62: 48:213107 E8               uv 01 80  1  88    *80*
    xor rbx,rbx                           ;#00448E66: 48:061333                  vu 08 08  1  88      
    mov r15,h4                            ;#00448E69: 49:277 0000000000000040    uv 8000 00  1  89      
    cmp rax,r15                           ;#00448E73: 4C:071370                  uv 00 8001  1  90 8000   
    jl #00448E83                          ;#00448E76: 174 0B                     v  00 00  1  90      
    add qword[rbx+rax*4-16],1             ;#00448E78: 48:203104203 F0 01         u  00 09  3  91      
    cmp eax,315                           ;#00448E7E: 075 3B010000               vu 00 01  1  93      
    mov [rbp-8] (args),rax                ;#00448E83: 48:211105 F8               uv 00 21  1  94      
    mov qword[retaddr],#00448E94          ;#00448E87: 48:307105 20 948E4400      vu 00 20  1  94      
    jmp #00449946 (code:c_func)           ;#00448E8F: 351 B20A0000               v  00 00  1  95      
    mov [rbp] (l),rax                     ;#00448E94: 48:211105 00               uv 00 21  1  96      
    mov r15,h4                            ;#00448E98: 49:277 0000000000000040    vu 8000 00  1  96      
    cmp rax,r15                           ;#00448EA2: 4C:071370                  uv 00 8001  1  97      
    jl #00448EBA                          ;#00448EA5: 174 13                     v  00 00  1  97      
    mov rsi,78                            ;#00448EA7: 48:307306 4E000000         uv 40 00  1  98      
    mov rdi,308                           ;#00448EAE: 48:307307 34010000         vu 80 00  1  98      
    call #00442D75 (:%pUnassigned)        ;#00448EB5: 350 BB9EFFFF               v  00 00  1  99      
;    49     res = get_proper_path(res)
    mov rcx,5                             ;#00448EBA: 48:307301 05000000         uv 02 00  1 100      
    mov rdx,85                            ;#00448EC1: 48:307302 55000000         vu 04 00  1 100      
    call :%opFrame (get_proper_path)      ;#00448EC8: 350 0E9AFFFF               v  00 00  1 101      
    mov rdi,[rbp+40] (prevebp)            ;#00448ECD: 48:213175 28               uv 80 20  1 102      
    mov rax,[rdi-8]                       ;#00448ED1: 48:213107 F8               uv 01 80  1 105 80 *80*
    mov [rdi-8],r15                       ;#00448ED5: 4C:211177 F8               vu 00 8080  1 105      
    mov [rbp] (filepath),rax              ;#00448ED9: 48:211105 00               uv 00 21  1 106      
    mov qword[retaddr],#00448EEA          ;#00448EDD: 48:307105 20 EA8E4400      vu 00 20  1 106      
    jmp #00448F1E (code:get_proper_path)  ;#00448EE5: 351 34000000               v  00 00  1 107      
    push rax                              ;#00448EEA: 120                        uv 00 01  1 108      
    mov rcx,[rbp-8] (res)                 ;#00448EEB: 48:213115 F8               vu 02 20  1 108      
    mov r15,h4                            ;#00448EEF: 49:277 0000000000000040    uv 8000 00  1 109      
    cmp rcx,r15                           ;#00448EF9: 4C:071371                  uv 00 8002  1 110 8000   
    jle #00448F0E                         ;#00448EFC: 176 10                     v  00 00  1 110      
    sub qword[rbx+rcx*4-16],1             ;#00448EFE: 48:203154213 F0 01         u  00 0A  3 111      
    jne #00448F0E                         ;#00448F04: 165 08                     v  00 00  1 113      
    mov rdx,rcx                           ;#00448F06: 48:213321                  uv 04 02  1 114      
    call #004422DA (:%pDealloc)           ;#00448F09: 350 CC93FFFF               v  00 00  1 114      
    pop dword[rbp-8] (res)                ;#00448F0E: 217105 F8                  np 00 20  3 115      
;    50     return res
    mov rax,[rbp-8] (res)                 ;#00448F11: 48:213105 F8               uv 01 20  1 118      
    mov [rbp-8] (res),rbx                 ;#00448F15: 48:211135 F8               vu 00 28  1 118      
    jmp #0044298D (:%opRetf)              ;#00448F19: 351 6F9AFFFF               v  00 00  1 119      
;    51 end function
;    52 
;    53 
;C:\Program Files (x86)\Phix\builtins\pgetpath.e:
;================================================
;     1 --
;     2 --  pgetpath.e
;     3 --  ==========
;     4 --
;     5 -- Implements function get_proper_path(string filepath, object rootdir=0).
;     6 --  This is automatically included when needed; there should be no need 
;     7 --  to manually include this file, and in fact since it is used by both
;     8 --  current_dir() and command_line(), it will often be loaded already.
;     9 --
;    10 -- Converts eg c:\PROGRA~1\edita\EDITA.EXW
;    11 --          to C:\Program Files\Edita\edita.exw.
;    12 --
;    13 --  ie get rid of any short filenames (which are getting rare but will
;    14 --      probably always be around), and perhaps more importantly get the
;    15 --      actual case.
;    16 --
;    17 -- Usage:
;    18 --  actual = get_proper_path(filepath[, rootdir])
;    19 --
;    20 -- rootdir may be omitted, 0 or "", in which case if needed (ie when
;    21 --  filepath[2]!=':') it uses current_dir(). In truth, rootdir only 
;    22 --  exists because of the internal structure of edita.edb, so that 
;    23 --  vedb.exw could fix it, but it is quite likely someone will want 
;    24 --  a value other than current_dir() in some application. If you
;    25 --  already have a full path, just pass the one parameter.
;    26 --
;    27 -- Tested on Phix (0.5.9), RDS Eu 2.4 and 4.0, Windows 7 and XP.
;    28 --
;    29 --!/**/without debug
;    30 --
;    31 --/*
;    32 include builtins\machine.e
;    33 include builtins\dll.e
;    34 include builtins\sort.e
;    35 include builtins\misc.e
;    36 include builtins\file.e
;    37 --*/
;    38 --with trace
;    39 
;    40 --include builtins\VM\pAlloc.e      -- allocate() [now in pHeap.e]
;    41 --include builtins\VM\pprntfN.e
;    42 --include builtins\pprntf.e     --DEV
;    43 --include builtins\VM\pHeap.e       -- allocate()
;    44 --!/**/include builtins\platform.e
;    45 
;    46 ----/**/    include builtins\pcfunc.e   --DEV
;    47 --include builtins\VM\pcfuncN.e
;    48 --/**/  include builtins\pcurrdir.e
;    49 --include builtins\VM\pcurrdirN.e [DEAD, so above should be fine]
;    50 
;    51 --/**/include builtins\peekstr.e
;    52 --  filepaths = {"C:\\Program Files (x86)\\Phix\\builtins\\",
;    53 --               "C:\\Program Files (x86)\\Phix\\"}
;    54 --  filenames = {{1, "pgetpath.e"}, {1, "pcurrdir.e"}, {1, "pcfunc.e"},
;    55 --               {1, "pprntf.e"}, {1, "platform.e"}, {1, "peekstr.e"}}
;    56 --
;    57 
;    58 function cleanUpPath(sequence filepath, object rootdir)
;    59 integer k
;    60     --
;    61     -- First make sure there is a proper filepath.
;    62     --
;    63     if length(filepath)<2 or filepath[2]!=':' then
    mov rdi,[rbp] (filepath)              ;#0044928D: 48:213175 00               uv 80 20  1   1      
    mov rsi,[rbx+rdi*4-24]                ;#00449291: 48:48:213164273 E8         uv 40 88  1   4 80 *80*
    cmp rsi,2                             ;#00449297: 48:203376 02               uv 00 40  1   5 40   
    jl #004492C6                          ;#0044929B: 174 29                     v  00 00  1   5      
    mov rdi,2                             ;#0044929D: 48:307307 02000000         uv 80 00  1   6      
    lea rcx,[rbp-32] (symtab[283])        ;#004492A4: 48:215115 E0               vu 02 20  1   6      
    mov rsi,[rbp] (filepath)              ;#004492A8: 48:213165 00               uv 40 20  1   7      
    mov rdx,278                           ;#004492AC: 48:307302 16010000         vu 04 00  1   7      
    call #00441675 (:%pSubse1)            ;#004492B3: 350 BD83FFFF               v  00 00  1   8      
    mov rcx,[rbp-32] (symtab[283])        ;#004492B8: 48:213115 E0               uv 02 20  1   9      
    cmp rcx,58                            ;#004492BC: 48:203371 3A               uv 00 02  1  10 02   
    je #004493C3                          ;#004492C0: 017204 FD000000            v  00 00  1  10      
;    64         if atom(rootdir) or length(rootdir)=0 then
    mov rax,[rbp-8] (rootdir)             ;#004492C6: 48:213105 F8               uv 01 20  1  11      
    mov r15,h4                            ;#004492CA: 49:277 0000000000000040    vu 8000 00  1  11      
    cmp rax,r15                           ;#004492D4: 4C:071370                  uv 00 8001  1  12      
    jl #004492E5                          ;#004492D7: 174 0C                     v  00 00  1  12      
    mov rdi,[rbx+rax*4-24]                ;#004492D9: 48:48:213174203 E8         uv 80 09  1  13      
    cmp rdi,0                             ;#004492DF: 48:203377 00               uv 00 80  1  14 80   
    jne #0044932C                         ;#004492E3: 165 47                     v  00 00  1  14      
;    65             rootdir = current_dir()
    mov rcx,4                             ;#004492E5: 48:307301 04000000         uv 02 00  1  15      
    mov rdx,83                            ;#004492EC: 48:307302 53000000         vu 04 00  1  15      
    call :%opFrame (current_dir)          ;#004492F3: 350 E395FFFF               v  00 00  1  16      
    mov qword[retaddr],#00449305          ;#004492F8: 48:307105 20 05934400      uv 00 20  1  17      
    jmp #00448C57 (code:current_dir)      ;#00449300: 351 52F9FFFF               v  00 00  1  17      
    push rax                              ;#00449305: 120                        uv 00 01  1  18      
    mov rsi,[rbp-8] (rootdir)             ;#00449306: 48:213165 F8               vu 40 20  1  18      
    mov r15,h4                            ;#0044930A: 49:277 0000000000000040    uv 8000 00  1  19      
    cmp rsi,r15                           ;#00449314: 4C:071376                  uv 00 8040  1  20 8000   
    jle #00449329                         ;#00449317: 176 10                     v  00 00  1  20      
    sub qword[rbx+rsi*4-16],1             ;#00449319: 48:203154263 F0 01         u  00 48  3  21      
    jne #00449329                         ;#0044931F: 165 08                     v  00 00  1  23      
    mov rdx,rsi                           ;#00449321: 48:213326                  uv 04 40  1  24      
    call #004422DA (:%pDealloc)           ;#00449324: 350 B18FFFFF               v  00 00  1  24      
    pop dword[rbp-8] (rootdir)            ;#00449329: 217105 F8                  np 00 20  3  25      
;    66         end if
;    67         if rootdir[length(rootdir)]='\\'
    lea rdi,[rbp-24] (symtab[281])        ;#0044932C: 48:215175 E8               uv 80 20  1  28      
    mov rsi,[rbp-8] (rootdir)             ;#00449330: 48:213165 F8               vu 40 20  1  28      
    mov rdx,279                           ;#00449334: 48:307302 17010000         uv 04 00  1  29      
    call #0043F28D (:%opLen)              ;#0044933B: 350 4D5FFFFF               v  00 00  1  29      
    mov rdi,rcx                           ;#00449340: 48:211317                  uv 80 02  1  30      
    lea rcx,[rbp-32] (symtab[283])        ;#00449343: 48:215115 E0               vu 02 20  1  30      
    mov rdx,279                           ;#00449347: 48:307302 17010000         uv 04 00  1  31      
    call #00441675 (:%pSubse1)            ;#0044934E: 350 2283FFFF               v  00 00  1  31      
    mov rax,[rbp-32] (symtab[283])        ;#00449353: 48:213105 E0               uv 01 20  1  32      
    cmp rax,92                            ;#00449357: 48:203370 5C               uv 00 01  1  33 01   
    je #00449392                          ;#0044935B: 164 35                     v  00 00  1  33      
;    68         or length(filepath)=0 or filepath[1]='\\' then
    mov rdi,[rbp] (filepath)              ;#0044935D: 48:213175 00               uv 80 20  1  34      
    mov rcx,[rbx+rdi*4-24]                ;#00449361: 48:48:213114273 E8         uv 02 88  1  37 80 *80*
    cmp rcx,0                             ;#00449367: 48:203371 00               uv 00 02  1  38 02   
    je #00449392                          ;#0044936B: 164 25                     v  00 00  1  38      
    mov rdi,1                             ;#0044936D: 48:307307 01000000         uv 80 00  1  39      
    lea rcx,[rbp-32] (symtab[283])        ;#00449374: 48:215115 E0               vu 02 20  1  39      
    mov rsi,[rbp] (filepath)              ;#00449378: 48:213165 00               uv 40 20  1  40      
    mov rdx,278                           ;#0044937C: 48:307302 16010000         vu 04 00  1  40      
    call #00441675 (:%pSubse1)            ;#00449383: 350 ED82FFFF               v  00 00  1  41      
    mov rax,[rbp-32] (symtab[283])        ;#00449388: 48:213105 E0               uv 01 20  1  42      
    cmp rax,92                            ;#0044938C: 48:203370 5C               uv 00 01  1  43 01   
    jne #004493A3                         ;#00449390: 165 11                     v  00 00  1  43      
;    69             filepath = rootdir & filepath
    mov rdx,rbp                           ;#00449392: 48:213325                  uv 04 20  1  44      
    lea rdi,[rbp-8] (rootdir)             ;#00449395: 48:215175 F8               vu 80 20  1  44      
    mov rcx,rbp                           ;#00449399: 48:213315                  uv 02 20  1  45      
    call #00440021 (:%opConcat)           ;#0044939C: 350 806CFFFF               v  00 00  1  45      
    jmp #004493C3                         ;#004493A1: 353 20                     v  00 00  1  46      
;    70         else
;    71             filepath = rootdir & '\\' & filepath
    mov rcx,3                             ;#004493A3: 48:307301 03000000         uv 02 00  1  47      
    push #004493C3                        ;#004493AA: 150 C3934400               vu 00 00  1  47      
    push qword[rbp] (filepath)            ;#004493AF: 377165 00                  np 00 20  2  48      
    push qword[#00402300]                 ;#004493B2: 377065 488FFBFF            np 00 00  2  50      
    push qword[rbp-8] (rootdir)           ;#004493B8: 377165 F8                  np 00 20  2  52      
    mov rax,rbp                           ;#004493BB: 48:213305                  uv 01 20  1  54      
    jmp #004402C2 (:%opConcatN)           ;#004493BE: 351 FF6EFFFF               v  00 00  1  54      
;    72         end if
;    73     end if
;    74     --
;    75     -- Replace any / in filepath with \\
;    76     --
;    77     while 1 do
;    78         k = find('/',filepath)
    mov rcx,7                             ;#004493C3: 48:307301 07000000         uv 02 00  1  55      
    mov rdx,75                            ;#004493CA: 48:307302 4B000000         vu 04 00  1  55      
    call #004428DB (:%opFrame) (find)     ;#004493D1: 350 0595FFFF               v  00 00  1  56      
    mov qword[rbp] (x),47                 ;#004493D6: 48:307105 00 2F000000      uv 00 20  1  57      
    mov rdi,[rbp+40] (prevebp)            ;#004493DE: 48:213175 28               vu 80 20  1  57      
    mov rax,[rdi]                         ;#004493E2: 48:213007                  uv 01 80  1  60    *80*
    xor rbx,rbx                           ;#004493E5: 48:061333                  vu 08 08  1  60      
    mov r15,h4                            ;#004493E8: 49:277 0000000000000040    uv 8000 00  1  61      
    cmp rax,r15                           ;#004493F2: 4C:071370                  uv 00 8001  1  62 8000   
    jl #00449402                          ;#004493F5: 174 0B                     v  00 00  1  62      
    add qword[rbx+rax*4-16],1             ;#004493F7: 48:203104203 F0 01         u  00 09  3  63      
    cmp eax,278                           ;#004493FD: 075 16010000               vu 00 01  1  65      
    mov [rbp-8] (s),rax                   ;#00449402: 48:211105 F8               uv 00 21  1  66      
    mov qword[retaddr],#00449413          ;#00449406: 48:307105 20 13944400      vu 00 20  1  66      
    jmp #0043DAD6 (code:find)             ;#0044940E: 351 C346FFFF               v  00 00  1  67      
    mov [rbp-16] (k),rax                  ;#00449413: 48:211105 F0               uv 00 21  1  68      
;    79         if k=0 then exit end if
    cmp rax,0                             ;#00449417: 48:203370 00               vu 00 01  1  68      
    je #00449435                          ;#0044941B: 164 18                     v  00 00  1  69      
;    80         filepath[k] = '\\'
    mov rdi,rax                           ;#0044941D: 48:211307                  uv 80 01  1  70      
    mov rcx,92                            ;#00449420: 48:307301 5C000000         vu 02 00  1  70      
    mov rsi,[rbp] (filepath)              ;#00449427: 48:213165 00               uv 40 20  1  71      
    mov rax,rbp                           ;#0044942B: 48:213305                  vu 01 20  1  71      
    call #00440C54 (:%pRepe1)             ;#0044942E: 350 2178FFFF               v  00 00  1  72      
;    81     end while
    jmp #004493C3                         ;#00449433: 353 8E                     v  00 00  1  73      
;    82     --
;    83     -- check for and remove any \..\ in filepath
;    84     --
;    85     while 1 do
;    86         k = match("\\..\\",filepath)
    mov rcx,17                            ;#00449435: 48:307301 11000000         uv 02 00  1  74      
    mov rdx,77                            ;#0044943C: 48:307302 4D000000         vu 04 00  1  74      
    call #004428DB (:%opFrame) (match)    ;#00449443: 350 9394FFFF               v  00 00  1  75      
    mov rcx,qword[#00402348]              ;#00449448: 48:213015 F98EFBFF         uv 02 00  1  76      
    mov [rbp] (s1),rcx                    ;#0044944F: 48:211115 00               uv 00 22  1  77 02   
    add qword[rbx+rcx*4-16],1             ;#00449453: 48:203104213 F0 01         u  00 0A  3  79    *02*
    mov rdi,[rbp+40] (prevebp)            ;#00449459: 48:213175 28               vu 80 20  1  81      
    mov rax,[rdi]                         ;#0044945D: 48:213007                  uv 01 80  1  84    *80*
    xor rbx,rbx                           ;#00449460: 48:061333                  vu 08 08  1  84      
    mov r15,h4                            ;#00449463: 49:277 0000000000000040    uv 8000 00  1  85      
    cmp rax,r15                           ;#0044946D: 4C:071370                  uv 00 8001  1  86 8000   
    jl #0044947D                          ;#00449470: 174 0B                     v  00 00  1  86      
    add qword[rbx+rax*4-16],1             ;#00449472: 48:203104203 F0 01         u  00 09  3  87      
    cmp eax,278                           ;#00449478: 075 16010000               vu 00 01  1  89      
    mov [rbp-8] (s2),rax                  ;#0044947D: 48:211105 F8               uv 00 21  1  90      
    mov qword[retaddr],#0044948E          ;#00449481: 48:307105 20 8E944400      vu 00 20  1  90      
    jmp #00449700 (code:match)            ;#00449489: 351 72020000               v  00 00  1  91      
    mov [rbp-16] (k),rax                  ;#0044948E: 48:211105 F0               uv 00 21  1  92      
;    87         if k=0 then exit end if
    cmp rax,0                             ;#00449492: 48:203370 00               vu 00 01  1  92      
    je #004495CA                          ;#00449496: 017204 2E010000            v  00 00  1  93      
;    88         for j=k-1 to 1 by -1 do
    lea rdi,[rbp-40] (symtab[286])        ;#0044949C: 48:215175 D8               uv 80 20  1  94      
    mov rcx,rax                           ;#004494A0: 48:211301                  vu 02 01  1  94      
    mov rax,qword[#00402030]              ;#004494A3: 48:213005 868BFBFF         uv 01 00  1  95      
    call #0043F4D8 (:%opSub)              ;#004494AA: 350 2960FFFF               v  00 00  1  95      
    mov rdx,[rbp-48] (j)                  ;#004494AF: 48:213125 D0               uv 04 20  1  96      
    mov r15,h4                            ;#004494B3: 49:277 0000000000000040    vu 8000 00  1  96      
    cmp rdx,r15                           ;#004494BD: 4C:071372                  uv 00 8004  1  97      
    jle #004494CF                         ;#004494C0: 176 0D                     v  00 00  1  97      
    sub qword[rbx+rdx*4-16],1             ;#004494C2: 48:203154223 F0 01         u  00 0C  3  98      
    jne #004494CF                         ;#004494C8: 165 05                     v  00 00  1 100      
    call #004422DA (:%pDealloc)           ;#004494CA: 350 0B8EFFFF               v  00 00  1 101      
    mov rdi,[rbp-40] (symtab[286])        ;#004494CF: 48:213175 D8               uv 80 20  1 102      
    mov r15,h4                            ;#004494D3: 49:277 0000000000000040    vu 8000 00  1 102      
    cmp rdi,r15                           ;#004494DD: 4C:071377                  uv 00 8080  1 103      
    jl #004494F7                          ;#004494E0: 174 15                     v  00 00  1 103      
    mov al,120                            ;#004494E2: 260 78                     uv 01 00  1 104      
    mov rdi,286                           ;#004494E4: 48:307307 1E010000         vu 80 00  1 104      
    mov rsi,1                             ;#004494EB: 48:307306 01000000         uv 40 00  1 105      
    call #00442DC8 (:%pRTErn)             ;#004494F2: 350 D198FFFF               v  00 00  1 105      
    mov [rbp-48] (j),rdi                  ;#004494F7: 48:211175 D0               uv 00 A0  1 106      
    cmp rdi,1                             ;#004494FB: 48:201377 01000000         vu 00 80  1 106      
    jl #00449581                          ;#00449502: 174 7D                     v  00 00  1 107      
;    89             if filepath[j]='\\' then
    mov rdi,[rbp-48] (j)                  ;#00449504: 48:213175 D0               uv 80 20  1 108      
    lea rcx,[rbp-32] (symtab[283])        ;#00449508: 48:215115 E0               vu 02 20  1 108      
    mov rsi,[rbp] (filepath)              ;#0044950C: 48:213165 00               uv 40 20  1 109      
    mov rdx,278                           ;#00449510: 48:307302 16010000         vu 04 00  1 109      
    call #00441675 (:%pSubse1)            ;#00449517: 350 5981FFFF               v  00 00  1 110      
    mov rcx,[rbp-32] (symtab[283])        ;#0044951C: 48:213115 E0               uv 02 20  1 111      
    cmp rcx,92                            ;#00449520: 48:203371 5C               uv 00 02  1 112 02   
    jne #00449569                         ;#00449524: 165 43                     v  00 00  1 112      
;    90                 -- remove "\\xxx\\.." (keeping filepath[k+3]==='\\')
;    91 --/**/          filepath[j..k+2] = ""                                           --/* -- Phix
    mov rax,[rbp-16] (k)                  ;#00449526: 48:213105 F0               uv 01 20  1 113      
    add rax,2                             ;#0044952A: 48:203300 02               uv 01 01  1 114 01   
    mov rdx,rax                           ;#0044952E: 48:213320                  uv 04 01  1 115 01   
    mov [rbp-24] (symtab[281]),rax        ;#00449531: 48:211105 E8               vu 00 21  1 115      
    shl rdx,1                             ;#00449535: 48:321342                  u  04 04  1 116      
    jno #00449543                         ;#00449538: 161 09                     v  00 00  1 116      
    lea rdi,[rbp-24] (symtab[281])        ;#0044953A: 48:215175 E8               uv 80 20  1 117      
    call #00442DA9 (:%pAddiii)            ;#0044953E: 350 6698FFFF               v  00 00  1 117      
    mov rcx,1                             ;#00449543: 48:307301 01000000         uv 02 00  1 118      
    push #00449563                        ;#0044954A: 150 63954400               vu 00 00  1 118      
    push qword[#00402240]                 ;#0044954F: 377065 EB8CFBFF            np 00 00  2 119      
    push qword[rbp-24] (symtab[281])      ;#00449555: 377165 E8                  np 00 20  2 121      
    push qword[rbp-48] (j)                ;#00449558: 377165 D0                  np 00 20  2 123      
    mov rax,rbp                           ;#0044955B: 48:213305                  uv 01 20  1 125      
    jmp #00440524 (:%pReps)               ;#0044955E: 351 C16FFFFF               v  00 00  1 125      
;    92                 filepath = filepath[1..j-1] & filepath[k+3..length(filepath)]   --*/ -- RDS
;    93                 k = 0 -- signal found
    mov [rbp-16] (k),rbx                  ;#00449563: 48:211135 F0               uv 00 28  1 126      
;    94                 exit
    jmp #00449581                         ;#00449567: 353 18                     v  00 00  1 126      
;    95             end if
;    96         end for
    mov rdi,[rbp-48] (j)                  ;#00449569: 48:213175 D0               uv 80 20  1 127      
    mov rdx,1                             ;#0044956D: 48:307302 01000000         vu 04 00  1 127      
    add rdi,-1                            ;#00449574: 48:203307 FF               uv 80 80  1 128      
    cmp rdi,rdx                           ;#00449578: 48:073372                  uv 00 84  1 129 80   
    mov [rbp-48] (j),rdi                  ;#0044957B: 48:211175 D0               vu 00 A0  1 129      
    jge #00449504                         ;#0044957F: 175 83                     v  00 00  1 130      
;    97         if k!=0 then
    mov rsi,[rbp-16] (k)                  ;#00449581: 48:213165 F0               uv 40 20  1 131      
    cmp rsi,0                             ;#00449585: 48:203376 00               uv 00 40  1 132 40   
    je #00449435                          ;#00449589: 017204 A6FEFFFF            v  00 00  1 132      
;    98             puts(1,"Warning, cannot cleanup "&filepath&'\n')
    mov rcx,3                             ;#0044958F: 48:307301 03000000         uv 02 00  1 133      
    push #004495B3                        ;#00449596: 150 B3954400               vu 00 00  1 133      
    push qword[#004020E8] (BRIGHT_GREEN)  ;#0044959B: 377065 478BFBFF            np 00 00  2 134      
    push qword[rbp] (filepath)            ;#004495A1: 377165 00                  np 00 20  2 136      
    push qword[#00402350]                 ;#004495A4: 377065 A68DFBFF            np 00 00  2 138      
    lea rax,[rbp-56] (symtab[289])        ;#004495AA: 48:215105 C8               uv 01 20  1 140      
    jmp #004402C2 (:%opConcatN)           ;#004495AE: 351 0F6DFFFF               v  00 00  1 140      
    mov rax,1                             ;#004495B3: 48:307300 01000000         uv 01 00  1 141      
    mov rdx,[rbp-56] (symtab[289])        ;#004495BA: 48:213125 C8               vu 04 20  1 141      
    call #0043E218 (:%opPuts)             ;#004495BE: 350 554CFFFF               v  00 00  1 142      
;    99 --          ?9/0
;   100             exit
    jmp #004495CA                         ;#004495C3: 353 05                     v  00 00  1 143      
;   101         end if
;   102     end while
    jmp #00449435                         ;#004495C5: 351 6BFEFFFF               v  00 00  1 144      
;   103     --
;   104     -- repeat for any \.\
;   105     --
;   106     while 1 do
;   107         k = match("\\.\\",filepath)
    mov rcx,17                            ;#004495CA: 48:307301 11000000         uv 02 00  1 145      
    mov rdx,77                            ;#004495D1: 48:307302 4D000000         vu 04 00  1 145      
    call #004428DB (:%opFrame) (match)    ;#004495D8: 350 FE92FFFF               v  00 00  1 146      
    mov rcx,qword[#00402358]              ;#004495DD: 48:213015 748DFBFF         uv 02 00  1 147      
    mov [rbp] (s1),rcx                    ;#004495E4: 48:211115 00               uv 00 22  1 148 02   
    add qword[rbx+rcx*4-16],1             ;#004495E8: 48:203104213 F0 01         u  00 0A  3 150    *02*
    mov rdi,[rbp+40] (prevebp)            ;#004495EE: 48:213175 28               vu 80 20  1 152      
    mov rax,[rdi]                         ;#004495F2: 48:213007                  uv 01 80  1 155    *80*
    xor rbx,rbx                           ;#004495F5: 48:061333                  vu 08 08  1 155      
    mov r15,h4                            ;#004495F8: 49:277 0000000000000040    uv 8000 00  1 156      
    cmp rax,r15                           ;#00449602: 4C:071370                  uv 00 8001  1 157 8000   
    jl #00449612                          ;#00449605: 174 0B                     v  00 00  1 157      
    add qword[rbx+rax*4-16],1             ;#00449607: 48:203104203 F0 01         u  00 09  3 158      
    cmp eax,278                           ;#0044960D: 075 16010000               vu 00 01  1 160      
    mov [rbp-8] (s2),rax                  ;#00449612: 48:211105 F8               uv 00 21  1 161      
    mov qword[retaddr],#00449623          ;#00449616: 48:307105 20 23964400      vu 00 20  1 161      
    jmp #00449700 (code:match)            ;#0044961E: 351 DD000000               v  00 00  1 162      
    mov [rbp-16] (k),rax                  ;#00449623: 48:211105 F0               uv 00 21  1 163      
;   108         if k=0 then exit end if
    cmp rax,0                             ;#00449627: 48:203370 00               vu 00 01  1 163      
    je #0044966B                          ;#0044962B: 164 3E                     v  00 00  1 164      
;   109         -- remove "\\." (keeping filepath[k+2]==='\\')
;   110 --/**/  filepath[k..k+1] = ""                                           --/* -- Phix
    add rax,1                             ;#0044962D: 48:203300 01               uv 01 01  1 165      
    mov rdx,rax                           ;#00449631: 48:213320                  uv 04 01  1 166 01   
    mov [rbp-24] (symtab[281]),rax        ;#00449634: 48:211105 E8               vu 00 21  1 166      
    shl rdx,1                             ;#00449638: 48:321342                  u  04 04  1 167      
    jno #00449646                         ;#0044963B: 161 09                     v  00 00  1 167      
    lea rdi,[rbp-24] (symtab[281])        ;#0044963D: 48:215175 E8               uv 80 20  1 168      
    call #00442DA9 (:%pAddiii)            ;#00449641: 350 6397FFFF               v  00 00  1 168      
    mov rcx,1                             ;#00449646: 48:307301 01000000         uv 02 00  1 169      
    push #00449666                        ;#0044964D: 150 66964400               vu 00 00  1 169      
    push qword[#00402240]                 ;#00449652: 377065 E88BFBFF            np 00 00  2 170      
    push qword[rbp-24] (symtab[281])      ;#00449658: 377165 E8                  np 00 20  2 172      
    push qword[rbp-16] (k)                ;#0044965B: 377165 F0                  np 00 20  2 174      
    mov rax,rbp                           ;#0044965E: 48:213305                  uv 01 20  1 176      
    jmp #00440524 (:%pReps)               ;#00449661: 351 BE6EFFFF               v  00 00  1 176      
;   111         filepath = filepath[1..k-1] & filepath[k+2..length(filepath)]   --*/ -- RDS
;   112     end while
    jmp #004495CA                         ;#00449666: 351 5FFFFFFF               v  00 00  1 177      
;   113     --
;   114     -- repeat for any \\
;   115     --
;   116     while 1 do
;   117         k = match("\\\\",filepath)
    mov rcx,17                            ;#0044966B: 48:307301 11000000         uv 02 00  1 178      
    mov rdx,77                            ;#00449672: 48:307302 4D000000         vu 04 00  1 178      
    call #004428DB (:%opFrame) (match)    ;#00449679: 350 5D92FFFF               v  00 00  1 179      
    mov rdi,qword[#00402360]              ;#0044967E: 48:213075 DB8CFBFF         uv 80 00  1 180      
    mov [rbp] (s1),rdi                    ;#00449685: 48:211175 00               uv 00 A0  1 181 80   
    add qword[rbx+rdi*4-16],1             ;#00449689: 48:203104273 F0 01         u  00 88  3 183    *80*
    mov rdi,[rbp+40] (prevebp)            ;#0044968F: 48:213175 28               vu 80 20  1 185      
    mov rax,[rdi]                         ;#00449693: 48:213007                  uv 01 80  1 188    *80*
    xor rbx,rbx                           ;#00449696: 48:061333                  vu 08 08  1 188      
    mov r15,h4                            ;#00449699: 49:277 0000000000000040    uv 8000 00  1 189      
    cmp rax,r15                           ;#004496A3: 4C:071370                  uv 00 8001  1 190 8000   
    jl #004496B3                          ;#004496A6: 174 0B                     v  00 00  1 190      
    add qword[rbx+rax*4-16],1             ;#004496A8: 48:203104203 F0 01         u  00 09  3 191      
    cmp eax,278                           ;#004496AE: 075 16010000               vu 00 01  1 193      
    mov [rbp-8] (s2),rax                  ;#004496B3: 48:211105 F8               uv 00 21  1 194      
    mov qword[retaddr],#004496C4          ;#004496B7: 48:307105 20 C4964400      vu 00 20  1 194      
    jmp #00449700 (code:match)            ;#004496BF: 351 3C000000               v  00 00  1 195      
    mov [rbp-16] (k),rax                  ;#004496C4: 48:211105 F0               uv 00 21  1 196      
;   118         if k=0 then exit end if
    cmp rax,0                             ;#004496C8: 48:203370 00               vu 00 01  1 196      
    je #004496F3                          ;#004496CC: 164 25                     v  00 00  1 197      
;   119         -- remove 1st "\\" of 2
;   120 --/**/  filepath[k..k] = ""                                             --/* -- Phix
    mov rcx,1                             ;#004496CE: 48:307301 01000000         uv 02 00  1 198      
    push #004496EE                        ;#004496D5: 150 EE964400               vu 00 00  1 198      
    push qword[#00402240]                 ;#004496DA: 377065 608BFBFF            np 00 00  2 199      
    push qword[rbp-16] (k)                ;#004496E0: 377165 F0                  np 00 20  2 201      
    push qword[rbp-16] (k)                ;#004496E3: 377165 F0                  np 00 20  2 203      
    mov rax,rbp                           ;#004496E6: 48:213305                  uv 01 20  1 205      
    jmp #00440524 (:%pReps)               ;#004496E9: 351 366EFFFF               v  00 00  1 205      
;   121         filepath = filepath[1..k-1] & filepath[k+1..length(filepath)]   --*/ -- RDS
;   122     end while
    jmp #0044966B                         ;#004496EE: 351 78FFFFFF               v  00 00  1 206      
;   123 
;   124     return filepath
    mov rax,[rbp] (filepath)              ;#004496F3: 48:213105 00               uv 01 20  1 207      
    mov [rbp] (filepath),rbx              ;#004496F7: 48:211135 00               vu 00 28  1 207      
    jmp #0044298D (:%opRetf)              ;#004496FB: 351 8D92FFFF               v  00 00  1 208      
;   125 end function
;   126 
;   127 atom kernel32, buffer
;   128 integer xGetLongPathName
;   129 --integer xGetLastError
;   130 constant MAX_PATH = 260
;   131 
;   132 integer gppinit
;   133         gppinit = 0
;   134 
;   135 -- (The following is because RDS Eu 2.4 does not support parameter defaults)
;   136 --DEV long gone?
;   137 -- (And I still want Edita to run on 2.4 as it is faster than OpenEu 4.0)
;   138 -- (Though if you really want it to be fast, run it on Phix!)
;   139 
;   140 --/**/global function get_proper_path(sequence filepath, object rootdir=0)
    mov rsi,[rbp-8] (rootdir)             ;#00448F1E: 48:213165 F8               uv 40 20  1   1      
    mov r15,h4                            ;#00448F22: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#00448F2C: 4C:071376                  uv 00 8040  1   2      
    jne #00448F35                         ;#00448F2F: 165 04                     v  00 00  1   2      
    mov [rbp-8] (rootdir),rbx             ;#00448F31: 48:211135 F8               uv 00 28  1   3      
;   141 --/*
;   142 global function get_proper_path(sequence filepath, object rootdir)
;   143 --*/
;   144 --
;   145 -- For an input filepath of eg c:\PROGRA~1\edita\EDITA.EXW,
;   146 --  returns eg C:\Program Files\Edita\edita.exw.
;   147 --  This routine was originally written so that edita does 
;   148 --  not accidentally open the same file twice. However, the
;   149 --  same processing ought to be performed for current_dir(),
;   150 --  and command_line().
;   151 --
;   152 -- Should work equally well for files and directories.
;   153 --  Of course the result is fairly meaningless if the 
;   154 --  the specified file or path does not exist, but if
;   155 --  you can open the input the same should be true for
;   156 --  the output.
;   157 --
;   158 -- rootdir may be omitted if filepath[2] is ':', or if 
;   159 --  current_dir() gives the correct directory, otherwise
;   160 --  specify the right directory to use. Specifically in
;   161 --  in the case of edita.edb/vedb.exw, filepath would be 
;   162 --  from T_files and rootdir from T_directories.
;   163 --
;   164 --/*
;   165 atom pFilePath
;   166 --*/
;   167 integer l
;   168 sequence res
;   169         if not gppinit then
    mov rdi,[#00402388] (gppinit)         ;#00448F35: 48:213075 4C94FBFF         vu 80 00  1   3      
    test rdi,rdi                          ;#00448F3C: 48:205377                  uv 00 80  1   4      
    jne #0044901F                         ;#00448F3F: 017205 DA000000            v  00 00  1   4      
;   170             --DEV locking as per pprntf.e
;   171             kernel32 = open_dll("kernel32")
    mov rcx,6                             ;#00448F45: 48:307301 06000000         uv 02 00  1   5      
    mov rdx,81                            ;#00448F4C: 48:307302 51000000         vu 04 00  1   5      
    call :%opFrame (open_dll)             ;#00448F53: 350 8399FFFF               v  00 00  1   6      
    mov rcx,qword[#00402390]              ;#00448F58: 48:213015 3194FBFF         uv 02 00  1   7      
    mov [rbp] (filename),rcx              ;#00448F5F: 48:211115 00               uv 00 22  1   8 02   
    add qword[rbx+rcx*4-16],1             ;#00448F63: 48:203104213 F0 01         u  00 0A  3  10    *02*
    mov qword[retaddr],#00448F76          ;#00448F69: 48:307105 20 768F4400      vu 00 20  1  12      
    jmp #0044A882 (code:open_dll)         ;#00448F71: 351 0C190000               v  00 00  1  13      
    push rax                              ;#00448F76: 120                        uv 00 01  1  14      
    mov rax,[#00402368] (kernel32)        ;#00448F77: 48:213005 EA93FBFF         vu 01 00  1  14      
    mov r15,h4                            ;#00448F7E: 49:277 0000000000000040    uv 8000 00  1  15      
    cmp rax,r15                           ;#00448F88: 4C:071370                  uv 00 8001  1  16 8000   
    jle #00448F9D                         ;#00448F8B: 176 10                     v  00 00  1  16      
    sub qword[rbx+rax*4-16],1             ;#00448F8D: 48:203154203 F0 01         u  00 09  3  17      
    jne #00448F9D                         ;#00448F93: 165 08                     v  00 00  1  19      
    mov rdx,rax                           ;#00448F95: 48:213320                  uv 04 01  1  20      
    call #004422DA (:%pDealloc)           ;#00448F98: 350 3D93FFFF               v  00 00  1  20      
    pop [#00402368] (kernel32)            ;#00448F9D: 217005 C593FBFF            np 00 00  3  21      
;   172 --#without reformat
;   173             xGetLongPathName = define_c_func(kernel32,"GetLongPathNameA",
;   174                 {C_POINTER, --  LPCTSTR lpszShortPath // input
;   175                  C_POINTER, --  LPTSTR lpszLongPath   // output
;   176                  C_LONG},   --  DWORD cchBuffer // specifies size of *lpszLongPath
;   177                 C_INT)  -- DWORD
    mov rcx,16                            ;#00448FA3: 48:307301 10000000         uv 02 00  1  24      
    mov rdx,73                            ;#00448FAA: 48:307302 49000000         vu 04 00  1  24      
    call :%opFrame (define_c_func)        ;#00448FB1: 350 2599FFFF               v  00 00  1  25      
    mov rsi,[#00402368] (kernel32)        ;#00448FB6: 48:213065 AB93FBFF         uv 40 00  1  26      
    mov [rbp] (lib),rsi                   ;#00448FBD: 48:211165 00               uv 00 60  1  27 40   
    mov r15,h4                            ;#00448FC1: 49:277 0000000000000040    vu 8000 00  1  27      
    cmp rsi,r15                           ;#00448FCB: 4C:071376                  uv 00 8040  1  28      
    jl #00448FD6                          ;#00448FCE: 174 06                     v  00 00  1  28      
    add qword[rbx+rsi*4-16],1             ;#00448FD0: 48:203104263 F0 01         u  00 48  3  29      
    mov rdi,qword[#00402398]              ;#00448FD6: 48:213075 BB93FBFF         vu 80 00  1  31      
    mov [rbp-8] (fname),rdi               ;#00448FDD: 48:211175 F8               uv 00 A0  1  32      
    add qword[rbx+rdi*4-16],1             ;#00448FE1: 48:203104273 F0 01         u  00 88  3  34    *80*
    mov rcx,qword[#004023A0]              ;#00448FE7: 48:213015 B293FBFF         vu 02 00  1  36      
    mov [rbp-16] (args),rcx               ;#00448FEE: 48:211115 F0               uv 00 22  1  37      
    add qword[rbx+rcx*4-16],1             ;#00448FF2: 48:203104213 F0 01         u  00 0A  3  39    *02*
    mov qword[return_type],16777220       ;#00448FF8: 48:307105 E8 04000001      vu 00 20  1  41      
    mov qword[retaddr],#0044900D          ;#00449000: 48:307105 20 0D904400      uv 00 20  1  42      
    jmp #0044A3A8 (code:define_c_func)    ;#00449008: 351 9B130000               v  00 00  1  42      
    mov [xGetLongPathName],rax            ;#0044900D: 48:211005 6493FBFF         uv 00 01  1  43      
;   178 --          xGetLastError = define_c_func(kernel32, "GetLastError",
;   179 --              {},
;   180 --              C_INT)      -- DWORD
;   181 --29/7/15:
;   182 --          buffer = allocate(MAX_PATH)
;   183 --#with reformat
;   184             gppinit = 1
    mov qword[#00402388] (gppinit),1      ;#00449014: 48:307005 6993FBFF 01000000 vu 00 00  1  43      
;   185         end if
;   186 --puts(1,"get_proper_path, filepath:\n")
;   187 --pp(filepath)
;   188         filepath = cleanUpPath(filepath,rootdir)
    mov rcx,8                             ;#0044901F: 48:307301 08000000         uv 02 00  1  44      
    mov rdx,277                           ;#00449026: 48:307302 15010000         vu 04 00  1  44      
    call :%opFrame (cleanUpPath)          ;#0044902D: 350 A998FFFF               v  00 00  1  45      
    mov rdi,[rbp+40] (prevebp)            ;#00449032: 48:213175 28               uv 80 20  1  46      
    mov rax,[rdi]                         ;#00449036: 48:213007                  uv 01 80  1  49 80 *80*
    mov [rdi],r15                         ;#00449039: 4C:211077                  vu 00 8080  1  49      
    mov [rbp] (filepath),rax              ;#0044903C: 48:211105 00               uv 00 21  1  50      
    mov rdi,[rbp+40] (prevebp)            ;#00449040: 48:213175 28               vu 80 20  1  50      
    mov rax,[rdi-8]                       ;#00449044: 48:213107 F8               uv 01 80  1  53    *80*
    mov [rbp-8] (rootdir),rax             ;#00449048: 48:211105 F8               uv 00 21  1  54 01   
    mov qword[retaddr],#00449059          ;#0044904C: 48:307105 20 59904400      vu 00 20  1  54      
    jmp #0044928D (code:cleanUpPath)      ;#00449054: 351 34020000               v  00 00  1  55      
    push rax                              ;#00449059: 120                        uv 00 01  1  56      
    mov rsi,[rbp] (filepath)              ;#0044905A: 48:213165 00               vu 40 20  1  56      
    mov r15,h4                            ;#0044905E: 49:277 0000000000000040    uv 8000 00  1  57      
    cmp rsi,r15                           ;#00449068: 4C:071376                  uv 00 8040  1  58 8000   
    jle #0044907D                         ;#0044906B: 176 10                     v  00 00  1  58      
    sub qword[rbx+rsi*4-16],1             ;#0044906D: 48:203154263 F0 01         u  00 48  3  59      
    jne #0044907D                         ;#00449073: 165 08                     v  00 00  1  61      
    mov rdx,rsi                           ;#00449075: 48:213326                  uv 04 40  1  62      
    call #004422DA (:%pDealloc)           ;#00449078: 350 5D92FFFF               v  00 00  1  62      
    pop dword[rbp] (filepath)             ;#0044907D: 217105 00                  np 00 20  3  63      
;   189 --pp(filepath)
;   190 --29/7/15:
;   191         buffer = allocate(MAX_PATH)
    mov rcx,260                           ;#00449080: 48:307301 04010000         uv 02 00  1  66      
    lea rdi,[#00402370] (buffer)          ;#00449087: 48:215075 E292FBFF         vu 80 00  1  66      
    call #00442460 (:%pAlloc)             ;#0044908E: 350 CD93FFFF               v  00 00  1  67      
;   192 
;   193 --/**/  l = c_func(xGetLongPathName,{filepath,buffer,MAX_PATH}) --/* -- Phix
    lea rax,[rbp-32] (symtab[304])        ;#00449093: 48:215105 E0               uv 01 20  1  68      
    mov rdx,3                             ;#00449097: 48:307302 03000000         vu 04 00  1  68      
    push #004490F3                        ;#0044909E: 150 F3904400               uv 00 00  1  69      
    push rax                              ;#004490A3: 120                        vu 00 01  1  69      
    push 260                              ;#004490A4: 150 04010000               uv 00 00  1  70      
    mov rdi,[#00402370] (buffer)          ;#004490A9: 48:213075 C092FBFF         vu 80 00  1  70      
    mov r15,h4                            ;#004490B0: 49:277 0000000000000040    uv 8000 00  1  71      
    cmp rdi,r15                           ;#004490BA: 4C:071377                  uv 00 8080  1  72 8000   
    jl #004490CA                          ;#004490BD: 174 0B                     v  00 00  1  72      
    add qword[rbx+rdi*4-16],1             ;#004490BF: 48:203104273 F0 01         u  00 88  3  73      
    cmp eax,293                           ;#004490C5: 075 25010000               vu 00 01  1  75      
    push rdi                              ;#004490CA: 127                        uv 00 80  1  76      
    mov rcx,[rbp] (filepath)              ;#004490CB: 48:213115 00               vu 02 20  1  76      
    mov r15,h4                            ;#004490CF: 49:277 0000000000000040    uv 8000 00  1  77      
    cmp rcx,r15                           ;#004490D9: 4C:071371                  uv 00 8002  1  78 8000   
    jl #004490E9                          ;#004490DC: 174 0B                     v  00 00  1  78      
    add qword[rbx+rcx*4-16],1             ;#004490DE: 48:203104213 F0 01         u  00 0A  3  79      
    cmp eax,297                           ;#004490E4: 075 29010000               vu 00 01  1  81      
    push rcx                              ;#004490E9: 121                        uv 00 02  1  82      
    mov rdi,[rbp-32] (symtab[304])        ;#004490EA: 48:213175 E0               vu 80 20  1  82      
    jmp #004404BD (:%pMkSq)               ;#004490EE: 351 CA73FFFF               v  00 00  1  83      
    mov rcx,10                            ;#004490F3: 48:307301 0A000000         uv 02 00  1  84      
    mov rdx,79                            ;#004490FA: 48:307302 4F000000         vu 04 00  1  84      
    call #004428DB (:%opFrame) (c_func)   ;#00449101: 350 D597FFFF               v  00 00  1  85      
    mov rax,[xGetLongPathName]            ;#00449106: 48:213005 6B92FBFF         uv 01 00  1  86      
    mov [rbp] (rid),rax                   ;#0044910D: 48:211105 00               uv 00 21  1  87 01   
    mov r15,h4                            ;#00449111: 49:277 0000000000000040    vu 8000 00  1  87      
    cmp rax,r15                           ;#0044911B: 4C:071370                  uv 00 8001  1  88      
    jne #00449133                         ;#0044911E: 165 13                     v  00 00  1  88      
    mov rsi,294                           ;#00449120: 48:307306 26010000         uv 40 00  1  89      
    mov rdi,1251                          ;#00449127: 48:307307 E3040000         vu 80 00  1  89      
    call #00442D75 (:%pUnassigned)        ;#0044912E: 350 429CFFFF               v  00 00  1  90      
    mov rdi,[rbp+40] (prevebp)            ;#00449133: 48:213175 28               uv 80 20  1  91      
    mov rax,[rdi-32]                      ;#00449137: 48:213107 E0               uv 01 80  1  94 80 *80*
    xor rbx,rbx                           ;#0044913B: 48:061333                  vu 08 08  1  94      
    mov r15,h4                            ;#0044913E: 49:277 0000000000000040    uv 8000 00  1  95      
    cmp rax,r15                           ;#00449148: 4C:071370                  uv 00 8001  1  96 8000   
    jl #00449158                          ;#0044914B: 174 0B                     v  00 00  1  96      
    add qword[rbx+rax*4-16],1             ;#0044914D: 48:203104203 F0 01         u  00 09  3  97      
    cmp eax,304                           ;#00449153: 075 30010000               vu 00 01  1  99      
    mov [rbp-8] (args),rax                ;#00449158: 48:211105 F8               uv 00 21  1 100      
    mov qword[retaddr],#00449169          ;#0044915C: 48:307105 20 69914400      vu 00 20  1 100      
    jmp #00449946 (code:c_func)           ;#00449164: 351 DD070000               v  00 00  1 101      
    mov [rbp-16] (l),rax                  ;#00449169: 48:211105 F0               uv 00 21  1 102      
    mov r15,h4                            ;#0044916D: 49:277 0000000000000040    vu 8000 00  1 102      
    cmp rax,r15                           ;#00449177: 4C:071370                  uv 00 8001  1 103      
    jl #0044918F                          ;#0044917A: 174 13                     v  00 00  1 103      
    mov rsi,78                            ;#0044917C: 48:307306 4E000000         uv 40 00  1 104      
    mov rdi,299                           ;#00449183: 48:307307 2B010000         vu 80 00  1 104      
    call #00442D75 (:%pUnassigned)        ;#0044918A: 350 E69BFFFF               v  00 00  1 105      
;   194         pFilePath = allocate_string(filepath)                        -- RDS
;   195         l = c_func(xGetLongPathName,{pFilePath,buffer,MAX_PATH})     -- RDS
;   196         free(pFilePath)                                         --*/ -- RDS
;   197         if l=0 then
    cmp rax,0                             ;#0044918F: 48:203370 00               uv 00 01  1 106      
    jne #004491A5                         ;#00449193: 165 10                     v  00 00  1 106      
;   198 --printf(1,"returning original, error code is %d\n",c_func(xGetLastError,{}))
;   199             res = filepath
    mov rsi,[rbp] (filepath)              ;#00449195: 48:213165 00               uv 40 20  1 107      
    mov [rbp-24] (res),rsi                ;#00449199: 48:211165 E8               uv 00 60  1 108 40   
    add qword[rbx+rsi*4-16],1             ;#0044919D: 48:203104263 F0 01         u  00 48  3 110    *40*
    jmp #0044920C                         ;#004491A3: 353 67                     v  00 00  1 112      
;   200         else
;   201             res = peek_string(buffer)
    mov rcx,3                             ;#004491A5: 48:307301 03000000         uv 02 00  1 113      
    mov rdx,87                            ;#004491AC: 48:307302 57000000         vu 04 00  1 113      
    call :%opFrame (peek_string)          ;#004491B3: 350 2397FFFF               v  00 00  1 114      
    mov rcx,[#00402370] (buffer)          ;#004491B8: 48:213015 B191FBFF         uv 02 00  1 115      
    mov [rbp] (addr),rcx                  ;#004491BF: 48:211115 00               uv 00 22  1 116 02   
    mov r15,h4                            ;#004491C3: 49:277 0000000000000040    vu 8000 00  1 116      
    cmp rcx,r15                           ;#004491CD: 4C:071371                  uv 00 8002  1 117      
    jl #004491D8                          ;#004491D0: 174 06                     v  00 00  1 117      
    add qword[rbx+rcx*4-16],1             ;#004491D2: 48:203104213 F0 01         u  00 0A  3 118      
    mov qword[retaddr],#004491E5          ;#004491D8: 48:307105 20 E5914400      vu 00 20  1 120      
    jmp #00449225 (code:peek_string)      ;#004491E0: 351 40000000               v  00 00  1 121      
    push rax                              ;#004491E5: 120                        uv 00 01  1 122      
    mov rdi,[rbp-24] (res)                ;#004491E6: 48:213175 E8               vu 80 20  1 122      
    mov r15,h4                            ;#004491EA: 49:277 0000000000000040    uv 8000 00  1 123      
    cmp rdi,r15                           ;#004491F4: 4C:071377                  uv 00 8080  1 124 8000   
    jle #00449209                         ;#004491F7: 176 10                     v  00 00  1 124      
    sub qword[rbx+rdi*4-16],1             ;#004491F9: 48:203154273 F0 01         u  00 88  3 125      
    jne #00449209                         ;#004491FF: 165 08                     v  00 00  1 127      
    mov rdx,rdi                           ;#00449201: 48:213327                  uv 04 80  1 128      
    call #004422DA (:%pDealloc)           ;#00449204: 350 D190FFFF               v  00 00  1 128      
    pop dword[rbp-24] (res)               ;#00449209: 217105 E8                  np 00 20  3 129      
;   202         end if 
;   203 -- then ?0 ?c_func(xGetLastError,{}) poke(buffer,0) end if 
;   204 --pp(peek_string(buffer))
;   205 --      return peek_string(buffer)
;   206         free(buffer)
    mov rax,[#00402370] (buffer)          ;#0044920C: 48:213005 5D91FBFF         uv 01 00  1 132      
    call #004424C8 (:%pFree)              ;#00449213: 350 B092FFFF               v  00 00  1 132      
;   207         return res
    mov rax,[rbp-24] (res)                ;#00449218: 48:213105 E8               uv 01 20  1 133      
    mov [rbp-24] (res),rbx                ;#0044921C: 48:211135 E8               vu 00 28  1 133      
    jmp #0044298D (:%opRetf)              ;#00449220: 351 6897FFFF               v  00 00  1 134      
;   208 end function
;   209 
;   210 -- (sequence filepath should be fine, but needs testing and I'm not convinced that
;   211 --  get_proper_path deals well with dword_sequences/errors on nested subsequences)
;   212 global function canonical_path(string filepath)
;   213     return get_proper_path(filepath)
;   214 end function
;   215 
;C:\Program Files (x86)\Phix\builtins\peekstr.e:
;===============================================
;     1 --
;     2 -- peekstr.e
;     3 -- =========
;     4 --
;     5 --  Implements peek_string(). This is automatically included when needed; 
;     6 --  there should be no need to manually include this file.
;     7 --
;     8 --  This is a temporary file, in that the point of putting this in a
;     9 --  totally separate file was to create a challenge for conversion to
;    10 --  an opcode/#ilasm construct thing. Of course that may lead to this 
;    11 --  file being deleted, moved, or (ab)used for a different purpose.
;    12 --
;    13 -- Erm, there should probably be a peek_stringW version of this...
;    14 --
;    15 global function peek_string(atom addr)
;    16 integer ch
;    17 --string res
;    18 sequence res
;    19     res = ""
    mov rsi,qword[#00402240]              ;#00449225: 48:213065 1490FBFF         uv 40 00  1   1      
    mov [rbp-16] (res),rsi                ;#0044922C: 48:211165 F0               uv 00 60  1   2 40   
    add qword[rbx+rsi*4-16],1             ;#00449230: 48:203104263 F0 01         u  00 48  3   4    *40*
;    20     while 1 do
;    21         ch = peek(addr)
    lea rdi,[rbp-8] (ch)                  ;#00449236: 48:215175 F8               vu 80 20  1   6      
    mov rsi,[rbp] (addr)                  ;#0044923A: 48:213165 00               uv 40 20  1   7      
    xor rcx,rcx                           ;#0044923E: 48:061311                  vu 02 02  1   7      
    mov rdx,1                             ;#00449241: 48:307302 01000000         uv 04 00  1   8      
    call #0043ED6C (:%opPeekNx)           ;#00449248: 350 1F5BFFFF               v  00 00  1   8      
;    22         if ch=0 then exit end if
    mov rcx,[rbp-8] (ch)                  ;#0044924D: 48:213115 F8               uv 02 20  1   9      
    cmp rcx,0                             ;#00449251: 48:203371 00               uv 00 02  1  10 02   
    je #00449280                          ;#00449255: 164 29                     v  00 00  1  10      
;    23         res &= ch
    lea rdx,[rbp-16] (res)                ;#00449257: 48:215125 F0               uv 04 20  1  11      
    lea rdi,[rbp-16] (res)                ;#0044925B: 48:215175 F0               vu 80 20  1  11      
    lea rcx,[rbp-8] (ch)                  ;#0044925F: 48:215115 F8               uv 02 20  1  12      
    xor rax,rax                           ;#00449263: 48:061300                  vu 01 01  1  12      
    call #0043FC15 (:%opApnd)             ;#00449266: 350 AA69FFFF               v  00 00  1  13      
;    24         addr += 1
    mov rdi,rbp                           ;#0044926B: 48:213375                  uv 80 20  1  14      
    mov rcx,[rbp] (addr)                  ;#0044926E: 48:213115 00               vu 02 20  1  14      
    mov rax,qword[#00402030]              ;#00449272: 48:213005 B78DFBFF         uv 01 00  1  15      
    call #0043F4AF (:%opAdd)              ;#00449279: 350 3162FFFF               v  00 00  1  15      
;    25     end while
    jmp #00449236                         ;#0044927E: 353 B6                     v  00 00  1  16      
;    26     return res
    mov rax,[rbp-16] (res)                ;#00449280: 48:213105 F0               uv 01 20  1  17      
    mov [rbp-16] (res),rbx                ;#00449284: 48:211135 F0               vu 00 28  1  17      
    jmp #0044298D (:%opRetf)              ;#00449288: 351 0097FFFF               v  00 00  1  18      
;    27 end function
;    28 
;    29 -- A challenge exists to recode this something like:
;    30 --  #ilASM{%%opPeekStr::
;    31 --          -- implements res=peek_str(addr)
;    32 --          -- NB: calling convention (as hard-coded in pilx86.e):
;    33 --          --  <opUnassigned addr if rqd>
;    34 --          --  mov e?x,[addr]
;    35 --          --  leamov e?x,res ; (var address)
;    36 --          --  call opPeekStr
;    37 --          ...
;    38 --        }
;    39 --  (peek_string was chosen as it seemed relatively straightforward, 
;    40 --   boy how wrong can one person be... ;-)
;    41 
;    42 -- Some asm snippets for finding the length (totally untested, would need to time them all anyway)
;    43 
;    44 --peek_string
;    45 --===========
;    46 --     #57,                        -- push   edi
;    47 --     #8B, #7C, #24, #08,         -- mov    edi, [esp+8]
;    48 --     #B9, #FF, #FF, #FF, #FF,    -- mov    ecx, #FFFFFFFF
;    49 --     #B0, #00,                   -- mov    al, 0
;    50 --     #FC,                        -- cld
;    51 --     #F2, #AE,                   -- repne  scasb
;    52 --     #B8, #FE, #FF, #FF, #FF,    -- mov    eax, #FFFFFFFE
;    53 --     #29, #C8,                   -- sub    eax, ecx
;    54 --     #5F,                        -- pop    edi
;    55 --     #C2, #04, #00               -- ret    4    -- pop 4 bytes off the 
;    56 
;    57 --proc strlen,pointer 
;    58 --  push ebx 
;    59 --  mov eax,[pointer]           ; get pointer s 
;    60 --  lea edx,[eax+3]             ; pointer+3 used in the end 
;    61 --  l1:
;    62 --  mov ebx,[eax]               ; read 4 bytes of string 
;    63 --  add eax,4                   ; increment pointer 
;    64 --  lea ecx,[ebx-0x01010101]    ; subtract 1 from each byte 
;    65 --  not ebx                     ; invert all bytes 
;    66 --  and ecx,ebx                 ; and these two 
;    67 --  and ecx,0x80808080          ; test all sign bits 
;    68 --  jz l1                       ; no zero bytes, continue loop 
;    69 --  mov ebx,ecx 
;    70 --  shr ebx,16 
;    71 --  test ecx,0x00008080         ; test first two bytes 
;    72 --  cmovz ecx,ebx               ; shift if not in first 2 bytes 
;    73 --  lea ebx,[eax+2]             ; .. and increment pointer by 2 
;    74 --  cmovz eax,ebx 
;    75 --  add cl,cl                   ; test first byte 
;    76 --  sbb eax,edx                 ; compute length 
;    77 --  pop ebx 
;    78 --  ret 
;    79 --endp
;    80 ----
;    81 ----;edx=string start
;    82 --  lea ecx,[edx+4]             ; load and increment pointer
;    83 --  mov ebx,[edx]               ; read first 4 bytes
;    84 --  lea edx,[edx+7]             ; pointer+7 used in the end
;    85 --  ._1:
;    86 --  lea eax,[ebx-0x01010101]    ; subtract 1 from each byte
;    87 --  xor ebx,-1                  ; invert all bytes
;    88 --  and eax,ebx                 ; and these two
;    89 --  mov ebx,[ecx]               ; read next 4 bytes
;    90 --  add ecx,4                   ; increment pointer
;    91 --  and eax,0x80808080          ; test all sign bits
;    92 --  jz ._1                      ; no zero bytes, continue loop
;    93 --  test eax,0x00008080         ; test first two bytes
;    94 --  jnz ._2
;    95 --  shr eax,16                  ; not in the first 2 bytes
;    96 --  add ecx,2
;    97 --  ._2:
;    98 --  shl al,1                    ; use carry flag to avoid a branch
;    99 --  sbb ecx,edx                 ; compute length
;   100 --  lea edx,[edx-7]
;   101 --
;   102 --
;   103 --??:
;   104 --use32
;   105 --strlen: ;uses the 'C' calling convention the pointer is pushed on the stack
;   106 --
;   107 --  ;registers are saved and result is returned in eax
;   108 --  push ecx
;   109 --  push esi
;   110 --  mov esi,[esp+4+8]
;   111 --  mov eax,[esi]
;   112 --  and esi,-4
;   113 --  .l1:
;   114 --  add esi,4
;   115 --  lea ecx,[eax-1010101h]
;   116 --  not eax
;   117 --  and ecx,eax
;   118 --  mov eax,[esi]
;   119 --  and ecx,80808080h
;   120 --  jz .l1
;   121 --  bsf eax,ecx
;   122 --  sub esi,[esp+4+8]
;   123 --  sar eax,3
;   124 --  lea eax,[eax+esi-4]
;   125 --  pop esi
;   126 --  pop ecx
;   127 --  ret
;   128 --
;   129 --
;   130 
;   131 -- ...and here is a copy of opAlloc, as an example/reference:
;   132 --
;   133 --  Notes: emapedx4 would be inlined, search for "fld qword" in pcfunc.e
;   134 --          for examples, and we may need to have a table of addresses
;   135 --          (etc) so that pdiag.e can handle eg e30ume->e94 properly.
;   136 --         locations of down53 & near53 could easily be added to VMep,
;   137 --          as could HeapAlloc, hHeap, FltWrk, not that we are actually
;   138 --          translating this here. However if they could be pure hll, 
;   139 --          then so much the better.
;   140 --         e37atambpi to be handled as per prntf.e (snippet below.)
;   141 --
;   142 --emapedx4: ; exception here mapped to e92vhnbaavEmapToEsp4feh
;   143 --  cmp byte[edx-1],0x12
;   144 --  jne @b
;   145 --  fld qword[edx]
;   146 --  mov edx,FltWrk
;   147 --  fldcw [down53]
;   148 --  fistp qword[edx]
;   149 --  fldcw [near53]
;   150 --  mov edx,[edx]
;   151 --  ret
;   152 --
;   153 --opAlloc:              ; [edi]=allocate([esi])
;   154 --;-------
;   155 --  trc opAlloc
;   156 --  mov edx,[esi]
;   157 --  cmp edx,h4
;   158 --  jl @f
;   159 --      shl edx,2
;   160 --      mov [emapTo],esi
;   161 --      call emapedx4
;   162 --      jne e37atambpi  ; argument to allocate must be positive integer
;   163 --  @@:
;   164 --
;   165 --  test edx,edx
;   166 --  js e37atambpi       ; argument to allocate must be positive integer
;   167 --  push edi
;   168 --  invoke HeapAlloc, [hHeap], 0, edx
;   169 --; ; just quietly return 0 on failure, when not in debug mode
;   170 --if debug
;   171 --  test eax,eax
;   172 --  jz e77phroomopAlloc
;   173 --end if
;   174 --  mov ecx,eax
;   175 --  pop edi                 ; target addr
;   176 --  shl ecx,1
;   177 --  jno @f
;   178 --      mov [FltWrk],eax
;   179 --      fild [FltWrk]
;   180 --      jmp StoreFlt        ;; store result (invokes dealloc if needed)
;   181 --  @@:
;   182 --  mov edx,[edi]
;   183 --  xor ebx,ebx
;   184 --  cmp edx,h4
;   185 --  mov [edi],eax
;   186 --  jle @f
;   187 --      dec dword[ebx+edx*4-8]
;   188 --      jz deallocX
;   189 --  @@:
;   190 --  ret
;   191 --
;   192 ---- and (from prntf.e):
;   193 ----/**/                #ilasm{ mov al,70
;   194 ----/**/                    --  xor edi,edi     -- ep1 unused
;   195 ----/**/                    --  xor esi,esi     -- ep2 unused
;   196 ----/**/                        call :%pRTErn}  -- fatal error (pUnassigned/dev/tmp)
;   197 --
;   198 
;   199 -- ...and here is a copy of opPeek:
;   200 --      Notes:  it is peek(object) but peek_string(atom), remember.
;   201 --              hence plenty of validation here you just don't need.
;   202 --              AllocStr could easily be added to VMep.
;   203 
;   204 --opPeek:
;   205 --;------
;   206 --  trc opPeek
;   207 --;calling convention:                              octal:         binary:          code:
;   208 --;  mov ecx,p1     ; target addr                   271         B9 imm32        mov ecx,imm32
;   209 --;  mov edx,p2     ; addr or {addr,len}            272         BA imm32        mov edx,imm32
;   210 --  mov edi,[edx]
;   211 --  xor eax,eax
;   212 --  cmp edi,h4
;   213 --  jl @f
;   214 --      shl edi,2
;   215 --      mov [emapTo],edx
;   216 --      call emapedi4
;   217 --;emapedi4:    ; exception here mapped to e92vhnbaavEmapToEsp4feh
;   218 --; cmp byte[edi-1],0x12
;   219 --; jne PeekSeq
;   220 --; fld qword[edi]
;   221 --; mov edi,FltWrk
;   222 --; fldcw [down53]
;   223 --; fistp qword[edi]
;   224 --; fldcw [near53]
;   225 --; mov edi,[edi]
;   226 --      jne PeekSeq
;   227 --  @@:
;   228 --  mov edx,[ecx]
;   229 --  xor ebx,ebx
;   230 --  opPeekMLE:                  ; exception here mapped to e99ipmaespfeh (invalid peek memory address)
;   231 --  mov al,[edi]
;   232 --  cmp edx,h4
;   233 --  mov [ecx],eax
;   234 --  jle @f
;   235 --      dec dword[ebx+edx*4-8]
;   236 --      jz deallocX
;   237 --  @@:
;   238 --  ret
;   239 --
;   240 --  PeekSeq:                    ; peek({addr,len}) case
;   241 --  ; edi is raw {addr,len}, ecx is tgt addr
;   242 --  cmp byte[edi-1],0x80        ; sequence:
;   243 --  jnz e43atpmbaoso2a          ; argument to peek must be atom or sequence of 2 atoms
;   244 --  mov eax,[edi-12]            ; length
;   245 --if newBase
;   246 --else
;   247 --  mov edi,[edi-20]
;   248 --end if
;   249 --  cmp eax,2                   ; of length 2:
;   250 --  jne e43atpmbaoso2a          ; argument to peek must be atom or sequence of 2 atoms
;   251 --  mov edx,[edi+4]
;   252 --  cmp edx,h4
;   253 --  jle @f
;   254 --      lea esi,[edi+4]
;   255 --      shl edx,2
;   256 --      mov [emapTo],esi
;   257 --      call emapedx4
;   258 --      jne e43atpmbaoso2a      ; argument to peek must be atom or sequence of 2 atoms
;   259 --  @@:
;   260 --  mov esi,[edi]
;   261 --  push ecx                    ; save tgt addr
;   262 --  cmp esi,h4
;   263 --  jle @f
;   264 --      shl esi,2
;   265 --      mov [emapTo],edi
;   266 --      call emapesi8
;   267 --      jne e43atpmbaoso2ap     ; argument to peek must be atom or sequence of 2 atoms
;   268 --  @@:
;   269 --  ; OK, len now in edx, and addr in esi
;   270 --  xor ebx,ebx
;   271 --  call AllocStr           ; damages eax only
;   272 --  mov ecx,edx
;   273 --  lea edi,[ebx+eax*4]
;   274 --  opPeeksMLE:                 ; exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   275 --  rep movsb
;   276 --  pop esi
;   277 --  mov byte[edi],0
;   278 --  mov edx,[esi]
;   279 --  mov [esi],eax
;   280 --  cmp edx,h4
;   281 --  jle @f
;   282 --      dec dword[ebx+edx*4-8]
;   283 --      jz deallocX
;   284 --  @@:
;   285 --  ret
;   286 --
;C:\Program Files (x86)\Phix\builtins\pcase.e: - skipped (no code entries)
;==========================================================================
;C:\Program Files (x86)\Phix\builtins\ppp.e: - skipped (no code entries)
;========================================================================
;C:\Program Files (x86)\Phix\builtins\VM\pStack.e:
;=================================================
;     1 --
;     2 -- pStackD.e
;     3 -- ========
;     4 
;     5 --constant freesym = "free symtab["
;     6 --constant closebr = "] \n"
;     7 
;     8 --
;     9 --  Call stack management. 
;    10 --
;    11 --  Phix uses a virtual stack, allocated in ~12K (~11K for 64-bit) blocks on the heap, rather than 
;    12 --  the system stack, which avoids having to deal with stack exceptions, and/or decide how big the 
;    13 --  stack should be before execution begins. This means that Phix can perform deeper nested calls, 
;    14 --  and/or use a larger heap, than a traditional system-stack based approach. The virtual stack 
;    15 --  block sizes were taken directly from the tables in pHeap.e, namely 12280 for 32 bit and 11248 
;    16 --  for 64 bit, and we use %:pGetPool rather than allocate, which would be 4/8 off those figures.
;    17 --  (In reality :%pGetPool existed long before :%pAlloc and was chosen for that singular reason;
;    18 --   it would not be a terrible idea to switch to :%pAlloc, albeit resulting in a tiny loss.)
;    19 --
;    20 --  Creating a new frame and invoking a routine is not that much different to how it would be done 
;    21 --  traditionally (on the system stack), however return has to decrease reference counts and when
;    22 --  they drop to zero deallocate the object. Additionally, specialised methods are used to perform 
;    23 --  type checking and "callonce" any top-level code. To be fair, there is very little difference 
;    24 --  between using the system stack or virtual stack blocks, not that I ever quite got the hang of 
;    25 --  catching some exception or other in order to extend the stack, but one idea I rather like
;    26 --  about vsbs is that when a program runs out of memory it is quite possible to free up all but 
;    27 --  the head and tail(2) of the vsb chain, compared to freeing up the middle of the stack, and of
;    28 --  course that little bit of extra available memory may well be all that pDiag.e needs.
;    29 --
;    30 --
;    31 --  A virtual stack block (32-bit) is:
;    32 --      dd vsb_prev                 [vsb_root]
;    33 --      dd vsb_next                 [vsb_root+4]
;    34 --      dd spare (was symtabptr)    [vsb_root+8]
;    35 --      dd spare (was gvarptr)      [vsb_root+12]
;    36 --      dd magic                    [vsb_root+16]       -- (#40565342 = "@VSB")
;    37 --      (frames in remaining 12280-24 bytes, leaving unused chunks rather than spanning)
;    38 --      dd magic                    [vsb_root+12276]    -- (#3C565342 = "<VSB")
;    39 --
;    40 --  A (32-bit) frame is:
;    41 --      dd items N..2               [ebp-n*4+4]
;    42 --      dd item 1                   [ebp]
;    43 --      dd N                        [ebp+4] (if N==0 then [ebp] is junk/off-limits)
;    44 --      dd routine being called     [ebp+8] (there is no longer a calling routine)
;    45 --      dd called from addr         [ebp+12]    [DEV remove?] [might be needed for opTchk]
;    46 --      dd return address           [ebp+16] (0 means callback)
;    47 --      dd prev_ebp                 [ebp+20] (0 means top-level quit [maybe?])
;    48 --      dd vsb_root                 [ebp+24]
;    49 -->?    dd ehand                    [ebp+28] (exception handler/flag) [proposed]
;    50 --old:
;    51 --      dd symtabptr                [ebp+24] \
;    52 --?     dd threadstack              [ebp+28]  } may be copied/overwritten every frame
;    53 --      dd vsb_root                 [ebp+32] /
;    54 
;    55 --DEV have this make ddthreadstack 0 and see if we really need it anymore...
;    56 --    can we not just use [ds+8] to load symptr? - I believe we now do...   [ARGH!]
;    57 
;    58 --
;    59 --  A virtual stack block (64-bit) is:
;    60 --      dq vsb_prev                 [vsb_root]
;    61 --      dq vsb_next                 [vsb_root+8]
;    62 --<     dq symtabptr                [vsb_root+16]       -- (raw address of symtab[1])   [DEV]
;    63 --<     dq gvarptr                  [vsb_root+24]       -- (raw address of gvar[1])     [DEV]
;    64 --      dq spare (was symtabptr)    [vsb_root+16]
;    65 --      dq spare (was gvarptr)      [vsb_root+24]
;    66 --      dq magic                    [vsb_root+32]       -- (#40565342 = "@VSB")
;    67 --pHeapD:
;    68 --<     <frames in remaining 9208-48 bytes, leaving unused chunks rather than spanning>
;    69 --      <frames in remaining 11248-48 bytes, leaving unused chunks rather than spanning>
;    70 --<     dq magic    ( [vsb_root+(9200)] )       -- (#3C565342 = "<VSB")
;    71 --      dq magic    ( [vsb_root+(11240)] )      -- (#3C565342 = "<VSB")
;    72 --
;    73 --  A (64-bit) frame is:
;    74 --      dq items N..2               [rbp-n*8+8]
;    75 --      dq item 1                   [rbp]
;    76 --      dq N                        [rbp+8] (if N==0 then [rbp] is junk/off-limits)
;    77 --      dq routine being called     [rbp+16] (there is no longer a calling routine)
;    78 --      dq called from addr         [rbp+24]    [DEV remove?] (see above)
;    79 --      dq return address           [rbp+32] (0 means callback)
;    80 --      dq prev_ebp                 [rbp+40] (0 means top-level quit [maybe?])
;    81 --      dq vsb_root                 [rbp+48]
;    82 -->?    dq ehand                    [rbp+56] (exception handler/flag) [proposed]
;    83 --
;    84 
;    85 --without debug
;    86 
;    87 include builtins\VM\pFEH.e
;    88 include builtins\VM\pHeap.e     -- :%pDealloc, :%pGetPool
;    89 
;    90 integer pArg = 0 -- [ELF] save of r|esp/4 (for command_line) at load
;    91 
;    92 integer nocleanup = 0   -- set to 1 if (eg) :!iDiag has been called,
;    93                         -- so abort proper like, rather than try and
;    94                         -- "return when interpreting" etc.
;    95 
;    96 integer CClean = 0      -- cleanup code for pcfuncN.e
;    97 
;    98 --DEV opCallOnceYeNot
;    99 --#ilASM{ jmp :%opRetf
;   100 --#ilASM{ jmp :fin
;   101 #ilASM{ jmp :!opCallOnceYeNot
                jmp :!opCallOnceYeNot     ;#004427EA: 351 F3050000               v  00 00  1   1      
;   102 
;   103 
;   104 --
;   105 -- The following two routines are needed for p.exw and pcfuncN.e: in the "parlor trick"
;   106 --  that is "p p p -test" we need to be sure that when we access [ds+8] we are talking
;   107 --  about the same one the VM is using. pDiagN/pStack/pTrace can use [ds+8] directly,
;   108 --  as they are part of the VM (and one day soon pcfuncN.e should be as well).
;   109 --
;   110 
;   111 --/*
;   112 procedure :%pGetSymPtr(:%)
;   113 end procedure -- (for Edita/CtrlQ)
;   114 --*/
;   115 :%pGetSymPtr        -- [e/rsi] := raw(symtab)
;   116 -------------
;   117     [32]
;   118         mov esi,[ds+8]      -- (esi:=raw addr of symtab[1])
;   119     [64]
;   120         mov rsi,[ds+8]      -- (rsi:=raw addr of symtab[1])
                mov rsi,qword[#00402008]  ;#004427EF: 48:213065 12F8FBFF         uv 40 00  1   2      
;   121     []
;   122         ret
                ret                       ;#004427F6: 303                        np 00 00  2   3      
;   123 
;   124 --/*
;   125 procedure :%pSetSymPtr(:%)
;   126 end procedure -- (for Edita/CtrlQ)
;   127 --*/
;   128 :%pSetSymPtr        -- raw(symtab) := [e/rsi]
;   129 -------------
;   130     [32]
;   131         mov [ds+8],esi      -- (raw addr of symtab[1]:=esi)
;   132     [64]
;   133         mov [ds+8],rsi      -- (raw addr of symtab[1]:=rsi)
                mov dword[#00402008],esi  ;#004427F7: 211065 0BF8FBFF            uv 00 40  1   5      
;   134     []
;   135         ret
                ret                       ;#004427FD: 303                        np 00 00  2   6      
;   136 
;   137 --/*
;   138 procedure :%opGetST(:%)
;   139 end procedure -- (for Edita/CtrlQ)
;   140 --*/
;   141 --DEV/temp...
;   142 :!opGetST       -- [e/rdi] := symtab
;   143     [32]
;   144         push dword[esp]
;   145     [64]
;   146         push qword[rsp]
                push qword[rsp]           ;#004427FE: 48:377064044               np 00 10  2   8      
;   147     []
;   148 :%opGetST       -- [e/rdi] := symtab
;   149 ---------       -- (trashes all registers, if [edi] needs dealloc, else just eax/edx)
;   150     [32]
;   151         mov eax,[ds+8]      -- (eax:=raw addr of symtab[1])
;   152         mov edx,[edi]
;   153         add dword[eax-8],1  -- inc refcount of symtab
;   154         add eax,1           -- \
;   155         ror eax,2           -- / make a #40000000+ ref
;   156         mov [edi],eax
;   157         cmp edx,h4
;   158         jle @f
;   159             sub dword[ebx+edx*4-8],1
;   160 --          jnz @f
;   161 --          pushad
;   162 ----      if debugmem2
;   163 ----        mov eax,[esp+32]
;   164 ----        mov [dmFera],eax
;   165 ----      end if
;   166 --          push dword[esp+32]
;   167 --          call :%pDealloc0
;   168 --          popad
;   169             jz :%pDealloc
;   170     [64]
;   171         mov rax,[ds+8]      -- (rax:=raw addr of symtab[1])
                mov rax,qword[#00402008]  ;#00442802: 48:213005 FFF7FBFF         uv 01 00  1  10      
;   172         mov rdx,[rdi]
                mov rdx,[rdi]             ;#00442809: 48:213027                  vu 04 80  1  10      
;   173         add qword[rax-16],1 -- inc refcount of symtab
                add qword[rax-16],1       ;#0044280C: 48:203100 F0 01            u  00 01  3  13    *01*
;   174         add rax,1           -- \
                add rax,1                 ;#00442811: 48:203300 01               vu 01 01  1  15      
;   175         ror rax,2           -- / make a #40000..00+ ref
                ror rax,2                 ;#00442815: 48:301310 02               np 01 01  1  16      
;   176         mov r15,h4
                mov r15,h4                ;#00442819: 49:277 0000000000000040    uv 8000 00  1  17      
;   177         mov [rdi],rax
                mov [rdi],rax             ;#00442823: 48:211007                  vu 00 81  1  17      
;   178         cmp rdx,r15
                cmp rdx,r15               ;#00442826: 49:073327                  uv 00 8004  1  18      
;   179         jle @f
                jle #00442837             ;#00442829: 176 0C                     v  00 00  1  18      
;   180             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0044282B: 48:203154223 F0 01         u  00 0C  3  19      
;   181             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#00442831: 017204 A3FAFFFF            v  00 00  1  21      
;   182     []
;   183       @@:
;   184         ret
                ret                       ;#00442837: 303                        np 00 00  2  22      
;   185 
;   186 --/*
;   187 procedure ::newVSB(::)
;   188 end procedure -- (for Edita/CtrlQ)
;   189 --*/
;   190 ::newVSB    -- (called from newStack and opFrame)
;   191 --------
;   192     -- Allocate a new page for the virtual stack or re-use vsb_next.
;   193     --
;   194     -- On entry, edi(/rdi) is vsb_root (may be stack00), nowt else matters.
;   195     -- On exit, eax(/rax) is the new ebp_root, ebp is unaltered, as are ecx, ebx, edx, esi, edi.
;   196     --
;   197     [32]
;   198         mov eax,[edi+4]                 -- vsb_next
;   199         test eax,eax
;   200         jnz @f
;   201         push ecx                        -- save
;   202         push edx                        -- save
;   203         push esi                        -- save
;   204         push edi                        -- save (vsb_root)
;   205         mov ecx,12280
;   206         call :%pGetPool                 -- sets eax,edx, trashes ecx,esi,edi
;   207         pop edi                         -- restore (vsb_root)
;   208         pop esi                         -- restore
;   209 --**DEV we need a fatal crash here if eax==0 returned... [maybe not, there is a #C0000005 coming right up...]
;   210 --  test eax,eax
;   211 --  jz :trimStack
;   212 --  cmp edx,12280
;   213 --  jne ???
;   214         pop edx                         -- restore
;   215         pop ecx                         -- restore
;   216         mov [edi+4],eax                 -- prev_block.vsb_next:=new_block
;   217         mov [eax],edi                   -- new_block.vsb_prev:=prev_block
;   218         mov [eax+4],ebx                 -- new_block.vsb_next:=0
;   219         mov [eax+8],ebx                 -- unused
;   220         mov [eax+12],ebx                -- unused
;   221         mov dword[eax+16],#40565342     -- magic ("@VSB")
;   222         mov dword[eax+12276],#3C565342  -- magic ("<VSB")
;   223       @@:
;   224 --  mov edi,eax
;   225     [64]
;   226         mov rax,[rdi+8]                 -- vsb_next
                mov rax,[rdi+8]           ;#00442838: 48:213107 08               uv 01 80  1  24      
;   227         test rax,rax
                test rax,rax              ;#0044283C: 48:205300                  uv 00 01  1  25 01   
;   228         jnz @f
                jnz #00442883             ;#0044283F: 165 42                     v  00 00  1  25      
;   229         push rcx                        -- save
                push rcx                  ;#00442841: 48:121                     uv 00 02  1  26      
;   230         push rdx                        -- save
                push rdx                  ;#00442843: 48:122                     vu 00 04  1  26      
;   231         push rsi                        -- save
                push rsi                  ;#00442845: 48:126                     uv 00 40  1  27      
;   232         push rdi                        -- save (vsb_root)
                push rdi                  ;#00442847: 48:127                     vu 00 80  1  27      
;   233 --pHeapD:
;   234 --<     mov rcx,9208
;   235         mov rcx,11248
                mov rcx,11248             ;#00442849: 48:307301 F02B0000         uv 02 00  1  28      
;   236         call :%pGetPool                 -- sets rax,rdx, trashes rcx,rsi,rdi[?]
                call #00441B4D (:%pGetPool)  ;#00442850: 350 F8F2FFFF               v  00 00  1  28      
;   237         pop rdi                         -- restore
                pop rdi                   ;#00442855: 48:137                     uv 80 00  1  29      
;   238         pop rsi                         -- restore
                pop rsi                   ;#00442857: 48:136                     vu 40 00  1  29      
;   239 --  test rax,rax
;   240 --  jz :trimStack
;   241 --< cmp rdx,9208
;   242 --  cmp rdx,11248
;   243 --  jne ???
;   244         pop rdx                         -- restore
                pop rdx                   ;#00442859: 48:132                     uv 04 00  1  30      
;   245         pop rcx                         -- restore
                pop rcx                   ;#0044285B: 48:131                     vu 02 00  1  30      
;   246         mov [rdi+8],rax                 -- set prev_block's vsb_next
                mov [rdi+8],rax           ;#0044285D: 48:211107 08               uv 00 81  1  31      
;   247         mov [rax],rdi                   -- set new_block's vsb_prev
                mov [rax],rdi             ;#00442861: 48:211070                  vu 00 81  1  31      
;   248         mov [rax+8],rbx                 -- set new_block's vsb_next = 0
                mov [rax+8],rbx           ;#00442864: 48:211130 08               uv 00 09  1  32      
;   249 --      mov qword[rax+16],#40565342     -- magic ("@VSB")
;   250         mov [rax+16],rbx
                mov [rax+16],rbx          ;#00442868: 48:211130 10               vu 00 09  1  32      
;   251         mov [rax+24],rbx
                mov [rax+24],rbx          ;#0044286C: 48:211130 18               uv 00 09  1  33      
;   252         mov qword[rax+32],#40565342     -- magic ("@VSB")
                mov qword[rax+32],1079399234  ;#00442870: 48:307100 20 42535640      vu 00 01  1  33      
;   253 --pHeapD:
;   254 --<     mov qword[rax+9200],#3C565342   -- magic ("<VSB")
;   255         mov qword[rax+11240],#3C565342  -- magic ("<VSB")
                mov qword[rax+11240],1012290370  ;#00442878: 48:307200 E82B0000 4253563C uv 00 01  1  34      
;   256       @@:
;   257 --  mov rdi,rax
;   258     []
;   259         ret
                ret                       ;#00442883: 303                        np 00 00  2  35      
;   260 
;   261 --/*
;   262 procedure :%newStack(:%)
;   263 end procedure -- (for Edita/CtrlQ)
;   264 --*/
;   265 :%newStack      -- (called from :>initStack, :%opInterp, task_yield, and CreateThread [DEV])
;   266 ----------
;   267     [32]
;   268         -- first, create a dummy vsb_root (vsb_next,vsb_prev@=0) on the stack
;   269         --DEV edx:=era?
;   270         xor ebx,ebx
;   271 --27/2/15:
;   272 --!     push ecx                -- gvarptr          [DEV]
;   273 --!     push eax                -- symtabptr        [DEV]
;   274         push ebx
;   275         push ebx
;   276         mov edi,esp
;   277         call :newVSB            -- allocate a new virtual stack block
;   278         add esp,8               -- discard that dummy vsb_root
;   279 --      lea esi,[eax+8]         -- new ebp (N=0, [ebp] is <magic> ie "@VSB")
;   280         lea esi,[eax+16]        -- new ebp (N=0, [ebp] is <magic> ie "@VSB")
;   281         mov [eax],ebx           -- clear new vsb_prev link
;   282         mov [esi+4],ebx         -- N
;   283         mov dword[esi+8],21     -- routine being called (T_maintls)
;   284         mov [esi+12],ebx        -- called from address (0)  [DEV remove?]
;   285         mov [esi+16],ebx        -- return address (0)
;   286         mov [esi+20],ebx        -- prev_ebp
;   287         mov [esi+24],eax        -- vsb_root
;   288         mov ebp,esi
;   289     [64]
;   290         -- first, create a dummy vsb_root (vsb_next,vsb_prev@=0) on the stack
;   291         --DEV rdx:=era?
;   292         xor rbx,rbx
                xor rbx,rbx               ;#00442884: 48:061333                  uv 08 08  1  37      
;   293         mov r15,h4
                mov r15,h4                ;#00442887: 49:277 0000000000000040    vu 8000 00  1  37      
;   294 --27/2/15:
;   295 --      push rcx                -- gvarptr
;   296 --      push rax                -- symtabptr
;   297         push rbx
                push rbx                  ;#00442891: 48:123                     uv 00 08  1  38      
;   298         push rbx
                push rbx                  ;#00442893: 48:123                     vu 00 08  1  38      
;   299         mov rdi,rsp
                mov rdi,rsp               ;#00442895: 48:213374                  uv 80 10  1  39      
;   300         call :newVSB            -- allocate a new virtual stack block
                call #00442838            ;#00442898: 350 9BFFFFFF               v  00 00  1  39      
;   301         add rsp,16              -- discard that dummy vsb_root
                add rsp,16                ;#0044289D: 48:203304 10               uv 10 10  1  40      
;   302 --      add rsp,32              -- discard that dummy vsb_root
;   303 --      lea rsi,[rax+16]        -- new ebp (N=0, [ebp] is <magic> ie "@VSB")
;   304         lea rsi,[rax+32]        -- new ebp (N=0, [ebp] is <magic> ie "@VSB")
                lea rsi,[rax+32]          ;#004428A1: 48:215160 20               vu 40 01  1  40      
;   305         mov [rax],rbx           -- clear new vsb_prev link
                mov [rax],rbx             ;#004428A5: 48:211030                  uv 00 09  1  41      
;   306         mov [rsi+8],rbx         -- N
                mov [rsi+8],rbx           ;#004428A8: 48:211136 08               uv 00 48  1  43    *40*
;   307         mov qword[rsi+16],21    -- routine being called
                mov qword[rsi+16],21      ;#004428AC: 48:307106 10 15000000      vu 00 40  1  43      
;   308         mov [rsi+24],rbx        -- called from address (0)
                mov [rsi+24],rbx          ;#004428B4: 48:211136 18               uv 00 48  1  44      
;   309         mov [rsi+32],rbx        -- return address (0)
                mov [rsi+32],rbx          ;#004428B8: 48:211136 20               vu 00 48  1  44      
;   310         mov [rsi+40],rbx        -- prev_ebp
                mov [rsi+40],rbx          ;#004428BC: 48:211136 28               uv 00 48  1  45      
;   311         mov [rsi+48],rax        -- vsb_root
                mov [rsi+48],rax          ;#004428C0: 48:211106 30               vu 00 41  1  45      
;   312         mov rbp,rsi
                mov rbp,rsi               ;#004428C4: 48:213356                  uv 20 40  1  46      
;   313     []
;   314         ret
                ret                       ;#004428C7: 303                        np 00 00  2  47      
;   315 
;   316 --/*
;   317 procedure :>initStack(:>)
;   318 end procedure -- (for Edita/CtrlQ)
;   319 --*/
;   320 :>initStack
;   321 -----------
;   322         call :>initFEH
                call #00442618 (:>initFEH)  ;#004428C8: 350 4BFDFFFF               v  00 00  1  49      
;   323 --      -- first, create a dummy vsb_root (vsb_next,vsb_prev@=0) on the stack
;   324     [32]
;   325 --      xor ebx,ebx
;   326 --      push ebx
;   327 --      push ebx
;   328 --      mov edi,esp
;   329 --27/2/15:
;   330 --      mov ecx,[ds+12]             -- maxop    [DEV - remove all this...]
;   331 --      mov eax,[ds+8]              -- symtabptr
;   332 --      shl ecx,2                   -- *4
;   333 --      add ecx,20                  -- gvarptr (==addr gvar[1]) --DEV gvar0?
;   334         call :%newStack
;   335 --      add esp,8                   -- discard that dummy vsb
;   336 --31/7/15:
;   337         mov dword[ebp+16],:Exit0    -- return address (0)
;   338     [ELF32] -- save esp for command line ... (assumes it is undamaged)  [DEV not interpret?]
;   339         mov eax,esp
;   340         shr eax,2
;   341         mov [pArg],eax
;   342     [64]
;   343 --      xor rbx,rbx
;   344 --      mov r15,h4
;   345 --      push rbx
;   346 --      push rbx
;   347 --      mov rdi,rsp
;   348 --27/2/15:
;   349 --      mov rcx,[ds+16]         -- maxop
;   350 --      mov rax,[ds+8]          -- symtabptr
;   351 --      shl rcx,3               -- *8
;   352 --      add rcx,32              -- gvarptr (==addr gvar[1])
;   353         call :%newStack
                call #00442884 (:%newStack)  ;#004428CD: 350 B2FFFFFF               v  00 00  1  50      
;   354 --      add rsp,16              -- discard that dummy vsb
;   355         mov qword[rbp+32],:Exit0    -- return address (0)
                mov qword[retaddr],#00442B6D  ;#004428D2: 48:307105 20 6D2B4400      uv 00 20  1  51      
;   356     [ELF64]
;   357         mov rax,rsp
;   358         shr rax,2
;   359         mov [pArg],rax
;   360     []
;   361         ret
                ret                       ;#004428DA: 303                        np 00 00  2  52      
;   362 
;   363 --/*
;   364 procedure :%opGetArg(:%)
;   365 end procedure -- (for Edita/CtrlQ)
;   366 --*/
;   367 --/* DEV
;   368     [ELF32]
;   369 :%opGetArgELF32
;   370         mov eax,[pArg]
;   371         ret
;   372     [ELF64]
;   373 :%opGetArgELF64
;   374         mov rax,[pArg]
;   375         ret
;   376     []
;   377 --*/
;   378 
;   379 --makeFrameX:
;   380 --  mov esi,[esp]       -- grab a copy of the "called from" address, for use in debug reporting
;   381 --                      -- (note the "return address" may be branch straightened to miles away)
;   382 
;   383 --/*
;   384 procedure :%opFrame(:%)
;   385 end procedure -- (for Edita/CtrlQ)
;   386 --*/
;   387 :%opFrame
;   388 ---------
;   389     [32]
;   390         -- new style vsb:
;   391         --  vsb_next
;   392         --  vsb_prev
;   393         --  spare (was symtabptr)
;   394         --  spare (was gvarptr)
;   395         --  magic == #40565342 aka "@VSB"
;   396         --  <frames in next 12280-24 bytes>
;   397         --  magic == #3C565342 aka "<VSB"
;   398         --
;   399         -- new style frame: (see above)
;   400         --  items N..2              [ebp-n*4] (p2 is at [ebp-4], p3 at [ebp-8], etc)
;   401         --ebp:
;   402         --  item 1                  [ebp]   p1 (may not exist)
;   403         --  N                       [ebp+4] number of parameters and locals (may be 0)
;   404         --  routine being called    [ebp+8] (there is no longer a calling routine)
;   405         --  called from addr        [ebp+12] (see note below)
;   406         --  return address          [ebp+16] (0 means callback)
;   407         --  prev_ebp                [ebp+20] (0 means top-level quit)
;   408         --  vsb_root                [ebp+24]
;   409         --
;   410         --  Obviously, if N [ebp+4] is zero, then [ebp] is magic/vsb_root of previous frame
;   411         --              and should not be read let alone overwritten.
;   412         --
;   413         -- On Entry, ecx is number of parameters and locals
;   414         --           edx is routineNo to call (nb was edi) (a symtab index)
;   415         --           [esp] is "called from" addr 
;   416         -- On Exit, eax is h4,
;   417         --          ebx is 0, (as usual)
;   418         --          ecx is 0,
;   419 --      --              edx is threadstack (==[ebp+28]) [DEV???]
;   420         --          edx is still routineNo
;   421         --          esi is ebp-N*4 or thereabouts
;   422         --          edi is prev_ebp (==[ebp+20])
;   423         --  Note "return address"=="called from" is correct for opCallOnce and opTChk, 
;   424         --       but replaced after all direct calls to :%opFrame from "normal" code,
;   425         --       via a mov dword[ebp+16],imm32 instruction.
;   426 --      push esi                    -- save called from addr (we ran out of registers!)
;   427 -- ::makeFrameX [DEV killme]
;   428         mov edi,[ebp+24]            -- vsb_root
;   429 --  lea esi,[ebp+ecx*4+36]      -- new ebp (provisional!)   
;   430         lea esi,[ebp+ecx*4+28]      -- new ebp (provisional!)   
;   431 
;   432 -- if (newebp+28)<=(vsb_root+12280) then frame fits OK in current virtual stack block
;   433 -- if [ebp+ecx*4+28+28-12280]<=edi
;   434 -- if [ebp+ecx*4-12224]<=edi
;   435 --DEV I am sure we can simplify this, to say esi<=edi+12224-36, try the following:
;   436 --      lea eax,[ebp+ecx*4-12224]
;   437 --      cmp eax,edi                 -- check space
;   438         lea eax,[edi+12248] -- (12280-32 = 12248)       (DEV AGI)
;   439         cmp esi,eax         -- (if newebp > vsb_root+12280-32 then newVSB)
;   440         jle @f
;   441 --DEV (untried)
;   442 --        push edx
;   443 --        mov edx,[esp+4]
;   444           call :newVSB              -- sets eax (new vsb_root)
;   445 --        pop edx
;   446           mov edi,eax
;   447           lea esi,[eax+ecx*4+16]    -- new ebp (for N=0, [ebp] is <magic> ie "@VSB")
;   448         @@:
;   449         xor ebx,ebx
;   450         mov eax,[esp]               -- called from address
;   451         mov [esi+4],ecx             -- N
;   452         mov [esi+8],edx             -- routine being called
;   453         mov [esi+12],eax            -- called from address
;   454         mov [esi+16],eax            -- return address (see note above)
;   455         mov [esi+20],ebp            -- prev_ebp
;   456         mov [esi+24],edi            -- vsb_root
;   457 --DEV test:
;   458 lea edx,[edi+12276]
;   459         mov eax,h4
;   460         mov edi,esi
;   461         std
;   462         rep stosd                   -- (while ecx-- do mov[edi--],eax)
;   463         cld
;   464         mov edi,ebp
;   465         mov ebp,esi
;   466 cmp dword[edx],#3C565342
;   467 je @f
;   468     int3
;   469 @@:
;   470     [64]
;   471         -- new style vsb:
;   472         --  vsb_next
;   473         --  vsb_prev
;   474         --  spare (was symtabptr)
;   475         --  spare (was gvarptr)
;   476         --  magic == #40565342 aka "@VSB" (plus dword 0 padding)
;   477         --  <frames in next 11248-48 bytes>
;   478         --  magic == #3C565342 aka "<VSB" (plus dword 0 padding)
;   479         --
;   480         -- new style frame: (see above)
;   481         --  items N..2              [rbp-n*8] (p2 is at [rbp-8], p3 at [rbp-16], etc)
;   482         --rbp:
;   483         --  item 1                  [rbp]   p1 (may not exist)
;   484         --  N                       [rbp+8] number of parameters and locals (may be 0)
;   485         --  routine being called    [rbp+16] (there is no longer a calling routine)
;   486         --  called from addr        [rbp+24] (see note below)   [DEV remove??]
;   487         --  return address          [rbp+32] (0 means callback)
;   488         --  prev_ebp                [rbp+40] (0 means top-level quit)
;   489         --  vsb_root                [rbp+48]
;   490         --
;   491         --  Obviously, if N [rbp+8] is zero, then [rbp] is magic/vsb_root of previous frame
;   492         --              and should not be read let alone overwritten.
;   493         --
;   494         -- On Entry, rcx is number of parameters and locals (N, >=0)
;   495         --           rdx is routineNo to call (a symtab index)
;   496         --           [rsp] is "called from" addr 
;   497         -- On Exit, rax is h4,
;   498         --          rbx is 0, (as usual)
;   499         --          rcx is 0,
;   500 --?         edx is threadstack (==[ebp+28]) 
;   501         --          rsi is rbp-N*8 or thereabouts
;   502         --          rdi is prev_ebp (==[rbp+40])
;   503         --          rbp is the new frame, such that [rbp+8] is N, 
;   504         --                                          [rbp+16] is routine no, etc
;   505         --  Note "return address"=="called from" is correct for opCallOnce and opTChk, 
;   506         --       but replaced after all direct calls to :%opFrame from "normal" code,
;   507         --       via a mov dword[rbp+32],imm32 instruction. [DEV check this]
;   508 --  push rsi                    -- save called from addr (we ran out of registers!)
;   509 --      mov r12,rsi                 -- save called from addr
;   510 -- ::makeFrameX
;   511         mov rdi,[rbp+48]            -- vsb_root
                mov rdi,[rbp+48]          ;#004428DB: 48:213175 30               uv 80 20  1  54      
;   512         lea rsi,[rbp+rcx*8+56]      -- new ebp (provisional!)  --DEV try this again!
                lea rsi,[rbp+rcx*8+56]    ;#004428DF: 48:215164315 38            vu 40 22  1  54      
;   513 --      lea rsi,[rbx+rcx*4+28]
;   514 --      shl rsi,2               --DEV? shl rsi,1??
;   515 --      add rsi,rbp                 -- new ebp (provisional!)
;   516 -- if (newebp+56)<=(vsb_root+9208) then frame fits OK in current virtual stack block
;   517 -- if [rbp+rcx*8+56+56-9208]<=rdi
;   518 -- if [rbp+rcx*8-9096]<=rdi
;   519 --      lea r13,[rbp+rcx*8-9096]        --DEV try this again!
;   520 -- if (newebp+56)<=(vsb_root+11248) then frame fits OK in current virtual stack block
;   521 -- if [rbp+rcx*8+56+56-11248]<=rdi
;   522 -- if [rbp+rcx*8-11136]<=rdi
;   523 --      lea r13,[rbp+rcx*8-11136]       --DEV try this again!
;   524 --pHeapD: (9208->11248)
;   525 --      lea r13,[rbx+rcx*4-4548]
;   526 --      lea r13,[rbx+rcx*4-4548?!]
;   527 --x!    shl r13,2   -- (spotted in passing!)
;   528 --      shl r13,1
;   529 --      add r13,rbp                 
;   530 --      cmp r13,rdi                 -- check space
;   531 --DEV I am sure we can simplify this, to say rsi<=rdi+9208-56, try the following: (after updating the numbers!)
;   532 --  lea rax,[rdi+9152]  -- (9208-56 = 9152)
;   533 --      lea rax,[rdi+9152]  -- (9208-56 = 9152)
;   534 --      lea rax,[rdi+11080] -- (11248-56 = 11080!)
;   535         lea rax,[rdi+11184] -- (11248-64 = 11184)       (DEV AGI)
                lea rax,[rdi+11184]       ;#004428E4: 48:215207 B02B0000         uv 01 80  1  57    *80*
;   536 --      cmp rsi,rax         -- (if newebp > vsb_root+9208-56 then newVSB)
;   537         cmp rsi,rax         -- (if newebp > vsb_root+11248-64 then newVSB)
                cmp rsi,rax               ;#004428EB: 48:071306                  uv 00 41  1  58 01   
;   538         jle @f
                jle #004428FD             ;#004428EE: 176 0D                     v  00 00  1  58      
;   539 --DEV (untried)
;   540 --        push rdx
;   541 --        mov rdx,[rsp+8]
;   542           call :newVSB              -- sets eax (new vsb_root)
                  call #00442838          ;#004428F0: 350 43FFFFFF               v  00 00  1  59      
;   543 --        pop rdx
;   544           mov rdi,rax
                  mov rdi,rax             ;#004428F5: 48:213370                  uv 80 01  1  60      
;   545 --DEV have I gone mad here?
;   546           lea rsi,[rax+rcx*8+32]    -- new ebp (for N=0, [ebp] is <magic> ie "@VSB")
                  lea rsi,[rax+rcx*8+32]  ;#004428F8: 48:215164310 20            vu 40 03  1  60      
;   547 --        lea rsi,[rbx+rcx*4+8]
;   548 --        lea rsi,[rbx+rcx*4+16]
;   549 --x!      shl rsi,2 -- (ditto)
;   550 --        shl rsi,1
;   551 --        add rsi,rax
;   552       @@:
;   553 --  xor rbx,rbx
;   554 --  pop eax                     -- called from address
;   555         mov rax,[rsp]               -- called from address
                mov rax,[rsp]             ;#004428FD: 48:213004044               uv 01 10  1  61      
;   556         mov [rsi+8],rcx             -- N
                mov [rsi+8],rcx           ;#00442901: 48:211116 08               uv 00 42  1  63    *40*
;   557         mov [rsi+16],rdx            -- routine being called
                mov [rsi+16],rdx          ;#00442905: 48:211126 10               vu 00 44  1  63      
;   558         mov [rsi+24],rax            -- called from address
                mov [rsi+24],rax          ;#00442909: 48:211106 18               uv 00 41  1  64      
;   559         mov [rsi+32],rax            -- return address (see note above)
                mov [rsi+32],rax          ;#0044290D: 48:211106 20               vu 00 41  1  64      
;   560         mov [rsi+40],rbp            -- prev_ebp
                mov [rsi+40],rbp          ;#00442911: 48:211156 28               uv 00 60  1  65      
;   561         mov [esi+48],rdi            -- vsb_root
                mov [rsi+48],rdi          ;#00442915: 48:211176 30               vu 00 C0  1  65      
;   562 --DEV test:
;   563 lea rdx,[rdi+11240]
        lea rdx,[rdi+11240]               ;#00442919: 48:215227 E82B0000         uv 04 80  1  66      
;   564         mov rax,h4
                mov rax,h4                ;#00442920: 48:270 0000000000000040    vu 01 00  1  66      
;   565         mov rdi,rsi
                mov rdi,rsi               ;#0044292A: 48:213376                  uv 80 40  1  67      
;   566         std
                std                       ;#0044292D: 375                        np 00 00  2  68      
;   567         rep stosq                   -- (while rcx-- do mov[rdi--],rax)
                rep stosq                 ;#0044292E: 363:48:253                 np 82 83  3  70      
;   568         cld
                cld                       ;#00442931: 374                        np 00 00  2  73      
;   569         mov rdi,rbp
                mov rdi,rbp               ;#00442932: 48:213375                  uv 80 20  1  75      
;   570         mov rbp,rsi
                mov rbp,rsi               ;#00442935: 48:213356                  vu 20 40  1  75      
;   571 cmp qword[rdx],#3C565342
        cmp qword[rdx],1012290370         ;#00442938: 48:201072 4253563C         uv 00 04  2  76      
;   572 je @f
        je #00442942                      ;#0044293F: 164 01                     v  00 00  1  77      
;   573     int3
            int3                          ;#00442941: 314                        np 00 00 13  78      
;   574 @@:
;   575 --      mov qword[rax+11240],#3C565342  -- magic ("<VSB")
;   576     []
;   577         ret
                ret                       ;#00442942: 303                        np 00 00  2  91      
;   578 
;   579 --/*
;   580 procedure :%opCallOnce(:%)
;   581 end procedure -- (for Edita/CtrlQ)
;   582 --*/
;   583 :%opCallOnce
;   584 ------------
;   585 --
;   586 -- Used for top level subroutine (tls) calls. A tls is created for each and every 
;   587 -- include file, with the one for the main file living in symtab[T_maintls(=21)],
;   588 -- which is the only one never invoked via :%pCallOnce. The compiler will however
;   589 -- try to optimise them away, if it turns out that all they do is invoke opRetf.
;   590 -- Effectively, the "include" statement generates an opCallOnce in the 'calling tls'.
;   591 -- Eg inc0.exw includes inc0b.e, and the [top-level] code from inc0b.e ends up
;   592 -- in symtab[362] so symtab[T_maintls] contains {...opCallOnce,362...}.
;   593 -- See also file:../docs/pfeat.htm#fwdDZ and the section after that.
;   594 -- A tls routine is parameterless, opCallOnce is opFrame+opCall rolled into one.
;   595 --
;   596 -- opCallOnce may also be used when invoking a forward (global) routine, to try and
;   597 -- ensure that any top-level initialisation in the include file has been done.
;   598 --
;   599     [32]
;   600         -- routine no passed in edi, all registers trashed
;   601         mov edx,[ds+8]              -- symtabptr
;   602         xor ebx,ebx
;   603 --DEV try nop nop
;   604         mov edx,[edx+edi*4-4]       -- symtab[edi]              (AGI unavoidable... unless fixup does it!)
;   605 --DEV try nop nop nop
;   606         mov eax,[ebx+edx*4+12]      -- symtab[edi][S_State=4]   (AGI unavoidable...)
;   607         mov ecx,[ebx+edx*4+40]      -- symtab[edi][S_il=11] - execute after makeFrame
;   608         test eax,#800               -- K_ran
;   609         jnz :justRetX               -- already called!
;   610         pop esi                     -- return address === called from addr
;   611         add eax,#800
;   612         push ecx                    -- symtab[edi][S_il] - execute after makeFrame
;   613         mov [ebx+edx*4+12],eax      -- update symtab[edi][S_State]
;   614         xor ecx,ecx                 -- no of params (0)
;   615         mov edx,edi
;   616         push esi
;   617         call :%opFrame
;   618         pop eax                     -- called from address (was esi)
;   619         mov [esi+12],eax            -- called from address
;   620         mov [esi+16],eax            -- return address (see note above)
;   621 --      add esp,4
;   622     [64]
;   623         -- routine no passed in rdi, all registers trashed
;   624         mov rdx,[ds+8]              -- symtabptr
                mov rdx,qword[#00402008]  ;#00442943: 48:213025 BEF6FBFF         uv 04 00  1  93      
;   625         xor rbx,rbx
                xor rbx,rbx               ;#0044294A: 48:061333                  vu 08 08  1  93      
;   626 --DEV try nop nop
;   627         mov rdx,[rdx+rdi*8-8]       -- symtab[edi]              (AGI unavoidable... unless fixup does it!)
                mov rdx,[rdx+rdi*8-8]     ;#0044294D: 48:213124372 F8            uv 04 84  1  96    *04*
;   628 --!     mov rdx,[rdx+r12]
;   629 --DEV try nop nop nop
;   630         mov rax,[rbx+rdx*4+24]      -- symtab[edi][S_State=4]   (AGI unavoidable...)
                mov rax,[rbx+rdx*4+24]    ;#00442952: 48:213104223 18            uv 01 0C  1  99 04 *04*
;   631         mov rcx,[rbx+rdx*4+80]      -- symtab[edi][S_il=11] - execute after makeFrame
                mov rcx,[rbx+rdx*4+80]    ;#00442957: 48:213114223 50            vu 02 0C  1  99      
;   632         test rax,#800               -- K_ran
                test rax,2048             ;#0044295C: 48:367300 00080000         uv 00 01  1 100      
;   633         jnz :justRetX               -- already called!
                jnz #0044298C             ;#00442963: 165 27                     v  00 00  1 100      
;   634         pop rsi                     -- return address === called from addr
                pop rsi                   ;#00442965: 48:136                     uv 40 00  1 101      
;   635         add rax,#800
                add rax,2048              ;#00442967: 48:201300 00080000         vu 01 01  1 101      
;   636         push rcx                    -- symtab[edi][S_il] - execute after makeFrame
                push rcx                  ;#0044296E: 48:121                     uv 00 02  1 102      
;   637         mov [rbx+rdx*4+24],rax      -- update symtab[edi][S_State]
                mov [rbx+rdx*4+24],rax    ;#00442970: 48:211104223 18            vu 00 0D  1 102      
;   638         xor rcx,rcx                 -- no of params (0)
                xor rcx,rcx               ;#00442975: 48:061311                  uv 02 02  1 103      
;   639         mov rdx,rdi
                mov rdx,rdi               ;#00442978: 48:213327                  vu 04 80  1 103      
;   640         push rsi
                push rsi                  ;#0044297B: 48:126                     uv 00 40  1 104      
;   641         call :%opFrame
                call #004428DB (:%opFrame)  ;#0044297D: 350 59FFFFFF               v  00 00  1 104      
;   642         pop rax                     -- called from address (was rsi)
                pop rax                   ;#00442982: 48:130                     uv 01 00  1 105      
;   643         mov [rsi+24],rax            -- called from address
                mov [rsi+24],rax          ;#00442984: 48:211106 18               uv 00 41  1 106 01   
;   644         mov [rsi+32],rax            -- return address (see note above)
                mov [rsi+32],rax          ;#00442988: 48:211106 20               vu 00 41  1 106      
;   645 --      add rsp,8
;   646     []
;   647       ::justRetX
;   648         ret
                ret                       ;#0044298C: 303                        np 00 00  2 107      
;   649 
;   650 --      jmp :%opFrame
;   651 
;   652 
;   653 --DEV sweeeeeeet! (untested) (can now patch [S_State]+=K_ran for {opRetf} jobs as well)
;   654 --  -- edi is routine no
;   655 --  -- edx is raw symtab[edi] as well
;   656 --  mov eax,[edx+12]            -- symtab[edi][S_State=4]       (AGI unavoidable...)
;   657 --  mov ecx,[edx+40]            -- symtab[edx][S_il=11] - execute after makeFrame
;   658 --  test eax,#800               -- K_ran
;   659 --  jnz @f                      -- already called!
;   660 --  pop esi                     -- return address === called from addr
;   661 --  add eax,#800
;   662 --  push ecx                    -- symtab[edx][S_il] - execute after makeFrame
;   663 --  mov [edx+12],eax            -- update S_State
;   664 --  xor ecx,ecx                 -- no of params (0)
;   665 --  xor eax,eax                 -- addr 1st (n/a)
;   666 --  jmp makeFrame               -- (esi,edi already set)
;   667 --  @@:
;   668 --  ret
;   669 
;   670 --/*
;   671 procedure :%opRetf(:%)
;   672 end procedure -- (for Edita/CtrlQ)
;   673 --*/
;   674 :%opRetf
;   675 --------
;   676 --nb must preserve eax/rax
;   677 -- new style vsb:
;   678 --  items N..2
;   679 --ebp: // so p1 is at [ebp], p2 at [ebp-4] etc...
;   680 --  item 1
;   681 --  N                       +4
;   682 --  routine being called    +8 (there is no longer a calling routine)
;   683 --  called from addr        +12 (see note below)
;   684 --  return address          +16 (0 means callback)
;   685 --  prev_ebp                +20
;   686 --! symtab                  +24
;   687 --! threadstack             +28     
;   688 --! vsb_root                +32
;   689 --  vsb_root                +24
;   690 
;   691     [32]
;   692         mov edx,[ebp+16]        -- return address
;   693         mov ecx,[ebp+4]         -- N
;   694 --      mov e?x,[ebp+20]        -- vsb_root (not needed??)
;   695         test edx,edx
;   696         jz @f
;   697           push edx
;   698       @@:
;   699 --      push eax                -- preserve eax
;   700         mov esi,ebp
;   701 --SUG:
;   702 --    ::opRetLoop
;   703       @@:
;   704         sub ecx,1               -- no of items saved
;   705         js :opRetLoopEnd
;   706         mov edx,[esi]
;   707 --      sub esi,4
;   708         lea esi,[esi-4]
;   709         cmp edx,h4
;   710         jle @b
;   711         sub dword[ebx+edx*4-8],1
;   712         jnz @b
;   713         pushad                  -- (needs to preserve ecx,esi, may as well do eax too)
;   714                                 -- (NB a single (/outer) pushad would not work anyway)
;   715 --?     call deallocY
;   716         push dword[esp+32]
;   717         call :%pDealloc0
;   718         popad
;   719         jmp @b
;   720       ::opRetLoopEnd
;   721         mov ecx,[ebp+20]        -- prev_ebp
;   722         test ecx,ecx
;   723         jz @f
;   724             mov ebp,ecx
;   725 --          xor eax,eax --no!!
;   726             ret
;   727       @@:
;   728         xor eax,eax  -- 11/2/15 (makes final top-level exit==abort(0), not abort(rand))
;   729         ret
;   730 
;   731     [64]
;   732         mov rdx,[rbp+32]        -- return address
                mov rdx,[rbp+32] (retaddr)  ;#0044298D: 48:213125 20               uv 04 20  1 109      
;   733         mov rcx,[rbp+8]         -- N
                mov rcx,[rbp+8]           ;#00442991: 48:213115 08               vu 02 20  1 109      
;   734         test rdx,rdx
                test rdx,rdx              ;#00442995: 48:205322                  uv 00 04  1 110      
;   735         jz @f
                jz #0044299C              ;#00442998: 164 02                     v  00 00  1 110      
;   736           push rdx
                  push rdx                ;#0044299A: 48:122                     uv 00 04  1 111      
;   737       @@:
;   738         mov rsi,rbp
                mov rsi,rbp               ;#0044299C: 48:213365                  vu 40 20  1 111      
;   739         mov r15,h4
                mov r15,h4                ;#0044299F: 49:277 0000000000000040    uv 8000 00  1 112      
;   740       @@:
;   741         sub rcx,1               -- no of items saved
                sub rcx,1                 ;#004429A9: 48:203351 01               vu 02 02  1 112      
;   742         js opRetLoopEnd
                js #004429DB              ;#004429AD: 170 2C                     v  00 00  1 113      
;   743         mov rdx,[rsi]
                mov rdx,[rsi]             ;#004429AF: 48:213026                  uv 04 40  1 114      
;   744         lea rsi,[rsi-8]
                lea rsi,[rsi-8]           ;#004429B2: 48:215166 F8               vu 40 40  1 114      
;   745 --      cmp rdx,h4
;   746         cmp rdx,r15
                cmp rdx,r15               ;#004429B6: 49:073327                  uv 00 8004  1 115      
;   747         jle @b
                jle #004429A9             ;#004429B9: 176 EE                     v  00 00  1 115      
;   748         sub qword[rbx+rdx*4-16],1
                sub qword[rbx+rdx*4-16],1  ;#004429BB: 48:203154223 F0 01         u  00 0C  3 116      
;   749         jnz @b
                jnz #004429A9             ;#004429C1: 165 E6                     v  00 00  1 118      
;   750         push rcx
                push rcx                  ;#004429C3: 48:121                     uv 00 02  1 119      
;   751         push rsi
                push rsi                  ;#004429C5: 48:126                     vu 00 40  1 119      
;   752         push rax
                push rax                  ;#004429C7: 48:120                     uv 00 01  1 120      
;   753 --DEV now assuming this preserves r15 (h4):
;   754         push qword[rsp+24]
                push qword[rsp+24]        ;#004429C9: 48:377164044 18            np 00 10  2 121      
;   755         call :%pDealloc0
                call #004422DE (:%pDealloc0)  ;#004429CE: 350 0BF9FFFF               v  00 00  1 123      
;   756         pop rax
                pop rax                   ;#004429D3: 48:130                     uv 01 00  1 124      
;   757         pop rsi
                pop rsi                   ;#004429D5: 48:136                     vu 40 00  1 124      
;   758         pop rcx
                pop rcx                   ;#004429D7: 48:131                     uv 02 00  1 125      
;   759         jmp @b
                jmp #004429A9             ;#004429D9: 353 CE                     v  00 00  1 125      
;   760       ::opRetLoopEnd
;   761         mov rcx,[rbp+40]        -- prev_ebp
                mov rcx,[rbp+40] (prevebp)  ;#004429DB: 48:213115 28               uv 02 20  1 126      
;   762         test rcx,rcx
                test rcx,rcx              ;#004429DF: 48:205311                  uv 00 02  1 127 02   
;   763         jz @f
                jz #004429E8              ;#004429E2: 164 04                     v  00 00  1 127      
;   764             mov rbp,rcx
                    mov rbp,rcx           ;#004429E4: 48:213351                  uv 20 02  1 128      
;   765             ret
                    ret                   ;#004429E7: 303                        np 00 00  2 129      
;   766       @@:
;   767         xor rax,rax  -- 11/2/15 (makes final top-level exit==abort(0), not abort(rand))
                xor rax,rax               ;#004429E8: 48:061300                  uv 01 01  1 131      
;   768         ret
                ret                       ;#004429EB: 303                        np 00 00  2 132      
;   769     []
;   770 
;   771 --/*
;   772 procedure :%pFreeStack(:%)
;   773 end procedure -- (for Edita/CtrlQ)
;   774 --*/
;   775 :%pFreeStack    -- called from pThread.e
;   776 ------------
;   777 ::tFreeStack
;   778     [32]
;   779         -- call :%opRetf until T_maintls
;   780         cmp dword[ebp+8],21     -- T_maintls
;   781         je @f
;   782 --          mov dword[ebp+16],:%pFreeStack  -- replace return address (DEV bug in pilasm.e)
;   783             mov dword[ebp+16],:tFreeStack   -- replace return address
;   784             jmp :%opRetf
;   785       @@:
;   786         mov eax,[ebp+24]        -- vsb_root
;   787       @@:
;   788         push dword[eax+4]       -- vsb_next
;   789         mov ecx,12280
;   790 --DEV edx:=?                    -- era
;   791         call :%pFreePool        -- release ecx bytes of memory at eax.
;   792         pop eax
;   793         test eax,eax
;   794         jnz @b
;   795         xor ebp,ebp
;   796     [64]
;   797         -- call :%opRetf until T_maintls
;   798         cmp qword[rbp+16],21    -- T_maintls
                cmp qword[rbp+16],21      ;#004429EC: 48:203175 10 15            u  00 20  2 134      
;   799         je @f
                je #00442A00              ;#004429F1: 164 0D                     v  00 00  1 135      
;   800 --          mov qword[rbp+16],:%pFreeStack  -- replace return address (DEV bug in pilasm.e)
;   801             mov qword[rbp+32],:tFreeStack   -- replace return address
                    mov qword[retaddr],#004429EC  ;#004429F3: 48:307105 20 EC294400      uv 00 20  1 136      
;   802             jmp :%opRetf
                    jmp #0044298D (:%opRetf)  ;#004429FB: 351 8DFFFFFF               v  00 00  1 136      
;   803       @@:
;   804         mov rax,[rbp+48]        -- vsb_root
                mov rax,[rbp+48]          ;#00442A00: 48:213105 30               uv 01 20  1 137      
;   805       @@:
;   806         push qword[rax+8]       -- vsb_next
                push qword[rax+8]         ;#00442A04: 48:377160 08               np 00 01  2 140    *01*
;   807 --pHeapD:
;   808 --<     mov rcx,9208
;   809         mov rcx,11248
                mov rcx,11248             ;#00442A08: 48:307301 F02B0000         uv 02 00  1 142      
;   810 --DEV rdx:=?                    -- era
;   811         call :%pFreePool        -- release rcx bytes of memory at rax.
                call #00441FFA (:%pFreePool)  ;#00442A0F: 350 E6F5FFFF               v  00 00  1 142      
;   812         pop rax
                pop rax                   ;#00442A14: 48:130                     uv 01 00  1 143      
;   813         test rax,rax
                test rax,rax              ;#00442A16: 48:205300                  uv 00 01  1 144 01   
;   814         jnz @b
                jnz #00442A04             ;#00442A19: 165 E9                     v  00 00  1 144      
;   815         xor rbp,rbp
                xor rbp,rbp               ;#00442A1B: 48:061355                  uv 20 20  1 145      
;   816     []
;   817         ret
                ret                       ;#00442A1E: 303                        np 00 00  2 146      
;   818 
;   819 --::trimStack
;   820 -------------
;   821 ----    puts(1,"Your program has run out of memory, one moment please\n")
;   822 --! mov eax,[ebp+32]                -- vsb_root
;   823 --  --
;   824 --  -- Keep the (full) vsb at edi, free everything below it.
;   825 --  -- (We may also want to keep the first vsb, but that is for another day)
;   826 --  -- First job: scan down the prev_ebp links looking for the first in this (edi) block,
;   827 --  --            then zero that prev_ebp (which is pointing to a different vsb).
;   828 --  mov edx,[ebp+24]                -- vsb_root
;   829 --  mov esi,ebp
;   830 --  mov eax,[ebp+20]                -- prev_ebp
;   831 -- ::tsloop1    -- while eax is between edx and esi, shadow eax in esi
;   832 --DEV should test this does what I want when a vsb straddles #80000000:
;   833 --  cmp eax,edx
;   834 --  jb @f
;   835 --  cmp eax,esi
;   836 --  ja @f
;   837 --  mov esi,eax
;   838 --  mov eax,[eax+20]                -- prev_ebp
;   839 --  jmp :tsloop1
;   840 -- @@:
;   841 --  mov [esi+20],ebx                -- prev_ebp:=null, on the first frame in this vsb
;   842 --  -- Second job: unlink and free all vsb_prev
;   843 --  push esi
;   844 -- ::tsloop2
;   845 --  mov eax,[edx]                   -- vsb_prev
;   846 --  mov [edx],ebx                   -- vsb_prev:=0 (only rqd on first)
;   847 --  test eax,eax
;   848 --? jz @f
;   849 --  jz e77phroom
;   850 --  push eax
;   851 --  mov ecx,12280
;   852 --  mov eax,edx
;   853 --  mov edx,??? (era)
;   854 --  call :%pFreePool    -- release ecx bytes at eax
;   855 --  pop edx
;   856 --  jmp :tsloop2
;   857 --? @@:
;   858 --? push ebp
;   859 --? mov eax,[eax]                   -- vsb_prev
;   860 --? test eax,eax
;   861 --? jz :trimdone
;   862 --? ::tslooptop
;   863 --? mov eax,[eax+32]                -- vsb_root
;   864 --? mov [esp],eax
;   865 --? mov eax,[eax]                   -- vsb_prev
;   866 --? test eax,eax
;   867 --? jz :trimdone
;   868 --? 
;   869 --? ::trimdone
;   870 --? add esp,4
;   871 --? jmp e77phroom
;   872 
;   873 --/*
;   874 procedure :%opTchk(:%)
;   875 end procedure -- (for Edita/CtrlQ)
;   876 --*/
;   877 :%opTchk
;   878 --------
;   879 -- calling convention (as used in pilx86.e)
;   880 --  mov ecx,nparms      -- no of params/locals/tmps (aka symtab[edx][S_Ltot])
;   881 --  mov edx,N           -- type check routineNo (using isVno)
;   882 --  push :return addr
;   883 --  push <varno>        -- var number (using isVno)
;   884 --  push <code>         -- addr of typecheck code (aka symtab[edx][S_il])
;   885 --  push dword[var]     -- value to check
;   886 --  jmp %:pTchk                                     351         E9 rel32        jmp rel32
;   887 -- ::return_addr
;   888     [32]
;   889         mov esi,[esp+12]    -- return address (==called from address)
;   890         call :%opFrame      -- leaves ecx=0, ?esi=addr first (was in eax)
;   891         pop eax             -- value to check
;   892 --(untried)
;   893 --      mov ecx,[esp+8]     -- real return addr
;   894         mov dword[ebp+16],:opTchkRetAddr  -- return address
;   895 --      mov dword[ebp+12],ecx
;   896         cmp eax,h4
;   897         jl @f
;   898           add dword[ebx+eax*4-8],1  -- incref
;   899       @@:
;   900         mov [ebp],eax       -- [addr first] := value
;   901         ret                 -- execute typecheck code!
;   902 
;   903 --DEV if era is opTchkRetAddr, then replace it with the one on the stack... (very messy if there be stuff on the stack...)
;   904 --      (better: stash it in [ebp+12]/[rbp+24] before the ret above)
;   905       ::opTchkRetAddr
;   906         pop ecx             -- var no
;   907         cmp eax,0
;   908         jne @f
;   909     :%opTchkFail
;   910 ----------------
;   911 --(no)      pop eax         -- return address
;   912 --DEV:
;   913 --          mov [ep1],ecx   -- var no (just leave it in ecx)
;   914 --          mov [era],eax   -- (just leave it on the stack)
;   915             pop edx
;   916             mov al,1
;   917             sub edx,1
;   918             jmp :!iDiag
;   919             int3
;   920       @@:
;   921         ret
;   922     [64]
;   923         mov rsi,[rsp+24]    -- return address (==called from address)
                mov rsi,[rsp+24]          ;#00442A1F: 48:213164044 18            uv 40 10  1 148      
;   924         call :%opFrame      -- leaves ecx=0, ?esi=addr first (was in eax)
                call #004428DB (:%opFrame)  ;#00442A24: 350 B2FEFFFF               v  00 00  1 148      
;   925         pop rax             -- value to check
                pop rax                   ;#00442A29: 48:130                     uv 01 00  1 149      
;   926 --DEV fudge:
;   927 --      mov qword[rbp+32],:opTchkRetAddr  -- return address
;   928         mov [rbp+32],rbx
                mov [rbp+32] (retaddr),rbx  ;#00442A2B: 48:211135 20               vu 00 28  1 149      
;   929         mov r15,h4
                mov r15,h4                ;#00442A2F: 49:277 0000000000000040    uv 8000 00  1 150      
;   930         mov dword[rbp+32],:opTchkRetAddr  -- return address
                mov [rbp+32] (retaddr),#00442A50  ;#00442A39: 307105 20 502A4400         vu 00 20  1 150      
;   931 --      cmp rax,h4
;   932         cmp rax,r15
                cmp rax,r15               ;#00442A40: 49:073307                  uv 00 8001  1 151      
;   933         jl @f
                jl #00442A4B              ;#00442A43: 174 06                     v  00 00  1 151      
;   934           add qword[rbx+rax*4-16],1 -- incref
                  add qword[rbx+rax*4-16],1  ;#00442A45: 48:203104203 F0 01         u  00 09  3 152      
;   935       @@:
;   936         mov [rbp],rax       -- [addr first] := value
                mov [rbp] (??? 0 845),rax  ;#00442A4B: 48:211105 00               vu 00 21  1 154      
;   937         ret                 -- execute typecheck code!
                ret                       ;#00442A4F: 303                        np 00 00  2 155      
;   938 
;   939       ::opTchkRetAddr
;   940         pop rcx             -- var no
                pop rcx                   ;#00442A50: 48:131                     uv 02 00  1 157      
;   941         cmp rax,0
                cmp rax,0                 ;#00442A52: 48:203370 00               vu 00 01  1 157      
;   942         jne @f
                jne #00442A5B             ;#00442A56: 165 03                     v  00 00  1 158      
;   943     :%opTchkFail
;   944 --(no)      pop rax         -- return address
;   945 --DEV:
;   946 --          mov [ep1],rcx   -- var no (just leave it in rcx)
;   947 --          mov [era],rax   -- (just leave in on the stack)
;   948             mov al,1
                    mov al,1              ;#00442A58: 260 01                     uv 01 00  1 159      
;   949 --DEV pdiag?
;   950 --          jmp :enumbset
;   951             int3 
                    int3                  ;#00442A5A: 314                        np 00 00 13 160      
;   952       @@:
;   953         ret
                ret                       ;#00442A5B: 303                        np 00 00  2 173      
;   954     []
;   955 
;   956 --/*
;   957 :%opInterp (should probably just be in p.exw/main())
;   958 ----------
;   959     -- note: the compiler should not have any open files when this is called.
;   960     --       interpretation is NOT thread safe
;   961 --  push [symtabptr] -- now [ds+8] (no longer needed)
;   962 --  mov [symtabptr],??? ""
;   963     [level]++
;   964 --27/2/15: eax:=symtabptr, ecx:=gvarptr
;   965     call :%newStack
;   966     call ???
;   967 :%opIaborted
;   968     [level]--
;   969 --  pop [symtabptr] ""
;   970     call :%pFreeStack
;   971     ret
;   972 --*/
;   973 
;   974 --::fin
;   975 
;   976 --
;   977 -- pAbort.e
;   978 -- ========
;   979 --
;   980 --  The abort() builtin.
;   981 --  Close any open files, free the console, ... [DEV]
;   982 --
;   983 
;   984 --include builtins\VM\pFEH.e    -- possibly temp
;   985 
;   986 --  ::e87acmbi
;   987 --      [32]
;   988 --          pop edx
;   989 --          mov al,87
;   990 --          sub edx,1
;   991 --      [64]
;   992 --          pop rdx...
;   993 --      []
;   994 --          jmp :!iDiag [DEV]
;   995 --          int3
;   996 
;   997 --newEmit/optable:
;   998 --/*
;   999 stack effects: #ilasm: any...!!!
;  1000 file        entry points
;  1001 pAbort.e
;  1002 ========
;  1003         :%opAbort
;  1004 --      (pFPU.e)    :%down53
;  1005 --      call :!opClosem9                -- (duplicates return addr, if called)
;  1006 --      call opFreeCons
;  1007 --      jmp :%opIaborted
;  1008 --*/
;  1009 
;  1010 --/*
;  1011 procedure :%SetCCleanup(:%)
;  1012 end procedure -- (for Edita/CtrlQ)
;  1013 --*/
;  1014     :%SetCCleanup
;  1015 ----------------
;  1016     [32]
;  1017         mov [CClean],eax
;  1018     [64]
;  1019         mov [CClean],rax
                mov [#00402F28] (CClean),rax  ;#00442A5C: 48:211005 C504FCFF         uv 00 01  1 175      
;  1020     []
;  1021         ret
                ret                       ;#00442A63: 303                        np 00 00  2 176      
;  1022 
;  1023 --/*
;  1024 procedure :%RunCleanup(:%)
;  1025 end procedure -- (for Edita/CtrlQ)
;  1026 --*/
;  1027     :%RunCleanup
;  1028 ----------------
;  1029 ::FreeStack
;  1030     [32]
;  1031         -- call :%opRetf until T_maintls
;  1032         cmp dword[ebp+8],21     -- T_maintls
;  1033         je @f
;  1034             mov dword[ebp+16],:FreeStack    -- replace return address
;  1035             jmp :%opRetf
;  1036       @@:
;  1037 
;  1038 --      mov edi,[freesym]
;  1039 --      call :%puts1
;  1040 --      mov edi,[closebr]
;  1041 --      call :%puts1
;  1042 
;  1043         mov eax,[CClean]
;  1044         shr eax,2
;  1045         jz @f
;  1046             call eax
;  1047       @@:
;  1048 
;  1049         mov esi,[ds+8]              -- (esi:=raw addr of symtab[1])
;  1050 
;  1051         mov ecx,[esi-12]            -- symlen
;  1052       ::CleanupLoop
;  1053 --pushad
;  1054 --      push ecx
;  1055 --      mov edi,[freesym]
;  1056 --      call :%puts1
;  1057 --      pop eax
;  1058 --      push 0
;  1059 --      call :%putsint
;  1060 --      mov edi,[closebr]
;  1061 --      call :%puts1
;  1062 --popad
;  1063 
;  1064         mov edi,[esi+ecx*4-4]       -- symtab[ecx]
;  1065         sub ecx,1
;  1066         cmp edi,h4
;  1067         jle @f
;  1068             mov edx,[ebx+edi*4+4]       -- symtab[ecx][S_NTyp]
;  1069             cmp edx,1                   -- <=2 (S_Const or S_GVar2)
;  1070             jne :opAgvar
;  1071                 test dword[ebx+edi*4+12],#200   -- K_noclr
;  1072                 jnz @f
;  1073           ::opAgvar
;  1074             cmp edx,2
;  1075             jg @f
;  1076                 -- S_Const w/o K_noclr and all S_Gvar2
;  1077                 mov eax,[esi+88]        -- eax:=symtab[T_ds4=23]
;  1078 --              mov edx,[ebx+edi*4+20]  -- symtab[ecx][S_Slink]
;  1079                 mov edi,[ebx+edi*4+20]  -- edi:=symtab[ecx][S_Slink]
;  1080 --              lea edi,[ds+8] -- no!
;  1081                 cmp [esi+84],ebx        -- symtab[T_EBP=22]=0?
;  1082                 je :compiled
;  1083                     shl eax,2
;  1084               ::compiled
;  1085 --              mov edx,[eax+edx*4+16]  -- gvar[symtab[ecx][S_Slink]]
;  1086                 mov edx,[eax+edi*4+16]  -- edx:=gvar[symtab[ecx][S_Slink]]
;  1087                 cmp edx,h4
;  1088                 jle @f
;  1089                     sub dword[ebx+edx*4-8],1
;  1090                     jnz @f
;  1091                         mov [eax+edi*4+16],ebx
;  1092                         pushad
;  1093                         call :%pDealloc
;  1094 
;  1095 --                      mov edi,[freesym]
;  1096 --                      call :%puts1
;  1097 --                      mov eax,[esp+24]    -- (ecx)
;  1098 --                      push 0
;  1099 --                      add eax,1
;  1100 --                      call :%putsint
;  1101 --                      mov edi,[closebr]
;  1102 --                      call :%puts1
;  1103 
;  1104                         popad
;  1105 --/*
;  1106         mov edi,[ecode]             -- "exception code #"
;  1107         call :%puts1
;  1108 
;  1109         mov edx,[edi]               -- exception_code
;  1110         push 0                      -- no cr
;  1111         call :%puthex32
;  1112 
;  1113         mov eax,[i]
;  1114         push [showcr]
;  1115         call :%putsint
;  1116 --*/
;  1117       @@:
;  1118         cmp ecx,26                  -- T_const1
;  1119         jg :CleanupLoop
;  1120 --      pop eax
;  1121 
;  1122         mov eax,[ebp+24]        -- vsb_root
;  1123       @@:
;  1124         push dword[eax+4]       -- vsb_next
;  1125         mov ecx,12280
;  1126 --DEV edx:=?                    -- era
;  1127         call :%pFreePool        -- release ecx bytes of memory at eax.
;  1128         pop eax
;  1129         test eax,eax
;  1130         jnz @b
;  1131         xor ebp,ebp
;  1132 
;  1133     [64]
;  1134         -- call :%opRetf until T_maintls
;  1135         cmp qword[rbp+16],21    -- T_maintls
                cmp qword[rbp+16],21      ;#00442A64: 48:203175 10 15            u  00 20  2 178      
;  1136         je @f
                je #00442A78              ;#00442A69: 164 0D                     v  00 00  1 179      
;  1137             mov qword[rbp+32],:FreeStack    -- replace return address
                    mov qword[retaddr],#00442A64  ;#00442A6B: 48:307105 20 642A4400      uv 00 20  1 180      
;  1138             jmp :%opRetf
                    jmp #0044298D (:%opRetf)  ;#00442A73: 351 15FFFFFF               v  00 00  1 180      
;  1139       @@:
;  1140 
;  1141         mov rax,[CClean]
                mov rax,[#00402F28] (CClean)  ;#00442A78: 48:213005 A904FCFF         uv 01 00  1 181      
;  1142         shr rax,2
                shr rax,2                 ;#00442A7F: 48:301350 02               u  01 01  1 182      
;  1143         jz @f
                jz #00442A87              ;#00442A83: 164 02                     v  00 00  1 182      
;  1144             call rax
                    call rax              ;#00442A85: 377320                     np 00 01  2 183      
;  1145       @@:
;  1146 
;  1147         mov rsi,[ds+8]              -- (rsi:=raw addr of symtab[1])
                mov rsi,qword[#00402008]  ;#00442A87: 48:213065 7AF5FBFF         uv 40 00  1 185      
;  1148 
;  1149         mov rcx,[rsi-24]            -- symlen
                mov rcx,[rsi-24]          ;#00442A8E: 48:213116 E8               uv 02 40  1 188 40 *40*
;  1150         mov r15,h4
                mov r15,h4                ;#00442A92: 49:277 0000000000000040    vu 8000 00  1 188      
;  1151       ::CleanupLoop
;  1152         mov rdi,[rsi+rcx*8-8]       -- symtab[rcx]
                mov rdi,[rsi+rcx*8-8]     ;#00442A9C: 48:213174316 F8            uv 80 42  1 191    *02*
;  1153         sub rcx,1
                sub rcx,1                 ;#00442AA1: 48:203351 01               vu 02 02  1 191      
;  1154         cmp rdi,r15
                cmp rdi,r15               ;#00442AA5: 49:073377                  uv 00 8080  1 192      
;  1155         jle @f
                jle #00442B02             ;#00442AA8: 176 58                     v  00 00  1 192      
;  1156             mov rdx,[rbx+rdi*8+8]       -- symtab[ecx][S_NTyp]
                    mov rdx,[rbx+rdi*8+8]  ;#00442AAA: 48:213124373 08            uv 04 88  1 193      
;  1157             cmp rdx,1                   -- <=2 (S_Const or S_GVar2)
                    cmp rdx,1             ;#00442AAF: 48:203372 01               uv 00 04  1 194 04   
;  1158             jne :opAgvar
                    jne #00442AC0         ;#00442AB3: 165 0B                     v  00 00  1 194      
;  1159                 test qword[rbx+rdi*8+24],#200   -- K_noclr
                        test qword[rbx+rdi*8+24],512  ;#00442AB5: 48:367104373 18 00020000   u  00 88  2 195      
;  1160                 jnz @f
                        jnz #00442B02     ;#00442ABE: 165 42                     v  00 00  1 196      
;  1161           ::opAgvar
;  1162             cmp rdx,2
                    cmp rdx,2             ;#00442AC0: 48:203372 02               uv 00 04  1 197      
;  1163             jg @f
                    jg #00442B02          ;#00442AC4: 177 3C                     v  00 00  1 197      
;  1164                 -- S_Const w/o K_noclr and all S_Gvar2
;  1165                 mov rax,[rsi+22*8]      -- eax:=symtab[T_ds4=23]
                        mov rax,[rsi+176]  ;#00442AC6: 48:213206 B0000000         uv 01 40  1 198      
;  1166                 mov rdi,[rbx+rdi*8+40]  -- edi:=symtab[rdi][S_Slink]
                        mov rdi,[rbx+rdi*8+40]  ;#00442ACD: 48:213174373 28            vu 80 88  1 198      
;  1167                 cmp [rsi+21*8],rbx      -- symtab[T_EBP=22]=0?
                        cmp [rsi+168],rbx  ;#00442AD2: 48:071236 A8000000         uv 00 48  2 199      
;  1168                 je :compiled
                        je #00442ADF      ;#00442AD9: 164 04                     v  00 00  1 200      
;  1169                     shl rax,2
                            shl rax,2     ;#00442ADB: 48:301340 02               u  01 01  1 201      
;  1170               ::compiled
;  1171                 mov rdx,[rax+rdi*8+32]  -- edx:=gvar[symtab[ecx][S_Slink]]
                        mov rdx,[rax+rdi*8+32]  ;#00442ADF: 48:213124370 20            uv 04 81  1 204 01 *01*
;  1172                 cmp rdx,r15
                        cmp rdx,r15       ;#00442AE4: 49:073327                  uv 00 8004  1 205 04   
;  1173                 jle @f
                        jle #00442B02     ;#00442AE7: 176 19                     v  00 00  1 205      
;  1174                     sub qword[rbx+rdx*4-16],1
                            sub qword[rbx+rdx*4-16],1  ;#00442AE9: 48:203154223 F0 01         u  00 0C  3 206      
;  1175                     jnz @f
                            jnz #00442B02  ;#00442AEF: 165 11                     v  00 00  1 208      
;  1176                         mov [rax+rdi*8+32],ebx
                                mov [rax+rdi*8+32],ebx  ;#00442AF1: 211134370 20               uv 00 89  1 209      
;  1177 --                      pushad
;  1178                         push rsi
                                push rsi  ;#00442AF5: 48:126                     vu 00 40  1 209      
;  1179                         push rcx
                                push rcx  ;#00442AF7: 48:121                     uv 00 02  1 210      
;  1180                         call :%pDealloc
                                call #004422DA (:%pDealloc)  ;#00442AF9: 350 DCF7FFFF               v  00 00  1 210      
;  1181 --                      popad
;  1182                         pop rcx
                                pop rcx   ;#00442AFE: 48:131                     uv 02 00  1 211      
;  1183                         pop rsi
                                pop rsi   ;#00442B00: 48:136                     vu 40 00  1 211      
;  1184       @@:
;  1185         cmp rcx,26                  -- T_const1
                cmp rcx,26                ;#00442B02: 48:203371 1A               uv 00 02  1 212      
;  1186         jg :CleanupLoop
                jg #00442A9C              ;#00442B06: 177 94                     v  00 00  1 212      
;  1187 
;  1188         mov rax,[rbp+48]        -- vsb_root
                mov rax,[rbp+48]          ;#00442B08: 48:213105 30               uv 01 20  1 213      
;  1189       @@:
;  1190         push qword[rax+8]       -- vsb_next
                push qword[rax+8]         ;#00442B0C: 48:377160 08               np 00 01  2 216    *01*
;  1191 --pHeapD:
;  1192 --<     mov rcx,9208
;  1193         mov rcx,11248
                mov rcx,11248             ;#00442B10: 48:307301 F02B0000         uv 02 00  1 218      
;  1194 --DEV rdx:=?                    -- era
;  1195         call :%pFreePool        -- release rcx bytes of memory at rax.
                call #00441FFA (:%pFreePool)  ;#00442B17: 350 DEF4FFFF               v  00 00  1 218      
;  1196         pop rax
                pop rax                   ;#00442B1C: 48:130                     uv 01 00  1 219      
;  1197         test rax,rax
                test rax,rax              ;#00442B1E: 48:205300                  uv 00 01  1 220 01   
;  1198         jnz @b
                jnz #00442B0C             ;#00442B21: 165 E9                     v  00 00  1 220      
;  1199         xor rbp,rbp
                xor rbp,rbp               ;#00442B23: 48:061355                  uv 20 20  1 221      
;  1200     []
;  1201         ret
                ret                       ;#00442B26: 303                        np 00 00  2 222      
;  1202 
;  1203 --/*
;  1204 procedure :%NoCleanup(:%)
;  1205 end procedure -- (for Edita/CtrlQ)
;  1206 --*/
;  1207     :%NoCleanup     -- ( this is not explicitly part of the VM )
;  1208 ---------------
;  1209         -- called by (eg) :!iDiag to make abort() etc invoke ExitProcess properly, 
;  1210         --  rather than try and return an error code to p.exw/pmain.e, which will
;  1211         --  then have a fit since c_cleanup() etc have not been called...
;  1212         -- Note this should stop :%RunCleanup being called, rather than change the
;  1213         --  way it works or otherwise bothering to test this flag.
;  1214         mov [nocleanup],1
                mov qword[#00402F24],1    ;#00442B27: 48:307005 F203FCFF 01000000 uv 00 00  1 224      
;  1215         ret
                ret                       ;#00442B32: 303                        np 00 00  2 225      
;  1216 
;  1217 --/*
;  1218 procedure :%opAbort(:%)
;  1219 end procedure -- (for Edita/CtrlQ)
;  1220 --*/
;  1221     :%opAbort
;  1222 -------------
;  1223 
;  1224 --DEV cleanup code...
;  1225 
;  1226 
;  1227 --/*
;  1228 --      call :%pLoadMint (with era mods, or as below)
;  1229     [32]
;  1230         cmp eax,h4
;  1231         jl @f
;  1232             shl eax,2
;  1233 --              jz e92vhnbaavespm9  -- or opUnassigned [DEV]
;  1234             jz :e87acmbi
;  1235             cmp byte[eax-1],0x12
;  1236             jne :e87acmbi   -- abort condition must be integer
;  1237             sub esp,8
;  1238             fld qword[eax]
;  1239             call :%down53
;  1240             fistp qword[esp]
;  1241             call :%near53
;  1242             mov eax,[esp]
;  1243             add esp,8
;  1244         @@:
;  1245     [64]
;  1246         pop al
;  1247     []
;  1248 --*/
;  1249 
;  1250 --!/*
;  1251     [32]
;  1252         mov esi,[ds+8]              -- esi:=raw addr of symtab[1]
;  1253         cmp eax,h4
;  1254         jl @f
;  1255             int3    -- abort code must be integer
;  1256       @@:
;  1257         mov edx,[esi+84]            -- edx:=symtab[T_EBP=22]
;  1258         mov ecx,[nocleanup]
;  1259         test edx,edx
;  1260         jz @f
;  1261         test ecx,ecx
;  1262         jnz @f
;  1263             -- interpreted
;  1264             mov ecx,[ebx+edx*4+4]   -- symtab[T_EBP][2] = esp4
;  1265             lea esp,[ebx+ecx*4-8]
;  1266             ret
;  1267           ::Exit0
;  1268             xor eax,eax
;  1269       @@:
;  1270     [64]
;  1271         mov r15,h4
                mov r15,h4                ;#00442B33: 49:277 0000000000000040    uv 8000 00  1 227      
;  1272         mov rsi,[ds+8]              -- rsi:=raw addr of symtab[1]
                mov rsi,qword[#00402008]  ;#00442B3D: 48:213065 C4F4FBFF         vu 40 00  1 227      
;  1273         cmp rax,r15
                cmp rax,r15               ;#00442B44: 49:073307                  uv 00 8001  1 228      
;  1274         jl @f
                jl #00442B4A              ;#00442B47: 174 01                     v  00 00  1 228      
;  1275             int3
                    int3                  ;#00442B49: 314                        np 00 00 13 229      
;  1276       @@:
;  1277         mov rdx,[rsi+168]           -- rdx:=symtab[T_EBP=22]
                mov rdx,[rsi+168]         ;#00442B4A: 48:213226 A8000000         uv 04 40  1 242      
;  1278         mov rcx,[nocleanup]
                mov rcx,[#00402F20] (nocleanup)  ;#00442B51: 48:213015 C803FCFF         vu 02 00  1 242      
;  1279         test rdx,rdx
                test rdx,rdx              ;#00442B58: 48:205322                  uv 00 04  1 243      
;  1280         jz @f
                jz #00442B70              ;#00442B5B: 164 13                     v  00 00  1 243      
;  1281         test rcx,rcx
                test rcx,rcx              ;#00442B5D: 48:205311                  uv 00 02  1 244      
;  1282         jnz @f
                jnz #00442B70             ;#00442B60: 165 0E                     v  00 00  1 244      
;  1283             -- interpreted
;  1284             mov rcx,[rbx+rdx*4+8]   -- symtab[T_EBP][2] = esp4
                    mov rcx,[rbx+rdx*4+8]  ;#00442B62: 48:213114223 08            uv 02 0C  1 245      
;  1285             lea rsp,[rbx+rcx*4-16]
                    lea rsp,[rbx+rcx*4-16]  ;#00442B67: 48:215144213 F0            uv 10 0A  1 248 02 *02*
;  1286             ret
                    ret                   ;#00442B6C: 303                        np 00 00  2 249      
;  1287           ::Exit0
;  1288             xor rax,rax
                    xor rax,rax           ;#00442B6D: 48:061300                  uv 01 01  1 251      
;  1289       @@:
;  1290     []
;  1291 
;  1292 
;  1293     [PE32]
;  1294         push eax                        -- uExitCode (for ExitProcess)
;  1295         --
;  1296         -- If pfileioN.e has not been included this resolves to "call 0", aka "push <addr next instruction>"
;  1297         --  whereas, obviously, if pfileioN.e /has/ been included this does the expected thing, however it
;  1298         --  (ie ":!opClosem9") deliberately leaves the return address on the stack, for the "add esp,4" 
;  1299         --  after the call.
;  1300         --
;  1301 --          call :!opClosem9                -- (duplicates return addr, if called)
;  1302 --          add esp,4                       -- (discard "", or a call 0's "this")
;  1303         call "kernel32.dll","ExitProcess"
;  1304 --          ret
;  1305     [PE64]
;  1306         mov rcx,rsp -- put 2 copies of rsp onto the stack...
                mov rcx,rsp               ;#00442B70: 48:213314                  vu 02 10  1 251      
;  1307         push rsp
                push rsp                  ;#00442B73: 48:124                     uv 00 10  1 252      
;  1308         push rcx
                push rcx                  ;#00442B75: 48:121                     vu 00 02  1 252      
;  1309         or rsp,8    -- [rsp] is now 1st or 2nd copy:
                or rsp,8                  ;#00442B77: 48:203314 08               uv 10 10  1 253      
;  1310                     -- if on entry rsp was xxx8: both copies remain on the stack
;  1311                     -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1312                     -- obviously rsp is now xxx8, whatever alignment we started with
;  1313         sub rsp,8*5
                sub rsp,40                ;#00442B7B: 48:203354 28               uv 10 10  1 254 10   
;  1314         mov rcx,rax                     -- uExitCode
                mov rcx,rax               ;#00442B7F: 48:213310                  vu 02 01  1 254      
;  1315         call "kernel32.dll","ExitProcess"
                call [#00401050] (ExitProcess)  ;#00442B82: 377025 C8E4FBFF            np 00 00  2 255      
;  1316 --          add rsp,8*5
;  1317 --          pop rsp     -- restore, equivalent to rsp += (either #08 or #10)
;  1318 --          mov rsp,[rsp+8*5]   -- equivalent to the add/pop
;  1319     [ELF32]
;  1320         mov ebx,eax                     -- error_code (p1)
;  1321         mov eax,1                       -- sys_exit(ebx=int error_code)
;  1322         int 0x80
;  1323 --          xor ebx,ebx                     -- (common requirement)
;  1324     [ELF64]
;  1325         mov rdi,rax                     -- error_code (p1)
;  1326         mov rax,60                      -- sys_exit(rdi=int error_code)
;  1327         syscall
;  1328     []
;  1329 
;  1330 --/*
;  1331 :%opAbort
;  1332 ---------
;  1333 
;  1334 if debugleak
;  1335     mov [echk],0        ;; not all cleanup code has run; skip the memory check.
;  1336 end if
;  1337 
;  1338     cmp edx,h4
;  1339     jl @f
;  1340         shl edx,2
;  1341         jz e92vhnbaavespm9
;  1342         cmp byte[edx-1],0x12
;  1343         jne e87acmbi    ; abort condition must be integer
;  1344         fld qword[edx]
;  1345         mov edx,FltWrk
;  1346         fldcw [down53]
;  1347         fistp qword[edx]
;  1348         fldcw [near53]
;  1349         mov edx,[edx]
;  1350     @@:
;  1351 
;  1352     push edx
;  1353     call opClosem1
;  1354 cmp [ebpidx],0
;  1355 jne @f
;  1356     call opFreeCons
;  1357     pop edx
;  1358     invoke ExitProcess,edx
;  1359 @@:
;  1360     pop edx
;  1361     mov [ecode],edx
;  1362 mov esp,[resp]
;  1363 jmp :%opIaborted
;  1364 --*/
;  1365 
;  1366 }
;  1367 
;  1368 
    jmp #0044298D (:%opRetf)              ;#00442B88: 351 00FEFFFF               v  00 00  1 257      
;C:\Program Files (x86)\Phix\builtins\VM\pFEH.e:
;===============================================
;     1 --
;     2 -- pFEH.e
;     3 --
;     4 --  The Phix final exception handler
;     5 --
;     6 --  This can display some machine-level diagnostics, which can be useful as long as
;     7 --  you have a matching list.asm, and is always loaded, unlike pdiagN.e, which can
;     8 --  be omitted (via the -nodiag command line option), and generally concerns itself
;     9 --  with hll-level diagnostics. Obviously this division of labour is intended to
;    10 --  assist with issues in the compiler or more accurately builtins\VM, rather than
;    11 --  in a more typical hll application.
;    12 --
;    13 
;    14 --without debug
;    15 
;    16 include builtins\VM\puts1.e         -- low-level console i/o
;    17 include builtins\VM\pUnassigned.e   -- opCallOnceYeNot etc
;    18 
;    19 --constant edetected = "exception detected, exception_pointers is #"
;    20 --constant comma = ",\n"
;    21 --constant erecord = "exception record is #"
;    22 --constant econtext = "exception context is #"
;    23 
;    24 constant ecode = "exception code #"
;    25 constant eat = " at #"
;    26 constant eaxis = "eax: ", ebxis = "ebx: ", ecxis = "ecx: ", edxis = "edx: ", esiis = "esi: ", ediis = "edi: "
;    27 --          (the above constants are rudely patched to rax..rdi under 64-bit, but later restored, btw.)
;    28 --constant setuef = "SetUnhandledExceptionFilter is #"
;    29 
;    30 integer finit = 0
;    31 
;    32 #ilASM{ jmp :!opCallOnceYeNot
                jmp :!opCallOnceYeNot     ;#00442613: 351 CA070000               v  00 00  1   1      
;    33 
;    34   :>initFEH
;    35         cmp [finit],0
                cmp qword[#00402F00] (finit),0  ;#00442618: 48:203075 E008FCFF 00      u  00 00  2   2      
;    36         jne :dont_do_everything_twice
                jne #0044264E             ;#00442620: 165 2C                     v  00 00  1   3      
;    37         mov [finit],1
                mov qword[#00402F00] (finit),1  ;#00442622: 48:307005 D308FCFF 01000000 uv 00 00  1   4      
;    38     [PE32]
;    39 --DEV temp (passed...)
;    40 --      mov edi,[setuef]            -- "SetUnhandledExceptionFilter is #"
;    41 --      call :%puts1
;    42 --      mov esi,:sehcall
;    43 --      mov edx,[esi+2]
;    44 --      mov edx,[edx]
;    45 --      push 1                      -- cr
;    46 --      call :%puthex32
;    47 --DEV /temp
;    48         mov eax,:finalExceptionHandler
;    49         push eax                                    -- lpTopLevelExceptionFilter
;    50 --::sehcall
;    51         call "kernel32.dll","SetUnhandledExceptionFilter"
;    52     [PE64]
;    53         mov rcx,rsp -- put 2 copies of rsp onto the stack...
                mov rcx,rsp               ;#0044262D: 48:213314                  vu 02 10  1   4      
;    54         push rsp
                push rsp                  ;#00442630: 48:124                     uv 00 10  1   5      
;    55         push rcx
                push rcx                  ;#00442632: 48:121                     vu 00 02  1   5      
;    56         or rsp,8    -- [rsp] is now 1st or 2nd copy:
                or rsp,8                  ;#00442634: 48:203314 08               uv 10 10  1   6      
;    57                     -- if on entry rsp was xxx8: both copies remain on the stack
;    58                     -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;    59                     -- obviously rsp is now xxx8, whatever alignment we started with
;    60         sub rsp,8*5
                sub rsp,40                ;#00442638: 48:203354 28               uv 10 10  1   7 10   
;    61         mov rcx,:finalExceptionHandler              -- lpTopLevelExceptionFilter
                mov rcx,#0044264F         ;#0044263C: 48:307301 4F264400         vu 02 00  1   7      
;    62         call "kernel32.dll","SetUnhandledExceptionFilter"
                call [SetUnhandledExceptionFilter]  ;#00442643: 377025 E7EAFBFF            np 00 00  2   8      
;    63 --      add rsp,8*5
;    64 --      pop rsp     -- restore, equivalent to rsp += (either #08 or #10)
;    65         mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                mov rsp,[rsp+40]          ;#00442649: 48:213144044 28            uv 10 10  1  10      
;    66     [ELF32]
;    67         pop al
;    68 --48        sys_signal                  0x30    int sig                 __sighandler_t handler  -                       -                       -               kernel/signal.c:2683
;    69 --67        sys_sigaction               0x43    int sig                 const struct old_sigaction *act struct old_sigaction *oact  -           -               arch/mips/kernel/signal.c:300
;    70 --119       sys_sigreturn               0x77    struct pt_regs *regs    -                       -                       -                       -               arch/alpha/kernel/entry.S:758
;    71 --see also SYSCALL_SIGNAL below (best bet?)
;    72 -- got it!: http://syprog.blogspot.co.uk/2011/10/iterfacing-linux-signals.html (saved in edita14)
;    73     [ELF64]
;    74         pop al
;    75     []
;    76       ::dont_do_everything_twice
;    77         ret
                ret                       ;#0044264E: 303                        np 00 00  2  11      
;    78 
;    79 
;    80       ::finalExceptionHandler
;    81     [PE32]
;    82         xor ebx,ebx -- important!!
;    83 
;    84         call :lowlevel              -- (temp)
;    85 
;    86         mov esi,[esp+4]             -- EXCEPTION_POINTERS
;    87         mov edi,[esi]               -- EXCEPTION_RECORD
;    88         mov esi,[esi+4]             -- CONTEXT_RECORD
;    89         mov ecx,[edi]               -- exception_code
;    90         mov edx,[esi+184]           -- or_eip (exception_addr)
;    91         mov ebp,[esi+180]           -- or_ebp (restore)
;    92         mov edi,esp                 -- (in case :!fehDiag not called)
;    93         mov esp,[esi+196]           -- or_esp
;    94 
;    95         -- special cases:
;    96         cmp edx,:!blockfound
;    97         jne @f
;    98             -- heap corruption: zero pTCB.pFree[idx] to minimise knock-on effects
;    99             push edi
;   100             push esi
;   101             mov edi,[esi+156]   -- or_edi
;   102             mov esi,[esi+160]   -- or_esi
;   103             mov [esi*4+edi+20],ebx  -- pTCB.pFree[idx]:=0 (see pHeap.e)
;   104             pop esi
;   105             pop edi
;   106       @@:
;   107 
;   108         --  esi is context record (save everything once we get into :!fehDiag)
;   109         --  edx is exception address
;   110         --  ecx is exception code
;   111         --  ebx, ebp, and esp have been reset
;   112         call :!fehDiag              -- pdiagN.e, if loaded
;   113         -- (control does not return if called, unless looping)
;   114 --      add esp,4
;   115         mov esp,edi
;   116 
;   117         call :lowlevel              -- (not temp)
;   118 
;   119 --      call :%opClosem9
;   120 --      push dword[errcode]         -- uExitCode
;   121         push 1                      -- uExitCode
;   122         call "kernel32","ExitProcess"
;   123 
;   124       ::lowlevel
;   125         -- 
;   126         mov edi,[ecode]             -- "exception code #"
;   127         call :%puts1
;   128         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   129         mov edi,[esi]               -- EXCEPTION_RECORD
;   130         mov edx,[edi]               -- exception_code
;   131         push 0                      -- no cr
;   132         call :%puthex32
;   133         mov edi,[eat]               -- " at #"
;   134         call :%puts1
;   135         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   136         mov ecx,[esi+4]             -- CONTEXT_RECORD
;   137         mov edx,[ecx+184]           -- or_eip
;   138         push 1                      -- cr
;   139         call :%puthex32
;   140 
;   141         mov edi,[eaxis]             -- "eax: "
;   142         call :%puts1
;   143         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   144         mov ecx,[esi+4]             -- CONTEXT_RECORD
;   145         mov edx,[ecx+176]           -- or_eax
;   146         push 1                      -- cr
;   147         call :%puthex32
;   148         mov edi,[ebxis]             -- "ebx: "
;   149         call :%puts1
;   150         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   151         mov ecx,[esi+4]             -- CONTEXT_RECORD
;   152         mov edx,[ecx+164]           -- or_ebx
;   153         push 1                      -- cr
;   154         call :%puthex32
;   155         mov edi,[ecxis]             -- "ecx: "
;   156         call :%puts1
;   157         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   158         mov ecx,[esi+4]             -- CONTEXT_RECORD
;   159         mov edx,[ecx+172]           -- or_ecx
;   160         push 1                      -- cr
;   161         call :%puthex32
;   162         mov edi,[edxis]             -- "edx: "
;   163         call :%puts1
;   164         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   165         mov ecx,[esi+4]             -- CONTEXT_RECORD
;   166         mov edx,[ecx+168]           -- or_edx
;   167         push 1                      -- cr
;   168         call :%puthex32
;   169         mov edi,[esiis]             -- "esi: "
;   170         call :%puts1
;   171         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   172         mov ecx,[esi+4]             -- CONTEXT_RECORD
;   173         mov edx,[ecx+160]           -- or_esi
;   174         push 1                      -- cr
;   175         call :%puthex32
;   176         mov edi,[ediis]             -- "edi: "
;   177         call :%puts1
;   178         mov esi,[esp+8]             -- EXCEPTION_POINTERS
;   179         mov ecx,[esi+4]             -- CONTEXT_RECORD
;   180         mov edx,[ecx+156]           -- or_edi
;   181         push 1                      -- cr
;   182         call :%puthex32
;   183 
;   184         ret
;   185 
;   186     [ELF32]
;   187         pop al
;   188     [PE64]
;   189         xor rbx,rbx -- important!!
                xor rbx,rbx               ;#0044264F: 48:061333                  uv 08 08  1  13      
;   190 
;   191         mov [rsp+8],rcx             -- copy actual param into shadow space!
                mov [rsp+8],rcx           ;#00442652: 48:211114044 08            vu 00 12  1  13      
;   192         call :lowlevel              -- (temp) [DEV]
                call #004426C3            ;#00442657: 350 67000000               v  00 00  1  14      
;   193         mov rcx,[rsp+8]             --   ""
                mov rcx,[rsp+8]           ;#0044265C: 48:213114044 08            uv 02 10  1  15      
;   194 
;   195 --      mov rsi,[rsp+8]             -- EXCEPTION_POINTERS
;   196 --      mov rdi,[rsi]               -- EXCEPTION_RECORD
;   197         mov rdi,[rcx]               -- EXCEPTION_RECORD
                mov rdi,[rcx]             ;#00442661: 48:213071                  uv 80 02  1  18 02 *02*
;   198 --      mov rsi,[rsi+8]             -- CONTEXT_RECORD
;   199         mov rsi,[rcx+8]             -- CONTEXT_RECORD
                mov rsi,[rcx+8]           ;#00442664: 48:213161 08               vu 40 02  1  18      
;   200         mov rdx,[rsi+248]           -- DWORD64 Rip (exception_addr)
                mov rdx,[rsi+248]         ;#00442668: 48:213226 F8000000         uv 04 40  1  21    *40*
;   201         mov ecx,dword[rdi]          -- exception_code (DWORD)
                mov ecx,[edi]             ;#0044266F: 213017                     vu 02 80  1  21      
;   202         mov rbp,[rsi+160]           -- DWORD64 Rbp (restore)
                mov rbp,[rsi+160]         ;#00442671: 48:213256 A0000000         uv 20 40  1  22      
;   203         mov rdi,rsp                 -- (in case :!fehDiag not called)
                mov rdi,rsp               ;#00442678: 48:213374                  vu 80 10  1  22      
;   204         mov rsp,[rsi+152]           -- DWORD64 Rsp (restore)
                mov rsp,[rsi+152]         ;#0044267B: 48:213246 98000000         uv 10 40  1  23      
;   205 
;   206         -- special cases:
;   207 --      cmp rdx,:!blockfound
;   208         cmp edx,:!blockfound
                cmp edx,#00441F45         ;#00442682: 201372 451F4400            vu 00 04  1  23      
;   209         jne @f
                jne #004426A5             ;#00442688: 165 1B                     v  00 00  1  24      
;   210             -- heap corruption: zero pTCB.pFree[idx] to minimise knock-on effects
;   211             push rdi
                    push rdi              ;#0044268A: 48:127                     uv 00 80  1  25      
;   212             push rsi
                    push rsi              ;#0044268C: 48:126                     vu 00 40  1  25      
;   213             mov rdi,[rsi+176]       -- DWORD64 Rdi
                    mov rdi,[rsi+176]     ;#0044268E: 48:213276 B0000000         uv 80 40  1  26      
;   214             mov rsi,[rsi+168]       -- DWORD64 Rsi
                    mov rsi,[rsi+168]     ;#00442695: 48:213266 A8000000         vu 40 40  1  26      
;   215             mov [rsi*4+rdi+32],rbx  -- pTCB.pFree[idx]:=0 (see pHeap.e)
                    mov [rdi+rsi*4+32],rbx  ;#0044269C: 48:211134267 20            uv 00 C8  1  29    *C0*
;   216             pop rsi
                    pop rsi               ;#004426A1: 48:136                     vu 40 00  1  29      
;   217             pop rdi
                    pop rdi               ;#004426A3: 48:137                     uv 80 00  1  30      
;   218       @@:
;   219 
;   220         --  rsi is context record (save everything once we get into :!fehDiag)
;   221         --  rdx is exception address
;   222         --  ecx is exception code (DWORD)
;   223         --  rbx, rbp, and rsp have been reset
;   224         call :!fehDiag              -- pdiagN.e, if loaded
                call #00442F64 (:!fehDiag)  ;#004426A5: 350 BA080000               v  00 00  1  30      
;   225         -- (control does not return if called, unless looping)
;   226 --      add rsp,8
;   227         mov rsp,rdi
                mov rsp,rdi               ;#004426AA: 48:213347                  uv 10 80  1  31      
;   228 
;   229         call :lowlevel              -- (not temp, that copy rcx is rqd)
                call #004426C3            ;#004426AD: 350 11000000               v  00 00  1  31      
;   230 
;   231 --      call :!opClosem9
;   232 --      add rsp,8
;   233 --      push dword[errcode]         -- uExitCode
;   234         sub rsp,8*5
                sub rsp,40                ;#004426B2: 48:203354 28               uv 10 10  1  32      
;   235         mov rcx,1
                mov rcx,1                 ;#004426B6: 48:307301 01000000         vu 02 00  1  32      
;   236         call "kernel32","ExitProcess"
                call [#00401050] (ExitProcess)  ;#004426BD: 377025 8DE9FBFF            np 00 00  2  33      
;   237 
;   238       ::lowlevel
;   239 
;   240         mov rdi,[ecode]             -- "exception code #"
                mov rdi,[#00402EC0] (ecode)  ;#004426C3: 48:213075 F607FCFF         uv 80 00  1  35      
;   241         call :%puts1
                call #00442B92 (:%puts1)  ;#004426CA: 350 C3040000               v  00 00  1  35      
;   242         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#004426CF: 48:213164044 10            uv 40 10  1  36      
;   243         mov rdi,[rsi]               -- EXCEPTION_RECORD
                mov rdi,[rsi]             ;#004426D4: 48:213076                  uv 80 40  1  39 40 *40*
;   244         mov edx,[rdi]               -- exception_code (DWORD)
                mov edx,[edi]             ;#004426D7: 213027                     uv 04 80  1  42 80 *80*
;   245         push 0                      -- no cr
                push 0                    ;#004426D9: 152 00                     vu 00 00  1  42      
;   246         call :%puthex32
                call #00442BFC (:%puthex32)  ;#004426DB: 350 1C050000               v  00 00  1  43      
;   247         mov rdi,[eat]               -- " at #"
                mov rdi,[#00402EC8] (eat)  ;#004426E0: 48:213075 E107FCFF         uv 80 00  1  44      
;   248         call :%puts1
                call #00442B92 (:%puts1)  ;#004426E7: 350 A6040000               v  00 00  1  44      
;   249         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#004426EC: 48:213164044 10            uv 40 10  1  45      
;   250         mov rcx,[rsi+8]             -- CONTEXT_RECORD
                mov rcx,[rsi+8]           ;#004426F1: 48:213116 08               uv 02 40  1  48 40 *40*
;   251         mov rdx,[rcx+248]           -- DWORD64 Rip
                mov rdx,[rcx+248]         ;#004426F5: 48:213221 F8000000         uv 04 02  1  51 02 *02*
;   252         push 1
                push 1                    ;#004426FC: 152 01                     vu 00 00  1  51      
;   253         call :%puthex32
                call #00442BFC (:%puthex32)  ;#004426FE: 350 F9040000               v  00 00  1  52      
;   254 
;   255         mov rdi,[eaxis]             -- "rax: "
                mov rdi,[#00402ED0] (eaxis)  ;#00442703: 48:213075 C607FCFF         uv 80 00  1  53      
;   256         call :puts1r
                call #004427D3            ;#0044270A: 350 C4000000               v  00 00  1  53      
;   257         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#0044270F: 48:213164044 10            uv 40 10  1  54      
;   258         mov rcx,[rsi+8]             -- CONTEXT_RECORD
                mov rcx,[rsi+8]           ;#00442714: 48:213116 08               uv 02 40  1  57 40 *40*
;   259         mov rdx,[rcx+120]           -- DWORD64 Rax
                mov rdx,[rcx+120]         ;#00442718: 48:213121 78               uv 04 02  1  60 02 *02*
;   260         push 1                      -- cr
                push 1                    ;#0044271C: 152 01                     vu 00 00  1  60      
;   261         call :%puthex64
                call #00442C4C (:%puthex64)  ;#0044271E: 350 29050000               v  00 00  1  61      
;   262         mov rdi,[ebxis]             -- "rbx: "
                mov rdi,[#00402ED8] (ebxis)  ;#00442723: 48:213075 AE07FCFF         uv 80 00  1  62      
;   263         call :puts1r
                call #004427D3            ;#0044272A: 350 A4000000               v  00 00  1  62      
;   264         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#0044272F: 48:213164044 10            uv 40 10  1  63      
;   265         mov rcx,[rsi+8]             -- CONTEXT_RECORD
                mov rcx,[rsi+8]           ;#00442734: 48:213116 08               uv 02 40  1  66 40 *40*
;   266         mov rdx,[rcx+144]           -- DWORD64 Rbx
                mov rdx,[rcx+144]         ;#00442738: 48:213221 90000000         uv 04 02  1  69 02 *02*
;   267         push 1                      -- cr
                push 1                    ;#0044273F: 152 01                     vu 00 00  1  69      
;   268         call :%puthex64
                call #00442C4C (:%puthex64)  ;#00442741: 350 06050000               v  00 00  1  70      
;   269         mov rdi,[ecxis]             -- "rcx: "
                mov rdi,[#00402EE0] (ecxis)  ;#00442746: 48:213075 9307FCFF         uv 80 00  1  71      
;   270         call :puts1r
                call #004427D3            ;#0044274D: 350 81000000               v  00 00  1  71      
;   271         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#00442752: 48:213164044 10            uv 40 10  1  72      
;   272         mov rcx,[rsi+8]             -- CONTEXT_RECORD
                mov rcx,[rsi+8]           ;#00442757: 48:213116 08               uv 02 40  1  75 40 *40*
;   273         mov rdx,[rcx+128]           -- DWORD64 Rcx
                mov rdx,[rcx+128]         ;#0044275B: 48:213221 80000000         uv 04 02  1  78 02 *02*
;   274         push 1                      -- cr
                push 1                    ;#00442762: 152 01                     vu 00 00  1  78      
;   275         call :%puthex64
                call #00442C4C (:%puthex64)  ;#00442764: 350 E3040000               v  00 00  1  79      
;   276         mov rdi,[edxis]             -- "rdx: "
                mov rdi,[#00402EE8] (edxis)  ;#00442769: 48:213075 7807FCFF         uv 80 00  1  80      
;   277         call :puts1r
                call #004427D3            ;#00442770: 350 5E000000               v  00 00  1  80      
;   278         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#00442775: 48:213164044 10            uv 40 10  1  81      
;   279         mov rcx,[rsi+8]             -- CONTEXT_RECORD
                mov rcx,[rsi+8]           ;#0044277A: 48:213116 08               uv 02 40  1  84 40 *40*
;   280         mov rdx,[rcx+136]           -- DWORD64 Rdx
                mov rdx,[rcx+136]         ;#0044277E: 48:213221 88000000         uv 04 02  1  87 02 *02*
;   281         push 1                      -- cr
                push 1                    ;#00442785: 152 01                     vu 00 00  1  87      
;   282         call :%puthex64
                call #00442C4C (:%puthex64)  ;#00442787: 350 C0040000               v  00 00  1  88      
;   283         mov rdi,[esiis]             -- "rsi: "
                mov rdi,[#00402EF0] (esiis)  ;#0044278C: 48:213075 5D07FCFF         uv 80 00  1  89      
;   284         call :puts1r
                call #004427D3            ;#00442793: 350 3B000000               v  00 00  1  89      
;   285         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#00442798: 48:213164044 10            uv 40 10  1  90      
;   286         mov rcx,[rsi+8]             -- CONTEXT_RECORD
                mov rcx,[rsi+8]           ;#0044279D: 48:213116 08               uv 02 40  1  93 40 *40*
;   287         mov rdx,[rcx+168]           -- DWORD64 Rsi
                mov rdx,[rcx+168]         ;#004427A1: 48:213221 A8000000         uv 04 02  1  96 02 *02*
;   288         push 1                      -- cr
                push 1                    ;#004427A8: 152 01                     vu 00 00  1  96      
;   289         call :%puthex64
                call #00442C4C (:%puthex64)  ;#004427AA: 350 9D040000               v  00 00  1  97      
;   290         mov rdi,[ediis]             -- "rdi: "
                mov rdi,[#00402EF8] (ediis)  ;#004427AF: 48:213075 4207FCFF         uv 80 00  1  98      
;   291         call :puts1r
                call #004427D3            ;#004427B6: 350 18000000               v  00 00  1  98      
;   292         mov rsi,[rsp+16]            -- EXCEPTION_POINTERS
                mov rsi,[rsp+16]          ;#004427BB: 48:213164044 10            uv 40 10  1  99      
;   293         mov rcx,[rsi+8]             -- CONTEXT_RECORD
                mov rcx,[rsi+8]           ;#004427C0: 48:213116 08               uv 02 40  1 102 40 *40*
;   294         mov rdx,[rcx+176]           -- DWORD64 Rdi
                mov rdx,[rcx+176]         ;#004427C4: 48:213221 B0000000         uv 04 02  1 105 02 *02*
;   295         push 1                      -- cr
                push 1                    ;#004427CB: 152 01                     vu 00 00  1 105      
;   296         call :%puthex64
                call #00442C4C (:%puthex64)  ;#004427CD: 350 7A040000               v  00 00  1 106      
;   297 
;   298         ret
                ret                       ;#004427D2: 303                        np 00 00  2 107      
;   299 
;   300       ::puts1r
;   301         push rdi
                push rdi                  ;#004427D3: 48:127                     uv 00 80  1 109      
;   302         mov byte[rbx+rdi*4],'r'     -- eax->rax etc
                mov [rbx+rdi*4], byte 114  ;#004427D5: 306004273 72               vu 00 88  1 109      
;   303         call :%puts1
                call #00442B92 (:%puts1)  ;#004427D9: 350 B4030000               v  00 00  1 110      
;   304         pop rdi
                pop rdi                   ;#004427DE: 48:137                     uv 80 00  1 111      
;   305         mov byte[rbx+rdi*4],'e'     -- restore (in case values are shared)
                mov [rbx+rdi*4], byte 101  ;#004427E0: 306004273 65               uv 00 88  1 114 80 *80*
;   306         ret
                ret                       ;#004427E4: 303                        np 00 00  2 115      
;   307 
;   308     [ELF64]
;   309         pop al
;   310     []
;   311 
;   312 --::fin
;   313       }
;   314 
;   315 --/*
;   316 virtual at edx  ; exception_pointers
;   317     exception_record dd ?
;   318     context_record   dd ?
;   319 end virtual
;   320 
;   321 typedef struct _EXCEPTION_RECORD {
;   322   DWORD                    ExceptionCode;
;   323   DWORD                    ExceptionFlags;
;   324   struct _EXCEPTION_RECORD  *ExceptionRecord;
;   325   PVOID                    ExceptionAddress;
;   326   DWORD                    NumberParameters;
;   327   ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;   328 } EXCEPTION_RECORD, *PEXCEPTION_RECORD;
;   329            
;   330 virtual at eax  ; exception_record
;   331     exception_code  dd ?
;   332     exception_flag  dd ?
;   333     nested          dd ?
;   334     exception_addr  dd ?
;   335     noof_params     dd ?
;   336     addtnl_data     dd ?
;   337 end virtual
;   338 
;   339 /* Exception record (32-bit version) */
;   340 typedef struct _EXCEPTION_RECORD32 {
;   341     DWORD   ExceptionCode;
;   342     DWORD   ExceptionFlags;
;   343     DWORD   ExceptionRecord;
;   344     DWORD   ExceptionAddress;
;   345     DWORD   NumberParameters;
;   346     DWORD   ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;   347 } EXCEPTION_RECORD32;
;   348 typedef EXCEPTION_RECORD32  *PEXCEPTION_RECORD32;
;   349 
;   350 /* Exception record (64-bit version) */
;   351 typedef struct _EXCEPTION_RECORD64 {
;   352     DWORD   ExceptionCode;
;   353     DWORD   ExceptionFlags;
;   354     DWORD64 ExceptionRecord;
;   355     DWORD64 ExceptionAddress;
;   356     DWORD   NumberParameters;
;   357     DWORD   __unusedAlignment;
;   358     DWORD64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;   359 } EXCEPTION_RECORD64;
;   360 typedef EXCEPTION_RECORD64  *PEXCEPTION_RECORD64;
;   361 
;   362 /* Pointers to exception and context records */
;   363 typedef struct _EXCEPTION_POINTERS {
;   364     PEXCEPTION_RECORD   ExceptionRecord;
;   365     PCONTEXT            ContextRecord;
;   366 } EXCEPTION_POINTERS;
;   367 typedef EXCEPTION_POINTERS  *PEXCEPTION_POINTERS;
;   368 
;   369 
;   370 typedef struct _CONTEXT {
;   371 0       DWORD   ContextFlags;
;   372 4       DWORD   Dr0;
;   373 8       DWORD   Dr1;
;   374 12      DWORD   Dr2;
;   375 16      DWORD   Dr3;
;   376 20      DWORD   Dr6;
;   377 24      DWORD   Dr7;
;   378 +112    FLOATING_SAVE_AREA FloatSave;
;   379 136     DWORD   SegGs;
;   380         DWORD   SegFs;
;   381         DWORD   SegEs;
;   382         DWORD   SegDs;
;   383         DWORD   Edi;
;   384         DWORD   Esi;
;   385         DWORD   Ebx;
;   386         DWORD   Edx;
;   387         DWORD   Ecx;
;   388         DWORD   Eax;
;   389         DWORD   Ebp;
;   390         DWORD   Eip;
;   391         DWORD   SegCs;
;   392         DWORD   EFlags;
;   393         DWORD   Esp;
;   394         DWORD   SegSs;
;   395         BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
;   396 } CONTEXT;
;   397 
;   398 virtual at eax  ; context_record
;   399 0   context_flags   dd ?
;   400 4   dr_0            dd ?    ; debug register 0
;   401 8   dr_1            dd ?
;   402 12  dr_2            dd ?
;   403 16  dr_3            dd ?
;   404 20  dr_6            dd ?
;   405 24  dr_7            dd ?
;   406 28  fp_cw           dd ?    ; control word
;   407 32  fp_sw           dd ?    ; status word
;   408 36  fp_tw           dd ?    ; tag word
;   409 40  fp_eo           dd ?    ; error offset
;   410 44  fp_es           dd ?    ; error selector
;   411 48  fp_do           dd ?    ; data offset
;   412 52  fp_ds           dd ?    ; data selector
;   413 56  fp_st0          dt ?    ; floating point register 0
;   414 66  fp_st1          dt ?
;   415 76  fp_st2          dt ?
;   416 86  fp_st3          dt ?
;   417 96  fp_st4          dt ?
;   418 106 fp_st5          dt ?
;   419 116 fp_st6          dt ?
;   420 126 fp_st7          dt ?
;   421 136 fp_cron         dd ?    ; ? Cr0NpxState ?
;   422 140 sr_gs           dd ?    ; gs register
;   423 144 sr_fs           dd ?    ; gs register
;   424 148 sr_es           dd ?    ; gs register
;   425 152 sr_ds           dd ?    ; gs register
;   426 156 or_edi          dd ?    ; edi
;   427 160 or_esi          dd ?    ; esi
;   428 164 or_ebx          dd ?
;   429 168 or_edx          dd ?
;   430 172 or_ecx          dd ?
;   431 176 or_eax          dd ?
;   432 180 or_ebp          dd ?
;   433 184 or_eip          dd ?        #B8 = 184 (tick)
;   434 188 or_cs           dd ?
;   435 192 or_eflags       dd ?
;   436 196 or_esp          dd ?
;   437 200 or_ss           dd ?
;   438 end virtual
;   439 
;   440 typedef struct DECLSPEC_ALIGN(16) _CONTEXT {
;   441 
;   442     //
;   443     // Register parameter home addresses.
;   444     //
;   445     // N.B. These fields are for convience - they could be used to extend the
;   446     //      context record in the future.
;   447     //
;   448 
;   449 0   DWORD64 P1Home;
;   450 8   DWORD64 P2Home;
;   451 16  DWORD64 P3Home;
;   452 24  DWORD64 P4Home;
;   453 32  DWORD64 P5Home;
;   454 40  DWORD64 P6Home;
;   455 
;   456     //
;   457     // Control flags.
;   458     //
;   459 
;   460 48  DWORD ContextFlags;
;   461 52  DWORD MxCsr;
;   462 
;   463     //
;   464     // Segment Registers and processor flags.
;   465     //
;   466 
;   467 56  WORD   SegCs;
;   468 58  WORD   SegDs;
;   469 60  WORD   SegEs;
;   470 62  WORD   SegFs;
;   471 64  WORD   SegGs;
;   472 66  WORD   SegSs;
;   473 68  DWORD EFlags;
;   474 
;   475     //
;   476     // Debug registers
;   477     //
;   478 
;   479 72  DWORD64 Dr0;
;   480 80  DWORD64 Dr1;
;   481 88  DWORD64 Dr2;
;   482 96  DWORD64 Dr3;
;   483 104 DWORD64 Dr6;
;   484 112 DWORD64 Dr7;
;   485 
;   486     //
;   487     // Integer registers.
;   488     //
;   489 
;   490 120 DWORD64 Rax;
;   491 128 DWORD64 Rcx;
;   492 136 DWORD64 Rdx;
;   493 144 DWORD64 Rbx;
;   494 152 DWORD64 Rsp;
;   495 160 DWORD64 Rbp;
;   496 168 DWORD64 Rsi;
;   497 176 DWORD64 Rdi;
;   498 184 DWORD64 R8;
;   499 192 DWORD64 R9;
;   500 200 DWORD64 R10;
;   501 208 DWORD64 R11;
;   502 216 DWORD64 R12;
;   503 224 DWORD64 R13;
;   504 232 DWORD64 R14;
;   505 240 DWORD64 R15;
;   506 
;   507     //
;   508     // Program counter.
;   509     //
;   510 
;   511 248 DWORD64 Rip;
;   512 
;   513     //
;   514     // Floating point state.
;   515     //
;   516 
;   517     union {
;   518         XMM_SAVE_AREA32 FltSave;
;   519         struct {
;   520             M128A Header[2];
;   521             M128A Legacy[8];
;   522             M128A Xmm0;
;   523             M128A Xmm1;
;   524             M128A Xmm2;
;   525             M128A Xmm3;
;   526             M128A Xmm4;
;   527             M128A Xmm5;
;   528             M128A Xmm6;
;   529             M128A Xmm7;
;   530             M128A Xmm8;
;   531             M128A Xmm9;
;   532             M128A Xmm10;
;   533             M128A Xmm11;
;   534             M128A Xmm12;
;   535             M128A Xmm13;
;   536             M128A Xmm14;
;   537             M128A Xmm15;
;   538         } DUMMYSTRUCTNAME;
;   539     } DUMMYUNIONNAME;
;   540 
;   541     //
;   542     // Vector registers.
;   543     //
;   544 
;   545     M128A VectorRegister[26];
;   546     DWORD64 VectorControl;
;   547 
;   548     //
;   549     // Special debug control registers.
;   550     //
;   551 
;   552     DWORD64 DebugControl;
;   553     DWORD64 LastBranchToRip;
;   554     DWORD64 LastBranchFromRip;
;   555     DWORD64 LastExceptionToRip;
;   556     DWORD64 LastExceptionFromRip;
;   557 } CONTEXT, *PCONTEXT;
;   558 
;   559 
;   560 STATUS_BREAKPOINT               = 80000003h
;   561 STATUS_SINGLE_STEP              = 80000004h
;   562 EXCEPTION_BREAKPOINT            = STATUS_BREAKPOINT
;   563 EXCEPTION_SINGLE_STEP           = STATUS_SINGLE_STEP
;   564 
;   565 EXCEPTION_ACCESS_VIOLATION              = C0000005h         -- <-- we get this!
;   566 EXCEPTION_DATATYPE_MISALIGNMENT         = 80000002h
;   567 EXCEPTION_BREAKPOINT                    = 80000003h         -- <-- ie an int3
;   568 EXCEPTION_SINGLE_STEP                   = 80000004h
;   569 EXCEPTION_ARRAY_BOUNDS_EXCEEDED         = C000008Ch
;   570 EXCEPTION_FLT_DENORMAL_OPERAND          = C000008Dh
;   571 EXCEPTION_FLT_DIVIDE_BY_ZERO            = C000008Eh
;   572 EXCEPTION_FLT_INEXACT_RESULT            = C000008Fh
;   573 EXCEPTION_FLT_INVALID_OPERATION         = C0000090h
;   574 EXCEPTION_FLT_OVERFLOW                  = C0000091h
;   575 EXCEPTION_FLT_STACK_CHECK               = C0000092h
;   576 EXCEPTION_FLT_UNDERFLOW                 = C0000093h
;   577 EXCEPTION_INT_DIVIDE_BY_ZERO            = C0000094h
;   578 EXCEPTION_INT_OVERFLOW                  = C0000095h
;   579 EXCEPTION_PRIV_INSTRUCTION              = C0000096h
;   580 EXCEPTION_IN_PAGE_ERROR                 = C0000006h
;   581 EXCEPTION_ILLEGAL_INSTRUCTION           = C000001Dh
;   582 EXCEPTION_NONCONTINUABLE_EXCEPTION      = C0000025h
;   583 EXCEPTION_STACK_OVERFLOW                = C00000FDh
;   584 EXCEPTION_INVALID_DISPOSITION           = C0000026h
;   585 EXCEPTION_GUARD_PAGE                    = 80000001h
;   586 EXCEPTION_INVALID_HANDLE                = C0000008h
;   587 EXCEPTION_POSSIBLE_DEADLOCK             = C0000194h
;   588 CONTROL_C_EXIT                          = C000013Ah
;   589 EXCEPTION_BCC_FATAL                     = 0EEFFACEh
;   590 EXCEPTION_BCC_NORMAL                    = 0EEFFAE6h
;   591 DBG_CONTROL_C                           = 0EEFFAE6h
;   592 --*/
;   593 
;   594 --/*
;   595 ; example for exception handling 
;   596 format ELF executable 
;   597 entry start 
;   598 
;   599 SYSCALL_EXIT   equ 1  ; syscall to function exit() 
;   600 SYSCALL_WRITE  equ 4  ; syscall to function write() 
;   601 SYSCALL_SIGNAL equ 48 ; syscall to function signal() 
;   602 SIGSEGV        equ 11 ; signal id SIGSEGV 
;   603 STDERR         equ 2  ; standard error 
;   604 
;   605 section readable writeable 
;   606 signal_handler_msg db 'Hmmm, SIGSEGV signal received', 0xa 
;   607 signal_handler_msg_size = $-signal_handler_msg 
;   608 reborn_msg db "but I'm still alive", 0xa 
;   609 reborn_msg_size = $-reborn_msg 
;   610 
;   611 section readable executable 
;   612 start: 
;   613 ; install signal handler 
;   614         mov     eax, SYSCALL_SIGNAL 
;   615         mov     ebx, SIGSEGV 
;   616         mov     ecx, my_signal_handler 
;   617         int     0x80 
;   618 ; do something dirty 
;   619         push    dword [fs:0] 
;   620 ; print reborn message 
;   621 .print_reborn_msg: 
;   622         mov     eax, SYSCALL_WRITE 
;   623         mov     ebx, STDERR 
;   624         mov     ecx, reborn_msg 
;   625         mov     edx, reborn_msg_size 
;   626         int     0x80 
;   627 .finish: 
;   628         xor     ebx, ebx 
;   629         mov     eax, SYSCALL_EXIT 
;   630         int     0x80 
;   631 
;   632 my_signal_handler: 
;   633 ; print exception message 
;   634         mov     eax, SYSCALL_WRITE 
;   635         mov     ebx, STDERR 
;   636         mov     ecx, signal_handler_msg 
;   637         mov     edx, signal_handler_msg_size 
;   638         int     0x80 
;   639 ; remove return adress from the stack 
;   640         add     esp, 4 
;   641 ; jump after the erroneous code 
;   642         jmp     start.print_reborn_msg
;   643 --*/
;   644 
;   645 --/*
;   646 ; example for exception handlig 
;   647 format ELF executable 
;   648 entry start 
;   649 
;   650 SYSCALL_EXIT      equ 1  ; syscall to function exit() 
;   651 SYSCALL_WRITE     equ 4  ; syscall to function write() 
;   652 SYSCALL_SIGACTION equ 67 ; syscall to function sigaction() 
;   653 SA_NOCLDSTOP      equ 0x00000001 
;   654 SA_NOCLDWAIT      equ 0x00000002 ; not supported yet 
;   655 SA_SIGINFO        equ 0x00000004 ; use sa_sigaction instead of sa_handler 
;   656 SA_ONSTACK        equ 0x08000000 
;   657 SA_RESTART        equ 0x10000000 
;   658 SA_NODEFER        equ 0x40000000 
;   659 SA_RESETHAND      equ 0x80000000 
;   660 SIGSEGV           equ 11 ; signal id SIGSEGV 
;   661 STDERR            equ 2  ; standard error 
;   662 
;   663 ; sigaction structure for installing signal handler 
;   664 struc sigaction sa, m, f { 
;   665         .sa_sigaction dd sa ; void (*sa_sigaction)(int, siginfo_t *, void *); 
;   666         .sa_mask      dd m  ; sigset_t sa_mask; 
;   667         .sa_flags     dd f  ; int sa_flags; 
;   668         .sa_restorer  dd 0  ; void (*sa_restorer)(void); -- obsoleted, don't use it 
;   669 } 
;   670 
;   671 ; sigcontext structure used in ucontext below 
;   672 ; it contains eip we're going to overwrite when catching signal 
;   673 struc sigcontext { 
;   674         .gs            rw 1 
;   675         .__gsh         rw 1 
;   676         .fs            rw 1 
;   677         .__fsh         rw 1 
;   678         .es            rw 1 
;   679         .__esh         rw 1 
;   680         .ds            rw 1 
;   681         .__dsh         rw 1 
;   682         .edi           rd 1 
;   683         .esi           rd 1 
;   684         .ebp           rd 1 
;   685         .esp           rd 1 
;   686         .ebx           rd 1 
;   687         .edx           rd 1 
;   688         .ecx           rd 1 
;   689         .eax           rd 1 
;   690         .trapno        rd 1 
;   691         .err           rd 1 
;   692         .eip           rd 1 
;   693         .cs            rw 1 
;   694         .__csh         rw 1 
;   695         .eflags        rd 1 
;   696         .esp_at_signal rd 1 
;   697         .ss            rw 1 
;   698         .__ssh         rw 1 
;   699         .fpstate       rd 1 
;   700         .oldmask       rd 1 
;   701         .cr2           rd 1 
;   702 } 
;   703 
;   704 virtual at 0 
;   705         sigcontext sigcontext 
;   706 end virtual 
;   707 
;   708 ; sigset structure used in ucontext below 
;   709 _NSIG             equ 64 
;   710 _NSIG_BPW         equ 32 
;   711 _NSIG_WORDS       equ (_NSIG / _NSIG_BPW) 
;   712 
;   713 struc sigset_t { 
;   714         .sig rd _NSIG_WORDS 
;   715 } 
;   716 
;   717 ; signalstack structure used in ucontext below 
;   718 struc signaltstack { 
;   719         ss_sp    rd 1 
;   720         ss_flags rd 1 
;   721         ss_size  rd 1 
;   722 } 
;   723 
;   724 ; structure type for 3rd parameter of signal handler 
;   725 struc ucontext { 
;   726         .uc_flags    rd 1 
;   727         .uc_link     rd 1 
;   728         .uc_stack    signaltstack 
;   729         .uc_mcontext sigcontext 
;   730         .uc_sigmask  sigset_t 
;   731 } 
;   732 
;   733 virtual at 0 
;   734         ucontext ucontext 
;   735 end virtual 
;   736 
;   737 ; some dangereous statements 
;   738 macro do_dirty { 
;   739 -       push    dword [ds:0] 
;   740 -       mov     dword [ds:0], eax 
;   741 -       push    dword [fs:0] 
;   742 } 
;   743 
;   744 ; determine size of those statements at compilation time 
;   745 virtual at 0 
;   746         do_dirty 
;   747         sizeof.do_dirty=$ 
;   748 end virtual 
;   749 
;   750 
;   751 ; define section for code and constants 
;   752 section readable executable 
;   753 
;   754 ; new_act is constant that's why it is here 
;   755 new_act sigaction my_signal_handler, 0,  SA_SIGINFO 
;   756 
;   757 start: 
;   758 ; install signal handler 
;   759         mov     eax, SYSCALL_SIGACTION 
;   760         mov     ebx, SIGSEGV 
;   761         mov     ecx, new_act 
;   762         xor     edx, edx 
;   763         int     0x80 
;   764 ; check result of installing signal handler 
;   765         test    eax, eax 
;   766         mov     ebx, eax ; set exit value 
;   767         jnz     .finish 
;   768 ; do something dirty 
;   769         do_dirty 
;   770 ; print reborn message 
;   771         mov     eax, SYSCALL_WRITE 
;   772         mov     ebx, STDERR 
;   773         mov     ecx, reborn_msg 
;   774         mov     edx, reborn_msg_size 
;   775         int     0x80 
;   776         xor     ebx, ebx 
;   777 .finish: 
;   778         mov     eax, SYSCALL_EXIT 
;   779         int     0x80 
;   780 
;   781 my_signal_handler: 
;   782 ; print exception message 
;   783         mov     eax, SYSCALL_WRITE 
;   784         mov     ebx, STDERR 
;   785         mov     ecx, signal_handler_msg 
;   786         mov     edx, signal_handler_msg_size 
;   787         int     0x80 
;   788 ; get parameter ucontext 
;   789         mov     eax, [esp+12] 
;   790 ; modify eip 
;   791         add     dword [eax+ucontext.uc_mcontext+sigcontext.eip], sizeof.do_dirty 
;   792         ret 
;   793 
;   794 ; define section for data 
;   795 section readable writeable 
;   796 signal_handler_msg db 'Hmmm, SIGSEGV signal received', 0xa 
;   797 signal_handler_msg_size = $-signal_handler_msg 
;   798 reborn_msg db "but I'm still alive", 0xa 
;   799 reborn_msg_size = $-reborn_msg
;   800 --*/
;   801 
;   802 --/*
;   803 Skeleton for multiprocess handling for 64-bits (easy portable to 32-bit world) - may help for trying in multithread handling
;   804 
;   805 Code:
;   806 start: 
;   807 
;   808         mov     eax,sys_fork 
;   809         syscall                         ; make second copy of program 
;   810 ; child has return value=0, parent return value = child's PID 
;   811 ; see: man fork 
;   812         or      rax,rax 
;   813         js      exit1                   ; something went wrong... 
;   814         jnz     parent_proc 
;   815 
;   816 child_proc: 
;   817 ; see: 
;   818 ; man ptrace 
;   819 ; look for PTRACE_TRACEME 
;   820 ; Any signal delivered to this process will cause it to stop and its parent to 
;   821 ; be notified via wait. 
;   822         xor     r10,r10 
;   823         xor     edx,edx 
;   824         xor     esi,esi 
;   825         mov     edi,PTRACE_TRACEME 
;   826         mov     eax,sys_ptrace 
;   827         syscall 
;   828 
;   829 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;   830 ; put the core of your program here ; 
;   831 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;   832 
;   833 parent_proc: 
;   834         mov     [child_PID],rax 
;   835 
;   836 parent_signal_wait: 
;   837         xor     r10,r10 
;   838         mov     edx,WUNTRACED 
;   839         lea     rsi,[child_status] 
;   840 ;       or      rdi,-1 
;   841 ; use -1 for wait to child's children too, but we want to wait for child only 
;   842         mov     rdi,qword [child_PID] 
;   843         mov     eax,sys_wait4 
;   844         syscall 
;   845         or      rax,rax 
;   846         jns     wait_L1 
;   847 msg_err_wait_exit: 
;   848         lea     rax,[msg_err_wait] 
;   849         jmp     exit_msg 
;   850 
;   851 wait_L1: 
;   852         mov     eax,dword [child_status] 
;   853 WIFSTOPPED              =       7Fh 
;   854         test    al,WIFSTOPPED 
;   855         jnz     wait_L2 
;   856 ; Child exited ? Then we do the same... 
;   857 ; WEXITSTATUS eax 
;   858         and     eax,0000FF00h 
;   859         sar     eax,8 
;   860 
;   861 ; al=exitstatus 
;   862 ; display the exit status 
;   863 ;... 
;   864         jmp     exit0 
;   865 
;   866 wait_L2: 
;   867 ; WIFSIGNALED eax 
;   868         and     eax,7Fh 
;   869         inc     eax 
;   870         sar     al,1 
;   871 
;   872         jle     wait_L3 
;   873 
;   874 ; display hexa content of AL register: 
;   875 ; ... 
;   876 
;   877         jmp     exit0 
;   878 
;   879 wait_L3: 
;   880         mov     eax,dword [child_status] 
;   881 
;   882         cmp     al,WIFSTOPPED 
;   883         jnz     wait_L7 
;   884 
;   885 ;       WSTOPSIG        eax 
;   886         and     eax,0000FF00h 
;   887         sar     eax,8 
;   888 ; al holds signal now 
;   889 
;   890 ; 0. display message with the signal number 
;   891 ; 1. then handle the exception and at the end choose only one of 1.A. or 1.B. 
;   892 ; 1.A. resume program: 
;   893 ;       mov     r10d,SIGCONT 
;   894 ;       xor     edx,edx 
;   895 ;       mov     rsi,qword [child_PID] 
;   896 ;       mov     edi,PTRACE_CONT 
;   897 ;       mov     eax,sys_ptrace 
;   898 ;       syscall 
;   899 ; 1.B. or kill the program: 
;   900 ;       xor     r10,r10 
;   901 ;       xor     edx,edx 
;   902 ;       mov     rsi,qword [child_PID] 
;   903 ;       mov     edi,PTRACE_KILL 
;   904 ;       mov     eax,sys_ptrace 
;   905 ;       syscall 
;   906 
;   907 wait_L7: 
;   908         jmp     parent_signal_wait 
;   909 
;   910 exit0: 
;   911         xor     edi,edi  
;   912 exit:   mov     eax,sys_exit 
;   913         syscall 
;   914 
;   915 exit1:  mov     edi,1 
;   916         jmp     exit 
;   917 
;   918 
;   919 
;   920 The above skeleton is from fdbg. I still don't know what to do when the child forks - something in the above code is missing. 
;   921     The above handling idea is the same as every debugger's job (it is an auto-debugger, or self-debugger).
;   922 part 2 (for it not to be so simple...)
;   923 if you want new thread instead of new process, then use
;   924 sys_clone with CLONE_THREAD
;   925 instead of
;   926 sys_fork
;   927 
;   928 you need to mmap space for new thread (new stack, ...) before sys_clone
;   929 
;   930 how to skip instruction causing singal ?
;   931 0. read registers sys_ptrace with PTRACE_GETREGS and get RIP (EIP) register
;   932 (offset of instruction pointer differs in x64 and x86 platform)
;   933 1. determine size of instruction:
;   934 1A read 16 bytes (2 qwords in x64, 4 dwords in x86) sys_ptrace PTRACE_PEEKTEXT
;   935 1B determine the size of the instruction by disassembling it, the most difficult task
;   936 you can use disasm engine for x64 or simplify it not to disassemble
;   937 the whole instruction but to determine instruction size only
;   938 I don't know whether there is any disasm engine for x86 written in asm
;   939 2. add instruction size to user.user_regs.rip (or ...eip)
;   940 3. write registers sys_ptrace PTRACE_SETREGS
;   941 4. continue run sys_ptrace PTRACE_CONT
;   942 
;   943 After doing this you can only hope that skipping instruction doesn't alter program run too much...
;   944 --*/
    jmp #0044298D (:%opRetf)              ;#004427E5: 351 A3010000               v  00 00  1 117      
;C:\Program Files (x86)\Phix\builtins\VM\pHeap.e:
;================================================
;     1 --
;     2 -- pHeapD.e
;     3 -- ========
;     4 --
;     5 -- Practical note: You should never really need to read this. If you are happy (for now)
;     6 --  to say "it is a programming language: it /knows/ how to deal with strings, and it 
;     7 --  /knows/ how to deal with floating-point numbers", my advice is leave this well alone.
;     8 --  Mind you, the "Memory Use At The Lowest Level" stuff is probably worthwhile skimming,
;     9 --  but even I do not trouble myself to remember the precise details of all of it.
;    10 --
;    11 -- The point of a heap manager is to scale effortlessly when it allocates /billions/ of
;    12 --  small blocks of memory, and allow them to be freed and re-used in any order, all in
;    13 --  a thread-safe manner, which is a decidedly non-trivial task. I am extremely proud of 
;    14 --  the code below, and believe it is very clean and efficient, considering the task it 
;    15 --  must do, but can hardly claim it is "simple". On that note, it is highly likely that 
;    16 --  the odd bug remains, although by its very nature it is the most extensively tested 
;    17 --  part of Phix. Any improvements are always welcome, of course.
;    18 --
;    19 --
;    20 -- Low-level memory access. Except for integers and a few constants, everything in Phix
;    21 --  gets stored in the heap, so an efficient heap manager is crucial to performance.
;    22 --  While newer versions of Windows (allegedly) come with a start-of-the-art allocator, 
;    23 --  previous verions were less than ideal, and Linux does not supply a heap manager at 
;    24 --  all. (Reference: http://x86asm.net/articles/memory-allocation-in-linux/index.html )
;    25 --  I looked at a few existing heap managers, but of course none are written in Phix, 
;    26 --  and besides, what works for (eg) C++ is not necessarily the best fit here. 
;    27 -- As well as dealing with internal/implicit memory requirements, this also implements 
;    28 --  thread-safe and cross-platform allocate() and free(). The externally exposed asm 
;    29 --  entry points are: :%pAllocStr, :%pAllocSeq, :%pStoreFlt, :%pStoreMint, :%pLoadMint, 
;    30 --  :%pAlloc, :%pFree, :%pDealloc[0], :%pInitCS, :%pDeleteCS, :%pEnterCS, :%pLeaveCS,
;    31 --  plus :%pGetPool and :%pFreePool, but they should really only be used by pStack.e,
;    32 --  and pApnd.e (:%pFreePool only)
;    33 --  The trivial :%pGetpGtcb is also available should you need/want it. [DEV]
;    34 --DEV
;    35 --  There may also need to be a :%pTerminateThread entry point for orphan handling.
;    36 --
;    37 -- TODO: * performance tests * [DEV]
;    38 --
;    39 -- Terminology
;    40 -- ===========
;    41 --  While this may yet make little sense, there are two types of memory block:
;    42 --  a) thread control blocks - used exclusively by these routines, one per thread.
;    43 --  b) superblocks - contain externally useable memory (eg "allocate(10)")
;    44 --  NB: All talk of thread safety in this program has nothing whatsoever to do with 
;    45 --  the thread safety of data /within/ the memory blocks it provides. In particular, 
;    46 --  increasing and decreasing reference counts on shared objects by multiple threads 
;    47 --  is an application-level issue that requires explicit application-level locking.
;    48 --  (eg see enter_cs() which is implemented via :%pEnterCS below)
;    49 --
;    50 --
;    51 -- Memory Use At The Lowest Level.
;    52 -- ==============================
;    53 --  This is actually utterly irrelevant to the heap manager, but it may be helpful to
;    54 --  properly understand exactly what (most) things it deals with are being used for.
;    55 --  Besides, a heap manager that does not yield "useful" sizes is no good to anyone.
;    56 --  Of course, memory obtained through allocate() can be used for whatever you want.
;    57 --
;    58 --  All memory blocks/allocations are at least dword-aligned, which means the address 
;    59 --  ends in 0b00 and right shifting two places does not cause any loss of information. 
;    60 --  Phix stores (31-bit) integers in the range -1073741824..1073741823, ie #C0000000..
;    61 --  #3FFFFFFF, ie leading bits 0b11 or 0b00, in a single dword. The special value h4,
;    62 --  or #40000000, means "unassigned", and anything above that (beginning 0b01) is a
;    63 --  2-bit-shifted raw address. For example, a hll variable containing #00000001 is 
;    64 --  just 1, whereas #40120021 is a ref pointing to memory at #00480084 - the shift 
;    65 --  effectively discards the leading #4/first two bits and puts back the 0b00 ending.
;    66 --  In practice we almost always scale (*4) rather than shift for performance reasons, 
;    67 --  but the net effect is exactly the same, including those first and last two bits.
;    68 --  Assuming something like "mov reg,[var]; cmp reg,h4; jl :isInt" has just occurred 
;    69 --  (the compiler may omit the load if it knows [var] is already in a reg, and the 
;    70 --  cmp/jmp if it is not integer, and is assigned, eg after "if not integer(var)"):
;    71 --
;    72 --  Floats are stored (on 32-bit) as
;    73 --      refcount @ dword[reg*4-8]
;    74 --      type #12 @ byte[reg*4-1]        plus 3 bytes used by delete_routine
;    75 --      f64      @ qword[reg*4]         as a 64-bit float (-1e308..+1e308)
;    76 --      total 16 bytes. On 64-bit two qwords and a tbyte(/f80) make it 26 bytes,
;    77 --                      which is rounded up to 28 to keep things dword-aligned.
;    78 --
;    79 --  Strings are stored as
;    80 --      maxlen   @ dword[reg*4-16]      actual allocated size in bytes
;    81 --      length   @ dword[reg*4-12]      in bytes/chars, not including null
;    82 --      refcount @ dword[reg*4-8]
;    83 --      type #82 @ byte[reg*4-1]        plus 3 bytes used by delete_routine
;    84 --      data     @ byte[reg*4]          ansi, UTF8, or even raw binary/WideString
;    85 --      char[i]  @ byte[reg*4+i-1]
;    86 --      null     @ byte[reg*4+length]   must always be present
;    87 --      header size is 16 bytes. 64-bit header is 32 bytes, but still 8-bit chars.
;    88 --
;    89 --  Sequences are stored as
;    90 --      slack    @ dword[reg*4-20]      bytes spare before header, initially 0
;    91 --      maxlen   @ dword[reg*4-16]      actual allocated size in bytes
;    92 --      length   @ dword[reg*4-12]      in dwords (qwords on 64-bit)
;    93 --      refcount @ dword[reg*4-8]
;    94 --      type #80 @ byte[reg*4-1]        plus 3 bytes used by delete_routine
;    95 --      elements @ dword[reg*4]         dword ints/refs
;    96 --      item[i]  @ dword[reg*4+i*4-4]
;    97 --      header size is 20 bytes. On 64-bit header is 40 bytes, with qword elements.
;    98 --
;    99 --  By making ref*4 locate the raw data, rather than the start of the header, we not only have
;   100 --  common/consistent offsets to data/type/refcount/length/maxlen, but also cause the special 
;   101 --  "unassigned" value of #40000000 (aka h4) to equate to a raw address of 0, which, quite 
;   102 --  apart from probably being used for something else or a "null pointer trap" by the OS, 
;   103 --  would make type/refcount etc negative/wrapped, ie it makes h4 patently/doubly invalid.
;   104 --  On 64-bit, type/refcount/length/maxlen/slack are [reg*4-1/16/24/32/40] respectively.
;   105 --
;   106 --  As noted above, a delete_routine index (see pDelete.e) may be stored in the remaining 3 
;   107 --  bytes of the type dword [at -4] (or 7 bytes of the type qword [at -8] on 64-bit).
;   108 --
;   109 --  As you can see, for floats the required size is always 16 bytes, 8 bytes of which are header.
;   110 --  Strings and sequences are allocated blocks of 32,64,128,etc, 16/20 bytes of which are header.
;   111 --  A zero-length string still needs a null terminator and thus does not fit in a 16 byte block.
;   112 --  Likewise, on 64-bit, you cannot fit a 32/40 byte header in 28 bytes, hence for both 32-bit
;   113 --  and 64-bit, chain[1]s only contain floats, and small allocate()ions, (which may become a bit 
;   114 --  clearer later on, and turns out to have little or no significance, except in the tables).
;   115 --  Update: There is a subtle implication for 64-bit here, that means qword-sequences are always 
;   116 --  qword-aligned (as long as the superblock was), ditto strings, which suits us just fine.
;   117 --
;   118 --  When strings/sequences are initially created, any spare space is at the end, and as long as
;   119 --  the refcount is 1 and we are doing a=append(a,b) style where b!=a, it may be done in situ.
;   120 --  Strings are always stored "hard left", with any spare space [maxlen-length-17] at the end.
;   121 --  Slice operations such as x=x[i..j] on dword-sequences with a refcount of 1 are permitted to 
;   122 --  move the header in situ, and set slack accordingly. A prepend operation (see VM/pApnd.e)
;   123 --  which finds slack of zero asks for a larger size and re-plants the header smack in the middle
;   124 --  of the newly allocated space, to cater for both subsequent append and prepend operations. If
;   125 --  prepend finds slack non-zero (and the refcount set to 1) it can move the 20-byte header left 
;   126 --  by 4 bytes (and reduce slack by 4), hence minimising the amount of data which must be moved. 
;   127 --  Append operations on dword-sequences must therefore check the length against (maxlen-slack), 
;   128 --  if there is no more space on the rhs it just creates a new "hard left" sequence.
;   129 --  Incidentally, any slack value not ending in 0b00 should immediately trigger an error.
;   130 --
;   131 --  Note that top-notch performance of prepend/slice on long strings has been deliberately 
;   132 --  sacrificed for the sake of significant speed gains elsewhere, whereas the performance of 
;   133 --  prepend/slice on dword-sequences is not compromised. By slice I specifically mean s=s[i..j]
;   134 --  when that could theoretically be done "in situ", rather than all forms of slices. For fast 
;   135 --  prepend/slice on strings you would need a "base" pointer in the string header to allow the 
;   136 --  text to start on an odd byte boundary, that is rather than move every byte just because you 
;   137 --  prepended one or more bytes to the start, but of course that would make all other operations 
;   138 --  on strings slower, and prevent passing the raw data to c_func etc. Some applications might 
;   139 --  therefore benefit from using dword-sequences instead of strings, by the simple technique of 
;   140 --  initialising to {} instead of "", or deliberately appending and then removing (say) a -1,
;   141 --  or, recommended if at all possible, reworked to use append in preference to prepend.
;   142 --
;   143 --  The maxlen is actually the total allocated space expressed in bytes, and is perhaps incorrectly 
;   144 --  named, equating to maximum length+17 for strings and maximum length*4+20 for dword-sequences. 
;   145 --  (Of course, actlen would have been a better name, but there is little point changing it now.)
;   146 --  On 64-bit those become maximum length+33 and maximum length*8+40 respectively.
;   147 --  For strings, (which must be dword-aligned) there is never any space at the start, for space at 
;   148 --  the end we must test whether (length+17)<maxlen (note the extra 1 for the null).
;   149 --  For sequences, checking for space at the start is simply whether slack is non-zero, at 
;   150 --  the end test whether (slack+(length*4)+20)<maxlen (again, slack is expressed in bytes).
;   151 --
;   152 --  Specifically note that when freeing a float, subtract 8, when freeing a string, subtract 16,
;   153 --  and when freeing a dword_sequence, subtract [slack]+20, that is, in order to obtain the proper 
;   154 --  "block start address" that a [ie this] heap manager has any chance of understanding. Of course
;   155 --  those numbers become 16/32/40 in 64-bit code.
;   156 --
;   157 --  The heap manager may also place additional fields before and after the above, for various 
;   158 --  housekeeping and/or corruption detection purposes. Note that the heap manager is heavily
;   159 --  biased towards faster performance, rather than absolute minimum memory consumption, not
;   160 --  that it chooses to be deliberately wasteful of course, but it is fair to say that using the
;   161 --  "doubling" method, described next, means that on average just shy of 25% of all allocated 
;   162 --  memory will technically not be in use, which (imho) is perfectly reasonable. By "on average"
;   163 --  I mean in the "mid-run" state, obviously at startup and should it go idle, expect high 90s.
;   164 --  Of course if anyone finds a better scheme I'd certainly love to hear about it.
;   165 --
;   166 --
;   167 -- Heap Management.
;   168 -- ===============
;   169 --  Smaller sizes (for now assume 16,32,64,128,256,etc, but we will revise that shortly) are 
;   170 --  allocated in per-thread "superblocks", ie we grab (say) an 8K chunk and split it up into 
;   171 --  packets of smaller sizes. According to some Intel paper I read, smaller sizes 16..512 
;   172 --  account for 98% of all usage, though that was for C++. We maintain simple chains of size 
;   173 --  links, 16,32,64,..2GB, and for now assume that means about 28 such lists (60 on 64bit),
;   174 --  per thread: not entirely trivial, but nevertheless perfectly manageable.
;   175 --  
;   176 --  Now, suppose we allocate an 8K "superblock" and logically attach it to sizes[10] (similar
;   177 --  processing may occur for larger sizes), then imagine we only want 32 bytes from it. We 
;   178 --  repeatedly split the block, detaching it from sizes[10] (if we ever really put it there)
;   179 --  and leave half on sizes[9] (4K), half the rest on sizes[8] (2K), and so on right down the
;   180 --  line until we're left with the 32 bytes we need. Now, if we want another 32 byte chunk,
;   181 --  that "other half" will be immediately available in sizes[2], and if we want another, that
;   182 --  is before either becomes free, then we will scan forward, find the sizes[3] (64 bytes) we
;   183 --  have left behind, and split that, half onto sizes[2] and the other half satisfying the
;   184 --  immediate requirement. Repeated requests for 32 byte chunks might continue this splitting
;   185 --  until we have used the whole 8K, at which point there are no more sizes[] to use and we
;   186 --  allocate another 8K "superblock" and repeat the process. One small point: whenever we 
;   187 --  split a block, we know that all the half-size-freelists down to the required size must be 
;   188 --  empty/null, which may (or may not) make things just a tiny little bit easier.
;   189 --
;   190 --  Releasing memory reverses this process. Simply put, we attempt to merge odd entries with 
;   191 --  the next, and even entries with the previous, pushing things back up sizes[] as far as 
;   192 --  they will go. "Entry Padding" below explains this in excruciating detail, together with a 
;   193 --  nice little diagram. Should we successfully merge an entire block, it is returned to the 
;   194 --  global pool (see below). In practice we allocate somewhat more than 8K (see below) to 
;   195 --  prevent padding (see below) from messing up the maths.
;   196 --
;   197 --  A thread must use a global lock to obtain a superblock, but can allocate smaller elements 
;   198 --  within any block it owns without locking. To avoid contention, each thread maintains two 
;   199 --  independent free lists, one for memory it owns, which it can update without any locking, 
;   200 --  and one for non-owned-memory, which must be locked, but with a thread-specific mechanism 
;   201 --  to minimise contention. It is of course other threads that put entries onto the non-owned
;   202 --  freelist(s), and the owning thread that later comes along and recycles them. No attempt 
;   203 --  is made to merge items before they are placed on the "non-owned" list, nor is the free bit
;   204 --  set on pRoot (explained below). A key aspect of this two-list scheme is that single threaded 
;   205 --  applications need perform virtually no locking as they acquire, release, and recycle memory, 
;   206 --  and of course even in a heavily multithreaded program, the vast majority of items are freed 
;   207 --  by the same thread that allocated them, and that can also be performed without locking.
;   208 --
;   209 --  One obvious example where memory allocated by one thread gets freed by another is the main 
;   210 --  gui creating and adding to (with appropriate locking) a "to-do" list, that a worker thread 
;   211 --  can (also lock and) process/remove entries from.
;   212 --
;   213 --  When the "owned" list is empty and the "non-owned" is not, we lock, zero the non-owned 
;   214 --  pointer, unlock, and then step down the list and merge things (ie everything that has 
;   215 --  been put on the "non-owned" freelist by other threads). Such locks (on the "non-owned"
;   216 --  lists) are extremely transient, covering only 3 or 4 fast instructions/clocks.
;   217 --  
;   218 --
;   219 -- Thread Termination.
;   220 -- ==================
;   221 --  By the time a thread reaches a natural conclusion, it may have amassed quite some list
;   222 --  of "owned" memory blocks. Some or all of that memory may remain in use, it just no longer
;   223 --  has a proper owning parent. Obviously, if the thread terminates abruptly, maybe we could
;   224 --  periodically check whether GetExitCodeThread() returns STILL_ACTIVE, but there would no
;   225 --  doubt be other issues (eg local variables/refcounts) that would prevent any recovery of
;   226 --  that memory short of application shutdown. Whatever, there should be a mechanism for a
;   227 --  thread to terminate gracefully, which includes saying to these routines "here, this is
;   228 --  all my stuff, you deal with it from now on.", or at least this should not preclude such.
;   229 --  NOTE: The first (few) version(s) are unlikely to have /any/ thread termination handling. [DEV]
;   230 --
;   231 --  In practice, we really want to leave "orphaned" memory exactly where it is, both in terms
;   232 --  of where the memory physically resides (obviously) and any and all pointers to it, since
;   233 --  any attempt to relink would significantly complicate matters, especially so for locking,
;   234 --  at least, that is, until every last byte ceases to be active. As mentioned above, when a
;   235 --  block is fully merged it is returned to the global pool, and that is just as valid for 
;   236 --  active threads as the orphaned memory previously owned by now-terminated threads. All we
;   237 --  need (or can) do is place a status code on the thread control block(s) as follows:
;   238 --
;   239 --      -1: normal (thread still active, let the owner deal with it)
;   240 --      -2: orphaned (thread terminated, lock/scan/merge whenever we need a new superblock)
;   241 --              [DEV there is still nothing that ever sets this value... (apart from and
;   242 --                   not counting the thing where we decide to leave it set to -2)]
;   243 --      -3: free (this thread control block should have all null pointers, and
;   244 --                can be reused whenever we need a new thread control block.)
;   245 --      -4: the global pool (-1 would probably be just fine, but why risk confusion)
;   246 --
;   247 --  Negative numbers were chosen simply because they stand out more in diagnostic hex dumps.
;   248 --  Normal/active thread control blocks can often end up with all null pointers, but in no 
;   249 --  way does that mean they are available for anyone else to nick.
;   250 --
;   251 --  Some lock contention may occur as things are shunted in and out of the global pool, but
;   252 --  it is almost all single-item and very transient.
;   253 --
;   254 --  There is one point where the memory allocator may appear to stall. Suppose that thread A 
;   255 --  allocates 10000 items and puts them on a "to-do" list, and thread B processes and removes
;   256 --  (say) 9996 of those entries (obviously with appropriate locking). When thread A allocates 
;   257 --  another item it may process all 9996 entries in one hit, which is fine, does not hinder 
;   258 --  thread B or any other thread, and besides is likely to be a tiny fraction of the time it
;   259 --  spent doing whatever it did to make the list that big in the first place. /However/, if 
;   260 --  thread A has terminated, a lock must remain in force for the entire duration of processing 
;   261 --  those 9996 entries, which /will/ stall anything attempting to free one of the remaining 4 
;   262 --  items, and likewise, for that matter, other threads attempting to obtain a new superblock.
;   263 -- DEV:
;   264 --  While :%pTerminateThread performs a full clear out/merglist all the "not-owned" lists, in
;   265 --  minimal locking fashion, thread A may terminate shortly after creating those 10000 items.
;   266 --  It is of course the single (locked) call :scan_orphans below, of which I speak.
;   267 --  (Translation: There is only one fairly rare case where the heap manager stalls any other
;   268 --                thread for anything beyond the briefest of fleeting moments.)
;   269 --
;   270 --
;   271 --  OK, so that's the theory, let's put together a practical implementation.
;   272 --
;   273 -- Superblock Header
;   274 -- =================
;   275 --  DWORD   dwMagic     -- [+0] checked for memory corruption ("SBH\0" = #00484253)
;   276 --  DWORD   dwThreadId  -- [+4] owner
;   277 --  DWORD   nsbSize     -- [+8] does not include this 20 bytes (should always be >= 10K)
;   278 --  DWORD   pTCB        -- [+12] ptr/4 to the owning Thread Control Block (see below)
;   279 --  DWORD   pNxtsb      -- [+16] next superblock
;   280 --  ==
;   281 --  20 bytes (#14)  (see below for 64-bit version)
;   282 --
;   283 -- dwThreadId is normally set from kernel32/xGetCurrentThreadId() or sys_getpid()
;   284 -- When superblocks are added to the global pool, dwThreadId is set to 0, and pTCB gets replaced.
;   285 -- Originally, pNxtsb was to be per-owner for orphaned block handling, but is now just a single chain 
;   286 --  linked from pGtcb, and really only of any use for diagnostic heap dumps (external to this code).
;   287 -- Strictly, we only really need nsbSize and pTCB here, but that would of course be harder to debug.
;   288 --
;   289 -- Entry Padding
;   290 -- =============
;   291 --pHeapD:
;   292 --  DWORD   era         -- [-8] effective return address, for diagnostics/leak checking
;   293 --  DWORD   pRoot       -- [-4] pointer to the SuperBlock Header[+1]
;   294 --                      -- 0b01 (aka bit 0): block is free
;   295 --                      -- if xor(left,right) not 0|1 then memory corruption has occurred.
;   296 --  (DWORD  nSize)      -- [+0] size (permanent for allocate()d blocks)
;   297 --  (DWORD  pNext)      -- [+4] (on free items only), next freelist link
;   298 --  (DWORD  pPrev)      -- [+8] (on owned free items only), previous freelist link
;   299 --
;   300 --  The pointer to the superblock header, together with the block size, determines whether for
;   301 --  merging purposes this is a "leftie" or "rightie". Consider the following possible memory 
;   302 --  splittings, in which the right side might be more broken up than the left, or vice versa:
;   303 --  (Obviously this represents a tiny chunk of a scheme that scales effortlessly to petabyte
;   304 --   sized blocks potentially split into trillions of float-sized fragments, and covering up
;   305 --   to 28-ish splitable/mergeable/halveable/doubleable sizes on 32-bit, 60-ish on 64-bit.)
;   306 --
;   307 --                              s   160 |       L       |
;   308 --                              i    80 |   L   |   R   |
;   309 --                              z    40 | L | R | L | R |
;   310 --                              e    20 |L|R|L|R|L|R|L|R|
;   311 --                               offset 0   40  80  120 160
;   312 --
;   313 --  A block at offset 80 is a "leftie" for sizes 20 and 40, and must look to the right to see
;   314 --  if the corresponding block is both free and the same size, whereas a block of size 80 at
;   315 --  that address is a "rightie" and must look left to see, again, if the corresponding block 
;   316 --  is both free and the same size. Clearly, if (offset/size) is odd, look left, else right. 
;   317 --  (ie/eg line 3: 0/40=0(->R), 40/40=1(->L), 80/40=2(->R), 120/40=3(->L), ...)
;   318 --
;   319 --  Just to be very clear here, consider a block of size 40 (3rd line) at offset 80: we can say 
;   320 --  with /absolute certainty/ that on the right is either another block of size 40 or two blocks
;   321 --  of size 20, but there will definitely be a valid padding at offset 120. However, should we 
;   322 --  try to look left (which we wouldn't want to do if we are trying to put things back together 
;   323 --  the same way we took them apart) then at offset 40 we might find the same, /or/ that it is 
;   324 --  slap bang in the middle of an 80, and hence might be anything, rather than a pRoot[+1].
;   325 --  Whereas a block of size 80 (2nd line) at offset 80 looking left will definitely find a pRoot
;   326 --  at offset 0, although of course it may still be in use and/or of size 20, 40, or 80.
;   327 --
;   328 --  Fairly obviously, superblock headers always lie on a dword boundary, hence we can use the 
;   329 --  low-order bit to signify free areas. Note that bit is NOT set when items are placed on the
;   330 --  "not-owned" freelists. When merging two blocks, an xor of their pRoots should be 0 or 1,
;   331 --  otherwise memory corruption has occurred. The size of a float/string/sequence can be deduced 
;   332 --  from the Phix data it contains, whereas allocate()d blocks need an explicit/permanent size.
;   333 --  nSize (except as just noted), pNext, and pPrev overlap the live data, and the doubly-linked 
;   334 --  freelist allows us to quickly snip an entry out of the sizes[n] freelist as is is merged,
;   335 --  before carrying on forwards with similar processing for sizes[n+1]. In practice we only need
;   336 --  set pPrev on the owned freelists, it isn't used on the non-owned freelists (which are picked 
;   337 --  up and merged wholesale, by the owner). Also, of course, pPrev should be 0 on the first item 
;   338 --  in the (owned) list and likewise pNext should be 0 on the last.
;   339 --
;   340 --  Note: pNext and pPrev can freely point from one superblock to another and back, and a walk
;   341 --        down a free chain (which I do not do anywhere) could quite probably re-visit several
;   342 --        superblocks several times. I expect all dwThreadId at [pRoot[-1]+4] on any one chain 
;   343 --        should match, including all fully merged blocks in the global pool, however (as yet) 
;   344 --        this code makes no attempt whatsoever to verify that. [DEV: MCHK/MLEAK/FALLOC]
;   345 --
;   346 --DEV may be slightly out of date...
;   347 --  Minor point: In practice, the nSize value on allocate()'d blocks is 4 less than it is on
;   348 --               freed blocks, which is actually (still) 4 less than the useable size, eg:
;   349 --pHeapD(??)
;   350 --<              in the table below, [1] says 20[#00000014]=4+16; so the block size (20) is
;   351 --<              the value stored on the freelists, pGetPool returns edx=16 which is stored 
;   352 --<              by pAlloc(<=12) just after pRoot (as nSize, and in exactly the same place  
;   353 --<              where pFreePool stores the value 20), before 12 bytes of useable space. 
;   354 --<              Obviously on 64-bit those numbers are more like 8<8<useable eg 36/28/20.
;   355 --               in the table below, [1] says 24[#00000018]=8+16; so the block size (24) is
;   356 --               the value stored on the freelists, pGetPool returns edx=20 which is stored 
;   357 --               by pAlloc(<=12) just after pRoot (as nSize, and in exactly the same place  
;   358 --               where pFreePool stores the value 24), before 12 bytes of useable space. 
;   359 --               Obviously on 64-bit those numbers are more like 8?<8<useable eg 36/28/20.  [DEV]
;   360 --               None of this causes any particular problems, other than mild confusion when 
;   361 --               debugging this code. Obviously I didn't consciously design it like that, but 
;   362 --               that is the way it works, and that is the way it is going to stay, not that
;   363 --               two matching tweaks to pAlloc/pFree ought be anything but trivial. [DEV oh, just sort it, once regression tests all up and running...]
;   364 --
;   365 --
;   366 -- Thread Control Blocks
;   367 -- =====================
;   368 --  DWORD       dwMagicT    -- [+0] checked for memory corruption ("TCB\0" = #00424354)
;   369 --  DWORD       dwThreadId  -- [+4] owner
;   370 --  DWORD       pNxtcb      -- [+8] next thread control block
;   371 --  DWORD       pFirst      -- [+12] first superblock
;   372 --  DWORD       nStatus     -- [+16] -1: normal, -2: orphaned, -3: free, -4: global pool
;   373 --  DWORD[27]   pFree       -- [+20] chains of owned free blocks, by size (not locked)
;   374 --  DWORD[27]   pNofl       -- [+128] ""       not-     ""                (need locks)
;   375 --  DWORD       dwMagicC    -- [+236] checked for memory corruption ("CCB\0" = #00424343)
;   376 --  BYTE[24]    csLock      -- [+240] critical section for locking (a dword futex on Lnx)
;   377 --  DWORD       dwMagicE    -- [+264] checked for memory corruption ("ECB\0" = #00424345)
;   378 --  ===
;   379 --  268 bytes (27*2+7)*4+24  (see below for 64-bit version)
;   380 --
;   381 --  A dwThreadId of 0 indicates the global pool (kept in pGtcb), which needs extra locking, has
;   382 --  an nStatus of -4, and the special properties that a) all entries in each pFree[i] chain point 
;   383 --  to <superblockheader+24> with a pRoot+0b01 and an nSize that corresponds exactly to [i]; there 
;   384 --  is never any need to do any merging within the global pool, and b) all of pNofl[] should forever 
;   385 --  be nulls. There should never be any reference [in pGtcb] to any memory that is still in use 
;   386 --  (except perhaps when there is a programming error such as an application invoking free(addr), 
;   387 --  but then continuing to use addr - you could test for bad pointers with and_bits(peek(addr-8),1), 
;   388 --  not that passing proves it is good, as it may have already been reused for something else).
;   389 --  [for a 64-bit application that test would, of course, be and_bits(peek(addr-16),1) instead, and
;   390 --   obviously any and all such tests would not port at all well to either OpenEuphoria or RDS Eu.]
;   391 --
;   392 --  As pGtcb is a hll variable and will always be dword-aligned it is stored /4 to ensure it is always 
;   393 --  an integer, and for consistency the pTCB values (on superblock headers) and pNxtcb are likewise /4, 
;   394 --  however pFirst etc are exact. [Note 64bit changes many *4 to *8, but pTCB handling remains /4|*4.]
;   395 --  While you must lock pGtcb->csLock to insert a new tcb, there should be no need for any locking by
;   396 --  other currently active threads that are just scanning the pGtcb->pNxtcb chain (there is no reason 
;   397 --  for them to be looking for the newest dwThreadId's tcb, or get upset when they cannot find it).
;   398 --  (In practice that just means updating pGtcb.pNxtcb last, after new.pNxtcb has got the old value.)
;   399 --  (Technically speaking, the creation of pGtcb itself is not thread safe, and we cannot change that,
;   400 --   since we haven't got anything we can lock until after we have created it, but it is highly unlikely 
;   401 --   that any application could get as far as CreateThread without somehow managing to initialise it.)
;   402 --
;   403 --  pFirst was originally intended to be per dwThreadId, but now everything is linked to pGtcb and it
;   404 --  should be null on all other records, and is only of any use for (external) heap dump diagnostics.
;   405 --  DEV: when/if we get Phix dlls, pFirst should probably be used to hold pGtcb...
;   406 --  dwMagicC/E can be used to check we located csLock correctly, all pointers should end with 0b00.
;   407 --  Obviously, on all superblock headers dwThreadId should match pTCB->dwThreadId (which also means
;   408 --  setting pSBH.dwThreadId to zero when transferring it to the global pool [&resetting pSBH.pTCB]).
;   409 --  
;   410 --  Possible improvements: Currently the pGtcb.pNxtcb chain is scanned to locate a dwThreadId, it may 
;   411 --                          improve matters to keep the current thread's tcb in thread local storage, 
;   412 --                          or use some other faster lookup.
;   413 --                         At startup, it hammers through ~17*2 pFree/pNofl on the thread tcb, and
;   414 --                          repeats that trick on the global pool. It might help (tracing, anyway)
;   415 --                          to have nMax holding the highest pFree/pNofl that can possibly contain
;   416 --                          anything useful. On 64-bit it's ~49*4 such checks that will all fail.
;   417 --                          Or: Init pFree with -1's, and when we allocate something, replace any
;   418 --                          lower pFree[i]s of -1 with 0s. If a scan stops on a pFree[] of -1, we
;   419 --                          know the rest of the table is empty and the same for pNofl (which is 
;   420 --                          still initialised to 0s). I'm thinking of a "js :ohnoitsallempty".
;   421 --                          To be fair, though, even saving 400 million clocks on a real-world
;   422 --                          application is unlikely to be particularly noticeable, these days.
;   423 --                         It might also be possible to detect the "startup" case, allocate an
;   424 --                          initial superblock and then obtain a tcb from within that. That could 
;   425 --                          however mean that we need to merge within the global pool, which I
;   426 --                          think would be a bad idea.
;   427 --                         We could also mark (in use) allocated blocks by setting bit #02 in pRoot,
;   428 --                          so they can be skipped by any memory leak checking code (none such yet).
;   429 --                          Obviously that means after xor(pRoots) we cmp 3 not cmp 1, before ja,
;   430 --                          and of course we need to mask out the extra bit. (ditto for pStack)
;   431 --                          [Update: I am now thinking that constant lf=allocate(sizeof(LOGFONT))
;   432 --                           w/o free should be treated as a memory leak that should be fixed.]
;   433 --                         Deferred coalescing. I have noticed this performs quite poorly when 
;   434 --                          saving 60,000-line+ files in Edita. This implements very aggressive
;   435 --                          coalescing, even to the point of returning fully merged blocks to the
;   436 --                          global pool, as soon as anything is freed. One approach might be to
;   437 --                          extend pFree/pNofl to pFree/pDefc/pNofl, and only process pDefc when
;   438 --                          there is nothing immediately available on pFree, ideally stopping
;   439 --                          the coalescing process the moment we have merged a block of the
;   440 --                          original required size. It may also be possible to utilise the spare
;   441 --                          bit on pRoot (#02) to indicate blocks which have not been coalesced.
;   442 --                          It would clearly be quite critical that #02 blocks are kept grouped 
;   443 --                          together at the head of pFree and we can stop scanning the list as 
;   444 --                          soon as we hit any non-#02 entry - pDefc is now sounding easier.
;   445 --                          Use the pHeap.e/pHeapD.e approach (see psym/ptok). Thread termination
;   446 --                          and the like may require a temporary reversion to aggressive mode.
;   447 --
;   448 --
;   449 -- Memory Leak Checking And Heap Diagnostics
;   450 -- =========================================
;   451 --  Every entry on the free list has a logical partner that we can examine. While that block might
;   452 --  be further split internally, it should be enough to report on the leftmost chunk.
;   453 --
;   454 --  This approach does not locate anything in completely full superblocks, but is deemed to be 
;   455 --  good enough for our purposes - if that ever proves otherwise it should prove relatively 
;   456 --  simple to skip down the full list of superblocks (start with pGtcb.pFirst then follow the
;   457 --  pNxtsb chain) and examine offset 0 for any block with a non-0 dwThreadId that we failed to 
;   458 --  visit via the freelists. As long as we report at least one of the possibly many items in 
;   459 --  error, the assumption is made that, after the programmer has fixed that particular memory 
;   460 --  leak or corruption, the next run will show up anything else that also needs to be reported.
;   461 --
;   462 --  It also strikes me that we will need to process all pNofl at the start of all of this:
;   463 --   things like mergelist and scan_orphans may want to be made part of the optable. [DEV?]
;   464 --
;   465 --  In order to make any sense of the contents of the heap, we need to store an era (effective
;   466 --  return address), as shown above in "Entry Padding", that can later be translated into a 
;   467 --  source file/line. Note that if we find an "orphaned" block of memory there is little point
;   468 --  trying to guess whether it is/was a float/string/sequence/raw memory, especially if we are
;   469 --  suspicious that any kind of memory corruption may have happened. What we do know is where
;   470 --  the padding/era are/should be, and the block size (from whatever free list entry pairs with 
;   471 --  it), and a hex dump of the first 40 bytes (size of sequence header) or so should be enough.
;   472 --
;   473 --  Also, any such checks are only performed when interpreting, and take significant advantage 
;   474 --  of having two (or more) heaps: the initial one that compiles the source code and later on
;   475 --  runs the code that analyses the second, and a second one, only used while running the app.
;   476 --  Obviously that means we can code the potentially difficult analysis in normal hll code, and
;   477 --  not have to worry that day-to-day work vars are messing up the very thing we are looking at.
;   478 --  If we are not going to do the analysis, clearly we can stick with using just the one heap.
;   479 --  Maybe at some point the required code could be repackaged into a single "check_memory()" 
;   480 --  call that can be invoked from the very last line of an application (and when interpreted 
;   481 --  it would effectively all get done twice), so that we can (optionally) have some form of
;   482 --  this checking in a compiled program, but that is left as an exercise for the reader. [DEV did I say that better somewhere else? opposite/create a new stack to run the analysis is...]
;   483 --
;   484 --  Because existing libraries such as win32lib and arwen contain non-released memory allocations
;   485 --  such as constant lf = allocate(SIZEOF_LOGFONT), and things like call_back() allocate memory 
;   486 --  that is never released, the default is to skip all memory obtained via allocate(), which is     [BLUFF]
;   487 --  achieved by leaving the era set to 0 (or perhaps some other magic number). Alternatively we
;   488 --  could have allocate() set era but have a secondary routine, say not_freed(a), which clears 
;   489 --  the era to exclude it from subsequent checking. Checking that all allocate() calls in an 
;   490 --  application have an appropriate matching free() is for now something that may or may not be 
;   491 --  returned to at a later date. Right now this is concentrating on the quiet stuff that goes on 
;   492 --  behind the scenes pretty much all the time.
;   493 --
;   494 --  The interpret code (in p.exw/main) needs something like:    [DONE]
;   495 --
;   496 --      #ilASM{
;   497 --              ...
;   498 --              call :%pNewGtcbChain        -- (if analysing)
;   499 --              mov [ntcb4],eax             -- temp save
;   500 --              <existing call :%newStack still rqd>
;   501 --              <existing call(symtab[T_maintls][S_il])>
;   502 --              <existing restore ebp/esp/symtabptr>
;   503 --              mov eax,[ntcb4]
;   504 --              call :%pRestoreGtcbChain    -- (if analysing)
;   505 --              mov [ntcb4],edx             -- analyse later, in hll (and free it)
;   506 --              ...
;   507 --            }
;   508 --      check_heap(ntcb4)                   -- (if analysing)
;   509 --      <carry on with profile, -test, etc>
;   510 --
;   511 --copied from above: [DEV/dead]
;   512 --  add next/prev to pAlloc/pFree. Need to save/restore/0 pAhead with pGtcb.
;   513 --  rework pStack to use :%pAlloc/pFree, then :%pGetPool/FreePool->::pGetPool/FreePool,
;   514 --  and remove them from the optable. (AH: but :%pFreePool is used by pApnd.e)
;   515 --  code to pFree() everything on pAhead, in pCleanupAll. Create/test say FALLOC=0/1.
;   516 --  then code to scan for memory leaks, also in pCleanupAll. Proper reporting may want/
;   517 --  need to be done in pdiag; we might want to limit the number of items listed, and
;   518 --  common up with existing code therein the conversion of era-1 to file/line, plus
;   519 --  hammering down symtab collecting [S_il] addresses and sorting them into order is
;   520 --  definately a job for hll rather than asm. Or we could scan symtab looking for the
;   521 --  largest [S_il] less than era, starting with symtab[T_maintls]. Or we could mark 
;   522 --  all alloc with a special tag/magic, and simply skip them (optionally) when checking
;   523 --  for memory leaks... Or just have an era of 0 in pAlloc.
;   524 --  DOH: let's just do memory leak checking when interpreted (only) and save the things
;   525 --  from the "opInterp", before restoring the ones used by p.exw; then we can analyse
;   526 --  things in hll code at our leisure!!!    <<--***
;   527 --</dead>
;   528 --
;   529 --
;   530 --  Note: if profiling then analysing should be turned off, otherwise there could be floats
;   531 --  as stored by opLnp[t] etc in the wrong heap/being reported as memory leaks, likewise for
;   532 --  tracing.
;   533 --
;   534 -- Revised Sizes.
;   535 -- =============
;   536 --  The initial plan of 16/32/64/128 etc byte sizes falls apart once we have entry padding. I wrote a
;   537 --  quick ditty (reproduced below) which created the following suggested sizes (for 32-bit):
;   538 --
;   539 --  idx      superblock size            block size  details             string           sequence
;   540 --  [1]                               24[#00000018]=4+4+16              n/a              n/a
;   541 --  [2]                               48[#00000030]=4+4+40              x(23)            s[5]
;   542 --  [3]                               96[#00000060]=4+4+88              x(71)            s[17]
;   543 --  [4]                              192[#000000C0]=4+4+184             x(167)           s[41]
;   544 --  [5]                              384[#00000180]=4+4+376             x(359)           s[89]
;   545 --  [6]                              768[#00000300]=4+4+760             x(743)           s[185]
;   546 --  [7]                             1536[#00000600]=4+4+1528            x(1,511)         s[377]
;   547 --  [8]                             3072[#00000C00]=4+4+3064            x(3,047)         s[761]
;   548 --  [9]                             6144[#00001800]=4+4+6136            x(6,119)         s[1,529]
;   549 -- [10]      12308[#00003014]      12288[#00003000]=4+4+12280 *         x(12,263)        s[3,065]
;   550 -- [11]      24596[#00006014]      24576[#00006000]=4+4+24568           x(24,551)        s[6,137]
;   551 -- [12]      49172[#0000C014]      49152[#0000C000]=4+4+49144           x(49,127)        s[12,281]
;   552 -- [13]      98324[#00018014]      98304[#00018000]=4+4+98296           x(98,279)        s[24,569]
;   553 -- [14]     196628[#00030014]     196608[#00030000]=4+4+196600          x(196,583)       s[49,145]
;   554 -- [15]     393236[#00060014]     393216[#00060000]=4+4+393208          x(393,191)       s[98,297]
;   555 -- [16]     786452[#000C0014]     786432[#000C0000]=4+4+786424          x(786,407)       s[196,601]
;   556 -- [17]    1572884[#00180014]    1572864[#00180000]=4+4+1572856         x(1,572,839)     s[393,209]
;   557 -- [18]    3145748[#00300014]    3145728[#00300000]=4+4+3145720         x(3,145,703)     s[786,425]
;   558 -- [19]    6291476[#00600014]    6291456[#00600000]=4+4+6291448         x(6,291,431)     s[1,572,857]
;   559 -- [20]   12582932[#00C00014]   12582912[#00C00000]=4+4+12582904        x(12,582,887)    s[3,145,721]
;   560 -- [21]   25165844[#01800014]   25165824[#01800000]=4+4+25165816        x(25,165,799)    s[6,291,449]
;   561 -- [22]   50331668[#03000014]   50331648[#03000000]=4+4+50331640        x(50,331,623)    s[12,582,905]
;   562 -- [23]  100663316[#06000014]  100663296[#06000000]=4+4+100663288       x(100,663,271)   s[25,165,817]
;   563 -- [24]  201326612[#0C000014]  201326592[#0C000000]=4+4+201326584       x(201,326,567)   s[50,331,641]
;   564 -- [25]  402653204[#18000014]  402653184[#18000000]=4+4+402653176       x(402,653,159)   s[100,663,289]
;   565 -- [26]  805306388[#30000014]  805306368[#30000000]=4+4+805306360       x(805,306,343)   s[201,326,585]
;   566 -- [27] 1610612756[#60000014] 1610612736[#60000000]=4+4+1610612728      x(1,610,612,711) s[402,653,177]
;   567 --([28] 3221225492[#C0000014] 3221225472[#C0000000]=4+4+3221225464      x(3,221,225,447) s[805,306,361]) [not possible, see below]
;   568 --                                      [#C0000000=3.00GB]
;   569 -- (The * on item 10 marks the virtual stack block size as used in pStack.e)
;   570 --
;   571 --  idx indicates the freelist entry (pFree/pNofl) [although this code uses 0,4,8...104(=26*4)]
;   572 --  superblock size includes the header and what we request from the OS (minimum 12K+20 rather than 8K)
;   573 --  The block size (critically) is the value which doubles in the above table, or, if you prefer to think 
;   574 --  the other way round, it is the value that we can halve and therefore split into two smaller blocks.
;   575 --  The details column shows padding (pRoot/era) and useable space, and by implication how to "round up".
;   576 --  The string and sequence columns show the maximum sizes the block can contain.
;   577 --
;   578 --  In the above scheme, a standard superblock can contain 512 floats, and if we assume the majority of 
;   579 --  strings are less than 71 characters long and the majority of sequences are less than 17 elements long 
;   580 --  (which is more likely to be so for table[i] than table) then a standard superblock can contain >= 128 
;   581 --  of them. All of which suggests that, on average, locking should be required less than 1% of the time.
;   582 --
;   583 --  The last entry ([28]) is shown in brackets because it would always fail, since kernel32/HeapAlloc has a 
;   584 --  hard limit of #7FFFFFFF. In practice (no doubt real-world apps would manage quite a bit less) it failed 
;   585 --  at #734CA1F8, equivalent to x(1,934,401,999) and s[483,600,499], as opposed to the values in [27] above. 
;   586 --  In adopting this scheme we are accepting an artificial limit of some 83% of the theoretical limit, not
;   587 --  that even a half-competent programmer should be thinking that hogging all possible available memory is 
;   588 --  the best way to achieve anything. Plus it kinda guarantees ~308MB should usually be available to cover 
;   589 --  diagnostics and/or any potential differences in available memory between compiled & interpreted apps,
;   590 --  at least when it fails when asked for something too big, as opposed to too many of something smaller.
;   591 --  Quick experiments on RDS Eu 2.4 and OpenEuphoria 4.1 (32-bit) gave (sequence) limits of s[483,164,865] 
;   592 --  and s[468,365,949] respectively, clearly (20%) better than the Phix dword-sequence limit, but a paltry 
;   593 --  30% of the Phix string (/byte/file size) limit.
;   594 --  
;   595 --  On a practical note, repeating the (trivial) size calculation loop on each and every allocation request
;   596 --  is actually faster than any dirty bsr-style skullduggery. (Ignore that if you don't know what it means.)
;   597 --  Testing will no doubt be limited to "if the smaller sizes all work, we can stop". Lastly, remember that 
;   598 --  explicit requests (ie allocate()) need an extra size field, so the limits for that are 12,36,84,180,372, 
;   599 --  but (thankfully) a few judiciously placed +/-12/24 allow the exact same code to be used for both).
;   600 --
;   601 --  As promised, I shall now formally declare the following limitations:
;   602 --
;   603 --      32-bit Phix does not support memory allocations over 1,610,612,728 bytes and in turn strings longer
;   604 --      than 1,610,612,711 characters or dword-sequences longer than 402,653,177. (The manual states these
;   605 --      limits as 400 million characters or 100 million elements, triple-able if allocated up front.)
;   606 --      64-bit Phix has (or more accurately is expected to have) such ludicrously high limits they are hardly 
;   607 --      worth mentioning. Oh go on then, around 5.5EB, by which I mean 5 million TB, which in 2014 is over a 
;   608 --      /billion/ quids worth of RAM (based on a 256GB SSD for 75), and presumably a leccy bill that would 
;   609 --      put the LHC to shame. I recently (May 2014) read that x86-64 is limited to 256TB, and Windows 7, 
;   610 --      according to wikipedia, is limited to 192GB.
;   611 --
;   612 --pHeapD:
;   613 -- The 64-bit version of the above table is:
;   614 --  idx      superblock size            block size  details     string          sequence
;   615 --  [1]                               44[#0000002C]=8+8+26+2    n/a             n/a
;   616 --  [2]                               88[#00000058]=8+8+72      x(39)           s[4]
;   617 --  [3]                              176[#000000B0]=8+8+160     x(127)          s[15]
;   618 --  [4]                              352[#00000160]=8+8+336     x(303)          s[37]
;   619 --  [5]                              704[#000002C0]=8+8+688     x(655)          s[81]
;   620 --  [6]                             1408[#00000580]=8+8+1392    x(1,359)        s[169]
;   621 --  [7]                             2816[#00000B00]=8+8+2800    x(2,767)        s[345]
;   622 --  [8]                             5632[#00001600]=8+8+5616    x(5,583)        s[697]
;   623 --  [9]      11296[#00002C20]      11264[#00002C00]=8+8+11248 * x(11,215)       s[1,401]
;   624 -- [10]      22560[#00005820]      22528[#00005800]=8+8+22512   x(22,479)       s[2,809]
;   625 -- [11]      45088[#0000B020]      45056[#0000B000]=8+8+45040   x(45,007)       s[5,625]
;   626 -- [12]      90144[#00016020]      90112[#00016000]=8+8+90096   x(90,063)       s[11,257]
;   627 -- [13]     180256[#0002C020]     180224[#0002C000]=8+8+180208  x(180,175)      s[22,521]
;   628 -- [14]     360480[#00058020]     360448[#00058000]=8+8+360432  x(360,399)      s[45,049]
;   629 -- [15]     720928[#000B0020]     720896[#000B0000]=8+8+720880  x(720,847)      s[90,105]
;   630 -- [16]    1441824[#00160020]    1441792[#00160000]=8+8+1441776 x(1,441,743)    s[180,217]
;   631 -- [17]    2883616[#002C0020]    2883584[#002C0000]=8+8+2883568 x(2,883,535)    s[360,441]
;   632 -- [18]    5767200[#00580020]    5767168[#00580000]=8+8+5767152 x(5,767,119)    s[720,889]
;   633 --  <snip>
;   634 -- [58] 6341068275337658400[#5800000000000020] 6341068275337658368[#5800000000000000]=16+6341068275337658352  x(6,341,068,275,337,658,319)  s[792,633,534,417,207,289]
;   635 --([59]12682136550675316768[#B000000000000020]12682136550675316736[#B000000000000000]=16+12682136550675316720 x(12,682,136,550,675,316,687) s[1,585,267,068,834,414,585])
;   636 --                                                                [#B000000000000000=11.00EB]
;   637 --
;   638 -- The above assumes floats are 16 byte header and a tbyte, so 26 bytes, rounded up to 28 to keep dword-alignment,
;   639 --  strings have a 32 byte header but are still ansi/UTF8, sequences have a 40 byte header and each element is 8 
;   640 --  bytes, and the superblock header becomes 32 bytes and padding (pRoot) doubles to 16 bytes, as detailed below.
;   641 --pHeapD:
;   642 --< The allocate() limits become 20,56,128,272,560,1138, etc, similar to 32-bit, that is +8,*2 instead of *2,+8.
;   643 --  The allocate() limits become 20,64,152,328,680,1384, etc, similar to 32-bit, that is +16,*2 instead of *2,+16.
;   644 --? The allocate() limits become 4,48,136,312,664,1368, etc, similar to 32-bit, that is +20,*2 instead of *2,+16.
;   645 --  The last 10 or so entries are probably beyond any practical use, but there is little gain to removing them.
;   646 --
;   647 --
;   648 --pHeapD (VERY OLD)
;   649 -- Provisionally, I expect the 64-bit version might end up something like this: (oops: #22 is not a whole number of dwords!)    [DEV OLD/BROKEN, see Try2 below]
;   650 --  idx      superblock size            block size  details     string          sequence
;   651 --  [1]                               34[#00000022]=8+26        n/a             n/a
;   652 --  [2]                               68[#00000044]=8+60        x(27)           s[2] (+4 bytes unused)
;   653 --  [3]                              136[#00000088]=8+128       x(95)           s[11]
;   654 --  [8]                             4352[#00001100]=8+4344      x(4,311)        s[538]
;   655 --  [9]       8736[#00002220]       8704[#00002200]=8+8696      x(8,663)        s[1,082]
;   656 -- [10]      17440[#00004420]      17408[#00004400]=8+17400     x(17,367)       s[2,170]
;   657 -- [11]      34848[#00008820]      34816[#00008800]=8+34808     x(34,775)       s[4,346]
;   658 --
;   659 -- pre-pHeapD:
;   660 -- Try2: (and this /might/ need even more padding to qword-align everything, if it turns out we need that)
;   661 --  idx      superblock size            block size  details     string          sequence
;   662 --  [1]                               36[#00000024]=8+26+2      n/a             n/a
;   663 --  [2]                               72[#00000048]=8+64        x(31)           s[3]
;   664 --  [7]                             2304[#00000900]=8+2296      x(2,263)        s[282]
;   665 --  [8]                             4608[#00001200]=8+4600      x(4,567)        s[570]
;   666 --  [9]       9248[#00002420]       9216[#00002400]=8+9208      x(9,175)        s[1,146]
;   667 -- [10]      18464[#00004820]      18432[#00004800]=8+18424     x(18,391)       s[2,298]
;   668 -- [11]      36896[#00009020]      36864[#00009000]=8+36856     x(36,823)       s[4,602]
;   669 --
;   670 --< The above assumes floats are 16 byte header and a tbyte, so 26 bytes rounded up to 28 to keep dword-alignment,
;   671 --< strings have a 32 byte header but are still ansi/UTF8, sequences have a 40 byte header and each element is 8 
;   672 --< bytes, and the superblock header becomes 32 bytes and padding (pRoot) doubles to 8 bytes, as detailed below.
;   673 --< The allocate() limits become 20,56,128,272,560,1138, etc, similar to 32-bit, that is +8,*2 instead of *2,+8.
;   674 --< The last 10 or so entries are probably beyond any practical use, but there is little gain to removing them.
;   675 --^<pHeapD ends>
;   676 --
;   677 -- Just in case anyone wants to play around with these numbers a bit more, here are the quick ditties I used:
;   678 --
;   679 --  -- 32-bit:
;   680 --  atom d = 16
;   681 --  atom w
;   682 --  integer i = 2
;   683 --  while d<2*1024*1024*1024 do
;   684 --      w = (d+8)*2     -- pHeapD
;   685 --      d = w-8
;   686 --      printf(1,"-- [%d] %10d[#%08x] %10d[#%08x]=4+%d\t\tx(%,d)\ts[%,d]\n",{i,w+20,w+20,w,w,d,d-17,floor((d-20)/4)})
;   687 --      i += 1
;   688 --  end while
;   689 --  printf(1,"[#%08x=%3.2fGB]\n",{w,w/(1024*1024*1024)})
;   690 --  if getc(0) then end if
;   691 --  abort(0)
;   692 --
;   693 --  -- 64-bit:
;   694 --  -- (note that if this is run on 32-bit, the 53-bit precision of floats loses the trailing #20 [line 54+]
;   695 --  --  on the lhs, and the rhs can be out by approx 2K. Lines 58..59 shown above are from a 64-bit run.)
;   696 --  atom d = 28
;   697 --  atom w
;   698 --  integer i = 2
;   699 --  while d<8*1024*1024*1024*1024*1024*1024 do
;   700 --      w = (d+16)*2    -- pHeapD
;   701 --      d = w-16
;   702 --      printf(1,"-- [%d] %10d[#%08x] %10d[#%08x]=8+%d\tx(%,d)\ts[%,d]\n",{i,w+32,w+32,w,w,d,d-33,floor((d-40)/8)})
;   703 --      i += 1
;   704 --  end while
;   705 --  printf(1,"[#%08x=%3.2fEB]\n",{w,w/(1024*1024*1024*1024*1024*1024)})
;   706 --  if getc(0) then end if
;   707 --  abort(0)
;   708 --
;   709 -- Superblock Header (64-bit)
;   710 -- ==========================
;   711 --  DWORD   dwMagic     -- [+0] checked for memory corruption ("SBH\0" = #00484253)
;   712 --  DWORD   dwThreadId  -- [+4] owner
;   713 --  QWORD   nsbSize     -- [+8] does not include this 32 bytes (should always be >= 8K)
;   714 --  QWORD   pTCB        -- [+16] ptr/4 to the owning Thread Control Block (see below)
;   715 --  QWORD   pNxtsb      -- [+24] next superblock
;   716 --  ==
;   717 --  32 bytes (#20) - note that magic and threadId are (quite deliberately) still dwords.
;   718 --
;   719 -- Entry Padding (64-bit)
;   720 -- ======================
;   721 --pHeapD:
;   722 --  QWORD   era         -- [-16] effective return address, for diagnostics/leak checking
;   723 --  QWORD   pRoot       -- [-8] pointer to the SuperBlock Header[+1]
;   724 --                      -- 0b01 (aka bit 0): block is free
;   725 --                      -- if xor(left,right) not 0|1 then memory corruption has occurred.
;   726 --  (QWORD  nSize)      -- [+0] size (permanent for allocate()d blocks)
;   727 --  (QWORD  pNext)      -- [+8] (on free items only), next freelist link
;   728 --  (QWORD  pPrev)      -- [+16] (on owned free items only), previous freelist link
;   729 --
;   730 -- Thread Control Block (64-bit)
;   731 -- =============================
;   732 --  DWORD       dwMagicT    -- [+0] checked for memory corruption ("TCB\0" = #00424354)
;   733 --  DWORD       dwThreadId  -- [+4] owner
;   734 --  QWORD       pNxtcb      -- [+8] next tcb
;   735 --  QWORD       pFirst      -- [+16] first superblock
;   736 --  QWORD       nStatus     -- [+24] -1: normal, -2: orphaned, -3: free, -4: global pool
;   737 --  QWORD[58]   pFree       -- [+32] chains of owned free blocks, by size (not locked)
;   738 --  QWORD[58]   pNofl       -- [+496]  ""    not-      ""                 (need locks)
;   739 --  DWORD       dwMagicB    -- [+960] checked for memory corruption ("BCB\0" = #00424342)
;   740 --  DWORD       dwMagicC    -- [+964] checked for memory corruption ("CCB\0" = #00424343)
;   741 --  BYTE[40]    csLock      -- [+968] critical section for locking (a dword futex on Lnx)
;   742 --  DWORD       dwMagicE    -- [+1008] checked for memory corruption ("ECB\0" = #00424345)
;   743 --  ===
;   744 --  1012 bytes - note that magic and threadId are (quite deliberately) still dwords.
;   745 --  dwMagicC can be used to check we located csLock correctly, all pointers should end 0b00
;   746 --
;   747 --
;   748 --DEV this probably belongs in the manual (ilASM), referenced here:
;   749 -- Technical note
;   750 -- ==============
;   751 --  This code contains both 32 and 64 bit versions, as well as PE and ELF differences.
;   752 --  In particular I want to point out that any split into equivalent chunks for 32/64 
;   753 --  or PE/ELF is quite arbitrary: pilasm.e declares labels etc using exactly the same
;   754 --  conditions (emitON) that control binary being emitted. When you see the general 
;   755 --  pattern [32] [64] [] label [32] [64] [] label [32] [64] [] label, you should not 
;   756 --  assume anything other than that I have used labels as a convenient breakpoint. 
;   757 --  So, for example, [32] ::mergeone [64] ::mergeone [] should not cause any problem.
;   758 --  Obviously [32] ::somelabel [64] call :somelabel [] causes the predictable error,
;   759 --  which can be somewhat confusing, so declaring all labels under [] is recommended.
;   760 --  While there is nothing wrong with [32] 800 lines [64] 800 lines [], it is probably 
;   761 --  a fair bit easier to maintain when the equivalent blocks both fit on the screen.
;   762 --  Of course it largely depends on what you are doing: when debugging (or simply just 
;   763 --  reading and understanding) it will probably help to have larger chunks, whereas 
;   764 --  smaller chunks make applying equivalent changes to 32 and 64 bit code far easier.
;   765 --  Obviously the splits you see were for translation, which is now done and dusted.
;   766 --  Feel free to merge/uninterleave or split/interleave chunks as it takes your fancy,
;   767 --  or "factor out" common code such as EnterCriticalSection and/or GetCurrentThreadId. [DONE!]
;   768 --  Likewise I have tended to use the ordering [PE32]/[ELF32]/[PE64]/[ELF64] but there
;   769 --  is no reason that (for instance) [PE32]/[PE64]/[ELF32]/[ELF64] would be wrong.
;   770 --  Obviously the code is more than twice as long as it would be if it supported just
;   771 --  a single target architecture, not much that can realistically be done about that.
;   772 --
;   773 --
;   774 -- Techical note: this all goes horribly wrong if e/rbx is not 0 on entry, hence to 
;   775 --  avoid grief I zero it at all known entry points. Feel free to add a few more.
;   776 --
;   777 
;   778 -- OLD STUFF:
;   779 -- Inconsequential ramblings that I couldn't quite bring myself to delete
;   780 -- ======================================================================
;   781 --  Obviously, feel free to skip this section.
;   782 --
;   783 --  Technically speaking hll variables/values beginning with 0b10 are invalid. 
;   784 --  Undefined behaviour occurs if the backend is asked to process such garbage,
;   785 --  ie in most cases it would probably be treated as a negative integer, but
;   786 --  other times it could bit-shift it and more than likely crash immediately.
;   787 --  Of course data (f64/char[]/raw memory) can contain any value, including 
;   788 --  dwords that happen to begin with 0b10, it is hll variables, and likewise
;   789 --  dword-sequence elements, which cannot. Note however the [new] compiler uses
;   790 --  0b10 for pre-relocated references, which get shr 2+0b001'd leaving a 0b01 
;   791 --  leadin. Said shift and add can be/is done at compilation-time for normal 
;   792 --  executables, but must be done after loading for DLLs [if ever finished].)
;   793 --
;   794 --DOH: I can/should do ALOT of testing before trying to make this live!!!
;   795 --SUG:safe_poke(base,offset,value): [base-8] must not have 0b01, [[base-8]] must be "SBH\0",
;   796 -- offset must be >=0 and <(=?)[base-4]-sizeinbytes(value).
;   797 --
;   798 --  All memory allocations are rounded up to a sensible size for subsequent splitting/reuse.
;   799 --  It makes little sense to bother the OS with sizes less than 8K, instead we grab ourselves
;   800 --  a "superblock" and farm out little bits of it ourselves. What we need are blocks that can
;   801 --  be split (in half) and recombined simply and efficiently. For now, assume powers of 2 (16,
;   802 --  32,64,128,256,...2GB) but expect a bit of tweaking in a moment.
;   803 --
;   804 --  This is deliberately fragile, with plenty of checks that trigger (/crash) when the slightest
;   805 --  thing goes wrong, on the basis that if it has not crashed by the time we have self-hosted
;   806 --  Phix and run Edita, then it probably never will.
;   807 --
;   808 --without debug
;   809 
;   810 --include builtins\VM\pFPU.e        -- (:%down53/64, :%near53/64 in pAlloc/Free)
;   811 --include builtins\VM\pFEH.e
;   812 --DEV
;   813 --include builtins\VM\pDeleteN.e
;   814 
;   815 integer pGtcb = 0       -- the global control block (dwThreadId=0, stored /4)
;   816                         -- (suprisingly, these 3=0 are all the initialisation we need!)
;   817 
;   818 integer stdcs = 0       -- for very short one-off inits in \builtins (opEnter/LeaveCS).
;   819 
;   820 --integer gt1tcb = 0
;   821 
;   822 #ilASM{ jmp :!opCallOnceYeNot
                jmp :!opCallOnceYeNot     ;#00441787: 351 56160000               v  00 00  1   1      
;   823 
;   824 --/*
;   825 procedure :%pGetpGtcb(:%)
;   826 end procedure -- (for Edita/CtrlQ)
;   827 --*/
;   828     :%pGetpGtcb         -- (for external heap diagnostics, if ever needed/written)
;   829 ---------------
;   830     [32]
;   831         mov eax,[pGtcb]
;   832     [64]
;   833         mov rax,[pGtcb]
                mov rax,[#00402F08] (pGtcb)  ;#0044178C: 48:213005 7517FCFF         uv 01 00  1   2      
;   834     []
;   835         ret
                ret                       ;#00441793: 303                        np 00 00  2   3      
;   836 
;   837 --/*
;   838 procedure :%pNewGtcbChain(:%)
;   839 end procedure -- (for Edita/CtrlQ)
;   840 --*/
;   841     :%pNewGtcbChain
;   842 --------------
;   843         -- eax/rax:=existing [pGtcb], if any, and [pGtcb]:=0 forces the test/newtcb 
;   844         --          at the start of pGetPool to trigger the next time it is called.
;   845         --  see "Memory Leak Checking And Heap Diagnostics" above
;   846     [32]
;   847         mov eax,[pGtcb]
;   848         mov [pGtcb],ebx
;   849     [64]
;   850         mov rax,[pGtcb]
                mov rax,[#00402F08] (pGtcb)  ;#00441794: 48:213005 6D17FCFF         uv 01 00  1   5      
;   851         mov [pGtcb],rdx
                mov [#00402F08] (pGtcb),rdx  ;#0044179B: 48:211025 6617FCFF         vu 00 04  1   5      
;   852     []
;   853         ret
                ret                       ;#004417A2: 303                        np 00 00  2   6      
;   854 
;   855 --/*
;   856 procedure :%pRestoreGtcbChain(:%)
;   857 end procedure -- (for Edita/CtrlQ)
;   858 --*/
;   859     :%pRestoreGtcbChain
;   860 ------------------
;   861         -- restore [pGtcb] from the value in eax/rax, typically saved from the one 
;   862         --  p.exe just used to compile the source, and return the current value in 
;   863         --  edx/rdx, typically one that was specially created to interpret the app
;   864         --  in, deliberately distinct from the p.exe one so that we can analyse it.
;   865         --  see "Memory Leak Checking And Heap Diagnostics" above
;   866     [32]
;   867         mov edx,[pGtcb]
;   868         mov [pGtcb],eax
;   869     [64]
;   870         mov rdx,[pGtcb]
                mov rdx,[#00402F08] (pGtcb)  ;#004417A3: 48:213025 5E17FCFF         uv 04 00  1   8      
;   871         mov [pGtcb],rax
                mov [#00402F08] (pGtcb),rax  ;#004417AA: 48:211005 5717FCFF         vu 00 01  1   8      
;   872     []
;   873         ret
                ret                       ;#004417B1: 303                        np 00 00  2   9      
;   874 
;   875 --/*
;   876 procedure ::pGetMem(::)
;   877 end procedure -- (for Edita/CtrlQ)  [I quickly tired of keying CtrlQ/<stare blankly>/AltS]
;   878 --*/
;   879     ::pGetMem
;   880 -------------
;   881         -- on entry, eax(/rax) is the required length, including any headers
;   882         -- caller is responsible for any required locking
;   883         -- on exit, eax(/rax) is the allocated memory (may want a /4)
;   884         -- can return 0 (which should be fatal for everything except allocate())
;   885         [PE32]
;   886             -- standard (Windows API) calling convention applies: 
;   887             -- eax/ecx/edx are damaged, as are st0..7
;   888             -- ebx/esi/edi are preserved
;   889             -- result in eax, eax:edx, or st0
;   890             push eax                                -- dwBytes (for HeapAlloc)
;   891             call "kernel32.dll","GetProcessHeap"
;   892 --DEV try HEAP_NO_SERIALIZE (=#00000001), when running performance tests, but I somehow doubt it will matter
;   893 --      (specifically test calling allocate(8000) until it fails)
;   894             push ebx                                -- dwFlags (0)
;   895             push eax                                -- hHeap
;   896             call "kernel32.dll","HeapAlloc"
;   897         [PE64]
;   898             -- standard (Windows API) calling convention applies: 
;   899             -- first 4 parameters are passed in rcx/rdx/r8/r9 (or xmm0..3),
;   900             -- caller (ie this code) must allocate >=32 bytes of shadow space.
;   901             -- logically: p1/rcx at [rsp], p2/rdx at [rsp+8], p3/r8 at [rsp+16],
;   902             -- p4/r9 at [rsp+24], then: p5 in [rsp+32], p6 in [rsp+40], etc.
;   903             -- rax/rcx/rdx/r8/r9/r10/r11 are damaged, as are xmm0..5 and st0..7
;   904             -- rbx/rbp/rdi/rsi/r12/r13/r14/r15 are preserved (as are xmm6..15)
;   905             -- result in rax or xmm0
;   906             --
;   907             -- Auto-aligning the stack to a 16-byte boundary
;   908             -- =============================================
;   909             --  (this may or may not be a good idea, assumes stack is 8-byte aligned)
;   910             --      mov reg,rsp         -- (if you got one to spare, obviously, else a)
;   911             --      push rsp            -- (push rsp; push qword[rsp] pair will do, but)
;   912             --      push reg            -- (that way causes an AGI stall, on the [rsp].)
;   913             --      -- (there are now two copies of the original rsp on the stack, doh)
;   914             --      or rsp,8            -- [rsp] is now 1st or 2nd copy:
;   915             --                          -- if on entry rsp was xxx8: both copies remain on the stack
;   916             --                          -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them
;   917             --                          -- obviously rsp is now xxx8, whatever alignment we started with
;   918             --      sub rsp,8*<odd>     -- (realign the stack as you normally would, including shadow space)
;   919             --      <code>
;   920             --  --  add rsp,8*<odd>
;   921             --  --  pop rsp             -- restore, equivalent to rsp += (either #08 or #10)
;   922             --      mov rsp,[rsp+8*odd] -- equivalent to the add/pop
;   923             --
;   924             mov rcx,rsp -- put 2 copies of rsp onto the stack...
                    mov rcx,rsp           ;#004417B2: 48:213314                  uv 02 10  1  11      
;   925             push rsp
                    push rsp              ;#004417B5: 48:124                     vu 00 10  1  11      
;   926             push rcx
                    push rcx              ;#004417B7: 48:121                     uv 00 02  1  12      
;   927             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#004417B9: 48:203314 08               vu 10 10  1  12      
;   928                         -- if on entry rsp was xxx8: both copies remain on the stack
;   929                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;   930                         -- obviously rsp is now xxx8, whatever alignment we started with
;   931             sub rsp,8*5                             -- minimum 4 param shadow space, and align/somewhere to save rax
                    sub rsp,40            ;#004417BD: 48:203354 28               uv 10 10  1  13      
;   932             mov [rsp+32],rax                        -- save rax (required length)
                    mov [rsp+32],rax      ;#004417C1: 48:211104044 20            uv 00 11  1  16 10 *10*
;   933             call "kernel32.dll","GetProcessHeap"
                    call [#004010B0] (GetProcessHeap)  ;#004417C6: 377025 E4F8FBFF            np 00 00  2  17      
;   934             mov r8,[rsp+32]                         -- dwBytes (p3)
                    mov r8,[rsp+32]       ;#004417CC: 4C:213104044 20            uv 100 10  1  19      
;   935             mov rdx,rbx                             -- dwFlags (p2,0)
                    mov rdx,rbx           ;#004417D1: 48:213323                  vu 04 08  1  19      
;   936             mov rcx,rax                             -- hHeap (p1)
                    mov rcx,rax           ;#004417D4: 48:213310                  uv 02 01  1  20      
;   937             call "kernel32.dll","HeapAlloc"
                    call [#004010C0] (HeapAlloc)  ;#004417D7: 377025 E3F8FBFF            np 00 00  2  21      
;   938 --          add rsp,8*5
;   939 --          pop rsp
;   940             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#004417DD: 48:213144044 28            uv 10 10  1  23      
;   941         [ELF32]
;   942             -- standard (kernel) calling convention applies: 
;   943             -- syscall (int 0x80) number in eax (see docs\LinuxSyscallReference.txt), eg:
;   944             --  1 sys_exit
;   945             --  3 sys_read
;   946             --  4 sys_write (stdout is 1)
;   947             --  5 sys_open
;   948             --  6 sys_close
;   949             -- 45 sys_brk
;   950             --140 sys_llseek
;   951             -- arguments in ebx,ecx,edx,esi,edi[,ebp?] (so assume *all* regs damaged)
;   952             -- (may need brandelf -t Linux filename on freeBSD, unless we can figure out how to do that as part of "p -c")
;   953             -- *NB*: ELF32 often requires "xor ebx,ebx" after an int 0x80, whereas PE32/PE64/ELF64 preserve ebx/rbx
;   954             push eax            -- save size
;   955             -- call sys_brk(0) to find the current location of the program break
;   956             xor ebx,ebx
;   957             mov eax,45          -- sys_brk(ebx=long brk)
;   958             int 0x80
;   959             cmp eax,-4096
;   960             ja :error_brk
;   961             -- call sys_brk(prev+size) to set the new program break
;   962             mov ebx,eax
;   963             add ebx,[esp]       -- size
;   964             push eax
;   965             mov eax,45          -- sys_brk(ebx=long brk)
;   966             int 0x80
;   967             pop ecx             -- prev
;   968             cmp eax,-4096
;   969             jbe @f
;   970           ::error_brk
;   971                 xor ecx,ecx
;   972           @@:
;   973             -- return previous program break (or 0)
;   974             mov eax,ecx
;   975             add esp,4           -- discard size
;   976             xor ebx,ebx         -- (common requirement after an int 0x80)
;   977 
;   978         [ELF64]
;   979             -- standard (kernel) calling convention applies: 
;   980             -- syscall number in rax (see docs\lsct64.txt)
;   981             -- first 6 parameters are passed in rdi/rsi/rdx/rcx(or r10 for system calls)/r8/r9 (or xmm0..7).
;   982             -- rax/rcx/rdx/rsi/rdi/r8/r9/r10/r11 are damaged, as are xmm0..15 and st0..7
;   983             -- rbx/rbp/r12/r13/r14/r15 are preserved
;   984             push rax                -- save length
;   985 --          mov r14,rax             -- save length
;   986             -- call sys_brk(0) to find the current location of the program break
;   987             xor rdi,rdi
;   988             mov rax,12              -- sys_brk(rdi=unsigned long brk)
;   989             syscall
;   990             -- call sys_brk(prev+size) to set the new program break
;   991 --          mov rdi,rax
;   992 --          add rdi,r14
;   993             pop rdi
;   994             add rdi,rax
;   995             mov rax,12              -- sys_brk(rdi=unsigned long brk)
;   996             syscall
;   997 --          pop r14
;   998 --  Description                     RAX     RBX     RCX     RDX     RSI     RDI     RBP     RSP     R8      R9      R10     R11     R12     R13     R14     R15     RIP/RA
;   999 --  Dwarf2 number                   0       3       2       1       4       5       6       7       8       9       10      11      12      13      14      15      16
;  1000 --  Preserved across function calls         Yes                                     Yes     Yes                                     Yes     Yes     Yes     Yes     N/A
;  1001 --  Function parameter                              4th     3rd     2nd     1st                     5th     6th                                                     N/A
;  1002 --  Return register                 1st                     2nd                                                                                                     N/A
;  1003 --  Kernel parameter                #NR                     3rd     2nd     1st                     5th     6th     4th                                             N/A
;  1004         []
;  1005             ret
                    ret                   ;#004417E2: 303                        np 00 00  2  24      
;  1006 
;  1007 --/*
;  1008 procedure ::pGetThread(::)
;  1009 end procedure -- (for Edita/CtrlQ)
;  1010 --*/
;  1011     ::pGetThread
;  1012 ----------------
;  1013         -- nb most registers are trashed, as per calling conventions outlined above
;  1014         --   (but feel free to save/restore them here, if it helps any)
;  1015         --  result in eax/rax
;  1016         [PE32]
;  1017             call "kernel32.dll","GetCurrentThreadId"
;  1018         [ELF32]
;  1019             mov eax,20              -- sys_getpid()
;  1020             int 0x80 
;  1021         [PE64]
;  1022             mov rax,rsp -- put 2 copies of rsp onto the stack...
                    mov rax,rsp           ;#004417E3: 48:213304                  uv 01 10  1  26      
;  1023             push rsp
                    push rsp              ;#004417E6: 48:124                     vu 00 10  1  26      
;  1024             push rax
                    push rax              ;#004417E8: 48:120                     uv 00 01  1  27      
;  1025             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#004417EA: 48:203314 08               vu 10 10  1  27      
;  1026                         -- if on entry rsp was xxx8: both copies remain on the stack
;  1027                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1028                         -- obviously rsp is now xxx8, whatever alignment we started with
;  1029             sub rsp,8*5
                    sub rsp,40            ;#004417EE: 48:203354 28               uv 10 10  1  28      
;  1030             call "kernel32.dll","GetCurrentThreadId"
                    call [GetCurrentThreadId]  ;#004417F2: 377025 90F8FBFF            np 00 00  2  29      
;  1031 --          add rsp,8*5
;  1032 --          pop rsp
;  1033             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#004417F8: 48:213144044 28            uv 10 10  1  31      
;  1034         [ELF64]
;  1035             mov eax,39              -- sys_getpid()
;  1036             syscall
;  1037         []
;  1038             ret
                    ret                   ;#004417FD: 303                        np 00 00  2  32      
;  1039     
;  1040 
;  1041 --/*
;  1042 procedure ::EnterCriticalSection(::)
;  1043 end procedure -- (for Edita/CtrlQ)
;  1044 --*/
;  1045     ::EnterCriticalSection
;  1046 --------------------------
;  1047         -- note this is internal, see also :%opEnterCS
;  1048         [PE32]
;  1049             -- lpCriticalSection in ecx
;  1050             push ecx
;  1051             call "kernel32.dll","EnterCriticalSection"
;  1052             ret
;  1053         [PE64]
;  1054             -- lpCriticalSection in rcx
;  1055             mov rax,rsp -- put 2 copies of rsp onto the stack...
                    mov rax,rsp           ;#004417FE: 48:213304                  uv 01 10  1  34      
;  1056             push rsp
                    push rsp              ;#00441801: 48:124                     vu 00 10  1  34      
;  1057             push rax
                    push rax              ;#00441803: 48:120                     uv 00 01  1  35      
;  1058             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#00441805: 48:203314 08               vu 10 10  1  35      
;  1059                         -- if on entry rsp was xxx8: both copies remain on the stack
;  1060                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1061                         -- obviously rsp is now xxx8, whatever alignment we started with
;  1062             sub rsp,8*5
                    sub rsp,40            ;#00441809: 48:203354 28               uv 10 10  1  36      
;  1063             call "kernel32.dll","EnterCriticalSection"
                    call [EnterCriticalSection]  ;#0044180D: 377025 35F8FBFF            np 00 00  2  37      
;  1064 --          add rsp,8*5
;  1065 --          pop rsp
;  1066             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#00441813: 48:213144044 28            uv 10 10  1  39      
;  1067             ret
                    ret                   ;#00441818: 303                        np 00 00  2  40      
;  1068 
;  1069 --      [ELF]
;  1070 --          --/*
;  1071 --            -- credit: "futexes are tricky" by Ulrich Drepper (futex3 code)
;  1072 --            int val = 0;
;  1073 --            void lock() {
;  1074 --              int c;
;  1075 --              if ((c = cmpxchg(val, 0, 1)) != 0) {
;  1076 --                if (c!=2) {
;  1077 --                  c = xchg(val, 2);
;  1078 --                }
;  1079 --                while (c!=0) {
;  1080 --                  futex_wait(&val, 2);
;  1081 --                  c = xchg(val, 2);
;  1082 --                }
;  1083 --              }
;  1084 --            }
;  1085 --            void unlock() {
;  1086 --              if (atomic_dec(val) != 1) {
;  1087 --                val = 0;
;  1088 --                futex_wake(&val, 1);
;  1089 --              }
;  1090 --            }
;  1091 --            My quick explanation (go and find a copy of futex.pdf for more detail):
;  1092 --              val has three states:  0 = unlocked, 1 = locked no waiters, 2 = locked with waiters.
;  1093 --              lock: if we can 0->1 then we're done (fast route, uncontended lock)
;  1094 --                    else loop: set val to 2; if it was 0 we're done else wait/loop.
;  1095 --              unlock: set val (which must have been 1 or 2) to 0; if it was 2 wake one waiter up.
;  1096 --          --*/
;  1097 
;  1098         [ELF32]
;  1099             -- csLock (address of a dword futex) in ecx
;  1100             -- all registers trashed
;  1101             mov edx,1
;  1102             xor eax,eax
;  1103             lock cmpxchg [ecx],edx  -- atomic(<tmp>:=eax; eax:=[ecx]; if <tmp>==eax then [ecx]:=edx end if)
;  1104             test eax,eax            -- so if eax is now/still 0, then [ecx] just got set (from 0) to 1.
;  1105             jz @f
;  1106                 push ecx
;  1107                 cmp eax,2
;  1108                 je :futex_wait      -- (else [rcx] must have been 1 on entry)
;  1109               ::xchg2
;  1110                 mov eax,2
;  1111                 lock xchg [ecx],eax
;  1112                 test eax,eax
;  1113                 jz :futex_locked    -- if [ecx] just got set from 0 to 2, we're done (else (1|2)->2==>wait)
;  1114               ::futex_wait
;  1115                     mov eax,240         -- sys_futex(ebx=void *futex, ecx=int op, edx=int val, esi=const struct timespec *timeout[==NULL][, edi=void *futex2, ebp=int val3])
;  1116                     mov ebx,ecx         -- *futex
;  1117                     mov ecx,#80         -- FUTEX_WAIT(0) or FUTEX_PRIVATE_FLAG(128)
;  1118                     mov edx,2           -- val
;  1119                     xor esi,esi         -- no timeout
;  1120                     int 0x80            -- futex_wait(ecx,2)
;  1121                     xor ebx,ebx
;  1122                     mov ecx,[esp]
;  1123                     jmp :xchg2
;  1124               ::futex_locked
;  1125                 pop ecx
;  1126           @@:
;  1127             ret
;  1128 
;  1129         [ELF64]
;  1130             -- csLock (address of a dword futex) in rcx (yes, a futex is still a dword on 64-bit)
;  1131             mov edx,1
;  1132             xor eax,eax
;  1133             lock cmpxchg [rcx],edx  -- atomic(<tmp>:=eax; eax:=[rcx]; if <tmp>==eax then [rcx]:=edx end if)
;  1134             test eax,eax            -- so if eax is now/still 0, then [rcx] just got set (from 0) to 1.
;  1135             jz @f
;  1136                 push rcx
;  1137                 cmp eax,2
;  1138                 je :futex_wait      -- (else [rcx] must have been 1 on entry)
;  1139               ::xchg2
;  1140                 mov eax,2
;  1141                 lock xchg [rcx],eax
;  1142                 test eax,eax
;  1143                 jz :futex_locked    -- if [rcx] just got set from 0 to 2, we're done (else (1|2)->2==>wait)
;  1144               ::futex_wait
;  1145                     mov eax,202         -- sys_futex(rdi=u32*uaddr, rsi=int op, rdx=u32 val, r10=struct timespec*utime[==NULL] [,r8=u32*uaddr2,r9=u32 val3])
;  1146                     mov rdi,rcx         -- *futex
;  1147                     mov rsi,#80         -- FUTEX_WAIT(0) or FUTEX_PRIVATE_FLAG(128)
;  1148                     mov edx,2           -- val
;  1149                     xor r10,r10         -- no timeout
;  1150                     syscall             -- futex_wait(rcx,2)
;  1151                     mov rcx,[rsp]
;  1152                     jmp :xchg2
;  1153               ::futex_locked
;  1154                 pop rcx
;  1155           @@:
;  1156             ret
;  1157         []
;  1158 
;  1159 --/*
;  1160 procedure ::TryEnterCriticalSection(::)
;  1161 end procedure -- (for Edita/CtrlQ)
;  1162 --*/
;  1163     ::TryEnterCriticalSection
;  1164 -----------------------------
;  1165         -- note this is internal, see also :%opTryCS
;  1166         [PE32]
;  1167             -- lpCriticalSection in ecx
;  1168             push ecx
;  1169             call "kernel32.dll","TryEnterCriticalSection"
;  1170             -- eax==0 on failure [DEV may want a test/mov 1 here]
;  1171             ret
;  1172         [PE64]
;  1173             -- lpCriticalSection in rcx
;  1174             mov rax,rsp -- put 2 copies of rsp onto the stack...
                    mov rax,rsp           ;#00441819: 48:213304                  uv 01 10  1  42      
;  1175             push rsp
                    push rsp              ;#0044181C: 48:124                     vu 00 10  1  42      
;  1176             push rax
                    push rax              ;#0044181E: 48:120                     uv 00 01  1  43      
;  1177             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#00441820: 48:203314 08               vu 10 10  1  43      
;  1178                         -- if on entry rsp was xxx8: both copies remain on the stack
;  1179                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1180                         -- obviously rsp is now xxx8, whatever alignment we started with
;  1181             sub rsp,8*5
                    sub rsp,40            ;#00441824: 48:203354 28               uv 10 10  1  44      
;  1182             call "kernel32.dll","TryEnterCriticalSection"
                    call [TryEnterCriticalSection]  ;#00441828: 377025 0AF9FBFF            np 00 00  2  45      
;  1183 --          add rsp,8*5
;  1184 --          pop rsp
;  1185             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#0044182E: 48:213144044 28            uv 10 10  1  47      
;  1186             -- rax==0 on failure [DEV may want a test/mov 1 here]
;  1187             ret
                    ret                   ;#00441833: 303                        np 00 00  2  48      
;  1188 
;  1189         [ELF32]
;  1190             -- csLock (address of a dword futex) in ecx
;  1191             -- all registers trashed
;  1192             mov edx,1
;  1193             xor eax,eax
;  1194             lock cmpxchg [ecx],edx  -- atomic(<tmp>:=eax; eax:=[ecx]; if <tmp>==eax then [ecx]:=edx end if)
;  1195             test eax,eax            -- so if eax is now/still 0, then [ecx] just got set (from 0) to 1.
;  1196             jz @f
;  1197                 xor eax,eax         -- failure
;  1198                 ret
;  1199           @@:
;  1200             mov eax,1
;  1201             ret
;  1202 
;  1203         [ELF64]
;  1204             -- csLock (address of a dword futex) in rcx (yes, a futex is still a dword on 64-bit)
;  1205             mov edx,1
;  1206             xor rax,rax
;  1207             lock cmpxchg [rcx],edx  -- atomic(<tmp>:=eax; eax:=[rcx]; if <tmp>==eax then [rcx]:=edx end if)
;  1208             test eax,eax            -- so if eax is now/still 0, then [rcx] just got set (from 0) to 1.
;  1209             jz @f
;  1210                 xor rax,rax         -- failure
;  1211                 ret
;  1212           @@:
;  1213             mov rax,1
;  1214             ret
;  1215         []
;  1216 
;  1217 --/*
;  1218 procedure ::LeaveCriticalSection(::)
;  1219 end procedure -- (for Edita/CtrlQ)
;  1220 --*/
;  1221     ::LeaveCriticalSection
;  1222 --------------------------
;  1223         -- note this is internal, see also :%opLeaveCS
;  1224         [PE32]
;  1225             -- lpCriticalSection in ecx
;  1226             push ecx
;  1227             call "kernel32.dll","LeaveCriticalSection"
;  1228             ret
;  1229 
;  1230         [PE64]
;  1231             -- lpCriticalSection in rcx
;  1232             mov rax,rsp -- put 2 copies of rsp onto the stack...
                    mov rax,rsp           ;#00441834: 48:213304                  uv 01 10  1  50      
;  1233             push rsp
                    push rsp              ;#00441837: 48:124                     vu 00 10  1  50      
;  1234             push rax
                    push rax              ;#00441839: 48:120                     uv 00 01  1  51      
;  1235             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#0044183B: 48:203314 08               vu 10 10  1  51      
;  1236                         -- if on entry rsp was xxx8: both copies remain on the stack
;  1237                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1238                         -- obviously rsp is now xxx8, whatever alignment we started with
;  1239             sub rsp,8*5
                    sub rsp,40            ;#0044183F: 48:203354 28               uv 10 10  1  52      
;  1240             call "kernel32.dll","LeaveCriticalSection"
                    call [LeaveCriticalSection]  ;#00441843: 377025 8FF8FBFF            np 00 00  2  53      
;  1241 --          add rsp,8*5
;  1242 --          pop rsp
;  1243             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#00441849: 48:213144044 28            uv 10 10  1  55      
;  1244             ret
                    ret                   ;#0044184E: 303                        np 00 00  2  56      
;  1245 
;  1246         [ELF32]
;  1247             -- csLock (address of a dword futex) in ecx
;  1248             lock sub dword[ecx],1   -- *futex -= 1
;  1249             jz @f
;  1250                 mov [ecx],ebx       -- *futex := 0
;  1251                 mov eax,240         -- sys_futex(ebx=u32*uaddr, ecx=int op, edx=u32 val [,esi=struct timespec*utime,edi=u32*uaddr2,ebp=u32 val3])
;  1252                 mov ebx,ecx         -- *futex
;  1253                 mov ecx,#81         -- FUTEX_WAKE(1) or FUTEX_PRIVATE_FLAG(128)
;  1254                 mov edx,1           -- val
;  1255                 int 0x80            -- futex_wake(ecx,1)
;  1256                 xor ebx,ebx
;  1257           @@:
;  1258             ret
;  1259 
;  1260         [ELF64]
;  1261             -- csLock (address of a dword futex) in rcx
;  1262             lock sub dword[rcx],1   -- *futex -= 1  (yes, it is still a dword on 64-bit)
;  1263             jz @f
;  1264                 mov [rcx],rbx       -- *futex := 0
;  1265                 mov eax,202         -- sys_futex(rdi=u32*uaddr, rsi=int op, rdx=u32 val [,r10=struct timespec*utime,r8=u32*uaddr2,r9=u32 val3])
;  1266                 mov rdi,rcx         -- *futex
;  1267                 mov rsi,#81         -- FUTEX_WAKE(1) or FUTEX_PRIVATE_FLAG(128)
;  1268                 mov edx,1           -- val
;  1269                 syscall             -- futex_wake(rcx,1)
;  1270           @@:
;  1271             ret
;  1272         []
;  1273 
;  1274 --/*
;  1275 procedure ::newtcb(::)
;  1276 end procedure -- (for Edita/CtrlQ)
;  1277 --*/
;  1278     ::newtcb
;  1279 ------------
;  1280         -- (no parameters)
;  1281         -- caller is responsible for any required locking
;  1282         -- on exit edi(/rdi) is pTCB/4 (dwThreadId is left set to 0)
;  1283         -- esi(/rsi) is preserved, all other registers are trashed [DEV]
;  1284         [32]
;  1285             mov edi,[pGtcb]     -- (stored /4)
;  1286             test edi,edi
;  1287             jz @f
;  1288                 -- (this loop assumes pGtcb.csLock is in force)
;  1289               ::scanforfreetcblooptop
;  1290                 mov edi,[ebx+edi*4+8]           -- pNxtcb
;  1291                 test edi,edi
;  1292                 jz @f
;  1293                 cmp dword[ebx+edi*4+16],-3      -- nStatus (free)
;  1294                 jne :scanforfreetcblooptop
;  1295                 jmp :freetcbfound
;  1296           @@:
;  1297             mov eax,268         -- sizeof(TCB)
;  1298             call :pGetMem
;  1299             test eax,eax
;  1300 --          jz :memoryallocationfailure
;  1301             jnz @f
;  1302                 int3
;  1303           @@:
;  1304             mov edx,eax
;  1305             lea edi,[eax+4]
;  1306             shr eax,2
;  1307             push eax            -- [1] save result
;  1308             mov dword[edx],#00424354                    -- dwMagicT ("TCB\0")
;  1309             mov dword[edx+264],#00424345                -- dwMagicE ("ECB\0")
;  1310             xor eax,eax
;  1311             mov ecx,65 -- (4+27*2+1+6)  -- (not dwMagicT/E, dwThreadId..csLock[$])
;  1312             rep stosd
;  1313             mov dword[edx+236],#00424343                -- dwMagicC ("CCB\0")
;  1314         [PE32]
;  1315             add edx,240
;  1316             push edx                                    -- lpCriticalSection
;  1317             call "kernel32.dll","InitializeCriticalSection"
;  1318 --      [ELF32]
;  1319             -- (a mutex (int32) of 0, as already set, is enough)
;  1320         [32]
;  1321             pop edi             -- [1] pTCB/4
;  1322           ::freetcbfound
;  1323             mov dword[ebx+edi*4+16],-1  -- nStatus (normal)
;  1324         [64]
;  1325             mov rax,rsp -- put 2 copies of rsp onto the stack...
                    mov rax,rsp           ;#0044184F: 48:213304                  uv 01 10  1  58      
;  1326             push rsp
                    push rsp              ;#00441852: 48:124                     vu 00 10  1  58      
;  1327             push rax
                    push rax              ;#00441854: 48:120                     uv 00 01  1  59      
;  1328             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#00441856: 48:203314 08               vu 10 10  1  59      
;  1329                         -- if on entry rsp was xxx8: both copies remain on the stack
;  1330                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1331                         -- obviously rsp is now xxx8, whatever alignment we started with
;  1332             sub rsp,8*5                                 -- minimum 4 param shadow space, and align/somewhere to save rax
                    sub rsp,40            ;#0044185A: 48:203354 28               uv 10 10  1  60      
;  1333             mov rdi,[pGtcb]                             -- (stored /4)
                    mov rdi,[#00402F08] (pGtcb)  ;#0044185E: 48:213075 A316FCFF         vu 80 00  1  60      
;  1334             test rdi,rdi
                    test rdi,rdi          ;#00441865: 48:205377                  uv 00 80  1  61      
;  1335             jz @f
                    jz #0044187E          ;#00441868: 164 14                     v  00 00  1  61      
;  1336                 -- (this loop assumes pGtcb.csLock is in force)
;  1337               ::scanforfreetcblooptop
;  1338                 mov rdi,[rbx+rdi*4+8]           -- pNxtcb
                        mov rdi,[rbx+rdi*4+8]  ;#0044186A: 48:213174273 08            uv 80 88  1  62      
;  1339                 test rdi,rdi
                        test rdi,rdi      ;#0044186F: 48:205377                  uv 00 80  1  63 80   
;  1340                 jz @f
                        jz #0044187E      ;#00441872: 164 0A                     v  00 00  1  63      
;  1341                 cmp qword[rbx+rdi*4+24],-3      -- nStatus (free)
                        cmp qword[rbx+rdi*4+24],-3  ;#00441874: 48:203174273 18 FD         u  00 88  2  64      
;  1342                 jne :scanforfreetcblooptop
                        jne #0044186A     ;#0044187A: 165 EE                     v  00 00  1  65      
;  1343                 jmp :freetcbfound
                        jmp #004418E6     ;#0044187C: 353 68                     v  00 00  1  66      
;  1344           @@:
;  1345             mov rax,1012    -- sizeof(TCB)
                    mov rax,1012          ;#0044187E: 48:307300 F4030000         uv 01 00  1  67      
;  1346             call :pGetMem
                    call #004417B2        ;#00441885: 350 28FFFFFF               v  00 00  1  67      
;  1347             test rax,rax
                    test rax,rax          ;#0044188A: 48:205300                  uv 00 01  1  68      
;  1348 --          jz :memoryallocationfailure
;  1349             jnz @f
                    jnz #00441890         ;#0044188D: 165 01                     v  00 00  1  68      
;  1350                 int3
                        int3              ;#0044188F: 314                        np 00 00 13  69      
;  1351           @@:
;  1352             mov rdx,rax
                    mov rdx,rax           ;#00441890: 48:213320                  uv 04 01  1  82      
;  1353             lea rdi,[rax+8]
                    lea rdi,[rax+8]       ;#00441893: 48:215170 08               vu 80 01  1  82      
;  1354             shr rax,2
                    shr rax,2             ;#00441897: 48:301350 02               u  01 01  1  83      
;  1355             mov [rsp+32],rax    -- [1] save result
                    mov [rsp+32],rax      ;#0044189B: 48:211104044 20            uv 00 11  1  84 01   
;  1356             mov dword[rdx],#00424354                    -- dwMagicT ("TCB\0")
                    mov [rdx], dword #00424354  ;#004418A0: 307002 54434200            vu 00 04  1  84      
;  1357             mov dword[rdx+4],ebx                        -- dwThreadId (:=0)
                    mov [edx+4],ebx       ;#004418A6: 211132 04                  uv 00 0C  1  85      
;  1358             mov dword[rdx+1008],#00424345               -- dwMagicE ("ECB\0")
                    mov [rdx+1008], dword #00424345  ;#004418A9: 307202 F0030000 45434200   vu 00 04  1  85      
;  1359             xor rax,rax
                    xor rax,rax           ;#004418B3: 48:061300                  uv 01 01  1  86      
;  1360             mov rcx,125 -- (3+58*2+1+5) -- (not dwMagicT/E, not dwThreadId, pNextcb..csLock[$])
                    mov rcx,125           ;#004418B6: 48:307301 7D000000         vu 02 00  1  86      
;  1361             rep stosq
                    rep stosq             ;#004418BD: 363:48:253                 np 82 83  3  87      
;  1362             mov dword[rdx+960],#00424342                -- dwMagicB ("BCB\0")
                    mov [rdx+960], dword #00424342  ;#004418C0: 307202 C0030000 42434200   uv 00 04  1  90      
;  1363             mov dword[rdx+964],#00424343                -- dwMagicC ("CCB\0")
                    mov [rdx+964], dword #00424343  ;#004418CA: 307202 C4030000 43434200   vu 00 04  1  90      
;  1364         [PE64]
;  1365             lea rcx,[rdx+968]                           -- lpCriticalSection (p1)
                    lea rcx,[rdx+968]     ;#004418D4: 48:215212 C8030000         uv 02 04  1  91      
;  1366             call "kernel32.dll","InitializeCriticalSection"
                    call [InitializeCriticalSection]  ;#004418DB: 377025 E7F7FBFF            np 00 00  2  92      
;  1367 --      [ELF64]
;  1368             -- (a mutex (int32) of 0, as already set, is enough)
;  1369         [64]
;  1370 --          mov rax,[rsp+32]    -- [1] pTCB/4
;  1371             mov rdi,[rsp+32]    -- [1] pTCB/4
                    mov rdi,[rsp+32]      ;#004418E1: 48:213174044 20            uv 80 10  1  94      
;  1372           ::freetcbfound
;  1373             mov qword[rbx+rdi*4+24],-1          -- nStatus (normal)
                    mov qword[rbx+rdi*4+24],-1  ;#004418E6: 48:307104273 18 FFFFFFFF   uv 00 88  1  97 80 *80*
;  1374 --          add rsp,8*5
;  1375 --          pop rsp
;  1376             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#004418EF: 48:213144044 28            vu 10 10  1  97      
;  1377         []
;  1378             ret
                    ret                   ;#004418F4: 303                        np 00 00  2  98      
;  1379 
;  1380 --/*
;  1381 procedure ::mergeone(::)
;  1382 end procedure -- (for Edita/CtrlQ)
;  1383 --*/
;  1384     ::mergeone
;  1385 --------------
;  1386         -- (should only ever be called by the block owner, or fully locked orphaned block handling)
;  1387     [32]
;  1388         -- on entry, return address in [esp] (DOH)
;  1389         --           block ptr in eax and [esp+4] (cleared by this routine)
;  1390         --           block idx(*4) in [esp+8] (cleared by this routine)
;  1391         --           block size in [esp+12] (cleared by this routine) 
;  1392         --           <return address for mergelist or null at [esp+16]>
;  1393         --           tcb/4 in [esp+20]
;  1394         --           (obviously, last two entries cleared by calling routine)
;  1395 --pHeapD?(ok)
;  1396         mov esi,[eax-4]     -- pRoot
;  1397         and esi,#FFFFFFFE   -- clear free bit (0b01, needed when looping)
;  1398         mov ecx,[esp+12]    -- block size
;  1399         cmp dword[esi],#00484253    -- dwMagic ("SBH\0")
;  1400 --      jne :memorycorruption
;  1401         je @f
;  1402             int3
;  1403       @@:
;  1404         cmp ecx,[esi+8]     -- pRoot.nsbSize (does not include header)
;  1405         jne :mergeonenotfull
;  1406             -- block fully merged, return it to the global pool
;  1407 --DEV :%retruntoglobalpool (do we really care??)
;  1408             mov edi,[pGtcb]
;  1409             mov [esi+4],ebx             -- dwThreadId(0)
;  1410             mov [esi+12],edi            -- pTCB/4
;  1411             or esi,1
;  1412             mov [eax],ecx               -- nSize (should already be set?)
;  1413 --pHeapD?(ok)
;  1414             mov [eax-4],esi             -- set free bit (0b01) on pRoot
;  1415             mov esi,eax
;  1416             lea ecx,[ebx+edi*4+240]     -- csLock
;  1417             cmp dword[ebx+edi*4+236],#00424343  -- dwMagicC ("CCB\0")
;  1418             jne :notCCB
;  1419             cmp dword[ebx+edi*4+264],#00424345  -- dwMagicE ("ECB\0")
;  1420             jne :notECB
;  1421             push ecx                    -- (save lpCriticalSection/csLock for Leave)
;  1422             call :EnterCriticalSection
;  1423             mov ecx,[esp+12]            -- idx*4 (+12 as lpCriticalSection still on the stack)
;  1424             mov eax,[edi*4+ecx+20]      -- tmp:=pGtcb.pFree[idx]
;  1425             mov [esi+4],eax             -- this.pNext:=tmp
;  1426             mov [esi+8],ebx             -- this.pPrev:=null
;  1427 --pHeapD?
;  1428 --          mov [esi-8],ebx             -- this.era:=null (erm?)
;  1429             mov [edi*4+ecx+20],esi      -- pGtcb.pFree[idx]:=this
;  1430 --DEV we also want to unlink from pFirst???
;  1431             pop ecx                     -- lpCriticalSection/csLock
;  1432             call :LeaveCriticalSection
;  1433         [64]
;  1434         -- on entry, return address in [rsp] (DOH)
;  1435 --DEV r13,14,15?
;  1436         --           block ptr in rax and [rsp+8] (cleared by this routine)
;  1437         --           block idx(*8) in [rsp+16] (cleared by this routine)
;  1438         --           block size in [rsp+24] (cleared by this routine) 
;  1439         --           <return address for mergelist or null at [rsp+32]>
;  1440         --           tcb/4 in [rsp+40]
;  1441         --           (obviously, last two entries cleared by calling routine)
;  1442         --           Note that, as normal, stack is 8 mod 16 after all that!
;  1443         mov r8,[rax-8]                  -- pRoot
                mov r8,[rax-8]            ;#004418F5: 4C:213100 F8               uv 100 01  1 100      
;  1444         and r8l, byte #FE               -- clear free bit (0b01, needed when looping, but not first time thru)
                and r8l,-2                ;#004418F9: 41:200340 FE               uv 100 100  1 101 100   
;  1445         mov rcx,[rsp+24]                -- block size
                mov rcx,[rsp+24]          ;#004418FD: 48:213114044 18            vu 02 10  1 101      
;  1446         cmp dword[r8],#00484253         -- dwMagic ("SBH\0")
                cmp dword[r8],4735571     ;#00441902: 41:201070 53424800         uv 00 100  2 104    *100*
;  1447 --      jne :memorycorruption
;  1448         je @f
                je #0044190C              ;#00441909: 164 01                     v  00 00  1 105      
;  1449             int3
                    int3                  ;#0044190B: 314                        np 00 00 13 106      
;  1450       @@:
;  1451         cmp rcx,[r8+8]                  -- pRoot.nsbSize (does not include header)
                cmp rcx,[r8+8]            ;#0044190C: 49:073110 08               uv 00 102  2 119      
;  1452         jne :mergeonenotfull
                jne #00441990             ;#00441910: 165 7E                     v  00 00  1 120      
;  1453             -- block fully merged, return it to the global pool
;  1454 --DEV :%retruntoglobalpool (do we really care??)
;  1455             mov rdi,[pGtcb]
                    mov rdi,[#00402F08] (pGtcb)  ;#00441912: 48:213075 EF15FCFF         uv 80 00  1 121      
;  1456             mov [r8+4],ebx              -- dwThreadId(0)
                    mov [r8+4],ebx        ;#00441919: 41:211130 04               vu 00 108  1 121      
;  1457             mov [r8+16],rdi             -- pTCB/4
                    mov [r8+16],rdi       ;#0044191D: 49:211170 10               uv 00 180  1 122      
;  1458             or r8l, byte 1
                    or r8l,1              ;#00441921: 41:200310 01               vu 100 100  1 122      
;  1459             mov [rax],rcx               -- nSize (should already be set?)
                    mov [rax],rcx         ;#00441925: 48:211010                  uv 00 03  1 123      
;  1460             mov [rax-8],r8              -- set free bit (0b01) on pRoot
                    mov [rax-8],r8        ;#00441928: 4C:211100 F8               vu 00 101  1 123      
;  1461             mov rsi,rax
                    mov rsi,rax           ;#0044192C: 48:213360                  uv 40 01  1 124      
;  1462             lea rcx,[rbx+rdi*4+968]     -- csLock
                    lea rcx,[rbx+rdi*4+968]  ;#0044192F: 48:215214273 C8030000      vu 02 88  1 124      
;  1463             cmp dword[rbx+rdi*4+960],#00424342  -- dwMagicB ("BCB\0")
                    cmp dword[rbx+rdi*4+960],#00424342  ;#00441937: 201274273 C0030000 42434200 u  00 88  2 125      
;  1464             jne :notCCB
                    jne #00441B3B         ;#00441942: 017205 F3010000            v  00 00  1 126      
;  1465             cmp dword[rbx+rdi*4+964],#00424343  -- dwMagicC ("CCB\0")
                    cmp dword[rbx+rdi*4+964],#00424343  ;#00441948: 201274273 C4030000 43434200 u  00 88  2 127      
;  1466             jne :notCCB
                    jne #00441B3B         ;#00441953: 017205 E2010000            v  00 00  1 128      
;  1467             cmp dword[rcx+40],#00424345         -- dwMagicE ("ECB\0")
                    cmp dword[rcx+40],#00424345  ;#00441959: 201171 28 45434200         u  00 02  2 129      
;  1468             jne :notECB
                    jne #00441B3D         ;#00441960: 017205 D7010000            v  00 00  1 130      
;  1469             push rcx                    -- save lpCriticalSection/csLock (for Leave)
                    push rcx              ;#00441966: 48:121                     uv 00 02  1 131      
;  1470             call :EnterCriticalSection
                    call #004417FE        ;#00441968: 350 91FEFFFF               v  00 00  1 131      
;  1471             mov rcx,[rsp+24]            -- idx*8
                    mov rcx,[rsp+24]      ;#0044196D: 48:213114044 18            uv 02 10  1 132      
;  1472             mov rax,[rdi*4+rcx+32]      -- tmp:=pGtcb.pFree[idx]
                    mov rax,[rcx+rdi*4+32]  ;#00441972: 48:213104271 20            uv 01 82  1 135 02 *02*
;  1473             mov [rsi+8],rax             -- this.pNext:=tmp
                    mov [rsi+8],rax       ;#00441977: 48:211106 08               uv 00 41  1 136 01   
;  1474             mov [rsi+16],rbx            -- this.pPrev:=null
                    mov [rsi+16],rbx      ;#0044197B: 48:211136 10               vu 00 48  1 136      
;  1475 --pHeapD?
;  1476 --          mov [rsi-16],rbx            -- this.era:=null (erm?)
;  1477             mov [rdi*4+rcx+32],rsi      -- pGtcb.pFree[idx]:=this
                    mov [rcx+rdi*4+32],rsi  ;#0044197F: 48:211164271 20            uv 00 C2  1 137      
;  1478 --DEV we also want to unlink from pFirst?
;  1479             pop rcx                     -- lpCriticalSection/csLock
                    pop rcx               ;#00441984: 48:131                     vu 02 00  1 137      
;  1480             call :LeaveCriticalSection
                    call #00441834        ;#00441986: 350 A9FEFFFF               v  00 00  1 138      
;  1481         []
;  1482             jmp :mergeonedone
                    jmp #00441A94         ;#0044198B: 351 04010000               v  00 00  1 139      
;  1483 
;  1484       ::mergeonenotfull
;  1485         [32]
;  1486             -- odd or even?
;  1487             push eax                    -- [1] in case of no merge
;  1488             sub eax,esi
;  1489 --pHeapD:
;  1490 --<         sub eax,24  -- (superblock header + pRoot)
;  1491             sub eax,28  -- (superblock header + pRoot + era)
;  1492             cmp dword[esi],#00484253    -- dwMagic ("SBH\0")
;  1493             jne :notSBH
;  1494 --          cdq
;  1495             xor edx,edx
;  1496             idiv ecx
;  1497             test edx,edx
;  1498             jnz :internalerror
;  1499             test eax,1
;  1500             mov eax,[esp+8]             -- block ptr
;  1501             mov ecx,[esp+16]            -- block size
;  1502             jnz :mergeleft
;  1503                 -- check right
;  1504                 add eax,ecx
;  1505                 jmp @f
;  1506           ::mergeleft
;  1507                 -- check left
;  1508                 sub eax,ecx
;  1509                 mov [esp+8],eax         -- new block ptr, iff we merge and loop
;  1510           @@:
;  1511             mov edi,[eax-4]             -- pRoot
;  1512             xor esi,edi
;  1513             cmp esi,1
;  1514 --          ja :memorycorruption
;  1515             jbe @f
;  1516                 int3
;  1517           @@:
;  1518             test edi,1
;  1519             jz :nomerge
;  1520             cmp ecx,[eax]               -- nSize
;  1521         [64]
;  1522             -- odd or even?
;  1523 -- DEV use r12?
;  1524             push rax                    -- [1] in case of no merge
                    push rax              ;#00441990: 48:120                     uv 00 01  1 140      
;  1525             sub rax,r8
                    sub rax,r8            ;#00441992: 49:053300                  vu 01 101  1 140      
;  1526 --pHeapD:
;  1527 --<         sub rax,40  -- (superblock header + pRoot)
;  1528             sub rax,48  -- (superblock header + pRoot + era)
                    sub rax,48            ;#00441995: 48:203350 30               uv 01 01  1 141      
;  1529             cmp dword[r8],#00484253     -- dwMagic ("SBH\0")
                    cmp dword[r8],4735571  ;#00441999: 41:201070 53424800         vu 00 100  2 141      
;  1530             jne :notSBH
                    jne #00441B3F         ;#004419A0: 017205 99010000            v  00 00  1 142      
;  1531 --          cdq
;  1532             xor rdx,rdx
                    xor rdx,rdx           ;#004419A6: 48:061322                  uv 04 04  1 143      
;  1533             idiv rcx
                    idiv rcx              ;#004419A9: 48:367371                  np 05 07 46 144      
;  1534             test rdx,rdx
                    test rdx,rdx          ;#004419AC: 48:205322                  uv 00 04  1 190      
;  1535             jnz :internalerror
                    jnz #00441B22         ;#004419AF: 017205 6D010000            v  00 00  1 190      
;  1536             test rax,1
                    test rax,1            ;#004419B5: 48:367300 01000000         uv 00 01  1 191      
;  1537             mov rax,[rsp+16]            -- block ptr
                    mov rax,[rsp+16]      ;#004419BC: 48:213104044 10            vu 01 10  1 191      
;  1538             mov rcx,[rsp+32]            -- block size
                    mov rcx,[rsp+32]      ;#004419C1: 48:213114044 20            uv 02 10  1 192      
;  1539             jnz :mergeleft
                    jnz #004419CD         ;#004419C6: 165 05                     v  00 00  1 192      
;  1540                 -- check right
;  1541                 add rax,rcx
                        add rax,rcx       ;#004419C8: 48:001310                  uv 01 03  1 193      
;  1542                 jmp @f
                        jmp #004419D5     ;#004419CB: 353 08                     v  00 00  1 193      
;  1543           ::mergeleft
;  1544                 -- check left
;  1545                 sub rax,rcx
                        sub rax,rcx       ;#004419CD: 48:051310                  uv 01 03  1 194      
;  1546                 mov [rsp+16],rax        -- new block ptr, iff we merge and loop
                        mov [rsp+16],rax  ;#004419D0: 48:211104044 10            uv 00 11  1 195 01   
;  1547           @@:
;  1548             mov rdi,[rax-8]             -- pRoot
                    mov rdi,[rax-8]       ;#004419D5: 48:213170 F8               uv 80 01  1 197    *01*
;  1549 -- 10/10/14:
;  1550 --          xor rsi,rdi
;  1551 --          cmp rsi,1
;  1552             xor r8,rdi
                    xor r8,rdi            ;#004419D9: 4C:063307                  uv 100 180  1 198 80   
;  1553             cmp r8,1
                    cmp r8,1              ;#004419DC: 49:203370 01               uv 00 100  1 199 100   
;  1554 --          ja :memorycorruption
;  1555             jbe @f
                    jbe #004419E3         ;#004419E0: 166 01                     v  00 00  1 199      
;  1556                 int3
                        int3              ;#004419E2: 314                        np 00 00 13 200      
;  1557           @@:
;  1558             test rdi,1
                    test rdi,1            ;#004419E3: 48:367307 01000000         uv 00 80  1 213      
;  1559             jz :nomerge
                    jz #00441A47          ;#004419EA: 164 5B                     v  00 00  1 213      
;  1560             cmp rcx,[rax]               -- nSize
                    cmp rcx,[rax]         ;#004419EC: 48:073010                  uv 00 03  2 214      
;  1561         []
;  1562             jne :nomerge
                    jne #00441A47         ;#004419EF: 165 56                     v  00 00  1 215      
;  1563                 -- merge blocks - just detach eax from the freelist and loop.
;  1564         [32]
;  1565                 add esp,4                   -- [1] discard 
;  1566 --temp:
;  1567 -- blat the middle pRoot (leave some footprints for a hex dump)
;  1568 --mov esi,[esp+4] -- block ptr
;  1569 --add esi,ecx
;  1570 --mov dword[esi-4],-10
;  1571                 mov esi,[eax+4]             -- pNext
;  1572                 mov edx,[eax+8]             -- pPrev
;  1573                 mov edi,[esp+8]             -- idx(*4)
;  1574                 test edx,edx
;  1575                 jnz :mergeone_midchain
;  1576                     mov edx,[esp+20]        -- tcb/4
;  1577                     test esi,esi
;  1578                     jz @f
;  1579                         mov [esi+8],ebx     -- this.pNext.pPrev:=null(=pPrev)
;  1580                   @@:
;  1581                     mov [edx*4+edi+20],esi  -- pTCB.pFree[idx]:=this.pNext
;  1582                     jmp @f
;  1583               ::mergeone_midchain
;  1584                     mov [edx+4],esi         -- this.pPrev.pNext:=this.pNext
;  1585                     test esi,esi
;  1586                     jz @f
;  1587                         mov [esi+8],edx     -- this.pNext.pPrev:=this.pPrev
;  1588               @@:
;  1589                 mov eax,[esp+4]
;  1590                 add edi,4
;  1591                 add ecx,ecx                 -- (or shl ecx,1)
;  1592                 mov [esp+8],edi             -- idx(*4)
;  1593                 mov [esp+12],ecx            -- block size
;  1594                 mov [eax],ecx               -- nSize
;  1595         [64]
;  1596 --              add esp,8                   -- [1] discard 
;  1597                 add rsp,8                   -- [1] discard 
                        add rsp,8         ;#004419F1: 48:203304 08               uv 10 10  1 216      
;  1598 --temp:
;  1599 -- blat the middle pRoot (leave some footprints for a hex dump)
;  1600 --mov rsi,[rsp+8]   -- block ptr
;  1601 --add rsi,rcx
;  1602 --mov qword[rsi-8],-10
;  1603                 mov rsi,[rax+8]             -- pNext
                        mov rsi,[rax+8]   ;#004419F5: 48:213160 08               vu 40 01  1 216      
;  1604                 mov rdx,[rax+16]            -- pPrev
                        mov rdx,[rax+16]  ;#004419F9: 48:213120 10               uv 04 01  1 217      
;  1605                 mov rdi,[rsp+16]            -- idx(*8)
                        mov rdi,[rsp+16]  ;#004419FD: 48:213174044 10            uv 80 10  1 219    *10*
;  1606                 test rdx,rdx
                        test rdx,rdx      ;#00441A02: 48:205322                  vu 00 04  1 219      
;  1607                 jnz :mergeone_midchain
                        jnz #00441A1C     ;#00441A05: 165 15                     v  00 00  1 220      
;  1608                     mov rdx,[rsp+40]        -- tcb/4
                            mov rdx,[rsp+40]  ;#00441A07: 48:213124044 28            uv 04 10  1 221      
;  1609                     test rsi,rsi
                            test rsi,rsi  ;#00441A0C: 48:205366                  vu 00 40  1 221      
;  1610                     jz @f
                            jz #00441A15  ;#00441A0F: 164 04                     v  00 00  1 222      
;  1611                         mov [rsi+16],rbx    -- this.pNext.pPrev:=null(=pPrev)
                                mov [rsi+16],rbx  ;#00441A11: 48:211136 10               uv 00 48  1 223      
;  1612                   @@:
;  1613                     mov [rdx*4+rdi+32],rsi  -- pTCB.pFree[idx]:=this.pNext
                            mov [rdi+rdx*4+32],rsi  ;#00441A15: 48:211164227 20            vu 00 C4  1 223      
;  1614                     jmp @f
                            jmp #00441A29  ;#00441A1A: 353 0D                     v  00 00  1 224      
;  1615               ::mergeone_midchain
;  1616                     mov [rdx+8],rsi         -- this.pPrev.pNext:=this.pNext
                            mov [rdx+8],rsi  ;#00441A1C: 48:211162 08               uv 00 44  1 225      
;  1617                     test rsi,rsi
                            test rsi,rsi  ;#00441A20: 48:205366                  vu 00 40  1 225      
;  1618                     jz @f
                            jz #00441A29  ;#00441A23: 164 04                     v  00 00  1 226      
;  1619 --                      mov [rsi+8],rdx     -- this.pNext.pPrev:=this.pPrev
;  1620                         mov [rsi+16],rdx    -- this.pNext.pPrev:=this.pPrev
                                mov [rsi+16],rdx  ;#00441A25: 48:211126 10               uv 00 44  1 227      
;  1621               @@:
;  1622                 mov rax,[rsp+8]             -- block ptr
                        mov rax,[rsp+8]   ;#00441A29: 48:213104044 08            vu 01 10  1 227      
;  1623                 add rdi,8
                        add rdi,8         ;#00441A2E: 48:203307 08               uv 80 80  1 228      
;  1624                 add rcx,rcx                 -- (or shl rcx,1)
                        add rcx,rcx       ;#00441A32: 48:001311                  vu 02 02  1 228      
;  1625                 mov [rsp+16],rdi            -- idx(*8)
                        mov [rsp+16],rdi  ;#00441A35: 48:211174044 10            uv 00 90  1 229      
;  1626                 mov [rsp+24],rcx            -- block size
                        mov [rsp+24],rcx  ;#00441A3A: 48:211114044 18            vu 00 12  1 229      
;  1627                 mov [rax],rcx               -- nSize
                        mov [rax],rcx     ;#00441A3F: 48:211010                  uv 00 03  1 230      
;  1628         []
;  1629                 -- ...and loop back to see what else it can be merged with
;  1630                 jmp :mergeone
                        jmp #004418F5     ;#00441A42: 351 AEFEFFFF               v  00 00  1 230      
;  1631 
;  1632           ::nomerge
;  1633                 -- so just add the block to the owned freelist
;  1634         [32]
;  1635                 pop eax                         -- [1] restore
;  1636                 or edi,1                        -- set 0b01 bit...
;  1637                 mov edx,[esp+20]                -- pTCB/4
;  1638                 mov [eax-4],edi                 -- ...on pRoot
;  1639 --pHeapD?
;  1640 --              mov [eax-8],ebx                 -- era:=null?
;  1641                 mov [eax+8],ebx                 -- pPrev(:=0)
;  1642                 mov edi,[esp+8]                 -- idx(*4)
;  1643                 cmp dword[ebx+edx*4],#00424354  -- dwMagicT ("TCB\0")
;  1644 --              jne :notTCB
;  1645                 je @f
;  1646                     int3
;  1647               @@:
;  1648                 mov ecx,[edx*4+edi+20]          -- tmp:=pFree[idx]
;  1649                 mov [eax+4],ecx                 -- this.pNext:=tmp
;  1650                 test ecx,ecx
;  1651                 jz @f
;  1652                     cmp dword[ecx+8],0          -- check tmp.pPrev was 0
;  1653 --                  jnz :pPrevnot0
;  1654                     mov [ecx+8],eax             -- tmp.pPrev:=this
;  1655                     jz @f
;  1656                         pop edx
;  1657 --                      mov edi,[esp+?]
;  1658                         mov edi,edx             -- temp
;  1659                         mov al,32               -- e32hc(era,edi)   --DEV pHeapD show era/line number?
;  1660                         jmp :!iDiag
;  1661                         int3
;  1662               @@:
;  1663                 mov [edx*4+edi+20],eax          -- pFree[idx]:=this
;  1664         [64]
;  1665                 pop rax                         -- [1] restore
                        pop rax           ;#00441A47: 48:130                     uv 01 00  1 231      
;  1666                 or rdi,1                        -- set 0b01 bit...
                        or rdi,1          ;#00441A49: 48:203317 01               vu 80 80  1 231      
;  1667                 mov rdx,[rsp+40]                -- pTCB/4
                        mov rdx,[rsp+40]  ;#00441A4D: 48:213124044 28            uv 04 10  1 232      
;  1668                 mov [rax-8],rdi                 -- ...on pRoot
                        mov [rax-8],rdi   ;#00441A52: 48:211170 F8               uv 00 81  1 234    *01*
;  1669 --pHeapD?
;  1670 --              mov [rax-16],rbx                -- era:=null?
;  1671                 mov [rax+16],rbx                -- pPrev(:=0)
                        mov [rax+16],rbx  ;#00441A56: 48:211130 10               vu 00 09  1 234      
;  1672                 mov rdi,[rsp+16]                -- idx(*8)
                        mov rdi,[rsp+16]  ;#00441A5A: 48:213174044 10            uv 80 10  1 235      
;  1673                 cmp dword[rbx+rdx*4],#00424354  -- dwMagicT ("TCB\0")
                        cmp dword[rbx+rdx*4],#00424354  ;#00441A5F: 201074223 54434200         vu 00 0C  2 235      
;  1674 --              jne :notTCB
;  1675                 je @f
                        je #00441A69      ;#00441A66: 164 01                     v  00 00  1 236      
;  1676                     int3
                            int3          ;#00441A68: 314                        np 00 00 13 237      
;  1677               @@:
;  1678                 mov rcx,[rdx*4+rdi+32]          -- tmp:=pFree[idx]
                        mov rcx,[rdi+rdx*4+32]  ;#00441A69: 48:213114227 20            uv 02 84  1 250      
;  1679 --2/12/14:
;  1680 --              mov [rax+4],rcx                 -- this.pNext:=tmp
;  1681                 mov [rax+8],rcx                 -- this.pNext:=tmp
                        mov [rax+8],rcx   ;#00441A6E: 48:211110 08               uv 00 03  1 251 02   
;  1682                 test rcx,rcx
                        test rcx,rcx      ;#00441A72: 48:205311                  vu 00 02  1 251      
;  1683                 jz @f
                        jz #00441A8F      ;#00441A75: 164 18                     v  00 00  1 252      
;  1684                     cmp qword[rcx+16],0         -- check tmp.pPrev was 0
                            cmp qword[rcx+16],0  ;#00441A77: 48:203171 10 00            u  00 02  2 253      
;  1685 --                  jnz :pPrevnot0
;  1686                     mov [rcx+16],rax            -- tmp.pPrev:=this
                            mov [rcx+16],rax  ;#00441A7C: 48:211101 10               vu 00 03  1 254      
;  1687                     jz @f
                            jz #00441A8F  ;#00441A80: 164 0D                     v  00 00  1 255      
;  1688                         pop rdx
                                pop rdx   ;#00441A82: 48:132                     uv 04 00  1 256      
;  1689 --                      mov rdi,[rsp+?]
;  1690                         mov rdi,rdx             -- temp
                                mov rdi,rdx  ;#00441A84: 48:213372                  uv 80 04  1 257 04   
;  1691                         mov al,32               -- e32hc(era,edi)   --DEV pHeapD show era/line number?
                                mov al,32  ;#00441A87: 260 20                     vu 01 00  1 257      
;  1692                         jmp :!iDiag
                                jmp #00442E66 (:!iDiag)  ;#00441A89: 351 D8130000               v  00 00  1 258      
;  1693                         int3
                                int3      ;#00441A8E: 314                        np 00 00 13 259      
;  1694               @@:
;  1695                 mov [rdx*4+rdi+32],rax          -- pFree[idx]:=this
                        mov [rdi+rdx*4+32],rax  ;#00441A8F: 48:211104227 20            uv 00 85  1 272      
;  1696         []
;  1697       ::mergeonedone
;  1698     [32]
;  1699         ret 12
;  1700     [64]
;  1701         ret 24
                ret 24                    ;#00441A94: 302 1800                   np 00 00  3 273      
;  1702     []
;  1703 
;  1704 --/*
;  1705 procedure ::mergelist(::)
;  1706 end procedure -- (for Edita/CtrlQ)
;  1707 --*/
;  1708     ::mergelist
;  1709 ---------------
;  1710     [32]
;  1711         -- on entry, <return address in [esp]>
;  1712         --           tcb/4 in [esp+4].
;  1713         --           list head in eax and [esp+8], (shd not be 0)
;  1714         --           block size in [esp+12],
;  1715         --           block idx(*4) in [esp+16],
;  1716         -- calling routine is responsible for removing the above
;  1717         -- (no specific result)
;  1718         mov ecx,[eax+4]     -- get/set pNext now
;  1719         mov edi,[esp+12]    -- block size
;  1720         mov edx,[esp+16]    -- block idx
;  1721         mov [esp+8],ecx     -- new list head
;  1722         -- (the following 3 parameters are cleared by mergeone)
;  1723         push edi            -- block size
;  1724         push edx            -- block idx
;  1725         push eax            -- block ptr
;  1726         call :mergeone
;  1727         mov eax,[esp+8]     -- pNext
;  1728         test eax,eax
;  1729     [64]
;  1730         -- on entry, <return address in [rsp]>
;  1731         --           tcb/4 in [rsp+8].
;  1732         --           list head in rax and [rsp+16], (shd not be 0)
;  1733         --           block size in [rsp+24],
;  1734         --           block idx(*8) in [rsp+32],
;  1735         -- calling routine is responsible for removing the above
;  1736         -- (no specific result)
;  1737         mov rcx,[rax+8]     -- get/set pNext now
                mov rcx,[rax+8]           ;#00441A97: 48:213110 08               uv 02 01  1 276      
;  1738         mov rdi,[rsp+24]    -- block size
                mov rdi,[rsp+24]          ;#00441A9B: 48:213174044 18            vu 80 10  1 276      
;  1739         mov rdx,[rsp+32]    -- block idx
                mov rdx,[rsp+32]          ;#00441AA0: 48:213124044 20            uv 04 10  1 277      
;  1740         mov [rsp+16],rcx    -- new list head
                mov [rsp+16],rcx          ;#00441AA5: 48:211114044 10            vu 00 12  1 277      
;  1741         -- (the following 3 parameters are cleared by mergeone)
;  1742         push rdi            -- block size
                push rdi                  ;#00441AAA: 48:127                     uv 00 80  1 278      
;  1743         push rdx            -- block idx
                push rdx                  ;#00441AAC: 48:122                     vu 00 04  1 278      
;  1744         push rax            -- block ptr
                push rax                  ;#00441AAE: 48:120                     uv 00 01  1 279      
;  1745         call :mergeone
                call #004418F5            ;#00441AB0: 350 40FEFFFF               v  00 00  1 279      
;  1746         mov rax,[rsp+16]    -- pNext
                mov rax,[rsp+16]          ;#00441AB5: 48:213104044 10            uv 01 10  1 280      
;  1747         test rax,rax
                test rax,rax              ;#00441ABA: 48:205300                  uv 00 01  1 281 01   
;  1748     []
;  1749         jne :mergelist
                jne #00441A97             ;#00441ABD: 165 D8                     v  00 00  1 281      
;  1750         ret
                ret                       ;#00441ABF: 303                        np 00 00  2 282      
;  1751 
;  1752 --/*
;  1753 procedure ::scan_orphans(::)
;  1754 end procedure -- (for Edita/CtrlQ)
;  1755 --*/
;  1756   ::scan_orphans
;  1757 ----------------
;  1758     [32]
;  1759         -- on entry esi is a locked tcb with nStatus of -2 (orphaned)
;  1760         -- esi is preserved, all other registers are trashed.
;  1761         push dword -3                       -- [1] new nStatus (free, iff everything merges)
;  1762         mov edi,0                           -- idx*4
;  1763 --pHeapD:
;  1764 --<     mov edx,20                          -- block size
;  1765         mov edx,24                          -- block size
;  1766       ::scanorphanlooptop
;  1767             mov eax,[esi*4+edi+128]         -- is pNofl[idx]!=0?
;  1768             test eax,eax
;  1769             jz @f
;  1770                 mov [esi*4+edi+128],ebx     -- pNofl[idx]:=0
;  1771                 push edi                    -- [2] idx*4
;  1772                 push edx                    -- [3] block size
;  1773                 push eax                    -- [4] list head
;  1774                 push esi                    -- [5] pTCB/4
;  1775                 -- recap: mergelist expects
;  1776                 --   return address in [esp],
;  1777                 --   tcb/4 in [esp+4],
;  1778                 --   list head in eax and [esp+8], 
;  1779                 --   block size in [esp+12],
;  1780                 --   block idx(*4) in [esp+16],
;  1781                 -- calling routine is responsible for removing the above
;  1782                 call :mergelist
;  1783                 pop esi                     -- [5] restore pTCB/4
;  1784                 pop eax                     -- [4] list head (discard)
;  1785                 pop edx                     -- [3] restore block size
;  1786                 pop edi                     -- [2] restore idx
;  1787           @@:
;  1788             cmp dword[esi*4+edi+20],0       -- is pFree[idx]!=0?
;  1789             je @f
;  1790                 mov dword[esp],-2           -- leave nStatus as -2 (orphaned)
;  1791           @@:
;  1792             add edi,4
;  1793             add edx,edx
;  1794             cmp edi,108 -- (=27*4)
;  1795             jl :scanorphanlooptop
;  1796         pop dword[ebx+esi*4+16]             -- [1] new nStatus
;  1797     [64]
;  1798         -- on entry rsi is a locked tcb with nStatus of -2
;  1799         -- rsi is preserved, all other registers are trashed.
;  1800         push qword -3                       -- [1] new nStatus (free, iff everything merges)
                push -3                   ;#00441AC0: 48:152 FD                  uv 00 00  1 284      
;  1801         mov rdi,0                           -- idx*8
                mov rdi,0                 ;#00441AC3: 48:307307 00000000         vu 80 00  1 284      
;  1802 --      mov rdx,34                          -- block size
;  1803 --pHeapD:
;  1804 --<     mov rdx,36                          -- block size
;  1805         mov rdx,44                          -- block size
                mov rdx,44                ;#00441ACA: 48:307302 2C000000         uv 04 00  1 285      
;  1806       ::scanorphanlooptop
;  1807             mov rax,[rsi*4+rdi+496]         -- is pNofl[idx]!=0?
                    mov rax,[rdi+rsi*4+496]  ;#00441AD1: 48:213204267 F0010000      uv 01 C0  1 287    *80*
;  1808             test rax,rax
                    test rax,rax          ;#00441AD9: 48:205300                  uv 00 01  1 288 01   
;  1809             jz @f
                    jz #00441AFA          ;#00441ADC: 164 1C                     v  00 00  1 288      
;  1810                 mov [rsi*4+rdi+496],ebx     -- pNofl[idx]:=0
                        mov [rdi+rsi*4+496],ebx  ;#00441ADE: 211234267 F0010000         uv 00 C8  1 289      
;  1811                 push rdi                    -- [2] idx*8
                        push rdi          ;#00441AE5: 48:127                     vu 00 80  1 289      
;  1812                 push rdx                    -- [3] block size
                        push rdx          ;#00441AE7: 48:122                     uv 00 04  1 290      
;  1813                 push rax                    -- [4] list head
                        push rax          ;#00441AE9: 48:120                     vu 00 01  1 290      
;  1814                 push rsi                    -- [5] pTCB/4
                        push rsi          ;#00441AEB: 48:126                     uv 00 40  1 291      
;  1815                 -- recap: mergelist expects
;  1816                 --   return address in [rsp],
;  1817                 --   tcb/4 in [rsp+8],
;  1818                 --   list head in rax and [rsp+16], 
;  1819                 --   block size in [rsp+24],
;  1820                 --   block idx(*8) in [rsp+32],
;  1821                 -- calling routine is responsible for removing the above
;  1822                 call :mergelist
                        call #00441A97    ;#00441AED: 350 A5FFFFFF               v  00 00  1 291      
;  1823                 pop rsi                     -- [5] restore pTCB/4
                        pop rsi           ;#00441AF2: 48:136                     uv 40 00  1 292      
;  1824                 pop rax                     -- [4] list head (discard)
                        pop rax           ;#00441AF4: 48:130                     vu 01 00  1 292      
;  1825                 pop rdx                     -- [3] restore block size
                        pop rdx           ;#00441AF6: 48:132                     uv 04 00  1 293      
;  1826                 pop rdi                     -- [2] restore idx
                        pop rdi           ;#00441AF8: 48:137                     vu 80 00  1 293      
;  1827           @@:
;  1828             cmp qword[rsi*4+rdi+32],0       -- is pFree[idx]!=0?
                    cmp qword[rdi+rsi*4+32],0  ;#00441AFA: 48:203174267 20 00         u  00 C0  2 296    *80*
;  1829             je @f
                    je #00441B0A          ;#00441B00: 164 08                     v  00 00  1 297      
;  1830                 mov qword[rsp],-2           -- leave nStatus as -2 (orphaned)
                        mov qword[rsp],-2  ;#00441B02: 48:307004044 FEFFFFFF      uv 00 10  1 298      
;  1831           @@:
;  1832             add rdi,8
                    add rdi,8             ;#00441B0A: 48:203307 08               vu 80 80  1 298      
;  1833             add rdx,rdx
                    add rdx,rdx           ;#00441B0E: 48:001322                  uv 04 04  1 299      
;  1834 --          cmp edi,108 -- (=27*4)
;  1835             cmp rdi,464 -- (=58*8)
                    cmp rdi,464           ;#00441B11: 48:201377 D0010000         vu 00 80  1 299      
;  1836             jl :scanorphanlooptop
                    jl #00441AD1          ;#00441B18: 174 B7                     v  00 00  1 300      
;  1837 --      pop qword[rbx+rsi*4+24]             -- [1] new nStatus
;  1838         pop rax
                pop rax                   ;#00441B1A: 48:130                     uv 01 00  1 301      
;  1839 --DEV 9/10/14 (spotted in passing)
;  1840 --      mov [ebx+esi*4+16],rax              -- [1] new nStatus
;  1841         mov [ebx+esi*4+24],rax              -- [1] new nStatus
                mov [rbx+rsi*4+24],rax    ;#00441B1C: 48:211104263 18            uv 00 49  1 302 01   
;  1842     []
;  1843         ret
                ret                       ;#00441B21: 303                        np 00 00  2 303      
;  1844 
;  1845 --
;  1846 -- NOTE: it seemed like a clever idea to common up diagnostics, but that
;  1847 --        just made the diagnostics themselves very much harder to debug!
;  1848 --        (as needed I expect to gradually undo/inline the following..)
;  1849 --
;  1850 --    ::memorycorruption    (..much like I've already done with this)
;  1851 --      int3
;  1852 --      nop
;  1853 --    ::pPrevnot0   -- e32hc(era,edi)
;  1854 --          -- first, clear that offending tmp.pPrev
;  1855 --          -- (not ideal, but might reduce diaglooping)
;  1856 --          -- (may also need to unlock)
;  1857 --          [32]
;  1858 --              mov dword[ecx+8],0
;  1859 --              mov ecx,2
;  1860 --              pop edx
;  1861 --              add esp,12
;  1862 --          [64]
;  1863 --              mov qword[rcx+16],0
;  1864 --              mov rcx,2
;  1865 --              pop rdx
;  1866 --              add rsp,24
;  1867 --          []
;  1868 --              mov al,32
;  1869 --              jmp :!iDiag
;  1870 --              int3
;  1871 --              nop
;  1872       ::internalerror
;  1873         int3
                int3                      ;#00441B22: 314                        np 00 00 13 305      
;  1874         nop
                nop                       ;#00441B23: 220                        uv 00 00  1 318      
;  1875       ::invalidmemoryrequest
;  1876         int3
                int3                      ;#00441B24: 314                        np 00 00 13 319      
;  1877         nop
                nop                       ;#00441B25: 220                        uv 00 00  1 332      
;  1878 --    ::memoryallocationfailure     -- e77phroom?
;  1879 --      int3
;  1880 --      nop
;  1881       ::deallocerrunknowntype
;  1882         [32]
;  1883             mov edx,[esp+4]
;  1884             mov al,32
;  1885             sub edx,1
;  1886             mov edi,edx
;  1887         [64]
;  1888             mov rdx,[rsp+8]
                    mov rdx,[rsp+8]       ;#00441B26: 48:213124044 08            vu 04 10  1 332      
;  1889             mov al,32
                    mov al,32             ;#00441B2B: 260 20                     uv 01 00  1 333      
;  1890             sub rdx,1
                    sub rdx,1             ;#00441B2D: 48:203352 01               vu 04 04  1 333      
;  1891             mov rdi,rdx
                    mov rdi,rdx           ;#00441B31: 48:213372                  uv 80 04  1 334      
;  1892         []
;  1893             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00441B34: 351 2D130000               v  00 00  1 334      
;  1894             int3
                    int3                  ;#00441B39: 314                        np 00 00 13 335      
;  1895         nop
                nop                       ;#00441B3A: 220                        uv 00 00  1 348      
;  1896       ::notCCB
;  1897         int3
                int3                      ;#00441B3B: 314                        np 00 00 13 349      
;  1898         nop
                nop                       ;#00441B3C: 220                        uv 00 00  1 362      
;  1899       ::notECB
;  1900         int3
                int3                      ;#00441B3D: 314                        np 00 00 13 363      
;  1901         nop
                nop                       ;#00441B3E: 220                        uv 00 00  1 376      
;  1902       ::notSBH
;  1903         int3
                int3                      ;#00441B3F: 314                        np 00 00 13 377      
;  1904         nop
                nop                       ;#00441B40: 220                        uv 00 00  1 390      
;  1905 --    ::notTCB
;  1906 --      int3
;  1907 --      nop
;  1908 --    ::notb01
;  1909 --      int3
;  1910 --      nop
;  1911       ::sizeErr
;  1912         int3
                int3                      ;#00441B41: 314                        np 00 00 13 391      
;  1913         nop
                nop                       ;#00441B42: 220                        uv 00 00  1 404      
;  1914       ::pfreeidxnz
;  1915         int3
                int3                      ;#00441B43: 314                        np 00 00 13 405      
;  1916         nop
                nop                       ;#00441B44: 220                        uv 00 00  1 418      
;  1917       ::listheadz
;  1918         int3
                int3                      ;#00441B45: 314                        np 00 00 13 419      
;  1919         nop
                nop                       ;#00441B46: 220                        uv 00 00  1 432      
;  1920       ::idxlz
;  1921         -- [DEV] improve this...
;  1922 --      jmp :%e02atdb0
;  1923         int3
                int3                      ;#00441B47: 314                        np 00 00 13 433      
;  1924         nop
                nop                       ;#00441B48: 220                        uv 00 00  1 446      
;  1925       ::e37atambpi
;  1926         int3
                int3                      ;#00441B49: 314                        np 00 00 13 447      
;  1927         nop
                nop                       ;#00441B4A: 220                        uv 00 00  1 460      
;  1928       ::e38atfmba   -- argument to free must be an atom
;  1929         int3
                int3                      ;#00441B4B: 314                        np 00 00 13 461      
;  1930         nop
                nop                       ;#00441B4C: 220                        uv 00 00  1 474      
;  1931 
;  1932 --/*
;  1933 procedure :%pGetPool(:%)
;  1934 end procedure -- (for Edita/CtrlQ)
;  1935 --*/
;  1936     :%pGetPool
;  1937 --------------
;  1938     [32]
;  1939         -- on entry ecx is the required length (in bytes, including any headers)
;  1940         --          edx is <era>
;  1941         -- on exit, edx is the allocated size and eax is the raw pointer, and
;  1942         --          all other registers are trashed.
;  1943         -- the returned memory is left filled with whatever garbage was there.
;  1944         -- can return 0 (which should be fatal for everything except allocate())
;  1945 sub edx,1
;  1946         push edx    -- [0] era
;  1947         push ecx    -- [1] save required size
;  1948         xor ebx,ebx -- (save some grief)
;  1949         call :pGetThread
;  1950         push eax    -- [2] save thread id
;  1951         mov esi,[pGtcb]
;  1952         test esi,esi
;  1953     [64]
;  1954         -- on entry rcx is the required length (in bytes, including any headers)
;  1955         --          rdx is <era>
;  1956         -- on exit, rdx is the allocated size and rax is the raw pointer, and
;  1957         --          all other registers are trashed.
;  1958         -- the returned memory is left filled with whatever garbage was there.
;  1959         -- can return 0 (which should be fatal for everything except allocate())
;  1960         sub rsp,8*11    -- minimum shadow space plus align/temp stores:
                sub rsp,88                ;#00441B4D: 48:203354 58               vu 10 10  1 474      
;  1961                         -- [rsp+0/8/16/24] shadow space <no longer rqd/used>
;  1962                         -- [rsp]    temp result     \
;  1963                         -- [rsp+8]  unused           \  ( recent
;  1964                         -- [rsp+16] asize (>8K)      /   additions)
;  1965                         -- [rsp+24] idx*8 for ""    /
;  1966                         -- [rsp+32] [1]required size
;  1967                         -- [rsp+40] lpCriticalSection
;  1968                         -- [rsp+48] [2]dwThreadId
;  1969                         -- [rsp+56] idx*8
;  1970                         -- [rsp+64] pTCB/4
;  1971                         -- [rsp+72] rqd size, rounded up (<2*[1])
;  1972                         -- [rsp+80] <era>
;  1973         xor rbx,rbx     -- (save some grief)
                xor rbx,rbx               ;#00441B51: 48:061333                  uv 08 08  1 475      
;  1974         mov [rsp+80],rdx    -- [0] era
                mov [rsp+80],rdx          ;#00441B54: 48:211124044 50            uv 00 14  1 477    *10*
;  1975         mov [rsp+32],rcx    -- [1] save required size
                mov [rsp+32],rcx          ;#00441B59: 48:211114044 20            vu 00 12  1 477      
;  1976         call :pGetThread
                call #004417E3            ;#00441B5E: 350 80FCFFFF               v  00 00  1 478      
;  1977         mov [rsp+48],eax    -- [2] save thread id
                mov [rsp+48],eax          ;#00441B63: 211104044 30               uv 00 11  1 479      
;  1978         mov rsi,[pGtcb]
                mov rsi,[#00402F08] (pGtcb)  ;#00441B67: 48:213065 9A13FCFF         vu 40 00  1 479      
;  1979         test rsi,rsi
                test rsi,rsi              ;#00441B6E: 48:205366                  uv 00 40  1 480      
;  1980     []
;  1981         jnz @f
                jnz #00441BF1             ;#00441B71: 165 7E                     v  00 00  1 480      
;  1982             -- create a thread control block for the global pool...
;  1983             call :newtcb                -- (edi/rdi := pTCB/4)
                    call #0044184F        ;#00441B73: 350 D7FCFFFF               v  00 00  1 481      
;  1984     [32]
;  1985             mov dword[ebx+edi*4+16],-4  -- nStatus (global pool)
;  1986             mov [pGtcb],edi
;  1987     [64]
;  1988             mov qword[rbx+rdi*4+24],-4  -- nStatus (global pool)
                    mov qword[rbx+rdi*4+24],-4  ;#00441B78: 48:307104273 18 FCFFFFFF   uv 00 88  1 482      
;  1989             mov [pGtcb],rdi
                    mov [#00402F08] (pGtcb),rdi  ;#00441B81: 48:211075 8013FCFF         vu 00 80  1 482      
;  1990     []
;  1991           ::newcttcb
;  1992             -- ...and one for the current thread
;  1993     [32]
;  1994             mov ecx,[pGtcb]
;  1995             shl ecx,2
;  1996             add ecx,240     -- csLock
;  1997             cmp dword[ecx-4],#00424343      -- dwMagicC ("CCB\0")
;  1998             jne :notCCB
;  1999             cmp dword[ecx+24],#00424345     -- dwMagicE ("ECB\0")
;  2000             jne :notECB
;  2001             push ecx                        -- lpCriticalSection/csLock (for Leave)
;  2002     [64]
;  2003             mov rcx,[pGtcb]
                    mov rcx,[#00402F08] (pGtcb)  ;#00441B88: 48:213015 7913FCFF         uv 02 00  1 483      
;  2004             shl rcx,2
                    shl rcx,2             ;#00441B8F: 48:301341 02               u  02 02  1 484      
;  2005             add rcx,968     -- csLock
                    add rcx,968           ;#00441B93: 48:201301 C8030000         uv 02 02  1 485 02   
;  2006             cmp dword[rcx-8],#00424342      -- dwMagicE ("BCB\0")
                    cmp dword[rcx-8],#00424342  ;#00441B9A: 201171 F8 42434200         u  00 02  2 488    *02*
;  2007             jne :notCCB
                    jne #00441B3B         ;#00441BA1: 165 98                     v  00 00  1 489      
;  2008             cmp dword[rcx-4],#00424343      -- dwMagicC ("CCB\0")
                    cmp dword[rcx-4],#00424343  ;#00441BA3: 201171 FC 43434200         u  00 02  2 490      
;  2009             jne :notCCB
                    jne #00441B3B         ;#00441BAA: 165 8F                     v  00 00  1 491      
;  2010             cmp dword[rcx+40],#00424345     -- dwMagicE ("ECB\0")
                    cmp dword[rcx+40],#00424345  ;#00441BAC: 201171 28 45434200         u  00 02  2 492      
;  2011             jne :notECB
                    jne #00441B3D         ;#00441BB3: 165 88                     v  00 00  1 493      
;  2012             mov [rsp+40],rcx            -- save lpCriticalSection/csLock (for Leave)
                    mov [rsp+40],rcx      ;#00441BB5: 48:211114044 28            uv 00 12  1 494      
;  2013     []
;  2014             call :EnterCriticalSection
                    call #004417FE        ;#00441BBA: 350 3FFCFFFF               v  00 00  1 494      
;  2015             call :newtcb                -- (edi/rdi := pTCB/4)
                    call #0044184F        ;#00441BBF: 350 8BFCFFFF               v  00 00  1 495      
;  2016     [32]
;  2017             mov esi,edi
;  2018             mov edi,[pGtcb]
;  2019             mov eax,[esp+4]             -- [2] thread id
;  2020             mov edx,[ebx+edi*4+8]       -- edx:=pGtcb.pNxtcb
;  2021 --          mov [gt1tcb],edx            -- (save for pGetStdCS)
;  2022             mov [ebx+esi*4+8],edx       -- new.pNxtcb:=edx
;  2023             mov [ebx+esi*4+4],eax       -- new.dwThreadId:=eax
;  2024             mov [ebx+edi*4+8],esi       -- pGtcb.pNxtcb:=new
;  2025             pop ecx                     -- lpCriticalSection/csLock
;  2026     [64]
;  2027             mov rsi,rdi
                    mov rsi,rdi           ;#00441BC4: 48:213367                  uv 40 80  1 496      
;  2028             mov rdi,[pGtcb]
                    mov rdi,[#00402F08] (pGtcb)  ;#00441BC7: 48:213075 3A13FCFF         vu 80 00  1 496      
;  2029             mov eax,dword[rsp+48]       -- [2] thread id
                    mov eax,[rsp+48]      ;#00441BCE: 213104044 30               uv 01 10  1 497      
;  2030             mov rdx,[rbx+rdi*4+8]       -- rdx:=pGtcb.pNxtcb
                    mov rdx,[rbx+rdi*4+8]  ;#00441BD2: 48:213124273 08            uv 04 88  1 499    *80*
;  2031 --          mov [gt1tcb],rdx            -- (save for pGetStdCS)
;  2032             mov [rbx+rsi*4+8],rdx       -- new.pNxtcb:=rdx
                    mov [rbx+rsi*4+8],rdx  ;#00441BD7: 48:211124263 08            uv 00 4C  1 500 04   
;  2033             mov [rbx+rsi*4+4],eax       -- new.dwThreadId:=eax
                    mov [rbx+rsi*4+4],eax  ;#00441BDC: 211104263 04               vu 00 49  1 500      
;  2034             mov [rbx+rdi*4+8],rsi       -- pGtcb.pNxtcb:=new
                    mov [rbx+rdi*4+8],rsi  ;#00441BE0: 48:211164273 08            uv 00 C8  1 501      
;  2035             mov rcx,[rsp+40]            -- lpCriticalSection/csLock
                    mov rcx,[rsp+40]      ;#00441BE5: 48:213114044 28            vu 02 10  1 501      
;  2036     []  
;  2037             call :LeaveCriticalSection
                    call #00441834        ;#00441BEA: 350 45FCFFFF               v  00 00  1 502      
;  2038             jmp :tcbfound
                    jmp #00441C0B         ;#00441BEF: 353 1A                     v  00 00  1 503      
;  2039 
;  2040       @@:
;  2041     [32]
;  2042         mov esi,dword[ebx+esi*4+8]          -- tcb:=tcb.pNxtcb
;  2043         test esi,esi
;  2044         jz :newcttcb
;  2045       :!GetPoolnotTCBa  -- era @ [esp+8]
;  2046         cmp dword[ebx+esi*4],#00424354      -- dwMagicT ("TCB\0")
;  2047 --      jne :memorycorruption
;  2048         je :tcbmagicok
;  2049             int3
;  2050       ::tcbmagicok
;  2051         cmp dword[ebx+esi*4+4],eax          -- dwThreadId
;  2052     [64]
;  2053         mov rsi,qword[rbx+rsi*4+8]          -- tcb:=tcb.pNxtcb
                mov rsi,[rbx+rsi*4+8]     ;#00441BF1: 48:213164263 08            uv 40 48  1 504      
;  2054         test rsi,rsi
                test rsi,rsi              ;#00441BF6: 48:205366                  uv 00 40  1 505 40   
;  2055         jz :newcttcb
                jz #00441B88              ;#00441BF9: 164 8D                     v  00 00  1 505      
;  2056       :!GetPoolnotTCBa  -- era @ [rsp+80]
;  2057         cmp dword[rbx+rsi*4],#00424354      -- dwMagicT ("TCB\0")
                cmp dword[rbx+rsi*4],#00424354  ;#00441BFB: 201074263 54434200         uv 00 48  2 506      
;  2058 --      jne :memorycorruption
;  2059         je :tcbmagicok
                je #00441C05              ;#00441C02: 164 01                     v  00 00  1 507      
;  2060             int3
                    int3                  ;#00441C04: 314                        np 00 00 13 508      
;  2061       ::tcbmagicok
;  2062         cmp dword[rbx+rsi*4+4],eax          -- dwThreadId
                cmp [rbx+rsi*4+4],eax     ;#00441C05: 071104263 04               uv 00 49  2 521      
;  2063     []
;  2064         jne @b
                jne #00441BF1             ;#00441C09: 165 E6                     v  00 00  1 522      
;  2065 
;  2066       ::tcbfound
;  2067     [32]
;  2068         pop eax         -- [2] discard the ThreadId
;  2069         pop ecx         -- [1] restore rqd size
;  2070         -- esi contains pTCB/4, stack is now empty
;  2071         push esi        -- [1] pTCB/4
;  2072         -- figure out the required size
;  2073         cmp ecx,#50000000
;  2074         ja :invalidmemoryrequest
;  2075 --pHeapD:
;  2076 --<     add ecx,4       -- add space for pRoot
;  2077         add ecx,8       -- add space for pRoot + era
;  2078 --<     mov edx,20      -- size
;  2079         mov edx,24      -- size
;  2080         mov edi,0       -- idx*4
;  2081       @@:
;  2082         cmp edx,ecx
;  2083         jge @f
;  2084             add edx,edx
;  2085             add edi,4
;  2086             jmp @b
;  2087       @@:
;  2088         push edi        -- [2] save idx(*4)
;  2089         push edx        -- [3] save rqd size, rounded up
;  2090     [64]
;  2091         mov rcx,[rsp+32]    -- [1?] restore required size
                mov rcx,[rsp+32]          ;#00441C0B: 48:213114044 20            uv 02 10  1 523      
;  2092         mov [rsp+64],rsi    -- pTCB/4
                mov [rsp+64],rsi          ;#00441C10: 48:211164044 40            vu 00 50  1 523      
;  2093         -- figure out the required size
;  2094 --      mov rdx,#5000000000000000
;  2095         mov rdx,#50000000 --00000000
                mov rdx,1342177280        ;#00441C15: 48:307302 00000050         uv 04 00  1 524      
;  2096         shl rdx,32
                shl rdx,32                ;#00441C1C: 48:301342 20               u  04 04  1 525      
;  2097         cmp rcx,rdx
                cmp rcx,rdx               ;#00441C20: 48:071321                  uv 00 06  1 526 04   
;  2098         ja :invalidmemoryrequest
                ja #00441B24              ;#00441C23: 017207 FBFEFFFF            v  00 00  1 526      
;  2099 --pHeapD:
;  2100 --<     add rcx,8       -- add space for pRoot
;  2101         add rcx,16      -- add space for pRoot + era
                add rcx,16                ;#00441C29: 48:203301 10               uv 02 02  1 527      
;  2102 --pHeapD:
;  2103 --<     mov rdx,36      -- size
;  2104         mov rdx,44      -- size
                mov rdx,44                ;#00441C2D: 48:307302 2C000000         vu 04 00  1 527      
;  2105         mov rdi,0       -- idx*8
                mov rdi,0                 ;#00441C34: 48:307307 00000000         uv 80 00  1 528      
;  2106       @@:
;  2107         cmp rdx,rcx
                cmp rdx,rcx               ;#00441C3B: 48:071312                  vu 00 06  1 528      
;  2108         jge @f
                jge #00441C49             ;#00441C3E: 175 09                     v  00 00  1 529      
;  2109             add rdx,rdx
                    add rdx,rdx           ;#00441C40: 48:001322                  uv 04 04  1 530      
;  2110             add rdi,8
                    add rdi,8             ;#00441C43: 48:203307 08               vu 80 80  1 530      
;  2111             jmp @b
                    jmp #00441C3B         ;#00441C47: 353 F2                     v  00 00  1 531      
;  2112       @@:
;  2113         mov [rsp+56],rdi    -- [2?] save idx(*8)
                mov [rsp+56],rdi          ;#00441C49: 48:211174044 38            uv 00 90  1 532      
;  2114         mov [rsp+72],rdx    -- [3?] save rqd size, rounded up
                mov [rsp+72],rdx          ;#00441C4E: 48:211124044 48            vu 00 14  1 532      
;  2115     []
;  2116         -- now look for an available block of >= rqd size
;  2117       ::gpchecknext
;  2118     [32]
;  2119         mov eax,[esi*4+edi+20]  -- pTCB.pFree[idx]
;  2120         test eax,eax
;  2121         jnz :!blockfound
;  2122         mov eax,[esi*4+edi+128] -- pTCB.pNofl[idx]
;  2123         test eax,eax
;  2124         jnz :retakeownership
;  2125         add edx,edx
;  2126         add edi,4
;  2127         cmp edi,108 -- (=27*4)
;  2128         jl :gpchecknext
;  2129         -- nothing suitable, get a fresh block.
;  2130         -- first: process any orphaned blocks (ie merge and shift what we can into the global pool)
;  2131 --      pushad -- (not entirely sure what we think we are preserving here...)
;  2132                 -- eax=0, edi=108, edx=#A0000000, esi is pTCB/4, which is already pushed and not used again, ecx is done with (size+4)
;  2133         mov esi,[pGtcb]
;  2134       @@:
;  2135         mov esi,[ebx+esi*4+8]           -- pNxtcb
;  2136         test esi,esi
;  2137         jz @f
;  2138             cmp dword[ebx+esi*4+16],-2  -- nStatus (orphaned?)
;  2139             jne @b
;  2140             lea edx,[ebx+esi*4+240]     -- csLock
;  2141             push edx            -- [?8]                 -- lpCriticalSection (for Leave)
;  2142             mov ecx,edx
;  2143             call :EnterCriticalSection
;  2144             cmp dword[ebx+esi*4+16],-2  -- nStatus (orphaned?)
;  2145             jne :someonelsedidit
;  2146                 -- (aside: the biggest worry here and what really warrants the above recheck
;  2147                 --          would be that while we waited it could have been processed /and/ 
;  2148                 --          then reused for a new thread, which is happily using it *right
;  2149                 --          now*, without any locking whatsoever. Just saying, in case you 
;  2150                 --          were thinking "it don't matter if we call scan_orphans twice"...
;  2151                 --          and you'd be quite right, as long as it wasn't /in/ re-use.
;  2152                 --          Of course, it /might/ have been scanned, re-used, and by now
;  2153                 --          re-orphaned (-2), but that's no problem. Anyway, sorry to panic
;  2154                 --          you over - OMG - 7 bytes and/or 1 clock, but we need it!)
;  2155             call :scan_orphans
;  2156           ::someonelsedidit
;  2157             pop ecx                     -- lpCriticalSection/csLock
;  2158             call :LeaveCriticalSection
;  2159     [64]
;  2160         mov rax,[rsi*4+rdi+32]  -- pTCB.pFree[idx]
                mov rax,[rdi+rsi*4+32]    ;#00441C53: 48:213104267 20            uv 01 C0  1 533      
;  2161         test rax,rax
                test rax,rax              ;#00441C58: 48:205300                  uv 00 01  1 534 01   
;  2162         jnz :!blockfound
                jnz #00441F45 (:!blockfound)  ;#00441C5B: 017205 E4020000            v  00 00  1 534      
;  2163         mov rax,[rsi*4+rdi+496] -- pTCB.pNofl[idx]
                mov rax,[rdi+rsi*4+496]   ;#00441C61: 48:213204267 F0010000      uv 01 C0  1 535      
;  2164         test rax,rax
                test rax,rax              ;#00441C69: 48:205300                  uv 00 01  1 536 01   
;  2165         jnz :retakeownership
                jnz #00441E87             ;#00441C6C: 017205 15020000            v  00 00  1 536      
;  2166         add rdx,rdx
                add rdx,rdx               ;#00441C72: 48:001322                  uv 04 04  1 537      
;  2167         add rdi,8
                add rdi,8                 ;#00441C75: 48:203307 08               vu 80 80  1 537      
;  2168 --      cmp edi,108 -- (=27*4)
;  2169         cmp rdi,464 -- (=58*8)
                cmp rdi,464               ;#00441C79: 48:201377 D0010000         uv 00 80  1 538      
;  2170         jl :gpchecknext
                jl #00441C53              ;#00441C80: 174 D1                     v  00 00  1 538      
;  2171         -- nothing suitable, get a fresh block.
;  2172         -- first: process any orphaned blocks (ie merge and shift what we can into the global pool)
;  2173         mov rsi,[pGtcb]
                mov rsi,[#00402F08] (pGtcb)  ;#00441C82: 48:213065 7F12FCFF         uv 40 00  1 539      
;  2174       @@:
;  2175         mov rsi,[rbx+rsi*4+8]           -- pNxtcb
                mov rsi,[rbx+rsi*4+8]     ;#00441C89: 48:213164263 08            uv 40 48  1 542 40 *40*
;  2176         test rsi,rsi
                test rsi,rsi              ;#00441C8E: 48:205366                  uv 00 40  1 543 40   
;  2177         jz @f
                jz #00441CC4              ;#00441C91: 164 31                     v  00 00  1 543      
;  2178             cmp dword[rbx+rsi*4+24],-2  -- nStatus (orphaned?)
                    cmp dword[rbx+rsi*4+24],-2  ;#00441C93: 203174263 18 FE            u  00 48  2 544      
;  2179             jne @b
                    jne #00441C89         ;#00441C98: 165 EF                     v  00 00  1 545      
;  2180             lea rcx,[rbx+rsi*4+968]     -- csLock
                    lea rcx,[rbx+rsi*4+968]  ;#00441C9A: 48:215214263 C8030000      uv 02 48  1 546      
;  2181             mov [rsp+40],rcx            -- save lpCriticalSection (for Leave)
                    mov [rsp+40],rcx      ;#00441CA2: 48:211114044 28            uv 00 12  1 547 02   
;  2182             call :EnterCriticalSection
                    call #004417FE        ;#00441CA7: 350 52FBFFFF               v  00 00  1 547      
;  2183             cmp dword[rbx+rsi*4+24],-2  -- nStatus (orphaned?)
                    cmp dword[rbx+rsi*4+24],-2  ;#00441CAC: 203174263 18 FE            u  00 48  2 548      
;  2184             jne :someonelsedidit
                    jne #00441CB8         ;#00441CB1: 165 05                     v  00 00  1 549      
;  2185                 -- (notes as per 32 bit)
;  2186             call :scan_orphans
                    call #00441AC0        ;#00441CB3: 350 08FEFFFF               v  00 00  1 550      
;  2187           ::someonelsedidit
;  2188             mov rcx,[rsp+40]            -- lpCriticalSection/csLock
                    mov rcx,[rsp+40]      ;#00441CB8: 48:213114044 28            uv 02 10  1 551      
;  2189             call :LeaveCriticalSection
                    call #00441834        ;#00441CBD: 350 72FBFFFF               v  00 00  1 551      
;  2190     []
;  2191             jmp @b
                    jmp #00441C89         ;#00441CC2: 353 C5                     v  00 00  1 552      
;  2192       @@:
;  2193         -- now check whether something in the global pool will satify our needs:
;  2194     [32]
;  2195         mov esi,[pGtcb]
;  2196         mov edi,[esp+4]     -- [2] idx*4
;  2197         mov edx,[esp]       -- [3] rqd size
;  2198     [64]
;  2199         mov rsi,[pGtcb]
                mov rsi,[#00402F08] (pGtcb)  ;#00441CC4: 48:213065 3D12FCFF         uv 40 00  1 553      
;  2200         mov rdi,[rsp+56]    -- [2?] idx*8
                mov rdi,[rsp+56]          ;#00441CCB: 48:213174044 38            vu 80 10  1 553      
;  2201         mov rdx,[rsp+72]    -- [3?] rqd size (rounded up)
                mov rdx,[rsp+72]          ;#00441CD0: 48:213124044 48            uv 04 10  1 554      
;  2202     []
;  2203       ::gpchecknextgpool
;  2204     [32]
;  2205         cmp dword[esi*4+edi+20],0   -- pGtb.pFree[idx]
;  2206     [64]
;  2207         cmp qword[rsi*4+rdi+32],0   -- pGtb.pFree[idx]
                cmp qword[rdi+rsi*4+32],0  ;#00441CD5: 48:203174267 20 00         u  00 C0  2 556    *C0*
;  2208     []
;  2209         je :gpentryempty
                je #00441D91              ;#00441CDB: 017204 B0000000            v  00 00  1 557      
;  2210     [32]
;  2211             push edx        -- [4] temp save (size)
;  2212             push ebx        -- [5] temp result
;  2213             lea ecx,[ebx+esi*4+240]             -- pGtcb.csLock
;  2214             cmp dword[ebx+esi*4+236],#00424343  -- dwMagicC ("CCB\0")
;  2215             jne :notCCB
;  2216             cmp dword[ecx+24],#00424345         -- dwMagicE ("ECB\0")
;  2217             jne :notECB
;  2218             push ecx                            -- save lpCriticalSection (for Leave)
;  2219             call :EnterCriticalSection
;  2220     [64]
;  2221 --DEV use [rsp+16], [rsp] instead:
;  2222 --          mov r14,rdx     -- temp save (size)
;  2223 --          mov r13,rbx     -- temp result
;  2224             mov [rsp+16],rdx    -- temp save (size)
                    mov [rsp+16],rdx      ;#00441CE1: 48:211124044 10            uv 00 14  1 558      
;  2225             mov [rsp],rbx       -- temp result
                    mov [rsp],rbx         ;#00441CE6: 48:211034044               vu 00 18  1 558      
;  2226             lea rcx,[rbx+rsi*4+968]     -- pGtcb.csLock
                    lea rcx,[rbx+rsi*4+968]  ;#00441CEA: 48:215214263 C8030000      uv 02 48  1 559      
;  2227             cmp dword[rbx+rsi*4+960],#00424342  -- dwMagicB ("BCB\0")
                    cmp dword[rbx+rsi*4+960],#00424342  ;#00441CF2: 201274263 C0030000 42434200 u  00 48  2 560      
;  2228             jne :notCCB
                    jne #00441B3B         ;#00441CFD: 017205 38FEFFFF            v  00 00  1 561      
;  2229             cmp dword[rbx+rsi*4+964],#00424343  -- dwMagicC ("CCB\0")
                    cmp dword[rbx+rsi*4+964],#00424343  ;#00441D03: 201274263 C4030000 43434200 u  00 48  2 562      
;  2230             jne :notCCB
                    jne #00441B3B         ;#00441D0E: 017205 27FEFFFF            v  00 00  1 563      
;  2231             cmp dword[rcx+40],#00424345         -- dwMagicE ("ECB\0")
                    cmp dword[rcx+40],#00424345  ;#00441D14: 201171 28 45434200         u  00 02  2 564      
;  2232             jne :notECB
                    jne #00441B3D         ;#00441D1B: 017205 1CFEFFFF            v  00 00  1 565      
;  2233             mov [rsp+40],rcx                    -- save lpCriticalSection (for Leave)
                    mov [rsp+40],rcx      ;#00441D21: 48:211114044 28            uv 00 12  1 566      
;  2234             call :EnterCriticalSection
                    call #004417FE        ;#00441D26: 350 D3FAFFFF               v  00 00  1 566      
;  2235     [32]
;  2236             mov eax,[esi*4+edi+20]      -- recheck (pGtb.pFree[idx])
;  2237             test eax,eax
;  2238     [64]
;  2239             mov rax,[rsi*4+rdi+32]      -- recheck (pGtb.pFree[idx])
                    mov rax,[rdi+rsi*4+32]  ;#00441D2B: 48:213104267 20            uv 01 C0  1 567      
;  2240             test rax,rax
                    test rax,rax          ;#00441D30: 48:205300                  uv 00 01  1 568 01   
;  2241     []
;  2242             jz :gpentrystolen
                    jz #00441D42          ;#00441D33: 164 0D                     v  00 00  1 568      
;  2243     [32]
;  2244 --DEV this was already +4?
;  2245                 mov ecx,[eax+4]         -- pNext
;  2246                 mov [esi*4+edi+20],ecx  -- pGtb.pFree[idx]
;  2247                 mov [esp+4],eax         -- stash result
;  2248     [64]
;  2249                 mov rcx,[rax+8]         -- pNext
                        mov rcx,[rax+8]   ;#00441D35: 48:213110 08               uv 02 01  1 569      
;  2250                 mov [rsi*4+rdi+32],rcx  -- pGtb.pFree[idx]
                        mov [rdi+rsi*4+32],rcx  ;#00441D39: 48:211114267 20            uv 00 C2  1 570 02   
;  2251 --              mov r13,rax             -- stash result
;  2252                 mov [rsp],rax           -- stash result
                        mov [rsp],rax     ;#00441D3E: 48:211004044               vu 00 11  1 570      
;  2253     []
;  2254           ::gpentrystolen
;  2255     [32]
;  2256             pop ecx                     -- lpCriticalSection/csLock
;  2257             call :LeaveCriticalSection
;  2258             pop eax         -- [5] result or null
;  2259             pop edx         -- [4] restore (size)
;  2260             test eax,eax
;  2261             jz :gpentryempty
;  2262             -- perform some quick sanity checks:
;  2263 --pHeapD:
;  2264 --          lea esi,[eax-24]    -- start of superblock
;  2265             lea esi,[eax-28]    -- start of superblock
;  2266             mov ecx,[eax-4]     -- pRoot...
;  2267             test ecx,0b01       -- .. should have 0b01 set
;  2268 --          jz :notb01
;  2269             jnz @f
;  2270                 int3
;  2271           @@:
;  2272             sub ecx,1
;  2273             cmp esi,ecx         -- ...but otherwise equal eax-28
;  2274 --          jnz :notb01
;  2275             jz @f
;  2276                 int3
;  2277           @@:
;  2278             cmp dword[esi],#00484253 -- dwMagic ("SBH\0")
;  2279             jne :notSBH
;  2280             cmp dword[esi+8],edx    -- and pSBH.nsbSize should match
;  2281             jne :sizeErr
;  2282             push edx            -- ([4]), size (as expected at gpgotfromgpool)
;  2283     [64]
;  2284             mov rcx,[rsp+40]            -- lpCriticalSection/csLock
                    mov rcx,[rsp+40]      ;#00441D42: 48:213114044 28            uv 02 10  1 571      
;  2285             call :LeaveCriticalSection
                    call #00441834        ;#00441D47: 350 E8FAFFFF               v  00 00  1 571      
;  2286 --          mov rax,r13     -- result or null
;  2287 --          mov rdx,r14     -- restore (size)
;  2288             mov rax,[rsp]       -- result or null
                    mov rax,[rsp]         ;#00441D4C: 48:213004044               uv 01 10  1 572      
;  2289             mov rdx,[rsp+16]    -- restore (size)
                    mov rdx,[rsp+16]      ;#00441D50: 48:213124044 10            vu 04 10  1 572      
;  2290             test rax,rax
                    test rax,rax          ;#00441D55: 48:205300                  uv 00 01  1 573      
;  2291             jz :gpentryempty
                    jz #00441D91          ;#00441D58: 164 37                     v  00 00  1 573      
;  2292             -- perform some quick sanity checks:
;  2293 --pHeapD:
;  2294 --<         lea rsi,[rax-40]    -- start of superblock
;  2295             lea rsi,[rax-48]    -- start of superblock
                    lea rsi,[rax-48]      ;#00441D5A: 48:215160 D0               uv 40 01  1 574      
;  2296             mov rcx,[rax-8]     -- pRoot...
                    mov rcx,[rax-8]       ;#00441D5E: 48:213110 F8               vu 02 01  1 574      
;  2297             test rcx,0b01       -- .. should have 0b01 set
                    test rcx,1            ;#00441D62: 48:367301 01000000         uv 00 02  1 575      
;  2298 --          jz :notb01
;  2299             jnz @f
                    jnz #00441D6C         ;#00441D69: 165 01                     v  00 00  1 575      
;  2300                 int3
                        int3              ;#00441D6B: 314                        np 00 00 13 576      
;  2301           @@:
;  2302             sub rcx,1
                    sub rcx,1             ;#00441D6C: 48:203351 01               uv 02 02  1 589      
;  2303             cmp rsi,rcx         -- ...but otherwise equal rax-48
                    cmp rsi,rcx           ;#00441D70: 48:071316                  uv 00 42  1 590 02   
;  2304 --          jnz :notb01
;  2305             jz @f
                    jz #00441D76          ;#00441D73: 164 01                     v  00 00  1 590      
;  2306                 int3
                        int3              ;#00441D75: 314                        np 00 00 13 591      
;  2307           @@:
;  2308             cmp dword[rsi],#00484253 -- dwMagic ("SBH\0")
                    cmp dword[rsi],4735571  ;#00441D76: 201076 53424800            uv 00 40  2 604      
;  2309             jne :notSBH
                    jne #00441B3F         ;#00441D7C: 017205 BDFDFFFF            v  00 00  1 605      
;  2310             cmp qword[rsi+8],rdx    -- and pSBH.nsbSize should match
                    cmp [rsi+8],rdx       ;#00441D82: 48:071126 08               uv 00 44  2 606      
;  2311             jne :sizeErr
                    jne #00441B41         ;#00441D86: 017205 B5FDFFFF            v  00 00  1 607      
;  2312 --          -- (gpgotfromgpool expects the size to be in r14)
;  2313             -- (gpgotfromgpool expects the size to be in [rsp+16])
;  2314 --          mov [rsp+16],r14
;  2315     []
;  2316             jmp :gpgotfromgpool -- (resets dwThreadId and pTCB)
                    jmp #00441E5A         ;#00441D8C: 351 C9000000               v  00 00  1 608      
;  2317 
;  2318       ::gpentryempty
;  2319     [32]
;  2320         add edx,edx
;  2321         add edi,4
;  2322         cmp edi,108 -- (=27*4)
;  2323     [64]
;  2324         add rdx,rdx
                add rdx,rdx               ;#00441D91: 48:001322                  uv 04 04  1 609      
;  2325         add rdi,8
                add rdi,8                 ;#00441D94: 48:203307 08               vu 80 80  1 609      
;  2326 --      cmp rdi,264 -- (=58*8)
;  2327         cmp rdi,464 -- (=58*8)
                cmp rdi,464               ;#00441D98: 48:201377 D0010000         uv 00 80  1 610      
;  2328     []
;  2329         jl :gpchecknextgpool
                jl #00441CD5              ;#00441D9F: 017214 30FFFFFF            v  00 00  1 610      
;  2330 
;  2331         -- nowt useful in the global pool, get some new memory then.
;  2332     [32]
;  2333         mov edi,[esp+4]     -- [2] idx*4
;  2334         mov eax,[esp]       -- [3] rqd size
;  2335 --      push esi            -- [4] save (tcb/4)
;  2336         cmp edi,36
;  2337         jae @f
;  2338             mov edi,36
;  2339             mov eax,12288   -- (block size[10])
;  2340     [64]
;  2341         mov rdi,[rsp+56]    -- [2?] idx*8
                mov rdi,[rsp+56]          ;#00441DA5: 48:213174044 38            uv 80 10  1 611      
;  2342         mov rax,[esp+72]    -- [3?] rqd size
                mov rax,[rsp+72]          ;#00441DAA: 48:213104044 48            vu 01 10  1 611      
;  2343         cmp rdi,64
                cmp rdi,64                ;#00441DAF: 48:203377 40               uv 00 80  1 612      
;  2344         jae @f
                jae #00441DC3             ;#00441DB3: 163 0E                     v  00 00  1 612      
;  2345             mov rdi,64
                    mov rdi,64            ;#00441DB5: 48:307307 40000000         uv 80 00  1 613      
;  2346 --          mov rax,8736
;  2347 --          mov rax,8704
;  2348 --pHeapD:
;  2349 --  [9]      11296[#00002C20]      11264[#00002C00]=8+8+11248*  x(11,215)       s[1,401]
;  2350 --  [9]       9248[#00002420]       9216[#00002400]=8+9208      x(9,175)        s[1,146]
;  2351 --<         mov rax,9216
;  2352             mov rax,11264
                    mov rax,11264         ;#00441DBC: 48:307300 002C0000         vu 01 00  1 613      
;  2353     []
;  2354       @@:
;  2355         -- create a new superblock and add it (under locking) to the pGtcb->pNxtcb chain
;  2356     [32]
;  2357         mov esi,[pGtcb]
;  2358         push eax                    -- [4] save size
;  2359         push edi                    -- [5] save (idx(*4))
;  2360         add eax,20                  -- sizeof(Superblock Header)
;  2361         lea ecx,[ebx+esi*4+240]     -- pTCB.csLock
;  2362         cmp dword[ebx+esi*4+236],#00424343  -- dwMagicC ("CCB\0")
;  2363         jne :notCCB
;  2364         cmp dword[ecx+24],#00424345         -- dwMagicE ("ECB\0")
;  2365         jne :notECB
;  2366         push eax                    -- [6] size/space for result
;  2367         push ecx                    -- save lpCriticalSection (for Leave)
;  2368         call :EnterCriticalSection
;  2369     [64]
;  2370         mov rsi,[pGtcb]
                mov rsi,[#00402F08] (pGtcb)  ;#00441DC3: 48:213065 3E11FCFF         uv 40 00  1 614      
;  2371 --DEV why not [rsp+56/72]? (oh, I think I know why... but instead why not two extra slots on rsp? 0/8/16/24 are all free!)
;  2372 --      mov r14,rax                 -- [4?] save size
;  2373 --      mov r12,rdi                 -- [5?] save (idx(*8))
;  2374         mov [rsp+16],rax            -- [4?] save size
                mov [rsp+16],rax          ;#00441DCA: 48:211104044 10            vu 00 11  1 614      
;  2375         mov [rsp+24],rdi            -- [5?] save (idx(*8))
                mov [rsp+24],rdi          ;#00441DCF: 48:211174044 18            uv 00 90  1 615      
;  2376 --      add rax,32                  -- sizeof(Superblock Header)
;  2377         lea rcx,[rbx+rsi*4+968]     -- pTCB.csLock
                lea rcx,[rbx+rsi*4+968]   ;#00441DD4: 48:215214263 C8030000      uv 02 48  1 617    *40*
;  2378         cmp dword[rbx+rsi*4+960],#00424342  -- dwMagicB ("BCB\0")
                cmp dword[rbx+rsi*4+960],#00424342  ;#00441DDC: 201274263 C0030000 42434200 u  00 48  2 618      
;  2379         jne :notCCB
                jne #00441B3B             ;#00441DE7: 017205 4EFDFFFF            v  00 00  1 619      
;  2380         cmp dword[rbx+rsi*4+964],#00424343  -- dwMagicC ("CCB\0")
                cmp dword[rbx+rsi*4+964],#00424343  ;#00441DED: 201274263 C4030000 43434200 u  00 48  2 620      
;  2381         jne :notCCB
                jne #00441B3B             ;#00441DF8: 017205 3DFDFFFF            v  00 00  1 621      
;  2382         cmp dword[rcx+40],#00424345         -- dwMagicE ("ECB\0")
                cmp dword[rcx+40],#00424345  ;#00441DFE: 201171 28 45434200         u  00 02  2 622      
;  2383         jne :notECB
                jne #00441B3D             ;#00441E05: 017205 32FDFFFF            v  00 00  1 623      
;  2384         mov [rsp+40],rcx            -- save lpCriticalSection (for Leave)
                mov [rsp+40],rcx          ;#00441E0B: 48:211114044 28            uv 00 12  1 624      
;  2385         call :EnterCriticalSection
                call #004417FE            ;#00441E10: 350 E9F9FFFF               v  00 00  1 624      
;  2386     [32]
;  2387         mov eax,[esp+4]             -- [6]
;  2388 --      add eax,20                  -- sizeof(Superblock Header)
;  2389         call :pGetMem
;  2390         test eax,eax
;  2391         jz @f
;  2392 --          add eax,4
;  2393             mov ecx,[ebx+esi*4+12]  -- tmp:=pGtcb.pFirst
;  2394             mov [eax+16],ecx        -- this.pNxtsb:=tmp
;  2395             mov [ebx+esi*4+12],eax  -- pGtcb.pFirst:=this
;  2396       @@:
;  2397         mov [esp+4],eax             -- [6] store result
;  2398 --      mov esi,eax
;  2399         pop ecx                     -- lpCriticalSection/csLock
;  2400         call :LeaveCriticalSection
;  2401     [64]
;  2402 --      mov rax,r14
;  2403         mov rax,[rsp+16]
                mov rax,[rsp+16]          ;#00441E15: 48:213104044 10            uv 01 10  1 625      
;  2404         add rax,32                  -- sizeof(Superblock Header)
                add rax,32                ;#00441E1A: 48:203300 20               uv 01 01  1 626 01   
;  2405         call :pGetMem
                call #004417B2            ;#00441E1E: 350 8FF9FFFF               v  00 00  1 626      
;  2406         test rax,rax
                test rax,rax              ;#00441E23: 48:205300                  uv 00 01  1 627      
;  2407         jz @f
                jz #00441E36              ;#00441E26: 164 0E                     v  00 00  1 627      
;  2408             mov rcx,[rbx+rsi*4+16]  -- tmp:=pGtcb.pFirst
                    mov rcx,[rbx+rsi*4+16]  ;#00441E28: 48:213114263 10            uv 02 48  1 628      
;  2409             mov [rax+24],rcx        -- this.pNxtsb:=tmp
                    mov [rax+24],rcx      ;#00441E2D: 48:211110 18               uv 00 03  1 629 02   
;  2410             mov [rbx+rsi*4+16],rax  -- pGtcb.pFirst:=this
                    mov [rbx+rsi*4+16],rax  ;#00441E31: 48:211104263 10            vu 00 49  1 629      
;  2411       @@:
;  2412 --      mov r13,rax                 -- save result
;  2413         mov [rsp],rax               -- save result
                mov [rsp],rax             ;#00441E36: 48:211004044               uv 00 11  1 630      
;  2414         mov rcx,[rsp+40]            -- lpCriticalSection/csLock
                mov rcx,[rsp+40]          ;#00441E3A: 48:213114044 28            vu 02 10  1 630      
;  2415         call :LeaveCriticalSection
                call #00441834            ;#00441E3F: 350 F0F9FFFF               v  00 00  1 631      
;  2416     [32]
;  2417         pop esi                     -- [6] result
;  2418         pop edi                     -- [5] restore (idx(*4))
;  2419         test esi,esi
;  2420         jnz :gpgotfromgpool
;  2421 --DEV eax:=0?? (added)
;  2422 --          add esp,16
;  2423             add esp,20              -- (now including era) [nb: pre-pHeapD, no change rqd here]
;  2424             xor eax,eax
;  2425             ret
;  2426     [64]
;  2427 --      mov rsi,r13                 -- result
;  2428         mov rsi,[rsp]               -- result
                mov rsi,[rsp]             ;#00441E44: 48:213064044               uv 40 10  1 632      
;  2429 --      mov rdi,r12                 -- [5?] restore (idx(*8))
;  2430         mov rdi,[rsp+24]            -- [5?] restore (idx(*8))
                mov rdi,[rsp+24]          ;#00441E48: 48:213174044 18            vu 80 10  1 632      
;  2431         test rsi,rsi
                test rsi,rsi              ;#00441E4D: 48:205366                  uv 00 40  1 633      
;  2432         jnz :gpgotfromgpool
                jnz #00441E5A             ;#00441E50: 165 08                     v  00 00  1 633      
;  2433 --DEV rax:=0?? (added)
;  2434             add rsp,8*11
                    add rsp,88            ;#00441E52: 48:203304 58               uv 10 10  1 634      
;  2435             xor rax,rax
                    xor rax,rax           ;#00441E56: 48:061300                  vu 01 01  1 634      
;  2436             ret
                    ret                   ;#00441E59: 303                        np 00 00  2 635      
;  2437         -- (size is (still) in r14) [erm, [rsp+16]?]
;  2438     []
;  2439 
;  2440 --/*
;  2441 procedure ::gpgotfromgpool(::)
;  2442 end procedure -- (for Edita/CtrlQ)
;  2443 --*/
;  2444       ::gpgotfromgpool
;  2445 ----------------------
;  2446         call :pGetThread
                call #004417E3            ;#00441E5A: 350 84F9FFFF               v  00 00  1 637      
;  2447     [32]
;  2448         pop edx             -- [4] size
;  2449         mov dword[esi],#00484253    -- dwMagic ("SBH\0")
;  2450         mov [esi+4],eax             -- dwThreadId
;  2451 --      mov eax,[esp]
;  2452         mov eax,[esp+8]             -- [1] pTCB/4
;  2453         mov [esi+8],edx             -- nsbSize
;  2454         mov [esi+12],eax            -- pTCB/4
;  2455 --pHeapD:?
;  2456 --<     mov [esi+20],esi            -- set pRoot
;  2457         mov [esi+24],esi            -- set pRoot
;  2458 --      ; eax,edi,edx should be set
;  2459 --pHeapD:
;  2460 --<     lea eax,[esi+24] -- hmm...
;  2461         lea eax,[esi+28] -- hmm...
;  2462 -- DEV is edx 4 too big?
;  2463     [64]
;  2464 --      mov rdx,r14                 -- [4?] size
;  2465         mov rdx,[rsp+16]            -- [4?] size
                mov rdx,[rsp+16]          ;#00441E5F: 48:213124044 10            uv 04 10  1 638      
;  2466         mov dword[rsi],#00484253    -- dwMagic ("SBH\0")
                mov [rsi], dword 4735571  ;#00441E64: 307006 53424800            vu 00 40  1 638      
;  2467         mov [rsi+4],eax             -- dwThreadId
                mov [esi+4],eax           ;#00441E6A: 211106 04                  uv 00 41  1 639      
;  2468         mov rax,[rsp+64]            -- pTCB/4
                mov rax,[rsp+64]          ;#00441E6D: 48:213104044 40            vu 01 10  1 639      
;  2469         mov [rsi+8],rdx             -- nsbSize
                mov [rsi+8],rdx           ;#00441E72: 48:211126 08               uv 00 44  1 640      
;  2470         mov [rsi+16],rax            -- set sbh.pTCB/4
                mov [rsi+16],rax          ;#00441E76: 48:211106 10               vu 00 41  1 640      
;  2471 --pHeapD:?
;  2472 --<     mov [rsi+32],rsi            -- set pRoot
;  2473         mov [rsi+40],rsi            -- set pRoot
                mov [rsi+40],rsi          ;#00441E7A: 48:211166 28               uv 00 40  1 641      
;  2474 --      ; rax,rdi,rdx should be set
;  2475 --pHeapD:
;  2476 --<     lea rax,[rsi+40] -- hmm...
;  2477         lea rax,[rsi+48] -- hmm...
                lea rax,[rsi+48]          ;#00441E7E: 48:215106 30               vu 01 40  1 641      
;  2478 -- DEV is rdx 8 too big?
;  2479     []
;  2480         jmp :blockdetached
                jmp #00441F82             ;#00441E82: 351 FB000000               v  00 00  1 642      
;  2481 
;  2482       ::retakeownership
;  2483     [32]
;  2484         push edi            -- [4] save (idx) (may be unnecessary)
;  2485         push edx            -- [5] save (block size)
;  2486         push ebx            -- [6] create space (list head)
;  2487         push esi            -- [7] save (pTCB/4)
;  2488         lea ecx,[ebx+esi*4+240]         -- csLock
;  2489         cmp dword[ebx+esi*4],#00424354  -- dwMagicT ("TCB\0")
;  2490 --      jne :notTCB
;  2491         je @f
;  2492             mov edx,[esp+16]
;  2493             mov edi,[esp+12]
;  2494             mov al,32                   -- e32hc(era,edi)
;  2495             sub edi,1
;  2496             jmp :!iDiag
;  2497             int3
;  2498       @@:
;  2499         cmp dword[ecx-4],#00424343      -- dwMagicC ("CCB\0")
;  2500         jne :notCCB
;  2501         cmp dword[ecx+24],#00424345     -- dwMagicE ("ECB\0")
;  2502         jne :notECB
;  2503         push ecx            -- [8]      -- save lpCriticalSection (for Leave)
;  2504         call :EnterCriticalSection
;  2505     [64]
;  2506         mov [rsp],rsi       -- [7] save pTCB/4
                mov [rsp],rsi             ;#00441E87: 48:211064044               uv 00 50  1 643      
;  2507         mov [rsp+8],rbx     -- [6] space for list head
                mov [rsp+8],rbx           ;#00441E8B: 48:211134044 08            vu 00 18  1 643      
;  2508         mov [rsp+16],rdx    -- [5] save block size
                mov [rsp+16],rdx          ;#00441E90: 48:211124044 10            uv 00 14  1 644      
;  2509         mov [rsp+24],rdi    -- [4] save idx*8
                mov [rsp+24],rdi          ;#00441E95: 48:211174044 18            vu 00 90  1 644      
;  2510 
;  2511         lea ecx,[rbx+rsi*4+968]         -- csLock
                lea ecx,[rbx+rsi*4+968]   ;#00441E9A: 215214263 C8030000         uv 02 48  1 645      
;  2512         cmp dword[rbx+rsi*4],#00424354  -- dwMagicT ("TCB\0")
                cmp dword[rbx+rsi*4],#00424354  ;#00441EA1: 201074263 54434200         vu 00 48  2 645      
;  2513 --      jne :notTCB
;  2514         je @f
                je #00441EC0              ;#00441EA8: 164 16                     v  00 00  1 646      
;  2515             mov rdx,[rsp+88]
                    mov rdx,[rsp+88]      ;#00441EAA: 48:213124044 58            uv 04 10  1 647      
;  2516             mov rdi,[rsp+80]
                    mov rdi,[rsp+80]      ;#00441EAF: 48:213174044 50            vu 80 10  1 647      
;  2517             mov al,32                   -- e32hc(era,edi)
                    mov al,32             ;#00441EB4: 260 20                     uv 01 00  1 648      
;  2518             sub rdi,1
                    sub rdi,1             ;#00441EB6: 48:203357 01               vu 80 80  1 648      
;  2519             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00441EBA: 351 A70F0000               v  00 00  1 649      
;  2520             int3
                    int3                  ;#00441EBF: 314                        np 00 00 13 650      
;  2521       @@:
;  2522         cmp dword[rcx-8],#00424342      -- dwMagicB ("BCB\0")
                cmp dword[rcx-8],#00424342  ;#00441EC0: 201171 F8 42434200         u  00 02  2 663      
;  2523         jne :notCCB
                jne #00441B3B             ;#00441EC7: 017205 6EFCFFFF            v  00 00  1 664      
;  2524         cmp dword[rcx-4],#00424343      -- dwMagicC ("CCB\0")
                cmp dword[rcx-4],#00424343  ;#00441ECD: 201171 FC 43434200         u  00 02  2 665      
;  2525         jne :notCCB
                jne #00441B3B             ;#00441ED4: 017205 61FCFFFF            v  00 00  1 666      
;  2526         cmp dword[rcx+40],#00424345     -- dwMagicE ("ECB\0")
                cmp dword[rcx+40],#00424345  ;#00441EDA: 201171 28 45434200         u  00 02  2 667      
;  2527         jne :notECB
                jne #00441B3D             ;#00441EE1: 017205 56FCFFFF            v  00 00  1 668      
;  2528         mov [rsp+40],rcx            -- save lpCriticalSection (for Leave)
                mov [rsp+40],rcx          ;#00441EE7: 48:211114044 28            uv 00 12  1 669      
;  2529         call :EnterCriticalSection
                call #004417FE            ;#00441EEC: 350 0DF9FFFF               v  00 00  1 669      
;  2530     [32]
;  2531         cmp dword[ebx+esi*4],#00424354      -- magic ("TCB\0")
;  2532 --      jne :notTCB
;  2533         je @f
;  2534             int3
;  2535       @@:
;  2536         mov eax,[esi*4+edi+128]     -- grab latest (pTCB.pNofl[idx])
;  2537         mov [esi*4+edi+128],ebx     -- and zero
;  2538         mov [esp+8],eax     -- [6] store list head
;  2539         pop ecx                     -- lpCriticalSection/csLock
;  2540         call :LeaveCriticalSection
;  2541     [64]
;  2542         cmp dword[rbx+rsi*4],#00424354      -- magic ("TCB\0")
                cmp dword[rbx+rsi*4],#00424354  ;#00441EF1: 201074263 54434200         uv 00 48  2 670      
;  2543 --      jne :notTCB
;  2544         je @f
                je #00441EFB              ;#00441EF8: 164 01                     v  00 00  1 671      
;  2545             int3
                    int3                  ;#00441EFA: 314                        np 00 00 13 672      
;  2546       @@:
;  2547         mov rax,[rsi*4+rdi+496]     -- grab latest (pTCB.pNofl[idx])
                mov rax,[rdi+rsi*4+496]   ;#00441EFB: 48:213204267 F0010000      uv 01 C0  1 685      
;  2548         mov [rsi*4+rdi+496],rbx     -- and zero
                mov [rdi+rsi*4+496],rbx   ;#00441F03: 48:211234267 F0010000      vu 00 C8  1 685      
;  2549         mov [rsp+8],rax     -- [6] store list head
                mov [rsp+8],rax           ;#00441F0B: 48:211104044 08            uv 00 11  1 686      
;  2550         mov rcx,[rsp+40]            -- lpCriticalSection/csLock
                mov rcx,[rsp+40]          ;#00441F10: 48:213114044 28            vu 02 10  1 686      
;  2551         call :LeaveCriticalSection
                call #00441834            ;#00441F15: 350 1AF9FFFF               v  00 00  1 687      
;  2552     [32]    
;  2553         mov eax,[esp+4]     -- [6] list head
;  2554         test eax,eax
;  2555         jz :listheadz       -- (no-one else should have done it!)
;  2556         -- recap: mergelist expects
;  2557         --   return address in [esp],
;  2558         --   tcb/4 in [esp+4],
;  2559         --   list head in eax and [esp+8], 
;  2560         --   block size in [esp+12],
;  2561         --   block idx(*4) in [esp+16],
;  2562         -- calling routine is responsible for removing the above
;  2563     [64]
;  2564         mov rax,[rsp+8]     -- [6] list head
                mov rax,[rsp+8]           ;#00441F1A: 48:213104044 08            uv 01 10  1 688      
;  2565         test rax,rax
                test rax,rax              ;#00441F1F: 48:205300                  uv 00 01  1 689 01   
;  2566         jz :listheadz       -- (no-one else should have done it!)
                jz #00441B45              ;#00441F22: 017204 1DFCFFFF            v  00 00  1 689      
;  2567         -- recap: mergelist expects
;  2568         --   return address in [rsp],
;  2569         --   tcb/4 in [rsp+8],
;  2570         --   list head in rax and [rsp+16], 
;  2571         --   block size in [rsp+24],
;  2572         --   block idx(*8) in [rsp+32],
;  2573         -- calling routine is responsible for removing the above
;  2574     []
;  2575         call :mergelist
                call #00441A97            ;#00441F28: 350 6AFBFFFF               v  00 00  1 690      
;  2576     [32]
;  2577         pop esi             -- [7] restore pTCB/4
;  2578         pop eax             -- [6] list head (discard)
;  2579         pop edx             -- [5] restore block size
;  2580         pop edi             -- [4] restore idx
;  2581     [64]
;  2582         mov rsi,[rsp]       -- [7] restore pTCB/4
                mov rsi,[rsp]             ;#00441F2D: 48:213064044               uv 40 10  1 691      
;  2583         mov rax,[rsp+8]     -- [6] list head (discard)
                mov rax,[rsp+8]           ;#00441F31: 48:213104044 08            vu 01 10  1 691      
;  2584         mov rdx,[rsp+16]    -- [5] restore block size
                mov rdx,[rsp+16]          ;#00441F36: 48:213124044 10            uv 04 10  1 692      
;  2585         mov rdi,[rsp+24]    -- [4] restore idx
                mov rdi,[rsp+24]          ;#00441F3B: 48:213174044 18            vu 80 10  1 692      
;  2586     []
;  2587         -- go back and see what mergelist has left us, if anything.
;  2588         jmp :gpchecknext
                jmp #00441C53             ;#00441F40: 351 0EFDFFFF               v  00 00  1 693      
;  2589 
;  2590     [32]
;  2591       :!blockfound  -- era @ [esp+12]
;  2592         -- first detach it from the freelist
;  2593         -- (see the recap in blockdetached, [only] esi and ecx are available)
;  2594         -- If we get an exception here, and as :!blockfound is only invoked 
;  2595         --  from one point above, we immediately zero dword[esi*4+edi+20],
;  2596         --  in pFEH.e, to minimise any heap corruption knock-on effects.
;  2597         mov esi,[eax+4]             -- pNext
;  2598         mov ecx,[eax+8]             -- pPrev
;  2599         test ecx,ecx
;  2600         jnz :!bf_midchain
;  2601             mov ecx,[esp+8]         -- pTCB/4
;  2602             test esi,esi
;  2603             jz @f
;  2604               :!blockfoundC0000005
;  2605                 mov [esi+8],ebx     -- this.pNext.pPrev:=null(=pPrev)
;  2606           @@:
;  2607             cmp dword[ebx+ecx*4],#00424354  -- magic ("TCB\0")
;  2608 --          jne :notTCB
;  2609             je @f
;  2610                 int3
;  2611           @@:
;  2612             mov [ecx*4+edi+20],esi  -- pTCB[idx]:=this.pNext
;  2613             jmp :blockdetached
;  2614       :!bf_midchain
;  2615             mov [ecx+4],esi         -- this.pPrev.pNext:=this.pNext
;  2616             test esi,esi
;  2617             jz :blockdetached
;  2618                 mov [esi+8],ecx     -- this.pNext.pPrev:=this.pPrev
;  2619     [64]
;  2620       :!blockfound  -- era @ [rsp+80]
;  2621         -- first detach it from the freelist
;  2622         -- (see the recap in blockdetached, [only] esi and ecx are available)
;  2623         -- if we get an exception here, and as :!blockfound is only called 
;  2624         --  from one point above, we immediately zero qword[rsi*4+rdi+32],
;  2625         --  in pFEH.e, to minimise any heap corruption knock-on effects.
;  2626         mov rsi,[rax+8]             -- pNext
                mov rsi,[rax+8]           ;#00441F45: 48:213160 08               uv 40 01  1 694      
;  2627         mov rcx,[rax+16]            -- pPrev
                mov rcx,[rax+16]          ;#00441F49: 48:213110 10               vu 02 01  1 694      
;  2628         test rcx,rcx
                test rcx,rcx              ;#00441F4D: 48:205311                  uv 00 02  1 695      
;  2629         jnz :!bf_midchain
                jnz #00441F75 (:!bf_midchain)  ;#00441F50: 017205 1F000000            v  00 00  1 695      
;  2630             mov rcx,[rsp+64]        -- pTCB/4
                    mov rcx,[rsp+64]      ;#00441F56: 48:213114044 40            uv 02 10  1 696      
;  2631             test rsi,rsi
                    test rsi,rsi          ;#00441F5B: 48:205366                  vu 00 40  1 696      
;  2632             jz @f
                    jz #00441F64          ;#00441F5E: 164 04                     v  00 00  1 697      
;  2633               :!blockfoundC0000005
;  2634                 mov [rsi+16],rbx    -- this.pNext.pPrev:=null(=pPrev)
                        mov [rsi+16],rbx  ;#00441F60: 48:211136 10               uv 00 48  1 698      
;  2635           @@:
;  2636             cmp dword[rbx+rcx*4],#00424354 -- magic ("TCB\0")
                    cmp dword[rbx+rcx*4],#00424354  ;#00441F64: 201074213 54434200         vu 00 0A  2 698      
;  2637 --          jne :notTCB
;  2638             je @f
                    je #00441F6E          ;#00441F6B: 164 01                     v  00 00  1 699      
;  2639                 int3
                        int3              ;#00441F6D: 314                        np 00 00 13 700      
;  2640           @@:
;  2641 -- 2/12/14:
;  2642 --          mov [rcx*4+rdi+32],esi  -- pTCB[idx]:=this.pNext
;  2643             mov [rcx*4+rdi+32],rsi  -- pTCB[idx]:=this.pNext
                    mov [rdi+rcx*4+32],rsi  ;#00441F6E: 48:211164217 20            uv 00 C2  1 713      
;  2644             jmp :blockdetached
                    jmp #00441F82         ;#00441F73: 353 0D                     v  00 00  1 713      
;  2645       :!bf_midchain
;  2646             mov [rcx+8],rsi         -- this.pPrev.pNext:=this.pNext
                    mov [rcx+8],rsi       ;#00441F75: 48:211161 08               uv 00 42  1 714      
;  2647             test rsi,rsi
                    test rsi,rsi          ;#00441F79: 48:205366                  vu 00 40  1 714      
;  2648             jz :blockdetached
                    jz #00441F82          ;#00441F7C: 164 04                     v  00 00  1 715      
;  2649                 mov [rsi+16],rcx    -- this.pNext.pPrev:=this.pPrev
                        mov [rsi+16],rcx  ;#00441F7E: 48:211116 10               uv 00 42  1 716      
;  2650     []
;  2651       ::blockdetached
;  2652     [32]
;  2653         -- recap:
;  2654         --      [esp] is rqd block size, rounded up (<=edx)
;  2655         --      [esp+4] is rqd idx*4 (<=edi) (not actually needed anymore)
;  2656         --      [esp+8] is pTCB/4
;  2657 --DEV   --      [esp+12] is era
;  2658 --      --      [esp+12] is <return address>
;  2659         --      [esp+16] is <return address>
;  2660         --      eax is an available block
;  2661         --      edx is size of ""
;  2662         --      edi is idx*4 of ""
;  2663         --      (obviously we may need to split eax until edx/edi match the stack values)
;  2664         mov ecx,[esp+8]             -- pTCB/4
;  2665         mov esi,[eax-4]             -- pRoot [+0b01, sometimes]
;  2666         and esi,#FFFFFFFE           -- clear 0b01, the free bit
;  2667         cmp dword[esi],#00484253    -- dwMagic ("SBH\0")
;  2668 --      jne :memorycorruption       -- (now checked in splitdone)
;  2669         je @f
;  2670             int3
;  2671       @@:
;  2672         cmp edx,[esp]               -- rqd block size
;  2673         je :splitdone
;  2674         shr edx,1                   -- /2
;  2675         or esi,1                    -- set 0b01 free bit
;  2676         sub edi,4                   -- decrease (idx*4)
;  2677         js :idxlz
;  2678         mov [eax+edx-4],esi         -- pRoot, with 0b01 set
;  2679 --pHeapD [NO!]
;  2680 --!     mov esi,[esp+12]            -- era
;  2681         mov [eax+edx],edx           -- nSize
;  2682 --!     mov [eax+edx-8],esi         -- era
;  2683         lea esi,[eax+edx]           -- esi:=address of block to put on freelist
;  2684         cmp [ecx*4+edi+20],ebx      -- check pFree[idx] is zero
;  2685         jne :pfreeidxnz             -- (if not, why we split bigger block?)
;  2686         mov [eax+edx+4],ebx         -- esi.pNext:=0 (w/o agi stall)
;  2687         mov [eax+edx+8],ebx         -- esi.pPrev:=0 ("")
;  2688         mov [ecx*4+edi+20],esi      -- pFree[idx](which was null):=2nd half
;  2689     [64]
;  2690         -- recap:
;  2691 --afaik, rsp should be the same as just after the:
;  2692 --      sub rsp,8*11    -- minimum shadow space plus align/temp stores:
;  2693 --                      -- [rsp+0/8/16/24] shadow space
;  2694 --                      -- [rsp+32] required size
;  2695 --                      -- [rsp+40] lpCriticalSection
;  2696 --                      -- [rsp+48] dwThreadId
;  2697 --                      -- [rsp+56] idx*8
;  2698 --                      -- [rsp+64] pTCB/4
;  2699 --                      -- [rsp+72] rqd size, rounded up
;  2700 --                      -- [rsp+80] era
;  2701         --      rax is an available block
;  2702         --      rdx is size of ""
;  2703         --      rdi is idx*8 of ""
;  2704         --      (obviously we may need to split rax until rdx/rdi match the stack values)
;  2705         mov rcx,[rsp+64]            -- pTCB/4
                mov rcx,[rsp+64]          ;#00441F82: 48:213114044 40            vu 02 10  1 716      
;  2706 --      mov rsi,[rax-8]             -- pRoot [+0b01, sometimes]
;  2707         mov r8,[rax-8]              -- pRoot [+0b01, sometimes]
                mov r8,[rax-8]            ;#00441F87: 4C:213100 F8               uv 100 01  1 717      
;  2708 --DEV (spotted in passing) disassembles as rsi..., should be esi according to FDBG, should really be rsi...
;  2709 --      and esi,#FFFFFFFE           -- clear 0b01, the free bit
;  2710 --      and rsi,-2                  -- clear 0b01, the free bit
;  2711 --DEV needs a #40 rex...
;  2712 --      and sil,-2                  -- clear 0b01, the free bit
;  2713         and r8l, byte #FE           -- clear 0b01, the free bit
                and r8l,-2                ;#00441F8B: 41:200340 FE               uv 100 100  1 718 100   
;  2714 --DEV ditto
;  2715 --      cmp dword[esi],#00484253    -- dwMagic ("SBH\0")
;  2716 --      cmp dword[rsi],#00484253    -- dwMagic ("SBH\0")
;  2717         cmp dword[r8],#00484253     -- dwMagic ("SBH\0")
                cmp dword[r8],4735571     ;#00441F8F: 41:201070 53424800         uv 00 100  2 721 100 *100*
;  2718 --      jne :memorycorruption       -- (now checked in splitdone)
;  2719         je @f
                je #00441F99              ;#00441F96: 164 01                     v  00 00  1 722      
;  2720             int3
                    int3                  ;#00441F98: 314                        np 00 00 13 723      
;  2721       @@:
;  2722         cmp rdx,[rsp+72]            -- rqd block size
                cmp rdx,[rsp+72]          ;#00441F99: 48:073124044 48            uv 00 14  2 736      
;  2723         je :splitdone
                je #00441FDA              ;#00441F9E: 164 3A                     v  00 00  1 737      
;  2724         shr rdx,1                   -- /2
                shr rdx,1                 ;#00441FA0: 48:321352                  u  04 04  1 738      
;  2725 --      or rsi,1                    -- set 0b01 free bit
;  2726         or r8l,1                    -- set 0b01 free bit
                or r8l,1                  ;#00441FA3: 41:200310 01               vu 100 100  1 738      
;  2727         sub rdi,8                   -- decrease (idx*8)
                sub rdi,8                 ;#00441FA7: 48:203357 08               uv 80 80  1 739      
;  2728         js :idxlz
                js #00441B47              ;#00441FAB: 017210 96FBFFFF            v  00 00  1 739      
;  2729 --      mov [rax+rdx-8],rsi         -- pRoot, with 0b01 set
;  2730         mov [rax+rdx-8],r8          -- pRoot, with 0b01 set
                mov [rax+rdx-8],r8        ;#00441FB1: 4C:211104020 F8            uv 00 105  1 740      
;  2731 --pHeapD: [NO!]
;  2732 --!     mov r9,[rsp+80]             -- era
;  2733         mov [rax+rdx],rdx           -- nSize
                mov [rax+rdx],rdx         ;#00441FB6: 48:211024020               vu 00 05  1 740      
;  2734 --!     mov [rax+rdx-16],r9         -- era
;  2735         lea rsi,[rax+rdx]           -- rsi:=address of block to put on freelist
                lea rsi,[rax+rdx]         ;#00441FBA: 48:215064020               uv 40 05  1 741      
;  2736         cmp [rcx*4+rdi+32],rbx      -- check pFree[idx] is zero
                cmp [rdi+rcx*4+32],rbx    ;#00441FBE: 48:071134217 20            vu 00 8A  2 741      
;  2737         jne :pfreeidxnz             -- (if not, why we split bigger block?)
                jne #00441B43             ;#00441FC3: 017205 7AFBFFFF            v  00 00  1 742      
;  2738         mov [rax+rdx+8],rbx         -- esi.pNext:=0 (w/o agi stall)
                mov [rax+rdx+8],rbx       ;#00441FC9: 48:211134020 08            uv 00 0D  1 743      
;  2739         mov [rax+rdx+16],rbx        -- esi.pPrev:=0 ("")
                mov [rax+rdx+16],rbx      ;#00441FCE: 48:211134020 10            vu 00 0D  1 743      
;  2740         mov [rcx*4+rdi+32],rsi      -- pFree[idx](which was null):=2nd half
                mov [rdi+rcx*4+32],rsi    ;#00441FD3: 48:211164217 20            uv 00 C2  1 744      
;  2741     []
;  2742         -- and carry on splitting as many times as required
;  2743         jmp :blockdetached
                jmp #00441F82             ;#00441FD8: 353 A8                     v  00 00  1 744      
;  2744 
;  2745       ::splitdone
;  2746     [32]
;  2747 --      and esi,#FFFFFFFE           -- clear 0b01, the free bit
;  2748 --      add esp,12
;  2749         cmp dword[esi],#00484253    -- dwMagic ("SBH\0")
;  2750 --      jne :memorycorruption
;  2751         je @f
;  2752             int3
;  2753       @@:
;  2754 --pHeapD:
;  2755         mov ecx,[esp+12]            -- era (edi would be fine too, I think)
;  2756         add esp,16
;  2757         mov [eax-4],esi             -- pRoot (w/out the free bit set)
;  2758         mov [eax-8],ecx             -- era
;  2759 --<     sub edx,4                   -- subtract the space used by pRoot
;  2760         sub edx,8                   -- subtract the space used by pRoot + era
;  2761         -- result is edx bytes at eax
;  2762     [64]
;  2763 --      mov r8,rsi
;  2764 --      and r8l,byte #FE            -- clear 0b01, the free bit
;  2765 --      add esp,12
;  2766         cmp dword[r8],#00484253     -- dwMagic ("SBH\0")
                cmp dword[r8],4735571     ;#00441FDA: 41:201070 53424800         uv 00 100  2 745      
;  2767 --      jne :memorycorruption
;  2768         je @f
                je #00441FE4              ;#00441FE1: 164 01                     v  00 00  1 746      
;  2769             int3
                    int3                  ;#00441FE3: 314                        np 00 00 13 747      
;  2770       @@:
;  2771 --pHeapD:
;  2772         mov r9,[rsp+80]             -- era
                mov r9,[rsp+80]           ;#00441FE4: 4C:213114044 50            uv 200 10  1 760      
;  2773         add rsp,8*11
                add rsp,88                ;#00441FE9: 48:203304 58               vu 10 10  1 760      
;  2774         mov [rax-8],r8              -- pRoot (w/out the free bit set)
                mov [rax-8],r8            ;#00441FED: 4C:211100 F8               uv 00 101  1 761      
;  2775         mov [rax-16],r9             -- era
                mov [rax-16],r9           ;#00441FF1: 4C:211110 F0               vu 00 201  1 761      
;  2776 --<     sub rdx,8                   -- subtract the space used by pRoot
;  2777         sub rdx,16                  -- subtract the space used by pRoot + era
                sub rdx,16                ;#00441FF5: 48:203352 10               uv 04 04  1 762      
;  2778         -- result is rdx bytes at rax
;  2779     []
;  2780         ret
                ret                       ;#00441FF9: 303                        np 00 00  2 763      
;  2781 
;  2782 
;  2783 --/*
;  2784 procedure :%pFreePool(:%)
;  2785 end procedure -- (for Edita/CtrlQ)
;  2786 --*/
;  2787     :%pFreePool
;  2788 ---------------
;  2789     [32]
;  2790         -- release ecx bytes of memory at eax, using edx as <era>.
;  2791         -- (no specific result, trashes eax/ecx/edx/esi/edi)
;  2792         push edx
;  2793         mov esi,[eax-4]             -- pRoot
;  2794         xor ebx,ebx -- (save some grief)
;  2795 --      and esi,#FFFFFFFE           -- clear free bit (needed when looping)
;  2796         test esi,#01
;  2797 --      jnz :memorycorruption
;  2798         jz :!FreePoole32a
;  2799             int3
;  2800       :!FreePoole32a
;  2801         cmp dword[esi],#00484253    -- dwMagic ("SBH\0")
;  2802 --      jne :memorycorruption
;  2803         je @f
;  2804             int3
;  2805       @@:
;  2806 --pHeapD:
;  2807 --<     add ecx,4                   -- include size of padding
;  2808         add ecx,8                   -- include size of padding
;  2809 --<     mov edx,20
;  2810         mov edx,24
;  2811         mov edi,0
;  2812       @@:
;  2813         cmp edx,ecx
;  2814 --      jle @f
;  2815         jge @f
;  2816             add edx,edx
;  2817             add edi,4
;  2818             jmp @b
;  2819       @@:
;  2820 --      cmp edx,ecx
;  2821 --      jne :memorycorruption
;  2822         je @f
;  2823             int3
;  2824       @@:
;  2825         cmp edi,108 -- (=27*4)
;  2826 --      jae :memorycorruption
;  2827         jb @f
;  2828             int3
;  2829       @@:
;  2830     [64]
;  2831         -- release rcx bytes of memory at rax, using rdx as <era>.
;  2832         -- (no specific result, trashes rax/rcx/rdx/rsi/rdi/r8/r9/r10/r11)
;  2833         push rdx
                push rdx                  ;#00441FFA: 48:122                     uv 00 04  1 765      
;  2834         mov rsi,[rax-8]             -- pRoot
                mov rsi,[rax-8]           ;#00441FFC: 48:213160 F8               vu 40 01  1 765      
;  2835         xor rbx,rbx -- (save some grief)
                xor rbx,rbx               ;#00442000: 48:061333                  uv 08 08  1 766      
;  2836         test rsi,#01
                test rsi,1                ;#00442003: 48:367306 01000000         vu 00 40  1 766      
;  2837 --      jnz :memorycorruption
;  2838         jz :!FreePoole32a
                jz #00442011 (:!FreePoole32a)  ;#0044200A: 017204 01000000            v  00 00  1 767      
;  2839             int3
                    int3                  ;#00442010: 314                        np 00 00 13 768      
;  2840       :!FreePoole32a
;  2841         cmp dword[rsi],#00484253    -- dwMagic ("SBH\0")
                cmp dword[rsi],4735571    ;#00442011: 201076 53424800            uv 00 40  2 781      
;  2842 --      jne :memorycorruption
;  2843         je @f
                je #0044201A              ;#00442017: 164 01                     v  00 00  1 782      
;  2844             int3
                    int3                  ;#00442019: 314                        np 00 00 13 783      
;  2845       @@:
;  2846 --pHeapD:
;  2847 --<     add rcx,8                   -- include size of padding
;  2848         add rcx,16                  -- include size of padding
                add rcx,16                ;#0044201A: 48:203301 10               uv 02 02  1 796      
;  2849 --<     mov rdx,36                  -- block size
;  2850         mov rdx,44                  -- block size
                mov rdx,44                ;#0044201E: 48:307302 2C000000         vu 04 00  1 796      
;  2851         mov rdi,0                   -- idx*8
                mov rdi,0                 ;#00442025: 48:307307 00000000         uv 80 00  1 797      
;  2852       @@:
;  2853         cmp rdx,rcx
                cmp rdx,rcx               ;#0044202C: 48:071312                  vu 00 06  1 797      
;  2854         jge @f
                jge #0044203A             ;#0044202F: 175 09                     v  00 00  1 798      
;  2855             add rdx,rdx
                    add rdx,rdx           ;#00442031: 48:001322                  uv 04 04  1 799      
;  2856             add rdi,8
                    add rdi,8             ;#00442034: 48:203307 08               vu 80 80  1 799      
;  2857             jmp @b
                    jmp #0044202C         ;#00442038: 353 F2                     v  00 00  1 800      
;  2858       @@:
;  2859 --      jne :memorycorruption
;  2860         je @f
                je #0044203D              ;#0044203A: 164 01                     v  00 00  1 801      
;  2861             int3
                    int3                  ;#0044203C: 314                        np 00 00 13 802      
;  2862       @@:
;  2863 --      cmp rdi,264 -- (=58*8)
;  2864         cmp rdi,464 -- (=58*8)
                cmp rdi,464               ;#0044203D: 48:201377 D0010000         uv 00 80  1 815      
;  2865 --      jae :memorycorruption
;  2866         jb @f
                jb #00442047              ;#00442044: 162 01                     v  00 00  1 815      
;  2867             int3
                    int3                  ;#00442046: 314                        np 00 00 13 816      
;  2868       @@:
;  2869     [32]
;  2870 --erm? (added 30/5/14)
;  2871         mov [eax],ecx               -- nSize
;  2872         push eax                    -- [1] save
;  2873 push ecx -- (does not actually help) [DEV]
;  2874     [64]
;  2875         mov [rax],rcx               -- nSize
                mov [rax],rcx             ;#00442047: 48:211010                  uv 00 03  1 829      
;  2876         mov r12,rax                 -- [1] save
                mov r12,rax               ;#0044204A: 4C:213340                  vu 1000 01  1 829      
;  2877     []
;  2878         call :pGetThread
                call #004417E3            ;#0044204D: 350 91F7FFFF               v  00 00  1 830      
;  2879     [32]
;  2880 pop ecx
;  2881         cmp eax,[esi+4]             -- sbh.dwThreadId
;  2882         mov edx,[esi+12]            -- pTCB/4
;  2883     [64]
;  2884         cmp eax,dword[rsi+4]        -- sbh.dwThreadId (dwMagic and dwThreadId are still dwords, btw)
                cmp eax,[esi+4]           ;#00442052: 073106 04                  uv 00 41  2 831      
;  2885         mov rdx,[rsi+16]            -- pTCB/4
                mov rdx,[rsi+16]          ;#00442055: 48:213126 10               vu 04 40  1 832      
;  2886     []
;  2887         jne @f
                jne #00442072             ;#00442059: 165 17                     v  00 00  1 833      
;  2888             -- owned
;  2889     [32]
;  2890             pop eax                 -- [1] restore
;  2891             push edx                -- pTCB/4
;  2892             push ebx                -- null (instead of mergelist's return address)
;  2893             push ecx                -- block size (cleared by mergeone)
;  2894             push edi                -- idx(*4)    (cleared by mergeone)
;  2895             push eax                -- block ptr  (cleared by mergeone)
;  2896             call :mergeone          --             (ends with a ret 12)
;  2897 --          add esp,8
;  2898             add esp,12
;  2899     [64]
;  2900             mov rax,r12             -- [1] restore
                    mov rax,r12           ;#0044205B: 49:213304                  uv 01 1000  1 834      
;  2901             push rdx                -- pTCB/4
                    push rdx              ;#0044205E: 48:122                     vu 00 04  1 834      
;  2902             push rbx                -- null (instead of mergelist's return address)
                    push rbx              ;#00442060: 48:123                     uv 00 08  1 835      
;  2903             push rcx                -- block size (cleared by mergeone)
                    push rcx              ;#00442062: 48:121                     vu 00 02  1 835      
;  2904             push rdi                -- idx(*8)    (cleared by mergeone)
                    push rdi              ;#00442064: 48:127                     uv 00 80  1 836      
;  2905             push rax                -- block ptr  (cleared by mergeone)
                    push rax              ;#00442066: 48:120                     vu 00 01  1 836      
;  2906             call :mergeone          --             (ends with a ret 24)
                    call #004418F5        ;#00442068: 350 88F8FFFF               v  00 00  1 837      
;  2907 --          add rsp,16
;  2908             add rsp,24
                    add rsp,24            ;#0044206D: 48:203304 18               uv 10 10  1 838      
;  2909     []
;  2910             ret
                    ret                   ;#00442071: 303                        np 00 00  2 839      
;  2911       @@:
;  2912         -- not owned
;  2913     [32]
;  2914         cmp dword[ebx+edx*4],#00424354      -- magic ("TCB\0")
;  2915 --      jne :memorycorruption
;  2916         je @f
;  2917             int3
;  2918       @@:
;  2919         lea esi,[ebx+edx*4+128]     -- locate pNofl (before edx gets damaged!)
;  2920         lea ecx,[ebx+edx*4+240]     -- csLock
;  2921         cmp dword[ebx+edx*4+236],#00424343  -- dwMagicC ("CCB\0")
;  2922         jne :notCCB
;  2923         cmp dword[ecx+24],#00424345 -- dwMagicE ("ECB\0")
;  2924         jne :notECB
;  2925         push ecx                                    -- lpCriticalSection (for Leave)
;  2926         call :EnterCriticalSection
;  2927     [64]
;  2928         cmp dword[rbx+rdx*4],#00424354      -- magic ("TCB\0")
                cmp dword[rbx+rdx*4],#00424354  ;#00442072: 201074223 54434200         uv 00 0C  2 841      
;  2929 --      jne :memorycorruption
;  2930         je @f
                je #0044207C              ;#00442079: 164 01                     v  00 00  1 842      
;  2931             int3
                    int3                  ;#0044207B: 314                        np 00 00 13 843      
;  2932       @@:
;  2933         lea rsi,[rbx+rdx*4+496]     -- locate pNofl (before rdx gets damaged!)
                lea rsi,[rbx+rdx*4+496]   ;#0044207C: 48:215264223 F0010000      uv 40 0C  1 856      
;  2934         lea rcx,[rbx+rdx*4+968]     -- csLock
                lea rcx,[rbx+rdx*4+968]   ;#00442084: 48:215214223 C8030000      vu 02 0C  1 856      
;  2935         cmp dword[rbx+rdx*4-960],#00424342  -- dwMagicB ("BCB\0")
                cmp dword[rbx+rdx*4-960],#00424342  ;#0044208C: 201274223 40FCFFFF 42434200 u  00 0C  2 857      
;  2936         jne :notCCB
                jne #00441B3B             ;#00442097: 017205 9EFAFFFF            v  00 00  1 858      
;  2937         cmp dword[rcx-4],#00424343  -- dwMagicC ("CCB\0")
                cmp dword[rcx-4],#00424343  ;#0044209D: 201171 FC 43434200         u  00 02  2 859      
;  2938         jne :notCCB
                jne #00441B3B             ;#004420A4: 017205 91FAFFFF            v  00 00  1 860      
;  2939         cmp dword[rcx+40],#00424345 -- dwMagicE ("ECB\0")
                cmp dword[rcx+40],#00424345  ;#004420AA: 201171 28 45434200         u  00 02  2 861      
;  2940         jne :notECB
                jne #00441B3D             ;#004420B1: 017205 86FAFFFF            v  00 00  1 862      
;  2941         mov [rsp+32],rcx            -- save lpCriticalSection (for Leave)
                mov [rsp+32],rcx          ;#004420B7: 48:211114044 20            uv 00 12  1 863      
;  2942         call :EnterCriticalSection
                call #004417FE            ;#004420BC: 350 3DF7FFFF               v  00 00  1 863      
;  2943     [32]
;  2944         mov eax,[esp+4]             -- [1] restore
;  2945         mov edx,[esi+edi]           -- pNofl[idx] (previous)
;  2946         mov [esi+edi],eax           -- pNofl[idx] (new)
;  2947 --13/8/15 no!!
;  2948 --      mov ecx,[eax-4]             -- pRoot
;  2949         mov [eax+4],edx             -- pNext
;  2950 --      or ecx,1
;  2951         mov [eax+8],ebx             -- pPrev (null, probably unnecessary)
;  2952 --      mov [eax-4],ecx             -- pRoot (with bit 0b01 set)
;  2953 --pHeapD?
;  2954 --      mov [eax-8],ebx             -- era?
;  2955         pop ecx                     -- lpCriticalSection/csLock
;  2956         call :LeaveCriticalSection
;  2957 --      add esp,4                   -- [1] discard          
;  2958         add esp,8                   -- [1] discard (and era)
;  2959     [64]
;  2960         mov rax,r12                 -- [1] restore
                mov rax,r12               ;#004420C1: 49:213304                  uv 01 1000  1 864      
;  2961         mov rdx,[rsi+rdi]           -- pNofl[idx] (previous)
                mov rdx,[rsi+rdi]         ;#004420C4: 48:213024076               vu 04 C0  1 864      
;  2962         mov [rsi+rdi],rax           -- pNofl[idx] (new)
                mov [rsi+rdi],rax         ;#004420C8: 48:211004076               uv 00 C1  1 865      
;  2963 --13/8/15 no!!
;  2964 --      mov rcx,[rax-8]             -- pRoot
;  2965         mov [rax+8],rdx             -- pNext
                mov [rax+8],rdx           ;#004420CC: 48:211120 08               uv 00 05  1 867    *01*
;  2966 --      or rcx,1
;  2967         mov [rax+16],rbx            -- pPrev (null, probably unnecessary)
                mov [rax+16],rbx          ;#004420D0: 48:211130 10               vu 00 09  1 867      
;  2968 --      mov [rax-8],rcx             -- pRoot (with bit 0b01 set)
;  2969 --pHeapD?
;  2970 --      mov [rax-16],rbx            -- era?
;  2971         mov rcx,[rsp+32]            -- lpCriticalSection/csLock
                mov rcx,[rsp+32]          ;#004420D4: 48:213114044 20            uv 02 10  1 868      
;  2972         call :LeaveCriticalSection
                call #00441834            ;#004420D9: 350 56F7FFFF               v  00 00  1 868      
;  2973         add rsp,8                   -- discard era
                add rsp,8                 ;#004420DE: 48:203304 08               uv 10 10  1 869      
;  2974     []
;  2975         ret
                ret                       ;#004420E2: 303                        np 00 00  2 870      
;  2976 
;  2977 --/*
;  2978 procedure :%pAllocStr(:%)
;  2979 end procedure -- (for Edita/CtrlQ)
;  2980 --*/
;  2981     :%pAllocStr
;  2982 ---------------
;  2983     [32]
;  2984         -- Allocate a string of length ecx.
;  2985         -- Sets the length, type/refcount, and returns a ref in eax.
;  2986         -- All other registers (except eax) are preserved.
;  2987         test ecx,ecx
;  2988 --      js e101atasonl                    ; attempt to allocate string of negative length
;  2989         js :invalidmemoryrequest
;  2990         pushad
;  2991         add ecx,17                      -- header plus terminating null
;  2992         xor ebx,ebx                     -- (save some grief)
;  2993         mov edx,[esp+32]                -- era
;  2994         call :%pGetPool                 -- allocate ecx bytes, rounded up
;  2995         test eax,eax
;  2996 --      jz :memoryallocationfailure
;  2997         jnz @f
;  2998             int3
;  2999       @@:
;  3000         mov ecx,[esp+24]                -- retrieve original length (ecx from the pushad)
;  3001         mov [eax],edx                   -- set maxlen
;  3002         lea edx,[eax+17]                --      ref: raw plus header & type bit,
;  3003         mov [eax+4],ecx                 -- set length
;  3004         ror edx,2                       --      rotated,
;  3005         mov dword[eax+8],1              -- refcount
;  3006         mov [esp+28],edx                --      keep new ref (in eax),
;  3007         mov dword[eax+12],0x82000000    -- type
;  3008         popad                           --      but restore all other registers
;  3009     [64]
;  3010         -- Allocate a string of length rcx.
;  3011         -- Sets the length, type/refcount, and returns a ref in rax.
;  3012         -- All other registers (except rax) are preserved. [DEV/ERM/may need yet more push/pop...]
;  3013         test rcx,rcx
                test rcx,rcx              ;#004420E3: 48:205311                  uv 00 02  1 872      
;  3014 --      js e101atasonl                    ; attempt to allocate string of negative length
;  3015         js :invalidmemoryrequest
                js #00441B24              ;#004420E6: 017210 38FAFFFF            v  00 00  1 872      
;  3016 --      pushad
;  3017         sub rsp,8                       -- align stack
                sub rsp,8                 ;#004420EC: 48:203354 08               uv 10 10  1 873      
;  3018         xor rbx,rbx                     -- (save some grief)
                xor rbx,rbx               ;#004420F0: 48:061333                  vu 08 08  1 873      
;  3019         push rsi                        -- [1] save
                push rsi                  ;#004420F3: 48:126                     uv 00 40  1 874      
;  3020         push rdi                        -- [2] save
                push rdi                  ;#004420F5: 48:127                     vu 00 80  1 874      
;  3021         push rdx                        -- [3] save
                push rdx                  ;#004420F7: 48:122                     uv 00 04  1 875      
;  3022         push rcx                        -- [4] save
                push rcx                  ;#004420F9: 48:121                     vu 00 02  1 875      
;  3023         add rcx,33                      -- header plus terminating null
                add rcx,33                ;#004420FB: 48:203301 21               uv 02 02  1 876      
;  3024         mov rdx,[rsp+40]                -- era
                mov rdx,[rsp+40]          ;#004420FF: 48:213124044 28            vu 04 10  1 876      
;  3025         call :%pGetPool                 -- allocate ecx bytes, rounded up
                call #00441B4D (:%pGetPool)  ;#00442104: 350 44FAFFFF               v  00 00  1 877      
;  3026         test rax,rax
                test rax,rax              ;#00442109: 48:205300                  uv 00 01  1 878      
;  3027 --      jz :memoryallocationfailure
;  3028         jnz @f
                jnz #0044210F             ;#0044210C: 165 01                     v  00 00  1 878      
;  3029             int3
                    int3                  ;#0044210E: 314                        np 00 00 13 879      
;  3030       @@:
;  3031         mov rcx,[rsp]                   -- [4] retrieve original length
                mov rcx,[rsp]             ;#0044210F: 48:213014044               uv 02 10  1 892      
;  3032         mov [rax],rdx                   -- set maxlen
                mov [rax],rdx             ;#00442113: 48:211020                  vu 00 05  1 892      
;  3033 --<     lea rdx,[rax+33]                --      ref: raw plus header & type bit,
;  3034         mov [rax+8],rcx                 -- set length
                mov [rax+8],rcx           ;#00442116: 48:211110 08               uv 00 03  1 893      
;  3035 --<     ror rdx,2                       --      rotated,
;  3036         mov qword[rax+16],1             -- refcount
                mov qword[rax+16],1       ;#0044211A: 48:307100 10 01000000      vu 00 01  1 893      
;  3037         mov dword[rax+24],ebx           -- type loword
                mov [eax+24],ebx          ;#00442122: 211130 18                  uv 00 09  1 894      
;  3038         mov dword[rax+28],0x82000000    -- type
                mov [rax+28], dword -2113929216  ;#00442125: 307100 1C 00000082         vu 00 01  1 894      
;  3039 --      popad                           --      but restore all other registers
;  3040 --<     mov rax,rdx
;  3041         mov rdx,[rsp+8]                 -- [3] restore
                mov rdx,[rsp+8]           ;#0044212C: 48:213124044 08            uv 04 10  1 895      
;  3042         mov rdi,[rsp+16]                -- [2] restore
                mov rdi,[rsp+16]          ;#00442131: 48:213174044 10            vu 80 10  1 895      
;  3043         mov rsi,[rsp+24]                -- [1] restore
                mov rsi,[rsp+24]          ;#00442136: 48:213164044 18            uv 40 10  1 896      
;  3044         lea rax,[rax+33]                -- ref: raw plus header & type bit,
                lea rax,[rax+33]          ;#0044213B: 48:215100 21               vu 01 01  1 896      
;  3045         add rsp,5*8
                add rsp,40                ;#0044213F: 48:203304 28               uv 10 10  1 897      
;  3046         ror rax,2                       -- rotated,
                ror rax,2                 ;#00442143: 48:301310 02               np 01 01  1 898      
;  3047     []
;  3048         ret
                ret                       ;#00442147: 303                        np 00 00  2 899      
;  3049 
;  3050 --/*
;  3051 procedure :%pAllocSeq(:%)
;  3052 end procedure -- (for Edita/CtrlQ)
;  3053 --*/
;  3054     :%pAllocSeq
;  3055 ---------------
;  3056     [32]
;  3057         -- Allocate a sequence of length ecx.
;  3058         --  on entry, era in edx
;  3059         -- Sets the length, type/refcount, and returns a ref in eax.
;  3060         -- All other registers (except eax) are preserved.
;  3061         test ecx,ecx
;  3062 --      js e101atasonl                  ; attempt to allocate string of negative length
;  3063         js :invalidmemoryrequest
;  3064         pushad
;  3065         xor ebx,ebx                     -- (save some grief)
;  3066         lea ecx,[ebx+ecx*4+20]          -- 4 bytes per element plus header
;  3067 --      mov edx,[esp+32]                -- era
;  3068         call :%pGetPool                 -- allocate ecx bytes, rounded up
;  3069         test eax,eax
;  3070 --      jz :memoryallocationfailure
;  3071         jnz @f
;  3072             int3
;  3073       @@:
;  3074         mov [eax],ebx                   -- set slack (=0)
;  3075         mov ecx,[esp+24]                -- retrieve original length (ecx from the pushad)
;  3076         mov [eax+4],edx                 -- set maxlen (= allocated size)
;  3077         lea edi,[eax+21]                --      ref: raw plus header & type bit,
;  3078         mov [eax+8],ecx                 -- set length
;  3079         ror edi,2                       --      rotated,
;  3080         mov dword[eax+12],1             -- refcount
;  3081         mov [esp+28],edi                --      keep new ref (in eax),
;  3082         mov dword[eax+16],0x80000000    -- type
;  3083         popad                           --      but restore all other registers
;  3084     [64]
;  3085         -- Allocate a sequence of length rcx.
;  3086         --  on entry, era in rdx
;  3087         -- Sets the length, type/refcount, and returns a ref in rax.
;  3088         -- All other registers (except rax) are preserved. [DEV/ERM...]
;  3089         test rcx,rcx
                test rcx,rcx              ;#00442148: 48:205311                  uv 00 02  1 901      
;  3090 --      js e101atasonl                  ; attempt to allocate string of negative length
;  3091         js :invalidmemoryrequest
                js #00441B24              ;#0044214B: 017210 D3F9FFFF            v  00 00  1 901      
;  3092 --      pushad
;  3093         sub rsp,8                       -- align stack
                sub rsp,8                 ;#00442151: 48:203354 08               uv 10 10  1 902      
;  3094         xor rbx,rbx                     -- (save some grief)
                xor rbx,rbx               ;#00442155: 48:061333                  vu 08 08  1 902      
;  3095         push rsi                        -- [1] save
                push rsi                  ;#00442158: 48:126                     uv 00 40  1 903      
;  3096         push rdi                        -- [2] save
                push rdi                  ;#0044215A: 48:127                     vu 00 80  1 903      
;  3097         push rdx                        -- [3] save
                push rdx                  ;#0044215C: 48:122                     uv 00 04  1 904      
;  3098         push rcx                        -- [4] save
                push rcx                  ;#0044215E: 48:121                     vu 00 02  1 904      
;  3099 --      lea rcx,[rbx+rcx*8+40]          -- 8 bytes per element plus header
;  3100         shl rcx,3                       -- 8 bytes per element
                shl rcx,3                 ;#00442160: 48:301341 03               u  02 02  1 905      
;  3101 --      mov rdx,[rsp+40]                -- era
;  3102         add rcx,40                      -- plus header
                add rcx,40                ;#00442164: 48:203301 28               uv 02 02  1 906 02   
;  3103         call :%pGetPool                 -- allocate rcx bytes, rounded up
                call #00441B4D (:%pGetPool)  ;#00442168: 350 E0F9FFFF               v  00 00  1 906      
;  3104         test rax,rax
                test rax,rax              ;#0044216D: 48:205300                  uv 00 01  1 907      
;  3105 --      jz :memoryallocationfailure
;  3106         jnz @f
                jnz #00442173             ;#00442170: 165 01                     v  00 00  1 907      
;  3107             int3
                    int3                  ;#00442172: 314                        np 00 00 13 908      
;  3108       @@:
;  3109         mov [rax],rbx                   -- set slack (=0)
                mov [rax],rbx             ;#00442173: 48:211030                  uv 00 09  1 921      
;  3110         mov rcx,[rsp]                   -- [4] retrieve original length
                mov rcx,[rsp]             ;#00442176: 48:213014044               vu 02 10  1 921      
;  3111         mov [rax+8],rdx                 -- set maxlen (= allocated size)
                mov [rax+8],rdx           ;#0044217A: 48:211120 08               uv 00 05  1 922      
;  3112 --      lea rdi,[rax+41]                --      ref: raw plus header & type bit,
;  3113         mov [rax+16],rcx                -- set length
                mov [rax+16],rcx          ;#0044217E: 48:211110 10               vu 00 03  1 922      
;  3114 --      ror rdi,2                       --      rotated,
;  3115         mov qword[rax+24],1             -- refcount
                mov qword[rax+24],1       ;#00442182: 48:307100 18 01000000      uv 00 01  1 923      
;  3116 --      mov [esp+28],edi                --      keep new ref (in eax),
;  3117         mov dword[rax+32],ebx           -- type loword
                mov [eax+32],ebx          ;#0044218A: 211130 20                  vu 00 09  1 923      
;  3118         mov dword[rax+36],0x80000000    -- type
                mov [rax+36], dword -2147483648  ;#0044218D: 307100 24 00000080         uv 00 01  1 924      
;  3119 --      popad                           --      but restore all other registers
;  3120         mov rdx,[rsp+8]                 -- [3] restore
                mov rdx,[rsp+8]           ;#00442194: 48:213124044 08            vu 04 10  1 924      
;  3121         mov rdi,[rsp+16]                -- [2] restore
                mov rdi,[rsp+16]          ;#00442199: 48:213174044 10            uv 80 10  1 925      
;  3122         mov rsi,[rsp+24]                -- [1] restore
                mov rsi,[rsp+24]          ;#0044219E: 48:213164044 18            vu 40 10  1 925      
;  3123         lea rax,[rax+41]                -- ref: raw plus header & type bit,
                lea rax,[rax+41]          ;#004421A3: 48:215100 29               uv 01 01  1 926      
;  3124         add rsp,5*8
                add rsp,40                ;#004421A7: 48:203304 28               vu 10 10  1 926      
;  3125         ror rax,2                       -- rotated,
                ror rax,2                 ;#004421AB: 48:301310 02               np 01 01  1 927      
;  3126     []
;  3127         ret
                ret                       ;#004421AF: 303                        np 00 00  2 928      
;  3128 
;  3129 --DEV test/fix this on 64-bit (hopefully not an issue)
;  3130 --  However while power(3,5) is exactly 243 in 64-bit mode, it is one bit 
;  3131 --  adrift in 80-bit mode, so eg:
;  3132 --          f=power(3,5)
;  3133 --          ?{f=243,f+1=244}
;  3134 --  may display {0,1}, and I can tell you it took me a fair while to track 
;  3135 --  that little bugger down. The really confusing thing was of course the
;  3136 --  way that 243.0 + 1 was getting stored as an integer... ie the _reload_
;  3137 --  of 243.0 cleared bits 64..80 compared to when it was first stored.
;  3138 
;  3139 --/*
;  3140 procedure :%pStoreFlt(:%)
;  3141 end procedure -- (for Edita/CtrlQ)
;  3142 --*/
;  3143     :%pStoreFlt
;  3144 ---------------
;  3145     [32]
;  3146         -- Store st0 in [edi], as integer if possible.
;  3147         -- Deallocates previous contents of [edi] if required.
;  3148         -- All registers are preserved.
;  3149         pushad
;  3150         xor ebx,ebx -- (save some grief)
;  3151         -- Force round to 64 bits, since that is how we store floats.
;  3152         sub esp,8
;  3153         fstp qword[esp]     -- store as 64-bit float/pop (2 cycle)
;  3154         fld qword[esp]      -- reload                    (1 cycle)
;  3155         fist dword[esp]     -- store as 32-bit int
;  3156         mov edx,[edi]       -- prev contents
;  3157         fild dword[esp]
;  3158         mov ecx,[esp]
;  3159         add esp,8
;  3160         fcomp st1           -- pop one
;  3161         fnstsw ax
;  3162 --DEV Agner sez (look this up!) test ax,0x40 jz StoreFlt64 (nb test inverted)
;  3163         sahf
;  3164         jne :StoreFlt64     -- not integer
;  3165         mov eax,ecx
;  3166         shl ecx,1
;  3167         jo :StoreFlt64      -- result bigger than 31 bits
;  3168         fstp st0            -- discard copy
;  3169         mov [edi],eax
;  3170         cmp edx,h4
;  3171         jle @f
;  3172             sub dword[ebx+edx*4-8],1
;  3173             jne @f
;  3174 --          push dword[esp+40]
;  3175             push dword[esp+32]
;  3176             call :%pDealloc0
;  3177       @@:
;  3178         popad
;  3179     [64]
;  3180         -- Store st0 in [rdi], as integer if possible.
;  3181         -- Deallocates previous contents of [rdi] if required.
;  3182         -- All registers are preserved. [DEV? what about :%pDealloc? :%pGetPool?]
;  3183         -- Preserves rax/rcx/rdx/rsi (see StoreMint) and rdi
;  3184         -- NB: is now expected to leave r15 set to h4 (pTime.e)
;  3185         push rdx
                push rdx                  ;#004421B0: 48:122                     uv 00 04  1 930      
;  3186         push rcx
                push rcx                  ;#004421B2: 48:121                     vu 00 02  1 930      
;  3187         push rax
                push rax                  ;#004421B4: 48:120                     uv 00 01  1 931      
;  3188         push rsi
                push rsi                  ;#004421B6: 48:126                     vu 00 40  1 931      
;  3189         mov r15,h4
                mov r15,h4                ;#004421B8: 49:277 0000000000000040    uv 8000 00  1 932      
;  3190         xor rbx,rbx -- (save some grief)
                xor rbx,rbx               ;#004421C2: 48:061333                  vu 08 08  1 932      
;  3191         sub rsp,16
                sub rsp,16                ;#004421C5: 48:203354 10               uv 10 10  1 933      
;  3192 --      fist qword[rsp]     -- store as 64-bit int (instruction not supported [by the/any hardware!])
;  3193         fld st0
                fld st0                   ;#004421C9: 331300                     np 00 00  1 934      
;  3194         fistp qword[rsp]    -- store as 64-bit int
                fistp qword[rsp]          ;#004421CB: 337074044                  np 00 10  6 935      
;  3195         mov rdx,[rdi]       -- prev contents
                mov rdx,[rdi]             ;#004421CE: 48:213027                  uv 04 80  1 941      
;  3196         fild qword[rsp]
                fild qword[rsp]           ;#004421D1: 337054044                  np 00 10  3 942      
;  3197         mov rcx,[rsp]
                mov rcx,[rsp]             ;#004421D4: 48:213014044               uv 02 10  1 945      
;  3198         add rsp,16
                add rsp,16                ;#004421D8: 48:203304 10               vu 10 10  1 945      
;  3199         fcomp st1           -- pop one
                fcomp                     ;#004421DC: 330331                     np 00 00  1 946      
;  3200         fnstsw ax
                fnstsw ax                 ;#004421DE: 337340                     np 01 00  6 947      
;  3201 --DEV Agner sez (look this up!) test ax,0x40 jz StoreFlt64 (nb test inverted)
;  3202         sahf
                sahf                      ;#004421E0: 236                        np 00 01  2 953      
;  3203         jne :StoreFlt64     -- not integer
                jne #00442214             ;#004421E1: 165 31                     v  00 00  1 955      
;  3204         mov rax,rcx
                mov rax,rcx               ;#004421E3: 48:213301                  uv 01 02  1 956      
;  3205         shl rcx,1
                shl rcx,1                 ;#004421E6: 48:321341                  u  02 02  1 957      
;  3206         jo :StoreFlt64      -- result bigger than 31 bits
                jo #00442214              ;#004421E9: 160 29                     v  00 00  1 957      
;  3207         fstp st0            -- discard copy
                fstp st0                  ;#004421EB: 335330                     np 00 00  1 958      
;  3208         mov [rdi],rax
                mov [rdi],rax             ;#004421ED: 48:211007                  uv 00 81  1 959      
;  3209 --      cmp rdx,h4
;  3210 --      mov r15,h4
;  3211         cmp rdx,r15
                cmp rdx,r15               ;#004421F0: 49:073327                  vu 00 8004  1 959      
;  3212         jle @f
                jle #0044220B             ;#004421F3: 176 16                     v  00 00  1 960      
;  3213             sub qword[ebx+edx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#004421F5: 48:203154223 F0 01         u  00 0C  3 961      
;  3214             jne @f
                    jne #0044220B         ;#004421FB: 165 0E                     v  00 00  1 963      
;  3215             push rdi
                    push rdi              ;#004421FD: 48:127                     uv 00 80  1 964      
;  3216             push qword[rsp+40]
                    push qword[rsp+40]    ;#004421FF: 48:377164044 28            np 00 10  2 965      
;  3217             call :%pDealloc0
                    call #004422DE (:%pDealloc0)  ;#00442204: 350 D5000000               v  00 00  1 967      
;  3218             pop rdi
                    pop rdi               ;#00442209: 48:137                     uv 80 00  1 968      
;  3219       @@:
;  3220         pop rsi
                pop rsi                   ;#0044220B: 48:136                     vu 40 00  1 968      
;  3221         pop rax
                pop rax                   ;#0044220D: 48:130                     uv 01 00  1 969      
;  3222         pop rcx
                pop rcx                   ;#0044220F: 48:131                     vu 02 00  1 969      
;  3223         pop rdx
                pop rdx                   ;#00442211: 48:132                     uv 04 00  1 970      
;  3224     []
;  3225         ret
                ret                       ;#00442213: 303                        np 00 00  2 971      
;  3226 
;  3227       ::StoreFlt64
;  3228     [32]
;  3229         cmp edx,h4
;  3230         jle :SFNewFlt
;  3231         mov ecx,[ebx+edx*4-8]           -- refcount
;  3232         cmp byte[ebx+edx*4-1],0x12
;  3233         jne @f
;  3234             sub ecx,1
;  3235             jne :SFnodealloc                -- reuse if refcount is exactly 1
;  3236             fstp qword[ebx+edx*4]
;  3237             popad
;  3238             ret
;  3239       @@:
;  3240         sub ecx,1
;  3241         jne :SFnodealloc
;  3242             push dword[esp+32]
;  3243             call :%pDealloc0
;  3244             jmp :SFNewFlt
;  3245       ::SFnodealloc
;  3246         mov [ebx+edx*4-8],ecx           -- store decremented refcount (still>0)
;  3247       ::SFNewFlt
;  3248         mov ecx,16
;  3249         mov edx,[esp+32]                -- era
;  3250         call :%pGetPool                 -- allocate ecx bytes
;  3251         test eax,eax
;  3252 --      jz :memoryallocationfailure
;  3253         jnz @f
;  3254             int3
;  3255       @@:
;  3256         mov edi,[esp]                   -- restore original edi (pGetPool trashes all regs)
;  3257         lea edx,[eax+9]                 --      ref: raw plus header & type bit,
;  3258         mov dword[eax],1                -- refcount
;  3259         ror edx,2                       --      rotated,
;  3260         mov dword[eax+4],0x12000000     -- type
;  3261         mov [edi],edx                   --      store ref in [edi]
;  3262         fstp qword[eax+8]               -- value
;  3263         popad
;  3264 
;  3265     [64]
;  3266 --      cmp rdx,h4
;  3267 --      mov r15,h4
;  3268         push rdi
                push rdi                  ;#00442214: 48:127                     uv 00 80  1 973      
;  3269         cmp rdx,r15
                cmp rdx,r15               ;#00442216: 49:073327                  vu 00 8004  1 973      
;  3270         jle :SFNewFlt
                jle #0044224B             ;#00442219: 176 30                     v  00 00  1 974      
;  3271         mov rcx,[rbx+rdx*4-16]          -- refcount
                mov rcx,[rbx+rdx*4-16]    ;#0044221B: 48:213114223 F0            uv 02 0C  1 975      
;  3272         cmp byte[rbx+rdx*4-1],0x12
                cmp byte[rbx+rdx*4-1],#12  ;#00442220: 200174223 FF 12            u  00 0C  2 976      
;  3273         jne @f
                jne #00442234             ;#00442225: 165 0D                     v  00 00  1 977      
;  3274             sub rcx,1
                    sub rcx,1             ;#00442227: 48:203351 01               uv 02 02  1 978      
;  3275             jne :SFnodealloc                -- reuse if refcount is exactly 1
                    jne #00442246         ;#0044222B: 165 19                     v  00 00  1 978      
;  3276             fstp tbyte[rbx+rdx*4]
                    fstp tbyte[rbx+rdx*4]  ;#0044222D: 333074223                  np 00 0C  3 979      
;  3277             pop rdi
                    pop rdi               ;#00442230: 48:137                     uv 80 00  1 982      
;  3278             jmp @b  -- (pop pop pop ret)
                    jmp #0044220B         ;#00442232: 353 D7                     v  00 00  1 982      
;  3279 
;  3280       @@:
;  3281         sub rcx,1
                sub rcx,1                 ;#00442234: 48:203351 01               uv 02 02  1 983      
;  3282         jne :SFnodealloc
                jne #00442246             ;#00442238: 165 0C                     v  00 00  1 983      
;  3283             push qword[rsp+40]
                    push qword[rsp+40]    ;#0044223A: 48:377164044 28            np 00 10  2 984      
;  3284             call :%pDealloc0
                    call #004422DE (:%pDealloc0)  ;#0044223F: 350 9A000000               v  00 00  1 986      
;  3285             jmp :SFNewFlt
                    jmp #0044224B         ;#00442244: 353 05                     v  00 00  1 987      
;  3286       ::SFnodealloc
;  3287         mov [rbx+rdx*4-16],rcx          -- store decremented refcount (still>0)
                mov [rbx+rdx*4-16],rcx    ;#00442246: 48:211114223 F0            uv 00 0E  1 988      
;  3288       ::SFNewFlt
;  3289 --      mov rcx,26
;  3290         mov rcx,28
                mov rcx,28                ;#0044224B: 48:307301 1C000000         vu 02 00  1 988      
;  3291         mov rdx,[rsp+40]                -- era
                mov rdx,[rsp+40]          ;#00442252: 48:213124044 28            uv 04 10  1 989      
;  3292         call :%pGetPool                 -- allocate rcx bytes
                call #00441B4D (:%pGetPool)  ;#00442257: 350 F1F8FFFF               v  00 00  1 989      
;  3293         test rax,rax
                test rax,rax              ;#0044225C: 48:205300                  uv 00 01  1 990      
;  3294 --      jz :memoryallocationfailure
;  3295         jnz @f
                jnz #00442262             ;#0044225F: 165 01                     v  00 00  1 990      
;  3296             int3
                    int3                  ;#00442261: 314                        np 00 00 13 991      
;  3297       @@:
;  3298 --      mov rdi,[rsp]                   -- restore original rdi (pGetPool trashes all regs) [DEV]
;  3299         pop rdi
                pop rdi                   ;#00442262: 48:137                     uv 80 00  1 1004      
;  3300         lea rdx,[rax+17]                --      ref: raw plus header & type bit,
                lea rdx,[rax+17]          ;#00442264: 48:215120 11               vu 04 01  1 1004      
;  3301         mov qword[rax],1                -- refcount
                mov qword[rax],1          ;#00442268: 48:307000 01000000         uv 00 01  1 1005      
;  3302         ror rdx,2                       --      rotated,
                ror rdx,2                 ;#0044226F: 48:301312 02               np 04 04  1 1006      
;  3303         mov qword[rax+8],rbx            -- type/delete_rtn
                mov [rax+8],rbx           ;#00442273: 48:211130 08               uv 00 09  1 1007      
;  3304         mov [rdi],rdx                   --      store ref in [rdi]
                mov [rdi],rdx             ;#00442277: 48:211027                  vu 00 84  1 1007      
;  3305         mov byte[rax+15],0x12           -- type
                mov [rax+15], byte #12    ;#0044227A: 306100 0F 12               uv 00 01  1 1008      
;  3306         fstp tbyte[rax+16]              -- value
                fstp tbyte[rax+16]        ;#0044227E: 333170 10                  np 00 01  3 1009      
;  3307         pop rsi
                pop rsi                   ;#00442281: 48:136                     uv 40 00  1 1012      
;  3308         pop rax
                pop rax                   ;#00442283: 48:130                     vu 01 00  1 1012      
;  3309         pop rcx
                pop rcx                   ;#00442285: 48:131                     uv 02 00  1 1013      
;  3310         pop rdx
                pop rdx                   ;#00442287: 48:132                     vu 04 00  1 1013      
;  3311     []
;  3312         ret
                ret                       ;#00442289: 303                        np 00 00  2 1014      
;  3313 
;  3314 --/*
;  3315 procedure :%pStoreMint(:%)
;  3316 end procedure -- (for Edita/CtrlQ)
;  3317 --*/
;  3318     :%pStoreMint    -- store a machine-sized (32/64-bit) integer
;  3319 ----------------
;  3320     [32]
;  3321         -- Store eax in [edi], as integer if possible, else as float.
;  3322         -- Deallocates previous contents of [edi] if required.
;  3323         -- All registers are preserved.
;  3324         pushad
;  3325         mov ecx,eax
;  3326         mov edx,[edi]       -- prev contents
;  3327         xor ebx,ebx         -- (save some grief)
;  3328         shl ecx,1
;  3329         jno @f
;  3330             fild dword[esp+28]      -- (ie the eax from pushad)
;  3331             jmp :StoreFlt64         -- (will dealloc [edi] if rqd)
;  3332       @@:
;  3333         mov [edi],eax
;  3334         cmp edx,h4
;  3335         jle @f
;  3336             sub dword[ebx+edx*4-8],1
;  3337             jne @f
;  3338             push dword[esp+32]
;  3339             call :%pDealloc0
;  3340       @@:
;  3341         popad
;  3342     [64]
;  3343         -- Store rax in [rdi], as integer if possible, else as float.
;  3344         -- Deallocates previous contents of [rdi] if required.
;  3345         -- Preserves rax/rcx/rdx/rsi (see StoreFlt) and rdi.
;  3346         push rdx
                push rdx                  ;#0044228A: 48:122                     uv 00 04  1 1016      
;  3347         push rcx
                push rcx                  ;#0044228C: 48:121                     vu 00 02  1 1016      
;  3348         push rax
                push rax                  ;#0044228E: 48:120                     uv 00 01  1 1017      
;  3349         push rsi
                push rsi                  ;#00442290: 48:126                     vu 00 40  1 1017      
;  3350         xor rbx,rbx -- (save some grief)
                xor rbx,rbx               ;#00442292: 48:061333                  uv 08 08  1 1018      
;  3351         mov rcx,rax
                mov rcx,rax               ;#00442295: 48:213310                  vu 02 01  1 1018      
;  3352         mov rdx,[rdi]       -- prev contents
                mov rdx,[rdi]             ;#00442298: 48:213027                  uv 04 80  1 1019      
;  3353         shl rcx,1
                shl rcx,1                 ;#0044229B: 48:321341                  u  02 02  1 1020      
;  3354         jno @f
                jno #004422A9             ;#0044229E: 161 09                     v  00 00  1 1020      
;  3355             fild qword[rsp+8]   -- (saved rax)
                    fild qword[rsp+8]     ;#004422A0: 337154044 08               np 00 10  3 1021      
;  3356             jmp :StoreFlt64
                    jmp #00442214         ;#004422A4: 351 6BFFFFFF               v  00 00  1 1024      
;  3357       @@:
;  3358         mov r15,h4
                mov r15,h4                ;#004422A9: 49:277 0000000000000040    uv 8000 00  1 1025      
;  3359         mov [rdi],rax
                mov [rdi],rax             ;#004422B3: 48:211007                  vu 00 81  1 1025      
;  3360         cmp rdx,r15
                cmp rdx,r15               ;#004422B6: 49:073327                  uv 00 8004  1 1026      
;  3361         jle @f
                jle #004422D1             ;#004422B9: 176 16                     v  00 00  1 1026      
;  3362             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#004422BB: 48:203154223 F0 01         u  00 0C  3 1027      
;  3363             jne @f
                    jne #004422D1         ;#004422C1: 165 0E                     v  00 00  1 1029      
;  3364             push rdi
                    push rdi              ;#004422C3: 48:127                     uv 00 80  1 1030      
;  3365             push qword[rsp+40]
                    push qword[rsp+40]    ;#004422C5: 48:377164044 28            np 00 10  2 1031      
;  3366             call :%pDealloc0
                    call #004422DE (:%pDealloc0)  ;#004422CA: 350 0F000000               v  00 00  1 1033      
;  3367             pop rdi
                    pop rdi               ;#004422CF: 48:137                     uv 80 00  1 1034      
;  3368       @@:
;  3369         pop rsi
                pop rsi                   ;#004422D1: 48:136                     vu 40 00  1 1034      
;  3370         pop rax
                pop rax                   ;#004422D3: 48:130                     uv 01 00  1 1035      
;  3371         pop rcx
                pop rcx                   ;#004422D5: 48:131                     vu 02 00  1 1035      
;  3372         pop rdx
                pop rdx                   ;#004422D7: 48:132                     uv 04 00  1 1036      
;  3373     []
;  3374         ret
                ret                       ;#004422D9: 303                        np 00 00  2 1037      
;  3375 
;  3376 --/*
;  3377 procedure :%pLoadMint(:%)
;  3378 end procedure -- (for Edita/CtrlQ)
;  3379 --*/
;  3380 --/*
;  3381 --  :%pLoadMint -- load a machine-sized (32/64-bit) integer
;  3382     :%pLoadMint -- finish loading a machine-sized (32/64-bit) integer
;  3383 ---------------
;  3384     [32]
;  3385 --      -- eax:=(int32)[edi]
;  3386         -- eax:=(int32)eax
;  3387 --DEV   -- edx = era
;  3388         -- All other registers are preserved (ebx:=0).
;  3389 --      mov eax,[edi]
;  3390         xor ebx,ebx         -- (save some grief)
;  3391         cmp eax,h4
;  3392         jle @f
;  3393             cmp byte[ebx+eax*4-1],#12
;  3394             jne :internalerror  -- DEV return carry flag?
;  3395             sub esp,8
;  3396             fld qword[ebx+eax*4]
;  3397             call :%down53
;  3398             fistp qword[esp]
;  3399             call :%near53
;  3400             mov eax,[esp]
;  3401             add esp,8
;  3402     [64]
;  3403 --      -- rax:=(int64)[rdi]
;  3404         -- rax:=(int64)rax
;  3405         -- All other registers are preserved (rbx:=0).
;  3406 --      mov rax,[rdi]
;  3407         mov r15,h4
;  3408         xor rbx,rbx         -- (save some grief)
;  3409         cmp rax,r15
;  3410         jle @f
;  3411             cmp byte[rbx+rax*4-1],#12
;  3412             jne :internalerror
;  3413             sub rsp,8
;  3414             fld tbyte[rbx+rax*4]
;  3415             call :%down64
;  3416             fistp qword[rsp]
;  3417             call :%near64
;  3418             pop rax
;  3419     []
;  3420       @@:
;  3421         ret
;  3422 --*/
;  3423 
;  3424 --/*
;  3425 procedure :%pDealloc[0](:%)
;  3426 end procedure -- (for Edita/CtrlQ)
;  3427 --*/
;  3428     :%pDealloc          -- (era==[e/rsp])
;  3429 --------------
;  3430         --
;  3431         -- called when a refcount [ebx+edx*4-8] drops to zero.
;  3432         -- Note the refcount itself need not actually be 0 when this is called,
;  3433         --     ie: "dec reg; jz deallocX; mov[ebx+edx*4-8],reg" is permitted.
;  3434         -- Invoke opDealloc iff era==[esp], ie when inlined and all those final
;  3435         --  jmp/jz from opcodes, otherwise push the era and invoke opDealloc0.
;  3436         -- All registers are trashed (except for esp and ebx[==0 on entry/exit]).
;  3437         --
;  3438     [32]
;  3439         push dword[esp] -- (era, discarded on exit)
;  3440     :%pDealloc0         -- (era @ [esp+4])
;  3441     -----------
;  3442         shl edx,2
;  3443         xor ebx,ebx -- (save some grief)
;  3444         test dword[edx-4],0x00FFFFFF    -- delete_routine in low 3 bytes of type
;  3445         jz @f
;  3446             push edx
;  3447             -- put a refcount of 1 back (normally but not necessarily 0 by now)
;  3448             mov dword[edx-8],1
;  3449             -- reconstruct the ref
;  3450             add edx,1
;  3451 --      mov eax,[DelRtn]            ; see builtins/pdelete.e/deletef()
;  3452             ror edx,2
;  3453 --      mov [DelRef],edx
;  3454 --      call eax
;  3455 --DEV:
;  3456 --          call :%DelRtn
;  3457 --        ::pDealloc12
;  3458             pop edx
;  3459             mov dword[edx-8],ebx        -- and re-zero the refcount
;  3460     [64]
;  3461         push qword[rsp]
                push qword[rsp]           ;#004422DA: 48:377064044               np 00 10  2 1039      
;  3462     :%pDealloc0         -- (era @ [rsp+8])
;  3463     -----------
;  3464         lea rax,[rbx-1]                         -- #FFFFFFFFFFFFFFFF, instead of...
                lea rax,[rbx-1]           ;#004422DE: 48:215103 FF               uv 01 08  1 1041      
;  3465         shl rdx,2
                shl rdx,2                 ;#004422E2: 48:301342 02               u  04 04  1 1042      
;  3466         shr rax,8                               -- #00FFFFFFFFFFFFFF (which, being 56 bits, we struggle to handle on 32-bits) [DEV]
                shr rax,8                 ;#004422E6: 48:301350 08               u  01 01  1 1043      
;  3467         xor rbx,rbx -- (save some grief)
                xor rbx,rbx               ;#004422EA: 48:061333                  vu 08 08  1 1043      
;  3468 --      test qword[rdx-8],0x00FFFFFFFFFFFFFF    -- delete_routine in low 7 bytes of type?
;  3469         test qword[rdx-8],rax                   -- delete_routine in low 7 bytes of type?
                test [rdx-8],rax          ;#004422ED: 48:205102 F8               uv 00 05  2 1044      
;  3470         jz @f
                jz #0044230B              ;#004422F1: 164 18                     v  00 00  1 1045      
;  3471             push rdx
                    push rdx              ;#004422F3: 48:122                     uv 00 04  1 1046      
;  3472             -- put a refcount of 1 back (normally but not necessarily 0 by now)
;  3473             mov qword[rdx-16],1
                    mov qword[rdx-16],1   ;#004422F5: 48:307102 F0 01000000      vu 00 04  1 1046      
;  3474             -- reconstruct the ref
;  3475             add rdx,1
                    add rdx,1             ;#004422FD: 48:203302 01               uv 04 04  1 1047      
;  3476 --      mov eax,[DelRtn]            ; see builtins/pdelete.e/deletef()
;  3477             ror rdx,2
                    ror rdx,2             ;#00442301: 48:301312 02               np 04 04  1 1048      
;  3478 --      mov [DelRef],edx
;  3479 --      call eax
;  3480 --DEV:
;  3481 --          call :%DelRtn
;  3482 --        ::pDealloc24
;  3483             pop rdx
                    pop rdx               ;#00442305: 48:132                     uv 04 00  1 1049      
;  3484             mov qword[rdx-16],rbx       -- and re-zero the refcount
                    mov [rdx-16],rbx      ;#00442307: 48:211132 F0               uv 00 0C  1 1052 04 *04*
;  3485     []
;  3486       @@:
;  3487     [32]
;  3488         cmp byte[edx-1],0x80
;  3489         jae @f
;  3490             -- float
;  3491 --          if debug
;  3492                 cmp byte[edx-1],0x12
;  3493                 jne :deallocerrunknowntype
;  3494 --          end if
;  3495 --          mov eax,edx
;  3496             lea eax,[edx-8]
;  3497             mov ecx,16
;  3498             mov edx,[esp+4]         -- era
;  3499             call :%pFreePool        -- free ecx bytes at eax
;  3500 --          ret
;  3501             ret 4
;  3502     [64]
;  3503         cmp byte[rdx-1],0x80
                cmp byte[rdx-1],#80       ;#0044230B: 200172 FF 80               u  00 04  2 1053      
;  3504         jae @f
                jae #00442333             ;#0044230F: 163 22                     v  00 00  1 1054      
;  3505             -- float
;  3506 --          if debug
;  3507                 cmp byte[rdx-1],0x12
                        cmp byte[rdx-1],#12  ;#00442311: 200172 FF 12               u  00 04  2 1055      
;  3508                 jne :deallocerrunknowntype
                        jne #00441B26     ;#00442315: 017205 0BF8FFFF            v  00 00  1 1056      
;  3509 --          end if
;  3510 --          mov rax,rdx
;  3511             lea rax,[rdx-16]
                    lea rax,[rdx-16]      ;#0044231B: 48:215102 F0               uv 01 04  1 1057      
;  3512 --          mov rcx,26
;  3513             mov rcx,28
                    mov rcx,28            ;#0044231F: 48:307301 1C000000         vu 02 00  1 1057      
;  3514 --          jmp :%pFreePool     -- free rcx bytes at rax
;  3515             mov rdx,[rsp+8]
                    mov rdx,[rsp+8]       ;#00442326: 48:213124044 08            uv 04 10  1 1058      
;  3516             call :%pFreePool    -- free rcx bytes at rax
                    call #00441FFA (:%pFreePool)  ;#0044232B: 350 CAFCFFFF               v  00 00  1 1058      
;  3517             ret 8
                    ret 8                 ;#00442330: 302 0800                   np 00 00  3 1059      
;  3518     []
;  3519       @@:
;  3520         je @f
                je #00442354              ;#00442333: 164 1F                     v  00 00  1 1062      
;  3521             -- string
;  3522     [32]
;  3523 --          if debug
;  3524                 cmp byte[edx-1],0x82
;  3525                 jne :deallocerrunknowntype
;  3526 --          end if
;  3527             mov ecx,[edx-16]        -- maxlen in bytes
;  3528             lea eax,[edx-16]        -- start of allocated memory (address of maxlen)
;  3529             mov edx,[esp+4]         -- era
;  3530             call :%pFreePool        -- free ecx bytes at eax
;  3531           ::dret
;  3532 --          ret
;  3533             ret 4
;  3534     [64]
;  3535 --          if debug
;  3536                 cmp byte[rdx-1],0x82
                        cmp byte[rdx-1],#82  ;#00442335: 200172 FF 82               u  00 04  2 1063      
;  3537                 jne :deallocerrunknowntype
                        jne #00441B26     ;#00442339: 017205 E7F7FFFF            v  00 00  1 1064      
;  3538 --          end if
;  3539             mov rcx,[rdx-32]        -- maxlen in bytes
                    mov rcx,[rdx-32]      ;#0044233F: 48:213112 E0               uv 02 04  1 1065      
;  3540             lea rax,[rdx-32]        -- start of allocated memory (address of maxlen)
                    lea rax,[rdx-32]      ;#00442343: 48:215102 E0               vu 01 04  1 1065      
;  3541 --          jmp :%pFreePool         -- free rcx bytes at rax
;  3542             mov rdx,[rsp+8]         -- era
                    mov rdx,[rsp+8]       ;#00442347: 48:213124044 08            uv 04 10  1 1066      
;  3543             call :%pFreePool        -- free rcx bytes at rax
                    call #00441FFA (:%pFreePool)  ;#0044234C: 350 A9FCFFFF               v  00 00  1 1066      
;  3544           ::dret
;  3545 --          ret
;  3546             ret 8
                    ret 8                 ;#00442351: 302 0800                   np 00 00  3 1067      
;  3547     []
;  3548       @@:
;  3549             -- sequence
;  3550     [32]
;  3551 --          if debug
;  3552 --              cmp byte[edx-1],0x80        -- (must be to get here)
;  3553 --              jne :deallocerrunknowntype
;  3554 --          end if
;  3555             mov dword[edx-8],0          -- clear refcount (just in case/see note above/tested to terminate loop)
;  3556          ::dseqloop
;  3557             mov ecx,[edx-12]            -- length in dwords
;  3558          ::dseqresetbase
;  3559             mov esi,edx                 -- start with base ptr, ie s[1]
;  3560          ::dseqelementloop
;  3561             sub ecx,1
;  3562     [64]
;  3563 --          if debug
;  3564 --              cmp byte[rdx-1],0x80        -- (must be to get here)
;  3565 --              jne :deallocerrunknowntype
;  3566 --          end if
;  3567             mov qword[rdx-16],0         -- clear refcount (just in case/see note above/tested to terminate loop)
                    mov qword[rdx-16],0   ;#00442354: 48:307102 F0 00000000      uv 00 04  1 1070      
;  3568          ::dseqloop
;  3569             mov rcx,[rdx-24]            -- length in qwords
                    mov rcx,[rdx-24]      ;#0044235C: 48:213112 E8               vu 02 04  1 1070      
;  3570             shl rcx,3                   -- length in bytes
                    shl rcx,3             ;#00442360: 48:301341 03               u  02 02  1 1071      
;  3571          ::dseqresetbase
;  3572             mov rsi,rdx                 -- start with base ptr, ie s[1]
                    mov rsi,rdx           ;#00442364: 48:213362                  vu 40 04  1 1071      
;  3573          ::dseqelementloop
;  3574             sub rcx,8
                    sub rcx,8             ;#00442367: 48:203351 08               uv 02 02  1 1072      
;  3575     []
;  3576             jge @f
                    jge #004423A3         ;#0044236B: 175 36                     v  00 00  1 1072      
;  3577     [32]
;  3578                 mov ecx,[edx-16]        -- maxlen in bytes
;  3579                 mov esi,[edx-8]         -- restore raw address (parent) from refcount
;  3580                 mov edi,[edx-4]         -- restore remaining items (parent) from type 
;  3581                 lea eax,[edx-20]        -- start of allocated memory (address of slack)
;  3582                 sub eax,[edx-20]        -- account for any slack
;  3583                 pushad
;  3584                 mov edx,[esp+36]        -- era
;  3585                 call :%pFreePool        -- free ecx bytes at eax
;  3586                 popad
;  3587                 test esi,esi            -- if no parent quit
;  3588                 jz :dret
;  3589                 mov edx,esi             -- raw address
;  3590                 mov ecx,edi             -- remaining items
;  3591                 jmp :dseqresetbase
;  3592     [64]
;  3593                 mov rcx,[rdx-32]        -- maxlen in bytes
                        mov rcx,[rdx-32]  ;#0044236D: 48:213112 E0               uv 02 04  1 1073      
;  3594                 mov rsi,[rdx-16]        -- restore raw address (parent) from refcount
                        mov rsi,[rdx-16]  ;#00442371: 48:213162 F0               vu 40 04  1 1073      
;  3595                 mov rdi,[rdx-8]         -- restore remaining items (parent) from type 
                        mov rdi,[rdx-8]   ;#00442375: 48:213172 F8               uv 80 04  1 1074      
;  3596                 lea rax,[rdx-40]        -- start of allocated memory (address of slack)
                        lea rax,[rdx-40]  ;#00442379: 48:215102 D8               vu 01 04  1 1074      
;  3597                 sub rax,[rdx-40]        -- account for any slack
                        sub rax,[rdx-40]  ;#0044237D: 48:053102 D8               uv 01 05  2 1075      
;  3598 --              pushad
;  3599                 push rdx    -- (align)
                        push rdx          ;#00442381: 48:122                     vu 00 04  1 1076      
;  3600                 push rsi
                        push rsi          ;#00442383: 48:126                     uv 00 40  1 1077      
;  3601                 push rdi
                        push rdi          ;#00442385: 48:127                     vu 00 80  1 1077      
;  3602                 mov rdx,[rsp+32]        -- era
                        mov rdx,[rsp+32]  ;#00442387: 48:213124044 20            uv 04 10  1 1078      
;  3603                 call :%pFreePool        -- free rcx bytes at rax
                        call #00441FFA (:%pFreePool)  ;#0044238C: 350 69FCFFFF               v  00 00  1 1078      
;  3604 --              popad
;  3605                 pop rdi
                        pop rdi           ;#00442391: 48:137                     uv 80 00  1 1079      
;  3606                 pop rsi
                        pop rsi           ;#00442393: 48:136                     vu 40 00  1 1079      
;  3607                 pop edx
                        pop rdx           ;#00442395: 132                        uv 04 00  1 1080      
;  3608                 test rsi,rsi            -- if no parent quit
                        test rsi,rsi      ;#00442396: 48:205366                  vu 00 40  1 1080      
;  3609                 jz :dret
                        jz #00442351      ;#00442399: 164 B6                     v  00 00  1 1081      
;  3610                 mov rdx,rsi             -- raw address
                        mov rdx,rsi       ;#0044239B: 48:213326                  uv 04 40  1 1082      
;  3611                 mov rcx,rdi             -- remaining items
                        mov rcx,rdi       ;#0044239E: 48:213317                  vu 02 80  1 1082      
;  3612                 jmp :dseqresetbase
                        jmp #00442364     ;#004423A1: 353 C1                     v  00 00  1 1083      
;  3613     []
;  3614           @@:
;  3615     [32]
;  3616             mov edi,[esi+ecx*4]
;  3617             xor eax,eax                 -- for use as base (lessens AGI to boot!)
;  3618             cmp edi,h4  
;  3619             jl :dseqelementloop
;  3620             sub dword[eax+edi*4-8],1    -- decrement refcount
;  3621             lea eax,[eax+edi*4]
;  3622             jnz :dseqelementloop
;  3623             test dword[eax-4],0x00FFFFFF
;  3624     [64]
;  3625             mov rdi,[rsi+rcx]
                    mov rdi,[rsi+rcx]     ;#004423A3: 48:213074016               uv 80 42  1 1086    *02*
;  3626             xor rax,rax                 -- for use as base (lessens AGI to boot!)
                    xor rax,rax           ;#004423A7: 48:061300                  vu 01 01  1 1086      
;  3627 --          cmp rdi,h4  
;  3628             mov r15,h4
                    mov r15,h4            ;#004423AA: 49:277 0000000000000040    uv 8000 00  1 1087      
;  3629             cmp rdi,r15
                    cmp rdi,r15           ;#004423B4: 49:073377                  uv 00 8080  1 1088 8000   
;  3630             jl :dseqelementloop
                    jl #00442367          ;#004423B7: 174 AE                     v  00 00  1 1088      
;  3631             sub qword[rax+rdi*4-16],1   -- decrement refcount
                    sub qword[rax+rdi*4-16],1  ;#004423B9: 48:203154270 F0 01         u  00 81  3 1089      
;  3632             lea rax,[rax+rdi*4]
                    lea rax,[rax+rdi*4]   ;#004423BF: 48:215004270               vu 01 81  1 1091      
;  3633             jnz :dseqelementloop
                    jnz #00442367         ;#004423C3: 165 A2                     v  00 00  1 1092      
;  3634 --          test dword[eax-4],0x00FFFFFF
;  3635 --[DEV check the listing:]
;  3636             test qword[rax-8],-256  -- delete_routine in low 7 bytes of type 
                    test qword[rax-8],-256  ;#004423C5: 48:367100 F8 00FFFFFF      u  00 01  2 1095    *01*
;  3637     []
;  3638             jz :nodeleteroutine
                    jz #004423E7          ;#004423CD: 164 18                     v  00 00  1 1096      
;  3639     [32]
;  3640                 pushad
;  3641                 mov dword[eax-8],1      -- put a refcount of 1 back
;  3642                 add eax,1               -- reconstruct the ref
;  3643 --      mov edx,[DelRtn]
;  3644                 ror eax,2
;  3645 --      mov [DelRef],eax
;  3646 --      call edx
;  3647                 mov edx,eax
;  3648 --DEV
;  3649 --              call :%DelRtn
;  3650 --            ::pDealloc40
;  3651                 popad
;  3652                 mov dword[eax-8],0
;  3653     [64]
;  3654                 push rdx
                        push rdx          ;#004423CF: 48:122                     uv 00 04  1 1097      
;  3655                 --rsi?
;  3656                 mov qword[rdx-16],1     -- puts a refcount of 1 back
                        mov qword[rdx-16],1  ;#004423D1: 48:307102 F0 01000000      vu 00 04  1 1097      
;  3657                 add rdx,1               -- reconstruct the ref
                        add rdx,1         ;#004423D9: 48:203302 01               uv 04 04  1 1098      
;  3658 --      mov rdx,[DelRtn]            ; see builtins/pdelete.e/deletef()
;  3659                 ror rdx,2
                        ror rdx,2         ;#004423DD: 48:301312 02               np 04 04  1 1099      
;  3660 --      mov [DelRef],eax
;  3661 --      call edx
;  3662 --DEV:
;  3663 --              call :%DelRtn
;  3664 --            ::pDealloc24a
;  3665                 pop rdx
                        pop rdx           ;#004423E1: 48:132                     uv 04 00  1 1100      
;  3666                 mov qword[rdx-16],rbx       -- and re-zero the refcount
                        mov [rdx-16],rbx  ;#004423E3: 48:211132 F0               uv 00 0C  1 1103 04 *04*
;  3667     []
;  3668           ::nodeleteroutine
;  3669     [32]
;  3670             cmp byte[eax-1],0x80
;  3671     [64]
;  3672             cmp byte[rax-1],0x80
                    cmp byte[rax-1],#80   ;#004423E7: 200170 FF 80               u  00 01  2 1104      
;  3673     []
;  3674             jnb @f
                    jnb #0044241D         ;#004423EB: 163 30                     v  00 00  1 1105      
;  3675             -- float
;  3676     [32]
;  3677 --              if debug
;  3678                     cmp byte[eax-1],0x12
;  3679                     jne :deallocerrunknowntype
;  3680 --              end if
;  3681                 pushad
;  3682                 sub eax,8
;  3683                 mov ecx,16
;  3684                 mov edx,[esp+36]        -- era
;  3685                 call :%pFreePool        -- free ecx bytes at eax
;  3686                 popad
;  3687     [64]
;  3688 --              if debug
;  3689                     cmp byte[rax-1],0x12
                            cmp byte[rax-1],#12  ;#004423ED: 200170 FF 12               u  00 01  2 1106      
;  3690                     jne :deallocerrunknowntype
                            jne #00441B26  ;#004423F1: 017205 2FF7FFFF            v  00 00  1 1107      
;  3691 --              end if
;  3692 --              pushad
;  3693                 push rcx
                        push rcx          ;#004423F7: 48:121                     uv 00 02  1 1108      
;  3694                 push rdx
                        push rdx          ;#004423F9: 48:122                     vu 00 04  1 1108      
;  3695                 push rsi
                        push rsi          ;#004423FB: 48:126                     uv 00 40  1 1109      
;  3696                 sub rax,16
                        sub rax,16        ;#004423FD: 48:203350 10               vu 01 01  1 1109      
;  3697 --              mov rcx,26
;  3698                 mov rcx,28
                        mov rcx,28        ;#00442401: 48:307301 1C000000         uv 02 00  1 1110      
;  3699                 mov rdx,[rsp+32]        -- era
                        mov rdx,[rsp+32]  ;#00442408: 48:213124044 20            vu 04 10  1 1110      
;  3700                 call :%pFreePool        -- free rcx bytes at rax
                        call #00441FFA (:%pFreePool)  ;#0044240D: 350 E8FBFFFF               v  00 00  1 1111      
;  3701 --              popad
;  3702                 pop rsi
                        pop rsi           ;#00442412: 48:136                     uv 40 00  1 1112      
;  3703                 pop rdx
                        pop rdx           ;#00442414: 48:132                     vu 04 00  1 1112      
;  3704                 pop rcx
                        pop rcx           ;#00442416: 48:131                     uv 02 00  1 1113      
;  3705     []
;  3706                 jmp :dseqelementloop
                        jmp #00442367     ;#00442418: 351 4AFFFFFF               v  00 00  1 1113      
;  3707           @@:
;  3708     [32]
;  3709                 mov edi,[eax-12]        -- length
;  3710     [64]
;  3711                 mov rdi,[rax-24]        -- length
                        mov rdi,[rax-24]  ;#0044241D: 48:213170 E8               uv 80 01  1 1114      
;  3712     []
;  3713                 je @f
                        je #00442450      ;#00442421: 164 2D                     v  00 00  1 1114      
;  3714                     -- string
;  3715     [32]
;  3716 --                  if debug
;  3717                         cmp byte[eax-1],0x82
;  3718                         jne :deallocerrunknowntype
;  3719 --                  end if
;  3720                     pushad
;  3721 --  push edx
;  3722 --  push ecx
;  3723                     mov ecx,[eax-16]
;  3724                     sub eax,16
;  3725                     mov edx,[esp+36]    -- era
;  3726                     call :%pFreePool    -- free ecx bytes at eax
;  3727                     popad
;  3728 --  pop ecx
;  3729 --  pop edx
;  3730     [64]
;  3731 --                  if debug
;  3732                         cmp byte[rax-1],0x82
                                cmp byte[rax-1],#82  ;#00442423: 200170 FF 82               u  00 01  2 1115      
;  3733                         jne :deallocerrunknowntype
                                jne #00441B26  ;#00442427: 017205 F9F6FFFF            v  00 00  1 1116      
;  3734 --                  end if
;  3735 --                  pushad
;  3736                     push rcx
                            push rcx      ;#0044242D: 48:121                     uv 00 02  1 1117      
;  3737                     push rdx
                            push rdx      ;#0044242F: 48:122                     vu 00 04  1 1117      
;  3738                     push rsi
                            push rsi      ;#00442431: 48:126                     uv 00 40  1 1118      
;  3739 --17/12/14:
;  3740 --                  mov ecx,[eax-16]
;  3741 --                  sub eax,16
;  3742                     mov rcx,[rax-32]
                            mov rcx,[rax-32]  ;#00442433: 48:213110 E0               vu 02 01  1 1118      
;  3743                     sub rax,32
                            sub rax,32    ;#00442437: 48:203350 20               uv 01 01  1 1119      
;  3744                     mov rdx,[rsp+32]    -- era
                            mov rdx,[rsp+32]  ;#0044243B: 48:213124044 20            vu 04 10  1 1119      
;  3745                     call :%pFreePool    -- free rcx bytes at rax
                            call #00441FFA (:%pFreePool)  ;#00442440: 350 B5FBFFFF               v  00 00  1 1120      
;  3746 --                  popad
;  3747                     pop rsi
                            pop rsi       ;#00442445: 48:136                     uv 40 00  1 1121      
;  3748                     pop rdx
                            pop rdx       ;#00442447: 48:132                     vu 04 00  1 1121      
;  3749                     pop rcx
                            pop rcx       ;#00442449: 48:131                     uv 02 00  1 1122      
;  3750     []
;  3751                     jmp :dseqelementloop
                            jmp #00442367  ;#0044244B: 351 17FFFFFF               v  00 00  1 1122      
;  3752           @@:
;  3753                 -- sequence
;  3754     [32]
;  3755 --              if debug
;  3756 --                  cmp byte[eax-1],0x80        -- (must be to get here)
;  3757 --                  jne :deallocerrunknowntype
;  3758 --              end if
;  3759                 mov [eax-8],edx     -- save raw (parent) in refcount (otherwise zero)
;  3760                 mov [eax-4],ecx     -- save remaining items in type (otherwise seq, ie #80)
;  3761                 mov edx,eax         -- new raw (child) address
;  3762     [64]
;  3763 --              if debug
;  3764 --                  cmp byte[rax-1],0x80        -- (must be to get here)
;  3765 --                  jne :deallocerrunknowntype
;  3766 --              end if
;  3767                 mov [rax-16],rdx    -- save raw (parent) in refcount (otherwise zero)
                        mov [rax-16],rdx  ;#00442450: 48:211120 F0               uv 00 05  1 1123      
;  3768                 mov [rax-8],rcx     -- save remaining items in type (otherwise seq, ie #80)
                        mov [rax-8],rcx   ;#00442454: 48:211110 F8               vu 00 03  1 1123      
;  3769                 mov rdx,rax         -- new raw (child) address
                        mov rdx,rax       ;#00442458: 48:213320                  uv 04 01  1 1124      
;  3770     []
;  3771                 jmp :dseqloop
                        jmp #0044235C     ;#0044245B: 351 FCFEFFFF               v  00 00  1 1124      
;  3772 
;  3773 --if debug
;  3774 --deallocerrunknowntype:
;  3775 --  call puthex32
;  3776 --  mov esi,deallocunknowntype
;  3777 --  call putstr
;  3778 --  jmp showerror
;  3779 --end if
;  3780 
;  3781 --;;DEV trigger p.err creation...
;  3782 --if used HeapFail
;  3783 --HeapFail:
;  3784 --  mov esi,Heaperror
;  3785 --  call putstr
;  3786 --;;int3
;  3787 --; invoke ExitProcess,1
;  3788 --end if
;  3789 --
;  3790 --;;DEV remove this?:
;  3791 --showerror:
;  3792 --  call showcr
;  3793 --  call showcr
;  3794 --  mov esi,pressenter
;  3795 --  call putstr
;  3796 --  call showcr
;  3797 --  call wait_key
;  3798 --  call opFreeCons
;  3799 --;DEV??? (if close() is now in hll)
;  3800 --  call opClosem1
;  3801 --  invoke ExitProcess,1
;  3802 
;  3803 --!*/
;  3804 
;  3805 --DEV allocate_data() etc might be an issue..
;  3806 --DEV/SUG put guards on all allocate and free, reduce limits accordingly. (NO: pRoot should be enough!)
;  3807 --/*
;  3808 procedure :%pAlloc(:%)
;  3809 end procedure -- (for Edita/CtrlQ)
;  3810 --*/
;  3811     :%pAlloc
;  3812 ------------
;  3813 --DEV linked list: nSize (4/8) -> nSize,pNext,pPrev (12/24), and matching changes to limits (pHeapA.e anyone?).
;  3814 --  pAlloc needs:
;  3815 --      enter_cs(0)     -- (if >1 tcb exists?)
;  3816 --      this.next = pAhead
;  3817 --      this.prev = null
;  3818 --      pAhead = this
;  3819 --      leave_cs(0)     -- ("", saved)
;  3820 --  pFree needs:
;  3821 --      enter_cs(0)     -- (if >1 tcb exists?)
;  3822 --      if this.prev==null then
;  3823 --          pAhead:=this.next
;  3824 --      else
;  3825 --          this.prev.next:=this.next
;  3826 --      end if
;  3827 --      if this.next!==null then
;  3828 --          this.next.prev:=this.prev
;  3829 --      end if
;  3830 --      leave_cs(0)     -- ("", saved)
;  3831     [32]
;  3832         -- size in ecx, result addr in edi
;  3833         xor ebx,ebx -- (save some grief)
;  3834         cmp ecx,h4  --DEV :%pLoadMint?
;  3835         jl @f
;  3836             cmp byte[ebx+ecx*4-1],0x12
;  3837             jne :e37atambpi  -- argument to allocate must be positive integer
;  3838             sub esp,8
;  3839             fld qword[ebx+ecx*4]
;  3840             call :%down53
;  3841             fistp qword[esp]
;  3842             call :%near53
;  3843             mov ecx,[esp]
;  3844             add esp,8
;  3845             test ecx,ecx
;  3846             jle :e37atambpi  -- argument to allocate must be positive integer
;  3847       @@:
;  3848         add ecx,4           -- for nSize
;  3849         mov edx,[esp]       -- era
;  3850         push edi
;  3851         call :%pGetPool     -- (trashes all registers)
;  3852         -- result is edx bytes at eax, but we use first 4 bytes to save the size, for free().
;  3853         test eax,eax
;  3854         jz @f
;  3855             mov [eax],edx   -- so this is 16 when returning 12 bytes of useable space (at eax+4).
;  3856             add eax,4       -- for nSize (see also "Minor point" above)
;  3857       @@:
;  3858         pop edi
;  3859         push ebx
;  3860         push eax
;  3861         fild qword[esp]
;  3862         add esp,8
;  3863         jmp :%pStoreFlt     -- [edi]:=st0
;  3864     [64]
;  3865         -- size in rcx, result addr in rdi
;  3866         xor rbx,rbx -- (save some grief)
                xor rbx,rbx               ;#00442460: 48:061333                  uv 08 08  1 1125      
;  3867         mov r15,h4
                mov r15,h4                ;#00442463: 49:277 0000000000000040    vu 8000 00  1 1125      
;  3868         push rdi
                push rdi                  ;#0044246D: 48:127                     uv 00 80  1 1126      
;  3869         cmp rcx,r15
                cmp rcx,r15               ;#0044246F: 49:073317                  vu 00 8002  1 1126      
;  3870         jl @f
                jl #0044249E              ;#00442472: 174 2A                     v  00 00  1 1127      
;  3871             cmp byte[rbx+rcx*4-1],0x12
                    cmp byte[rbx+rcx*4-1],#12  ;#00442474: 200174213 FF 12            u  00 0A  2 1128      
;  3872             jne :e37atambpi  -- argument to allocate must be positive integer
                    jne #00441B49         ;#00442479: 017205 CAF6FFFF            v  00 00  1 1129      
;  3873             sub rsp,8
                    sub rsp,8             ;#0044247F: 48:203354 08               uv 10 10  1 1130      
;  3874             fld tbyte[rbx+rcx*4]
                    fld tbyte[rbx+rcx*4]  ;#00442483: 333054213                  np 00 0A  3 1131      
;  3875             call :%down64
                    call #0044139E (:%down64)  ;#00442486: 350 13EFFFFF               v  00 00  1 1134      
;  3876             fistp qword[rsp]
                    fistp qword[rsp]      ;#0044248B: 337074044                  np 00 10  6 1135      
;  3877             call :%near64
                    call #004413A5 (:%near64)  ;#0044248E: 350 12EFFFFF               v  00 00  1 1141      
;  3878             pop rcx
                    pop rcx               ;#00442493: 48:131                     uv 02 00  1 1142      
;  3879             test rcx,rcx
                    test rcx,rcx          ;#00442495: 48:205311                  uv 00 02  1 1143 02   
;  3880             jle :e37atambpi  -- argument to allocate must be positive integer
                    jle #00441B49         ;#00442498: 017216 ABF6FFFF            v  00 00  1 1143      
;  3881       @@:
;  3882         add rcx,8   -- for nSize
                add rcx,8                 ;#0044249E: 48:203301 08               uv 02 02  1 1144      
;  3883         mov rdx,[rsp+8]     -- era
                mov rdx,[rsp+8]           ;#004424A2: 48:213124044 08            vu 04 10  1 1144      
;  3884         call :%pGetPool
                call #00441B4D (:%pGetPool)  ;#004424A7: 350 A1F6FFFF               v  00 00  1 1145      
;  3885         -- result is rdx bytes at rax, but we use first 8 bytes to save the size, for free().
;  3886         test rax,rax
                test rax,rax              ;#004424AC: 48:205300                  uv 00 01  1 1146      
;  3887         jz @f
                jz #004424B8              ;#004424AF: 164 07                     v  00 00  1 1146      
;  3888             mov [rax],rdx -- so this is 28 when returning 20 bytes of useable space (at rax+8).
                    mov [rax],rdx         ;#004424B1: 48:211020                  uv 00 05  1 1147      
;  3889             add rax,8   -- for nSize (see also "Minor point" above)
                    add rax,8             ;#004424B4: 48:203300 08               vu 01 01  1 1147      
;  3890       @@:
;  3891         pop rdi
                pop rdi                   ;#004424B8: 48:137                     uv 80 00  1 1148      
;  3892         push rax
                push rax                  ;#004424BA: 48:120                     vu 00 01  1 1148      
;  3893         fild qword[rsp]
                fild qword[rsp]           ;#004424BC: 337054044                  np 00 10  3 1149      
;  3894         add rsp,8
                add rsp,8                 ;#004424BF: 48:203304 08               uv 10 10  1 1152      
;  3895         jmp :%pStoreFlt     -- [rdi]:=st0
                jmp #004421B0 (:%pStoreFlt)  ;#004424C3: 351 E8FCFFFF               v  00 00  1 1152      
;  3896     []
;  3897 
;  3898 --/*
;  3899 procedure :%pFree(:%)
;  3900 end procedure -- (for Edita/CtrlQ)
;  3901 --*/
;  3902     :%pFree
;  3903 ------------
;  3904     [32]
;  3905         -- addr in eax
;  3906 --DEV should free(0) crash? -- (methinks yes)
;  3907         xor ebx,ebx -- (save some grief)
;  3908         cmp eax,h4  --DEV :%pLoadMint
;  3909         jl @f
;  3910             cmp byte[ebx+eax*4-1],0x12
;  3911             jne :e38atfmba   -- argument to free must be an atom
;  3912             sub esp,8
;  3913             fld qword[ebx+eax*4]
;  3914             call :%down53
;  3915             fistp qword[esp]
;  3916             call :%near53
;  3917             mov eax,[esp]
;  3918             add esp,8
;  3919       @@:
;  3920         mov ecx,[eax-4] -- retrieve size
;  3921         sub eax,4
;  3922         mov edx,[esp]   -- era
;  3923     [64]
;  3924         -- addr in rax
;  3925         mov r15,h4
                mov r15,h4                ;#004424C8: 49:277 0000000000000040    uv 8000 00  1 1153      
;  3926         xor rbx,rbx -- (save some grief)
                xor rbx,rbx               ;#004424D2: 48:061333                  vu 08 08  1 1153      
;  3927         cmp rax,r15
                cmp rax,r15               ;#004424D5: 49:073307                  uv 00 8001  1 1154      
;  3928         jl @f
                jl #004424FB              ;#004424D8: 174 21                     v  00 00  1 1154      
;  3929             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#004424DA: 200174203 FF 12            u  00 09  2 1155      
;  3930             jne :e38atfmba   -- argument to free must be an atom
                    jne #00441B4B         ;#004424DF: 017205 66F6FFFF            v  00 00  1 1156      
;  3931             sub rsp,8
                    sub rsp,8             ;#004424E5: 48:203354 08               uv 10 10  1 1157      
;  3932             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#004424E9: 333054203                  np 00 09  3 1158      
;  3933             call :%down64
                    call #0044139E (:%down64)  ;#004424EC: 350 ADEEFFFF               v  00 00  1 1161      
;  3934             fistp qword[rsp]
                    fistp qword[rsp]      ;#004424F1: 337074044                  np 00 10  6 1162      
;  3935             call :%near64
                    call #004413A5 (:%near64)  ;#004424F4: 350 ACEEFFFF               v  00 00  1 1168      
;  3936             pop rax
                    pop rax               ;#004424F9: 48:130                     uv 01 00  1 1169      
;  3937       @@:
;  3938         mov rcx,[rax-8] -- retrieve size
                mov rcx,[rax-8]           ;#004424FB: 48:213110 F8               uv 02 01  1 1172 01 *01*
;  3939         sub rax,8
                sub rax,8                 ;#004424FF: 48:203350 08               vu 01 01  1 1172      
;  3940         mov rdx,[rsp]   -- era
                mov rdx,[rsp]             ;#00442503: 48:213024044               uv 04 10  1 1173      
;  3941     []
;  3942         call :%pFreePool
                call #00441FFA (:%pFreePool)  ;#00442507: 350 EEFAFFFF               v  00 00  1 1173      
;  3943         ret
                ret                       ;#0044250C: 303                        np 00 00  2 1174      
;  3944 
;  3945 --SUG: (now that I've written them, maybe I'll use them... though admittedly IncRef just looks like pure pointless overhead...)
;  3946 --     (we might want cmp h4 inside these calls, which may alter the balance in favour of them being useful...)
;  3947 --/*
;  3948     :%opIncRef
;  3949 --------------
;  3950         [32]
;  3951             -- on entry edx must be set, all registers preserved
;  3952             cmp edx,h4
;  3953             jl @f
;  3954                 add dword[ebx+edx*4-8],1
;  3955           @@:
;  3956         [64]
;  3957             -- on entry rdx must be set, all registers preserved
;  3958             mov r15,h4
;  3959             cmp edx,r15
;  3960             jl @f
;  3961                 add qword[rbx+rdx*4-16],1
;  3962           @@:
;  3963         []
;  3964         ret
;  3965     :%opDecRef
;  3966 --------------
;  3967         [32]
;  3968             -- on entry esi and edx must be set, all registers preserved
;  3969             cmp edx,h4
;  3970             jl @f
;  3971                 sub dword[ebx+edx*4-8],1
;  3972                 jnz @f
;  3973                     pushad
;  3974                     mov dword[esi],ebx
;  3975                     push dword[esp+32]
;  3976                     call :%pDealloc0
;  3977                     popad
;  3978         [64]
;  3979             -- on entry rsi and rdx must be set, no(?) registers preserved
;  3980             mov r15,h4
;  3981             cmp rdx,r15
;  3982             jl @f
;  3983                 sub qword[rbx+rdx*4-16],1
;  3984                 jnz @f
;  3985 --                  pop al  -- (yet to determine which registers need preserving)
;  3986                     mov qword[rsi],rbx
;  3987 --                  push qword[rsp+40??]
;  3988                     push qword[rsp]
;  3989                     call :%pDealloc0
;  3990         []
;  3991           @@:
;  3992             ret
;  3993 --*/
;  3994 
;  3995 --/*
;  3996 procedure :%pCleanupAll(:%)
;  3997 end procedure -- (for Edita/CtrlQ)
;  3998 --*/
;  3999     :%pCleanupAll
;  4000 -----------------
;  4001 --          call :%pFreeStack
;  4002 --      [32]
;  4003 --      [64]
;  4004 --      []
;  4005             ret
                    ret                   ;#0044250D: 303                        np 00 00  2 1176      
;  4006 
;  4007 --/*
;  4008 procedure :%pInitCS(:%)
;  4009 end procedure -- (for Edita/CtrlQ)
;  4010 --*/
;  4011     :%pInitCS
;  4012 -------------
;  4013         [32]
;  4014             -- calling convention:
;  4015             -- lea edi,[res]            -- (integer)
;  4016             -- call :%pInitCS           -- [edi]:=init_cs()
;  4017             -- (trashes all registers)
;  4018             mov edx,[esp]               -- era
;  4019             mov ecx,4                   -- for nSize
;  4020             push edi
;  4021         [64]
;  4022             -- calling convention:
;  4023             -- lea rdi,[res]            -- (integer)
;  4024             -- call :%pInitCS           -- [rdi]:=init_cs()
;  4025             -- (trashes all registers)
;  4026             mov rdx,[rsp]               -- era
                    mov rdx,[rsp]         ;#0044250E: 48:213024044               uv 04 10  1 1178      
;  4027             mov rcx,8                   -- for nSize
                    mov rcx,8             ;#00442512: 48:307301 08000000         vu 02 00  1 1178      
;  4028             push rdi
                    push rdi              ;#00442519: 48:127                     uv 00 80  1 1179      
;  4029         [PE32]
;  4030             add ecx,24                  -- win32 critical section size
;  4031         [PE64]
;  4032             add rcx,40                  -- win64 critical section size
                    add rcx,40            ;#0044251B: 48:203301 28               vu 02 02  1 1179      
;  4033         [ELF32]
;  4034             add ecx,4                   -- linux: single DWORD futex,
;  4035         [ELF64]
;  4036             add rcx,4                   --        even on 64-bit
;  4037         []
;  4038             call :%pGetPool             -- (trashes all registers)
                    call #00441B4D (:%pGetPool)  ;#0044251F: 350 29F6FFFF               v  00 00  1 1180      
;  4039         [32]
;  4040             test eax,eax
;  4041 --          jz :memoryallocationfailure
;  4042             jnz @f
;  4043                 int3
;  4044           @@:
;  4045             mov [eax],edx               -- save nSize
;  4046         [PE32]
;  4047             lea ecx,[eax+4]
;  4048         [ELF32]
;  4049             mov [eax+4],ebx             -- (a mutex (int32) of 0 is enough)
;  4050         [32]
;  4051             shr eax,2
;  4052             pop edi
;  4053             call :%pStoreMint           -- [edi]:=eax (all registers preserved)
;  4054         [PE32]
;  4055             push ecx                                    -- lpCriticalSection
;  4056             call "kernel32.dll","InitializeCriticalSection"
;  4057         [64]
;  4058             test rax,rax
                    test rax,rax          ;#00442524: 48:205300                  uv 00 01  1 1181      
;  4059 --          jz :memoryallocationfailure
;  4060             jnz @f
                    jnz #0044252A         ;#00442527: 165 01                     v  00 00  1 1181      
;  4061                 int3
                        int3              ;#00442529: 314                        np 00 00 13 1182      
;  4062           @@:
;  4063             mov [rax],rdx               -- save nSize
                    mov [rax],rdx         ;#0044252A: 48:211020                  uv 00 05  1 1195      
;  4064         [PE64]
;  4065             lea rcx,[rax+8]             -- lpCriticalSection (p1)
                    lea rcx,[rax+8]       ;#0044252D: 48:215110 08               vu 02 01  1 1195      
;  4066         [ELF64]
;  4067             mov dword[rax+8],ebx        -- (a mutex (int32) of 0 is enough)
;  4068         [64]
;  4069             shr rax,2
                    shr rax,2             ;#00442531: 48:301350 02               u  01 01  1 1196      
;  4070             pop rdi
                    pop rdi               ;#00442535: 48:137                     vu 80 00  1 1196      
;  4071             call :%pStoreMint           -- [rdi]:=rax (preserves rax/rcx/rdx/rsi/rdi)
                    call #0044228A (:%pStoreMint)  ;#00442537: 350 4EFDFFFF               v  00 00  1 1197      
;  4072         [PE64]
;  4073             mov rax,rsp -- put 2 copies of rsp onto the stack...
                    mov rax,rsp           ;#0044253C: 48:213304                  uv 01 10  1 1198      
;  4074             push rsp
                    push rsp              ;#0044253F: 48:124                     vu 00 10  1 1198      
;  4075             push rax
                    push rax              ;#00442541: 48:120                     uv 00 01  1 1199      
;  4076             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#00442543: 48:203314 08               vu 10 10  1 1199      
;  4077                         -- if on entry rsp was xxx8: both copies remain on the stack
;  4078                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  4079                         -- obviously rsp is now xxx8, whatever alignment we started with
;  4080             sub rsp,8*5                 -- minimum 4 param shadow space, and align/somewhere to save rax
                    sub rsp,40            ;#00442547: 48:203354 28               uv 10 10  1 1200      
;  4081 --          (rcx already set)
;  4082             call "kernel32.dll","InitializeCriticalSection"
                    call [InitializeCriticalSection]  ;#0044254B: 377025 77EBFBFF            np 00 00  2 1201      
;  4083 --          add rsp,8*5
;  4084 --          pop rsp
;  4085             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#00442551: 48:213144044 28            uv 10 10  1 1203      
;  4086         []
;  4087             ret
                    ret                   ;#00442556: 303                        np 00 00  2 1204      
;  4088 
;  4089 --/*
;  4090 procedure :%pDeleteCS(:%)
;  4091 end procedure -- (for Edita/CtrlQ)
;  4092 --*/
;  4093     :%pDeleteCS
;  4094 ---------------
;  4095         [32]
;  4096             -- calling convention
;  4097             --  mov eax,[mycs]
;  4098             --  mov esi,mycs        -- var no, if it can be unassigned [DEV]
;  4099             --  call :%pDeleteCS    -- delete_cs(eax)
;  4100 --          test eax,eax
;  4101 --          jz @f
;  4102             shl eax,2
;  4103             jz :unassignedcs
;  4104 --          jnz @f
;  4105 --              mov eax,[stdcs]
;  4106 --              mov [stdcs],ebx
;  4107 --        @@:
;  4108         [PE32]
;  4109 --          lea ecx,[ebx+eax*4+4]
;  4110             lea ecx,[eax+4]
;  4111             push eax
;  4112             push ecx                                -- lpCriticalSection
;  4113             call "kernel32","DeleteCriticalSection"
;  4114             pop eax
;  4115 --      [ELF32]
;  4116 --          pop al          -- (nowt needed)
;  4117         [64]
;  4118             -- calling convention
;  4119             --  mov rax,[mycs]
;  4120             --  mov rsi,mycs        -- var no, if it can be unassigned
;  4121             --  call :%pDeleteCS    -- delete_cs(rax)
;  4122 --          test rax,rax
;  4123 --          jz @f
;  4124             shl rax,2
                    shl rax,2             ;#00442557: 48:301340 02               u  01 01  1 1206      
;  4125             jz :unassignedcs
                    jz #004425B9          ;#0044255B: 164 5C                     v  00 00  1 1206      
;  4126 --          jnz @f
;  4127 --              mov rax,[stdcs]
;  4128 --              mov [stdcs],rbx
;  4129 --        @@:
;  4130         [PE64]
;  4131             push rax
                    push rax              ;#0044255D: 48:120                     uv 00 01  1 1207      
;  4132             mov rcx,rsp -- put 2 copies of rsp onto the stack...
                    mov rcx,rsp           ;#0044255F: 48:213314                  vu 02 10  1 1207      
;  4133             push rsp
                    push rsp              ;#00442562: 48:124                     uv 00 10  1 1208      
;  4134             push rcx
                    push rcx              ;#00442564: 48:121                     vu 00 02  1 1208      
;  4135             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#00442566: 48:203314 08               uv 10 10  1 1209      
;  4136                         -- if on entry rsp was xxx8: both copies remain on the stack
;  4137                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  4138                         -- obviously rsp is now xxx8, whichever alignment we started with
;  4139             sub rsp,8*5 -- minimum 4 param shadow space, and align
                    sub rsp,40            ;#0044256A: 48:203354 28               uv 10 10  1 1210 10   
;  4140 --          lea rcx,[rbx+rax*4+8]                   -- lpCriticalSection
;  4141             lea rcx,[rax+8]
                    lea rcx,[rax+8]       ;#0044256E: 48:215110 08               vu 02 01  1 1210      
;  4142             call "kernel32","DeleteCriticalSection"
                    call [DeleteCriticalSection]  ;#00442572: 377025 C8EAFBFF            np 00 00  2 1211      
;  4143 --          add rsp,8*5
;  4144 --          pop rsp
;  4145             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#00442578: 48:213144044 28            uv 10 10  1 1213      
;  4146             pop rax
                    pop rax               ;#0044257D: 48:130                     vu 01 00  1 1213      
;  4147 --      [ELF64]
;  4148 --          pop al              -- (nowt needed)
;  4149         [32]
;  4150 --          mov ecx,[ebx+eax*2] -- retrieve size
;  4151             mov ecx,[eax]       -- retrieve size
;  4152 --          shl eax,2
;  4153             mov edx,[esp]       -- era
;  4154         [64]
;  4155 --          mov rcx,[rbx+rax*2] -- retrieve size
;  4156             mov rcx,[rax]       -- retrieve size
                    mov rcx,[rax]         ;#0044257F: 48:213010                  uv 02 01  1 1216    *01*
;  4157 --          shl rax,2
;  4158             mov rdx,[rsp]       -- era
                    mov rdx,[rsp]         ;#00442582: 48:213024044               vu 04 10  1 1216      
;  4159         []
;  4160             call :%pFreePool
                    call #00441FFA (:%pFreePool)  ;#00442586: 350 6FFAFFFF               v  00 00  1 1217      
;  4161 --        @@:
;  4162             ret
                    ret                   ;#0044258B: 303                        np 00 00  2 1218      
;  4163 
;  4164 
;  4165 --/*
;  4166 procedure :%pGetStdCS(:%)
;  4167 end procedure -- (for Edita/CtrlQ)
;  4168 --*/
;  4169 --DEV cold feet?
;  4170 --/*
;  4171     :%pGetStdCS                 -- [edi]:=get_stdcs()
;  4172 --------------
;  4173     [32]
;  4174         -- calling convention
;  4175         -- lea edi,[res]        -- result
;  4176         -- call :%pGetStdCS     -- eax:=get_stdcs(); [edi]:=eax
;  4177         -- (trashes all other registers)
;  4178         mov eax,[stdcs]
;  4179         push edi
;  4180         test eax,eax
;  4181         jnz @f
;  4182             cmp [gt1tcb],ebx
;  4183             je @f
;  4184                 -- (so >1 tcb exists)
;  4185                 lea edi,[stdcs]
;  4186                 call :%pInitCS      -- (trashes all registers)
;  4187                 mov eax,[stdcs]
;  4188       @@:
;  4189         pop rdi
;  4190         jmp :%pStoreMint            -- [edi]:=eax (all registers preserved)
;  4191     [64]
;  4192         mov rax,[stdcs]
;  4193         test rax,rax
;  4194         jnz @f
;  4195             cmp [gt1tcb],rbx
;  4196             je @f
;  4197                 lea rdi,[stdcs]
;  4198                 call :%pInitCS      -- (trashes all registers)
;  4199                 mov rax,[stdcs]
;  4200       @@:
;  4201         pop rdi
;  4202         jmp :%pStoreMint            -- [rdi]:=rax (preserves rax/rcx/rdx/rsi/rdi)
;  4203     []
;  4204 --*/
;  4205 
;  4206 -- no: compiler automatically inserts NULL
;  4207 --  :%opEnterSTDCS
;  4208 --      mov eax,[stdcs]
;  4209 --      ...
;  4210 --/*
;  4211 procedure :%pEnterCS(:%)
;  4212 end procedure -- (for Edita/CtrlQ)
;  4213 --*/
;  4214     :%pEnterCS
;  4215 --------------
;  4216     [32]
;  4217         -- calling convention
;  4218         -- mov ecx,[mycs]       -- or xor ecx,ecx
;  4219         -- mov esi,mycs         -- var no, if it can be unassigned [DEV]
;  4220         -- call :%opEnterCS     -- enter_cs(ecx)
;  4221         test ecx,ecx
;  4222         jnz @f
;  4223             mov ecx,[stdcs]
;  4224             test ecx,ecx
;  4225             jnz @f
;  4226             lea edi,[stdcs]
;  4227             call :%pInitCS
;  4228             mov ecx,[stdcs]
;  4229 --          lea edi,[stdcs]
;  4230 --          call :%pGetStdCS    -- sets eax, trashes rest
;  4231 --          mov ecx,eax
;  4232             xor esi,esi
;  4233       @@:
;  4234         shl ecx,2
;  4235         jnz @f
;  4236       ::unassignedcs
;  4237             pop edx -- era
;  4238             mov al,92           -- e92vhnbaav(esi)
;  4239             sub edx,1
;  4240             jmp :!iDiag
;  4241             int3
;  4242       @@:
;  4243         add ecx,4
;  4244     [64]
;  4245         -- calling convention
;  4246         -- mov rcx,[mycs]       -- or xor rcx,rcx
;  4247         -- mov rsi,mycs         -- var no, if it can be unassigned
;  4248         -- call :%opEnterCS     -- enter_cs(rcx)
;  4249         test rcx,rcx
                test rcx,rcx              ;#0044258C: 48:205311                  uv 00 02  1 1220      
;  4250         jnz @f
                jnz #004425B3             ;#0044258F: 165 22                     v  00 00  1 1220      
;  4251             mov rcx,[stdcs]
                    mov rcx,[#00402F10] (stdcs)  ;#00442591: 48:213015 7809FCFF         uv 02 00  1 1221      
;  4252             test rcx,rcx
                    test rcx,rcx          ;#00442598: 48:205311                  uv 00 02  1 1222 02   
;  4253             jnz @f
                    jnz #004425B3         ;#0044259B: 165 16                     v  00 00  1 1222      
;  4254             lea rdi,[stdcs]
                    lea rdi,[#00402F10] (stdcs)  ;#0044259D: 48:215075 6C09FCFF         uv 80 00  1 1223      
;  4255             call :%pInitCS
                    call #0044250E (:%pInitCS)  ;#004425A4: 350 65FFFFFF               v  00 00  1 1223      
;  4256             mov rcx,[stdcs]
                    mov rcx,[#00402F10] (stdcs)  ;#004425A9: 48:213015 6009FCFF         uv 02 00  1 1224      
;  4257 --          lea rdi,[stdcs]
;  4258 --          call :%pGetStdCS    -- sets rax, trashes rest
;  4259 --          mov rcx,rax
;  4260             xor rsi,rsi
                    xor rsi,rsi           ;#004425B0: 48:061366                  vu 40 40  1 1224      
;  4261       @@:
;  4262         shl rcx,2
                shl rcx,2                 ;#004425B3: 48:301341 02               u  02 02  1 1225      
;  4263         jnz @f
                jnz #004425C7             ;#004425B7: 165 0E                     v  00 00  1 1225      
;  4264       ::unassignedcs
;  4265             pop rdx -- era
                    pop rdx               ;#004425B9: 48:132                     uv 04 00  1 1226      
;  4266             mov al,92           -- e92vhnbaav(esi)
                    mov al,92             ;#004425BB: 260 5C                     vu 01 00  1 1226      
;  4267             sub rdx,1
                    sub rdx,1             ;#004425BD: 48:203352 01               uv 04 04  1 1227      
;  4268             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#004425C1: 351 A0080000               v  00 00  1 1227      
;  4269             int3
                    int3                  ;#004425C6: 314                        np 00 00 13 1228      
;  4270       @@:
;  4271         add rcx,8
                add rcx,8                 ;#004425C7: 48:203301 08               uv 02 02  1 1241      
;  4272     []
;  4273         call :EnterCriticalSection -- in pHeap.e (cs in ecx) all registers trashed
                call #004417FE            ;#004425CB: 350 2EF2FFFF               v  00 00  1 1241      
;  4274         ret
                ret                       ;#004425D0: 303                        np 00 00  2 1242      
;  4275 
;  4276 --/*
;  4277 procedure :%pTryCS(:%)
;  4278 end procedure -- (for Edita/CtrlQ)
;  4279 --*/
;  4280     :%pTryCS
;  4281 ------------
;  4282 --DEV (if >1 tcb exists)
;  4283     [32]
;  4284         -- calling convention
;  4285         -- mov ecx,[mycs]
;  4286         -- mov esi,mycs         -- var no, if it can be unassigned [DEV]
;  4287         -- lea edi,[res]
;  4288         -- call :%opTryCS       -- [edi]:=try_cs(ecx) (0 means failure)
;  4289         shl ecx,2
;  4290         jz :unassignedcs
;  4291         add ecx,4
;  4292         push edi
;  4293     [64]
;  4294         -- calling convention
;  4295         -- mov rcx,[mycs]
;  4296         -- mov rsi,mycs         -- var no, if it can be unassigned
;  4297         -- lea rdi,[res]
;  4298         -- call :%opTryCS       -- [rdi]:=try_cs(rcx) (0 means failure)
;  4299         shl rcx,2
                shl rcx,2                 ;#004425D1: 48:301341 02               u  02 02  1 1244      
;  4300         jz :unassignedcs
                jz #004425B9              ;#004425D5: 164 E2                     v  00 00  1 1244      
;  4301         add rcx,8
                add rcx,8                 ;#004425D7: 48:203301 08               uv 02 02  1 1245      
;  4302         push rdi
                push rdi                  ;#004425DB: 48:127                     vu 00 80  1 1245      
;  4303     []
;  4304         call :TryEnterCriticalSection
                call #00441819            ;#004425DD: 350 37F2FFFF               v  00 00  1 1246      
;  4305     [32]
;  4306         pop edi
;  4307     [64]
;  4308         pop rdi
                pop rdi                   ;#004425E2: 48:137                     uv 80 00  1 1247      
;  4309     []
;  4310         jmp :%pStoreMint
                jmp #0044228A (:%pStoreMint)  ;#004425E4: 351 A1FCFFFF               v  00 00  1 1247      
;  4311 
;  4312 --NO: compiler automatically inserts NULL
;  4313 --  :%opLeaveSTDCS
;  4314 --      mov eax,[stdcs]
;  4315 --      ...
;  4316 --/*
;  4317 procedure :%pLeaveCS(:%)
;  4318 end procedure -- (for Edita/CtrlQ)
;  4319 --*/
;  4320     :%pLeaveCS
;  4321 --------------
;  4322 -- DEV (if >1 tcb exists)
;  4323     [32]
;  4324         -- calling convention
;  4325         -- mov ecx,[mycs]       -- or xor ecx,ecx
;  4326         -- mov esi,mycs         -- var no, if it can be unassigned [DEV]
;  4327         -- call :%opLeaveCS     -- leave_cs(ecx)
;  4328         test ecx,ecx
;  4329         jnz @f
;  4330             mov ecx,[stdcs]
;  4331             test ecx,ecx
;  4332             jz :%e02atdb0
;  4333       @@:
;  4334         shl ecx,2
;  4335         jz :unassignedcs
;  4336         add ecx,4
;  4337     [64]
;  4338         -- calling convention
;  4339         -- mov rcx,[mycs]       -- or xor rcx,rcx
;  4340         -- mov rsi,mycs         -- var no, if it can be unassigned
;  4341         -- call :%opLeaveCS     -- leave_cs(rcx)
;  4342         test rcx,rcx
                test rcx,rcx              ;#004425E9: 48:205311                  uv 00 02  1 1248      
;  4343         jnz @f
                jnz #004425FE             ;#004425EC: 165 10                     v  00 00  1 1248      
;  4344             mov rcx,[stdcs]
                    mov rcx,[#00402F10] (stdcs)  ;#004425EE: 48:213015 1B09FCFF         uv 02 00  1 1249      
;  4345             test rcx,rcx
                    test rcx,rcx          ;#004425F5: 48:205311                  uv 00 02  1 1250 02   
;  4346             jz :%e02atdb0
                    jz #00442DD2 (:%pDiv0)  ;#004425F8: 017204 D4070000            v  00 00  1 1250      
;  4347       @@:
;  4348         shl rcx,2
                shl rcx,2                 ;#004425FE: 48:301341 02               u  02 02  1 1251      
;  4349         jz :unassignedcs
                jz #004425B9              ;#00442602: 164 B5                     v  00 00  1 1251      
;  4350         add rcx,8
                add rcx,8                 ;#00442604: 48:203301 08               uv 02 02  1 1252      
;  4351     []
;  4352         call :LeaveCriticalSection
                call #00441834            ;#00442608: 350 27F2FFFF               v  00 00  1 1252      
;  4353         ret
                ret                       ;#0044260D: 303                        np 00 00  2 1253      
;  4354     
;  4355 --  ::fin
;  4356     }
;  4357 
;  4358 
    jmp #0044298D (:%opRetf)              ;#0044260E: 351 7A030000               v  00 00  1 1255      
;C:\Program Files (x86)\Phix\builtins\VM\pSubseN.e:
;==================================================
;     1 --
;     2 -- pSubseN.e
;     3 -- =========
;     4 --
;     5 --  Various subscripting routines:
;     6 --
;     7 --      :%pSubse            -- res = ref[idx1][idx2]..[idxn]
;     8 --      :%pSubse1           -- [ecx]=esi[edi], aka p3=p1[p2]
;     9 --      :%pSubse1i          -- [ecx]=esi[edi], aka p3=p1[p2] when [ecx] is integer (no dealloc)
;    10 --      :%pSubse1ip         -- as opSubse1i when p1 is dword-sequence of integer, and p3 is integer
;    11 --      :%pSubse1is         -- eax=esi[edi], aka p3=p1[p2] when esi is string and result is integer
;    12 --
;    13 --  The latter four are optimised forms of :%pSubse, with exactly 1 index and other strict rules.
;    14 --  If porting, you could just (temporarily) implement :%pSubse and use it for everything, but 
;    15 --  that would require matching (temp) changes to psym.e, pmain.e, and pilx86.e.
;    16 --
;    17 
;    18 include builtins\VM\pHeap.e     -- :%pDealloc
;    19 
;    20 include builtins\VM\pFixup.e    -- negative and floating point index handling (:%fixupIndex)
;    21 
;    22 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#00441581: 351 07140000               v  00 00  1   1      
;    23 
;    24 --DEV FIXME: (and the :!bang labels below)
;    25     ::e04atsaa8
;    26         int3
                int3                      ;#00441586: 314                        np 00 00 13   2      
;    27 --  ::e04atsaa0
;    28 --      int3
;    29 --  ::e110ecxesp
;    30 --      int3
;    31     ::e93edx
;    32     [32]
;    33         mov edi,edx
;    34         pop edx
;    35         mov al,93       -- e93vhnbaav(edi)
;    36         sub edx,1
;    37     [64]
;    38         mov rdi,rdx
                mov rdi,rdx               ;#00441587: 48:213372                  uv 80 04  1  15      
;    39         pop rdx
                pop rdx                   ;#0044158A: 48:132                     vu 04 00  1  15      
;    40         mov al,93       -- e93vhnbaav(rdi)
                mov al,93                 ;#0044158C: 260 5D                     uv 01 00  1  16      
;    41         sub rdx,1
                sub rdx,1                 ;#0044158E: 48:203352 01               vu 04 04  1  16      
;    42     []
;    43         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#00441592: 351 CF180000               v  00 00  1  17      
;    44         int3
                int3                      ;#00441597: 314                        np 00 00 13  18      
;    45 
;    46 --/*
;    47 procedure :%pSubse(:%)
;    48 end procedure -- (for Edita/CtrlQ)
;    49 --*/
;    50     :%pSubse    -- res = ref[idx1][idx2]..[idxn]
;    51 ------------
;    52     [32]
;    53         -- calling convention (as hard-coded in pilx86.e):
;    54         --  push <return address>
;    55         --  push <addr res>                                 (or lea reg [ebp-NN], push reg)
;    56         --  push [idxn]..[idx1]     (opUnassign'd)			(or push dword[m32 or ebp+d8/32])
;    57         --  mov ecx,n
;    58         --  mov edx,<addr ref>                              (or lea edx,[ebp+d8/32]
;    59         --  jmp :%pSubse            (actually a call)
;    60         --<return address>
;    61         --  callee must ensure ref(edx) and all indexes are assigned beforehand (ie pmain.e 
;    62         --  should emit any required opUnassigned instructions before the opSubse).
;    63         --  if result is integer, left in eax, otherwise all registers clobbered.
;    64         pop edi
;    65         mov eax,[edx]
;    66     ::opSubseWhile
;    67         cmp eax,h4
;    68 --      jl :e04atsaa8           -- attempt to subscript an atom, era @ [esp+ecx*4]
;    69         jg @f
;    70 --          mov e?dx,[esp+ecx*4+4]
;    71 --          mov e??,[esp+ecx*4]
;    72 --          lea esp,[esp+ecx*4+4]
;    73             lea esp,[esp+ecx*4]
;    74             je :e93edx
;    75             pop edx
;    76             mov al,4            -- e04atssaa
;    77             sub edx,1
;    78             jmp :!iDiag
;    79             int3
;    80       @@:
;    81 --DEV
;    82 --    :!opSubsee92a             -- exception here mapped to opSubsee92aedxfeh
;    83         mov edx,[ebx+eax*4-12]  -- length
;    84         lea edi,[edi-1]
;    85         cmp byte[ebx+eax*4-1],0x80
;    86         lea eax,[ebx+eax*4]
;    87         jne :opSubseStr
;    88         cmp edi,edx
;    89         jb @f                   -- unsigned jump, lets 0..len-1 through
;    90                                 --              (we just decremented edi)
;    91             push eax
;    92             add ecx,1
;    93             mov al,8+4+1        -- [era] @ [esp+ecx*4], "reading from"
;    94             call :%fixupIndex   -- idx-1 in edi, len in edx, (not: idx addr in ebx), al set
;    95                                 -- (we have opUnassign'd all idx that we need to, because
;    96                                 --  the new calling convention has no var addr, thus ebx 
;    97                                 --  would not be useful here anyway)
;    98             sub ecx,1
;    99             pop eax
;   100       @@:
;   101         mov eax,[eax+edi*4]
;   102         pop edi
;   103         sub ecx,1
;   104         jnz :opSubseWhile
;   105 
;   106         mov edx,[edi]
;   107         cmp eax,h4
;   108         mov [edi],eax
;   109         jl :opSubseEndWhile
;   110             add dword[ebx+eax*4-8],1
;   111       ::opSubseEndWhile
;   112         cmp edx,h4
;   113         jle @f
;   114             sub dword[ebx+edx*4-8],1
;   115             jz :%pDealloc
;   116       @@:
;   117         ret
;   118 
;   119       ::opSubseStr
;   120         cmp ecx,1
;   121         jne :e04atsaa8          -- attempt to subscript an atom, era @ [esp+ecx*4]
;   122         pop ecx
;   123         cmp byte[eax-1],0x82
;   124         jne :e04atsaa8          -- attempt to subscript an atom, era @ [esp+ecx*4]
;   125         cmp edi,edx
;   126         jb @f                   -- unsigned jump, lets 0..len-1 through
;   127                                 --               (we just did a dec edi)
;   128             push eax
;   129             mov al,4+1          -- [era] @ [esp+8], "reading from"
;   130             call :%fixupIndex   -- idx-1 in edi, len in edx, (not: idx addr in ebx), al set
;   131                                 -- (ditto note above)
;   132             pop eax
;   133        @@:
;   134         add edi,eax
;   135         xor eax,eax
;   136         mov edx,[ecx]
;   137         mov al,[edi]
;   138         cmp edx,h4
;   139         mov [ecx],eax
;   140         jle @f
;   141             sub dword[ebx+edx*4-8],1
;   142             jz :%pDealloc
;   143       @@:
;   144         ret
;   145     [64]
;   146         -- calling convention (as hard-coded in pilx86.e):
;   147         --  push <return address>
;   148         --  push <addr res>                                 (or lea reg [rbp-NN], push reg)
;   149         --  push [idxn]..[idx1]     (opUnassign'd)			(or push qword[m32 or rbp+d8/32])
;   150         --  mov rcx,n
;   151         --  mov rdx,<addr ref>                              (or lea rdx,[rbp+d8/32]
;   152         --  jmp :%pSubse            (actually a call)
;   153         --<return address>
;   154         --  callee must ensure ref(rdx) and all indexes are assigned beforehand (ie pmain.e 
;   155         --  should emit any required opUnassigned instructions before the opSubse).
;   156         --  if result is integer, left in rax, otherwise all registers clobbered.
;   157         pop rdi
                pop rdi                   ;#00441598: 48:137                     uv 80 00  1  31      
;   158         mov rax,[rdx]
                mov rax,[rdx]             ;#0044159A: 48:213002                  vu 01 04  1  31      
;   159         mov r15,h4
                mov r15,h4                ;#0044159D: 49:277 0000000000000040    uv 8000 00  1  32      
;   160     ::opSubseWhile
;   161 --      cmp rax,h4
;   162         cmp rax,r15
                cmp rax,r15               ;#004415A7: 49:073307                  uv 00 8001  1  33 8000   
;   163 --      jl :e04atsaa8           -- attempt to subscript an atom, era @ [esp+ecx*4]
;   164         jg @f
                jg #004415C0              ;#004415AA: 177 14                     v  00 00  1  33      
;   165 --          mov e?dx,[esp+ecx*4+4]
;   166 --          mov e??,[esp+ecx*4]
;   167             lea rsp,[rsp+rcx*8]
                    lea rsp,[rsp+rcx*8]   ;#004415AC: 48:215044314               uv 10 12  1  34      
;   168             je :e93edx
                    je #00441587          ;#004415B0: 164 D5                     v  00 00  1  34      
;   169             pop rdx
                    pop rdx               ;#004415B2: 48:132                     uv 04 00  1  35      
;   170             mov al,4            -- e04atssaa
                    mov al,4              ;#004415B4: 260 04                     vu 01 00  1  35      
;   171             sub rdx,1
                    sub rdx,1             ;#004415B6: 48:203352 01               uv 04 04  1  36      
;   172             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#004415BA: 351 A7180000               v  00 00  1  36      
;   173             int3
                    int3                  ;#004415BF: 314                        np 00 00 13  37      
;   174       @@:
;   175 --      mov rdx,[rbx+rax*4-12]  -- length
;   176         mov rdx,[rbx+rax*4-24]  -- length
                mov rdx,[rbx+rax*4-24]    ;#004415C0: 48:213124203 E8            uv 04 09  1  50      
;   177         lea rdi,[rdi-1]
                lea rdi,[rdi-1]           ;#004415C5: 48:215177 FF               vu 80 80  1  50      
;   178         cmp byte[rbx+rax*4-1],0x80
                cmp byte[rbx+rax*4-1],#80  ;#004415C9: 200174203 FF 80            u  00 09  2  51      
;   179         lea rax,[rbx+rax*4]
                lea rax,[rbx+rax*4]       ;#004415CE: 48:215004203               vu 01 09  1  52      
;   180         jne :opSubseStr
                jne #00441625             ;#004415D2: 165 51                     v  00 00  1  53      
;   181         cmp rdi,rdx
                cmp rdi,rdx               ;#004415D4: 48:071327                  uv 00 84  1  54      
;   182         jb @f                   -- unsigned jump, lets 0..len-1 through
                jb #004415EC              ;#004415D7: 162 13                     v  00 00  1  54      
;   183                                 --              (we just decremented edi)
;   184             push rax
                    push rax              ;#004415D9: 48:120                     uv 00 01  1  55      
;   185             add rcx,1
                    add rcx,1             ;#004415DB: 48:203301 01               vu 02 02  1  55      
;   186             mov al,8+4+1        -- [era] @ [rsp+rcx*8], "reading from"
                    mov al,13             ;#004415DF: 260 0D                     uv 01 00  1  56      
;   187             call :%fixupIndex   -- idx-1 in rdi, len in rdx, (not: idx addr in rbx), al set
                    call #0044144B (:%fixupIndex)  ;#004415E1: 350 65FEFFFF               v  00 00  1  56      
;   188                                 -- (we have opUnassign'd all idx that we need to, because
;   189                                 --  the new calling convention has no var addr, thus ebx 
;   190                                 --  would not be useful here anyway)
;   191             sub rcx,1
                    sub rcx,1             ;#004415E6: 48:203351 01               uv 02 02  1  57      
;   192             pop rax
                    pop rax               ;#004415EA: 48:130                     vu 01 00  1  57      
;   193       @@:
;   194         mov rax,[rax+rdi*8]
                mov rax,[rax+rdi*8]       ;#004415EC: 48:213004370               uv 01 81  1  60    *01*
;   195         pop rdi
                pop rdi                   ;#004415F0: 48:137                     vu 80 00  1  60      
;   196         sub rcx,1
                sub rcx,1                 ;#004415F2: 48:203351 01               uv 02 02  1  61      
;   197         jnz :opSubseWhile
                jnz #004415A7             ;#004415F6: 165 AF                     v  00 00  1  61      
;   198 
;   199         mov rdx,[rdi]
                mov rdx,[rdi]             ;#004415F8: 48:213027                  uv 04 80  1  62      
;   200 --      cmp rax,h4
;   201 --      mov r15,h4
;   202         cmp rax,r15
                cmp rax,r15               ;#004415FB: 49:073307                  vu 00 8001  1  62      
;   203         mov [rdi],rax
                mov [rdi],rax             ;#004415FE: 48:211007                  uv 00 81  1  63      
;   204         jl :opSubseEndWhile
                jl #00441609              ;#00441601: 174 06                     v  00 00  1  63      
;   205             add qword[rbx+rax*4-16],1
                    add qword[rbx+rax*4-16],1  ;#00441603: 48:203104203 F0 01         u  00 09  3  64      
;   206       ::opSubseEndWhile
;   207 --      cmp rdx,h4
;   208         mov r15,h4
                mov r15,h4                ;#00441609: 49:277 0000000000000040    vu 8000 00  1  66      
;   209         cmp rdx,r15
                cmp rdx,r15               ;#00441613: 49:073327                  uv 00 8004  1  67      
;   210         jle @f
                jle #00441624             ;#00441616: 176 0C                     v  00 00  1  67      
;   211             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#00441618: 48:203154223 F0 01         u  00 0C  3  68      
;   212             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0044161E: 017204 B60C0000            v  00 00  1  70      
;   213       @@:
;   214         ret
                ret                       ;#00441624: 303                        np 00 00  2  71      
;   215 
;   216       ::opSubseStr
;   217         cmp rcx,1
                cmp rcx,1                 ;#00441625: 48:203371 01               uv 00 02  1  73      
;   218         jne :e04atsaa8          -- attempt to subscript an atom, era @ [rsp+rcx*8]
                jne #00441586             ;#00441629: 017205 57FFFFFF            v  00 00  1  73      
;   219         pop rcx
                pop rcx                   ;#0044162F: 48:131                     uv 02 00  1  74      
;   220         cmp byte[rax-1],0x82
                cmp byte[rax-1],#82       ;#00441631: 200170 FF 82               u  00 01  2  75      
;   221         jne :e04atsaa8          -- attempt to subscript an atom, era @ [rsp+rcx*4]
                jne #00441586             ;#00441635: 017205 4BFFFFFF            v  00 00  1  76      
;   222         cmp rdi,rdx
                cmp rdi,rdx               ;#0044163B: 48:071327                  uv 00 84  1  77      
;   223         jb @f                   -- unsigned jump, lets 0..len-1 through
                jb #0044164B              ;#0044163E: 162 0B                     v  00 00  1  77      
;   224                                 --               (we just did a dec rdi)
;   225             push rax
                    push rax              ;#00441640: 48:120                     uv 00 01  1  78      
;   226             mov al,4+1          -- [era] @ [rsp+16], "reading from"
                    mov al,5              ;#00441642: 260 05                     vu 01 00  1  78      
;   227             call :%fixupIndex   -- idx-1 in rdi, len in rdx, (not: idx addr in rbx), al set
                    call #0044144B (:%fixupIndex)  ;#00441644: 350 02FEFFFF               v  00 00  1  79      
;   228                                 -- (ditto note above)
;   229             pop rax
                    pop rax               ;#00441649: 48:130                     uv 01 00  1  80      
;   230        @@:
;   231         add rdi,rax
                add rdi,rax               ;#0044164B: 48:001307                  uv 80 81  1  81 01   
;   232         xor rax,rax
                xor rax,rax               ;#0044164E: 48:061300                  vu 01 01  1  81      
;   233         mov rdx,[rcx]
                mov rdx,[rcx]             ;#00441651: 48:213021                  uv 04 02  1  82      
;   234         mov al,[rdi]
                mov al,[edi]              ;#00441654: 212007                     uv 01 80  1  84    *80*
;   235 --      cmp rdx,h4
;   236         mov r15,h4
                mov r15,h4                ;#00441656: 49:277 0000000000000040    vu 8000 00  1  84      
;   237         cmp rdx,r15
                cmp rdx,r15               ;#00441660: 49:073327                  uv 00 8004  1  85      
;   238         mov [rcx],rax
                mov [rcx],rax             ;#00441663: 48:211001                  vu 00 03  1  85      
;   239         jle @f
                jle #00441674             ;#00441666: 176 0C                     v  00 00  1  86      
;   240             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#00441668: 48:203154223 F0 01         u  00 0C  3  87      
;   241             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0044166E: 017204 660C0000            v  00 00  1  89      
;   242       @@:
;   243         ret
                ret                       ;#00441674: 303                        np 00 00  2  90      
;   244     []
;   245 
;   246 --/*
;   247 procedure :%pSubse1(:%)
;   248 end procedure -- (for Edita/CtrlQ)
;   249 --*/
;   250     :%pSubse1               -- [ecx]=esi[edi], aka p3=p1[p2]
;   251 -------------
;   252     [32]
;   253         -- calling convention (as hard-coded in pilx86.e):
;   254         --  mov edi,[p2]        -- idx (opUnassigned)
;   255         --  mov ecx,p3          -- addr res
;   256         --  mov esi,[p1]        -- s
;   257         --  mov edx,p1          -- var no of s              
;   258         --  call opSubse1       -- [res]:=s[idx]
;   259         sub edi,1
;   260 --DEV
;   261 --    :!opSubse1Re92a:          -- exception here mapped to e94vhnbaavedxesifeh
;   262         mov edx,[ebx+esi*4-12]  -- length
;   263         mov ah,byte[ebx+esi*4-1]
;   264         shl esi,2
;   265         cmp edi,edx
;   266         jb @f
;   267             mov al,2+1              -- [era] @ [esp+4], "reading from"
;   268             call :%fixupIndex       -- idx-1 in edi, len in edx, (not: idx addr in ebx), al set
;   269       @@:
;   270         cmp ah,0x80
;   271         je :opSubse1Seq
;   272         cmp ah,0x82
;   273 --      jne :e04atsaa0
;   274         je @f
;   275             pop edx
;   276             mov al,4    -- e04atssaa
;   277             sub edx,1
;   278             jmp :!iDiag
;   279             int3
;   280       @@:
;   281         xor eax,eax
;   282         mov edx,[ecx]
;   283         mov al,[esi+edi]
;   284         jmp @f
;   285       ::opSubse1Seq
;   286         mov eax,[esi+edi*4]
;   287         mov edx,[ecx]           -- prev(res)
;   288         cmp eax,h4
;   289         jl @f
;   290             add dword[ebx+eax*4-8],1
;   291       @@:
;   292         cmp edx,h4
;   293         jle @f
;   294             mov edi,[ebx+edx*4-8]   -- decref in edi
;   295             mov [ecx],eax
;   296             dec edi
;   297             jz :%pDealloc
;   298             mov [ebx+edx*4-8],edi
;   299             ret
;   300       @@:
;   301         mov [ecx],eax
;   302         ret
;   303     [64]
;   304         -- calling convention (as hard-coded in pilx86.e):
;   305         --  mov rdi,[p2]        -- idx (opUnassigned)
;   306         --  mov rcx,p3          -- addr res
;   307         --  mov rsi,[p1]        -- s
;   308         --  mov rdx,p1          -- var no of s              
;   309         --  call opSubse1       -- [res]:=s[idx]
;   310         sub rdi,1
                sub rdi,1                 ;#00441675: 48:203357 01               uv 80 80  1  92      
;   311 --      mov r15,h4
;   312 --DEV
;   313 --    :!opSubse1Re92a:          -- exception here mapped to e94vhnbaavedxesifeh
;   314         mov rdx,[rbx+rsi*4-24]  -- length
                mov rdx,[rbx+rsi*4-24]    ;#00441679: 48:213124263 E8            vu 04 48  1  92      
;   315         mov ah,byte[rbx+rsi*4-1]
                mov ah,[rbx+rsi*4-1]      ;#0044167E: 212144263 FF               uv 01 48  1  93      
;   316         shl rsi,2
                shl rsi,2                 ;#00441682: 48:301346 02               u  40 40  1  94      
;   317         cmp rdi,rdx
                cmp rdi,rdx               ;#00441686: 48:071327                  vu 00 84  1  94      
;   318         jb @f
                jb #00441692              ;#00441689: 162 07                     v  00 00  1  95      
;   319             mov al,2+1              -- [era] @ [rsp+8], "reading from"
                    mov al,3              ;#0044168B: 260 03                     uv 01 00  1  96      
;   320             call :%fixupIndex       -- idx-1 in rdi, len in rdx, (not: idx addr in rbx), al set
                    call #0044144B (:%fixupIndex)  ;#0044168D: 350 B9FDFFFF               v  00 00  1  96      
;   321       @@:
;   322         cmp ah,0x80
                cmp ah,#80                ;#00441692: 200374 80                  uv 00 01  1  97      
;   323         je :opSubse1Seq
                je #004416B5              ;#00441695: 164 1E                     v  00 00  1  97      
;   324         cmp ah,0x82
                cmp ah,#82                ;#00441697: 200374 82                  uv 00 01  1  98      
;   325 --      jne :e04atsaa0
;   326         je @f
                je #004416AA              ;#0044169A: 164 0E                     v  00 00  1  98      
;   327             pop rdx
                    pop rdx               ;#0044169C: 48:132                     uv 04 00  1  99      
;   328             mov al,4    -- e04atssaa
                    mov al,4              ;#0044169E: 260 04                     vu 01 00  1  99      
;   329             sub rdx,1
                    sub rdx,1             ;#004416A0: 48:203352 01               uv 04 04  1 100      
;   330             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#004416A4: 351 BD170000               v  00 00  1 100      
;   331             int3
                    int3                  ;#004416A9: 314                        np 00 00 13 101      
;   332       @@:
;   333         xor rax,rax
                xor rax,rax               ;#004416AA: 48:061300                  uv 01 01  1 114      
;   334         mov rdx,[rcx]
                mov rdx,[rcx]             ;#004416AD: 48:213021                  vu 04 02  1 114      
;   335         mov al,[rsi+rdi]
                mov al,[rsi+rdi]          ;#004416B0: 212004076                  uv 01 C0  1 115      
;   336         jmp @f
                jmp #004416D1             ;#004416B3: 353 1C                     v  00 00  1 115      
;   337       ::opSubse1Seq
;   338         mov rax,[rsi+rdi*8]
                mov rax,[rsi+rdi*8]       ;#004416B5: 48:213004376               uv 01 C0  1 116      
;   339         mov rdx,[rcx]           -- prev(res)
                mov rdx,[rcx]             ;#004416B9: 48:213021                  vu 04 02  1 116      
;   340 --      cmp rax,h4
;   341         mov r15,h4
                mov r15,h4                ;#004416BC: 49:277 0000000000000040    uv 8000 00  1 117      
;   342         cmp rax,r15
                cmp rax,r15               ;#004416C6: 49:073307                  uv 00 8001  1 118 8000   
;   343         jl @f
                jl #004416D1              ;#004416C9: 174 06                     v  00 00  1 118      
;   344             add qword[rbx+rax*4-16],1
                    add qword[rbx+rax*4-16],1  ;#004416CB: 48:203104203 F0 01         u  00 09  3 119      
;   345       @@:
;   346 --      cmp rdx,h4
;   347         cmp rdx,r15
                cmp rdx,r15               ;#004416D1: 49:073327                  vu 00 8004  1 121      
;   348         jle @f
                jle #004416EE             ;#004416D4: 176 18                     v  00 00  1 122      
;   349             mov rdi,[rbx+rdx*4-16]  -- decref in rdi
                    mov rdi,[rbx+rdx*4-16]  ;#004416D6: 48:213174223 F0            uv 80 0C  1 123      
;   350             mov [rcx],rax
                    mov [rcx],rax         ;#004416DB: 48:211001                  vu 00 03  1 123      
;   351             sub rdi,1
                    sub rdi,1             ;#004416DE: 48:203357 01               uv 80 80  1 124      
;   352             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#004416E2: 017204 F20B0000            v  00 00  1 124      
;   353             mov [rbx+rdx*4-16],rdi
                    mov [rbx+rdx*4-16],rdi  ;#004416E8: 48:211174223 F0            uv 00 8C  1 125      
;   354             ret
                    ret                   ;#004416ED: 303                        np 00 00  2 126      
;   355       @@:
;   356         mov [rcx],rax
                mov [rcx],rax             ;#004416EE: 48:211001                  uv 00 03  1 128      
;   357         ret
                ret                       ;#004416F1: 303                        np 00 00  2 129      
;   358     []
;   359 
;   360 --/*
;   361 procedure :%pSubse1i(:%)
;   362 end procedure -- (for Edita/CtrlQ)
;   363 --*/
;   364     :%pSubse1i          -- [ecx]=esi[edi], aka p3=p1[p2] when [ecx] is integer (no dealloc)
;   365 --------------          -- esi must be sequence [not object], (DEV test that) need not be S_Init.
;   366     [32]
;   367         -- calling convention (as hard-coded in pilx86.e):
;   368         --  mov edi,[p2]        -- idx (opUnassigned)
;   369         --  mov esi,[p1]        -- s
;   370         --  lea ecx,[res]       -- result addr
;   371         --  mov edx,p1          -- var no of s              
;   372         --  call opSubse1is     -- [ecx]:=s[idx]
;   373         --  mov [p3],eax        -- res
;   374         sub edi,1
;   375 --DEV
;   376 --    :!opSubse1iRe92a:         -- exception here mapped to e94vhnbaavedxesifeh (edx contains var no, esi value. e94vhnbaav or e04atsaa)
;   377         mov edx,[ebx+esi*4-12]  -- length
;   378         mov al,byte[ebx+esi*4-1] -- type byte
;   379         shl esi,2
;   380         cmp edi,edx
;   381         jb @f
;   382             push eax
;   383             mov al,4+1          -- [era] @ [esp+8], "reading from"
;   384             call :%fixupIndex   -- idx-1 in edi, len in edx, (not: idx addr in ebx), al set
;   385             pop eax
;   386       @@:
;   387         and eax,2       -- test for 0x82 and clear top 3 bytes!
;   388         jne :opSubse1iCh
;   389             mov eax,[esi+edi*4]
;   390             cmp eax,h4
;   391             jl @f
;   392 --          jmp :e110ecxesp -- type check error
;   393             -- type check error (ecx is var addr)
;   394 --          mov edi,edx
;   395             mov [ecx],eax
;   396             pop edx
;   397             mov al,110          -- e110tce(ecx)
;   398             sub edx,1
;   399             jmp :!iDiag
;   400             int3
;   401 
;   402       ::opSubse1iCh
;   403         mov al,[esi+edi]
;   404     @@:
;   405         mov [ecx],eax
;   406         ret
;   407     [64]
;   408         -- calling convention (as hard-coded in pilx86.e):
;   409         --  mov rdi,[p2]        -- idx (opUnassigned)
;   410         --  mov rsi,[p1]        -- s
;   411         --  lea rcx,[res]       -- result addr
;   412         --  mov rdx,p1          -- var no of s              
;   413         --  call opSubse1is     -- [rcx]:=s[idx]
;   414         --  mov [p3],rax        -- res  [DEV?]
;   415         sub rdi,1
                sub rdi,1                 ;#004416F2: 48:203357 01               uv 80 80  1 131      
;   416 --DEV
;   417 --    :!opSubse1iRe92a:         -- exception here mapped to e94vhnbaavedxesifeh (edx contains var no, esi value. e94vhnbaav or e04atsaa)
;   418         mov rdx,[rbx+rsi*4-24]  -- length
                mov rdx,[rbx+rsi*4-24]    ;#004416F6: 48:213124263 E8            vu 04 48  1 131      
;   419         mov al,byte[rbx+rsi*4-1] -- type byte
                mov al,[rbx+rsi*4-1]      ;#004416FB: 212104263 FF               uv 01 48  1 132      
;   420         shl rsi,2
                shl rsi,2                 ;#004416FF: 48:301346 02               u  40 40  1 133      
;   421         cmp rdi,rdx
                cmp rdi,rdx               ;#00441703: 48:071327                  vu 00 84  1 133      
;   422         jb @f
                jb #00441713              ;#00441706: 162 0B                     v  00 00  1 134      
;   423             push rax
                    push rax              ;#00441708: 48:120                     uv 00 01  1 135      
;   424             mov al,4+1          -- [era] @ [rsp+16], "reading from"
                    mov al,5              ;#0044170A: 260 05                     vu 01 00  1 135      
;   425             call :%fixupIndex   -- idx-1 in rdi, len in rdx, (not: idx addr in rbx), al set
                    call #0044144B (:%fixupIndex)  ;#0044170C: 350 3AFDFFFF               v  00 00  1 136      
;   426             pop rax
                    pop rax               ;#00441711: 48:130                     uv 01 00  1 137      
;   427       @@:
;   428         and rax,2       -- test for 0x82 and clear top 3 bytes!
                and rax,2                 ;#00441713: 48:203340 02               uv 01 01  1 138 01   
;   429         jne :opSubse1iCh
                jne #0044173D             ;#00441717: 165 24                     v  00 00  1 138      
;   430             mov rax,[rsi+rdi*8]
                    mov rax,[rsi+rdi*8]   ;#00441719: 48:213004376               uv 01 C0  1 139      
;   431 --          cmp rax,h4
;   432             mov r15,h4
                    mov r15,h4            ;#0044171D: 49:277 0000000000000040    vu 8000 00  1 139      
;   433             cmp rax,r15
                    cmp rax,r15           ;#00441727: 49:073307                  uv 00 8001  1 140      
;   434             jl @f
                    jl #00441740          ;#0044172A: 174 14                     v  00 00  1 140      
;   435 --          jmp :e110ecxesp -- type check error
;   436             -- type check error (rcx is var addr)
;   437 --          mov rdi,rdx
;   438             mov [rcx],rax
                    mov [rcx],rax         ;#0044172C: 48:211001                  uv 00 03  1 141      
;   439             pop rdx
                    pop rdx               ;#0044172F: 48:132                     vu 04 00  1 141      
;   440             mov al,110      -- e110tce(ecx)
                    mov al,110            ;#00441731: 260 6E                     uv 01 00  1 142      
;   441             sub rdx,1
                    sub rdx,1             ;#00441733: 48:203352 01               vu 04 04  1 142      
;   442             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00441737: 351 2A170000               v  00 00  1 143      
;   443             int3
                    int3                  ;#0044173C: 314                        np 00 00 13 144      
;   444 
;   445       ::opSubse1iCh
;   446         mov al,[rsi+rdi]
                mov al,[rsi+rdi]          ;#0044173D: 212004076                  uv 01 C0  1 157      
;   447     @@:
;   448         mov [rcx],rax
                mov [rcx],rax             ;#00441740: 48:211001                  uv 00 03  1 158 01   
;   449         ret
                ret                       ;#00441743: 303                        np 00 00  2 159      
;   450     []
;   451 
;   452 --/*
;   453 procedure :%pSubse1ip(:%)
;   454 end procedure -- (for Edita/CtrlQ)
;   455 --*/
;   456     :%pSubse1ip             -- as opSubse1i when p1 is sequence of integer, and p3 is integer
;   457 ---------------             -- p1/esi must be sequence [not string/atom], need not be S_Init.
;   458     [32]
;   459         -- calling convention (as hard-coded in pilx86.e):
;   460         --  mov edi,[p2]        -- idx (opUnassigned)
;   461         --  mov esi,[p1]        -- s
;   462         --  mov edx,p1          -- var no of s              
;   463         --  call opSubse1ip     -- eax:=s[idx]
;   464         --  mov [p3],eax        -- store res
;   465         sub edi,1
;   466       :!opSubse1ipRe92a         -- exception here mapped to e94vhnbaavedxesifeh
;   467         mov edx,[ebx+esi*4-12]  -- length
;   468         shl esi,2
;   469         cmp edi,edx
;   470         jb @f
;   471             mov al,2+1              -- [era] @ [esp+4], "reading from"
;   472             call :%fixupIndex       -- idx-1 in edi, len in edx, (not: idx addr in ebx), al set
;   473       @@:
;   474         mov eax,[esi+edi*4]
;   475         ret
;   476     [64]
;   477         -- calling convention (as hard-coded in pilx86.e):
;   478         --  mov rdi,[p2]        -- idx (opUnassigned)
;   479         --  mov rsi,[p1]        -- s
;   480         --  mov rdx,p1          -- var no of s              
;   481         --  call opSubse1ip     -- rax:=s[idx]
;   482         --  mov [p3],rax        -- store res
;   483         sub rdi,1
                sub rdi,1                 ;#00441744: 48:203357 01               uv 80 80  1 161      
;   484 --DEV
;   485 --    :!opSubse1ipRe92a:            -- exception here mapped to e94vhnbaavedxesifeh
;   486         mov rdx,[rbx+rsi*4-24]  -- length
                mov rdx,[rbx+rsi*4-24]    ;#00441748: 48:213124263 E8            vu 04 48  1 161      
;   487         shl rsi,2
                shl rsi,2                 ;#0044174D: 48:301346 02               u  40 40  1 162      
;   488         cmp rdi,rdx
                cmp rdi,rdx               ;#00441751: 48:071327                  vu 00 84  1 162      
;   489         jb @f
                jb #0044175D              ;#00441754: 162 07                     v  00 00  1 163      
;   490             mov al,2+1              -- [era] @ [rsp+8], "reading from"
                    mov al,3              ;#00441756: 260 03                     uv 01 00  1 164      
;   491             call :%fixupIndex       -- idx-1 in rdi, len in rdx, (not: idx addr in rbx), al set
                    call #0044144B (:%fixupIndex)  ;#00441758: 350 EEFCFFFF               v  00 00  1 164      
;   492       @@:
;   493         mov rax,[rsi+rdi*8]
                mov rax,[rsi+rdi*8]       ;#0044175D: 48:213004376               uv 01 C0  1 165      
;   494         ret
                ret                       ;#00441761: 303                        np 00 00  2 166      
;   495     []
;   496 
;   497 --/*
;   498 procedure :%pSubse1is(:%)
;   499 end procedure -- (for Edita/CtrlQ)
;   500 --*/
;   501     :%pSubse1is             -- eax=esi[edi], aka p3=p1[p2] when esi is string and result is integer
;   502 ---------------
;   503     [32]
;   504         -- calling convention (as hard-coded in pilx86.e):
;   505         --  mov edi,[p2]        -- idx (opUnassigned)
;   506         --  mov esi,[p1]        -- s
;   507         --  mov edx,p1          -- var no of s
;   508         --  call opSubse1is     -- eax:=s[idx]
;   509         --  mov [p3],eax        -- store res
;   510         sub edi,1
;   511         xor eax,eax
;   512 --DEV
;   513 --    :!opSubse1isRe92a:            -- exception here mapped to e94vhnbaavedxesifeh
;   514         mov edx,[ebx+esi*4-12]  -- length
;   515         shl esi,2
;   516         cmp edi,edx
;   517         jb @f
;   518             mov al,2+1          -- [era] @ [esp+4], "reading from"
;   519             call :%fixupIndex   -- idx-1 in edi, len in edx, (not idx addr in ebx), al set
;   520       @@:
;   521         mov al,[esi+edi]
;   522         ret
;   523     [64]
;   524         -- calling convention (as hard-coded in pilx86.e):
;   525         --  mov rdi,[p2]        -- idx (opUnassigned)
;   526         --  mov rsi,[p1]        -- s
;   527         --  mov rdx,p1          -- var no of s
;   528         --  call opSubse1is     -- rax:=s[idx]
;   529         --  mov [p3],rax        -- store res
;   530         sub rdi,1
                sub rdi,1                 ;#00441762: 48:203357 01               uv 80 80  1 168      
;   531         xor rax,rax
                xor rax,rax               ;#00441766: 48:061300                  vu 01 01  1 168      
;   532 --DEV
;   533 --    :!opSubse1isRe92a:            -- exception here mapped to e94vhnbaavedxesifeh
;   534         mov rdx,[rbx+rsi*4-24]  -- length
                mov rdx,[rbx+rsi*4-24]    ;#00441769: 48:213124263 E8            uv 04 48  1 169      
;   535         shl rsi,2
                shl rsi,2                 ;#0044176E: 48:301346 02               u  40 40  1 170      
;   536         cmp rdi,rdx
                cmp rdi,rdx               ;#00441772: 48:071327                  vu 00 84  1 170      
;   537         jb @f
                jb #0044177E              ;#00441775: 162 07                     v  00 00  1 171      
;   538             mov al,2+1          -- [era] @ [rsp+8], "reading from"
                    mov al,3              ;#00441777: 260 03                     uv 01 00  1 172      
;   539             call :%fixupIndex   -- idx-1 in rdi, len in rdx, (not idx addr in rbx), al set
                    call #0044144B (:%fixupIndex)  ;#00441779: 350 CDFCFFFF               v  00 00  1 172      
;   540       @@:
;   541         mov al,[rsi+rdi]
                mov al,[rsi+rdi]          ;#0044177E: 212004076                  uv 01 C0  1 173      
;   542         ret
                ret                       ;#00441781: 303                        np 00 00  2 174      
;   543     []
;   544 
;   545       }
;   546 
    jmp #0044298D (:%opRetf)              ;#00441782: 351 06120000               v  00 00  1 176      
;C:\Program Files (x86)\Phix\builtins\VM\pFixup.e:
;=================================================
;     1 --
;     2 --  pFixup.e
;     3 --  ========
;     4 --
;     5 --      negative and floating point index handling 
;     6 --      (:%fixupIndex, :%fixupSliceStart, :%fixupSliceEnd)
;     7 --
;     8 --  Note this is not an autoinclude. Used by pSubseN.e, pRepeN.e, pSubssN.e, pJnotx.e
;     9 --
;    10 --  All functions in this file adjust edi to a normal 0-based index, and leave 
;    11 --  all other registers undamaged.
;    12 --
;    13 
;    14 include builtins\VM\pFPU.e
;    15 
;    16 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#004413B8: 351 D0150000               v  00 00  1   1      
;    17 
;    18 --DEV FIXME: (and the :!bang labels below)
;    19     ::e05sinaae06
;    20         or al,#10
                or al,16                  ;#004413BD: 200310 10                  uv 01 01  1   2      
;    21         jmp :e06ioobWhat
                jmp #004413C3             ;#004413C0: 353 01                     v  00 00  1   2      
;    22 --      int3
;    23     ::e05sinaae10
;    24         int3
                int3                      ;#004413C2: 314                        np 00 00 13   3      
;    25     ::e06ioobWhat
;    26         -- 0 or >length
;    27     [32]
;    28         mov esi,edx
;    29     [64]
;    30         mov rsi,rdx
                mov rsi,rdx               ;#004413C3: 48:213362                  uv 40 04  1  16      
;    31     []
;    32         test al,0x08
                test al,8                 ;#004413C6: 250 08                     vu 00 01  1  16      
;    33         jz :e06not8
                jz #004413E6              ;#004413C8: 164 1C                     v  00 00  1  17      
;    34         test al,0x04
                test al,4                 ;#004413CA: 250 04                     uv 00 01  1  18      
;    35         jz :e06not4
                jz #004413D5              ;#004413CC: 164 07                     v  00 00  1  18      
;    36     [32]
;    37             mov edx,[esp+ecx*4+4]
;    38     [64]
;    39             mov rdx,[rsp+rcx*8+8]
                    mov rdx,[rsp+rcx*8+8]  ;#004413CE: 48:213124314 08            uv 04 12  1  19      
;    40     []
;    41             jmp @f
                    jmp #004413F4         ;#004413D3: 353 1F                     v  00 00  1  19      
;    42       ::e06not4
;    43         test al,0x02
                test al,2                 ;#004413D5: 250 02                     uv 00 01  1  20      
;    44         jz :e06not2
                jz #004413DF              ;#004413D7: 164 06                     v  00 00  1  20      
;    45     [32]
;    46             mov edx,[esp+ecx*4]
;    47     [64]
;    48             mov rdx,[rsp+rcx*8]
                    mov rdx,[rsp+rcx*8]   ;#004413D9: 48:213024314               uv 04 12  1  21      
;    49     []
;    50             jmp @f
                    jmp #004413F4         ;#004413DD: 353 15                     v  00 00  1  21      
;    51       ::e06not2
;    52     [32]
;    53             mov edx,[esp+ecx*4-4]
;    54     [64]
;    55             mov rdx,[rsp+rcx*8-8]
                    mov rdx,[rsp+rcx*8-8]  ;#004413DF: 48:213124314 F8            uv 04 12  1  22      
;    56     []
;    57             jmp @f
                    jmp #004413F4         ;#004413E4: 353 0E                     v  00 00  1  22      
;    58       ::e06not8
;    59     [32]
;    60             mov edx,[esp+4]
;    61     [64]
;    62             mov rdx,[rsp+8]
                    mov rdx,[rsp+8]       ;#004413E6: 48:213124044 08            uv 04 10  1  23      
;    63     []
;    64         test al,0x04
                test al,4                 ;#004413EB: 250 04                     vu 00 01  1  23      
;    65         jz @f
                jz #004413F4              ;#004413ED: 164 05                     v  00 00  1  24      
;    66     [32]
;    67             mov edx,[esp+8]
;    68     [64]
;    69             mov rdx,[rsp+16]
                    mov rdx,[rsp+16]      ;#004413EF: 48:213124044 10            uv 04 10  1  25      
;    70     []
;    71       @@:
;    72     [32]
;    73         sub edx,1
;    74     [64]
;    75         sub rdx,1
                sub rdx,1                 ;#004413F4: 48:203352 01               uv 04 04  1  26 04   
;    76     []
;    77 --      mov [ep1],edi
;    78 --      mov [ep2],edx
;    79 --      mov [era],ecx
;    80         test al,0x20
                test al,32                ;#004413F8: 250 20                     vu 00 01  1  26      
;    81         jz @f
                jz #00441404              ;#004413FA: 164 08                     v  00 00  1  27      
;    82             mov al,92           -- variable has not been assigned a value
                    mov al,92             ;#004413FC: 260 5C                     uv 01 00  1  28      
;    83             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#004413FE: 351 631A0000               v  00 00  1  28      
;    84             int3
                    int3                  ;#00441403: 314                        np 00 00 13  29      
;    85       @@:
;    86         test al,0x10
                test al,16                ;#00441404: 250 10                     uv 00 01  1  42      
;    87         jz @f
                jz #00441410              ;#00441406: 164 08                     v  00 00  1  42      
;    88             mov al,5            -- subscript is not an atom
                    mov al,5              ;#00441408: 260 05                     uv 01 00  1  43      
;    89             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#0044140A: 351 571A0000               v  00 00  1  43      
;    90             int3
                    int3                  ;#0044140F: 314                        np 00 00 13  44      
;    91       @@:
;    92         test al,1
                test al,1                 ;#00441410: 250 01                     uv 00 01  1  57      
;    93         jnz @f
                jnz #0044141C             ;#00441412: 165 08                     v  00 00  1  57      
;    94             mov al,6            -- index %d(edi) out of bounds, assigning to a sequence of length %d(esi)
                    mov al,6              ;#00441414: 260 06                     uv 01 00  1  58      
;    95             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00441416: 351 4B1A0000               v  00 00  1  58      
;    96             int3
                    int3                  ;#0044141B: 314                        np 00 00 13  59      
;    97       @@:
;    98             mov al,106          -- index %d(edi) out of bounds, reading from a sequence of length %d(esi)
                    mov al,106            ;#0044141C: 260 6A                     uv 01 00  1  72      
;    99             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#0044141E: 351 431A0000               v  00 00  1  72      
;   100             int3
                    int3                  ;#00441423: 314                        np 00 00 13  73      
;   101 
;   102     ::e06ioobp1WhatN
;   103         int3
                int3                      ;#00441424: 314                        np 00 00 13  86      
;   104     ::e06ioobp1What
;   105         int3
                int3                      ;#00441425: 314                        np 00 00 13  99      
;   106     ::e08seinaie11
;   107         int3
                int3                      ;#00441426: 314                        np 00 00 13 112      
;   108     ::e10sspeosediedx
;   109         int3
                int3                      ;#00441427: 314                        np 00 00 13 125      
;   110     ::e10sspeosediedx0
;   111         int3
                int3                      ;#00441428: 314                        np 00 00 13 138      
;   112     ::e10sspeosediedxN
;   113         int3
                int3                      ;#00441429: 314                        np 00 00 13 151      
;   114       ::e11sepeosediedxN
;   115     [32]
;   116         sub edi,edx
;   117         sub edi,1
;   118     [64]
;   119         sub rdi,rdx
                sub rdi,rdx               ;#0044142A: 48:051327                  uv 80 84  1 164      
;   120         sub rdi,1
                sub rdi,1                 ;#0044142D: 48:203357 01               uv 80 80  1 165 80   
;   121     []
;   122       ::e11sepeosediedx
;   123     [32]
;   124         mov esi,edx
;   125         and ecx,0xFF
;   126         mov edx,[esp+ecx]       -- era
;   127         sub edx,1
;   128     [64]
;   129         mov rdi,rdx
                mov rdi,rdx               ;#00441431: 48:213372                  uv 80 04  1 166 80   
;   130         and rcx,0xFF
                and rcx,255               ;#00441434: 48:201341 FF000000         vu 02 02  1 166      
;   131         mov rdx,[rsp+rcx]       -- era
                mov rdx,[rsp+rcx]         ;#0044143B: 48:213024014               uv 04 12  1 169    *02*
;   132         sub rdx,1
                sub rdx,1                 ;#0044143F: 48:203352 01               uv 04 04  1 170 04   
;   133     []
;   134         mov al,11               -- slice ends past end of sequence (%d(edi) > %d(esi))
                mov al,11                 ;#00441443: 260 0B                     vu 01 00  1 170      
;   135         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#00441445: 351 1C1A0000               v  00 00  1 171      
;   136         int3                    -- (nodiag)
                int3                      ;#0044144A: 314                        np 00 00 13 172      
;   137 
;   138 --/*
;   139 e06ioobp1What:
;   140     add edi,1
;   141 e06ioobWhat:
;   142     ; bit #20 in al: 1 is e92 ("variable has not been assigned a value") [set in e92vhnbaavEbxe06feh]
;   143     ; bit #10 in al: 1 is e05 ("subscript is not an atom") [set in e05sinaae06]
;   144     ; bit #01 in al: 0 is e06 ("assigning to"), 1 is e106 ("reading from")
;   145     ; bit #08 in al, plus:
;   146     ;  bit #04=1: [era] is at [esp+ecx*4+4]
;   147     ;  bit #02=0: [era] is at [esp+ecx*4-4]
;   148     ;  bit #02=1: [era] is at [esp+ecx*4]
;   149     ; bit #04 in al: [era] is at [esp+8]
;   150     ; bit #02 in al: [era] is at [esp+4]
;   151     mov ebx,esp
;   152 e06espinebx:
;   153     test al,0x08
;   154     jz e06not8
;   155     test al,0x04
;   156     jz e06not4
;   157     mov ecx,[ebx+ecx*4+4]
;   158     jmp @f
;   159 e06not4:
;   160     test al,0x02
;   161     jz e06not2
;   162     mov ecx,[ebx+ecx*4]
;   163     jmp @f
;   164 e06not2:
;   165     mov ecx,[ebx+ecx*4-4]
;   166     jmp @f
;   167 e06not8:        
;   168     mov ecx,[ebx+4]
;   169     test al,0x04
;   170     jz @f
;   171     mov ecx,[ebx+8]
;   172 @@:
;   173     sub ecx,1
;   174     mov [ep1],edi
;   175     mov [ep2],edx
;   176     mov [era],ecx
;   177     test al,0x20
;   178     jz @f
;   179     mov al,92           ; variable has not been assigned a value
;   180     jmp enumbset
;   181 @@:
;   182     test al,0x10
;   183     jz @f
;   184     mov al,5            ; subscript is not an atom
;   185     jmp enumbset
;   186 @@:
;   187     test al,1
;   188     jnz @f
;   189     mov al,6            ; index %d out of bounds, assigning to a sequence of length %d
;   190     jmp enumbset
;   191 
;   192 e106ioobrp1:
;   193     add edi,1
;   194 e106ioobr:
;   195     mov [ep1],edi
;   196     mov [ep2],edx
;   197     pop [era]
;   198 @@:
;   199     mov al,106          ; index %d out of bounds, reading from a sequence of length %d
;   200     jmp enumbset
;   201 --*/
;   202 
;   203 
;   204 --/*
;   205 procedure :%fixupIndex(:%)
;   206 end procedure -- (for Edita/CtrlQ)
;   207 --*/
;   208     :%fixupIndex
;   209 ----------------
;   210     [32]
;   211         -- idx-1 in edi, len in edx, NOT: idx addr in ebx, al set as below
;   212         -- bit #01 in al: 0 is e06 ("assigning to"), 1 is e106 ("reading from")
;   213         -- bit #08 in al, plus:
;   214         --  bit #04=1: [era] is at [esp+ecx*4+4]
;   215         --  bit #02=0: [era] is at [esp+ecx*4-4]
;   216         --  bit #02=1: [era] is at [esp+ecx*4]
;   217         -- bit #04 in al: [era] is at [esp+8]
;   218         -- bit #02 in al: [era] is at [esp+4]
;   219 
;   220         add edi,1
;   221         jl :opfixupNegativeIdx
;   222         -- but it might be a float:
;   223         cmp edi,h4
;   224         jl :e06ioobWhat             -- 0 or >length
;   225 --DEV use [ebx+edi*2-1] instead... :%LoadMint?
;   226         shl edi,2
;   227 --DEV
;   228 --    :!fixupIdxe92                 -- exception here mapped to e92vhnbaavEbxe06feh (see pdiagN.e)
;   229         cmp byte[edi-1],0x12
;   230         jne :e05sinaae06
;   231         fld qword[edi]
;   232         call :%down53
;   233         sub esp,8
;   234         fistp qword[esp]
;   235         call :%near53
;   236         mov edi,[esp]
;   237         add esp,8
;   238         cmp edi,0
;   239         jge :opfixupIdxNotNegative
;   240       ::opfixupNegativeIdx
;   241             add edi,edx
;   242             xor ebx,ebx
;   243             cmp edi,edx
;   244             jae :e06ioobp1WhatN
;   245             ret
;   246       ::opfixupIdxNotNegative
;   247         sub edi,1
;   248         xor ebx,ebx
;   249         cmp edi,edx
;   250         jae :e06ioobp1What          -- > length or still <=0
;   251     [64]
;   252         -- NB: calling code usually has the 32-bit comment, even in 64-bit code.
;   253         --      if it says esp, map it from the above and update the comment,
;   254         --      once you have proved it is correct and fully tested, that is.
;   255         -- idx-1 in rdi, len in rdx, NOT: idx addr in rbx, al set as below
;   256         -- bit #01 in al: 0 is e06 ("assigning to"), 1 is e106 ("reading from")
;   257         -- bit #08 in al, plus:
;   258         --  bit #04=1: [era] is at [rsp+rcx*8+8]
;   259         --  bit #02=0: [era] is at [rsp+rcx*8-8]
;   260         --  bit #02=1: [era] is at [rsp+rcx*8]
;   261         -- bit #04 in al: [era] is at [rsp+16]
;   262         -- bit #02 in al: [era] is at [rsp+8]
;   263 
;   264         add rdi,1
                add rdi,1                 ;#0044144B: 48:203307 01               uv 80 80  1 185      
;   265         jl :opfixupNegativeIdx
                jl #00441493              ;#0044144F: 174 42                     v  00 00  1 185      
;   266         -- but it might be a float:
;   267 --      cmp rdi,h4
;   268         mov r15,h4  -- DEV should always already be so?...
                mov r15,h4                ;#00441451: 49:277 0000000000000040    uv 8000 00  1 186      
;   269         cmp rdi,r15
                cmp rdi,r15               ;#0044145B: 49:073377                  uv 00 8080  1 187 8000   
;   270         jl :e06ioobWhat             -- 0 or >length
                jl #004413C3              ;#0044145E: 017214 5FFFFFFF            v  00 00  1 187      
;   271         shl rdi,2
                shl rdi,2                 ;#00441464: 48:301347 02               u  80 80  1 188      
;   272 --DEV
;   273 --    :!fixupIdxe92                 -- exception here mapped to e92vhnbaavEbxe06feh (see pdiagN.e)
;   274         cmp byte[rdi-1],0x12
                cmp byte[rdi-1],#12       ;#00441468: 200177 FF 12               u  00 80  2 191    *80*
;   275         jne :e05sinaae06
                jne #004413BD             ;#0044146C: 017205 4BFFFFFF            v  00 00  1 192      
;   276         fld tbyte[rdi]
                fld tbyte[rdi]            ;#00441472: 333057                     np 00 80  3 193      
;   277 --      fldcw [down53]
;   278         call :%down53
                call #00441389 (:%down53)  ;#00441474: 350 10FFFFFF               v  00 00  1 196      
;   279         sub rsp,8
                sub rsp,8                 ;#00441479: 48:203354 08               uv 10 10  1 197      
;   280         fistp qword[rsp]
                fistp qword[rsp]          ;#0044147D: 337074044                  np 00 10  6 200    *10*
;   281 --      fldcw [near53]
;   282 --      call :%near53
;   283         call :%near64
                call #004413A5 (:%near64)  ;#00441480: 350 20FFFFFF               v  00 00  1 206      
;   284         mov rdi,[rsp]
                mov rdi,[rsp]             ;#00441485: 48:213074044               uv 80 10  1 207      
;   285         add rsp,8
                add rsp,8                 ;#00441489: 48:203304 08               vu 10 10  1 207      
;   286         cmp rdi,0
                cmp rdi,0                 ;#0044148D: 48:203377 00               uv 00 80  1 208      
;   287         jge :opfixupIdxNotNegative
                jge #0044149F             ;#00441491: 175 0C                     v  00 00  1 208      
;   288       ::opfixupNegativeIdx
;   289             add rdi,rdx
                    add rdi,rdx           ;#00441493: 48:001327                  uv 80 84  1 209      
;   290             xor rbx,rbx
                    xor rbx,rbx           ;#00441496: 48:061333                  vu 08 08  1 209      
;   291             cmp rdi,rdx
                    cmp rdi,rdx           ;#00441499: 48:071327                  uv 00 84  1 210      
;   292             jae :e06ioobp1WhatN
                    jae #00441424         ;#0044149C: 163 86                     v  00 00  1 210      
;   293             ret
                    ret                   ;#0044149E: 303                        np 00 00  2 211      
;   294       ::opfixupIdxNotNegative
;   295         sub rdi,1
                sub rdi,1                 ;#0044149F: 48:203357 01               uv 80 80  1 213      
;   296         xor rbx,rbx
                xor rbx,rbx               ;#004414A3: 48:061333                  vu 08 08  1 213      
;   297         cmp rdi,rdx
                cmp rdi,rdx               ;#004414A6: 48:071327                  uv 00 84  1 214      
;   298         jae :e06ioobp1What          -- > length or still <=0
                jae #00441425             ;#004414A9: 017203 76FFFFFF            v  00 00  1 214      
;   299     []
;   300         ret
                ret                       ;#004414AF: 303                        np 00 00  2 215      
;   301 
;   302 --/*
;   303 procedure :%fixupSliceStart(:%)
;   304 end procedure -- (for Edita/CtrlQ)
;   305 --*/
;   306     :%fixupSliceStart
;   307 ---------------------
;   308     [32]
;   309         add edi,1
;   310         jle :fixupNegativeSliceStart
;   311         -- but it might be a float:
;   312         cmp edi,h4
;   313         jl :e10sspeosediedx0
;   314         shl edi,2
;   315 --DEV
;   316 --  :!fixupSliceStarte92            -- exception here mapped to e92vhnbaavEbxe10feh
;   317         cmp byte[edi-1],0x12
;   318         jne e05sinaae10             -- subscript is not an atom [era as per e10]
;   319         fld qword[edi]
;   320 --      fldcw [down53]
;   321         call :%down53
;   322         sub esp,8
;   323         fistp qword[esp]
;   324 --      fldcw [near53]
;   325         call :%near53
;   326         mov edi,[esp]
;   327         add esp,8
;   328         cmp edi,0
;   329         jge :fixupSliceStartNotNegative
;   330       ::fixupNegativeSliceStart
;   331             add edi,edx
;   332             xor ebx,ebx
;   333             cmp edi,edx
;   334             ja :e10sspeosediedxN    -- slice starts past end of sequence (%d > %d)
;   335             ret
;   336       ::fixupSliceStartNotNegative
;   337         sub edi,1
;   338         xor ebx,ebx
;   339         cmp edi,edx
;   340         ja :e10sspeosediedx     -- slice starts past end of sequence (%d > %d)
;   341         ret
;   342     [64]
;   343         add rdi,1
                add rdi,1                 ;#004414B0: 48:203307 01               uv 80 80  1 217      
;   344         jle :fixupNegativeSliceStart
                jle #004414F8             ;#004414B4: 176 42                     v  00 00  1 217      
;   345         -- but it might be a float:
;   346         mov r15,h4
                mov r15,h4                ;#004414B6: 49:277 0000000000000040    uv 8000 00  1 218      
;   347         cmp rdi,r15
                cmp rdi,r15               ;#004414C0: 49:073377                  uv 00 8080  1 219 8000   
;   348         jl :e10sspeosediedx0
                jl #00441428              ;#004414C3: 017214 5FFFFFFF            v  00 00  1 219      
;   349         shl rdi,2
                shl rdi,2                 ;#004414C9: 48:301347 02               u  80 80  1 220      
;   350 --DEV
;   351 --  :!fixupSliceStarte92            -- exception here mapped to e92vhnbaavEbxe10feh
;   352         cmp byte[rdi-1],0x12
                cmp byte[rdi-1],#12       ;#004414CD: 200177 FF 12               u  00 80  2 223    *80*
;   353         jne e05sinaae10             -- subscript is not an atom [era as per e10]
                jne #004413C2             ;#004414D1: 017205 EBFEFFFF            v  00 00  1 224      
;   354         fld tbyte[rdi]
                fld tbyte[rdi]            ;#004414D7: 333057                     np 00 80  3 225      
;   355 --      fldcw [down53]
;   356         call :%down53
                call #00441389 (:%down53)  ;#004414D9: 350 ABFEFFFF               v  00 00  1 228      
;   357         sub rsp,8
                sub rsp,8                 ;#004414DE: 48:203354 08               uv 10 10  1 229      
;   358         fistp qword[rsp]
                fistp qword[rsp]          ;#004414E2: 337074044                  np 00 10  6 232    *10*
;   359 --      fldcw [near53]
;   360 --      call :%near53
;   361         call :%near64
                call #004413A5 (:%near64)  ;#004414E5: 350 BBFEFFFF               v  00 00  1 238      
;   362         mov rdi,[rsp]
                mov rdi,[rsp]             ;#004414EA: 48:213074044               uv 80 10  1 239      
;   363         add rsp,8
                add rsp,8                 ;#004414EE: 48:203304 08               vu 10 10  1 239      
;   364         cmp rdi,0
                cmp rdi,0                 ;#004414F2: 48:203377 00               uv 00 80  1 240      
;   365         jge :fixupSliceStartNotNegative
                jge #00441508             ;#004414F6: 175 10                     v  00 00  1 240      
;   366       ::fixupNegativeSliceStart
;   367             add rdi,rdx
                    add rdi,rdx           ;#004414F8: 48:001327                  uv 80 84  1 241      
;   368             xor rbx,rbx
                    xor rbx,rbx           ;#004414FB: 48:061333                  vu 08 08  1 241      
;   369             cmp rdi,rdx
                    cmp rdi,rdx           ;#004414FE: 48:071327                  uv 00 84  1 242      
;   370             ja :e10sspeosediedxN    -- slice starts past end of sequence (%d > %d)
                    ja #00441429          ;#00441501: 017207 22FFFFFF            v  00 00  1 242      
;   371             ret
                    ret                   ;#00441507: 303                        np 00 00  2 243      
;   372       ::fixupSliceStartNotNegative
;   373         sub rdi,1
                sub rdi,1                 ;#00441508: 48:203357 01               uv 80 80  1 245      
;   374         xor rbx,rbx
                xor rbx,rbx               ;#0044150C: 48:061333                  vu 08 08  1 245      
;   375         cmp rdi,rdx
                cmp rdi,rdx               ;#0044150F: 48:071327                  uv 00 84  1 246      
;   376         ja :e10sspeosediedx     -- slice starts past end of sequence (%d > %d)
                ja #00441427              ;#00441512: 017207 0FFFFFFF            v  00 00  1 246      
;   377         ret
                ret                       ;#00441518: 303                        np 00 00  2 247      
;   378     []
;   379 
;   380 --/*
;   381 procedure :%fixupSliceEnd(:%)
;   382 end procedure -- (for Edita/CtrlQ)
;   383 --*/
;   384     :%fixupSliceEnd
;   385 -------------------
;   386     [32]
;   387         -- idx in edi, len in edx, cl=0/4/8/12 etc for era
;   388         -- NB flags from the cmp edi,edx must be undamaged!
;   389         jl :fixupNegativeSliceEnd
;   390 
;   391         -- but it might be a float:
;   392         cmp edi,h4
;   393 --      jl e06ioobWhat
;   394         jl :e11sepeosediedx
;   395         shl edi,2
;   396 --DEV
;   397 --    :!fixupSliceEnde92                  -- exception here mapped to e92vhnbaavEbxe11feh
;   398         cmp byte[edi-1],0x12
;   399         jne :e08seinaie11                -- slice end is not an integer [era as per e11]
;   400         fld qword[edi]
;   401         call :%down53
;   402         sub esp,8
;   403         fistp qword[esp]
;   404         call :%near53
;   405         mov edi,[esp]
;   406         add esp,8
;   407         cmp edi,0
;   408         jge :fixupSliceEndNotNegative
;   409       ::fixupNegativeSliceEnd
;   410             lea edi,[edi+edx+1]
;   411             xor ebx,ebx
;   412             cmp edi,edx
;   413             ja :e11sepeosediedxN    -- slice ends past end of sequence (%d > %d)
;   414             ret
;   415       ::fixupSliceEndNotNegative
;   416         cmp edi,edx
;   417         ja :e11sepeosediedx     -- slice ends past end of sequence (%d > %d)
;   418         xor ebx,ebx
;   419         ret
;   420     [64]
;   421         -- idx in rdi, len in rdx, cl=4/8 for era
;   422         -- NB flags from the cmp rdi,rdx must be undamaged!
;   423         jl :fixupNegativeSliceEnd
                jl #0044155D              ;#00441519: 174 42                     v  00 00  1 249      
;   424 
;   425         -- but it might be a float:
;   426 --      cmp rdi,h4
;   427         mov r15,h4
                mov r15,h4                ;#0044151B: 49:277 0000000000000040    uv 8000 00  1 250      
;   428         cmp rdi,r15
                cmp rdi,r15               ;#00441525: 49:073377                  uv 00 8080  1 251 8000   
;   429 --      jl e06ioobWhat
;   430         jl :e11sepeosediedx
                jl #00441431              ;#00441528: 017214 03FFFFFF            v  00 00  1 251      
;   431         shl rdi,2
                shl rdi,2                 ;#0044152E: 48:301347 02               u  80 80  1 252      
;   432 --DEV
;   433 --    :!fixupSliceEnde92                  -- exception here mapped to e92vhnbaavEbxe11feh
;   434         cmp byte[rdi-1],0x12
                cmp byte[rdi-1],#12       ;#00441532: 200177 FF 12               u  00 80  2 255    *80*
;   435         jne :e08seinaie11                -- slice end is not an integer [era as per e11]
                jne #00441426             ;#00441536: 017205 EAFEFFFF            v  00 00  1 256      
;   436         fld qword[rdi]
                fld qword[rdi]            ;#0044153C: 335007                     np 00 80  1 257      
;   437 --      fldcw [down53]
;   438         call :%down53
                call #00441389 (:%down53)  ;#0044153E: 350 46FEFFFF               v  00 00  1 258      
;   439         sub rsp,8
                sub rsp,8                 ;#00441543: 48:203354 08               uv 10 10  1 259      
;   440         fistp qword[rsp]
                fistp qword[rsp]          ;#00441547: 337074044                  np 00 10  6 262    *10*
;   441 --      fldcw [near53]
;   442 --      call :%near53
;   443         call :%near64
                call #004413A5 (:%near64)  ;#0044154A: 350 56FEFFFF               v  00 00  1 268      
;   444         mov rdi,[rsp]
                mov rdi,[rsp]             ;#0044154F: 48:213074044               uv 80 10  1 269      
;   445         add rsp,8
                add rsp,8                 ;#00441553: 48:203304 08               vu 10 10  1 269      
;   446         cmp rdi,0
                cmp rdi,0                 ;#00441557: 48:203377 00               uv 00 80  1 270      
;   447         jge :fixupSliceEndNotNegative
                jge #0044156F             ;#0044155B: 175 12                     v  00 00  1 270      
;   448       ::fixupNegativeSliceEnd
;   449             lea rdi,[rdi+rdx+1]
                    lea rdi,[rdi+rdx+1]   ;#0044155D: 48:215174027 01            uv 80 84  1 271      
;   450             xor rbx,rbx
                    xor rbx,rbx           ;#00441562: 48:061333                  vu 08 08  1 271      
;   451             cmp rdi,rdx
                    cmp rdi,rdx           ;#00441565: 48:071327                  uv 00 84  1 272      
;   452             ja :e11sepeosediedxN    -- slice ends past end of sequence (%d > %d)
                    ja #0044142A          ;#00441568: 017207 BCFEFFFF            v  00 00  1 272      
;   453             ret
                    ret                   ;#0044156E: 303                        np 00 00  2 273      
;   454       ::fixupSliceEndNotNegative
;   455         cmp rdi,rdx
                cmp rdi,rdx               ;#0044156F: 48:071327                  uv 00 84  1 275      
;   456         ja :e11sepeosediedx     -- slice ends past end of sequence (%d > %d)
                ja #00441431              ;#00441572: 017207 B9FEFFFF            v  00 00  1 275      
;   457         xor rbx,rbx
                xor rbx,rbx               ;#00441578: 48:061333                  uv 08 08  1 276      
;   458         ret
                ret                       ;#0044157B: 303                        np 00 00  2 277      
;   459     []
;   460       }
;   461 
    jmp #0044298D (:%opRetf)              ;#0044157C: 351 0C140000               v  00 00  1 279      
;C:\Program Files (x86)\Phix\builtins\VM\pFPU.e:
;===============================================
;     1 --
;     2 -- pFPU.e
;     3 -- ======
;     4 --
;     5 --  Floating point precision control
;     6 --  implements :%down53, :%near53, :%trunc53, :%down64, :%near64, :%trunc64
;     7 --  Used by: pSubseN.e, pMath.e, pHeap.e, etc, etc
;     8 --
;     9 --  The Control Word rounding control is in bits 10..11:
;    10 --      00 = and_bits(ax,0xF3FF) = Round to nearest, or even if equidistant (this is the initialized state)
;    11 --      01 = 0x0400 = Round down (toward -infinity)
;    12 --      10 = 0x0800 = Round up (toward +infinity)
;    13 --      11 = 0x0C00 = Truncate (toward 0)
;    14 --
;    15 --  The Control Word precision control is in bits 8..9 (0x0300)
;    16 --      00 = and_bits(ax,0xFCFF) = 24 bits (REAL4)
;    17 --      01 = Not used
;    18 --      10 = 0x0200 = 53 bits (REAL8)
;    19 --      11 = 0x0300 = 64 bits (REAL10) (this is the initialized state)
;    20 --
;    21 --
;    22 --Erm, investigate fcomi[p] instead of sahf etc. (use ja/jb not jl/jg, jz/ne etc are fine)
;    23 --DEV ensure we are looping on C2/fprem
;    24 -- Not strictly relevant, but while I've got that web page open, some interesting Status Word bits (after compare):
;    25 --      C3 = 0x400 = Z flag
;    26 --      C2 = 0x040 = P flag
;    27 --      C1 = 0x020 = ?
;    28 --      C0 = 0x010 = C flag
;    29 --without debug
;    30 
;    31 -- fpu round/precision control: (these are treated as 16-bit words)
;    32 integer near53 = 0  -- usual/default setting for 32-bit
;    33 integer down53 = 0  -- for truncating f.p. idx, etc
;    34 integer trunc53 = 0 -- for poke etc
;    35 integer near64 = 0  -- usual/default setting for 64-bit, unused in 32-bit
;    36 integer down64 = 0  -- used by (32-bit) opFloor, and 64-bit for idx, etc
;    37 integer trunc64 = 0 -- for poke etc
;    38 
;    39 --/*
;    40 procedure :>initFPU(:>)
;    41 end procedure -- (for Edita/CtrlQ)
;    42 --*/
;    43 --DEV opCallOnceYeNot
;    44 --#ilASM{ jmp :%opRetf
;    45 #ilASM{ jmp :fin
                jmp #004413B3             ;#00441319: 351 95000000               v  00 00  1   1      
;    46 
;    47 --/*
;    48 procedure :>initFPU(:>)
;    49 end procedure -- (for Edita/CtrlQ)
;    50 --*/
;    51     :>initFPU
;    52 -------------
;    53 --      call :>initFEH
;    54         fninit                      -- initialise FPU
                fninit                    ;#0044131E: 333343                     np 00 00 12   2      
;    55 --DEV tryme: [??]
;    56 --/*
;    57     [32]
;    58 --      jmp :%near53
;    59         push word #027F
;    60         fldcw word[esp]
;    61         add esp,2
;    62     [64]
;    63 --      jmp :%near64
;    64         push word #057F
;    65         fldcw word[rsp]
;    66         add rsp,2
;    67     []
;    68 --  near53 = #27F
;    69 --  down53 = #67F
;    70 --  near64 = 0
;    71 --  down64 = #77F
;    72 --*/
;    73     [32]
;    74         sub esp,4
;    75         fnstcw word[esp]            --                                                  -- 7F 03 (NB: le notation)
;    76         and word[esp],0xF0FF        -- set rounding to nearest or even,                 -- 7F 00
;    77         or word[esp],0x0200         -- and 53 bit precision as the default              -- 7F 02
;    78         fldcw word[esp]
;    79         mov ax,word[esp]
;    80         add esp,4
;    81     [64]
;    82         sub rsp,8
                sub rsp,8                 ;#00441320: 48:203354 08               uv 10 10  1  14      
;    83         fnstcw word[rsp]            --                                                  -- 7F 03 (NB: le notation)
                fnstcw word[rsp]          ;#00441324: 331074044                  np 00 10  2  17    *10*
;    84         and word[rsp],0xF0FF        -- set rounding to nearest or even,                 -- 7F 00
                and word[rsp],-3841       ;#00441327: 146:201044044 FFF0         uv 00 10  3  19      
;    85         or word[rsp],0x0200         -- and 53 bit precision                             -- 7F 02
                or word[rsp],512          ;#0044132D: 146:201014044 0002         vu 00 10  3  21      
;    86         mov ax,word[rsp]
                mov ax,word[rsp]          ;#00441333: 146:213004044              uv 01 10  1  22      
;    87     []
;    88         mov word[near53],ax         --                                                  -- 7F 02
                mov word[#00402F30] (near53),ax  ;#00441337: 146:211005 F21BFCFF        uv 00 01  1  23 01   
;    89         or ax,0x0600                -- round down, 53 bit precision                     -- 7F 06
                or ax,1536                ;#0044133E: 146:201310 0006            vu 01 01  1  23      
;    90         mov word[down53],ax
                mov word[#00402F38] (down53),ax  ;#00441343: 146:211005 EE1BFCFF        uv 00 01  1  24      
;    91         or ax,0x0700                -- round down, 64 bit precision                     -- 7F 07
                or ax,1792                ;#0044134A: 146:201310 0007            vu 01 01  1  24      
;    92         mov word[down64],ax
                mov word[#00402F50] (down64),ax  ;#0044134F: 146:211005 FA1BFCFF        uv 00 01  1  25      
;    93         or ax,0x0E00                -- truncate, 64 bit precision
                or ax,3584                ;#00441356: 146:201310 000E            vu 01 01  1  25      
;    94         mov word[trunc64],ax
                mov word[#00402F58] (trunc64),ax  ;#0044135B: 146:211005 F61BFCFF        uv 00 01  1  26      
;    95         sub ax,0x0100               -- truncate, 53 bit precision
                sub ax,256                ;#00441362: 146:201350 0001            vu 01 01  1  26      
;    96         mov word[trunc53],ax
                mov word[#00402F40] (trunc53),ax  ;#00441367: 146:211005 D21BFCFF        uv 00 01  1  27      
;    97     [64]
;    98         mov ax,word[rsp]
                mov ax,word[rsp]          ;#0044136E: 146:213004044              vu 01 10  1  27      
;    99         add rsp,8
                add rsp,8                 ;#00441372: 48:203304 08               uv 10 10  1  28      
;   100         or ax,0x0300
                or ax,768                 ;#00441376: 146:201310 0003            vu 01 01  1  28      
;   101         mov word[near64],ax                                                             -- 7F 03
                mov word[#00402F48] (near64),ax  ;#0044137B: 146:211005 C61BFCFF        uv 00 01  1  29      
;   102         fldcw word[near64]
                fldcw word[#00402F48] (near64)  ;#00441382: 331055 C01BFCFF            np 00 00  8  30      
;   103     []
;   104         ret
                ret                       ;#00441388: 303                        np 00 00  2  38      
;   105 
;   106 --/*
;   107 procedure :%down53(:%)
;   108 end procedure -- (for Edita/CtrlQ)
;   109 --*/
;   110     :%down53
;   111 ------------
;   112         fldcw word[down53]
                fldcw word[#00402F38] (down53)  ;#00441389: 331055 A91BFCFF            np 00 00  8  40      
;   113         ret
                ret                       ;#0044138F: 303                        np 00 00  2  48      
;   114 
;   115 --/*
;   116 procedure :%near53(:%)
;   117 end procedure -- (for Edita/CtrlQ)
;   118 --*/
;   119     :%near53
;   120 ------------
;   121         fldcw word[near53]
                fldcw word[#00402F30] (near53)  ;#00441390: 331055 9A1BFCFF            np 00 00  8  50      
;   122         ret
                ret                       ;#00441396: 303                        np 00 00  2  58      
;   123 
;   124 --/*
;   125 procedure :%trunc53(:%)
;   126 end procedure -- (for Edita/CtrlQ)
;   127 --*/
;   128     :%trunc53
;   129 ------------
;   130         fldcw word[trunc53]
                fldcw word[#00402F40] (trunc53)  ;#00441397: 331055 A31BFCFF            np 00 00  8  60      
;   131         ret
                ret                       ;#0044139D: 303                        np 00 00  2  68      
;   132 
;   133 --/*
;   134 procedure :%down64(:%)
;   135 end procedure -- (for Edita/CtrlQ)
;   136 --*/
;   137     :%down64
;   138 ------------
;   139         fldcw word[down64]
                fldcw word[#00402F50] (down64)  ;#0044139E: 331055 AC1BFCFF            np 00 00  8  70      
;   140         ret
                ret                       ;#004413A4: 303                        np 00 00  2  78      
;   141 
;   142 --/*
;   143 procedure :%near64(:%)
;   144 end procedure -- (for Edita/CtrlQ)
;   145 --*/
;   146     :%near64
;   147 ------------
;   148         fldcw word[near64]
                fldcw word[#00402F48] (near64)  ;#004413A5: 331055 9D1BFCFF            np 00 00  8  80      
;   149         ret
                ret                       ;#004413AB: 303                        np 00 00  2  88      
;   150 
;   151 --/*
;   152 procedure :%trunc64(:%)
;   153 end procedure -- (for Edita/CtrlQ)
;   154 --*/
;   155     :%trunc64
;   156 ------------
;   157         fldcw word[trunc64]
                fldcw word[#00402F58] (trunc64)  ;#004413AC: 331055 A61BFCFF            np 00 00  8  90      
;   158         ret
                ret                       ;#004413B2: 303                        np 00 00  2  98      
;   159 
;   160     ::fin
;   161       }
    jmp #0044298D (:%opRetf)              ;#004413B3: 351 D5150000               v  00 00  1 100      
;C:\Program Files (x86)\Phix\builtins\VM\pSubssN.e:
;==================================================
;     1 --
;     2 -- pSubssN.e
;     3 -- =========
;     4 --
;     5 --  Various subscripting routines:
;     6 --
;     7 --      :%pSubss            -- res := ref[idx1]~[idxN..sliceend]
;     8 --      :%pSubsss           -- res := string[slicestart..sliceend]
;     9 --
;    10 
;    11 include builtins\VM\pHeap.e     -- :%pDealloc, :%pAllocStr, :%pAllocSeq
;    12 
;    13 include builtins\VM\pFixup.e    -- negative and floating point index handling (:%fixupIndex)
;    14 
;    15 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#00440F15: 351 731A0000               v  00 00  1   1      
;    16 
;    17 --DEV FIXME: (and the :!bang labels below)
;    18     ::e04atsaa4
;    19         int3
                int3                      ;#00440F1A: 314                        np 00 00 13   2      
;    20     ::e04atsaa9
;    21         int3
                int3                      ;#00440F1B: 314                        np 00 00 13  15      
;    22     ::e04atsaap8
;    23         int3
                int3                      ;#00440F1C: 314                        np 00 00 13  28      
;    24     ::e04atsaap12
;    25         int3
                int3                      ;#00440F1D: 314                        np 00 00 13  41      
;    26     ::e09slinecx
;    27         int3
                int3                      ;#00440F1E: 314                        np 00 00 13  54      
;    28 --  ::e09slinecx2
;    29 --      int3
;    30 
;    31 --/*
;    32 procedure :%pSubss(:%)
;    33 end procedure -- (for Edita/CtrlQ)
;    34 --*/
;    35     :%pSubss        -- res := ref[idx1]~[idxN..sliceend]
;    36 ------------
;    37     [32]
;    38         --calling convention:
;    39         -- <perform any required opUnassigned's>
;    40         --  mov ecx,N
;    41         --  push <return address>
;    42         --  push res            -- result var addr
;    43         --  push [sliceend]     -- (opUnassigned)
;    44         --  push [idxN]..[idx1] -- (opUnassigned)
;    45         --  mov esi,[ref]       -- (opUnassigned)
;    46         --  jmp :%pSubss        -- actually a call
;    47         --<return address>
;    48 
;    49       ::pSubssWhile
;    50             pop edi             -- next idx (ref)
;    51 --expect exception here for subscript errors...
;    52           :!pSubsse94   -- exception here mapped to e94vhnbaav(edx)
;    53             mov al,[ebx+esi*4-1]
;    54             mov edx,[ebx+esi*4-12]  -- length
;    55             shl esi,2
;    56             sub edi,1
;    57             test al,0x80
;    58             jz :e04atsaa9       -- era @ [esp+ecx*4+4]
;    59 
;    60             sub ecx,1
;    61             jz :pSubssEndWhile -- quit loop with startslice (aka idxN) ref in edi (may need fixupSliceStart)
;    62 
;    63             cmp edi,edx
;    64             jb @f               -- unsigned jump, lets 0..len-1 through
;    65                                 --               (we just decremented edi)
;    66                 mov al,8+4+1        -- [era] is [esp+ecx*4+4], "reading from"
;    67                 call :%fixupIndex   -- idx-1 in edi, len in edx, al set
;    68                 mov al,byte[esi-1]  -- as we just trashed it
;    69           @@:
;    70             cmp al,0x80
;    71             jne @f
;    72             mov esi,[esi+edi*4]
;    73             jmp :pSubssWhile
;    74 
;    75           @@:
;    76             cmp al,0x82
;    77             jne :e04atsaap8         -- era @ [esp+ecx*4+8]
;    78             lea esi,[esi+edi]       -- address of (first) char
;    79             sub ecx,1
;    80             jnz :e04atsaap12        -- strings must be last segment
;    81 
;    82       ::pSubssEndWhile
;    83         cmp edi,edx
;    84         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here)
;    85                             --               (we just did a dec edi)
;    86                             --               (slice start can be 1..length+1)
;    87             mov cl,12               -- [era] @ [esp+12]
;    88             call :%fixupSliceStart  -- idx in edi, len in edx
;    89       @@:
;    90 -->     mov [ap1],edi           -- save slice start
;    91 --not: edx,edi,ecx,ebx,esi,eax...
;    92 --      mov ??,edi
;    93 --      pop edi                 -- ref slice end
;    94         xchg [esp],edi          -- swap slice start/end
;    95         cmp edi,edx
;    96         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here, and no dec edi)
;    97                             --               (slice end can be 0..length)
;    98 --          mov cl,8            -- [era] @ [esp+8]
;    99             mov cl,12           -- [era] @ [esp+12] (inc ret to @@:)
;   100             call :%fixupSliceEnd    -- idx in edi, len in edx
;   101       @@:
;   102 
;   103         -- stack contents:
;   104         --  [esp] slice start (0-based)
;   105         --  [esp+4] addr res
;   106         --  [esp+8] return address
;   107         mov ecx,edi             -- slice end
;   108 --      xor ebx,ebx
;   109         mov edi,[esp+4]         -- address of res (re-fetched later)
;   110 -->     sub ecx,[ap1]           -- slice start
;   111         sub ecx,[esp]           -- slice start
;   112         jl :e09slinecx          -- slice length is negative
;   113 --      mov edi,[esp]           -- address of res (re-fetched later)
;   114 --      mov edi,[esp+4]         -- address of res (re-fetched later)
;   115         mov edx,ecx             -- new object len = slice len
;   116         mov edi,[edi]           -- ref of result (prev)
;   117         cmp al,0x80
;   118         jne :pSubssStr
;   119         --
;   120         -- can we do things in-situ?
;   121         --
;   122         cmp edi,h4
;   123 --      jle :pSubssp1leh4
;   124 --    ::pSubssp1leh4    -- ref p1 <= h4         (first test)
;   125         jg @f
;   126             -- if new length = length(p2) then incref p2 -> p1, exit/all done
;   127             cmp edx,[esi-12]
;   128             jne :pSubssNewSeq
;   129             -- (this is the [int/unassigned]:=x[1..$] case)
;   130             add esp,4                   -- discard slice start (must be 0 anyway)
;   131             pop edi                     -- addr tgt
;   132             mov edx,[esi-8]             -- refcount
;   133             lea eax,[esi+1]
;   134             add edx,1
;   135             ror eax,2                   -- == ref p2
;   136             mov [esi-8],edx
;   137             mov [edi],eax               -- (no need to dealloc)
;   138             ret
;   139       @@:
;   140         shl edi,2
;   141         cmp dword[edi-8],1              -- refcount of 1
;   142 --      jne :pSubssp2rcn1
;   143 --    ::pSubssp2rcn1    -- refcount(esi/p2)!=1  (second test)
;   144         je @f
;   145             cmp edi,esi
;   146             jne :pSubssp2nep1
;   147             cmp edx,[esi-12]
;   148             jne :pSubssNewSeq
;   149             -- (this must therefore be the x:=x[1..$] case, at least datawise, 
;   150             --  although the hll could be say ti:=table[i][1..$], repeated)
;   151 --          pop edi                     -- [1] discard addr res
;   152             add esp,8                   -- discard slice start and addr res
;   153             ret
;   154       @@:
;   155         cmp edi,esi
;   156 --      jne :pSubssp2nep1
;   157         je @f
;   158           ::pSubssp2nep1    -- edi!=esi             (third test)
;   159             cmp edx,[esi-12]                -- if lengths match
;   160             jne :pSubssNewSeq
;   161             add esp,4                       -- discard slice start (must be 0 anyway)
;   162             pop edi                         -- addr tgt
;   163             mov ecx,[esi-8]                 -- p2 refcount (or ref[idx1][idx2]..[idxn-1])
;   164             lea eax,[esi+1]                 -- calc ref (for "") in eax
;   165             add ecx,1
;   166             mov edx,[edi]                   -- get prev ref
;   167             mov [esi-8],ecx                 -- incref
;   168             ror eax,2                       -- == ref p2
;   169             mov ecx,[ebx+edx*4-8]           -- p1 refcount
;   170             mov [edi],eax                   -- save new ref
;   171             sub ecx,1
;   172             jz :%pDealloc
;   173             mov [ebx+edx*4-8],ecx           -- decref
;   174             ret
;   175 
;   176       @@:
;   177         -- (this is the x:=x[i..j] case, with a refcount of 1)
;   178         push ecx                        --[?] save new length
;   179         xor ebx,ebx
;   180 -->     mov edx,[ap1]                   -- slice start (0-based)
;   181         mov edx,[esp+4]                 -- slice start (0-based)
;   182         mov ecx,[edi-12]                -- original length
;   183         add edx,1
;   184       ::pSubssDeallocPrevLoop
;   185             sub edx,1
;   186             jz :pSubssDeallocPrevDone
;   187             mov eax,[esi]
;   188             sub ecx,1
;   189             add esi,4
;   190             cmp eax,h4
;   191             jle :pSubssDeallocPrevLoop
;   192             sub dword[ebx+eax*4-8],1
;   193             jnz :pSubssDeallocPrevLoop
;   194             pushad
;   195             mov edx,eax
;   196 --  if debugmem2
;   197 --  mov eax,[esp+40]    -- (DEV: untested!)
;   198 --  mov [dmFera],eax
;   199 --  end if
;   200             push dword[esp+44]
;   201             call :%pDealloc0
;   202             popad
;   203             jmp :pSubssDeallocPrevLoop
;   204 
;   205       ::pSubssDeallocPrevDone
;   206         --
;   207         -- re-site the header.
;   208         --
;   209         -- register contents:
;   210         --  eax - unused
;   211         --  ecx - length less slice start (needed below)
;   212         --  edx - 0
;   213         --  esi - location of new s[1]
;   214         --  edi - raw addr of prev header
;   215         --  [esp] = new length
;   216         --  [esp+4] = slice start (0-based), aka discarded items
;   217         --  [esp+8] = addr res
;   218         --  [esp+12] = return address
;   219         --
;   220         cmp esi,edi
;   221         jne :pSubssReSiteHeader
;   222             -- must be x=x[1..??] case, no need to resite header:
;   223             pop edx                     -- new length
;   224             add esp,8                   -- discard slice start and addr res
;   225             mov [esi-12],edx            -- set new length
;   226             jmp :pSubssDeallocRest
;   227 
;   228       ::pSubssReSiteHeader
;   229         mov eax,[edi-16]                -- prev maxlen
;   230 -->     mov edx,[ap1]                   -- discarded items
;   231         mov edx,[esp+4]                 -- discarded items, aka slice start
;   232         mov ebx,[edi-4]                 -- type (added 1/11/14)
;   233         shl edx,2                       -- discarded items in bytes
;   234         mov [esi-16],eax                -- maxlen (unaltered)
;   235         mov eax,[edi-20]                -- previous slack
;   236 --      add edx,[edi-20]                -- previous slack
;   237         mov [esi-4],ebx                 -- type (unaltered)
;   238         add eax,edx                     -- new slack
;   239         mov [esi-8],dword 1             -- refcount (unaltered)
;   240         mov ebx,esi                     -- calculate new ref in ebx
;   241 --      pop dword[esi-12]               -- new length
;   242         pop edx                         -- new length
;   243         add esp,4                       -- discard slice start
;   244         add ebx,1
;   245         pop edi                         -- addr res
;   246         mov [esi-20],eax                -- set new slack
;   247         ror ebx,2
;   248 --      mov [esi-20],edx                -- set new slack
;   249         mov [esi-12],edx                -- set new length
;   250         mov [edi],ebx                   -- new ref of shifted header -> res
;   251         xor ebx,ebx                 -- important!
;   252       ::pSubssDeallocRest
;   253         lea esi,[esi+edx*4]             -- esi := esi[newlength+1]
;   254 
;   255       ::pSubssDeallocRestLoop
;   256         cmp ecx,edx
;   257         je :pSubssDeallocRestDone
;   258         mov eax,[esi]
;   259         sub ecx,1
;   260         add esi,4
;   261         cmp eax,h4
;   262         jle :pSubssDeallocRestLoop
;   263         sub dword[ebx+eax*4-8],1
;   264         jnz :pSubssDeallocRestLoop
;   265         pushad
;   266         mov edx,eax
;   267 --    if debugmem2
;   268 --      mov eax,[esp+32]
;   269 --      mov [dmFera],eax
;   270 --    end if
;   271         push dword[esp+32]
;   272         call :%pDealloc0
;   273         popad
;   274         jmp :pSubssDeallocRestLoop
;   275         
;   276 --      nop?
;   277       ::pSubssDeallocRestDone
;   278         ret
;   279 
;   280 
;   281       ::pSubssNewSeq
;   282         -- register contents:
;   283         --  al 0x80
;   284         --  ecx = edx = new length
;   285         --  esi = raw addr of p2
;   286         --  edi = unknown (ref or raw tgt)
;   287         --  [esp] = slice start (0-based)
;   288         --  [esp+4] = addr res
;   289 --      xor ebx,ebx
;   290 --mov ecx,edx
;   291 --      mov edx,[esp]               -- slice start (0-based)
;   292 --      pop edx                     -- slice start (0-based)
;   293         pop edi                     -- slice start (0-based)
;   294         mov edx,[esp+8]             -- era
;   295         call :%pAllocSeq            -- damages eax only
;   296 -->     mov edx,[ap1]               -- slice start
;   297 --      lea esi,[esi+edx*4]
;   298         lea esi,[esi+edi*4]
;   299         push eax                    --[?] save ref
;   300         test ecx,ecx
;   301         je :pSubssStore
;   302         lea edi,[ebx+eax*4]
;   303       @@:
;   304             lodsd                   -- mov eax,[esi], esi+=4
;   305             stosd                   -- mov [edi],eax, edi+=4
;   306             cmp eax,h4
;   307             jl :Subss2_no_incref
;   308                 add dword[ebx+eax*4-8],1
;   309           ::Subss2_no_incref
;   310             sub ecx,1
;   311             jnz @b
;   312         nop
;   313         jmp :pSubssStore
;   314 
;   315       ::pSubssStr
;   316         -- register contents:
;   317         --  al 0x82
;   318         --  ecx = edx = new length
;   319         --  esi = raw addr of p2
;   320         --  edi = ref p1
;   321         --  [esp] = slice start (post-fixup, zero-based)
;   322         --  [esp+4] = addr res
;   323         --  [esp+8] = return address
;   324         -- insitu if: slice starts at 1, and refcount p2 is 1.
;   325         -- jumps to @f(AllocStr) must preserve/reset edx(=ecx),ecx,esi.
;   326         cmp al,0x82                     -- sanity check
;   327         jne :e04atsaa4
;   328         mov eax,[esi-8]         -- refcount
;   329 --      mov edx,[ap1]           -- slice start (post-fixup/0-based)
;   330         mov edx,[esp]           -- slice start (post-fixup/0-based)
;   331         cmp eax,1
;   332 --      jne @f                  -- refcount!=1 (==>AllocStr)
;   333         jne :pSubssNewStr       -- refcount!=1 (==>AllocStr)
;   334         test edx,edx
;   335 --      jnz @f                  -- slice start is not 1 (==>AllocStr)
;   336         jnz :pSubssNewStr       -- slice start is not 1 (==>AllocStr)
;   337         cmp edi,h4
;   338 --      jg pSubssStrp1gh4
;   339         jg @f
;   340             -- p1 unassigned/integer.
;   341             -- can still just copy ref iff edx==length(p2) (eg x=s[1..-1])
;   342             cmp ecx,[esi-12]
;   343 --          jne @f              -- (==>AllocStr)
;   344             jne :pSubssNewStr
;   345             lea eax,[esi+1]
;   346             add esp,4           -- discard slice start (which is 1)
;   347             pop edi             -- addr tgt
;   348             ror eax,2           -- == ref p2 (or ref[idx1][idx2]...[idxn-1])
;   349             mov dword[esi-8],2  -- refcount is now 2
;   350             mov [edi],eax
;   351             ret
;   352 --    ::pSubssStrp1gh4
;   353       @@:
;   354         lea eax,[ebx+edi*4]
;   355     --  mov edx,edi             -- in case dealloc needed
;   356     --  cmp edi,esi
;   357         cmp eax,esi
;   358 --      jne pSubssStrp1nep2
;   359         jne @f
;   360             -- s=s[1..?], no incref/decref needed.
;   361             mov [esi-12],ecx    -- set new length
;   362 --          pop edi             -- discard addr tgt
;   363             add esp,8           -- discard slice start and addr tgt
;   364             mov byte[esi+ecx],0 -- plant new terminator
;   365             ret
;   366 --    ::pSubssStrp1nep2
;   367       @@:
;   368             -- p1!=p2.
;   369             -- again, we can still just copy ref p2 & deref p1, iff ecx==length(p2).
;   370             --  ie/eg a=b[1..-1] can just incref b, but a=b[1..-2] needs to
;   371             --       end up with two different length strings in a & b.
;   372             cmp ecx,[esi-12]
;   373 --          jne @f              -- (==>AllocStr)
;   374             jne :pSubssNewStr
;   375             mov edx,edi         -- for dealloc
;   376             mov dword[esi-8],2  -- set new refcount
;   377             add esp,4           -- discard slice start
;   378             pop edi             -- addr tgt
;   379             add esi,1
;   380             mov ecx,[eax-8]
;   381             ror esi,2           -- recreated ref p2 (or ref[idx][idx2]...[idxn-1])
;   382             dec ecx
;   383             mov [edi],esi
;   384             jz :%pDealloc
;   385             mov [eax-8],ecx
;   386             ret
;   387 --    @@:
;   388       ::pSubssNewStr
;   389 --      mov edx,ecx
;   390         pop edx                 -- slice start (post-fixup/0-based)
;   391 --      mov edx,[esp]           -- slice start (post-fixup/0-based)
;   392         call :%pAllocStr        -- damages eax only
;   393 --      mov edx,[ap1]           -- slice start (post-fixup/0-based)
;   394 --      mov edx,[esp]           -- slice start (post-fixup/0-based)
;   395 --      xor ebx,ebx
;   396 --      lea esi,[esi+edx]
;   397         add esi,edx
;   398         push eax                --[2] save ref
;   399         lea edi,[ebx+eax*4]
;   400 --      or ecx,ecx
;   401 --      je @f
;   402         rep movsb
;   403 --    @@:
;   404         xor eax,eax
;   405         stosb                   -- trailing null
;   406 
;   407       ::pSubssStore
;   408         pop eax                 --[2] newly created ref
;   409 --      add esp,4               -- discard slice start
;   410         pop edi                 -- addr result
;   411         mov edx,[edi]
;   412         mov [edi],eax
;   413         cmp edx,h4
;   414         jle @f
;   415             sub dword[ebx+edx*4-8],1
;   416             jz :%pDealloc
;   417       @@:
;   418         ret
;   419     [64]
;   420         --calling convention:
;   421         -- <perform any required opUnassigned's>
;   422         --  mov rcx,N
;   423         --  push <return address>
;   424         --  push res            -- result var addr
;   425         --  push [sliceend]     -- (opUnassigned)
;   426         --  push [idxN]..[idx1] -- (opUnassigned)
;   427         --  mov rsi,[ref]       -- (opUnassigned)
;   428         --  jmp :%pSubss        -- actually a call
;   429         --<return address>
;   430 
;   431       ::pSubssWhile
;   432             pop rdi             -- next idx (ref)
                    pop rdi               ;#00440F1F: 48:137                     uv 80 00  1  67      
;   433 --expect exception here for subscript errors...
;   434           :!pSubsse94   -- exception here mapped to e94vhnbaav(rdx)
;   435             mov al,[rbx+rsi*4-1]
                    mov al,[rbx+rsi*4-1]  ;#00440F21: 212104263 FF               vu 01 48  1  67      
;   436             mov rdx,[rbx+rsi*4-24]  -- length
                    mov rdx,[rbx+rsi*4-24]  ;#00440F25: 48:213124263 E8            uv 04 48  1  68      
;   437             shl rsi,2
                    shl rsi,2             ;#00440F2A: 48:301346 02               u  40 40  1  69      
;   438             sub rdi,1
                    sub rdi,1             ;#00440F2E: 48:203357 01               vu 80 80  1  69      
;   439             test al,0x80
                    test al,#80           ;#00440F32: 250 80                     uv 00 01  1  70      
;   440             jz :e04atsaa9       -- era @ [rsp+rcx*8+8]
                    jz #00440F1B          ;#00440F34: 164 E5                     v  00 00  1  70      
;   441 
;   442             sub rcx,1
                    sub rcx,1             ;#00440F36: 48:203351 01               uv 02 02  1  71      
;   443             jz :pSubssEndWhile -- quit loop with startslice (aka idxN) ref in rdi (may need fixupSliceStart)
                    jz #00440F65          ;#00440F3A: 164 29                     v  00 00  1  71      
;   444 
;   445             cmp rdi,rdx
                    cmp rdi,rdx           ;#00440F3C: 48:071327                  uv 00 84  1  72      
;   446             jb @f               -- unsigned jump, lets 0..len-1 through
                    jb #00440F4B          ;#00440F3F: 162 0A                     v  00 00  1  72      
;   447                                 --               (we just decremented rdi)
;   448                 mov al,8+4+1        -- [era] is [esp+ecx*4+4], "reading from"
                        mov al,13         ;#00440F41: 260 0D                     uv 01 00  1  73      
;   449                 call :%fixupIndex   -- idx-1 in rdi, len in rdx, al set
                        call #0044144B (:%fixupIndex)  ;#00440F43: 350 03050000               v  00 00  1  73      
;   450                 mov al,byte[rsi-1]  -- as we just trashed it
                        mov al,[esi-1]    ;#00440F48: 212106 FF                  uv 01 40  1  74      
;   451           @@:
;   452             cmp al,0x80
                    cmp al,#80            ;#00440F4B: 200370 80                  uv 00 01  1  75 01   
;   453             jne @f
                    jne #00440F56         ;#00440F4E: 165 06                     v  00 00  1  75      
;   454             mov rsi,[rsi+rdi*8]
                    mov rsi,[rsi+rdi*8]   ;#00440F50: 48:213064376               uv 40 C0  1  76      
;   455             jmp :pSubssWhile
                    jmp #00440F1F (:%pSubss)  ;#00440F54: 353 C9                     v  00 00  1  76      
;   456 
;   457           @@:
;   458             cmp al,0x82
                    cmp al,#82            ;#00440F56: 200370 82                  uv 00 01  1  77      
;   459             jne :e04atsaap8         -- era @ [esp+ecx*4+8]
                    jne #00440F1C         ;#00440F59: 165 C1                     v  00 00  1  77      
;   460             lea rsi,[rsi+rdi]       -- address of (first) char
                    lea rsi,[rsi+rdi]     ;#00440F5B: 48:215064076               uv 40 C0  1  78      
;   461             sub rcx,1
                    sub rcx,1             ;#00440F5F: 48:203351 01               vu 02 02  1  78      
;   462             jnz :e04atsaap12        -- strings must be last segment
                    jnz #00440F1D         ;#00440F63: 165 B8                     v  00 00  1  79      
;   463 
;   464       ::pSubssEndWhile
;   465         cmp rdi,rdx
                cmp rdi,rdx               ;#00440F65: 48:071327                  uv 00 84  1  80      
;   466         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here)
                jbe #00440F71             ;#00440F68: 166 07                     v  00 00  1  80      
;   467                             --               (we just did a dec rdi)
;   468                             --               (slice start can be 1..length+1)
;   469             mov cl,12               -- [era] @ [esp+12]
                    mov cl,12             ;#00440F6A: 261 0C                     uv 02 00  1  81      
;   470             call :%fixupSliceStart  -- idx in rdi, len in rdx
                    call :%fixupSliceStart  ;#00440F6C: 350 3F050000               v  00 00  1  81      
;   471       @@:
;   472 -->     mov [ap1],edi           -- save slice start
;   473 --not: edx,edi,ecx,ebx,esi,eax...
;   474 --      mov ??,edi
;   475 --      pop edi                 -- ref slice end
;   476         xchg [rsp],rdi          -- swap slice start/end
                xchg qword[rsp],rdi       ;#00440F71: 48:207074044               np 80 90  3  82      
;   477         mov r15,h4
                mov r15,h4                ;#00440F75: 49:277 0000000000000040    uv 8000 00  1  85      
;   478         cmp rdi,rdx
                cmp rdi,rdx               ;#00440F7F: 48:071327                  vu 00 84  1  85      
;   479         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here, and no dec rdi)
                jbe #00440F8B             ;#00440F82: 166 07                     v  00 00  1  86      
;   480                             --               (slice end can be 0..length)
;   481 --          mov cl,8            -- [era] @ [esp+8]
;   482             mov cl,24           -- [era] @ [rsp+24]  (inc ret to @@:)
                    mov cl,24             ;#00440F84: 261 18                     uv 02 00  1  87      
;   483             call :%fixupSliceEnd    -- idx in rdi, len in rdx
                    call #00441519 (:%fixupSliceEnd)  ;#00440F86: 350 8E050000               v  00 00  1  87      
;   484       @@:
;   485 
;   486         -- stack contents:
;   487         --  [rsp] slice start (0-based)
;   488         --  [rsp+8] addr res
;   489         --  [rsp+16] return address
;   490         mov rcx,rdi             -- slice end
                mov rcx,rdi               ;#00440F8B: 48:213317                  uv 02 80  1  88      
;   491         mov rdi,[rsp+8]         -- address of res (re-fetched later)
                mov rdi,[rsp+8]           ;#00440F8E: 48:213174044 08            vu 80 10  1  88      
;   492         sub rcx,[rsp]           -- slice start
                sub rcx,[rsp]             ;#00440F93: 48:053014044               uv 02 12  2  89      
;   493         jl :e09slinecx          -- slice length is negative
                jl #00440F1E              ;#00440F97: 174 85                     v  00 00  1  90      
;   494         mov rdx,rcx             -- new object len = slice len
                mov rdx,rcx               ;#00440F99: 48:213321                  uv 04 02  1  91      
;   495         mov rdi,[rdi]           -- ref of result (prev)
                mov rdi,[rdi]             ;#00440F9C: 48:213077                  vu 80 80  1  91      
;   496         cmp al,0x80
                cmp al,#80                ;#00440F9F: 200370 80                  uv 00 01  1  92      
;   497         jne :pSubssStr
                jne #00441154             ;#00440FA2: 017205 AC010000            v  00 00  1  92      
;   498         --
;   499         -- can we do things in-situ?
;   500         --
;   501         cmp rdi,r15
                cmp rdi,r15               ;#00440FA8: 49:073377                  uv 00 8080  1  93      
;   502         jg @f
                jg #00440FD5              ;#00440FAB: 177 28                     v  00 00  1  93      
;   503             -- if new length = length(p2) then incref p2 -> p1, exit/all done
;   504             cmp rdx,[rsi-24]
                    cmp rdx,[rsi-24]      ;#00440FAD: 48:073126 E8               uv 00 44  2  94      
;   505             jne :pSubssNewSeq
                    jne #0044111A         ;#00440FB1: 017205 63010000            v  00 00  1  95      
;   506             -- (this is the [int/unassigned]:=x[1..$] case)
;   507             add rsp,8                   -- discard slice start (must be 0 anyway)
                    add rsp,8             ;#00440FB7: 48:203304 08               uv 10 10  1  96      
;   508             pop rdi                     -- addr tgt
                    pop rdi               ;#00440FBB: 48:137                     vu 80 00  1  96      
;   509             mov rdx,[rsi-16]            -- refcount
                    mov rdx,[rsi-16]      ;#00440FBD: 48:213126 F0               uv 04 40  1  97      
;   510             lea rax,[rsi+1]             -- (recreate ref)
                    lea rax,[rsi+1]       ;#00440FC1: 48:215106 01               vu 01 40  1  97      
;   511             add rdx,1
                    add rdx,1             ;#00440FC5: 48:203302 01               uv 04 04  1  98      
;   512             ror rax,2                   -- == ref p2
                    ror rax,2             ;#00440FC9: 48:301310 02               np 01 01  1  99      
;   513             mov [rsi-16],rdx
                    mov [rsi-16],rdx      ;#00440FCD: 48:211126 F0               uv 00 44  1 100      
;   514             mov [rdi],rax               -- (no need to dealloc)
                    mov [rdi],rax         ;#00440FD1: 48:211007                  vu 00 81  1 100      
;   515             ret
                    ret                   ;#00440FD4: 303                        np 00 00  2 101      
;   516       @@:
;   517         shl rdi,2
                shl rdi,2                 ;#00440FD5: 48:301347 02               u  80 80  1 103      
;   518         cmp qword[rdi-16],1             -- refcount of 1
                cmp qword[rdi-16],1       ;#00440FD9: 48:203177 F0 01            u  00 80  2 106    *80*
;   519         je @f
                je #00440FF4              ;#00440FDE: 164 14                     v  00 00  1 107      
;   520             cmp rdi,rsi
                    cmp rdi,rsi           ;#00440FE0: 48:071367                  uv 00 C0  1 108      
;   521             jne :pSubssp2nep1
                    jne #00440FF9         ;#00440FE3: 165 14                     v  00 00  1 108      
;   522             cmp rdx,[rsi-24]
                    cmp rdx,[rsi-24]      ;#00440FE5: 48:073126 E8               uv 00 44  2 109      
;   523             jne :pSubssNewSeq
                    jne #0044111A         ;#00440FE9: 017205 2B010000            v  00 00  1 110      
;   524             -- (this must therefore be the x:=x[1..$] case, at least datawise, 
;   525             --  although the hll could be say ti:=table[i][1..$], repeated)
;   526             add rsp,16                  -- discard slice start and addr res
                    add rsp,16            ;#00440FEF: 48:203304 10               uv 10 10  1 111      
;   527             ret
                    ret                   ;#00440FF3: 303                        np 00 00  2 112      
;   528       @@:
;   529         cmp rdi,rsi
                cmp rdi,rsi               ;#00440FF4: 48:071367                  uv 00 C0  1 114      
;   530         je @f
                je #00441038              ;#00440FF7: 164 3F                     v  00 00  1 114      
;   531           ::pSubssp2nep1    -- rdi!=rsi             (third test)
;   532             cmp rdx,[rsi-24]                -- if lengths match
                    cmp rdx,[rsi-24]      ;#00440FF9: 48:073126 E8               uv 00 44  2 115      
;   533             jne :pSubssNewSeq
                    jne #0044111A         ;#00440FFD: 017205 17010000            v  00 00  1 116      
;   534             add rsp,8                       -- discard slice start (must be 0 anyway)
                    add rsp,8             ;#00441003: 48:203304 08               uv 10 10  1 117      
;   535             pop rdi                         -- addr tgt
                    pop rdi               ;#00441007: 48:137                     vu 80 00  1 117      
;   536             mov rcx,[rsi-16]                -- p2 refcount (or ref[idx1][idx2]..[idxn-1])
                    mov rcx,[rsi-16]      ;#00441009: 48:213116 F0               uv 02 40  1 118      
;   537             lea rax,[rsi+1]                 -- calc ref (for "") in eax
                    lea rax,[rsi+1]       ;#0044100D: 48:215106 01               vu 01 40  1 118      
;   538             add rcx,1
                    add rcx,1             ;#00441011: 48:203301 01               uv 02 02  1 119      
;   539             mov rdx,[rdi]                   -- get prev ref
                    mov rdx,[rdi]         ;#00441015: 48:213027                  vu 04 80  1 119      
;   540             mov [rsi-16],rcx                -- incref
                    mov [rsi-16],rcx      ;#00441018: 48:211116 F0               uv 00 42  1 120      
;   541             ror rax,2                       -- == ref p2
                    ror rax,2             ;#0044101C: 48:301310 02               np 01 01  1 121      
;   542             mov rcx,[rbx+rdx*4-16]          -- p1 refcount
                    mov rcx,[rbx+rdx*4-16]  ;#00441020: 48:213114223 F0            uv 02 0C  1 122      
;   543             mov [rdi],rax                   -- save new ref
                    mov [rdi],rax         ;#00441025: 48:211007                  vu 00 81  1 122      
;   544             sub rcx,1
                    sub rcx,1             ;#00441028: 48:203351 01               uv 02 02  1 123      
;   545             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0044102C: 017204 A8120000            v  00 00  1 123      
;   546             mov [rbx+rdx*4-16],rcx          -- decref
                    mov [rbx+rdx*4-16],rcx  ;#00441032: 48:211114223 F0            uv 00 0E  1 124      
;   547             ret
                    ret                   ;#00441037: 303                        np 00 00  2 125      
;   548 
;   549       @@:
;   550         -- (this is the x:=x[i..j] case, with a refcount of 1)
;   551         push rcx                        --[?] save new length
                push rcx                  ;#00441038: 48:121                     uv 00 02  1 127      
;   552         xor rbx,rbx
                xor rbx,rbx               ;#0044103A: 48:061333                  vu 08 08  1 127      
;   553         mov edx,[rsp+8]                 -- slice start (0-based)
                mov edx,[rsp+8]           ;#0044103D: 213124044 08               uv 04 10  1 128      
;   554         mov rcx,[rdi-24]                -- original length
                mov rcx,[rdi-24]          ;#00441041: 48:213117 E8               vu 02 80  1 128      
;   555         add rdx,1
                add rdx,1                 ;#00441045: 48:203302 01               uv 04 04  1 129      
;   556       ::pSubssDeallocPrevLoop
;   557             sub rdx,1
                    sub rdx,1             ;#00441049: 48:203352 01               uv 04 04  1 130 04   
;   558             jz :pSubssDeallocPrevDone
                    jz #00441086          ;#0044104D: 164 37                     v  00 00  1 130      
;   559             mov rax,[rsi]
                    mov rax,[rsi]         ;#0044104F: 48:213006                  uv 01 40  1 131      
;   560             sub rcx,1
                    sub rcx,1             ;#00441052: 48:203351 01               vu 02 02  1 131      
;   561             add rsi,8
                    add rsi,8             ;#00441056: 48:203306 08               uv 40 40  1 132      
;   562             cmp rax,r15
                    cmp rax,r15           ;#0044105A: 49:073307                  vu 00 8001  1 132      
;   563             jle :pSubssDeallocPrevLoop
                    jle #00441049         ;#0044105D: 176 EA                     v  00 00  1 133      
;   564             sub qword[rbx+rax*4-16],1
                    sub qword[rbx+rax*4-16],1  ;#0044105F: 48:203154203 F0 01         u  00 09  3 134      
;   565             jnz :pSubssDeallocPrevLoop
                    jnz #00441049         ;#00441065: 165 E2                     v  00 00  1 136      
;   566 --          pushad
;   567             push rdi
                    push rdi              ;#00441067: 48:127                     uv 00 80  1 137      
;   568             push rcx
                    push rcx              ;#00441069: 48:121                     vu 00 02  1 137      
;   569             push rsi
                    push rsi              ;#0044106B: 48:126                     uv 00 40  1 138      
;   570             push rdx
                    push rdx              ;#0044106D: 48:122                     vu 00 04  1 138      
;   571             mov rdx,rax
                    mov rdx,rax           ;#0044106F: 48:213320                  uv 04 01  1 139      
;   572 --  if debugmem2
;   573 --  mov eax,[esp+40]    -- (DEV: untested!)
;   574 --  mov [dmFera],eax
;   575 --  end if
;   576             push qword[rsp+56]
                    push qword[rsp+56]    ;#00441072: 48:377164044 38            np 00 10  2 140      
;   577             call :%pDealloc0
                    call #004422DE (:%pDealloc0)  ;#00441077: 350 62120000               v  00 00  1 142      
;   578 --          popad
;   579             pop rdx
                    pop rdx               ;#0044107C: 48:132                     uv 04 00  1 143      
;   580             pop rsi
                    pop rsi               ;#0044107E: 48:136                     vu 40 00  1 143      
;   581             pop rcx
                    pop rcx               ;#00441080: 48:131                     uv 02 00  1 144      
;   582             pop rdi
                    pop rdi               ;#00441082: 48:137                     vu 80 00  1 144      
;   583             jmp :pSubssDeallocPrevLoop
                    jmp #00441049         ;#00441084: 353 C3                     v  00 00  1 145      
;   584 
;   585       ::pSubssDeallocPrevDone
;   586         --
;   587         -- re-site the header.
;   588         --
;   589         -- register contents:
;   590         --  rax - unused
;   591         --  rcx - length less slice start (needed below)
;   592         --  rdx - 0
;   593         --  rsi - location of new s[1]
;   594         --  rdi - raw addr of prev header
;   595         --  [rsp] = new length
;   596         --  [rsp+8] = slice start (0-based), aka discarded items
;   597         --  [rsp+16] = addr res
;   598         --  [rsp+24] = return address
;   599         --
;   600         cmp rsi,rdi
                cmp rsi,rdi               ;#00441086: 48:071376                  uv 00 C0  1 146      
;   601         jne :pSubssReSiteHeader
                jne #00441097             ;#00441089: 165 0C                     v  00 00  1 146      
;   602             -- must be x=x[1..??] case, no need to resite header:
;   603             pop rdx                     -- new length
                    pop rdx               ;#0044108B: 48:132                     uv 04 00  1 147      
;   604             add rsp,16                  -- discard slice start and addr res
                    add rsp,16            ;#0044108D: 48:203304 10               vu 10 10  1 147      
;   605             mov [rsi-24],rdx            -- set new length
                    mov [rsi-24],rdx      ;#00441091: 48:211126 E8               uv 00 44  1 148      
;   606             jmp :pSubssDeallocRest
                    jmp #004410DD         ;#00441095: 353 46                     v  00 00  1 148      
;   607 
;   608       ::pSubssReSiteHeader
;   609         mov rax,[rdi-32]                -- prev maxlen
                mov rax,[rdi-32]          ;#00441097: 48:213107 E0               uv 01 80  1 149      
;   610         mov rdx,[rsp+8]                 -- discarded items, aka slice start
                mov rdx,[rsp+8]           ;#0044109B: 48:213124044 08            vu 04 10  1 149      
;   611         mov r9,[rdi-8]                  -- previous type
                mov r9,[rdi-8]            ;#004410A0: 4C:213117 F8               uv 200 80  1 150      
;   612         shl rdx,3                       -- discarded items in bytes
                shl rdx,3                 ;#004410A4: 48:301342 03               u  04 04  1 151      
;   613         mov [rsi-32],rax                -- maxlen (unaltered)
                mov [rsi-32],rax          ;#004410A8: 48:211106 E0               vu 00 41  1 151      
;   614         mov rax,[rdi-40]                -- previous slack
                mov rax,[rdi-40]          ;#004410AC: 48:213107 D8               uv 01 80  1 152      
;   615 --      add rdx,[rdi-40]                -- previous slack
;   616         mov qword[rsi-8],r9             -- type (unaltered)
                mov [rsi-8],r9            ;#004410B0: 4C:211116 F8               vu 00 240  1 152      
;   617         add rax,rdx                     -- new slack
                add rax,rdx               ;#004410B4: 48:001320                  uv 01 05  1 153      
;   618         mov [rsi-16],qword 1            -- refcount (unaltered)
                mov qword[rsi-16],1       ;#004410B7: 48:307106 F0 01000000      vu 00 40  1 153      
;   619         mov r9,rsi                      -- calculate new ref in r9
                mov r9,rsi                ;#004410BF: 4C:213316                  uv 200 40  1 154      
;   620 --      pop qword[rsi-24]               -- new length
;   621         pop rdx                         -- new length
                pop rdx                   ;#004410C2: 48:132                     vu 04 00  1 154      
;   622         add rsp,8                       -- discard slice start
                add rsp,8                 ;#004410C4: 48:203304 08               uv 10 10  1 155      
;   623         add r9,1
                add r9,1                  ;#004410C8: 49:203301 01               vu 200 200  1 155      
;   624         pop rdi                         -- addr res
                pop rdi                   ;#004410CC: 48:137                     uv 80 00  1 156      
;   625         mov [rsi-40],rax                -- set new slack
                mov [rsi-40],rax          ;#004410CE: 48:211106 D8               vu 00 41  1 156      
;   626         ror r9,2
                ror r9,2                  ;#004410D2: 49:301311 02               np 200 200  1 157      
;   627 --      mov [rsi-40],rdx                -- set new slack
;   628         mov [rsi-24],rdx                -- set new length
                mov [rsi-24],rdx          ;#004410D6: 48:211126 E8               uv 00 44  1 158      
;   629         mov [edi],r9                    -- new ref of shifted header -> res
                mov [rdi],r9              ;#004410DA: 4C:211017                  vu 00 280  1 158      
;   630       ::pSubssDeallocRest
;   631         lea rsi,[rsi+rdx*8]             -- esi := esi[newlength+1]
                lea rsi,[rsi+rdx*8]       ;#004410DD: 48:215064326               uv 40 44  1 159      
;   632 
;   633       ::pSubssDeallocRestLoop
;   634         cmp rcx,rdx
                cmp rcx,rdx               ;#004410E1: 48:071321                  vu 00 06  1 159      
;   635         je :pSubssDeallocRestDone
                je #00441119              ;#004410E4: 164 33                     v  00 00  1 160      
;   636         mov rax,[rsi]
                mov rax,[rsi]             ;#004410E6: 48:213006                  uv 01 40  1 161      
;   637         sub rcx,1
                sub rcx,1                 ;#004410E9: 48:203351 01               vu 02 02  1 161      
;   638         add rsi,4
                add rsi,4                 ;#004410ED: 48:203306 04               uv 40 40  1 162      
;   639         cmp rax,r15
                cmp rax,r15               ;#004410F1: 49:073307                  vu 00 8001  1 162      
;   640         jle :pSubssDeallocRestLoop
                jle #004410E1             ;#004410F4: 176 EB                     v  00 00  1 163      
;   641         sub qword[rbx+rax*4-16],1
                sub qword[rbx+rax*4-16],1  ;#004410F6: 48:203154203 F0 01         u  00 09  3 164      
;   642         jnz :pSubssDeallocRestLoop
                jnz #004410E1             ;#004410FC: 165 E3                     v  00 00  1 166      
;   643 --      pushad
;   644         push rcx
                push rcx                  ;#004410FE: 48:121                     uv 00 02  1 167      
;   645         push rdx
                push rdx                  ;#00441100: 48:122                     vu 00 04  1 167      
;   646         push rsi
                push rsi                  ;#00441102: 48:126                     uv 00 40  1 168      
;   647         mov rdx,rax
                mov rdx,rax               ;#00441104: 48:213320                  vu 04 01  1 168      
;   648         push qword[rsp+24]
                push qword[rsp+24]        ;#00441107: 48:377164044 18            np 00 10  2 169      
;   649         call :%pDealloc0
                call #004422DE (:%pDealloc0)  ;#0044110C: 350 CD110000               v  00 00  1 171      
;   650 --      popad
;   651         pop rsi
                pop rsi                   ;#00441111: 48:136                     uv 40 00  1 172      
;   652         pop rdx
                pop rdx                   ;#00441113: 48:132                     vu 04 00  1 172      
;   653         pop rcx     
                pop rcx                   ;#00441115: 48:131                     uv 02 00  1 173      
;   654         jmp :pSubssDeallocRestLoop
                jmp #004410E1             ;#00441117: 353 C8                     v  00 00  1 173      
;   655         
;   656 --      nop?
;   657       ::pSubssDeallocRestDone
;   658         ret
                ret                       ;#00441119: 303                        np 00 00  2 174      
;   659 
;   660 
;   661       ::pSubssNewSeq
;   662         -- register contents:
;   663         --  al 0x80
;   664         --  rcx = rdx = new length
;   665         --  rsi = raw addr of p2
;   666         --  rdi = unknown (ref or raw tgt)
;   667         --  [rsp] = slice start (0-based)
;   668         --  [rsp+8] = addr res
;   669 --      pop rdx                     -- slice start (0-based)
;   670         pop rdi                     -- slice start (0-based)
                pop rdi                   ;#0044111A: 48:137                     uv 80 00  1 176      
;   671         mov rdx,[rsp+16]            -- era
                mov rdx,[rsp+16]          ;#0044111C: 48:213124044 10            vu 04 10  1 176      
;   672         call :%pAllocSeq            -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00441121: 350 22100000               v  00 00  1 177      
;   673 --      lea rsi,[rsi+rdx*4]
;   674 --      lea rsi,[rsi+rdx*8]
;   675         lea rsi,[rsi+rdi*8]
                lea rsi,[rsi+rdi*8]       ;#00441126: 48:215064376               uv 40 C0  1 178      
;   676         push rax                    --[?] save ref
                push rax                  ;#0044112A: 48:120                     vu 00 01  1 178      
;   677         test rcx,rcx
                test rcx,rcx              ;#0044112C: 48:205311                  uv 00 02  1 179      
;   678         je :pSubssStore
                je #004411F6              ;#0044112F: 017204 C1000000            v  00 00  1 179      
;   679         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#00441135: 48:215074203               uv 80 09  1 180      
;   680       @@:
;   681             lodsq                   -- mov rax,[rsi], rsi+=4
                    lodsq                 ;#00441139: 48:255                     np 41 40  2 181      
;   682             stosq                   -- mov [rdi],rax, rdi+=4
                    stosq                 ;#0044113B: 48:253                     np 80 81  3 183      
;   683             cmp rax,r15
                    cmp rax,r15           ;#0044113D: 49:073307                  uv 00 8001  1 186      
;   684             jl :Subss2_no_incref
                    jl #00441148          ;#00441140: 174 06                     v  00 00  1 186      
;   685                 add qword[rbx+rax*4-16],1
                        add qword[rbx+rax*4-16],1  ;#00441142: 48:203104203 F0 01         u  00 09  3 187      
;   686           ::Subss2_no_incref
;   687             sub rcx,1
                    sub rcx,1             ;#00441148: 48:203351 01               vu 02 02  1 189      
;   688             jnz @b
                    jnz #00441139         ;#0044114C: 165 EB                     v  00 00  1 190      
;   689         nop
                nop                       ;#0044114E: 220                        uv 00 00  1 191      
;   690         jmp :pSubssStore
                jmp #004411F6             ;#0044114F: 351 A2000000               v  00 00  1 191      
;   691 
;   692       ::pSubssStr
;   693         -- register contents:
;   694         --  al 0x82
;   695         --  rcx = rdx = new length
;   696         --  rsi = raw addr of p2
;   697         --  rdi = ref p1
;   698         --  [rsp] = slice start (post-fixup, zero-based)
;   699         --  [rsp+8] = addr res
;   700         --  [rsp+16] = return address
;   701         -- insitu if: slice starts at 1, and refcount p2 is 1.
;   702         -- jumps to @f(AllocStr) must preserve/reset rdx(=rcx),rcx,rsi.
;   703         cmp al,0x82                     -- sanity check
                cmp al,#82                ;#00441154: 200370 82                  uv 00 01  1 192      
;   704         jne :e04atsaa4
                jne #00440F1A             ;#00441157: 017205 BDFDFFFF            v  00 00  1 192      
;   705         mov rax,[rsi-16]        -- refcount
                mov rax,[rsi-16]          ;#0044115D: 48:213106 F0               uv 01 40  1 193      
;   706         mov rdx,[rsp]           -- slice start (post-fixup/0-based)
                mov rdx,[rsp]             ;#00441161: 48:213024044               vu 04 10  1 193      
;   707         cmp rax,1
                cmp rax,1                 ;#00441165: 48:203370 01               uv 00 01  1 194      
;   708         jne :pSubssNewStr       -- refcount!=1 (==>AllocStr)
                jne #004411E0             ;#00441169: 165 75                     v  00 00  1 194      
;   709         test rdx,rdx
                test rdx,rdx              ;#0044116B: 48:205322                  uv 00 04  1 195      
;   710         jnz :pSubssNewStr       -- slice start is not 1 (==>AllocStr)
                jnz #004411E0             ;#0044116E: 165 70                     v  00 00  1 195      
;   711         cmp rdi,r15
                cmp rdi,r15               ;#00441170: 49:073377                  uv 00 8080  1 196      
;   712         jg @f
                jg #00441195              ;#00441173: 177 20                     v  00 00  1 196      
;   713             -- p1 unassigned/integer.
;   714             -- can still just copy ref iff edx==length(p2) (eg x=s[1..-1])
;   715             cmp rcx,[rsi-24]
                    cmp rcx,[rsi-24]      ;#00441175: 48:073116 E8               uv 00 42  2 197      
;   716             jne :pSubssNewStr
                    jne #004411E0         ;#00441179: 165 65                     v  00 00  1 198      
;   717             lea rax,[rsi+1]
                    lea rax,[rsi+1]       ;#0044117B: 48:215106 01               uv 01 40  1 199      
;   718             add rsp,8           -- discard slice start (which is 1)
                    add rsp,8             ;#0044117F: 48:203304 08               vu 10 10  1 199      
;   719             pop rdi             -- addr tgt
                    pop rdi               ;#00441183: 48:137                     uv 80 00  1 200      
;   720             ror rax,2           -- == ref p2 (or ref[idx1][idx2]...[idxn-1])
                    ror rax,2             ;#00441185: 48:301310 02               np 01 01  1 201      
;   721             mov qword[rsi-16],2 -- refcount is now 2
                    mov qword[rsi-16],2   ;#00441189: 48:307106 F0 02000000      uv 00 40  1 202      
;   722             mov [rdi],rax
                    mov [rdi],rax         ;#00441191: 48:211007                  vu 00 81  1 202      
;   723             ret
                    ret                   ;#00441194: 303                        np 00 00  2 203      
;   724       @@:
;   725         lea rax,[rbx+rdi*4]
                lea rax,[rbx+rdi*4]       ;#00441195: 48:215004273               uv 01 88  1 205      
;   726         cmp rax,rsi
                cmp rax,rsi               ;#00441199: 48:071360                  uv 00 41  1 206 01   
;   727         jne @f
                jne #004411AB             ;#0044119C: 165 0D                     v  00 00  1 206      
;   728             -- s=s[1..?], no incref/decref needed.
;   729             mov [rsi-24],rcx    -- set new length
                    mov [rsi-24],rcx      ;#0044119E: 48:211116 E8               uv 00 42  1 207      
;   730             add rsp,16          -- discard slice start and addr tgt
                    add rsp,16            ;#004411A2: 48:203304 10               vu 10 10  1 207      
;   731             mov byte[rsi+rcx],0 -- plant new terminator
                    mov [rsi+rcx], byte 0  ;#004411A6: 306004016 00               uv 00 42  1 208      
;   732             ret
                    ret                   ;#004411AA: 303                        np 00 00  2 209      
;   733       @@:
;   734             -- p1!=p2.
;   735             -- again, we can still just copy ref p2 & deref p1, iff ecx==length(p2).
;   736             --  ie/eg a=b[1..-1] can just incref b, but a=b[1..-2] needs to
;   737             --       end up with two different length strings in a & b.
;   738             cmp rcx,[rsi-24]
                    cmp rcx,[rsi-24]      ;#004411AB: 48:073116 E8               uv 00 42  2 211      
;   739             jne :pSubssNewStr
                    jne #004411E0         ;#004411AF: 165 2F                     v  00 00  1 212      
;   740             mov rdx,rdi         -- for dealloc
                    mov rdx,rdi           ;#004411B1: 48:213327                  uv 04 80  1 213      
;   741             mov qword[rsi-16],2 -- set new refcount
                    mov qword[rsi-16],2   ;#004411B4: 48:307106 F0 02000000      vu 00 40  1 213      
;   742             add rsp,8           -- discard slice start
                    add rsp,8             ;#004411BC: 48:203304 08               uv 10 10  1 214      
;   743             pop rdi             -- addr tgt
                    pop rdi               ;#004411C0: 48:137                     vu 80 00  1 214      
;   744             add rsi,1
                    add rsi,1             ;#004411C2: 48:203306 01               uv 40 40  1 215      
;   745             mov rcx,[rax-16]
                    mov rcx,[rax-16]      ;#004411C6: 48:213110 F0               vu 02 01  1 215      
;   746             ror rsi,2           -- recreated ref p2 (or ref[idx][idx2]...[idxn-1])
                    ror rsi,2             ;#004411CA: 48:301316 02               np 40 40  1 216      
;   747             sub rcx,1
                    sub rcx,1             ;#004411CE: 48:203351 01               uv 02 02  1 217      
;   748             mov [rdi],rsi
                    mov [rdi],rsi         ;#004411D2: 48:211067                  vu 00 C0  1 217      
;   749             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#004411D5: 017204 FF100000            v  00 00  1 218      
;   750             mov [rax-16],rcx
                    mov [rax-16],rcx      ;#004411DB: 48:211110 F0               uv 00 03  1 219      
;   751             ret
                    ret                   ;#004411DF: 303                        np 00 00  2 220      
;   752 
;   753       ::pSubssNewStr
;   754         pop rdx                 -- slice start (post-fixup/0-based)
                pop rdx                   ;#004411E0: 48:132                     uv 04 00  1 222      
;   755         call :%pAllocStr        -- damages rax only
                call #004420E3 (:%pAllocStr)  ;#004411E2: 350 FC0E0000               v  00 00  1 222      
;   756         add rsi,rdx
                add rsi,rdx               ;#004411E7: 48:001326                  uv 40 44  1 223      
;   757         push rax                --[2] save ref
                push rax                  ;#004411EA: 48:120                     vu 00 01  1 223      
;   758         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#004411EC: 48:215074203               uv 80 09  1 224      
;   759         rep movsb
                rep movsb                 ;#004411F0: 363:244                    np C2 C2  4 227    *C0*
;   760         xor rax,rax
                xor rax,rax               ;#004411F2: 48:061300                  uv 01 01  1 231      
;   761         stosb                   -- trailing null
                stosb                     ;#004411F5: 252                        np 80 81  3 233    *80*
;   762 
;   763       ::pSubssStore
;   764         pop rax                 --[2] newly created ref
                pop rax                   ;#004411F6: 48:130                     uv 01 00  1 236      
;   765         pop rdi                 -- addr result
                pop rdi                   ;#004411F8: 48:137                     vu 80 00  1 236      
;   766         mov rdx,[rdi]
                mov rdx,[rdi]             ;#004411FA: 48:213027                  uv 04 80  1 239    *80*
;   767         mov [rdi],rax
                mov [rdi],rax             ;#004411FD: 48:211007                  vu 00 81  1 239      
;   768         cmp rdx,r15
                cmp rdx,r15               ;#00441200: 49:073327                  uv 00 8004  1 240      
;   769         jle @f
                jle #00441211             ;#00441203: 176 0C                     v  00 00  1 240      
;   770             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#00441205: 48:203154223 F0 01         u  00 0C  3 241      
;   771             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0044120B: 017204 C9100000            v  00 00  1 243      
;   772       @@:
;   773         ret
                ret                       ;#00441211: 303                        np 00 00  2 244      
;   774     []
;   775 
;   776 --/*
;   777 procedure :%pSubsss(:%)
;   778 end procedure -- (for Edita/CtrlQ)
;   779 --*/
;   780     :%pSubsss       -- res := string[slicestart..sliceend]
;   781 -------------
;   782     [32]
;   783         --calling convention:
;   784         --  lea eax,[res]
;   785         --  mov edi,[p2]        -- slice start (opUnassigned)
;   786         --  mov ecx,[p3]        -- slice end (opUnassigned)
;   787         --  mov esi,[p1]        -- ref (opUnassigned, must be a string)
;   788 --X     --  mov edx,p1          -- var no of ref            (DEV deliberately commented out in pilx86.e, as we opUnassign)
;   789         --  call pSubsss        -- [eax]=esi[edi..ecx]
;   790 --  ::pSubssse92a       -- exception here mapped to e94vhnbaavedxesifeh
;   791         mov edx,[ebx+esi*4-12]  -- length   (exception here mapped to e94vhnbaav(edx))
;   792         sub edi,1
;   793         shl esi,2
;   794         cmp edi,edx
;   795         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here)
;   796                             --               (we just did a dec edi)
;   797                             --               (slice start can be 1..length+1)
;   798 --          mov cl,0        -- [era] @ [esp]
;   799             push ecx
;   800             mov cl,8        -- [era] @ [esp+8] (inc ret to @@:)
;   801             call :%fixupSliceStart  -- idx in edi, len in edx
;   802             pop ecx
;   803       @@:
;   804 --      push edi            -- save slice start
;   805 --!     mov edx,edi             -- save slice start
;   806         cmp ecx,edx
;   807         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here, and no dec ecx)
;   808                             --               (slice end can be 0..length)
;   809             push edi            -- save slice start
;   810             mov edi,ecx
;   811             mov cl,8            -- [era] @ [esp+8] (inc ret to @@:)
;   812             call :%fixupSliceEnd    -- idx in edi, len in edx
;   813             mov ecx,edi
;   814 --          mov edi,[esp]
;   815             pop edi
;   816       @@:
;   817         sub ecx,edi             -- slice length
;   818 --      jl :e09slinecx2         -- slice length is negative
;   819         jge @f
;   820             add ecx,edi
;   821             add edi,1
;   822             pop edx
;   823             mov al,9    -- e09slin(edi,ecx)
;   824             sub edx,1
;   825             jmp :!iDiag
;   826             int3
;   827       @@:
;   828         push eax                -- save addr res
;   829 --?     mov edx,ecx             -- new object len = slice len
;   830         mov edx,edi             -- save slice start
;   831         mov edi,[eax]           -- ref of result
;   832         -- register contents:
;   833         --  ecx = new length
;   834         --  edx = slice start (0-based)
;   835         --  esi = raw addr of p2
;   836         --  edi = ref p1 (res)
;   837         --  [esp] = addr res
;   838 --X     --  [esp+4] = slice start (post-fixup, zero-based)
;   839         -- insitu if: slice starts at 1, and refcount p2 is 1.
;   840         -- jumps to @f(AllocStr) must preserve/reset ecx,esi.
;   841 --      mov eax,[esi-8]         -- refcount
;   842 --      mov edx,[esp+4]         -- slice start (post-fixup/0-based)
;   843 --      cmp eax,1
;   844         cmp dword[esi-8],1
;   845         jne :pSubsssNewStr      -- refcount!=1 (==>AllocStr)
;   846 --      test edx,edx
;   847         cmp edx,0
;   848         jnz :pSubsssNewStr      -- slice start is not 1 (==>AllocStr)
;   849         cmp edi,h4
;   850         jg @f
;   851             -- p1 unassigned/integer.
;   852             -- can still just copy ref iff ecx==length(p2) (eg x=s[1..-1])
;   853             cmp ecx,[esi-12]
;   854             jne :pSubsssNewStr
;   855             lea eax,[esi+1]
;   856             pop edi             -- addr tgt
;   857             ror eax,2           -- == ref p2 (or ref[idx1][idx2]...[idxn-1])
;   858             mov dword[esi-8],2  -- refcount is now 2
;   859             mov [edi],eax
;   860             ret
;   861       @@:
;   862         lea eax,[ebx+edi*4]     -- raw tgt
;   863         cmp eax,esi
;   864         jne @f
;   865             -- s=s[1..?], no incref/decref needed.
;   866             mov [esi-12],ecx    -- set new length
;   867             add esp,4           -- discard addr tgt
;   868             mov byte[esi+ecx],0 -- plant new terminator
;   869             ret
;   870       @@:
;   871         -- p1!=p2.
;   872         -- again, we can still just copy ref p2 & deref p1, iff ecx==length(p2).
;   873         --  ie/eg a=b[1..-1] can just incref b, but a=b[1..-2] needs to
;   874         --       end up with two different length strings in a & b.
;   875         cmp ecx,[esi-12]
;   876         jne :pSubsssNewStr
;   877         mov edx,edi         -- for dealloc
;   878         mov dword[esi-8],2  -- set new refcount (we know it was 1)
;   879         pop edi             -- addr tgt
;   880         add esi,1
;   881         mov ecx,[eax-8]     -- p1 refcount
;   882         ror esi,2           -- recreated ref p2
;   883         sub ecx,1
;   884         mov [edi],esi
;   885         jz :%pDealloc
;   886         mov [eax-8],ecx
;   887         ret
;   888 
;   889       ::pSubsssNewStr
;   890     --  mov edx,ecx
;   891     --DEV: [1..-1] could just incref...
;   892     --DEV 21/1/09 that code above belongs here...   [ 28/1/09 fixed/rewritten above ]
;   893 --      pop edx                 -- slice start (post-fixup/0-based)
;   894         call :%pAllocStr        -- damages eax only
;   895     --  mov edx,[esp+4]         -- slice start (post-fixup/0-based)
;   896     --  xor ebx,ebx
;   897     --  lea esi,[esi+edx]
;   898         add esi,edx             -- raw(p2) + slice start (0-based)
;   899         push eax                --[2] save ref
;   900         lea edi,[ebx+eax*4]
;   901     --DEV do we need this? [NO, I just tested]
;   902     --  test ecx,ecx
;   903     --  je @f
;   904         rep movsb
;   905     --  @@:
;   906         xor eax,eax
;   907         stosb                   -- trailing null
;   908 
;   909     --  ::pSubsssStore
;   910         pop eax                 --[2] newly created ref
;   911         pop edi                 -- addr result
;   912         mov edx,[edi]
;   913         mov [edi],eax
;   914         cmp edx,h4
;   915         jle @f
;   916             sub dword[ebx+edx*4-8],1
;   917             jz :%pDealloc
;   918       @@:
;   919         ret
;   920     [64]
;   921         --calling convention:
;   922         --  lea rax,[res]
;   923         --  mov rdi,[p2]        -- slice start (opUnassigned)
;   924         --  mov rcx,[p3]        -- slice end (opUnassigned)
;   925         --  mov rsi,[p1]        -- ref (opUnassigned)
;   926         --  mov rdx,p1
;   927         --  call :%pSubsss      -- [rax]=rsi[rdi..rcx] (where esi is a string)
;   928         mov rdx,[rbx+rsi*4-24]  -- length (exceptiuon here mapped to e94vhnbaav(rdx))
                mov rdx,[rbx+rsi*4-24]    ;#00441212: 48:213124263 E8            uv 04 48  1 246      
;   929         sub rdi,1
                sub rdi,1                 ;#00441217: 48:203357 01               vu 80 80  1 246      
;   930         shl rsi,2
                shl rsi,2                 ;#0044121B: 48:301346 02               u  40 40  1 247      
;   931         mov r15,h4
                mov r15,h4                ;#0044121F: 49:277 0000000000000040    vu 8000 00  1 247      
;   932         cmp rdi,rdx
                cmp rdi,rdx               ;#00441229: 48:071327                  uv 00 84  1 248      
;   933         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here)
                jbe #00441239             ;#0044122C: 166 0B                     v  00 00  1 248      
;   934                             --               (we just did a dec rdi)
;   935                             --               (slice start can be 1..length+1)
;   936             push rcx
                    push rcx              ;#0044122E: 48:121                     uv 00 02  1 249      
;   937 --          mov cl,0        -- [era] @ [esp]
;   938             mov cl,16       -- [era] @ [esp+16] (inc ret to @@:)
                    mov cl,16             ;#00441230: 261 10                     vu 02 00  1 249      
;   939             call :%fixupSliceStart  -- idx in rdi, len in rdx
                    call :%fixupSliceStart  ;#00441232: 350 79020000               v  00 00  1 250      
;   940             pop rcx
                    pop rcx               ;#00441237: 48:131                     uv 02 00  1 251      
;   941       @@:
;   942         cmp rcx,rdx
                cmp rcx,rdx               ;#00441239: 48:071321                  uv 00 06  1 252 02   
;   943         jbe @f              -- unsigned jump, lets 0..len through (NB jbe here, and no dec rcx)
                jbe #0044124F             ;#0044123C: 166 11                     v  00 00  1 252      
;   944                             --               (slice end can be 0..length)
;   945             push rdi            -- save slice start
                    push rdi              ;#0044123E: 48:127                     uv 00 80  1 253      
;   946             mov rdi,rcx
                    mov rdi,rcx           ;#00441240: 48:213371                  vu 80 02  1 253      
;   947 --          mov cl,8            -- [era] @ [rsp+8]
;   948             mov cl,16           -- [era] @ [rsp+16] (inc ret to @@:)
                    mov cl,16             ;#00441243: 261 10                     uv 02 00  1 254      
;   949             call :%fixupSliceEnd    -- idx in rdi, len in rdx
                    call #00441519 (:%fixupSliceEnd)  ;#00441245: 350 CF020000               v  00 00  1 254      
;   950             mov rcx,rdi
                    mov rcx,rdi           ;#0044124A: 48:213317                  uv 02 80  1 255      
;   951             pop rdi
                    pop rdi               ;#0044124D: 48:137                     vu 80 00  1 255      
;   952       @@:
;   953         sub rcx,rdi             -- slice length
                sub rcx,rdi               ;#0044124F: 48:051371                  uv 02 82  1 256      
;   954 --      jl :e09slinecx2         -- slice length is negative
;   955         jge @f
                jge #00441269             ;#00441252: 175 15                     v  00 00  1 256      
;   956             add rcx,rdi
                    add rcx,rdi           ;#00441254: 48:001371                  uv 02 82  1 257      
;   957             add rdi,1
                    add rdi,1             ;#00441257: 48:203307 01               vu 80 80  1 257      
;   958             pop rdx
                    pop rdx               ;#0044125B: 48:132                     uv 04 00  1 258      
;   959             mov al,9    -- e09slin(rdi,rcx)
                    mov al,9              ;#0044125D: 260 09                     vu 01 00  1 258      
;   960             sub rdx,1
                    sub rdx,1             ;#0044125F: 48:203352 01               uv 04 04  1 259      
;   961             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00441263: 351 FE1B0000               v  00 00  1 259      
;   962             int3
                    int3                  ;#00441268: 314                        np 00 00 13 260      
;   963       @@:
;   964         push rax                -- save addr res
                push rax                  ;#00441269: 48:120                     uv 00 01  1 273      
;   965         mov rdx,rdi             -- save slice start
                mov rdx,rdi               ;#0044126B: 48:213327                  vu 04 80  1 273      
;   966         mov rdi,[rax]           -- ref of result
                mov rdi,[rax]             ;#0044126E: 48:213070                  uv 80 01  1 274      
;   967         -- register contents:
;   968         --  rcx = new length
;   969         --  rdx = slice start (0-based)
;   970         --  rsi = raw addr of p2 (a string)
;   971         --  rdi = ref p1 (res)
;   972         --  [rsp] = addr res
;   973         -- insitu if: slice starts at 1, and refcount p2 is 1.
;   974         -- jumps to @f(AllocStr) must preserve/reset rcx,rsi.
;   975         cmp dword[rsi-16],1
                cmp dword[rsi-16],1       ;#00441271: 203176 F0 01               u  00 40  2 275      
;   976         jne :pSubsssNewStr      -- refcount!=1 (==>AllocStr)
                jne #004412E4             ;#00441275: 165 6D                     v  00 00  1 276      
;   977         cmp rdx,0
                cmp rdx,0                 ;#00441277: 48:203372 00               uv 00 04  1 277      
;   978         jnz :pSubsssNewStr      -- slice start is not 1 (==>AllocStr)
                jnz #004412E4             ;#0044127B: 165 67                     v  00 00  1 277      
;   979         cmp rdi,r15
                cmp rdi,r15               ;#0044127D: 49:073377                  uv 00 8080  1 278      
;   980         jg @f
                jg #0044129D              ;#00441280: 177 1B                     v  00 00  1 278      
;   981             -- p1 unassigned/integer.
;   982             -- can still just copy ref iff ecx==length(p2) (eg x=s[1..-1])
;   983             cmp rcx,[rsi-24]
                    cmp rcx,[rsi-24]      ;#00441282: 48:073116 E8               uv 00 42  2 279      
;   984             jne :pSubsssNewStr
                    jne #004412E4         ;#00441286: 165 5C                     v  00 00  1 280      
;   985             lea rax,[rsi+1]
                    lea rax,[rsi+1]       ;#00441288: 48:215106 01               uv 01 40  1 281      
;   986             pop rdi             -- addr tgt
                    pop rdi               ;#0044128C: 48:137                     vu 80 00  1 281      
;   987             ror rax,2           -- == ref p2 (or ref[idx1][idx2]...[idxn-1])
                    ror rax,2             ;#0044128E: 48:301310 02               np 01 01  1 282      
;   988             mov dword[rsi-16],2 -- refcount is now 2
                    mov [rsi-16], dword 2  ;#00441292: 307106 F0 02000000         uv 00 40  1 283      
;   989             mov [rdi],rax
                    mov [rdi],rax         ;#00441299: 48:211007                  uv 00 81  1 285    *80*
;   990             ret
                    ret                   ;#0044129C: 303                        np 00 00  2 286      
;   991       @@:
;   992         lea rax,[rbx+rdi*4]     -- raw tgt
                lea rax,[rbx+rdi*4]       ;#0044129D: 48:215004273               uv 01 88  1 288      
;   993         cmp rax,rsi
                cmp rax,rsi               ;#004412A1: 48:071360                  uv 00 41  1 289 01   
;   994         jne @f
                jne #004412B3             ;#004412A4: 165 0D                     v  00 00  1 289      
;   995             -- s=s[1..?], no incref/decref needed.
;   996             mov [rsi-24],rcx    -- set new length
                    mov [rsi-24],rcx      ;#004412A6: 48:211116 E8               uv 00 42  1 290      
;   997 --26/1/15:
;   998 --          add rsp,4           -- discard addr tgt
;   999             add rsp,8           -- discard addr tgt
                    add rsp,8             ;#004412AA: 48:203304 08               vu 10 10  1 290      
;  1000             mov byte[rsi+rcx],0 -- plant new terminator
                    mov [rsi+rcx], byte 0  ;#004412AE: 306004016 00               uv 00 42  1 291      
;  1001             ret
                    ret                   ;#004412B2: 303                        np 00 00  2 292      
;  1002       @@:
;  1003         -- p1!=p2.
;  1004         -- again, we can still just copy ref p2 & deref p1, iff ecx==length(p2).
;  1005         --  ie/eg a=b[1..-1] can just incref b, but a=b[1..-2] needs to
;  1006         --       end up with two different length strings in a & b.
;  1007         cmp rcx,[rsi-24]
                cmp rcx,[rsi-24]          ;#004412B3: 48:073116 E8               uv 00 42  2 294      
;  1008         jne :pSubsssNewStr
                jne #004412E4             ;#004412B7: 165 2B                     v  00 00  1 295      
;  1009         mov rdx,rdi         -- for dealloc
                mov rdx,rdi               ;#004412B9: 48:213327                  uv 04 80  1 296      
;  1010         mov qword[rsi-16],2 -- set new refcount (we know it was 1)
                mov qword[rsi-16],2       ;#004412BC: 48:307106 F0 02000000      vu 00 40  1 296      
;  1011         pop rdi             -- addr tgt
                pop rdi                   ;#004412C4: 48:137                     uv 80 00  1 297      
;  1012         add rsi,1
                add rsi,1                 ;#004412C6: 48:203306 01               vu 40 40  1 297      
;  1013         mov rcx,[rax-16]    -- p1 refcount
                mov rcx,[rax-16]          ;#004412CA: 48:213110 F0               uv 02 01  1 298      
;  1014         ror rsi,2           -- recreated ref p2
                ror rsi,2                 ;#004412CE: 48:301316 02               np 40 40  1 299      
;  1015         sub rcx,1
                sub rcx,1                 ;#004412D2: 48:203351 01               uv 02 02  1 300      
;  1016         mov [rdi],rsi
                mov [rdi],rsi             ;#004412D6: 48:211067                  vu 00 C0  1 300      
;  1017         jz :%pDealloc
                jz #004422DA (:%pDealloc)  ;#004412D9: 017204 FB0F0000            v  00 00  1 301      
;  1018         mov [rax-16],rcx
                mov [rax-16],rcx          ;#004412DF: 48:211110 F0               uv 00 03  1 302      
;  1019         ret
                ret                       ;#004412E3: 303                        np 00 00  2 303      
;  1020 
;  1021       ::pSubsssNewStr
;  1022         call :%pAllocStr        -- damages rax only
                call #004420E3 (:%pAllocStr)  ;#004412E4: 350 FA0D0000               v  00 00  1 305      
;  1023         add rsi,rdx             -- raw(p2) + slice start (0-based)
                add rsi,rdx               ;#004412E9: 48:001326                  uv 40 44  1 306      
;  1024         push rax                --[2] save ref
                push rax                  ;#004412EC: 48:120                     vu 00 01  1 306      
;  1025         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#004412EE: 48:215074203               uv 80 09  1 307      
;  1026         rep movsb
                rep movsb                 ;#004412F2: 363:244                    np C2 C2  4 310    *C0*
;  1027         xor rax,rax
                xor rax,rax               ;#004412F4: 48:061300                  uv 01 01  1 314      
;  1028         stosb                   -- trailing null
                stosb                     ;#004412F7: 252                        np 80 81  3 316    *80*
;  1029 
;  1030     --  ::pSubsssStore
;  1031         pop rax                 --[2] newly created ref
                pop rax                   ;#004412F8: 48:130                     uv 01 00  1 319      
;  1032         pop rdi                 -- addr result
                pop rdi                   ;#004412FA: 48:137                     vu 80 00  1 319      
;  1033         mov rdx,[rdi]
                mov rdx,[rdi]             ;#004412FC: 48:213027                  uv 04 80  1 322    *80*
;  1034         mov [rdi],rax
                mov [rdi],rax             ;#004412FF: 48:211007                  vu 00 81  1 322      
;  1035         cmp rdx,r15
                cmp rdx,r15               ;#00441302: 49:073327                  uv 00 8004  1 323      
;  1036         jle @f
                jle #00441313             ;#00441305: 176 0C                     v  00 00  1 323      
;  1037             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#00441307: 48:203154223 F0 01         u  00 0C  3 324      
;  1038             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0044130D: 017204 C70F0000            v  00 00  1 326      
;  1039       @@:
;  1040         ret
                ret                       ;#00441313: 303                        np 00 00  2 327      
;  1041     []
;  1042       }
;  1043 
    jmp #0044298D (:%opRetf)              ;#00441314: 351 74160000               v  00 00  1 329      
;C:\Program Files (x86)\Phix\builtins\VM\pRepeN.e:
;=================================================
;     1 --
;     2 -- pRepeN.e
;     3 -- ========
;     4 --
;     5 --  Various subscripting routines:
;     6 --
;     7 --      :%pRepe             -- eax[esp]..[esp+n]:=[edi]
;     8 --      :%pRepe1            -- esi[edi]:=ecx, aka ref[idx]:=rep
;     9 --      :%pRepe1ip          -- esi[edi]:=ecx, as opRepe1 when esi is sequence of integer, as proved by gvar_scan.
;    10 --      :%pRepe1is          -- esi[edi]:=ecx, as opRepe1 when esi is string, as proved by gvar_scan.
;    11 --
;    12 --  The latter three are optimised forms of :%pRepe, with exactly 1 index and other strict rules.
;    13 --  If porting, you could just (temporarily) implement :%pRepe and use it for everything, but 
;    14 --  that would require matching (temp) changes to psym.e, pmain.e, and pilx86.e.
;    15 --
;    16 
;    17 include builtins\VM\pHeap.e     -- :%pDealloc, :%pAllocStr, :%pAllocSeq
;    18 
;    19 include builtins\VM\pFixup.e    -- negative and floating point index handling (:%fixupIndex)
;    20 
;    21 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#00440ABD: 351 CB1E0000               v  00 00  1   1      
;    22 
;    23 --DEV FIXME: (and the :!bang labels below)
;    24 --  ::e04atsaa08
;    25 --      int3
;    26     ::e04atsaa8
;    27         int3
                int3                      ;#00440AC2: 314                        np 00 00 13   2      
;    28     ::e04atsaa9
;    29         int3
                int3                      ;#00440AC3: 314                        np 00 00 13  15      
;    30     ::e04atsaa4
;    31         int3
                int3                      ;#00440AC4: 314                        np 00 00 13  28      
;    32     ::e110Repe1is
;    33         int3
                int3                      ;#00440AC5: 314                        np 00 00 13  41      
;    34 
;    35 --/*
;    36 procedure :%pRepe(:%)
;    37 end procedure -- (for Edita/CtrlQ)
;    38 --*/
;    39     :%pRepe         -- eax[esp]..[esp+n]:=[edi]
;    40 -----------
;    41     [32]
;    42         --calling convention:
;    43         --  push <return addr>
;    44         --  push [rep]              (opUnassigned)
;    45         --  push [idxn]..[idx1]     (opUnassigned)
;    46         --  mov ecx,n
;    47         --  lea eax,[ref]
;    48         --  jmp :%pRepe
;    49         --<return addr>
;    50       ::opRepeWhile
;    51         --
;    52         -- On entry, eax is address of ref, ecx is remaining indexes,
;    53         --  next index to apply is on the stack
;    54         --
;    55         mov esi,[eax]           -- ref
;    56         pop edi                 -- idx
;    57         cmp esi,h4
;    58 --      jl :e04atsaa08          -- attempt to subscript an atom, era @ [esp+ecx*4]
;    59         jge @f
;    60             mov edx,[esp+ecx*4]
;    61             mov al,4            -- e04atssaa
;    62             sub edx,1
;    63             jmp :!iDiag
;    64             int3
;    65       @@:
;    66         shl esi,2               -- raw addr of ref
;    67         push eax                --[1] ref addr, in case we need to clone...
;    68         sub edi,1
;    69         mov edx,[esi-12]        -- length
;    70         cmp byte[esi-1],0x80
;    71         jne :RepeStr
;    72         cmp edi,edx             -- cmp idx,length
;    73         jb @f                   -- unsigned jump, lets 0..len-1 through
;    74             add ecx,1
;    75             mov al,8+4+0        -- [era] @ [esp+ecx*4+4], "assigning to"
;    76             call :%fixupIndex   -- idx-1 in edi, len in edx, al set
;    77             sub ecx,1
;    78       @@:
;    79         --
;    80         -- edi now contains 0-based index to replace, and edx the length
;    81         -- ecx is remaining indexes (including the one in edi)
;    82         --   
;    83         mov eax,[esi-8]         -- refcount
;    84         sub eax,1
;    85         jz :RepeSeqNoClone
;    86         mov [esi-8],eax         -- non-1 so no need to dealloc
;    87         push ecx                --[2] remaining idx
;    88         push edi                --[3] idx
;    89         mov edi,[esp+8]         --[1] (ref addr, leaving it on the stack)
;    90 --      mov ecx,edx
;    91         push edx
;    92         mov edx,[esp+ecx*4+20]  -- era
;    93         mov ecx,[esp]
;    94         call :%pAllocSeq        -- damages eax only
;    95         pop edx
;    96         mov [edi],eax           -- Replace the ref at the original address
;    97         lea edi,[ebx+eax*4]
;    98         push edi                --[4] raw addr of newly allocated sequence
;    99         mov ecx,edx
;   100       @@:
;   101             lodsd               -- mov eax,[esi], esi+=4
;   102             stosd               -- mov [edi],eax, edi+=4
;   103             cmp eax,h4
;   104             jl :Repe_no_incref
;   105                 add dword[ebx+eax*4-8],1
;   106           ::Repe_no_incref
;   107             sub ecx,1
;   108             jnz @b
;   109 
;   110         pop esi                 --[4] NB esi:=edi!
;   111         pop edi                 --[3] idx
;   112         pop ecx                 --[2] remainding idx
;   113 
;   114       ::RepeSeqNoClone
;   115         add esp,4               --[1] discard
;   116         lea eax,[esi+edi*4]
;   117         sub ecx,1
;   118         jnz :opRepeWhile
;   119 
;   120         pop ecx                 -- replacement
;   121         mov edx,[eax]
;   122         cmp ecx,h4
;   123         jl @f
;   124           add dword[ebx+ecx*4-8],1
;   125       @@:
;   126         mov [eax],ecx
;   127         cmp edx,h4
;   128         jle @f
;   129           sub dword[ebx+edx*4-8],1
;   130           jz :%pDealloc
;   131       @@:
;   132         ret
;   133 
;   134       ::RepeStr
;   135         cmp byte[esi-1],0x82
;   136         jne :e04atsaa8          -- era @ [esp+ecx*4]
;   137         sub ecx,1
;   138         jnz :e04atsaa9          -- must be last index, era @ [esp+ecx*4+4]
;   139         mov ecx,[esp+4]         -- replacement
;   140         xor ebx,ebx
;   141         cmp ecx,255
;   142         ja :RepeExpandString    -- also jumps for -ve & non-int
;   143         cmp [esi+edi],cl        -- avoid clone if unchanged
;   144         je @f
;   145         cmp dword[esi-8],1      -- refcount 1?
;   146         jnz :RepeDupString
;   147         mov [esi+edi],cl        -- replace char in situ then
;   148       @@:
;   149         add esp,8               -- discard [1] and replacement
;   150         ret
;   151 
;   152       ::RepeDupString
;   153         sub dword[esi-8],1      -- non-1 so no need to dealloc
;   154         mov ecx,edx
;   155         pop edx                 --[1] this is why we saved it!
;   156         call :%pAllocStr        -- damages eax only
;   157         add ecx,1               -- include trailing null
;   158         mov [edx],eax           -- replace ref at original address
;   159         lea edx,[eax*4+edi]     -- replacement char location
;   160         lea edi,[ebx+eax*4]
;   161         rep movsb
;   162         pop ecx
;   163         mov [edx],cl
;   164         ret
;   165 
;   166       ::RepeExpandString
;   167         mov ecx,edx
;   168         mov edx,[esp+8]         -- era
;   169         call :%pAllocSeq        -- damages eax only
;   170         push eax                --[2]
;   171         shl eax,2
;   172         lea edx,[eax+edi*4]     -- replacement location
;   173         mov edi,eax
;   174         xor eax,eax
;   175       @@:
;   176             lodsb               -- mov al,[esi], esi+=1
;   177             stosd               -- mov [edi],eax, edi+=4
;   178             sub ecx,1
;   179             jnz @b
;   180 
;   181         mov eax,[esp+8]         -- replacement
;   182         cmp eax,h4
;   183         jl @f
;   184           add dword[ebx+eax*4-8],1
;   185       @@:
;   186         pop ecx                 --[2] newly allocated sequence
;   187         pop edi                 --[1] address of ref to replace
;   188         mov [edx],eax           -- replace element (a char that became a dword)
;   189         add esp,4               -- discard replacement
;   190         mov edx,[edi]           -- get old
;   191         mov [edi],ecx           -- replace expanded string
;   192         cmp edx,h4
;   193         jle @f
;   194           sub dword[ebx+edx*4-8],1
;   195           jz :%pDealloc
;   196       @@:
;   197         ret
;   198     [64]
;   199         --calling convention:
;   200         --  push <return addr>
;   201         --  push [rep]              (opUnassigned)
;   202         --  push [idxn]..[idx1]     (opUnassigned)
;   203         --  mov rcx,n
;   204         --  lea rax,[ref]
;   205         --  jmp :%pRepe
;   206         --<return addr>
;   207         mov r15,h4
                mov r15,h4                ;#00440AC6: 49:277 0000000000000040    uv 8000 00  1  54      
;   208       ::opRepeWhile
;   209         --
;   210         -- On entry, rax is address of ref, rcx is remaining indexes,
;   211         --  next index to apply is on the stack
;   212         --
;   213         mov rsi,[rax]       -- ref
                mov rsi,[rax]             ;#00440AD0: 48:213060                  vu 40 01  1  54      
;   214         pop rdi             -- idx
                pop rdi                   ;#00440AD3: 48:137                     uv 80 00  1  55      
;   215         cmp rsi,r15
                cmp rsi,r15               ;#00440AD5: 49:073367                  vu 00 8040  1  55      
;   216 --      jl :e04atsaa08      -- attempt to subscript an atom, era @ [esp+ecx*4]
;   217         jge @f
                jge #00440AEA             ;#00440AD8: 175 10                     v  00 00  1  56      
;   218             mov rdx,[rsp+rcx*8]
                    mov rdx,[rsp+rcx*8]   ;#00440ADA: 48:213024314               uv 04 12  1  57      
;   219             mov al,4        -- e04atssaa
                    mov al,4              ;#00440ADE: 260 04                     vu 01 00  1  57      
;   220             sub rdx,1
                    sub rdx,1             ;#00440AE0: 48:203352 01               uv 04 04  1  58      
;   221             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#00440AE4: 351 7D230000               v  00 00  1  58      
;   222             int3
                    int3                  ;#00440AE9: 314                        np 00 00 13  59      
;   223       @@:
;   224         shl rsi,2           -- raw addr of ref
                shl rsi,2                 ;#00440AEA: 48:301346 02               u  40 40  1  72      
;   225         push rax            --[1] ref addr, in case we need to clone...
                push rax                  ;#00440AEE: 48:120                     vu 00 01  1  72      
;   226         sub rdi,1
                sub rdi,1                 ;#00440AF0: 48:203357 01               uv 80 80  1  73      
;   227 --      mov rdx,[rsi-12]    -- length
;   228         mov rdx,[rsi-24]    -- length
                mov rdx,[rsi-24]          ;#00440AF4: 48:213126 E8               uv 04 40  1  75    *40*
;   229         cmp byte[rsi-1],0x80
                cmp byte[rsi-1],#80       ;#00440AF8: 200176 FF 80               u  00 40  2  76      
;   230         jne :RepeStr
                jne #00440B9D             ;#00440AFC: 017205 9B000000            v  00 00  1  77      
;   231         cmp rdi,rdx         -- cmp idx,length
                cmp rdi,rdx               ;#00440B02: 48:071327                  uv 00 84  1  78      
;   232         jb @f               -- unsigned jump, lets 0..len-1 through
                jb #00440B16              ;#00440B05: 162 0F                     v  00 00  1  78      
;   233             add rcx,1
                    add rcx,1             ;#00440B07: 48:203301 01               uv 02 02  1  79      
;   234             mov al,8+4+0        -- [era] @ [esp+ecx*4+4], "assigning to"
                    mov al,12             ;#00440B0B: 260 0C                     vu 01 00  1  79      
;   235             call :%fixupIndex   -- idx-1 in edi, len in edx, al set
                    call #0044144B (:%fixupIndex)  ;#00440B0D: 350 39090000               v  00 00  1  80      
;   236             sub rcx,1
                    sub rcx,1             ;#00440B12: 48:203351 01               uv 02 02  1  81      
;   237       @@:
;   238         --
;   239         -- rdi now contains 0-based index to replace, and rdx the length
;   240         -- rcx is remaining indexes (including the one in rdi)
;   241         --   
;   242         mov rax,[rsi-16]        -- refcount
                mov rax,[rsi-16]          ;#00440B16: 48:213106 F0               vu 01 40  1  81      
;   243         sub rax,1
                sub rax,1                 ;#00440B1A: 48:203350 01               uv 01 01  1  82      
;   244         jz :RepeSeqNoClone
                jz #00440B66              ;#00440B1E: 164 46                     v  00 00  1  82      
;   245         mov [rsi-16],rax        -- non-1 so no need to dealloc
                mov [rsi-16],rax          ;#00440B20: 48:211106 F0               uv 00 41  1  83      
;   246         push rcx                --[2] remaining idx
                push rcx                  ;#00440B24: 48:121                     vu 00 02  1  83      
;   247         push rdi                --[3] idx
                push rdi                  ;#00440B26: 48:127                     uv 00 80  1  84      
;   248         mov rdi,[rsp+16]        --[1] (ref addr, leaving it on the stack)
                mov rdi,[rsp+16]          ;#00440B28: 48:213174044 10            vu 80 10  1  84      
;   249 --      mov rcx,rdx
;   250         push rdx
                push rdx                  ;#00440B2D: 48:122                     uv 00 04  1  85      
;   251         mov rdx,[rsp+rcx*8+40]  -- era
                mov rdx,[rsp+rcx*8+40]    ;#00440B2F: 48:213124314 28            vu 04 12  1  85      
;   252         mov rcx,[rsp]
                mov rcx,[rsp]             ;#00440B34: 48:213014044               uv 02 10  1  86      
;   253         call :%pAllocSeq        -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440B38: 350 0B160000               v  00 00  1  86      
;   254         pop rdx
                pop rdx                   ;#00440B3D: 48:132                     uv 04 00  1  87      
;   255         mov [rdi],rax           -- Replace the ref at the original address
                mov [rdi],rax             ;#00440B3F: 48:211007                  vu 00 81  1  87      
;   256         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#00440B42: 48:215074203               uv 80 09  1  88      
;   257         push rdi                --[4] raw addr of newly allocated sequence
                push rdi                  ;#00440B46: 48:127                     uv 00 80  1  89 80   
;   258         mov rcx,rdx
                mov rcx,rdx               ;#00440B48: 48:213312                  vu 02 04  1  89      
;   259 --      mov r15,h4
;   260       @@:
;   261             lodsq               -- mov rax,[rsi], rsi+=8
                    lodsq                 ;#00440B4B: 48:255                     np 41 40  2  90      
;   262             stosq               -- mov [rdi],rax, rdi+=8
                    stosq                 ;#00440B4D: 48:253                     np 80 81  3  92      
;   263             cmp rax,r15
                    cmp rax,r15           ;#00440B4F: 49:073307                  uv 00 8001  1  95      
;   264             jl :Repe_no_incref
                    jl #00440B5A          ;#00440B52: 174 06                     v  00 00  1  95      
;   265                 add qword[rbx+rax*4-16],1
                        add qword[rbx+rax*4-16],1  ;#00440B54: 48:203104203 F0 01         u  00 09  3  96      
;   266           ::Repe_no_incref
;   267             sub rcx,1
                    sub rcx,1             ;#00440B5A: 48:203351 01               vu 02 02  1  98      
;   268             jnz @b
                    jnz #00440B4B         ;#00440B5E: 165 EB                     v  00 00  1  99      
;   269 
;   270         pop rsi                 --[4] NB esi:=edi!
                pop rsi                   ;#00440B60: 48:136                     uv 40 00  1 100      
;   271         pop rdi                 --[3] idx
                pop rdi                   ;#00440B62: 48:137                     vu 80 00  1 100      
;   272         pop rcx                 --[2] remainding idx
                pop rcx                   ;#00440B64: 48:131                     uv 02 00  1 101      
;   273 
;   274       ::RepeSeqNoClone
;   275         add rsp,8               --[1] discard
                add rsp,8                 ;#00440B66: 48:203304 08               vu 10 10  1 101      
;   276         lea rax,[rsi+rdi*8]
                lea rax,[rsi+rdi*8]       ;#00440B6A: 48:215004376               uv 01 C0  1 102      
;   277         sub rcx,1
                sub rcx,1                 ;#00440B6E: 48:203351 01               vu 02 02  1 102      
;   278         jnz :opRepeWhile
                jnz #00440AD0             ;#00440B72: 017205 58FFFFFF            v  00 00  1 103      
;   279 
;   280         pop rcx                 -- replacement
                pop rcx                   ;#00440B78: 48:131                     uv 02 00  1 104      
;   281         mov rdx,[rax]
                mov rdx,[rax]             ;#00440B7A: 48:213020                  vu 04 01  1 104      
;   282 --      mov r15,h4
;   283         cmp rcx,r15
                cmp rcx,r15               ;#00440B7D: 49:073317                  uv 00 8002  1 105      
;   284         jl @f
                jl #00440B88              ;#00440B80: 174 06                     v  00 00  1 105      
;   285           add qword[rbx+rcx*4-16],1
                  add qword[rbx+rcx*4-16],1  ;#00440B82: 48:203104213 F0 01         u  00 0A  3 106      
;   286       @@:
;   287         mov [rax],rcx
                mov [rax],rcx             ;#00440B88: 48:211010                  vu 00 03  1 108      
;   288         cmp rdx,r15
                cmp rdx,r15               ;#00440B8B: 49:073327                  uv 00 8004  1 109      
;   289         jle @f
                jle #00440B9C             ;#00440B8E: 176 0C                     v  00 00  1 109      
;   290           sub qword[rbx+rdx*4-16],1
                  sub qword[rbx+rdx*4-16],1  ;#00440B90: 48:203154223 F0 01         u  00 0C  3 110      
;   291           jz :%pDealloc
                  jz #004422DA (:%pDealloc)  ;#00440B96: 017204 3E170000            v  00 00  1 112      
;   292       @@:
;   293         ret
                ret                       ;#00440B9C: 303                        np 00 00  2 113      
;   294 
;   295       ::RepeStr
;   296         cmp byte[rsi-1],0x82
                cmp byte[rsi-1],#82       ;#00440B9D: 200176 FF 82               u  00 40  2 115      
;   297         jne :e04atsaa8          -- era @ [esp+ecx*4]
                jne #00440AC2             ;#00440BA1: 017205 1BFFFFFF            v  00 00  1 116      
;   298         sub rcx,1
                sub rcx,1                 ;#00440BA7: 48:203351 01               uv 02 02  1 117      
;   299         jnz :e04atsaa9          -- must be last index, era @ [esp+ecx*4+4]
                jnz #00440AC3             ;#00440BAB: 017205 12FFFFFF            v  00 00  1 117      
;   300         mov rcx,[rsp+8]         -- replacement (from calling convention)
                mov rcx,[rsp+8]           ;#00440BB1: 48:213114044 08            uv 02 10  1 118      
;   301         xor rbx,rbx
                xor rbx,rbx               ;#00440BB6: 48:061333                  vu 08 08  1 118      
;   302         cmp rcx,255
                cmp rcx,255               ;#00440BB9: 48:201371 FF000000         uv 00 02  1 119      
;   303         ja :RepeExpandString    -- also jumps for -ve & non-int
                ja #00440BFB              ;#00440BC0: 167 39                     v  00 00  1 119      
;   304         cmp [rsi+rdi],cl        -- avoid clone if unchanged
                cmp [rsi+rdi],cl          ;#00440BC2: 070014076                  uv 00 C2  2 120      
;   305         je @f
                je #00440BD1              ;#00440BC5: 164 0A                     v  00 00  1 121      
;   306         cmp qword[rsi-16],1     -- refcount 1?
                cmp qword[rsi-16],1       ;#00440BC7: 48:203176 F0 01            u  00 40  2 122      
;   307         jnz :RepeDupString
                jnz #00440BD6             ;#00440BCC: 165 08                     v  00 00  1 123      
;   308         mov [rsi+rdi],cl        -- replace char in situ then
                mov [rsi+rdi],cl          ;#00440BCE: 210014076                  uv 00 C2  1 124      
;   309       @@:
;   310         add rsp,16              -- discard [1] and replacement
                add rsp,16                ;#00440BD1: 48:203304 10               vu 10 10  1 124      
;   311         ret
                ret                       ;#00440BD5: 303                        np 00 00  2 125      
;   312 
;   313       ::RepeDupString
;   314         sub qword[rsi-16],1     -- non-1 so no need to dealloc
                sub qword[rsi-16],1       ;#00440BD6: 48:203156 F0 01            u  00 40  3 127      
;   315         mov rcx,rdx
                mov rcx,rdx               ;#00440BDB: 48:213312                  vu 02 04  1 129      
;   316         pop rdx                 --[1] this is why we saved it!
                pop rdx                   ;#00440BDE: 48:132                     uv 04 00  1 130      
;   317         call :%pAllocStr        -- damages rax only
                call #004420E3 (:%pAllocStr)  ;#00440BE0: 350 FE140000               v  00 00  1 130      
;   318         add rcx,1               -- include trailing null
                add rcx,1                 ;#00440BE5: 48:203301 01               uv 02 02  1 131      
;   319         mov [rdx],rax           -- replace ref at original address
                mov [rdx],rax             ;#00440BE9: 48:211002                  uv 00 05  1 133    *04*
;   320         lea rdx,[rax*4+rdi]     -- replacement char location
                lea rdx,[rdi+rax*4]       ;#00440BEC: 48:215024207               vu 04 81  1 133      
;   321         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#00440BF0: 48:215074203               uv 80 09  1 134      
;   322         rep movsb
                rep movsb                 ;#00440BF4: 363:244                    np C2 C2  4 137    *80*
;   323         pop rcx
                pop rcx                   ;#00440BF6: 48:131                     uv 02 00  1 141      
;   324         mov [rdx],cl
                mov [edx],cl              ;#00440BF8: 210012                     uv 00 06  1 142 02   
;   325         ret
                ret                       ;#00440BFA: 303                        np 00 00  2 143      
;   326 
;   327       ::RepeExpandString
;   328         mov rcx,rdx
                mov rcx,rdx               ;#00440BFB: 48:213312                  uv 02 04  1 145      
;   329         mov rdx,[rsp+16]        -- era
                mov rdx,[rsp+16]          ;#00440BFE: 48:213124044 10            vu 04 10  1 145      
;   330         call :%pAllocSeq        -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440C03: 350 40150000               v  00 00  1 146      
;   331         push rax                --[2]
                push rax                  ;#00440C08: 48:120                     uv 00 01  1 147      
;   332         shl rax,2
                shl rax,2                 ;#00440C0A: 48:301340 02               u  01 01  1 148      
;   333         lea rdx,[rax+rdi*8]     -- replacement location
                lea rdx,[rax+rdi*8]       ;#00440C0E: 48:215024370               uv 04 81  1 151 01 *01*
;   334         mov rdi,rax
                mov rdi,rax               ;#00440C12: 48:213370                  vu 80 01  1 151      
;   335         xor rax,rax
                xor rax,rax               ;#00440C15: 48:061300                  uv 01 01  1 152      
;   336       @@:
;   337             lodsb               -- mov al,[rsi], rsi+=1
                    lodsb                 ;#00440C18: 254                        np 41 40  2 153      
;   338             stosq               -- mov [rdi],rax, rdi+=8
                    stosq                 ;#00440C19: 48:253                     np 80 81  3 155      
;   339             sub rcx,1
                    sub rcx,1             ;#00440C1B: 48:203351 01               uv 02 02  1 158      
;   340             jnz @b
                    jnz #00440C18         ;#00440C1F: 165 F7                     v  00 00  1 158      
;   341 
;   342         mov rax,[rsp+16]        -- replacement
                mov rax,[rsp+16]          ;#00440C21: 48:213104044 10            uv 01 10  1 159      
;   343 --      mov r15,h4
;   344         cmp rax,r15
                cmp rax,r15               ;#00440C26: 49:073307                  uv 00 8001  1 160 01   
;   345         jl @f
                jl #00440C31              ;#00440C29: 174 06                     v  00 00  1 160      
;   346           add qword[rbx+rax*4-16],1
                  add qword[rbx+rax*4-16],1  ;#00440C2B: 48:203104203 F0 01         u  00 09  3 161      
;   347       @@:
;   348         pop rcx                 --[2] newly allocated sequence
                pop rcx                   ;#00440C31: 48:131                     vu 02 00  1 163      
;   349         pop rdi                 --[1] address of ref to replace
                pop rdi                   ;#00440C33: 48:137                     uv 80 00  1 164      
;   350         mov [rdx],rax           -- replace element (a char that became a dword)
                mov [rdx],rax             ;#00440C35: 48:211002                  vu 00 05  1 164      
;   351         add rsp,8               -- discard replacement
                add rsp,8                 ;#00440C38: 48:203304 08               uv 10 10  1 165      
;   352         mov rdx,[rdi]           -- get old
                mov rdx,[rdi]             ;#00440C3C: 48:213027                  uv 04 80  1 167    *80*
;   353         mov [rdi],rcx           -- replace expanded string
                mov [rdi],rcx             ;#00440C3F: 48:211017                  vu 00 82  1 167      
;   354         cmp rdx,r15
                cmp rdx,r15               ;#00440C42: 49:073327                  uv 00 8004  1 168      
;   355         jle @f
                jle #00440C53             ;#00440C45: 176 0C                     v  00 00  1 168      
;   356           sub qword[rbx+rdx*4-16],1
                  sub qword[rbx+rdx*4-16],1  ;#00440C47: 48:203154223 F0 01         u  00 0C  3 169      
;   357           jz :%pDealloc
                  jz #004422DA (:%pDealloc)  ;#00440C4D: 017204 87160000            v  00 00  1 171      
;   358       @@:
;   359         ret
                ret                       ;#00440C53: 303                        np 00 00  2 172      
;   360     []
;   361 
;   362 --/*
;   363 procedure :%pRepe1(:%)
;   364 end procedure -- (for Edita/CtrlQ)
;   365 --*/
;   366     :%pRepe1            -- esi[edi]:=ecx, aka ref[idx]:=rep
;   367 ------------
;   368     [32]
;   369         --calling convention:
;   370         --  mov edi,[idx]       (opUnassigned)
;   371         --  mov ecx,[rep]       (opUnassigned)
;   372         --  mov esi,[ref]       (opUnassigned)
;   373         --  lea eax,[ref]
;   374         --  call :%pRepe1       -- ref[idx]:=rep
;   375         sub edi,1                   -- idx -= 1
;   376 --  mov [rep1ra],eax            -- save addr rep, in case we clone [ref?!]
;   377         push eax                    --[0] save addr ref
;   378         mov edx,[ebx+esi*4-12]      -- get length
;   379         cmp edi,edx                 -- if idx is -ve/float/oob then longhand
;   380         jb @f
;   381             mov al,4+0              -- [era] @ [esp+8] "assigning to"
;   382             call :%fixupIndex       -- idx-1 in edi, len in edx, not idx addr in ebx, al set
;   383       @@:
;   384         cmp dword[ebx+esi*4-8],1    -- if refcount!=1 then clone
;   385         jne :opRepe1Clone
;   386         lea eax,[ebx+esi*4]
;   387         cmp byte[ebx+esi*4-1],0x80  -- type byte
;   388         jbe :opRepe1Sequence
;   389         cmp ecx,255
;   390         ja :opRepe1ExpandString
;   391         add esp,4
;   392         mov [eax+edi],cl
;   393         ret
;   394 
;   395       ::opRepe1ExpandString
;   396         -- esi is ref of source string, of refcount 1, will need dealloc
;   397         -- edi is idx-1, checked to be in bounds
;   398         -- ecx is some non-char replacement
;   399         -- edx contains the original length
;   400         -- eax is src base (not used/refetched here)
;   401         -- [esp] is addr ref
;   402         cmp ecx,h4
;   403         jl @f
;   404             add dword[ebx+ecx*4-8],1
;   405       @@:
;   406         pop eax                     --[0]
;   407         push esi                    --[1] save the string ref for final dealloc
;   408         push ecx                    --[2] Replacement ref (rep)
;   409 --newEBP
;   410 --? mov ecx,[rep1ra]            -- ref addr
;   411         mov ecx,edx
;   412 --      mov edx,eax
;   413         push eax
;   414         mov edx,[esp+8]             -- era
;   415         call :%pAllocSeq            -- damages eax only
;   416         pop edx
;   417 --  mov ecx,[ecx-9]             -- ref addr
;   418         lea esi,[ebx+esi*4]
;   419 --DEV would    shl esi,2    be any better?
;   420         mov [edx],eax               -- replace it now
;   421         mov edx,ecx
;   422         lea ecx,[ebx+edi*4]         -- idx -> dwords
;   423         lea edi,[ebx+eax*4]         -- new base
;   424         xor eax,eax
;   425         add ecx,edi                 -- replacement location
;   426       @@:
;   427 --DEV lodsb stosd??
;   428 --      mov al,[esi]
;   429 --      inc esi
;   430         lodsb
;   431 --      mov [edi],eax
;   432 --      add edi,4
;   433         stosd
;   434 --      dec edx
;   435         sub edx,1
;   436         jnz @b
;   437 
;   438         pop esi                     --[2] Replacement ref
;   439         pop edx                     --[1] previous content (a string)
;   440         mov [ecx],esi
;   441         jmp :%pDealloc
;   442 
;   443       ::opRepe1Sequence
;   444         -- esi is source ref, of refcount 1 so replace in situ, 
;   445         --                    unless it is an atom (jl error)
;   446         -- edi is idx-1, checked to be in bounds
;   447         -- ecx is rep (may need incref)
;   448         -- edx contains the original length (no longer needed)
;   449         -- eax is src base
;   450         -- [esp] is addr ref
;   451         mov edx,[eax+edi*4]         -- get prev s[i]
;   452         jl :e04atsaa4               -- attempt to subscript an atom (era @ [esp-4])
;   453         cmp ecx,h4
;   454         jl @f
;   455             add dword[ebx+ecx*4-8],1
;   456       @@:
;   457         mov [eax+edi*4],ecx         -- rep
;   458         pop eax                     --[0] discard
;   459         cmp edx,h4
;   460         jle @f
;   461             sub dword[ebx+edx*4-8],1
;   462             jz :%pDealloc
;   463       @@:
;   464         ret
;   465 
;   466       ::opRepe1Clone
;   467         -- esi is src ref (unknown type), of refcount >1, (so just decref it)
;   468         -- edi is idx-1,
;   469         -- ecx is rep (may need incref)
;   470         -- edx contains the original length
;   471         -- eax is src base [BLUFF: addr ref]
;   472         -- [esp] is addr ref
;   473         sub dword[ebx+esi*4-8],1    -- reduce refcount (not 1, dealloc not rqd)
;   474         push ecx                    --[1] save rep
;   475         cmp ecx,h4                  -- incref if needed
;   476         jl @f
;   477             add dword[ebx+ecx*4-8],1
;   478       @@:
;   479         cmp byte[ebx+esi*4-1],0x80  -- type byte
;   480         jbe :opRepe1CloneSequence
;   481         cmp ecx,255
;   482         ja :opRepe1CloneExpandStr
;   483 --  mov ecx,[esp+4]             -- return addr
;   484 --newEBP
;   485 --  mov ecx,[rep1ra]
;   486         mov ecx,edx
;   487         mov edx,[esp+4]             -- [0]
;   488         call :%pAllocStr            -- damages eax only
;   489 --  mov ecx,[ecx-9]             -- ref addr
;   490 --  lea esi,[ebx+esi*4]
;   491         shl esi,2                   -- src base
;   492         mov [edx],eax               -- replace it now
;   493         add ecx,1                   -- include trailing null in following rep movsb
;   494         lea edx,[eax*4+edi]         -- replacement char location
;   495         lea edi,[ebx+eax*4]         -- raw(new)
;   496         pop eax                     --[1] Replacement char
;   497         rep movsb
;   498         mov [edx],al
;   499         add esp,4                   --[0]
;   500         ret
;   501 
;   502       ::opRepe1CloneSequence
;   503         -- esi is src ref, already decrefed, <= #80 (ie jl error rqd)
;   504         -- edi is idx-1,
;   505         -- edx contains the original length (ready for AllocSeq)
;   506         -- eax is src base [BLUFF: addr ref]
;   507         -- [esp] == ecx is rep (already increfd)
;   508         -- [esp+4] is addr ref
;   509 --newEBP::
;   510 --> mov ecx,[rep1ra]
;   511         mov ecx,edx
;   512         jl :e04atsaa8               -- attempt to subscript an atom (era @ [esp+8])
;   513         mov edx,[esp+8]             -- era
;   514         call :%pAllocSeq            -- damages eax only
;   515         mov edx,[esp+4]             -- [0]
;   516 --  mov ecx,[ecx-9]             -- ref addr
;   517         lea edi,[eax+edi]           -- after shl2 below will effectively be ...
;   518 --  lea esi,[ebx+esi*4]
;   519         shl esi,2                   -- src base
;   520         shl edi,2                   -- rep addr ... [eax*4(new base)+edi*4(idx->dwords)]
;   521         mov [edx],eax               -- replace it now (WOW! no AGI!)
;   522         shl eax,2                   -- new base
;   523       @@:
;   524         mov edx,[esi]
;   525         add esi,4
;   526         mov [eax],edx
;   527         add eax,4
;   528         cmp edx,h4
;   529         jl :Repe1_no_incref
;   530             -- exception here fatal (mid-clone/back-end error)
;   531             add dword[ebx+edx*4-8],1
;   532       ::Repe1_no_incref
;   533         sub ecx,1
;   534         jnz @b
;   535         mov edx,[edi]               -- prev s[i]
;   536         pop ecx                     -- [1] rep ref (already incref'd)
;   537         pop eax                     -- [0] discard
;   538         mov [edi],ecx
;   539         cmp edx,h4
;   540         jl @f
;   541             sub dword[ebx+edx*4-8],1
;   542             jz :%pDealloc
;   543       @@:
;   544         ret
;   545 
;   546       ::opRepe1CloneExpandStr
;   547         -- esi is src ref (string), already decrefed
;   548         -- edi is idx-1,
;   549         -- edx contains the original length (ready for AllocSeq)
;   550         -- eax is src base [bluff: addr ref]
;   551         -- [esp] == ecx is non-char rep (already increfd)
;   552         -- [esp+4] is addr ref
;   553 --  mov ecx,[esp+4]             -- return addr
;   554 --  opRepe1is110: ---- rejoin point for e110Repe1is [DEV]
;   555 --newEBP::
;   556 --> mov ecx,[rep1ra]
;   557         mov ecx,edx
;   558         mov edx,[esp+8]         -- era
;   559         call :%pAllocSeq        -- damages eax only
;   560         mov edx,[esp+4]         -- [0]
;   561 --  mov ecx,[ecx-9]             -- ref addr
;   562 --  lea edi,[eax+edi]           -- after shl2 below will effectively be ...
;   563         add edi,eax                 -- after shl2 below will effectively be ...
;   564 --  lea esi,[ebx+esi*4]
;   565         shl esi,2               -- src base
;   566         shl edi,2               -- rep addr ... [eax*4(new base)+edi*4(idx->dwords)]
;   567         mov [edx],eax           -- replace it now
;   568         mov edx,ecx
;   569         shl eax,2               -- new base
;   570         xor ecx,ecx
;   571       @@:
;   572         mov cl,[esi]
;   573         add esi,1
;   574         mov [eax],ecx
;   575         add eax,4
;   576         sub edx,1
;   577         jnz @b
;   578 --      pop ecx                 -- [1] rep
;   579         pop dword[edi]          -- [1] rep
;   580         pop eax                 -- [0] discard
;   581 --      mov [edi],ecx
;   582         ret
;   583     [64]
;   584         --calling convention:
;   585         --  mov rdi,[idx]       (opUnassigned)
;   586         --  mov rcx,[rep]       (opUnassigned)
;   587         --  mov rsi,[ref]       (opUnassigned)
;   588         --  lea rax,[ref]
;   589         --  call :%pRepe1       -- ref[idx]:=rep
;   590         sub rdi,1                   -- idx -= 1
                sub rdi,1                 ;#00440C54: 48:203357 01               uv 80 80  1 174      
;   591         push rax                    --[0] save addr ref
                push rax                  ;#00440C58: 48:120                     vu 00 01  1 174      
;   592         mov rdx,[rbx+rsi*4-24]      -- get length
                mov rdx,[rbx+rsi*4-24]    ;#00440C5A: 48:213124263 E8            uv 04 48  1 175      
;   593         cmp rdi,rdx                 -- if idx is -ve/float/oob then longhand
                cmp rdi,rdx               ;#00440C5F: 48:071327                  uv 00 84  1 176 04   
;   594         jb @f
                jb #00440C6B              ;#00440C62: 162 07                     v  00 00  1 176      
;   595             mov al,4+0              -- [era] @ [esp+8] "assigning to"
                    mov al,4              ;#00440C64: 260 04                     uv 01 00  1 177      
;   596             call :%fixupIndex       -- idx-1 in edi, len in edx, not idx addr in ebx, al set
                    call #0044144B (:%fixupIndex)  ;#00440C66: 350 E0070000               v  00 00  1 177      
;   597       @@:
;   598         cmp qword[rbx+rsi*4-16],1   -- if refcount!=1 then clone
                cmp qword[rbx+rsi*4-16],1  ;#00440C6B: 48:203174263 F0 01         u  00 48  2 178      
;   599         jne :opRepe1Clone
                jne #00440D22             ;#00440C71: 017205 AB000000            v  00 00  1 179      
;   600         lea rax,[rbx+rsi*4]
                lea rax,[rbx+rsi*4]       ;#00440C77: 48:215004263               uv 01 48  1 180      
;   601         cmp byte[rbx+rsi*4-1],0x80  -- type byte
                cmp byte[rbx+rsi*4-1],#80  ;#00440C7B: 200174263 FF 80            u  00 48  2 181      
;   602         jbe :opRepe1Sequence
                jbe #00440CEB             ;#00440C80: 166 69                     v  00 00  1 182      
;   603         cmp rcx,255
                cmp rcx,255               ;#00440C82: 48:201371 FF000000         uv 00 02  1 183      
;   604         ja :opRepe1ExpandString
                ja #00440C93              ;#00440C89: 167 08                     v  00 00  1 183      
;   605         add rsp,8
                add rsp,8                 ;#00440C8B: 48:203304 08               uv 10 10  1 184      
;   606         mov [rax+rdi],cl
                mov [rax+rdi],cl          ;#00440C8F: 210014070                  vu 00 83  1 184      
;   607         ret
                ret                       ;#00440C92: 303                        np 00 00  2 185      
;   608 
;   609       ::opRepe1ExpandString
;   610         -- rsi is ref of source string, of refcount 1, will need dealloc
;   611         -- rdi is idx-1, checked to be in bounds
;   612         -- rcx is some non-char replacement
;   613         -- rdx contains the original length
;   614         -- rax is src base (not used/refetched here)
;   615         -- [rsp] is addr ref
;   616         mov r15,h4
                mov r15,h4                ;#00440C93: 49:277 0000000000000040    uv 8000 00  1 187      
;   617         cmp rcx,r15
                cmp rcx,r15               ;#00440C9D: 49:073317                  uv 00 8002  1 188 8000   
;   618         jl @f
                jl #00440CA8              ;#00440CA0: 174 06                     v  00 00  1 188      
;   619             add qword[rbx+rcx*4-16],1
                    add qword[rbx+rcx*4-16],1  ;#00440CA2: 48:203104213 F0 01         u  00 0A  3 189      
;   620       @@:
;   621         pop rax                     --[0]
                pop rax                   ;#00440CA8: 48:130                     vu 01 00  1 191      
;   622         push rsi                    --[1] save the string ref for final dealloc
                push rsi                  ;#00440CAA: 48:126                     uv 00 40  1 192      
;   623         push rcx                    --[2] Replacement ref (rep)
                push rcx                  ;#00440CAC: 48:121                     vu 00 02  1 192      
;   624         mov rcx,rdx
                mov rcx,rdx               ;#00440CAE: 48:213312                  uv 02 04  1 193      
;   625 --      mov rdx,rax
;   626         mov r9,rax
                mov r9,rax                ;#00440CB1: 4C:213310                  vu 200 01  1 193      
;   627         mov rdx,[rsp+16]            -- era
                mov rdx,[rsp+16]          ;#00440CB4: 48:213124044 10            uv 04 10  1 194      
;   628         call :%pAllocSeq            -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440CB9: 350 8A140000               v  00 00  1 194      
;   629         lea rsi,[rbx+rsi*4]
                lea rsi,[rbx+rsi*4]       ;#00440CBE: 48:215064263               uv 40 48  1 195      
;   630 --      mov [rdx],rax               -- replace it now
;   631         mov [r9],rax                -- replace it now
                mov [r9],rax              ;#00440CC2: 49:211001                  vu 00 201  1 195      
;   632         mov rdx,rcx
                mov rdx,rcx               ;#00440CC5: 48:213321                  uv 04 02  1 196      
;   633         lea rcx,[rbx+rdi*8]         -- idx -> qwords
                lea rcx,[rbx+rdi*8]       ;#00440CC8: 48:215014373               vu 02 88  1 196      
;   634         lea rdi,[rbx+rax*4]         -- new base
                lea rdi,[rbx+rax*4]       ;#00440CCC: 48:215074203               uv 80 09  1 197      
;   635         xor rax,rax
                xor rax,rax               ;#00440CD0: 48:061300                  vu 01 01  1 197      
;   636         add rcx,rdi                 -- replacement location
                add rcx,rdi               ;#00440CD3: 48:001371                  uv 02 82  1 198      
;   637       @@:
;   638             lodsb
                    lodsb                 ;#00440CD6: 254                        np 41 40  2 199      
;   639             stosq
                    stosq                 ;#00440CD7: 48:253                     np 80 81  3 201      
;   640             sub rdx,1
                    sub rdx,1             ;#00440CD9: 48:203352 01               uv 04 04  1 204      
;   641             jnz @b
                    jnz #00440CD6         ;#00440CDD: 165 F7                     v  00 00  1 204      
;   642         pop rsi                     --[2] Replacement ref
                pop rsi                   ;#00440CDF: 48:136                     uv 40 00  1 205      
;   643         pop rdx                     --[1] previous content (a string)
                pop rdx                   ;#00440CE1: 48:132                     vu 04 00  1 205      
;   644         mov [rcx],rsi
                mov [rcx],rsi             ;#00440CE3: 48:211061                  uv 00 42  1 206      
;   645         jmp :%pDealloc
                jmp #004422DA (:%pDealloc)  ;#00440CE6: 351 EF150000               v  00 00  1 206      
;   646 
;   647       ::opRepe1Sequence
;   648         -- rsi is source ref, of refcount 1 so replace in situ, 
;   649         --                    unless it is an atom (jl error)
;   650         -- rdi is idx-1, checked to be in bounds
;   651         -- rcx is rep (may need incref)
;   652         -- rdx contains the original length (no longer needed)
;   653         -- rax is src base
;   654         -- [rsp] is addr ref
;   655         mov rdx,[rax+rdi*8]         -- get prev s[i]
                mov rdx,[rax+rdi*8]       ;#00440CEB: 48:213024370               uv 04 81  1 207      
;   656         jl :e04atsaa4               -- attempt to subscript an atom (era @ [esp-4])
                jl #00440AC4              ;#00440CEF: 017214 CFFDFFFF            v  00 00  1 207      
;   657         mov r15,h4
                mov r15,h4                ;#00440CF5: 49:277 0000000000000040    uv 8000 00  1 208      
;   658         cmp rcx,r15
                cmp rcx,r15               ;#00440CFF: 49:073317                  uv 00 8002  1 209 8000   
;   659         jl @f
                jl #00440D0A              ;#00440D02: 174 06                     v  00 00  1 209      
;   660             add qword[rbx+rcx*4-16],1
                    add qword[rbx+rcx*4-16],1  ;#00440D04: 48:203104213 F0 01         u  00 0A  3 210      
;   661       @@:
;   662         mov [rax+rdi*8],rcx         -- rep
                mov [rax+rdi*8],rcx       ;#00440D0A: 48:211014370               vu 00 83  1 212      
;   663         pop rax                     --[0] discard
                pop rax                   ;#00440D0E: 48:130                     uv 01 00  1 213      
;   664         cmp rdx,r15
                cmp rdx,r15               ;#00440D10: 49:073327                  vu 00 8004  1 213      
;   665         jle @f
                jle #00440D21             ;#00440D13: 176 0C                     v  00 00  1 214      
;   666             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#00440D15: 48:203154223 F0 01         u  00 0C  3 215      
;   667             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#00440D1B: 017204 B9150000            v  00 00  1 217      
;   668       @@:
;   669         ret
                ret                       ;#00440D21: 303                        np 00 00  2 218      
;   670 
;   671       ::opRepe1Clone
;   672         -- rsi is src ref (unknown type), of refcount >1, (so just decref it)
;   673         -- rdi is idx-1,
;   674         -- rcx is rep (may need incref)
;   675         -- rdx contains the original length
;   676         -- rax is src base [BLUFF: addr ref]
;   677         -- [rsp] is addr ref
;   678         sub qword[rbx+rsi*4-16],1   -- reduce refcount (not 1, dealloc not rqd)
                sub qword[rbx+rsi*4-16],1  ;#00440D22: 48:203154263 F0 01         u  00 48  3 220      
;   679         push rcx                    --[1] save rep
                push rcx                  ;#00440D28: 48:121                     vu 00 02  1 222      
;   680         mov r15,h4
                mov r15,h4                ;#00440D2A: 49:277 0000000000000040    uv 8000 00  1 223      
;   681         cmp rcx,r15                 -- incref if needed
                cmp rcx,r15               ;#00440D34: 49:073317                  uv 00 8002  1 224 8000   
;   682         jl @f
                jl #00440D3F              ;#00440D37: 174 06                     v  00 00  1 224      
;   683             add qword[rbx+rcx*4-16],1
                    add qword[rbx+rcx*4-16],1  ;#00440D39: 48:203104213 F0 01         u  00 0A  3 225      
;   684       @@:
;   685         cmp byte[rbx+rsi*4-1],0x80  -- type byte
                cmp byte[rbx+rsi*4-1],#80  ;#00440D3F: 200174263 FF 80            u  00 48  2 228      
;   686         jbe :opRepe1CloneSequence
                jbe #00440D7E             ;#00440D44: 166 38                     v  00 00  1 229      
;   687         cmp rcx,255
                cmp rcx,255               ;#00440D46: 48:201371 FF000000         uv 00 02  1 230      
;   688         ja :opRepe1CloneExpandStr
                ja #00440DF1              ;#00440D4D: 017207 9E000000            v  00 00  1 230      
;   689         mov rcx,rdx
                mov rcx,rdx               ;#00440D53: 48:213312                  uv 02 04  1 231      
;   690         mov rdx,[rsp+8]             --[0] ref addr
                mov rdx,[rsp+8]           ;#00440D56: 48:213124044 08            vu 04 10  1 231      
;   691         call :%pAllocStr            -- damages rax only
                call #004420E3 (:%pAllocStr)  ;#00440D5B: 350 83130000               v  00 00  1 232      
;   692         shl rsi,2                   -- src base
                shl rsi,2                 ;#00440D60: 48:301346 02               u  40 40  1 233      
;   693         mov [rdx],rax               -- replace it now
                mov [rdx],rax             ;#00440D64: 48:211002                  uv 00 05  1 235    *04*
;   694         add rcx,1                   -- include trailing null in following rep movsb
                add rcx,1                 ;#00440D67: 48:203301 01               vu 02 02  1 235      
;   695         lea rdx,[rax*4+rdi]         -- replacement char location
                lea rdx,[rdi+rax*4]       ;#00440D6B: 48:215024207               uv 04 81  1 236      
;   696         lea rdi,[rbx+rax*4]         -- raw(new)
                lea rdi,[rbx+rax*4]       ;#00440D6F: 48:215074203               vu 80 09  1 236      
;   697         pop rax                     --[1] Replacement char
                pop rax                   ;#00440D73: 48:130                     uv 01 00  1 237      
;   698         rep movsb
                rep movsb                 ;#00440D75: 363:244                    np C2 C2  4 239    *80*
;   699         mov [rdx],al
                mov [edx],al              ;#00440D77: 210002                     uv 00 05  1 243      
;   700         add rsp,8                   --[0]
                add rsp,8                 ;#00440D79: 48:203304 08               vu 10 10  1 243      
;   701         ret
                ret                       ;#00440D7D: 303                        np 00 00  2 244      
;   702 
;   703       ::opRepe1CloneSequence
;   704         -- rsi is src ref, already decrefed, <= #80 (ie jl error rqd)
;   705         -- rdi is idx-1,
;   706         -- rdx contains the original length (ready for AllocSeq)
;   707         -- rax is src base [BLUFF: addr ref]
;   708         -- [rsp] == rcx is rep (already increfd)
;   709         -- [rsp+8] is addr ref
;   710         mov rcx,rdx
                mov rcx,rdx               ;#00440D7E: 48:213312                  uv 02 04  1 246      
;   711         jl :e04atsaa8               -- attempt to subscript an atom (era @ [ebp-8])
                jl #00440AC2              ;#00440D81: 017214 3BFDFFFF            v  00 00  1 246      
;   712         mov rdx,[rsp+16]            -- era
                mov rdx,[rsp+16]          ;#00440D87: 48:213124044 10            uv 04 10  1 247      
;   713         call :%pAllocSeq            -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440D8C: 350 B7130000               v  00 00  1 247      
;   714 --      mov rdx,[rsp+4]             -- [0]
;   715         mov rdx,[rsp+8]             -- [0]
                mov rdx,[rsp+8]           ;#00440D91: 48:213124044 08            uv 04 10  1 248      
;   716         lea rdi,[rax+rdi*2]         -- after shl2 below will effectively be ...
                lea rdi,[rax+rdi*2]       ;#00440D96: 48:215074170               vu 80 81  1 248      
;   717         shl rsi,2                   -- src base
                shl rsi,2                 ;#00440D9A: 48:301346 02               u  40 40  1 249      
;   718         shl rdi,2                   -- rep addr ... [rax*4(new base)+rdi*8(idx->qwords)]
                shl rdi,2                 ;#00440D9E: 48:301347 02               u  80 80  1 250      
;   719         mov [rdx],rax               -- replace it now (WOW! no AGI!)
                mov [rdx],rax             ;#00440DA2: 48:211002                  vu 00 05  1 250      
;   720         mov rdx,rcx
                mov rdx,rcx               ;#00440DA5: 48:213321                  uv 04 02  1 251      
;   721         shl rax,2                   -- new base
                shl rax,2                 ;#00440DA8: 48:301340 02               u  01 01  1 252      
;   722         mov r15,h4
                mov r15,h4                ;#00440DAC: 49:277 0000000000000040    vu 8000 00  1 252      
;   723       @@:
;   724         mov rcx,[rsi]
                mov rcx,[rsi]             ;#00440DB6: 48:213016                  uv 02 40  1 253      
;   725         add rsi,8
                add rsi,8                 ;#00440DB9: 48:203306 08               vu 40 40  1 253      
;   726         mov [rax],rcx
                mov [rax],rcx             ;#00440DBD: 48:211010                  uv 00 03  1 254      
;   727         add rax,8
                add rax,8                 ;#00440DC0: 48:203300 08               vu 01 01  1 254      
;   728         cmp rcx,r15
                cmp rcx,r15               ;#00440DC4: 49:073317                  uv 00 8002  1 255      
;   729         jl :Repe1_no_incref
                jl #00440DCF              ;#00440DC7: 174 06                     v  00 00  1 255      
;   730             -- exception here fatal (mid-clone/back-end error)
;   731             add qword[rbx+rcx*4-16],1
                    add qword[rbx+rcx*4-16],1  ;#00440DC9: 48:203104213 F0 01         u  00 0A  3 256      
;   732       ::Repe1_no_incref
;   733         sub rdx,1
                sub rdx,1                 ;#00440DCF: 48:203352 01               vu 04 04  1 258      
;   734         jnz @b
                jnz #00440DB6             ;#00440DD3: 165 E1                     v  00 00  1 259      
;   735         mov rdx,[rdi]               -- prev s[i]
                mov rdx,[rdi]             ;#00440DD5: 48:213027                  uv 04 80  1 260      
;   736         pop rcx                     -- [1] rep ref (already incref'd)
                pop rcx                   ;#00440DD8: 48:131                     vu 02 00  1 260      
;   737         pop rax                     -- [0] discard
                pop rax                   ;#00440DDA: 48:130                     uv 01 00  1 261      
;   738         mov [rdi],rcx
                mov [rdi],rcx             ;#00440DDC: 48:211017                  vu 00 82  1 261      
;   739         cmp rdx,r15
                cmp rdx,r15               ;#00440DDF: 49:073327                  uv 00 8004  1 262      
;   740         jl @f
                jl #00440DF0              ;#00440DE2: 174 0C                     v  00 00  1 262      
;   741             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#00440DE4: 48:203154223 F0 01         u  00 0C  3 263      
;   742             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#00440DEA: 017204 EA140000            v  00 00  1 265      
;   743       @@:
;   744         ret
                ret                       ;#00440DF0: 303                        np 00 00  2 266      
;   745 
;   746       ::opRepe1CloneExpandStr
;   747         -- rsi is src ref (string), already decrefed
;   748         -- rdi is idx-1,
;   749         -- rdx contains the original length (ready for AllocSeq)
;   750         -- rax is src base [BLUFF: addr ref]
;   751         -- [rsp] == rcx is non-char rep (already increfd)
;   752         -- [rsp+8] is addr ref
;   753 --  opRepe1is110: ---- rejoin point for e110Repe1is [DEV]
;   754         mov rcx,rdx
                mov rcx,rdx               ;#00440DF1: 48:213312                  uv 02 04  1 268      
;   755         mov rdx,[rsp+16]        -- era
                mov rdx,[rsp+16]          ;#00440DF4: 48:213124044 10            vu 04 10  1 268      
;   756         call :%pAllocSeq        -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440DF9: 350 4A130000               v  00 00  1 269      
;   757         mov rdx,[rsp+8]         -- [0]
                mov rdx,[rsp+8]           ;#00440DFE: 48:213124044 08            uv 04 10  1 270      
;   758         lea rdi,[rdi*2+rax]     -- after shl2 below will effectively be ...
                lea rdi,[rax+rdi*2]       ;#00440E03: 48:215074170               vu 80 81  1 270      
;   759         shl rsi,2               -- src base
                shl rsi,2                 ;#00440E07: 48:301346 02               u  40 40  1 271      
;   760         shl rdi,2               -- rep addr ... [rax*4(new base)+rdi*8(idx->qwords)]
                shl rdi,2                 ;#00440E0B: 48:301347 02               u  80 80  1 272      
;   761         mov [rdx],rax           -- replace it now
                mov [rdx],rax             ;#00440E0F: 48:211002                  vu 00 05  1 272      
;   762         mov rdx,rcx
                mov rdx,rcx               ;#00440E12: 48:213321                  uv 04 02  1 273      
;   763         shl rax,2               -- new base
                shl rax,2                 ;#00440E15: 48:301340 02               u  01 01  1 274      
;   764         xor rcx,rcx
                xor rcx,rcx               ;#00440E19: 48:061311                  vu 02 02  1 274      
;   765       @@:
;   766         mov cl,[rsi]
                mov cl,[esi]              ;#00440E1C: 212016                     uv 02 40  1 275      
;   767         add rsi,1
                add rsi,1                 ;#00440E1E: 48:203306 01               vu 40 40  1 275      
;   768         mov [rax],rcx
                mov [rax],rcx             ;#00440E22: 48:211010                  uv 00 03  1 276      
;   769         add rax,8
                add rax,8                 ;#00440E25: 48:203300 08               vu 01 01  1 276      
;   770         sub rdx,1
                sub rdx,1                 ;#00440E29: 48:203352 01               uv 04 04  1 277      
;   771         jnz @b
                jnz #00440E1C             ;#00440E2D: 165 ED                     v  00 00  1 277      
;   772 --      pop qword[rdi]          -- [1] rep
;   773         pop rdx
                pop rdx                   ;#00440E2F: 48:132                     uv 04 00  1 278      
;   774         pop rax                 -- [0] discard
                pop rax                   ;#00440E31: 48:130                     vu 01 00  1 278      
;   775         mov [rdi],rdx
                mov [rdi],rdx             ;#00440E33: 48:211027                  uv 00 84  1 279      
;   776         ret
                ret                       ;#00440E36: 303                        np 00 00  2 280      
;   777     []
;   778 
;   779 --/*
;   780 procedure :%pRepe1ip(:%)
;   781 end procedure -- (for Edita/CtrlQ)
;   782 --*/
;   783     :%pRepe1ip          -- esi[edi]:=ecx, as opRepe1 when esi is sequence of integer, as proved by gvar_scan.
;   784 --------------
;   785     [32]
;   786         --calling convention:
;   787         --  mov edi,[idx]       (opUnassigned)
;   788         --  mov ecx,[rep]       (opUnassigned)
;   789         --  mov esi,[ref]       (opUnassigned)
;   790         --  lea eax,[ref]
;   791         --  call :%pRepe1ip     -- ref[idx]:=rep
;   792         sub edi,1                   -- idx -= 1
;   793 --  mov [rep1ra],eax
;   794         push eax                    --[0] save ref addr
;   795         mov edx,[ebx+esi*4-12]      -- get length
;   796         lea eax,[ebx+esi*4]
;   797         cmp edi,edx                 -- if idx is -ve/float/oob then longhand
;   798         jb @f
;   799             mov al,2+0              -- [era] @ [esp+4] "assigning to"
;   800             call :%fixupIndex       -- idx-1 in edi, len in edx, not idx addr in ebx, al set
;   801             lea eax,[ebx+esi*4]     -- as we just trashed it
;   802       @@:
;   803         cmp dword[ebx+esi*4-8],1    -- if refcount!=1 then clone
;   804         jne :opRepe1ipClone
;   805         add esp,4                   --[0] discard
;   806         mov [eax+edi*4],ecx         -- rep
;   807         ret
;   808 
;   809       ::opRepe1ipClone
;   810         -- esi is src ref (sequence of integer), of refcount >1, (so just decref it)
;   811         -- edi is idx-1,
;   812         -- ecx is rep (an integer)
;   813         -- edx contains the original length (ready for AllocSeq)
;   814         -- eax is the new (non-0) refcount
;   815         -- [esp] is ref addr
;   816         sub dword[ebx+esi*4-8],1    -- reduce refcount (was not 1, dealloc not rqd)
;   817         push ecx                    --[1] save rep
;   818         mov ecx,edx
;   819         mov edx,[esp+8]             -- era
;   820         call :%pAllocSeq            -- damages eax only
;   821         mov edx,[esp+4]             --[0]
;   822         lea edi,[eax+edi]           -- after shl2 below will effectively be ...
;   823         shl esi,2                   -- src base
;   824         shl edi,2                   -- rep addr ... [eax*4(new base)+edi*4(idx->dwords)]
;   825         mov [edx],eax               -- replace it now (WOW! no AGI!)
;   826         shl eax,2                   -- new base
;   827       @@:
;   828         mov edx,[esi]
;   829         add esi,4
;   830         mov [eax],edx
;   831         add eax,4
;   832         sub ecx,1
;   833         jnz @b
;   834         pop dword[edi]              --[1] rep
;   835         add esp,4                   --[0] discard
;   836         ret
;   837     [64]
;   838         --calling convention:
;   839         --  mov rdi,[idx]       (opUnassigned)
;   840         --  mov rcx,[rep]       (opUnassigned)
;   841         --  mov rsi,[ref]       (opUnassigned)
;   842         --  lea rax,[ref]
;   843         --  call :%pRepe1ip     -- ref[idx]:=rep
;   844         sub rdi,1                   -- idx -= 1
                sub rdi,1                 ;#00440E37: 48:203357 01               uv 80 80  1 282      
;   845         push rax                    --[0] save ref addr
                push rax                  ;#00440E3B: 48:120                     vu 00 01  1 282      
;   846         mov rdx,[rbx+rsi*4-24]      -- get length
                mov rdx,[rbx+rsi*4-24]    ;#00440E3D: 48:213124263 E8            uv 04 48  1 283      
;   847         lea rax,[rbx+rsi*4]
                lea rax,[rbx+rsi*4]       ;#00440E42: 48:215004263               vu 01 48  1 283      
;   848         cmp rdi,rdx                 -- if idx is -ve/float/oob then longhand
                cmp rdi,rdx               ;#00440E46: 48:071327                  uv 00 84  1 284      
;   849         jb @f
                jb #00440E56              ;#00440E49: 162 0B                     v  00 00  1 284      
;   850             mov al,2+0              -- [era] @ [esp+4] "assigning to"
                    mov al,2              ;#00440E4B: 260 02                     uv 01 00  1 285      
;   851             call :%fixupIndex       -- idx-1 in edi, len in edx, not idx addr in ebx, al set
                    call #0044144B (:%fixupIndex)  ;#00440E4D: 350 F9050000               v  00 00  1 285      
;   852             lea rax,[rbx+rsi*4]     -- as we just trashed it
                    lea rax,[rbx+rsi*4]   ;#00440E52: 48:215004263               uv 01 48  1 286      
;   853       @@:
;   854         cmp qword[rbx+rsi*4-16],1   -- if refcount!=1 then clone
                cmp qword[rbx+rsi*4-16],1  ;#00440E56: 48:203174263 F0 01         u  00 48  2 287      
;   855         jne :opRepe1ipClone
                jne #00440E67             ;#00440E5C: 165 09                     v  00 00  1 288      
;   856         add rsp,8                   --[0] discard
                add rsp,8                 ;#00440E5E: 48:203304 08               uv 10 10  1 289      
;   857 --8/7/15:
;   858 --      mov [rax+rdi*8],ecx         -- rep
;   859         mov [rax+rdi*8],rcx         -- rep
                mov [rax+rdi*8],rcx       ;#00440E62: 48:211014370               vu 00 83  1 289      
;   860         ret
                ret                       ;#00440E66: 303                        np 00 00  2 290      
;   861 
;   862       ::opRepe1ipClone
;   863         -- rsi is src ref (sequence of integer), of refcount >1, (so just decref it)
;   864         -- rdi is idx-1,
;   865         -- rcx is rep (an integer)
;   866         -- rdx contains the original length (ready for AllocSeq)
;   867         -- rax is the new (non-0) refcount
;   868         -- [rsp] is ref addr
;   869         sub qword[rbx+rsi*4-16],1   -- reduce refcount (was not 1, dealloc not rqd)
                sub qword[rbx+rsi*4-16],1  ;#00440E67: 48:203154263 F0 01         u  00 48  3 292      
;   870         push rcx                    --[1] save rep
                push rcx                  ;#00440E6D: 48:121                     vu 00 02  1 294      
;   871         mov rcx,rdx
                mov rcx,rdx               ;#00440E6F: 48:213312                  uv 02 04  1 295      
;   872         mov rdx,[rsp+16]            -- era
                mov rdx,[rsp+16]          ;#00440E72: 48:213124044 10            vu 04 10  1 295      
;   873         call :%pAllocSeq            -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440E77: 350 CC120000               v  00 00  1 296      
;   874         mov rdx,[rsp+8]             --[0]
                mov rdx,[rsp+8]           ;#00440E7C: 48:213124044 08            uv 04 10  1 297      
;   875         lea rdi,[rax+rdi*2]         -- after shl2 below will effectively be ...
                lea rdi,[rax+rdi*2]       ;#00440E81: 48:215074170               vu 80 81  1 297      
;   876         shl rsi,2                   -- src base
                shl rsi,2                 ;#00440E85: 48:301346 02               u  40 40  1 298      
;   877         shl rdi,2                   -- rep addr ... [eax*4(new base)+edi*8(idx->qwords)]
                shl rdi,2                 ;#00440E89: 48:301347 02               u  80 80  1 299      
;   878         mov [rdx],rax               -- replace it now (WOW! no AGI!)
                mov [rdx],rax             ;#00440E8D: 48:211002                  vu 00 05  1 299      
;   879         shl rax,2                   -- new base
                shl rax,2                 ;#00440E90: 48:301340 02               u  01 01  1 300      
;   880       @@:
;   881             mov rdx,[rsi]
                    mov rdx,[rsi]         ;#00440E94: 48:213026                  vu 04 40  1 300      
;   882             add rsi,8
                    add rsi,8             ;#00440E97: 48:203306 08               uv 40 40  1 301      
;   883             mov [rax],rdx
                    mov [rax],rdx         ;#00440E9B: 48:211020                  uv 00 05  1 303    *01*
;   884             add rax,8
                    add rax,8             ;#00440E9E: 48:203300 08               vu 01 01  1 303      
;   885             sub rcx,1
                    sub rcx,1             ;#00440EA2: 48:203351 01               uv 02 02  1 304      
;   886             jnz @b
                    jnz #00440E94         ;#00440EA6: 165 EC                     v  00 00  1 304      
;   887 --      pop qword[rdi]              --[1] rep
;   888         pop eax
                pop rax                   ;#00440EA8: 130                        uv 01 00  1 305      
;   889         add rsp,8                   --[0] discard
                add rsp,8                 ;#00440EA9: 48:203304 08               vu 10 10  1 305      
;   890         mov [rdi],rax
                mov [rdi],rax             ;#00440EAD: 48:211007                  uv 00 81  1 306      
;   891         ret
                ret                       ;#00440EB0: 303                        np 00 00  2 307      
;   892     []
;   893 
;   894 --/*
;   895 procedure :%pRepe1is(:%)
;   896 end procedure -- (for Edita/CtrlQ)
;   897 --*/
;   898     :%pRepe1is          -- esi[edi]:=ecx, as opRepe1 when esi is string, as proved by gvar_scan.
;   899 --------------          --  (no expand, no dealloc, also has builtin typecheck)
;   900     [32]
;   901         --calling convention:
;   902         --  mov edi,[idx]       (opUnassigned)
;   903         --  mov ecx,[rep]       (opUnassigned) [must be char-sized]
;   904         --  mov esi,[ref]       (opUnassigned) [must be string]
;   905         --  lea eax,[ref]
;   906         --  call :%pRepe1is     -- ref[idx]:=rep, aka esi[edi]:=cl
;   907         sub edi,1                   -- idx -= 1
;   908         mov edx,[ebx+esi*4-12]      -- get length
;   909         cmp edi,edx                 -- if idx is -ve/float/oob then longhand
;   910         jb @f
;   911             push eax
;   912             mov al,4+0              -- [era] @ [esp+8] "assigning to"
;   913             call :%fixupIndex       -- idx-1 in edi, len in edx, not idx addr in ebx, al set
;   914             pop eax
;   915       @@:
;   916         cmp ecx,255
;   917         ja :e110Repe1is             -- type check error
;   918         cmp dword[ebx+esi*4-8],1    -- if refcount!=1 then clone
;   919         jne :opRepe1isClone
;   920         mov [esi*4+edi],cl
;   921         ret
;   922 
;   923       ::opRepe1isClone
;   924         -- esi is src ref (string), of refcount >1, (so just decref it)
;   925         -- edi is idx-1,
;   926         -- ecx is rep (an integer char)
;   927         -- edx contains the original length
;   928         -- eax is the new (non-0) refcount
;   929         sub dword[ebx+esi*4-8],1    -- reduce refcount (non-0, dealloc not rqd)
;   930         push ecx                    --[1] save rep
;   931         mov ecx,edx
;   932         mov edx,eax
;   933         call :%pAllocStr            -- damages eax only
;   934         lea esi,[ebx+esi*4]
;   935 --DEV would    shl esi,2    be any better?
;   936         mov [edx],eax               -- replace it now
;   937         add ecx,1                   -- include trailing null in following rep movsb
;   938         lea edx,[eax*4+edi]         -- replacement char location
;   939         lea edi,[ebx+eax*4]         -- raw(new)
;   940         pop eax                     --[1] Replacement char
;   941         rep movsb
;   942         mov [edx],al
;   943         ret
;   944 
;   945     [64]
;   946         --calling convention:
;   947         --  mov rdi,[idx]       (opUnassigned)
;   948         --  mov rcx,[rep]       (opUnassigned) [must be char-sized]
;   949         --  mov rsi,[ref]       (opUnassigned) [must be string]
;   950         --  lea rax,[ref]
;   951         --  call :%pRepe1is     -- ref[idx]:=rep, aka rsi[rdi]:=cl
;   952         sub rdi,1                   -- idx -= 1
                sub rdi,1                 ;#00440EB1: 48:203357 01               uv 80 80  1 309      
;   953         mov rdx,[rbx+rsi*4-24]      -- get length
                mov rdx,[rbx+rsi*4-24]    ;#00440EB5: 48:213124263 E8            vu 04 48  1 309      
;   954         cmp rdi,rdx                 -- if idx is -ve/float/oob then longhand
                cmp rdi,rdx               ;#00440EBA: 48:071327                  uv 00 84  1 310      
;   955         jb @f
                jb #00440ECA              ;#00440EBD: 162 0B                     v  00 00  1 310      
;   956             push rax
                    push rax              ;#00440EBF: 48:120                     uv 00 01  1 311      
;   957             mov al,4+0              -- [era] @ [esp+8] "assigning to"
                    mov al,4              ;#00440EC1: 260 04                     vu 01 00  1 311      
;   958             call :%fixupIndex       -- idx-1 in edi, len in edx, not idx addr in ebx, al set
                    call #0044144B (:%fixupIndex)  ;#00440EC3: 350 83050000               v  00 00  1 312      
;   959             pop rax
                    pop rax               ;#00440EC8: 48:130                     uv 01 00  1 313      
;   960       @@:
;   961         cmp rcx,255
                cmp rcx,255               ;#00440ECA: 48:201371 FF000000         vu 00 02  1 313      
;   962         ja :e110Repe1is             -- type check error
                ja #00440AC5              ;#00440ED1: 017207 EEFBFFFF            v  00 00  1 314      
;   963         cmp qword[rbx+rsi*4-16],1   -- if refcount!=1 then clone
                cmp qword[rbx+rsi*4-16],1  ;#00440ED7: 48:203174263 F0 01         u  00 48  2 315      
;   964         jne :opRepe1isClone
                jne #00440EE3             ;#00440EDD: 165 04                     v  00 00  1 316      
;   965         mov [rsi*4+rdi],cl
                mov [rdi+rsi*4],cl        ;#00440EDF: 210014267                  uv 00 C2  1 317      
;   966         ret
                ret                       ;#00440EE2: 303                        np 00 00  2 318      
;   967 
;   968       ::opRepe1isClone
;   969         -- rsi is src ref (string), of refcount >1, (so just decref it)
;   970         -- rdi is idx-1,
;   971         -- rcx is rep (an integer char)
;   972         -- rdx contains the original length
;   973         -- rax is the new (non-0) refcount
;   974         sub qword[rbx+rsi*4-16],1   -- reduce refcount (non-0, dealloc not rqd)
                sub qword[rbx+rsi*4-16],1  ;#00440EE3: 48:203154263 F0 01         u  00 48  3 320      
;   975         push rcx                    --[1] save rep
                push rcx                  ;#00440EE9: 48:121                     vu 00 02  1 322      
;   976         mov rcx,rdx
                mov rcx,rdx               ;#00440EEB: 48:213312                  uv 02 04  1 323      
;   977         mov rdx,rax
                mov rdx,rax               ;#00440EEE: 48:213320                  vu 04 01  1 323      
;   978         call :%pAllocStr            -- damages rax only
                call #004420E3 (:%pAllocStr)  ;#00440EF1: 350 ED110000               v  00 00  1 324      
;   979         lea rsi,[rbx+rsi*4]
                lea rsi,[rbx+rsi*4]       ;#00440EF6: 48:215064263               uv 40 48  1 325      
;   980         mov [rdx],rax               -- replace it now
                mov [rdx],rax             ;#00440EFA: 48:211002                  uv 00 05  1 327    *04*
;   981         add rcx,1                   -- include trailing null in following rep movsb
                add rcx,1                 ;#00440EFD: 48:203301 01               vu 02 02  1 327      
;   982         lea rdx,[rax*4+rdi]         -- replacement char location
                lea rdx,[rdi+rax*4]       ;#00440F01: 48:215024207               uv 04 81  1 328      
;   983         lea rdi,[rbx+rax*4]         -- raw(new)
                lea rdi,[rbx+rax*4]       ;#00440F05: 48:215074203               vu 80 09  1 328      
;   984         pop rax                     --[1] Replacement char
                pop rax                   ;#00440F09: 48:130                     uv 01 00  1 329      
;   985         rep movsb
                rep movsb                 ;#00440F0B: 363:244                    np C2 C2  4 331    *80*
;   986         mov [rdx],al
                mov [edx],al              ;#00440F0D: 210002                     uv 00 05  1 335      
;   987         ret
                ret                       ;#00440F0F: 303                        np 00 00  2 336      
;   988     []
;   989       }
;   990 
    jmp #0044298D (:%opRetf)              ;#00440F10: 351 781A0000               v  00 00  1 338      
;C:\Program Files (x86)\Phix\builtins\VM\pRepsN.e:
;=================================================
;     1 --
;     2 -- pRepsN.e
;     3 -- ========
;     4 --
;     5 --  The replace slice routine:
;     6 --
;     7 --      :%pReps             -- [eax][idx1]..[idxN..sliceend]:=rep
;     8 --
;     9 -- (There may be a case for some optimised forms, especially string[slicestart..sliceend]:=string and
;    10 --  possibly string[slicestart..sliceend]:=char, but I stongly doubt that pReps1 (similar to pRepe1)
;    11 --  would deliver any measurable gain, but /would/ be a significant size and maintenance overhead.
;    12 --  The first step would be to plant puts(1,"xxx") statements in pilx86.e to show when/if it can use
;    13 --  a new pRepss/pRepsch, before bothering to write them.)
;    14 --
;    15 -- Technical note:
;    16 --  This is perhaps the most complex/ctritical part of the VM (well, it is either this or pHeap.e).
;    17 --  It, alone, implements variable length slice assignment (eg "food"[2..3]:="e" -> "fed") as well
;    18 --  as over half (rest in pRepeN.e) of the auto-expansion of strings to dword-sequences. I should
;    19 --  note that it is extremely easy to study this for 10 minutes and then gleefully modify completely
;    20 --  the wrong block of code, or at least that has been my sad and sorry experience with it. ;-)
;    21 --  Throughout this source I have liberally scattered "current state of registers and stack" comments,
;    22 --  (5 registers and 7 stack entries) because without them this code would be absolutely impossible 
;    23 --  to write/maintain. However, they are extremely difficult to keep up to date, not least because it
;    24 --  is the same thing over and over again, but with ever-so-subtle differences, and should always be 
;    25 --  treated with deep suspicion. They are most useful not when reading the source, but when single-
;    26 --  stepping though the instructions in OllyDbg or similar. Please fix any slip-ups that you spot.
;    27 --
;    28 -- TODO:
;    29 --  check/add tests (t24slice) for eg 'x[1][2.2..5.9] = expr' giving the same results as 'x[1][2..5] = expr'.
;    30 --  lots of tests in terror
;    31 
;    32 include builtins\VM\pHeap.e     -- :%pDealloc, :%pAllocStr, :%pAllocSeq
;    33 
;    34 include builtins\VM\pFixup.e    -- negative and floating point index handling (:%fixupIndex)
;    35 
;    36 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0044050D: 351 7B240000               v  00 00  1   1      
;    37 
;    38 --DEV FIXME: (and the :!bang labels below)
;    39     ::e04atsaam4
;    40 --          lea esp,[esp+ecx*4-4]
;    41         [32]
;    42             mov esi,[esp+ecx*4-4]   -- era
;    43         [64]
;    44             mov rsi,[rsp+rcx*8-8]   -- era (DEV untested!)
                    mov rsi,[rsp+rcx*8-8]  ;#00440512: 48:213164314 F8            uv 40 12  1   2      
;    45         []
;    46             mov al,4
                    mov al,4              ;#00440517: 260 04                     vu 01 00  1   2      
;    47 --          jmp :!iDiag
;    48             int3
                    int3                  ;#00440519: 314                        np 00 00 13   3      
;    49 --  ::e04atsaa4
;    50 --          int3
;    51     ::e04atsaa9
;    52         [32]
;    53             mov esi,[esp+ecx*4+4]   -- era
;    54         [64]
;    55             mov rsi,[rsp+rcx*8+8]   -- era (DEV untested!)
                    mov rsi,[rsp+rcx*8+8]  ;#0044051A: 48:213164314 08            uv 40 12  1  16      
;    56         []
;    57             mov al,4
                    mov al,4              ;#0044051F: 260 04                     vu 01 00  1  16      
;    58 --          jmp :!iDiag
;    59             int3
                    int3                  ;#00440521: 314                        np 00 00 13  17      
;    60     ::e09slinespp4
;    61             int3
                    int3                  ;#00440522: 314                        np 00 00 13  30      
;    62     ::e04atsaa24
;    63             int3
                    int3                  ;#00440523: 314                        np 00 00 13  43      
;    64 --/*
;    65 procedure :%pReps(:%)
;    66 end procedure -- (for Edita/CtrlQ)
;    67 --*/
;    68     :%pReps         -- [eax][idx1]..[idxN..sliceend]:=rep
;    69 -----------
;    70     [32]
;    71         --calling convention:
;    72         --  mov ecx,N
;    73         --  push <return address>
;    74         --  push [rep]          -- replacement (opUnassigned)
;    75         --  push [sliceend]     -- sliceend (opUnassigned)
;    76         --  push [idxN]..[idx1] -- (opUnassigned)
;    77         --  lea eax,[ref]       -- ref addr
;    78         --  jmp opReps          -- actually a call
;    79         --<return address>
;    80 
;    81       ::opRepsRnxt
;    82         mov esi,[eax]
;    83         pop edi                 -- next idx (ref)
;    84         cmp esi,h4
;    85         jl :e04atsaam4          -- attempt to subscript an atom, era @ [esp+ecx*4-4]?
;    86         push eax                --[1] ref addr, in case we need to clone...
;    87         mov al,[ebx+esi*4-1]
;    88         sub edi,1
;    89         mov edx,[ebx+esi*4-12]  -- length
;    90         shl esi,2
;    91 
;    92         sub ecx,1
;    93         je :opRepsMain          -- deal with final slice separately
;    94         cmp al,0x80
;    95         jne :e04atsaa9          -- must be seq since another idx (or the slice) follows, era * [esp+ecx*4+4]?
;    96 
;    97         cmp edi,edx
;    98         jb @f                   -- unsigned jump, lets 0..len-1 through
;    99                                 --               (we just did a dec edi)
;   100 --DEV +8..
;   101             mov al,8+4+0        -- [era] @ [esp+ecx*4+4], "assigning to"
;   102             call :%fixupIndex   -- idx-1 in edi, len in edx, al set
;   103       @@:
;   104         --
;   105         -- edi now contains index to replace, and edx the length
;   106         --   
;   107         mov eax,[esi-8]         -- refcount
;   108         sub eax,1
;   109         jz :opRepsSeqNoClone
;   110         mov [esi-8],eax         -- non-1 so no need to dealloc
;   111         mov eax,[esp+ecx*4+4]   -- era
;   112         push ecx                --[2] no of remainding indexes
;   113         push edi                --[3] idx
;   114         mov ecx,edx
;   115         mov edi,[esp+8]         --[1] (ref addr, leaving it on the stack)
;   116         mov edx,eax             -- era
;   117         call :%pAllocSeq        -- damages eax only
;   118         mov [edi],eax           -- Replace ref at original address [no dealloc rqd]
;   119         lea edi,[ebx+eax*4]
;   120         push edi                --[4]
;   121       @@:
;   122             lodsd               -- mov eax,[esi], esi+=4
;   123             stosd               -- mov [edi],eax, edi+=4
;   124             cmp eax,h4
;   125             jl :opReps_no_incref
;   126                 add dword[ebx+eax*4-8],1
;   127           ::opReps_no_incref
;   128 
;   129             sub ecx,1
;   130             jnz @b
;   131 
;   132         pop esi                 --[4] NB esi:=edi
;   133         pop edi                 --[3] idx
;   134         pop ecx                 --[2] no of remaining indexes
;   135       ::opRepsSeqNoClone
;   136         add esp,4               --[1] discard ref addr
;   137         lea eax,[esi+edi*4]
;   138         jmp :opRepsRnxt
;   139 
;   140       ::opRepsMain
;   141 ------------------
;   142         -- al type byte
;   143         -- ecx 0
;   144         -- edx length ref
;   145         -- esi raw ref
;   146         -- edi slice start (-1, pre fixup)
;   147         -- stack contents:
;   148         --  [esp]   ref addr (after several subcripts)
;   149         --  [esp+4] slice end (pre fixup)
;   150         --  [esp+8] rep ref
;   151         --  [esp+12] <return address>
;   152         test al,0x80
;   153 --      jz :e04atsaa4
;   154         jnz @f
;   155             mov edx,[esp+12]
;   156             mov al,4    -- e04atasaa
;   157             sub edx,1
;   158             jmp :!iDiag
;   159             int3
;   160       @@:
;   161         cmp edi,edx
;   162         jbe @f                  -- unsigned jump, lets 0..len through (NB jbe here)
;   163                                 --               (we just did a dec edi)
;   164                                 --               (slice start can be 1..length+1)
;   165 --DEV +12
;   166             mov cl,8                -- [era] @ [esp+8]
;   167             call :%fixupSliceStart  -- idx in edi, len in edx
;   168       @@:
;   169         push edi                -- save slice start (0-based)
;   170         mov edi,[esp+8]         -- slice end
;   171         cmp edi,edx
;   172         jbe @f                  -- unsigned jump, lets 0..len through (NB jbe here, and no dec edi)
;   173                                 --               (slice end can be 0..length)
;   174 --DEV 16
;   175 --          mov cl,12               -- [era] @ [esp+12]
;   176             mov cl,20               -- [era] @ [esp+20]
;   177             call :%fixupSliceEnd    -- idx in edi, len in edx, idx addr in ebx
;   178             mov [esp+8],edi         -- save normalised slice end (1-based)
;   179       @@:
;   180         mov ecx,edi
;   181         sub ecx,[esp]
;   182         jl :e09slinespp4        -- slice length is negative (%d..%d)
;   183         push ecx                -- save slice length
;   184         push edx                -- save source (ref) length
;   185         mov edi,[esp+20]        -- rep ref
;   186         --
;   187         --  al: type byte ([esi-1])
;   188         --  ecx: slice length [also in esp+4]
;   189         --  edx: ref length [also in esp]
;   190         --  edi: rep ref
;   191         --  esi: raw(ref)
;   192         --  [esp] ref length
;   193         --  [esp+4] slice length
;   194         --  [esp+8] slice start (0-based)
;   195         --  [esp+12] ref addr
;   196         --  [esp+16] slice end (1-based)
;   197         --  [esp+20] rep ref
;   198         --  [esp+24] return addr
;   199         --
;   200         -- handle sequence and string slices separately...
;   201         --
;   202         cmp al,0x80
;   203         jne :opRepsStr
;   204             --
;   205             -- check for insitu replacement
;   206             --
;   207             cmp dword[esi-8],1
;   208             jne :opRepsSeqMultiRef
;   209             --
;   210             -- which is ok for atoms...
;   211             --
;   212             cmp edi,h4
;   213             jl @f
;   214                 lea eax,[ebx+edi*4]
;   215                 test byte[ebx+edi*4-1],0x80
;   216                 jnz :opRepsSeqSeq
;   217                 add dword[ebx+edi*4-8],ecx  -- bulk ref update (float)
;   218           @@:                       -- replacement is an atom
;   219             mov edx,[esp+8]         -- slice start
;   220             cmp ecx,0               -- check for zero length slice replacement
;   221             je :opRepsPop6          -- do nothing case
;   222             mov eax,edi
;   223 --          lea edi,[esi+edx*4-4]
;   224             lea edi,[esi+edx*4]
;   225           ::opRepsSeqAtomLoop
;   226             mov edx,[edi]
;   227             cmp edx,h4
;   228             jle @f
;   229                 sub dword[ebx+edx*4-8],1
;   230                 jnz @f
;   231                     pushad
;   232 --                if debugmem2
;   233 --                  mov eax,[esp+52]    -- (untested!)
;   234 --                  mov [dmFera],eax
;   235 --                end if
;   236                     push dword[esp+56]
;   237                     call :%pDealloc0
;   238                     popad
;   239           @@:
;   240             stosd                   -- mov [edi],eax, edi+=4
;   241             sub ecx,1
;   242             jnz :opRepsSeqAtomLoop
;   243 
;   244       ::opRepsPop6
;   245 ------------------
;   246             add esp,24
;   247             ret
;   248 
;   249       ::opRepsSeqSeq
;   250 --------------------
;   251             --
;   252             -- .. and sequences of the same length
;   253             --
;   254             cmp dword[eax-12],ecx
;   255             jne :opRepsSeqMRSeqStr
;   256             cmp ecx,0
;   257             je :opRepsPop6          -- eg x[2..1]={}/"", do nothing case
;   258             --
;   259             --  eax: raw(edi)
;   260             --  ecx: slice length [also in esp+4] (!=0)
;   261             --  edx: ref length [also in esp]
;   262             --  edi: rep ref (a sequence/string of length ecx)
;   263             --  esi: raw(ref) (a dword-sequence)
;   264             --  [esp] ref length
;   265             --  [esp+4] slice length
;   266             --  [esp+8] slice start (0-based)
;   267             --  [esp+12] ref addr
;   268             --  [esp+16] slice end (1-based)
;   269             --  [esp+20] rep ref
;   270             --  [esp+24] return addr
;   271             --
;   272             mov edx,[esp+8]             -- slice start
;   273             mov edi,esi                 -- raw(ref)
;   274             mov esi,eax                 -- raw(rep)
;   275             cmp byte[eax-1],0x80
;   276 --5/2/15:
;   277 --          lea edi,[edi+edx*4-4]       -- addr ref[slice start]
;   278             lea edi,[edi+edx*4]         -- addr ref[slice start]
;   279             jne :opRepsSeqStr
;   280           ::opRepsSeqSeqLoop
;   281                 lodsd                       -- mov eax,[esi], esi+=4
;   282                 cmp eax,h4
;   283                 jl @f
;   284                     add dword[ebx+eax*4-8],1
;   285               @@:
;   286                 mov edx,[edi]
;   287                 cmp edx,h4
;   288                 jle @f
;   289                     sub dword[ebx+edx*4-8],1
;   290                     jnz @f
;   291                         pushad
;   292 --                    if debugmem2
;   293 --                      mov eax,[esp+52]    -- as above
;   294 --                      mov [dmFera],eax
;   295 --                    end if
;   296                         push dword[esp+56]
;   297                         call :%pDealloc0
;   298                         popad
;   299               @@:
;   300                 stosd                   -- mov [edi],eax, edi+=4
;   301                 sub ecx,1
;   302                 jnz :opRepsSeqSeqLoop
;   303             jmp :opRepsPop6
;   304 
;   305       ::opRepsSeqStr
;   306 --------------------
;   307             --
;   308             --  eax: raw(edi)
;   309             --  ecx: slice length [also in esp+4] (!=0)
;   310             --  edx: slice start [also in esp+8]
;   311             --  edi: addr ref[slice start]
;   312             --  esi: raw(rep) (a dword-sequence)
;   313             --  [esp] ref length
;   314             --  [esp+4] slice length
;   315             --  [esp+8] slice start (0-based)
;   316             --  [esp+12] ref addr
;   317             --  [esp+16] slice end (1-based)
;   318             --  [esp+20] rep ref
;   319             --  [esp+24] return addr
;   320             --
;   321             xor eax,eax
;   322           ::opRepsSeqStrLoop
;   323                 mov edx,[edi]
;   324                 lodsb                   -- mov al,[esi], esi+=1
;   325                 cmp edx,h4
;   326                 jle @f
;   327                     sub dword[ebx+edx*4-8],1
;   328                     jnz @f
;   329                         pushad
;   330 --                    if debugmem2
;   331 --                      mov eax,[esp+52]    -- as above*2
;   332 --                      mov [dmFera],eax
;   333 --                    end if
;   334                         push dword[esp+56]
;   335                         call :%pDealloc0
;   336                         popad
;   337               @@:
;   338                 stosd                   -- mov [edi],eax, edi+=4
;   339                 sub ecx,1
;   340                 jnz :opRepsSeqStrLoop
;   341 
;   342 --          jmp :opRepsPop6
;   343             add esp,24
;   344             ret
;   345 
;   346       ::opRepsSeqMultiRef
;   347 -------------------------
;   348             --
;   349             --  al: type byte ([esi-1])
;   350             --  ecx: slice length [also in esp+4]
;   351             --  edx: ref length [also in esp]
;   352             --  edi: rep ref [also in esp+20]
;   353             --  esi: raw(ref) (dword_sequence, refcount>1)
;   354             --  [esp] ref length
;   355             --  [esp+4] slice length
;   356             --  [esp+8] slice start (0-based)
;   357             --  [esp+12] ref addr
;   358             --  [esp+16] slice end (1-based)
;   359             --  [esp+20] rep ref
;   360             --  [esp+24] return addr
;   361             --
;   362             --
;   363             -- ok, how big does this thing have to be?
;   364             --
;   365             -- In the case of an atom, same as source...
;   366             --
;   367             cmp edi,h4
;   368             jl @f
;   369                 lea eax,[ebx+edi*4]
;   370                 test byte[ebx+edi*4-1],0x80
;   371                 jnz :opRepsSeqMRSeqStr
;   372                 add dword[ebx+edi*4-8],ecx    -- bulk ref update (float)
;   373           @@:                       -- replacement is an atom
;   374             cmp ecx,0               -- check for zero length slice replacement
;   375             je :opRepsPop6          -- do nothing case
;   376             mov ecx,edx
;   377             mov edx,[esp+24]        -- era
;   378             mov edi,[esp+12]        -- addr ref
;   379             call :%pAllocSeq        -- damages eax only
;   380             mov [edi],eax           -- Replace the ref at the original address
;   381             sub dword[esi-8],1      -- non-1 so no need to dealloc
;   382             lea edi,[ebx+eax*4]
;   383             --
;   384             -- duplicate original items before the slice
;   385             --
;   386 --          mov ecx,[esp+12]                -- slice start
;   387             mov ecx,[esp+8]         -- slice start (0-based)
;   388 --          sub ecx,1
;   389             test ecx,ecx
;   390             jz :opRepsSeqMRAmid
;   391           ::opRepsSeqMRAtomBeforeLoop
;   392                 lodsd                           -- mov eax,[esi], esi+=4
;   393                 stosd                           -- mov [edi],eax, edi+=4
;   394                 cmp eax,h4
;   395                 jl @f
;   396                     add dword[ebx+eax*4-8],1    -- exception should never happen (we are cloning)
;   397               @@:
;   398                 sub ecx,1
;   399                 jnz :opRepsSeqMRAtomBeforeLoop
;   400 
;   401             --
;   402             -- blat slice area with atom
;   403             --
;   404           ::opRepsSeqMRAmid
;   405 ---------------------------
;   406             mov eax,[esp+20]        -- rep ref 
;   407             mov ecx,[esp+4]         -- slice len
;   408             rep stosd
;   409             --
;   410             -- duplicate remaining original items
;   411             --
;   412             mov ecx,[esp]           -- original source ref length
;   413 --erm 17/11/14:
;   414 --          mov eax,[esp+8]         -- slice end
;   415             mov eax,[esp+16]        -- slice end
;   416             sub ecx,eax
;   417             jz :opRepsPop6
;   418             mov eax,[esp+4]         -- slice length
;   419             lea esi,[esi+eax*4-4]
;   420           ::opRepsSeqMRAtomAfterLoop
;   421                 lodsd                       -- mov eax,[esi], esi+=4
;   422                 stosd                       -- mov [edi],eax, edi+=4
;   423                 cmp eax,h4
;   424                 jl @f
;   425                     add dword[ebx+eax*4-8],1            -- exception should never happen (we are cloning)
;   426               @@:
;   427                 sub ecx,1
;   428                 jnz :opRepsSeqMRAtomAfterLoop
;   429 --          jmp :opRepsPop6
;   430             add esp,24
;   431             ret
;   432 
;   433       ::opRepsSeqMRSeqStr
;   434 -------------------------
;   435             --
;   436             --  eax: raw(edi)
;   437             --  ecx: slice length [also in esp+4]
;   438             --  edx: ref length [also in esp]
;   439             --  edi: rep ref (a sequence/string) [also in esp+20]
;   440             --  esi: raw(ref) (a dword-sequence)
;   441             --  [esp] ref length
;   442             --  [esp+4] slice length
;   443             --  [esp+8] slice start (0-based)
;   444             --  [esp+12] ref addr (becomes original ref rsn)
;   445             --  [esp+16] slice end (1-based)
;   446             --  [esp+20] rep ref (becomes ref[sliceend+1] rsn)
;   447             --  [esp+24] return addr
;   448             --
;   449             --
;   450             -- .. in the case of a string/sequence rep, the required length is:
;   451             --
;   452             sub edx,ecx                 -- original length-slicelength
;   453             mov ecx,dword[eax-12]       -- replacement length
;   454             add ecx,edx
;   455 --          mov edx,[esp+12]            -- addr ref
;   456             mov edi,[esp+12]            -- addr ref
;   457             mov edx,[esp+24]            -- era
;   458             call :%pAllocSeq            -- damages eax only
;   459 --          mov edi,[edx]               -- original ref
;   460             mov edx,[edi]               -- original ref
;   461             mov ecx,[esp+8]             -- slice start (0-based)
;   462 --          mov [esp+12],edi            -- decref/dealloc at end (opRepsPop6da)
;   463             mov [esp+12],edx            -- decref/dealloc at end (opRepsPop6da)
;   464 --          mov [edx],eax               -- Replace the ref at the original address
;   465             mov [edi],eax               -- Replace the ref at the original address
;   466 
;   467             lea edi,[ebx+eax*4]
;   468             mov edx,[esp+4]             -- slice length (for opRepsSeqMRSmid)
;   469             --
;   470             -- duplicate original items before the slice
;   471             --
;   472 --          sub ecx,1
;   473             test ecx,ecx
;   474             jz opRepsSeqMRSmid
;   475           ::opRepsSeqMRSeqBeforeLoop
;   476                 lodsd                   -- mov eax,[esi], esi+=4
;   477                 stosd                   -- mov [edi],eax, edi+=4
;   478                 cmp eax,h4
;   479                 jl @f
;   480                     add dword[ebx+eax*4-8],1    -- exception should never happen (we are cloning)
;   481               @@:
;   482                 sub ecx,1
;   483                 jnz :opRepsSeqMRSeqBeforeLoop
;   484 
;   485             --
;   486             -- slice area is either from sequence or string...
;   487             --
;   488           ::opRepsSeqMRSmid
;   489 ---------------------------
;   490             lea ecx,[esi+edx*4]         -- ref[end slice+1]
;   491             mov esi,[esp+20]            -- rep ref
;   492             mov [esp+20],ecx            -- ref[end slice+1]
;   493             shl esi,2
;   494             mov ecx,[esi-12]            -- rep length
;   495             cmp ecx,0
;   496             je :opRepsSeqMRmidDone
;   497             cmp byte[esi-1],0x80
;   498             jne :opRepsSeqMRmidStr
;   499             -- copy seq elements one by one into middle of new sequence
;   500           ::opRepsSeqMRSeqLoop
;   501                 lodsd                   -- mov eax,[esi], esi+=4
;   502                 stosd                   -- mov [edi],eax, edi+=4
;   503                 cmp eax,h4
;   504                 jl @f
;   505                     add dword[ebx+eax*4-8],1    -- exception should never happen (we are cloning)
;   506               @@:
;   507                 sub ecx,1
;   508                 jnz :opRepsSeqMRSeqLoop
;   509             nop
;   510             jmp :opRepsSeqMRmidDone
;   511 
;   512           ::opRepsSeqMRmidStr
;   513 -----------------------------
;   514             -- copy string chars one by one into middle of new sequence
;   515             xor eax,eax
;   516           @@:
;   517                 lodsb                   -- mov al,[esi], esi+=1
;   518                 stosd                   -- mov [edi],eax, edi+=4
;   519                 sub ecx,1
;   520                 jnz @b
;   521 
;   522           ::opRepsSeqMRmidDone
;   523 ------------------------------
;   524             --
;   525             -- duplicate remaining original items
;   526             --
;   527             mov ecx,[esp]               -- original source ref length
;   528             mov eax,[esp+16]            -- slice end
;   529             sub ecx,eax
;   530             jz :opRepsPop6da
;   531             mov esi,[esp+20]            -- ref[sliceend+1]
;   532           ::opRepsSeqMRSeqAfterLoop
;   533                 lodsd                   -- mov eax,[esi], esi+=4
;   534                 stosd                   -- mov [edi],eax, edi+=4
;   535                 cmp eax,h4
;   536                 jl @f
;   537                     add dword[ebx+eax*4-8],1    -- exception should never happen (we are cloning)
;   538               @@:
;   539                 sub ecx,1
;   540                 jnz :opRepsSeqMRSeqAfterLoop
;   541 
;   542           ::opRepsPop6da
;   543 ------------------------
;   544             mov edx,[esp+12]        -- original ref
;   545             add esp,24
;   546             cmp edx,h4
;   547             jle @f
;   548                 sub dword[ebx+edx*4-8],1
;   549                 jz :%pDealloc
;   550           @@:
;   551             ret
;   552       
;   553       ::opRepsStr
;   554 -----------------
;   555         --
;   556         --  al: type byte ([esi-1]) (#82 [actually: has bit #80 but !=#80])
;   557         --  ecx: slice length [also in esp+4]
;   558         --  edx: ref length [also in esp]
;   559         --  edi: rep ref (unknown type)
;   560         --  esi: raw(ref) (a string)
;   561         --  [esp] ref length
;   562         --  [esp+4] slice length
;   563         --  [esp+8] slice start (0-based)
;   564         --  [esp+12] ref addr (may become original ref rsn)
;   565         --  [esp+16] slice end (1-based)
;   566         --  [esp+20] rep ref
;   567         --  [esp+24] return addr
;   568         --
;   569         cmp al,0x82
;   570         jne :e04atsaa24 -- cannot happen? (unless type byte is corrupt)
;   571         --
;   572         -- check for insitu replacement
;   573         --
;   574         cmp dword[esi-8],1
;   575         jne :opRepsStrMultiRef
;   576         --
;   577         -- which is ok for chars...
;   578         --
;   579         cmp edi,h4
;   580         jge @f
;   581             cmp ecx,0               -- check for zero length slice replacement
;   582             je :opRepsPop6          -- do nothing case
;   583             cmp edi,#FF
;   584             ja :opRepsStrToSeqA     -- also jumps for -ve & non-int
;   585 --          mov edi,-1
;   586 --          add esi,[esp+8]         -- slice start (0-based)
;   587             mov edi,[esp+8]         -- slice start (0-based)
;   588 --          mov eax,edi
;   589             mov eax,[esp+20]
;   590             add edi,esi
;   591 --          lea edi,[esi+edx-1]
;   592             rep stosb
;   593             jmp :opRepsPop6
;   594       @@:
;   595         --
;   596         -- .. and strings of the same length
;   597         --
;   598         cmp byte[ebx+edi*4-1],0x82
;   599         jne @f
;   600             cmp dword[ebx+edi*4-12],ecx
;   601             jne :opRepsStrSeqL
;   602             shl edi,2
;   603 --          mov edx,[esp+12]        -- slice start
;   604             mov edx,[esp+8]         -- slice start (0-based)
;   605             xchg esi,edi
;   606 --DEV see above?
;   607 --          lea edi,[edi+edx-1]
;   608             add edi,edx
;   609             rep movsb
;   610             jmp :opRepsPop6
;   611 
;   612       @@:
;   613         cmp byte[ebx+edi*4-1],0x80
;   614         je :opRepsStrSeqL
;   615       ::opRepsStrToSeqAtom
;   616         add dword[ebx+edi*4-8],ecx  -- bulk ref update (float)
;   617 
;   618       ::opRepsStrToSeqA
;   619 -----------------------
;   620         --
;   621         -- replacement (edi) is atom, but we must create a sequence (same length as original)
;   622         --
;   623         cmp ecx,0                   -- check for zero length slice replacement
;   624         je :opRepsPop6              -- do nothing case
;   625         mov ecx,edx                 -- new length == original length
;   626 --      mov edx,[esp+12]            -- ref addr
;   627         mov edi,[esp+12]            -- ref addr
;   628 --      push edi                    --[7]
;   629         mov edx,[esp+24]            -- era
;   630         call :%pAllocSeq            -- damages eax only
;   631 --      mov edi,[edx]
;   632         mov edx,[edi]
;   633 --      mov [edx],eax               -- Replace the ref at the original address
;   634         mov [edi],eax               -- Replace the ref at the original address
;   635 -->     mov [esp+16],edi            -- decref/dealloc at end (opRepsPop6da)
;   636 --      mov [esp+12],edi            -- decref/dealloc at end (opRepsPop6da)
;   637         mov [esp+12],edx            -- decref/dealloc at end (opRepsPop6da)
;   638         mov edx,eax
;   639         lea edi,[ebx+eax*4]
;   640 --      add edx,[esp+12]
;   641         add edx,[esp+8]             -- slice start, 0-based
;   642         mov ecx,[esp]               -- source ref length
;   643         shl edx,2                   -- (lea edx,newseq[slice start], doing both ref->raw and idx->dwords at the same time)
;   644         xor eax,eax
;   645       @@:
;   646             lodsb                   -- mov al,[esi], esi+=1
;   647             stosd                   -- mov [edi],eax, edi+=4
;   648             sub ecx,1
;   649             jnz @b
;   650 
;   651         mov edi,edx                 -- newseq[slicestart]
;   652 --      pop eax                     --[7]
;   653         mov eax,[esp+20]            -- rep ref (already incref'd)
;   654         mov ecx,[esp+4]             -- slice len
;   655         rep stosd
;   656         jmp :opRepsPop6da
;   657 
;   658       ::opRepsStrMultiRef
;   659 -------------------------
;   660         --
;   661         --  al: type byte ([esi-1]) (#82)
;   662         --  ecx: slice length [also in esp+4]
;   663         --  edx: ref length [also in esp]
;   664         --  edi: rep ref (unknown type)
;   665         --  esi: raw(ref) (a string)
;   666         --  [esp] ref length
;   667         --  [esp+4] slice length
;   668         --  [esp+8] slice start (0-based)
;   669         --  [esp+12] ref addr (may become original ref rsn)
;   670         --  [esp+16] slice end (1-based)
;   671         --  [esp+20] rep ref
;   672         --  [esp+24] return addr
;   673         --
;   674         --
;   675         -- if the replacement is a char or a string or a 0-length dword-sequence, then result is string
;   676         --
;   677         cmp edi,h4
;   678         jg @f
;   679             cmp ecx,0                   -- check for zero length slice replacement
;   680             je :opRepsPop6              -- do nothing case
;   681             cmp edi,#FF                 -- also jumps for -ve & non-int
;   682             ja :opRepsStrToSeqA
;   683             mov ecx,edx                 -- same length as original
;   684             mov edx,[esp+12]            -- ref addr
;   685             call :%pAllocStr            -- damages eax only
;   686             mov [edx],eax               -- Replace the ref at the original address
;   687             sub dword[esi-8],1          -- non-1 so no need to dealloc
;   688             xchg eax,edi
;   689             mov edx,[esp+8]             -- slice start (0-based)
;   690             shl edi,2
;   691             mov ecx,[esp]               -- original source length (all of it)
;   692             add edx,edi                 -- (lea edx,newstr[slicestart])
;   693             add ecx,1                   -- and the trailing null
;   694             rep movsb
;   695             mov edi,edx
;   696             mov ecx,[esp+4]             -- slice length (go over middle bit)
;   697             rep stosb
;   698             jmp :opRepsPop6
;   699       @@:
;   700         cmp byte[ebx+edi*4-1],0x12
;   701         je :opRepsStrToSeqAtom
;   702       ::opRepsStrSeqL
;   703         -- calculate required size (whether it needs to be a string or dword-sequence)
;   704         add edx,dword[ebx+edi*4-12] -- original plus replacement length..
;   705 --      lea eax,[ebx+edi*4]         -- may as well
;   706 -->     sub dword[esi-8],1          -- non-1 so no need to dealloc (no, use opRepsPop6da)
;   707         sub edx,dword[esp+4]        -- ..minus slice length
;   708         mov ecx,edx                 -- new length
;   709         mov edx,[esp+12]            -- ref addr
;   710         cmp dword[ebx+edi*4-12],0   -- replacement length 0?
;   711         je :opRepsStrStr
;   712         cmp byte[ebx+edi*4-1],0x80
;   713         je :opRepsStrSeq
;   714 
;   715       ::opRepsStrStr
;   716 --------------------
;   717         --
;   718         -- string[i..j]:=string
;   719         -- new string (size already calculated), built in chunks
;   720         --
;   721         call :%pAllocStr            -- damages eax only
;   722         mov edi,[edx]
;   723         mov [esp+12],edi            -- now becomes ref to decref at end
;   724         mov [edx],eax               -- Replace the ref at the original address
;   725         --
;   726         -- duplicate original items before the slice
;   727         -- (and set edx,eax for later use, to avoid AGI stalls)
;   728         --
;   729         lea edi,[ebx+eax*4]
;   730         mov edx,[esp+16]            -- slice end (1-based)
;   731         mov ecx,[esp+8]             -- slice start (0-based)
;   732         mov eax,[esp+20]            -- rep ref (a string)
;   733         add edx,esi                 -- (lea edx,[esi+sliceend+1])
;   734         shl eax,2                   -- (lea eax,[rep[1]])
;   735         rep movsb
;   736         --
;   737         -- duplicate the replacement string
;   738         --
;   739         mov esi,eax
;   740         mov ecx,[eax-12]            -- replacement length
;   741         rep movsb
;   742         --
;   743         -- duplicate remaining original items
;   744         --
;   745         mov ecx,[esp]           -- ref length
;   746         mov esi,edx
;   747         sub ecx,[esp+16]        -- minus slice end (1-based)
;   748 --added 16/2/15:
;   749         add ecx,1               -- include terminating null
;   750         rep movsb
;   751         jmp :opRepsPop6da
;   752 
;   753       ::opRepsStrSeq
;   754 --------------------
;   755         --
;   756         --  al: type byte ([esi-1]) (#82)
;   757         --  ecx: slice length [also in esp+4]
;   758 --X     --  edx: ref length [also in esp]
;   759         --  edx: ref addr
;   760         --  edi: rep ref (a dword-sequence, of non-0 length)
;   761         --  esi: raw(ref) (a string)
;   762         --  [esp] ref length
;   763         --  [esp+4] slice length
;   764         --  [esp+8] slice start (0-based)
;   765         --  [esp+12] ref addr (becomes original ref rsn)
;   766         --  [esp+16] slice end (1-based)
;   767         --  [esp+20] rep ref
;   768         --  [esp+24] return addr
;   769         --
;   770         --
;   771         -- string[i..j]:=dword_sequence
;   772         -- new sequence (size already calculated), built in chunks
;   773         --
;   774         mov edi,edx
;   775         mov edx,[esp+24]        -- era
;   776         call :%pAllocSeq        -- damages eax only
;   777 --      mov edi,[edx]
;   778         mov edx,[edi]
;   779 --      mov [esp+12],edi        -- now becomes ref to dealloc at end
;   780         mov [esp+12],edx        -- now becomes ref to dealloc at end
;   781 --      mov [edx],eax           -- Replace the ref at the original address
;   782         mov [edi],eax           -- Replace the ref at the original address
;   783 
;   784         --
;   785         -- duplicate original chars before the slice as dwords
;   786         -- (and set edx for later use, to avoid an AGI stall)
;   787         --
;   788 --      mov edx,[esp+16]        -- slice end, 1-based
;   789         lea edi,[ebx+eax*4]
;   790 --      shl edx,2
;   791         mov ecx,[esp+8]         -- slice start (0-based)
;   792 -->     mov eax,[esp+20]        -- rep ref (a sequence)
;   793 --      add edx,esi             -- (lea edx,[esi+sliceend+1])
;   794 -->     shl eax,2
;   795 --?     mov [esp+20],edx
;   796         mov edx,[esp+20]        -- rep ref (a sequence)
;   797         test ecx,ecx
;   798         jz @f
;   799             xor eax,eax
;   800       ::opRepsStrSeqBeforeLoop
;   801             lodsb               -- mov al,[esi], esi+=1
;   802             stosd               -- mov [edi],eax, edi+=4
;   803             sub ecx,1
;   804             jnz :opRepsStrSeqBeforeLoop
;   805 
;   806       @@:
;   807         --
;   808         -- duplicate replacement sequence contents
;   809         -- (and save esi in edx for later use)
;   810         --
;   811 -->     mov ecx,[esp]           -- ref length
;   812 --!     mov esi,edx
;   813 -->?        sub ecx,[esp+16]        -- minus slice end (1-based)
;   814 -->?        mov esi,edx
;   815         mov eax,esi
;   816         lea esi,[ebx+edx*4]
;   817         mov ecx,[ebx+edx*4-12]  -- rep length
;   818         mov edx,eax
;   819 --      mov edx,[esp+16]        -- slice end, 1-based
;   820 --      shl edx,2
;   821 --      add edx,esi             -- (lea edx,[esi+sliceend+1])
;   822 --      test ecx,ecx            -- (we know it is not 0-length)
;   823 --      jz :opRepsStrSeqMidDone
;   824       ::opRepsStrSeqMidLoop
;   825             lodsd               -- mov eax,[esi], esi+=4
;   826             stosd               -- mov [edi],eax, edi+=4
;   827             cmp eax,h4
;   828             jl @f
;   829                 add dword[ebx+eax*4-8],1    -- exception should never happen (we are cloning)
;   830           @@:
;   831             sub ecx,1
;   832             jnz :opRepsStrSeqMidLoop
;   833 
;   834 --    ::opRepsStrSeqMidDone
;   835 ---------------------------
;   836         --
;   837         -- duplicate remaining original items
;   838         --
;   839         mov esi,edx
;   840         mov ecx,[esp]           -- ref length
;   841         add esi,[esp+4]         -- slice length
;   842 --      mov esi,[esp+20]
;   843 --      add esi,[esp+4]         -- slice length
;   844         sub ecx,[esp+16]        -- minus slice end (1-based)
;   845         jz :opRepsPop6da
;   846         xor eax,eax
;   847       @@:
;   848             lodsb               -- mov al,[esi], esi+=1
;   849             stosd               -- mov [edi],eax, edi+=4
;   850             sub ecx,1
;   851             jnz @b
;   852         nop
;   853         jmp :opRepsPop6da
;   854 
;   855     [64]
;   856         --calling convention:
;   857         --  mov rcx,N
;   858         --  push <return address>
;   859         --  push [rep]          -- replacement (opUnassigned)
;   860         --  push [sliceend]     -- sliceend (opUnassigned)
;   861         --  push [idxN]..[idx1] -- (opUnassigned)
;   862         --  lea rax,[ref]       -- ref addr
;   863         --  jmp opReps          -- actually a call
;   864         --<return address>
;   865         mov r15,h4
                mov r15,h4                ;#00440524: 49:277 0000000000000040    uv 8000 00  1  56      
;   866       ::opRepsRnxt64
;   867         mov rsi,[rax]
                mov rsi,[rax]             ;#0044052E: 48:213060                  vu 40 01  1  56      
;   868         pop rdi                 -- next idx (ref)
                pop rdi                   ;#00440531: 48:137                     uv 80 00  1  57      
;   869         cmp rsi,r15
                cmp rsi,r15               ;#00440533: 49:073367                  vu 00 8040  1  57      
;   870         jl :e04atsaam4          -- attempt to subscript an atom, era @ [esp+ecx*4-4]?
                jl #00440512              ;#00440536: 174 DA                     v  00 00  1  58      
;   871         push rax                --[1] ref addr, in case we need to clone...
                push rax                  ;#00440538: 48:120                     uv 00 01  1  59      
;   872         mov al,[rbx+rsi*4-1]
                mov al,[rbx+rsi*4-1]      ;#0044053A: 212104263 FF               vu 01 48  1  59      
;   873         sub rdi,1
                sub rdi,1                 ;#0044053E: 48:203357 01               uv 80 80  1  60      
;   874 --      mov rdx,[rbx+rsi*4-12]  -- length
;   875         mov rdx,[rbx+rsi*4-24]  -- length
                mov rdx,[rbx+rsi*4-24]    ;#00440542: 48:213124263 E8            vu 04 48  1  60      
;   876         shl rsi,2
                shl rsi,2                 ;#00440547: 48:301346 02               u  40 40  1  61      
;   877 
;   878         sub rcx,1
                sub rcx,1                 ;#0044054B: 48:203351 01               vu 02 02  1  61      
;   879         je :opRepsMain64        -- deal with final slice separately
                je #004405BA              ;#0044054F: 164 69                     v  00 00  1  62      
;   880         cmp al,0x80
                cmp al,#80                ;#00440551: 200370 80                  uv 00 01  1  63      
;   881         jne :e04atsaa9          -- must be seq since another idx (or the slice) follows, era * [esp+ecx*4+4]?
                jne #0044051A             ;#00440554: 165 C4                     v  00 00  1  63      
;   882 
;   883         cmp rdi,rdx
                cmp rdi,rdx               ;#00440556: 48:071327                  uv 00 84  1  64      
;   884         jb @f                   -- unsigned jump, lets 0..len-1 through
                jb #00440562              ;#00440559: 162 07                     v  00 00  1  64      
;   885                                 --               (we just did a dec edi)
;   886 --DEV +8..
;   887             mov al,8+4+0        -- [era] @ [esp+ecx*4+4], "assigning to"
                    mov al,12             ;#0044055B: 260 0C                     uv 01 00  1  65      
;   888             call :%fixupIndex   -- idx-1 in rdi, len in rdx, al set
                    call #0044144B (:%fixupIndex)  ;#0044055D: 350 E90E0000               v  00 00  1  65      
;   889       @@:
;   890         --
;   891         -- rdi now contains index to replace, and rdx the length
;   892         --   
;   893         mov rax,[rsi-16]        -- refcount
                mov rax,[rsi-16]          ;#00440562: 48:213106 F0               uv 01 40  1  66      
;   894         sub rax,1
                sub rax,1                 ;#00440566: 48:203350 01               uv 01 01  1  67 01   
;   895         jz :opRepsSeqNoClone64
                jz #004405AD              ;#0044056A: 164 41                     v  00 00  1  67      
;   896         mov [rsi-16],rax        -- non-1 so no need to dealloc
                mov [rsi-16],rax          ;#0044056C: 48:211106 F0               uv 00 41  1  68      
;   897         mov rax,[rsp+rcx*8+8]   -- era
                mov rax,[rsp+rcx*8+8]     ;#00440570: 48:213104314 08            vu 01 12  1  68      
;   898         push rcx                --[2] no of remainding indexes
                push rcx                  ;#00440575: 48:121                     uv 00 02  1  69      
;   899         push rdi                --[3] idx
                push rdi                  ;#00440577: 48:127                     vu 00 80  1  69      
;   900         mov rcx,rdx
                mov rcx,rdx               ;#00440579: 48:213312                  uv 02 04  1  70      
;   901         mov rdi,[rsp+16]        --[1] (ref addr, leaving it on the stack)
                mov rdi,[rsp+16]          ;#0044057C: 48:213174044 10            vu 80 10  1  70      
;   902         mov rdx,rax             -- era
                mov rdx,rax               ;#00440581: 48:213320                  uv 04 01  1  71      
;   903         call :%pAllocSeq        -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440584: 350 BF1B0000               v  00 00  1  71      
;   904         mov [rdi],rax           -- Replace ref at original address [no dealloc rqd]
                mov [rdi],rax             ;#00440589: 48:211007                  uv 00 81  1  72      
;   905         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#0044058C: 48:215074203               vu 80 09  1  72      
;   906         push rdi                --[4]
                push rdi                  ;#00440590: 48:127                     uv 00 80  1  73      
;   907       @@:
;   908             lodsq               -- mov rax,[rsi], rsi+=8
                    lodsq                 ;#00440592: 48:255                     np 41 40  2  74      
;   909             stosq               -- mov [rdi],rax, rdi+=8
                    stosq                 ;#00440594: 48:253                     np 80 81  3  76      
;   910             cmp rax,r15
                    cmp rax,r15           ;#00440596: 49:073307                  uv 00 8001  1  79      
;   911             jl :opReps_no_incref64
                    jl #004405A1          ;#00440599: 174 06                     v  00 00  1  79      
;   912                 add qword[rbx+rax*4-16],1
                        add qword[rbx+rax*4-16],1  ;#0044059B: 48:203104203 F0 01         u  00 09  3  80      
;   913           ::opReps_no_incref64
;   914 
;   915             sub rcx,1
                    sub rcx,1             ;#004405A1: 48:203351 01               vu 02 02  1  82      
;   916             jnz @b
                    jnz #00440592         ;#004405A5: 165 EB                     v  00 00  1  83      
;   917 
;   918         pop rsi                 --[4] NB rsi:=rdi
                pop rsi                   ;#004405A7: 48:136                     uv 40 00  1  84      
;   919         pop rdi                 --[3] idx
                pop rdi                   ;#004405A9: 48:137                     vu 80 00  1  84      
;   920         pop rcx                 --[2] no of remaining indexes
                pop rcx                   ;#004405AB: 48:131                     uv 02 00  1  85      
;   921       ::opRepsSeqNoClone64
;   922         add rsp,8               --[1] discard ref addr
                add rsp,8                 ;#004405AD: 48:203304 08               vu 10 10  1  85      
;   923         lea rax,[rsi+rdi*4]
                lea rax,[rsi+rdi*4]       ;#004405B1: 48:215004276               uv 01 C0  1  86      
;   924         jmp :opRepsRnxt64
                jmp #0044052E             ;#004405B5: 351 74FFFFFF               v  00 00  1  86      
;   925 
;   926       ::opRepsMain64
;   927 --------------------
;   928         -- al type byte
;   929         -- rcx 0
;   930         -- rdx length ref
;   931         -- rsi raw ref
;   932         -- rdi slice start (-1, pre fixup)
;   933         -- stack contents:
;   934         --  [rsp]   ref addr (after several subcripts)
;   935         --  [rsp+8] slice end (pre fixup)
;   936         --  [rsp+16] rep ref
;   937         --  [rsp+24] <return address>
;   938         test al,0x80
                test al,#80               ;#004405BA: 250 80                     uv 00 01  1  87      
;   939 --      jz :e04atsaa4
;   940         jnz @f
                jnz #004405CF             ;#004405BC: 165 11                     v  00 00  1  87      
;   941             mov rdx,[rsp+24]
                    mov rdx,[rsp+24]      ;#004405BE: 48:213124044 18            uv 04 10  1  88      
;   942             mov al,4    -- e04atsaa
                    mov al,4              ;#004405C3: 260 04                     vu 01 00  1  88      
;   943             sub rdx,1
                    sub rdx,1             ;#004405C5: 48:203352 01               uv 04 04  1  89      
;   944             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#004405C9: 351 98280000               v  00 00  1  89      
;   945             int3
                    int3                  ;#004405CE: 314                        np 00 00 13  90      
;   946       @@:
;   947         cmp rdi,rdx
                cmp rdi,rdx               ;#004405CF: 48:071327                  uv 00 84  1 103      
;   948         jbe @f                  -- unsigned jump, lets 0..len through (NB jbe here)
                jbe #004405DB             ;#004405D2: 166 07                     v  00 00  1 103      
;   949                                 --               (we just did a dec rdi)
;   950                                 --               (slice start can be 1..length+1)
;   951 --DEV +12
;   952             mov cl,8                -- [era] @ [esp+8]
                    mov cl,8              ;#004405D4: 261 08                     uv 02 00  1 104      
;   953             call :%fixupSliceStart  -- idx in rdi, len in rdx
                    call :%fixupSliceStart  ;#004405D6: 350 D50E0000               v  00 00  1 104      
;   954       @@:
;   955         push rdi                -- save slice start (0-based)
                push rdi                  ;#004405DB: 48:127                     uv 00 80  1 105      
;   956         mov rdi,[rsp+16]        -- slice end
                mov rdi,[rsp+16]          ;#004405DD: 48:213174044 10            vu 80 10  1 105      
;   957         cmp rdi,rdx
                cmp rdi,rdx               ;#004405E2: 48:071327                  uv 00 84  1 106      
;   958         jbe @f                  -- unsigned jump, lets 0..len through (NB jbe here, and no dec rdi)
                jbe #004405F3             ;#004405E5: 166 0C                     v  00 00  1 106      
;   959                                 --               (slice end can be 0..length)
;   960 --DEV 16
;   961 --          mov cl,12               -- [era] @ [esp+12]
;   962             mov cl,40               -- [era] @ [rsp+40]
                    mov cl,40             ;#004405E7: 261 28                     uv 02 00  1 107      
;   963             call :%fixupSliceEnd    -- idx in rdi, len in rdx, idx addr in rbx(?)
                    call #00441519 (:%fixupSliceEnd)  ;#004405E9: 350 2B0F0000               v  00 00  1 107      
;   964             mov [rsp+16],rdi        -- save normalised slice end (1-based)
                    mov [rsp+16],rdi      ;#004405EE: 48:211174044 10            uv 00 90  1 108      
;   965       @@:
;   966         mov rcx,rdi
                mov rcx,rdi               ;#004405F3: 48:213317                  vu 02 80  1 108      
;   967         sub rcx,[rsp]
                sub rcx,[rsp]             ;#004405F6: 48:053014044               uv 02 12  2 109      
;   968         jl :e09slinespp4        -- slice length is negative (%d..%d)
                jl #00440522              ;#004405FA: 017214 22FFFFFF            v  00 00  1 110      
;   969         push rcx                -- save slice length
                push rcx                  ;#00440600: 48:121                     uv 00 02  1 111      
;   970         push rdx                -- save source (ref) length
                push rdx                  ;#00440602: 48:122                     vu 00 04  1 111      
;   971         mov rdi,[rsp+40]        -- rep ref
                mov rdi,[rsp+40]          ;#00440604: 48:213174044 28            uv 80 10  1 112      
;   972         --
;   973         --  al: type byte ([esi-1])
;   974         --  rcx: slice length [also in esp+4]
;   975         --  rdx: ref length [also in esp]
;   976         --  rdi: rep ref
;   977         --  rsi: raw(ref)
;   978         --  [rsp] ref length
;   979         --  [rsp+8] slice length
;   980         --  [rsp+16] slice start (0-based)
;   981         --  [rsp+24] ref addr
;   982         --  [rsp+32] slice end (1-based)
;   983         --  [rsp+40] rep ref
;   984         --  [rsp+48] return addr
;   985         --
;   986         -- handle sequence and string slices separately...
;   987         --
;   988         cmp al,0x80
                cmp al,#80                ;#00440609: 200370 80                  vu 00 01  1 112      
;   989         jne :opRepsStr64
                jne #00440893             ;#0044060C: 017205 81020000            v  00 00  1 113      
;   990             --
;   991             -- check for insitu replacement
;   992             --
;   993 --          cmp dword[rsi-16],1
;   994             cmp qword[rsi-16],1
                    cmp qword[rsi-16],1   ;#00440612: 48:203176 F0 01            u  00 40  2 114      
;   995             jne :opRepsSeqMultiRef64
                    jne #0044071B         ;#00440617: 017205 FE000000            v  00 00  1 115      
;   996             --
;   997             -- which is ok for atoms...
;   998             --
;   999             cmp rdi,r15
                    cmp rdi,r15           ;#0044061D: 49:073377                  uv 00 8080  1 116      
;  1000             jl @f
                    jl #00440632          ;#00440620: 174 10                     v  00 00  1 116      
;  1001                 lea rax,[rbx+rdi*4]
                        lea rax,[rbx+rdi*4]  ;#00440622: 48:215004273               uv 01 88  1 117      
;  1002                 test byte[rbx+rdi*4-1],0x80
                        test byte[rbx+rdi*4-1],#80  ;#00440626: 366104273 FF 80            u  00 88  2 118      
;  1003                 jnz :opRepsSeqSeq64
                        jnz #0044067B     ;#0044062B: 165 4E                     v  00 00  1 119      
;  1004                 add qword[rbx+rdi*4-16],rcx -- bulk ref update (float)
                        add [rbx+rdi*4-16],rcx  ;#0044062D: 48:001114273 F0            uv 00 8A  3 120      
;  1005           @@:                       -- replacement is an atom
;  1006 --          mov rdx,[rsp+8]         -- slice start
;  1007             mov rdx,[rsp+16]        -- slice start
                    mov rdx,[rsp+16]      ;#00440632: 48:213124044 10            vu 04 10  1 122      
;  1008             cmp rcx,0               -- check for zero length slice replacement
                    cmp rcx,0             ;#00440637: 48:203371 00               uv 00 02  1 123      
;  1009             je :opRepsPop664        -- do nothing case
                    je #00440676          ;#0044063B: 164 39                     v  00 00  1 123      
;  1010             mov rax,rdi
                    mov rax,rdi           ;#0044063D: 48:213307                  uv 01 80  1 124      
;  1011 --          lea rdi,[rsi+rdx*4-8]
;  1012 --          lea rdi,[rsi+rdx*4]
;  1013             lea rdi,[rsi+rdx*8]
                    lea rdi,[rsi+rdx*8]   ;#00440640: 48:215074326               vu 80 44  1 124      
;  1014           ::opRepsSeqAtomLoop64
;  1015             mov rdx,[rdi]
                    mov rdx,[rdi]         ;#00440644: 48:213027                  uv 04 80  1 127    *80*
;  1016             cmp rdx,r15
                    cmp rdx,r15           ;#00440647: 49:073327                  uv 00 8004  1 128 04   
;  1017             jle @f
                    jle #0044066E         ;#0044064A: 176 22                     v  00 00  1 128      
;  1018                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0044064C: 48:203154223 F0 01         u  00 0C  3 129      
;  1019                 jnz @f
                        jnz #0044066E     ;#00440652: 165 1A                     v  00 00  1 131      
;  1020 --                  pushad
;  1021                     push rax
                            push rax      ;#00440654: 48:120                     uv 00 01  1 132      
;  1022                     push rcx
                            push rcx      ;#00440656: 48:121                     vu 00 02  1 132      
;  1023                     push rsi
                            push rsi      ;#00440658: 48:126                     uv 00 40  1 133      
;  1024                     push rdi
                            push rdi      ;#0044065A: 48:127                     vu 00 80  1 133      
;  1025                     push qword[rsp+80]
                            push qword[rsp+80]  ;#0044065C: 48:377164044 50            np 00 10  2 134      
;  1026                     call :%pDealloc0
                            call #004422DE (:%pDealloc0)  ;#00440661: 350 781C0000               v  00 00  1 136      
;  1027 --                  popad
;  1028                     pop rdi
                            pop rdi       ;#00440666: 48:137                     uv 80 00  1 137      
;  1029                     pop rsi
                            pop rsi       ;#00440668: 48:136                     vu 40 00  1 137      
;  1030                     pop rcx
                            pop rcx       ;#0044066A: 48:131                     uv 02 00  1 138      
;  1031                     pop rax
                            pop rax       ;#0044066C: 48:130                     vu 01 00  1 138      
;  1032           @@:
;  1033             stosq                   -- mov [rdi],rax, rdi+=8
                    stosq                 ;#0044066E: 48:253                     np 80 81  3 139      
;  1034             sub rcx,1
                    sub rcx,1             ;#00440670: 48:203351 01               uv 02 02  1 142      
;  1035             jnz :opRepsSeqAtomLoop64
                    jnz #00440644         ;#00440674: 165 CE                     v  00 00  1 142      
;  1036 
;  1037       ::opRepsPop664
;  1038 --------------------
;  1039             add rsp,48
                    add rsp,48            ;#00440676: 48:203304 30               uv 10 10  1 143      
;  1040             ret
                    ret                   ;#0044067A: 303                        np 00 00  2 144      
;  1041 
;  1042       ::opRepsSeqSeq64
;  1043 ----------------------
;  1044             --
;  1045             -- .. and sequences of the same length
;  1046             --
;  1047             cmp qword[rax-24],rcx
                    cmp [rax-24],rcx      ;#0044067B: 48:071110 E8               uv 00 03  2 146      
;  1048             jne :opRepsSeqMRSeqStr64
                    jne #004407BE         ;#0044067F: 017205 39010000            v  00 00  1 147      
;  1049             cmp rcx,0
                    cmp rcx,0             ;#00440685: 48:203371 00               uv 00 02  1 148      
;  1050             je :opRepsPop664            -- eg x[2..1]={}/"", do nothing case
                    je #00440676          ;#00440689: 164 EB                     v  00 00  1 148      
;  1051             --
;  1052             --  rax: raw(rdi)
;  1053             --  rcx: slice length [also in rsp+8] (!=0)
;  1054             --  rdx: ref length [also in rsp]
;  1055             --  rdi: rep ref (a sequence/string of length ecx)
;  1056             --  rsi: raw(ref) (a dword-sequence)
;  1057             --  [rsp] ref length
;  1058             --  [rsp+8] slice length
;  1059             --  [rsp+16] slice start (0-based)
;  1060             --  [rsp+24] ref addr
;  1061             --  [rsp+32] slice end (1-based)
;  1062             --  [rsp+40] rep ref
;  1063             --  [rsp+48] return addr
;  1064             --
;  1065             mov rdx,[rsp+16]            -- slice start
                    mov rdx,[rsp+16]      ;#0044068B: 48:213124044 10            uv 04 10  1 149      
;  1066             mov rdi,rsi                 -- raw(ref)
                    mov rdi,rsi           ;#00440690: 48:213376                  vu 80 40  1 149      
;  1067             mov rsi,rax                 -- raw(rep)
                    mov rsi,rax           ;#00440693: 48:213360                  uv 40 01  1 150      
;  1068             cmp byte[rax-1],0x80
                    cmp byte[rax-1],#80   ;#00440696: 200170 FF 80               u  00 01  2 151      
;  1069 --5/2/15:
;  1070 --          lea rdi,[rdi+rdx*4-8]       -- addr ref[slice start]
;  1071             lea rdi,[rdi+rdx*4]         -- addr ref[slice start]
                    lea rdi,[rdi+rdx*4]   ;#0044069A: 48:215074227               vu 80 84  1 152      
;  1072             jne :opRepsSeqStr64
                    jne #004406E1         ;#0044069E: 165 41                     v  00 00  1 153      
;  1073           ::opRepsSeqSeqLoop64
;  1074                 lodsq                       -- mov rax,[rsi], rsi+=8
                        lodsq             ;#004406A0: 48:255                     np 41 40  2 154      
;  1075                 cmp rax,r15
                        cmp rax,r15       ;#004406A2: 49:073307                  uv 00 8001  1 156      
;  1076                 jl @f
                        jl #004406AD      ;#004406A5: 174 06                     v  00 00  1 156      
;  1077                     add qword[rbx+rax*4-16],1
                            add qword[rbx+rax*4-16],1  ;#004406A7: 48:203104203 F0 01         u  00 09  3 157      
;  1078               @@:
;  1079                 mov rdx,[rdi]
                        mov rdx,[rdi]     ;#004406AD: 48:213027                  vu 04 80  1 159      
;  1080                 cmp rdx,r15
                        cmp rdx,r15       ;#004406B0: 49:073327                  uv 00 8004  1 160      
;  1081                 jle @f
                        jle #004406D7     ;#004406B3: 176 22                     v  00 00  1 160      
;  1082                     sub qword[rbx+rdx*4-16],1
                            sub qword[rbx+rdx*4-16],1  ;#004406B5: 48:203154223 F0 01         u  00 0C  3 161      
;  1083                     jnz @f
                            jnz #004406D7  ;#004406BB: 165 1A                     v  00 00  1 163      
;  1084 --                      pushad
;  1085                         push rcx
                                push rcx  ;#004406BD: 48:121                     uv 00 02  1 164      
;  1086                         push rsi
                                push rsi  ;#004406BF: 48:126                     vu 00 40  1 164      
;  1087                         push rax
                                push rax  ;#004406C1: 48:120                     uv 00 01  1 165      
;  1088                         push rdi
                                push rdi  ;#004406C3: 48:127                     vu 00 80  1 165      
;  1089                         push qword[rsp+80]
                                push qword[rsp+80]  ;#004406C5: 48:377164044 50            np 00 10  2 166      
;  1090                         call :%pDealloc0
                                call #004422DE (:%pDealloc0)  ;#004406CA: 350 0F1C0000               v  00 00  1 168      
;  1091                         pop rdi
                                pop rdi   ;#004406CF: 48:137                     uv 80 00  1 169      
;  1092                         pop rax
                                pop rax   ;#004406D1: 48:130                     vu 01 00  1 169      
;  1093                         pop rsi
                                pop rsi   ;#004406D3: 48:136                     uv 40 00  1 170      
;  1094                         pop rcx
                                pop rcx   ;#004406D5: 48:131                     vu 02 00  1 170      
;  1095 --                      popad
;  1096               @@:
;  1097                 stosq                   -- mov [rdi],rax, rdi+=8
                        stosq             ;#004406D7: 48:253                     np 80 81  3 171      
;  1098                 sub rcx,1
                        sub rcx,1         ;#004406D9: 48:203351 01               uv 02 02  1 174      
;  1099                 jnz :opRepsSeqSeqLoop64
                        jnz #004406A0     ;#004406DD: 165 C1                     v  00 00  1 174      
;  1100             jmp :opRepsPop664
                    jmp #00440676         ;#004406DF: 353 95                     v  00 00  1 175      
;  1101 
;  1102       ::opRepsSeqStr64
;  1103 ----------------------
;  1104             --
;  1105             --  rax: raw(edi)
;  1106             --  rcx: slice length [also in rsp+8] (!=0)
;  1107             --  rdx: slice start [also in rsp+16]
;  1108             --  rdi: addr ref[slice start]
;  1109             --  rsi: raw(rep) (a dword-sequence)
;  1110             --  [rsp] ref length
;  1111             --  [rsp+8] slice length
;  1112             --  [rsp+16] slice start (0-based)
;  1113             --  [rsp+24] ref addr
;  1114             --  [rsp+32] slice end (1-based)
;  1115             --  [rsp+40] rep ref
;  1116             --  [rsp+48] return addr
;  1117             --
;  1118             xor rax,rax
                    xor rax,rax           ;#004406E1: 48:061300                  uv 01 01  1 176      
;  1119           ::opRepsSeqStrLoop64
;  1120                 mov rdx,[rdi]
                        mov rdx,[rdi]     ;#004406E4: 48:213027                  vu 04 80  1 176      
;  1121                 lodsb                   -- mov al,[rsi], rsi+=1
                        lodsb             ;#004406E7: 254                        np 41 40  2 177      
;  1122                 cmp rdx,r15
                        cmp rdx,r15       ;#004406E8: 49:073327                  uv 00 8004  1 179      
;  1123                 jle @f
                        jle #0044070F     ;#004406EB: 176 22                     v  00 00  1 179      
;  1124                     sub qword[rbx+rdx*4-16],1
                            sub qword[rbx+rdx*4-16],1  ;#004406ED: 48:203154223 F0 01         u  00 0C  3 180      
;  1125                     jnz @f
                            jnz #0044070F  ;#004406F3: 165 1A                     v  00 00  1 182      
;  1126 --                      pushad
;  1127                         push rcx
                                push rcx  ;#004406F5: 48:121                     uv 00 02  1 183      
;  1128                         push rsi
                                push rsi  ;#004406F7: 48:126                     vu 00 40  1 183      
;  1129                         push rax
                                push rax  ;#004406F9: 48:120                     uv 00 01  1 184      
;  1130                         push rdi
                                push rdi  ;#004406FB: 48:127                     vu 00 80  1 184      
;  1131                         push qword[rsp+80]
                                push qword[rsp+80]  ;#004406FD: 48:377164044 50            np 00 10  2 185      
;  1132                         call :%pDealloc0
                                call #004422DE (:%pDealloc0)  ;#00440702: 350 D71B0000               v  00 00  1 187      
;  1133                         pop rdi
                                pop rdi   ;#00440707: 48:137                     uv 80 00  1 188      
;  1134                         pop rax
                                pop rax   ;#00440709: 48:130                     vu 01 00  1 188      
;  1135                         pop rsi
                                pop rsi   ;#0044070B: 48:136                     uv 40 00  1 189      
;  1136                         pop rcx
                                pop rcx   ;#0044070D: 48:131                     vu 02 00  1 189      
;  1137 --                      popad
;  1138               @@:
;  1139                 stosq                   -- mov [rdi],rax, rdi+=8
                        stosq             ;#0044070F: 48:253                     np 80 81  3 190      
;  1140                 sub rcx,1
                        sub rcx,1         ;#00440711: 48:203351 01               uv 02 02  1 193      
;  1141                 jnz :opRepsSeqStrLoop64
                        jnz #004406E4     ;#00440715: 165 CD                     v  00 00  1 193      
;  1142 
;  1143 --          jmp :opRepsPop664
;  1144             add esp,48
                    add esp,48            ;#00440717: 203304 30                  uv 10 10  1 194      
;  1145             ret
                    ret                   ;#0044071A: 303                        np 00 00  2 195      
;  1146 
;  1147       ::opRepsSeqMultiRef64
;  1148 ---------------------------
;  1149             --
;  1150             --  al: type byte ([rsi-1])
;  1151             --  rcx: slice length [also in rsp+8]
;  1152             --  rdx: ref length [also in rsp]
;  1153             --  rdi: rep ref [also in rsp+40]
;  1154             --  rsi: raw(ref) (dword_sequence, refcount>1)
;  1155             --  [rsp] ref length
;  1156             --  [rsp+8] slice length
;  1157             --  [rsp+16] slice start (0-based)
;  1158             --  [rsp+24] ref addr
;  1159             --  [rsp+32] slice end (1-based)
;  1160             --  [rsp+40] rep ref
;  1161             --  [rsp+48] return addr
;  1162             --
;  1163             --
;  1164             -- ok, how big does this thing have to be?
;  1165             --
;  1166             -- In the case of an atom, same as source...
;  1167             --
;  1168             cmp rdi,r15
                    cmp rdi,r15           ;#0044071B: 49:073377                  uv 00 8080  1 197      
;  1169             jl @f
                    jl #00440734          ;#0044071E: 174 14                     v  00 00  1 197      
;  1170                 lea rax,[rbx+rdi*4]
                        lea rax,[rbx+rdi*4]  ;#00440720: 48:215004273               uv 01 88  1 198      
;  1171                 test byte[rbx+rdi*4-1],0x80
                        test byte[rbx+rdi*4-1],#80  ;#00440724: 366104273 FF 80            u  00 88  2 199      
;  1172                 jnz :opRepsSeqMRSeqStr64
                        jnz #004407BE     ;#00440729: 017205 8F000000            v  00 00  1 200      
;  1173                 add qword[rbx+rdi*4-16],rcx   -- bulk ref update (float)
                        add [rbx+rdi*4-16],rcx  ;#0044072F: 48:001114273 F0            uv 00 8A  3 201      
;  1174           @@:                       -- replacement is an atom
;  1175             cmp rcx,0               -- check for zero length slice replacement
                    cmp rcx,0             ;#00440734: 48:203371 00               vu 00 02  1 203      
;  1176             je :opRepsPop664        -- do nothing case
                    je #00440676          ;#00440738: 017204 38FFFFFF            v  00 00  1 204      
;  1177             mov rcx,rdx
                    mov rcx,rdx           ;#0044073E: 48:213312                  uv 02 04  1 205      
;  1178 --          mov rdx,[rsp+24]        -- addr ref
;  1179             mov rdi,[rsp+24]        -- addr ref
                    mov rdi,[rsp+24]      ;#00440741: 48:213174044 18            vu 80 10  1 205      
;  1180             mov rdx,[rsp+48]        -- era
                    mov rdx,[rsp+48]      ;#00440746: 48:213124044 30            uv 04 10  1 206      
;  1181             call :%pAllocSeq        -- damages rax only
                    call #00442148 (:%pAllocSeq)  ;#0044074B: 350 F8190000               v  00 00  1 206      
;  1182 --          mov [rdx],rax           -- Replace the ref at the original address
;  1183             mov [rdi],rax           -- Replace the ref at the original address
                    mov [rdi],rax         ;#00440750: 48:211007                  uv 00 81  1 207      
;  1184             sub qword[rsi-16],1     -- non-1 so no need to dealloc
                    sub qword[rsi-16],1   ;#00440753: 48:203156 F0 01            u  00 40  3 208      
;  1185             lea rdi,[rbx+rax*4]
                    lea rdi,[rbx+rax*4]   ;#00440758: 48:215074203               vu 80 09  1 210      
;  1186             --
;  1187             -- duplicate original items before the slice
;  1188             --
;  1189 --          mov rcx,[rsp+24]                -- slice start
;  1190             mov rcx,[rsp+16]        -- slice start (0-based)
                    mov rcx,[rsp+16]      ;#0044075C: 48:213114044 10            uv 02 10  1 211      
;  1191 --          sub rcx,1
;  1192             test rcx,rcx
                    test rcx,rcx          ;#00440761: 48:205311                  uv 00 02  1 212 02   
;  1193             jz :opRepsSeqMRAmid64
                    jz #0044077B          ;#00440764: 164 15                     v  00 00  1 212      
;  1194           ::opRepsSeqMRAtomBeforeLoop64
;  1195                 lodsq                           -- mov rax,[rsi], rsi+=8
                        lodsq             ;#00440766: 48:255                     np 41 40  2 213      
;  1196                 stosq                           -- mov [rdi],rax, rdi+=8
                        stosq             ;#00440768: 48:253                     np 80 81  3 215      
;  1197                 cmp rax,r15
                        cmp rax,r15       ;#0044076A: 49:073307                  uv 00 8001  1 218      
;  1198                 jl @f
                        jl #00440775      ;#0044076D: 174 06                     v  00 00  1 218      
;  1199                     add qword[rbx+rax*4-16],1   -- exception should never happen (we are cloning)
                            add qword[rbx+rax*4-16],1  ;#0044076F: 48:203104203 F0 01         u  00 09  3 219      
;  1200               @@:
;  1201                 sub rcx,1
                        sub rcx,1         ;#00440775: 48:203351 01               vu 02 02  1 221      
;  1202                 jnz :opRepsSeqMRAtomBeforeLoop64
                        jnz #00440766     ;#00440779: 165 EB                     v  00 00  1 222      
;  1203 
;  1204             --
;  1205             -- blat slice area with atom
;  1206             --
;  1207           ::opRepsSeqMRAmid64
;  1208 -----------------------------
;  1209             mov rax,[rsp+40]        -- rep ref 
                    mov rax,[rsp+40]      ;#0044077B: 48:213104044 28            uv 01 10  1 223      
;  1210             mov rcx,[rsp+8]         -- slice len
                    mov rcx,[rsp+8]       ;#00440780: 48:213114044 08            vu 02 10  1 223      
;  1211             rep stosq
                    rep stosq             ;#00440785: 363:48:253                 np 82 83  3 224      
;  1212             --
;  1213             -- duplicate remaining original items
;  1214             --
;  1215             mov rcx,[rsp]           -- original source ref length
                    mov rcx,[rsp]         ;#00440788: 48:213014044               uv 02 10  1 227      
;  1216 --erm, 7/11/14:
;  1217 --          mov rax,[rsp+16]        -- slice end
;  1218             mov rax,[rsp+32]        -- slice end
                    mov rax,[rsp+32]      ;#0044078C: 48:213104044 20            vu 01 10  1 227      
;  1219             sub rcx,rax
                    sub rcx,rax           ;#00440791: 48:051301                  uv 02 03  1 228      
;  1220             jz :opRepsPop664
                    jz #00440676          ;#00440794: 017204 DCFEFFFF            v  00 00  1 228      
;  1221             mov rax,[rsp+8]         -- slice length
                    mov rax,[rsp+8]       ;#0044079A: 48:213104044 08            uv 01 10  1 229      
;  1222             lea rsi,[rsi+rax*4-8]
                    lea rsi,[rsi+rax*4-8]  ;#0044079F: 48:215164206 F8            uv 40 41  1 232 01 *01*
;  1223           ::opRepsSeqMRAtomAfterLoop64
;  1224                 lodsq                       -- mov rax,[rsi], rsi+=8
                        lodsq             ;#004407A4: 48:255                     np 41 40  2 235    *40*
;  1225                 stosq                       -- mov [rdi],rax, rdi+=8
                        stosq             ;#004407A6: 48:253                     np 80 81  3 237      
;  1226                 cmp rax,r15
                        cmp rax,r15       ;#004407A8: 49:073307                  uv 00 8001  1 240      
;  1227                 jl @f
                        jl #004407B3      ;#004407AB: 174 06                     v  00 00  1 240      
;  1228                     add qword[rbx+rax*4-16],1           -- exception should never happen (we are cloning)
                            add qword[rbx+rax*4-16],1  ;#004407AD: 48:203104203 F0 01         u  00 09  3 241      
;  1229               @@:
;  1230                 sub rcx,1
                        sub rcx,1         ;#004407B3: 48:203351 01               vu 02 02  1 243      
;  1231                 jnz :opRepsSeqMRAtomAfterLoop64
                        jnz #004407A4     ;#004407B7: 165 EB                     v  00 00  1 244      
;  1232 --          jmp :opRepsPop664
;  1233             add rsp,48
                    add rsp,48            ;#004407B9: 48:203304 30               uv 10 10  1 245      
;  1234             ret
                    ret                   ;#004407BD: 303                        np 00 00  2 246      
;  1235 
;  1236       ::opRepsSeqMRSeqStr64
;  1237 ---------------------------
;  1238             --
;  1239             --  rax: raw(rdi)
;  1240             --  rcx: slice length [also in rsp+8]
;  1241             --  rdx: ref length [also in rsp]
;  1242             --  rdi: rep ref (a sequence/string) [also in rsp+40]
;  1243             --  rsi: raw(ref) (a dword-sequence)
;  1244             --  [rsp] ref length
;  1245             --  [rsp+8] slice length
;  1246             --  [rsp+16] slice start (0-based)
;  1247             --  [rsp+24] ref addr (becomes original ref rsn)
;  1248             --  [rsp+32] slice end (1-based)
;  1249             --  [rsp+40] rep ref (becomes ref[sliceend+1] rsn)
;  1250             --  [rsp+48] return addr
;  1251             --
;  1252             --
;  1253             -- .. in the case of a string/sequence rep, the required length is:
;  1254             --
;  1255             sub rdx,rcx                 -- original length-slicelength
                    sub rdx,rcx           ;#004407BE: 48:051312                  uv 04 06  1 248      
;  1256             mov rcx,qword[rax-24]       -- replacement length
                    mov rcx,[rax-24]      ;#004407C1: 48:213110 E8               vu 02 01  1 248      
;  1257             add rcx,rdx
                    add rcx,rdx           ;#004407C5: 48:001321                  uv 02 06  1 249      
;  1258 --          mov rdx,[rsp+24]            -- addr ref
;  1259             mov rdi,[rsp+24]            -- addr ref
                    mov rdi,[rsp+24]      ;#004407C8: 48:213174044 18            vu 80 10  1 249      
;  1260             mov rdx,[rsp+48]            -- era
                    mov rdx,[rsp+48]      ;#004407CD: 48:213124044 30            uv 04 10  1 250      
;  1261             call :%pAllocSeq            -- damages rax only
                    call #00442148 (:%pAllocSeq)  ;#004407D2: 350 71190000               v  00 00  1 250      
;  1262 --          mov rdi,[rdx]               -- original ref
;  1263             mov rdx,[rdi]               -- original ref
                    mov rdx,[rdi]         ;#004407D7: 48:213027                  uv 04 80  1 251      
;  1264             mov rcx,[rsp+16]            -- slice start (0-based)
                    mov rcx,[rsp+16]      ;#004407DA: 48:213114044 10            vu 02 10  1 251      
;  1265 --          mov [rsp+24],rdi            -- decref/dealloc at end (opRepsPop6da64)
;  1266             mov [rsp+24],rdx            -- decref/dealloc at end (opRepsPop6da64)
                    mov [rsp+24],rdx      ;#004407DF: 48:211124044 18            uv 00 14  1 252      
;  1267 --          mov [rdx],rax               -- Replace the ref at the original address
;  1268             mov [rdi],rax               -- Replace the ref at the original address
                    mov [rdi],rax         ;#004407E4: 48:211007                  vu 00 81  1 252      
;  1269 
;  1270             lea rdi,[rbx+rax*4]
                    lea rdi,[rbx+rax*4]   ;#004407E7: 48:215074203               uv 80 09  1 253      
;  1271             mov rdx,[rsp+8]             -- slice length (for opRepsSeqMRSmid64)
                    mov rdx,[rsp+8]       ;#004407EB: 48:213124044 08            vu 04 10  1 253      
;  1272             --
;  1273             -- duplicate original items before the slice
;  1274             --
;  1275 --          sub rcx,1
;  1276             test rcx,rcx
                    test rcx,rcx          ;#004407F0: 48:205311                  uv 00 02  1 254      
;  1277             jz opRepsSeqMRSmid64
                    jz #0044080A          ;#004407F3: 164 15                     v  00 00  1 254      
;  1278           ::opRepsSeqMRSeqBeforeLoop64
;  1279                 lodsq                   -- mov rax,[rsi], rsi+=8
                        lodsq             ;#004407F5: 48:255                     np 41 40  2 255      
;  1280                 stosq                   -- mov [rdi],rax, rdi+=8
                        stosq             ;#004407F7: 48:253                     np 80 81  3 257      
;  1281                 cmp rax,r15
                        cmp rax,r15       ;#004407F9: 49:073307                  uv 00 8001  1 260      
;  1282                 jl @f
                        jl #00440804      ;#004407FC: 174 06                     v  00 00  1 260      
;  1283                     add qword[rbx+rax*4-16],1   -- exception should never happen (we are cloning)
                            add qword[rbx+rax*4-16],1  ;#004407FE: 48:203104203 F0 01         u  00 09  3 261      
;  1284               @@:
;  1285                 sub rcx,1
                        sub rcx,1         ;#00440804: 48:203351 01               vu 02 02  1 263      
;  1286                 jnz :opRepsSeqMRSeqBeforeLoop64
                        jnz #004407F5     ;#00440808: 165 EB                     v  00 00  1 264      
;  1287 
;  1288             --
;  1289             -- slice area is either from sequence or string...
;  1290             --
;  1291           ::opRepsSeqMRSmid64
;  1292 -----------------------------
;  1293 --          lea rcx,[rsi+rdx*4]         -- ref[end slice+1]
;  1294             lea rcx,[rsi+rdx*8]         -- ref[end slice+1]
                    lea rcx,[rsi+rdx*8]   ;#0044080A: 48:215014326               uv 02 44  1 265      
;  1295             mov rsi,[rsp+40]            -- rep ref
                    mov rsi,[rsp+40]      ;#0044080E: 48:213164044 28            vu 40 10  1 265      
;  1296             mov [rsp+40],rcx            -- ref[end slice+1]
                    mov [rsp+40],rcx      ;#00440813: 48:211114044 28            uv 00 12  1 266      
;  1297             shl rsi,2
                    shl rsi,2             ;#00440818: 48:301346 02               u  40 40  1 267      
;  1298             mov rcx,[rsi-24]            -- rep length
                    mov rcx,[rsi-24]      ;#0044081C: 48:213116 E8               uv 02 40  1 270 40 *40*
;  1299             cmp rcx,0
                    cmp rcx,0             ;#00440820: 48:203371 00               uv 00 02  1 271 02   
;  1300             je :opRepsSeqMRmidDone64
                    je #00440850          ;#00440824: 164 2A                     v  00 00  1 271      
;  1301             cmp byte[rsi-1],0x80
                    cmp byte[rsi-1],#80   ;#00440826: 200176 FF 80               u  00 40  2 272      
;  1302             jne :opRepsSeqMRmidStr64
                    jne #00440844         ;#0044082A: 165 18                     v  00 00  1 273      
;  1303             -- copy seq elements one by one into middle of new sequence
;  1304           ::opRepsSeqMRSeqLoop64
;  1305                 lodsq                   -- mov rax,[rsi], rsi+=8
                        lodsq             ;#0044082C: 48:255                     np 41 40  2 274      
;  1306                 stosq                   -- mov [rdi],rax, rdi+=8
                        stosq             ;#0044082E: 48:253                     np 80 81  3 276      
;  1307                 cmp rax,r15
                        cmp rax,r15       ;#00440830: 49:073307                  uv 00 8001  1 279      
;  1308                 jl @f
                        jl #0044083B      ;#00440833: 174 06                     v  00 00  1 279      
;  1309                     add qword[rbx+rax*4-16],1   -- exception should never happen (we are cloning)
                            add qword[rbx+rax*4-16],1  ;#00440835: 48:203104203 F0 01         u  00 09  3 280      
;  1310               @@:
;  1311                 sub rcx,1
                        sub rcx,1         ;#0044083B: 48:203351 01               vu 02 02  1 282      
;  1312                 jnz :opRepsSeqMRSeqLoop64
                        jnz #0044082C     ;#0044083F: 165 EB                     v  00 00  1 283      
;  1313             nop
                    nop                   ;#00440841: 220                        uv 00 00  1 284      
;  1314             jmp :opRepsSeqMRmidDone64
                    jmp #00440850         ;#00440842: 353 0C                     v  00 00  1 284      
;  1315 
;  1316           ::opRepsSeqMRmidStr64
;  1317 -------------------------------
;  1318             -- copy string chars one by one into middle of new sequence
;  1319             xor rax,rax
                    xor rax,rax           ;#00440844: 48:061300                  uv 01 01  1 285      
;  1320           @@:
;  1321                 lodsb                   -- mov al,[rsi], rsi+=1
                        lodsb             ;#00440847: 254                        np 41 40  2 286      
;  1322                 stosq                   -- mov [rdi],rax, rdi+=8
                        stosq             ;#00440848: 48:253                     np 80 81  3 288      
;  1323                 sub rcx,1
                        sub rcx,1         ;#0044084A: 48:203351 01               uv 02 02  1 291      
;  1324                 jnz @b
                        jnz #00440847     ;#0044084E: 165 F7                     v  00 00  1 291      
;  1325 
;  1326           ::opRepsSeqMRmidDone64
;  1327 --------------------------------
;  1328             --
;  1329             -- duplicate remaining original items
;  1330             --
;  1331             mov rcx,[rsp]               -- original source ref length
                    mov rcx,[rsp]         ;#00440850: 48:213014044               uv 02 10  1 292      
;  1332             mov rax,[rsp+32]            -- slice end
                    mov rax,[rsp+32]      ;#00440854: 48:213104044 20            vu 01 10  1 292      
;  1333             sub rcx,rax
                    sub rcx,rax           ;#00440859: 48:051301                  uv 02 03  1 293      
;  1334             jz :opRepsPop6da64
                    jz #00440878          ;#0044085C: 164 1A                     v  00 00  1 293      
;  1335             mov rsi,[rsp+40]            -- ref[sliceend+1]
                    mov rsi,[rsp+40]      ;#0044085E: 48:213164044 28            uv 40 10  1 294      
;  1336           ::opRepsSeqMRSeqAfterLoop64
;  1337                 lodsq                   -- mov rax,[rsi], rsi+=8
                        lodsq             ;#00440863: 48:255                     np 41 40  2 297    *40*
;  1338                 stosq                   -- mov [rdi],rax, rdi+=8
                        stosq             ;#00440865: 48:253                     np 80 81  3 299      
;  1339                 cmp rax,r15
                        cmp rax,r15       ;#00440867: 49:073307                  uv 00 8001  1 302      
;  1340                 jl @f
                        jl #00440872      ;#0044086A: 174 06                     v  00 00  1 302      
;  1341                     add qword[rbx+rax*4-16],1   -- exception should never happen (we are cloning)
                            add qword[rbx+rax*4-16],1  ;#0044086C: 48:203104203 F0 01         u  00 09  3 303      
;  1342               @@:
;  1343                 sub rcx,1
                        sub rcx,1         ;#00440872: 48:203351 01               vu 02 02  1 305      
;  1344                 jnz :opRepsSeqMRSeqAfterLoop64
                        jnz #00440863     ;#00440876: 165 EB                     v  00 00  1 306      
;  1345 
;  1346           ::opRepsPop6da64
;  1347 --------------------------
;  1348             mov rdx,[rsp+24]        -- original ref
                    mov rdx,[rsp+24]      ;#00440878: 48:213124044 18            uv 04 10  1 307      
;  1349             add rsp,48
                    add rsp,48            ;#0044087D: 48:203304 30               vu 10 10  1 307      
;  1350             cmp rdx,r15
                    cmp rdx,r15           ;#00440881: 49:073327                  uv 00 8004  1 308      
;  1351             jle @f
                    jle #00440892         ;#00440884: 176 0C                     v  00 00  1 308      
;  1352                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#00440886: 48:203154223 F0 01         u  00 0C  3 309      
;  1353                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0044088C: 017204 481A0000            v  00 00  1 311      
;  1354           @@:
;  1355             ret
                    ret                   ;#00440892: 303                        np 00 00  2 312      
;  1356       
;  1357       ::opRepsStr64
;  1358 -------------------
;  1359         --
;  1360         --  al: type byte ([rsi-1]) (#82 [actually: has bit #80 but !=#80])
;  1361         --  rcx: slice length [also in rsp+8]
;  1362         --  rdx: ref length [also in rsp]
;  1363         --  rdi: rep ref (unknown type)
;  1364         --  rsi: raw(ref) (a string)
;  1365         --  [rsp] ref length
;  1366         --  [rsp+8] slice length
;  1367         --  [rsp+16] slice start (0-based)
;  1368         --  [rsp+24] ref addr (may become original ref rsn)
;  1369         --  [rsp+32] slice end (1-based)
;  1370         --  [rsp+40] rep ref
;  1371         --  [rsp+48] return addr
;  1372         --
;  1373         cmp al,0x82
                cmp al,#82                ;#00440893: 200370 82                  uv 00 01  1 314      
;  1374         jne :e04atsaa24 -- cannot happen? (unless type byte is corrupt)
                jne #00440523             ;#00440896: 017205 87FCFFFF            v  00 00  1 314      
;  1375         --
;  1376         -- check for insitu replacement
;  1377         --
;  1378         cmp dword[rsi-16],1
                cmp dword[rsi-16],1       ;#0044089C: 203176 F0 01               u  00 40  2 315      
;  1379         jne :opRepsStrMultiRef64
                jne #00440968             ;#004408A0: 017205 C2000000            v  00 00  1 316      
;  1380         --
;  1381         -- which is ok for chars...
;  1382         --
;  1383         cmp rdi,r15
                cmp rdi,r15               ;#004408A6: 49:073377                  uv 00 8080  1 317      
;  1384         jge @f
                jge #004408D2             ;#004408A9: 175 27                     v  00 00  1 317      
;  1385             cmp rcx,0               -- check for zero length slice replacement
                    cmp rcx,0             ;#004408AB: 48:203371 00               uv 00 02  1 318      
;  1386             je :opRepsPop664        -- do nothing case
                    je #00440676          ;#004408AF: 017204 C1FDFFFF            v  00 00  1 318      
;  1387             cmp rdi,#FF
                    cmp rdi,255           ;#004408B5: 48:201377 FF000000         uv 00 80  1 319      
;  1388             ja :opRepsStrToSeqA64   -- also jumps for -ve & non-int
                    ja #0044090A          ;#004408BC: 167 4C                     v  00 00  1 319      
;  1389 --          mov rdi,-1
;  1390 --          add rsi,[rsp+16]        -- slice start (0-based)
;  1391             mov rdi,[rsp+16]        -- slice start (0-based)
                    mov rdi,[rsp+16]      ;#004408BE: 48:213174044 10            uv 80 10  1 320      
;  1392 --          mov rax,rdi
;  1393             mov rax,[rsp+40]
                    mov rax,[rsp+40]      ;#004408C3: 48:213104044 28            vu 01 10  1 320      
;  1394             add rdi,rsi
                    add rdi,rsi           ;#004408C8: 48:001367                  uv 80 C0  1 321      
;  1395 --          lea rdi,[rsi+rdx-1]
;  1396             rep stosb
                    rep stosb             ;#004408CB: 363:252                    np 82 83  3 324    *80*
;  1397             jmp :opRepsPop664
                    jmp #00440676         ;#004408CD: 351 A4FDFFFF               v  00 00  1 327      
;  1398       @@:
;  1399         --
;  1400         -- .. and strings of the same length
;  1401         --
;  1402         cmp byte[rbx+rdi*4-1],0x82
                cmp byte[rbx+rdi*4-1],#82  ;#004408D2: 200174273 FF 82            u  00 88  2 330    *80*
;  1403         jne @f
                jne #004408FA             ;#004408D7: 165 21                     v  00 00  1 331      
;  1404             cmp qword[rbx+rdi*4-24],rcx
                    cmp [rbx+rdi*4-24],rcx  ;#004408D9: 48:071114273 E8            uv 00 8A  2 332      
;  1405             jne :opRepsStrSeqL64
                    jne #004409C7         ;#004408DE: 017205 E3000000            v  00 00  1 333      
;  1406             shl rdi,2
                    shl rdi,2             ;#004408E4: 48:301347 02               u  80 80  1 334      
;  1407 --          mov rdx,[rsp+24]        -- slice start
;  1408             mov rdx,[rsp+16]        -- slice start (0-based)
                    mov rdx,[rsp+16]      ;#004408E8: 48:213124044 10            vu 04 10  1 334      
;  1409             xchg rsi,rdi
                    xchg rsi,rdi          ;#004408ED: 48:207376                  np C0 C0  3 335      
;  1410 --DEV see above?
;  1411 --          lea rdi,[rdi+rdx-1]
;  1412             add rdi,rdx
                    add rdi,rdx           ;#004408F0: 48:001327                  uv 80 84  1 338      
;  1413             rep movsb
                    rep movsb             ;#004408F3: 363:244                    np C2 C2  4 341    *80*
;  1414             jmp :opRepsPop664
                    jmp #00440676         ;#004408F5: 351 7CFDFFFF               v  00 00  1 345      
;  1415 
;  1416       @@:
;  1417         cmp byte[rbx+rdi*4-1],0x80
                cmp byte[rbx+rdi*4-1],#80  ;#004408FA: 200174273 FF 80            u  00 88  2 348    *80*
;  1418         je :opRepsStrSeqL64
                je #004409C7              ;#004408FF: 017204 C2000000            v  00 00  1 349      
;  1419       ::opRepsStrToSeqAtom64
;  1420         add qword[rbx+rdi*4-16],rcx -- bulk ref update (float)
                add [rbx+rdi*4-16],rcx    ;#00440905: 48:001114273 F0            uv 00 8A  3 350      
;  1421 
;  1422       ::opRepsStrToSeqA64
;  1423 -------------------------
;  1424         --
;  1425         -- replacement (rdi) is atom, but we must create a sequence (same length as original)
;  1426         --
;  1427         cmp rcx,0                   -- check for zero length slice replacement
                cmp rcx,0                 ;#0044090A: 48:203371 00               vu 00 02  1 352      
;  1428         je :opRepsPop664            -- do nothing case
                je #00440676              ;#0044090E: 017204 62FDFFFF            v  00 00  1 353      
;  1429         mov rcx,rdx                 -- new length == original length
                mov rcx,rdx               ;#00440914: 48:213312                  uv 02 04  1 354      
;  1430 --      mov rdx,[rsp+24]            -- ref addr
;  1431         mov rdi,[rsp+24]            -- ref addr
                mov rdi,[rsp+24]          ;#00440917: 48:213174044 18            vu 80 10  1 354      
;  1432 --      push rdi                    --[7]
;  1433         mov rdx,[rsp+48]            -- era
                mov rdx,[rsp+48]          ;#0044091C: 48:213124044 30            uv 04 10  1 355      
;  1434         call :%pAllocSeq            -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440921: 350 22180000               v  00 00  1 355      
;  1435 --      mov rdi,[rdx]
;  1436         mov rdx,[rdi]
                mov rdx,[rdi]             ;#00440926: 48:213027                  uv 04 80  1 356      
;  1437 --      mov [rdx],rax               -- Replace the ref at the original address
;  1438         mov [rdi],rax               -- Replace the ref at the original address
                mov [rdi],rax             ;#00440929: 48:211007                  vu 00 81  1 356      
;  1439 -->     mov [rsp+32],rdi            -- decref/dealloc at end (opRepsPop6da64)
;  1440 --      mov [rsp+24],rdi            -- decref/dealloc at end (opRepsPop6da64)
;  1441         mov [rsp+24],rdx            -- decref/dealloc at end (opRepsPop6da64)
                mov [rsp+24],rdx          ;#0044092C: 48:211124044 18            uv 00 14  1 357      
;  1442 --      mov rdx,rax
;  1443         mov rdx,[rsp+16]            -- slice start, 0-based
                mov rdx,[rsp+16]          ;#00440931: 48:213124044 10            vu 04 10  1 357      
;  1444         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#00440936: 48:215074203               uv 80 09  1 358      
;  1445 --      add rdx,[rsp+24]
;  1446 --      add rdx,[rsp+16]            -- slice start, 0-based
;  1447         mov rcx,[rsp]               -- source ref length
                mov rcx,[rsp]             ;#0044093A: 48:213014044               vu 02 10  1 358      
;  1448 --      shl edx,2                   -- (lea edx,newseq[slice start], doing both ref->raw and idx->dwords at the same time)
;  1449         shl rdx,3                   -- idx->qwords
                shl rdx,3                 ;#0044093E: 48:301342 03               u  04 04  1 359      
;  1450         shl rax,2                   -- ref->raw
                shl rax,2                 ;#00440942: 48:301340 02               u  01 01  1 360      
;  1451         add rdx,rax                 -- (lea edx,newseq[slice start])
                add rdx,rax               ;#00440946: 48:001302                  uv 04 05  1 361 01   
;  1452         xor eax,eax
                xor eax,eax               ;#00440949: 061300                     vu 01 01  1 361      
;  1453       @@:
;  1454             lodsb                   -- mov al,[rsi], rsi+=1
                    lodsb                 ;#0044094B: 254                        np 41 40  2 362      
;  1455             stosq                   -- mov [rdi],rax, rdi+=8
                    stosq                 ;#0044094C: 48:253                     np 80 81  3 364      
;  1456             sub rcx,1
                    sub rcx,1             ;#0044094E: 48:203351 01               uv 02 02  1 367      
;  1457             jnz @b
                    jnz #0044094B         ;#00440952: 165 F7                     v  00 00  1 367      
;  1458 
;  1459         mov rdi,rdx                 -- newseq[slicestart]
                mov rdi,rdx               ;#00440954: 48:213372                  uv 80 04  1 368      
;  1460 --      pop eax                     --[7]
;  1461         mov rax,[rsp+40]            -- rep ref (already incref'd)
                mov rax,[rsp+40]          ;#00440957: 48:213104044 28            vu 01 10  1 368      
;  1462         mov rcx,[rsp+8]             -- slice len
                mov rcx,[rsp+8]           ;#0044095C: 48:213114044 08            uv 02 10  1 369      
;  1463         rep stosd
                rep stosd                 ;#00440961: 363:253                    np 82 83  3 371    *80*
;  1464         jmp :opRepsPop6da64
                jmp #00440878             ;#00440963: 351 10FFFFFF               v  00 00  1 374      
;  1465 
;  1466       ::opRepsStrMultiRef64
;  1467 ---------------------------
;  1468         --
;  1469         --  al: type byte ([rsi-1]) (#82)
;  1470         --  rcx: slice length [also in rsp+8]
;  1471         --  rdx: ref length [also in rsp]
;  1472         --  rdi: rep ref (unknown type)
;  1473         --  rsi: raw(ref) (a string)
;  1474         --  [rsp] ref length
;  1475         --  [rsp+8] slice length
;  1476         --  [rsp+16] slice start (0-based)
;  1477         --  [rsp+24] ref addr (may become original ref rsn)
;  1478         --  [rsp+32] slice end (1-based)
;  1479         --  [rsp+40] rep ref
;  1480         --  [rsp+48] return addr
;  1481         --
;  1482         --
;  1483         -- if the replacement is a char or a string or a 0-length dword-sequence, then result is string
;  1484         --
;  1485         cmp rdi,r15
                cmp rdi,r15               ;#00440968: 49:073377                  uv 00 8080  1 375      
;  1486         jg @f
                jg #004409BC              ;#0044096B: 177 4F                     v  00 00  1 375      
;  1487             cmp rcx,0                   -- check for zero length slice replacement
                    cmp rcx,0             ;#0044096D: 48:203371 00               uv 00 02  1 376      
;  1488             je :opRepsPop664            -- do nothing case
                    je #00440676          ;#00440971: 017204 FFFCFFFF            v  00 00  1 376      
;  1489             cmp rdi,#FF                 -- also jumps for -ve & non-int
                    cmp rdi,255           ;#00440977: 48:201377 FF000000         uv 00 80  1 377      
;  1490             ja :opRepsStrToSeqA64
                    ja #0044090A          ;#0044097E: 167 8A                     v  00 00  1 377      
;  1491             mov rcx,rdx                 -- same length as original
                    mov rcx,rdx           ;#00440980: 48:213312                  uv 02 04  1 378      
;  1492             mov rdx,[rsp+24]            -- ref addr
                    mov rdx,[rsp+24]      ;#00440983: 48:213124044 18            vu 04 10  1 378      
;  1493             call :%pAllocStr            -- damages rax only
                    call #004420E3 (:%pAllocStr)  ;#00440988: 350 56170000               v  00 00  1 379      
;  1494             mov [rdx],rax               -- Replace the ref at the original address
                    mov [rdx],rax         ;#0044098D: 48:211002                  uv 00 05  1 382    *04*
;  1495             sub qword[rsi-16],1         -- non-1 so no need to dealloc
                    sub qword[rsi-16],1   ;#00440990: 48:203156 F0 01            u  00 40  3 383      
;  1496             xchg rax,rdi
                    xchg rax,rdi          ;#00440995: 48:227                     np 81 81  2 386      
;  1497             mov rdx,[rsp+16]            -- slice start (0-based)
                    mov rdx,[rsp+16]      ;#00440997: 48:213124044 10            uv 04 10  1 388      
;  1498             shl rdi,2
                    shl rdi,2             ;#0044099C: 48:301347 02               u  80 80  1 389      
;  1499             mov rcx,[rsp]               -- original source length (all of it)
                    mov rcx,[rsp]         ;#004409A0: 48:213014044               vu 02 10  1 389      
;  1500             add rdx,rdi                 -- (lea edx,newstr[slicestart])
                    add rdx,rdi           ;#004409A4: 48:001372                  uv 04 84  1 390      
;  1501             add rcx,1                   -- and the trailing null
                    add rcx,1             ;#004409A7: 48:203301 01               vu 02 02  1 390      
;  1502             rep movsb
                    rep movsb             ;#004409AB: 363:244                    np C2 C2  4 391      
;  1503             mov rdi,rdx
                    mov rdi,rdx           ;#004409AD: 48:213372                  uv 80 04  1 395      
;  1504             mov rcx,[rsp+8]             -- slice length (go over middle bit)
                    mov rcx,[rsp+8]       ;#004409B0: 48:213114044 08            vu 02 10  1 395      
;  1505             rep stosb
                    rep stosb             ;#004409B5: 363:252                    np 82 83  3 398    *80*
;  1506             jmp :opRepsPop664
                    jmp #00440676         ;#004409B7: 351 BAFCFFFF               v  00 00  1 401      
;  1507       @@:
;  1508         cmp byte[rbx+rdi*4-1],0x12
                cmp byte[rbx+rdi*4-1],#12  ;#004409BC: 200174273 FF 12            u  00 88  2 404    *80*
;  1509         je :opRepsStrToSeqAtom64
                je #00440905              ;#004409C1: 017204 3EFFFFFF            v  00 00  1 405      
;  1510       ::opRepsStrSeqL64
;  1511         -- calculate required size (whether it needs to be a string or dword-sequence)
;  1512         add rdx,qword[rbx+rdi*4-24] -- original plus replacement length..
                add rdx,[rbx+rdi*4-24]    ;#004409C7: 48:003124273 E8            uv 04 8C  2 406      
;  1513 --      lea rax,[rbx+rdi*4]         -- may as well
;  1514 -->     sub qword[rsi-16],1         -- non-1 so no need to dealloc (no, use opRepsPop6da)
;  1515         sub rdx,qword[rsp+8]        -- ..minus slice length
                sub rdx,[rsp+8]           ;#004409CC: 48:053124044 08            uv 04 14  2 408 04   
;  1516         mov rcx,rdx                 -- new length
                mov rcx,rdx               ;#004409D1: 48:213312                  uv 02 04  1 410 04   
;  1517         mov rdx,[rsp+24]            -- ref addr
                mov rdx,[rsp+24]          ;#004409D4: 48:213124044 18            vu 04 10  1 410      
;  1518         cmp qword[rbx+rdi*4-24],0   -- replacement length 0?
                cmp qword[rbx+rdi*4-24],0  ;#004409D9: 48:203174273 E8 00         u  00 88  2 411      
;  1519         je :opRepsStrStr64
                je #004409E8              ;#004409DF: 164 07                     v  00 00  1 412      
;  1520         cmp byte[rbx+rdi*4-1],0x80
                cmp byte[rbx+rdi*4-1],#80  ;#004409E1: 200174273 FF 80            u  00 88  2 413      
;  1521         je :opRepsStrSeq64
                je #00440A34              ;#004409E6: 164 4C                     v  00 00  1 414      
;  1522 
;  1523       ::opRepsStrStr64
;  1524 ----------------------
;  1525         --
;  1526         -- string[i..j]:=string
;  1527         -- new string (size already calculated), built in chunks
;  1528         --
;  1529         call :%pAllocStr            -- damages rax only
                call #004420E3 (:%pAllocStr)  ;#004409E8: 350 F6160000               v  00 00  1 415      
;  1530         mov rdi,[rdx]
                mov rdi,[rdx]             ;#004409ED: 48:213072                  uv 80 04  1 416      
;  1531         mov [rsp+24],rdi            -- now becomes ref to decref at end
                mov [rsp+24],rdi          ;#004409F0: 48:211174044 18            uv 00 90  1 417 80   
;  1532         mov [rdx],rax               -- Replace the ref at the original address
                mov [rdx],rax             ;#004409F5: 48:211002                  vu 00 05  1 417      
;  1533         --
;  1534         -- duplicate original items before the slice
;  1535         -- (and set rdx,rax for later use, to avoid AGI stalls)
;  1536         --
;  1537         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#004409F8: 48:215074203               uv 80 09  1 418      
;  1538         mov rdx,[rsp+32]            -- slice end (1-based)
                mov rdx,[rsp+32]          ;#004409FC: 48:213124044 20            vu 04 10  1 418      
;  1539         mov rcx,[rsp+16]            -- slice start (0-based)
                mov rcx,[rsp+16]          ;#00440A01: 48:213114044 10            uv 02 10  1 419      
;  1540         mov rax,[rsp+40]            -- rep ref (a string)
                mov rax,[rsp+40]          ;#00440A06: 48:213104044 28            vu 01 10  1 419      
;  1541         add rdx,rsi                 -- (lea rdx,[rsi+sliceend+1])
                add rdx,rsi               ;#00440A0B: 48:001362                  uv 04 44  1 420      
;  1542         shl rax,2                   -- (lea rax,[rep[1]])
                shl rax,2                 ;#00440A0E: 48:301340 02               u  01 01  1 421      
;  1543         rep movsb
                rep movsb                 ;#00440A12: 363:244                    np C2 C2  4 422      
;  1544         --
;  1545         -- duplicate the replacement string
;  1546         --
;  1547         mov rsi,rax
                mov rsi,rax               ;#00440A14: 48:213360                  uv 40 01  1 426      
;  1548         mov rcx,[rax-24]            -- replacement length
                mov rcx,[rax-24]          ;#00440A17: 48:213110 E8               vu 02 01  1 426      
;  1549         rep movsb
                rep movsb                 ;#00440A1B: 363:244                    np C2 C2  4 429    *40*
;  1550         --
;  1551         -- duplicate remaining original items
;  1552         --
;  1553         mov rcx,[rsp]           -- ref length
                mov rcx,[rsp]             ;#00440A1D: 48:213014044               uv 02 10  1 433      
;  1554         mov rsi,rdx
                mov rsi,rdx               ;#00440A21: 48:213362                  vu 40 04  1 433      
;  1555         sub rcx,[rsp+32]        -- minus slice end (1-based)
                sub rcx,[rsp+32]          ;#00440A24: 48:053114044 20            uv 02 12  2 434      
;  1556 --added 16/2/15:
;  1557         add rcx,1               -- include terminating null
                add rcx,1                 ;#00440A29: 48:203301 01               uv 02 02  1 436 02   
;  1558         rep movsb
                rep movsb                 ;#00440A2D: 363:244                    np C2 C2  4 437      
;  1559         jmp :opRepsPop6da64
                jmp #00440878             ;#00440A2F: 351 44FEFFFF               v  00 00  1 441      
;  1560 
;  1561       ::opRepsStrSeq64
;  1562 ----------------------
;  1563         --
;  1564         --  al: type byte ([rsi-1]) (#82)
;  1565         --  rcx: slice length [also in rsp+8]
;  1566 --X     --  rdx: ref length [also in rsp]
;  1567         --  rdx: ref addr
;  1568         --  rdi: rep ref (a dword-sequence, of non-0 length)
;  1569         --  rsi: raw(ref) (a string)
;  1570         --  [rsp] ref length
;  1571         --  [rsp+8] slice length
;  1572         --  [rsp+16] slice start (0-based)
;  1573         --  [rsp+24] ref addr (becomes original ref rsn)
;  1574         --  [rsp+32] slice end (1-based)
;  1575         --  [rsp+40] rep ref
;  1576         --  [rsp+48] return addr
;  1577         --
;  1578         --
;  1579         -- string[i..j]:=dword_sequence
;  1580         -- new sequence (size already calculated), built in chunks
;  1581         --
;  1582         mov rdi,rdx
                mov rdi,rdx               ;#00440A34: 48:213372                  uv 80 04  1 442      
;  1583         mov rdx,[rsp+48]        -- era
                mov rdx,[rsp+48]          ;#00440A37: 48:213124044 30            vu 04 10  1 442      
;  1584         call :%pAllocSeq        -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#00440A3C: 350 07170000               v  00 00  1 443      
;  1585 --      mov rdi,[rdx]
;  1586         mov rdx,[rdi]
                mov rdx,[rdi]             ;#00440A41: 48:213027                  uv 04 80  1 444      
;  1587 --      mov [rsp+24],rdi        -- now becomes ref to dealloc at end
;  1588         mov [rsp+24],rdx        -- now becomes ref to dealloc at end
                mov [rsp+24],rdx          ;#00440A44: 48:211124044 18            uv 00 14  1 445 04   
;  1589 --      mov [rdx],rax           -- Replace the ref at the original address
;  1590         mov [rdi],rax           -- Replace the ref at the original address
                mov [rdi],rax             ;#00440A49: 48:211007                  vu 00 81  1 445      
;  1591 
;  1592         --
;  1593         -- duplicate original chars before the slice as dwords
;  1594         -- (and set rdx for later use, to avoid an AGI stall)
;  1595         --
;  1596         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#00440A4C: 48:215074203               uv 80 09  1 446      
;  1597         mov rcx,[rsp+16]        -- slice start (0-based)
                mov rcx,[rsp+16]          ;#00440A50: 48:213114044 10            vu 02 10  1 446      
;  1598         mov rdx,[rsp+40]        -- rep ref (a sequence)
                mov rdx,[rsp+40]          ;#00440A55: 48:213124044 28            uv 04 10  1 447      
;  1599         test rcx,rcx
                test rcx,rcx              ;#00440A5A: 48:205311                  vu 00 02  1 447      
;  1600         jz @f
                jz #00440A6B              ;#00440A5D: 164 0C                     v  00 00  1 448      
;  1601             xor rax,rax
                    xor rax,rax           ;#00440A5F: 48:061300                  uv 01 01  1 449      
;  1602       ::opRepsStrSeqBeforeLoop64
;  1603             lodsb               -- mov al,[rsi], rsi+=1
                    lodsb                 ;#00440A62: 254                        np 41 40  2 450      
;  1604             stosq               -- mov [rdi],rax, rdi+=8
                    stosq                 ;#00440A63: 48:253                     np 80 81  3 452      
;  1605             sub rcx,1
                    sub rcx,1             ;#00440A65: 48:203351 01               uv 02 02  1 455      
;  1606             jnz :opRepsStrSeqBeforeLoop64
                    jnz #00440A62         ;#00440A69: 165 F7                     v  00 00  1 455      
;  1607 
;  1608       @@:
;  1609         --
;  1610         -- duplicate replacement sequence contents
;  1611         -- (and save rsi in rdx for later use)
;  1612         --
;  1613         mov rax,rsi
                mov rax,rsi               ;#00440A6B: 48:213306                  uv 01 40  1 456      
;  1614         lea rsi,[rbx+rdx*4]
                lea rsi,[rbx+rdx*4]       ;#00440A6E: 48:215064223               vu 40 0C  1 456      
;  1615         mov rcx,[rbx+rdx*4-24]  -- rep length
                mov rcx,[rbx+rdx*4-24]    ;#00440A72: 48:213114223 E8            uv 02 0C  1 457      
;  1616         mov rdx,rax
                mov rdx,rax               ;#00440A77: 48:213320                  vu 04 01  1 457      
;  1617       ::opRepsStrSeqMidLoop64
;  1618             lodsq               -- mov rax,[rsi], rsi+=8
                    lodsq                 ;#00440A7A: 48:255                     np 41 40  2 458      
;  1619             stosq               -- mov [rdi],rax, rdi+=8
                    stosq                 ;#00440A7C: 48:253                     np 80 81  3 460      
;  1620             cmp rax,r15
                    cmp rax,r15           ;#00440A7E: 49:073307                  uv 00 8001  1 463      
;  1621             jl @f
                    jl #00440A89          ;#00440A81: 174 06                     v  00 00  1 463      
;  1622                 add qword[rbx+rax*4-16],1   -- exception should never happen (we are cloning)
                        add qword[rbx+rax*4-16],1  ;#00440A83: 48:203104203 F0 01         u  00 09  3 464      
;  1623           @@:
;  1624             sub rcx,1
                    sub rcx,1             ;#00440A89: 48:203351 01               vu 02 02  1 466      
;  1625             jnz :opRepsStrSeqMidLoop64
                    jnz #00440A7A         ;#00440A8D: 165 EB                     v  00 00  1 467      
;  1626 
;  1627 --    ::opRepsStrSeqMidDone64
;  1628 -----------------------------
;  1629         --
;  1630         -- duplicate remaining original items
;  1631         --
;  1632         mov rsi,rdx
                mov rsi,rdx               ;#00440A8F: 48:213362                  uv 40 04  1 468      
;  1633         mov rcx,[rsp]           -- ref length
                mov rcx,[rsp]             ;#00440A92: 48:213014044               vu 02 10  1 468      
;  1634         add rsi,[rsp+8]         -- slice length
                add rsi,[rsp+8]           ;#00440A96: 48:003164044 08            uv 40 50  2 469      
;  1635         sub rcx,[rsp+32]        -- minus slice end (1-based)
                sub rcx,[rsp+32]          ;#00440A9B: 48:053114044 20            vu 02 12  2 470      
;  1636         jz :opRepsPop6da64
                jz #00440878              ;#00440AA0: 017204 D2FDFFFF            v  00 00  1 471      
;  1637         xor rax,rax
                xor rax,rax               ;#00440AA6: 48:061300                  uv 01 01  1 472      
;  1638       @@:
;  1639             lodsb               -- mov al,[rsi], rsi+=1
                    lodsb                 ;#00440AA9: 254                        np 41 40  2 473      
;  1640             stosq               -- mov [rdi],rax, rdi+=8
                    stosq                 ;#00440AAA: 48:253                     np 80 81  3 475      
;  1641             sub rcx,1
                    sub rcx,1             ;#00440AAC: 48:203351 01               uv 02 02  1 478      
;  1642             jnz @b
                    jnz #00440AA9         ;#00440AB0: 165 F7                     v  00 00  1 478      
;  1643         nop
                nop                       ;#00440AB2: 220                        uv 00 00  1 479      
;  1644         jmp :opRepsPop6da64
                jmp #00440878             ;#00440AB3: 351 C0FDFFFF               v  00 00  1 479      
;  1645     []
;  1646       }
;  1647 
    jmp #0044298D (:%opRetf)              ;#00440AB8: 351 D01E0000               v  00 00  1 480      
;C:\Program Files (x86)\Phix\builtins\VM\pMkSqN.e:
;=================================================
;     1 --
;     2 -- pMkSqN.e
;     3 -- ========
;     4 --  Make Sequence opcode
;     5 --
;     6 
;     7 include builtins\VM\pHeap.e     -- (needed for :%pDealloc, :%pAllocSeq)
;     8 
;     9 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#004404B8: 351 D0240000               v  00 00  1   1      
;    10 
;    11 --/*
;    12 procedure :%pMkSq(:%)
;    13 end procedure -- (for Edita/CtrlQ)
;    14 --*/
;    15     :%pMkSq
;    16 -----------
;    17         -- calling convention:
;    18         --  mov r/edx,N
;    19         --  push <return addr>
;    20         --  push <dest addr>
;    21         --  push [eN]..[e1]     -- pre-incref'd
;    22         --  mov r/edi,[dest]    -- prev dest ref
;    23         --  jmp :%pMkSq
;    24         --<return addr>:
;    25     [32]
;    26         mov ecx,edx
;    27         mov edx,[esp+edx*4+4]   -- era
;    28         call :%pAllocSeq        -- damages eax only (needs edx set)
;    29         mov edx,edi             -- for later dealloc
;    30         lea edi,[ebx+eax*4]
;    31         mov esi,esp
;    32         lea esp,[esp+ecx*4]
;    33         rep movsd
;    34         pop esi                 -- dest addr
;    35         cmp edx,h4
;    36         jle @f
;    37             mov ecx,[ebx+edx*4-8]   -- refcount
;    38             mov [esi],eax
;    39             sub ecx,1
;    40             jz :%pDealloc
;    41             mov [ebx+edx*4-8],ecx   -- refcount
;    42             ret
;    43       @@:
;    44         mov [esi],eax
;    45     [64]
;    46 --DEV check this zero-fills on X64: [YEP] (and what regs pAllocSeq(X64) damages)
;    47 --lea rcx,[rbx-1] -- (set rcx to -1 for the following test)
;    48 --mov ecx,edx
;    49         mov rcx,rdx
                mov rcx,rdx               ;#004404BD: 48:213312                  uv 02 04  1   2      
;    50 --sub rsp,8*5? (if N is odd/even may need an aligning push/pop on the call)
;    51         mov rdx,[rsp+rdx*8+8]   -- era
                mov rdx,[rsp+rdx*8+8]     ;#004404C0: 48:213124324 08            vu 04 14  1   2      
;    52         call :%pAllocSeq        -- damages eax[DEV?] only (needs edx set)
                call #00442148 (:%pAllocSeq)  ;#004404C5: 350 7E1C0000               v  00 00  1   3      
;    53 -- (damages rax/r8/r9/r10/r11/r13/r15 [at least])
;    54         mov rdx,rdi             -- for later dealloc
                mov rdx,rdi               ;#004404CA: 48:213327                  uv 04 80  1   4      
;    55         lea rdi,[rbx+rax*4]     -- (yes that is a *4, ref->raw)
                lea rdi,[rbx+rax*4]       ;#004404CD: 48:215074203               vu 80 09  1   4      
;    56         mov rsi,rsp
                mov rsi,rsp               ;#004404D1: 48:213364                  uv 40 10  1   5      
;    57         lea rsp,[rsp+rcx*8]
                lea rsp,[rsp+rcx*8]       ;#004404D4: 48:215044314               vu 10 12  1   5      
;    58         rep movsq
                rep movsq                 ;#004404D8: 363:48:245                 np C2 C2  4   8    *40*
;    59         mov r15,h4
                mov r15,h4                ;#004404DB: 49:277 0000000000000040    uv 8000 00  1  12      
;    60         pop rsi                 -- dest addr
                pop rsi                   ;#004404E5: 48:136                     vu 40 00  1  12      
;    61 --      cmp rdx,h4
;    62         cmp rdx,r15
                cmp rdx,r15               ;#004404E7: 49:073327                  uv 00 8004  1  13      
;    63         jle @f
                jle #00440504             ;#004404EA: 176 18                     v  00 00  1  13      
;    64             mov rcx,[rbx+rdx*4-16]  -- refcount
                    mov rcx,[rbx+rdx*4-16]  ;#004404EC: 48:213114223 F0            uv 02 0C  1  14      
;    65             mov [rsi],rax
                    mov [rsi],rax         ;#004404F1: 48:211006                  vu 00 41  1  14      
;    66             sub rcx,1
                    sub rcx,1             ;#004404F4: 48:203351 01               uv 02 02  1  15      
;    67             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#004404F8: 017204 DC1D0000            v  00 00  1  15      
;    68             mov [rbx+rdx*4-16],rcx  -- refcount
                    mov [rbx+rdx*4-16],rcx  ;#004404FE: 48:211114223 F0            uv 00 0E  1  16      
;    69             ret
                    ret                   ;#00440503: 303                        np 00 00  2  17      
;    70       @@:
;    71         mov [rsi],rax
                mov [rsi],rax             ;#00440504: 48:211006                  uv 00 41  1  19      
;    72     []
;    73         ret
                ret                       ;#00440507: 303                        np 00 00  2  20      
;    74       }
;    75 
    jmp #0044298D (:%opRetf)              ;#00440508: 351 80240000               v  00 00  1  22      
;C:\Program Files (x86)\Phix\builtins\VM\pApnd.e:
;================================================
;     1 --
;     2 -- pApnd.e
;     3 -- =======
;     4 --
;     5 --  Implements :%opApnd (append()/prepend()), opConcat(&), opConcatN, and opCatsi.
;     6 --
;     7 --  The latter two are optimised forms of opConcat, respectively for the a&b&c[&...] 
;     8 --  case, and when concatenating sequences of integer, so refcounting can be avoided.
;     9 --
;    10 
;    11 -- Note: originally commented as a = append(b,c), if you find any such references
;    12 --       remaining, map them to p1 = append(p2,p3) (pretty please)
;    13 
;    14 -- Technical note: As per pfileioN.e, append guarantees to have all content in place
;    15 --                  before the ref is updated. Similar does NOT apply to prepend or
;    16 --                  concat. (see "Multithreading issues" in pfileioN.e)
;    17 
;    18 include VM\pHeap.e  -- :%pDealloc/:%pAllocSeq/:%pAllocStr/:%pFreePool
;    19 
;    20 
;    21 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043FC0F: 351 792D0000               v  00 00  1   1      
;    22 
;    23 --DEV fixme... (new error code, unknown type byte [internal error])
;    24  ::eNNunknown
;    25     int3
            int3                          ;#0043FC14: 314                        np 00 00 13   2      
;    26 
;    27 --/*
;    28 procedure :%opApnd(:%)
;    29 end procedure -- (for Edita/CtrlQ)
;    30 --*/
;    31     :%opApnd                    -- p1=append/prepend(p2,p3); also several p1=p2&p3 cases, see opConcat
;    32 ------------
;    33     [32]
;    34         --calling convention (p1 = append/prepend(p2,p3))
;    35         --  lea edx,[p1]
;    36         --  lea edi,[p2]    (opUnassigned)???[DEV]
;    37         --  lea ecx,[p3]    (opUnassigned)
;    38         --  mov eax,0       or 1 for prepend
;    39         --  call :%opApnd               -- [edx]=append([edi],[ecx])
;    40         push eax    -- flag@[esp+12] (1=prepend, 0=append)
;    41         push ecx    -- addr p3@[esp+8]
;    42         push edi    -- addr p2@[esp+4]
;    43         push edx    -- addr p1@[esp]
;    44         mov esi,[edi]           -- ref of p2
;    45         mov ecx,[ecx]           -- ref of p3
;    46     ::opApndA   -- (entry point for p1=p2&p3 -> p1=append(p2,p3) when p3 atom.)
;    47         cmp esi,h4
;    48 --      jl e55fatambs           -- first argument to append must be sequence (remove me)
;    49         jl :ApndNewSeq2
;    50     :%opPpndSA  -- (entry point for p1=p2&p3 -> p1=prepend(p3,p2) when p2 atom, see ppMap below.)
;    51                 -- exception here mapped to e93vhnbaav(edi)
;    52         mov al,[ebx+esi*4-1]    -- type byte
;    53         mov edx,[ebx+esi*4-12]  -- length
;    54         cmp al,0x12
;    55         je :ApndNewSeq2
;    56         shl esi,2
;    57         
;    58         cmp al,0x80
;    59         je :ApndSeq
;    60         cmp al,0x82
;    61         jne :eNNunknown
;    62         cmp ecx,#FF
;    63         ja :ApndExpandString    -- (if not #00..#FF)
;    64         mov eax,ecx             -- save char
;    65         cmp dword[esi-8],1      -- check ref count of 1
;    66         jne :ApndNewStr
;    67         cmp dword[esp+12],0     -- (check prepend flag)
;    68         jne :ApndNewStr         -- (prepend must create a new string)   [the old opPpnd did it in situ, but I doubt that gains any]
;    69         cmp edi,[esp]           -- must also be pbr-optimise (x=append(x,y))
;    70         jne :ApndNewStr         --  (we already know it is not circular, ie not x=append(x,x), 
;    71                                 --   as p3 is a char here, and p1(==p2) is a string)
;    72         lea ecx,[edx+16+1]
;    73 --  mov edi,[esi-20]        -- slack (at start/left)
;    74 --  sub ecx,edi     -- DOH! no slack on strings!
;    75         cmp ecx,[esi-16]        -- maxlen
;    76         je :ApndNewStr          -- and have space/check maxlen
;    77         -- (jge would also be fine, though it will/shd never be g)
;    78         -- so expand string by one char in situ:
;    79         lea ecx,[edx+1]
;    80         mov word[esi+edx],ax    -- includes a new trailing null
;    81         mov [esi-12],ecx        -- increase length
;    82         add esp,16
;    83         ret
;    84     [64]
;    85         --calling convention (p1 = append/prepend(p2,p3))
;    86         --  lea rdx,[p1]
;    87         --  lea rdi,[p2]    (opUnassigned)
;    88         --  lea rcx,[p3]    (opUnassigned)
;    89         --  mov rax,0       or 1 for prepend
;    90         --  call :%opApnd               -- [rdx]=append([rdi],[rcx])
;    91         push rax    -- flag@[rsp+24] (1=prepend, 0=append)
                push rax                  ;#0043FC15: 48:120                     uv 00 01  1  15      
;    92         push rcx    -- p3@[rsp+16]
                push rcx                  ;#0043FC17: 48:121                     vu 00 02  1  15      
;    93         push rdi    -- p2@[rsp+8]
                push rdi                  ;#0043FC19: 48:127                     uv 00 80  1  16      
;    94         push rdx    -- p1@[rsp]
                push rdx                  ;#0043FC1B: 48:122                     vu 00 04  1  16      
;    95         mov rsi,[rdi]           -- ref of p2
                mov rsi,[rdi]             ;#0043FC1D: 48:213067                  uv 40 80  1  17      
;    96         mov rcx,[rcx]           -- ref of p3
                mov rcx,[rcx]             ;#0043FC20: 48:213011                  vu 02 02  1  17      
;    97     ::opApndA   -- (entry point for p1=p2&p3 -> p1=append(p2,p3) when p3 atom.)
;    98         mov r15,h4
                mov r15,h4                ;#0043FC23: 49:277 0000000000000040    uv 8000 00  1  18      
;    99         cmp rsi,r15
                cmp rsi,r15               ;#0043FC2D: 49:073367                  uv 00 8040  1  19 8000   
;   100 --      jl e55fatambs           -- first argument to append must be sequence (remove me)
;   101         jl :ApndNewSeq2
                jl #0043FCA2              ;#0043FC30: 174 70                     v  00 00  1  19      
;   102     :%opPpndSA  -- (entry point for p1=p2&p3 -> p1=prepend(p3,p2) when p2 atom, see ppMap below.)
;   103                 -- exception here mapped to e93vhnbaav(rdi)
;   104         mov al,[rbx+rsi*4-1]    -- type byte
                mov al,[rbx+rsi*4-1]      ;#0043FC32: 212104263 FF               uv 01 48  1  20      
;   105         mov rdx,[rbx+rsi*4-24]  -- length
                mov rdx,[rbx+rsi*4-24]    ;#0043FC36: 48:213124263 E8            vu 04 48  1  20      
;   106         cmp al,0x12
                cmp al,#12                ;#0043FC3B: 200370 12                  uv 00 01  1  21      
;   107         je :ApndNewSeq2
                je #0043FCA2              ;#0043FC3E: 164 62                     v  00 00  1  21      
;   108         shl rsi,2
                shl rsi,2                 ;#0043FC40: 48:301346 02               u  40 40  1  22      
;   109         
;   110         cmp al,0x80
                cmp al,#80                ;#0043FC44: 200370 80                  vu 00 01  1  22      
;   111         je :ApndSeq
                je #0043FE10              ;#0043FC47: 017204 C3010000            v  00 00  1  23      
;   112         cmp al,0x82
                cmp al,#82                ;#0043FC4D: 200370 82                  uv 00 01  1  24      
;   113         jne :eNNunknown
                jne #0043FC14             ;#0043FC50: 165 C2                     v  00 00  1  24      
;   114         cmp rcx,#FF
                cmp rcx,255               ;#0043FC52: 48:201371 FF000000         uv 00 02  1  25      
;   115         ja :ApndExpandString    -- (if not #00..#FF)
                ja #0043FDA1              ;#0043FC59: 017207 42010000            v  00 00  1  25      
;   116         mov rax,rcx             -- save char
                mov rax,rcx               ;#0043FC5F: 48:213301                  uv 01 02  1  26      
;   117         cmp qword[rsi-16],1     -- check ref count of 1
                cmp qword[rsi-16],1       ;#0043FC62: 48:203176 F0 01            u  00 40  2  27      
;   118         jne :ApndNewStr
                jne #0043FD53             ;#0043FC67: 017205 E6000000            v  00 00  1  28      
;   119         cmp qword[rsp+24],0     -- (check prepend flag)
                cmp qword[rsp+24],0       ;#0043FC6D: 48:203174044 18 00         u  00 10  2  29      
;   120         jne :ApndNewStr         -- (prepend must create a new string)   [the old opPpnd did it in situ, but I doubt that gains any]
                jne #0043FD53             ;#0043FC73: 017205 DA000000            v  00 00  1  30      
;   121         cmp rdi,[rsp]           -- must also be pbr-optimise (x=append(x,y))
                cmp rdi,[rsp]             ;#0043FC79: 48:073074044               uv 00 90  2  31      
;   122         jne :ApndNewStr         --  (we already know it is not circular, ie not x=append(x,x), 
                jne #0043FD53             ;#0043FC7D: 017205 D0000000            v  00 00  1  32      
;   123                                 --   as p3 is a char here, and p1(==p2) is a string)
;   124         lea rcx,[rdx+32+1]
                lea rcx,[rdx+33]          ;#0043FC83: 48:215112 21               uv 02 04  1  33      
;   125 --  mov edi,[esi-20]        -- slack (at start/left)
;   126 --  sub ecx,edi     -- DOH! no slack on strings!
;   127         cmp rcx,[rsi-32]        -- maxlen
                cmp rcx,[rsi-32]          ;#0043FC87: 48:073116 E0               uv 00 42  2  34 02   
;   128         je :ApndNewStr          -- and have space/check maxlen
                je #0043FD53              ;#0043FC8B: 017204 C2000000            v  00 00  1  35      
;   129         -- (jge would also be fine, though it will/shd never be g)
;   130         -- so expand string by one char in situ:
;   131         lea rcx,[rdx+1]
                lea rcx,[rdx+1]           ;#0043FC91: 48:215112 01               uv 02 04  1  36      
;   132         mov word[rsi+rdx],ax    -- includes a new trailing null
                mov word[rsi+rdx],ax      ;#0043FC95: 146:211004026              vu 00 45  1  36      
;   133         mov [rsi-24],rcx        -- increase length
                mov [rsi-24],rcx          ;#0043FC99: 48:211116 E8               uv 00 42  1  37      
;   134         add rsp,32
                add rsp,32                ;#0043FC9D: 48:203304 20               vu 10 10  1  37      
;   135         ret
                ret                       ;#0043FCA1: 303                        np 00 00  2  38      
;   136     []
;   137 
;   138   ::ApndNewSeq2
;   139 ---------------
;   140         -- new sequence length 2 (p2 is atom)
;   141     [32]
;   142         mov edi,ecx
;   143         cmp dword[esp+12],0         -- prepend?
;   144         je @f
;   145 --      jne @f
;   146             xchg esi,edi
;   147       @@:
;   148         cmp esi,#FF
;   149         ja @f
;   150             cmp edi,#FF
;   151             jbe :ApndNewStr2
;   152       @@:
;   153         mov ecx,2
;   154         mov edx,[esp+16]            -- era
;   155         call :%pAllocSeq
;   156         mov [ebx+eax*4],esi         -- new[1]:=p2
;   157 --      mov [ebx+eax*4],edi         -- new[1]:=p2
;   158         mov edx,[esp]
;   159         cmp esi,h4
;   160         jl @f
;   161             add dword[ebx+esi*4-8],1
;   162       @@:
;   163         mov [ebx+eax*4+4],edi       -- new[2]:=p3
;   164         cmp edi,h4
;   165         jl @f
;   166             add dword[ebx+edi*4-8],1
;   167       @@:
;   168         mov ecx,[edx]
;   169         add esp,16
;   170         mov [edx],eax
;   171         cmp ecx,h4
;   172 --18/2/15!
;   173 --      jl @f
;   174         jle @f
;   175             mov edx,ecx
;   176             sub dword[ebx+ecx*4-8],1
;   177             jz :%pDealloc
;   178       @@:
;   179         ret
;   180     [64]
;   181         mov rdi,rcx
                mov rdi,rcx               ;#0043FCA2: 48:213371                  uv 80 02  1  40      
;   182         cmp qword[rsp+24],0         -- prepend?
                cmp qword[rsp+24],0       ;#0043FCA5: 48:203174044 18 00         u  00 10  2  42    *10*
;   183         je @f
                je #0043FCB0              ;#0043FCAB: 164 03                     v  00 00  1  43      
;   184 --      jne @f
;   185             xchg rsi,rdi
                    xchg rsi,rdi          ;#0043FCAD: 48:207376                  np C0 C0  3  44      
;   186       @@:
;   187         cmp rsi,#FF
                cmp rsi,255               ;#0043FCB0: 48:201376 FF000000         uv 00 40  1  47      
;   188         ja @f
                ja #0043FCC2              ;#0043FCB7: 167 09                     v  00 00  1  47      
;   189             cmp rdi,#FF
                    cmp rdi,255           ;#0043FCB9: 48:201377 FF000000         uv 00 80  1  48      
;   190             jbe :ApndNewStr2
                    jbe #0043FD15         ;#0043FCC0: 166 53                     v  00 00  1  48      
;   191       @@:
;   192         mov rcx,2
                mov rcx,2                 ;#0043FCC2: 48:307301 02000000         uv 02 00  1  49      
;   193         mov rdx,[rsp+32]            -- era
                mov rdx,[rsp+32]          ;#0043FCC9: 48:213124044 20            vu 04 10  1  49      
;   194         call :%pAllocSeq
                call #00442148 (:%pAllocSeq)  ;#0043FCCE: 350 75240000               v  00 00  1  50      
;   195         mov [rbx+rax*4],rsi         -- new[1]:=p2
                mov [rbx+rax*4],rsi       ;#0043FCD3: 48:211064203               uv 00 49  1  51      
;   196 --      mov [ebx+eax*4],edi         -- new[1]:=p2
;   197         mov rdx,[rsp]
                mov rdx,[rsp]             ;#0043FCD7: 48:213024044               vu 04 10  1  51      
;   198         cmp rsi,r15
                cmp rsi,r15               ;#0043FCDB: 49:073367                  uv 00 8040  1  52      
;   199         jl @f
                jl #0043FCE6              ;#0043FCDE: 174 06                     v  00 00  1  52      
;   200             add qword[rbx+rsi*4-16],1
                    add qword[rbx+rsi*4-16],1  ;#0043FCE0: 48:203104263 F0 01         u  00 48  3  53      
;   201       @@:
;   202         mov [rbx+rax*4+8],rdi       -- new[2]:=p3
                mov [rbx+rax*4+8],rdi     ;#0043FCE6: 48:211174203 08            vu 00 89  1  55      
;   203         cmp rdi,r15
                cmp rdi,r15               ;#0043FCEB: 49:073377                  uv 00 8080  1  56      
;   204         jl @f
                jl #0043FCF6              ;#0043FCEE: 174 06                     v  00 00  1  56      
;   205             add qword[rbx+rdi*4-16],1
                    add qword[rbx+rdi*4-16],1  ;#0043FCF0: 48:203104273 F0 01         u  00 88  3  57      
;   206       @@:
;   207         mov rcx,[rdx]
                mov rcx,[rdx]             ;#0043FCF6: 48:213012                  vu 02 04  1  59      
;   208         add rsp,32
                add rsp,32                ;#0043FCF9: 48:203304 20               uv 10 10  1  60      
;   209         mov [rdx],rax
                mov [rdx],rax             ;#0043FCFD: 48:211002                  vu 00 05  1  60      
;   210         cmp rcx,r15
                cmp rcx,r15               ;#0043FD00: 49:073317                  uv 00 8002  1  61      
;   211 --18/2/15!
;   212 --      jl @f
;   213         jle @f
                jle #0043FD14             ;#0043FD03: 176 0F                     v  00 00  1  61      
;   214             mov rdx,rcx
                    mov rdx,rcx           ;#0043FD05: 48:213321                  uv 04 02  1  62      
;   215             sub qword[rbx+rcx*4-16],1
                    sub qword[rbx+rcx*4-16],1  ;#0043FD08: 48:203154213 F0 01         u  00 0A  3  63      
;   216             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043FD0E: 017204 C6250000            v  00 00  1  65      
;   217       @@:
;   218         ret
                ret                       ;#0043FD14: 303                        np 00 00  2  66      
;   219     []
;   220     
;   221   ::ApndNewStr2
;   222 ---------------
;   223         -- new string length 2 (p2 and p3 are both #00..#FF)
;   224         --
;   225         --  (you could probably drop this if it causes any problems, just
;   226         --   as long as you also document append(chr,chr)->dword_sequence; 
;   227         --   it was more because of that not really sounding quite right, 
;   228         --   as opposed to it being clearly wrong, that this went in..)
;   229         --
;   230     [32]
;   231 --DEV (this might want to be shl edi,8)
;   232 --      shl esi,8                   -- (to make a 16-bit word of the two chars)
;   233         shl edi,8
;   234         mov ecx,2
;   235         add esi,edi
;   236         mov edi,[esp]
;   237         call :%pAllocStr
;   238         mov edx,[edi]
;   239         mov ecx,esi
;   240         add esp,16
;   241 --DEV try ecx (min string length is 19), or for that matter esi (null terminator and 1 more 0)
;   242         mov [ebx+eax*4],cx
;   243         mov [ebx+eax*4+2],bl        -- and a null terminator
;   244         mov [edi],eax
;   245         cmp edx,h4
;   246 --26/1/15!
;   247 --      jl @f
;   248         jle @f
;   249             sub dword[ebx+edx*4-8],1
;   250             jz :%pDealloc
;   251       @@:
;   252         ret
;   253     [64]
;   254         shl rdi,8                   -- (to make a 16-bit word of the two chars)
                shl rdi,8                 ;#0043FD15: 48:301347 08               u  80 80  1  68      
;   255         mov rcx,2
                mov rcx,2                 ;#0043FD19: 48:307301 02000000         vu 02 00  1  68      
;   256         add rsi,rdi
                add rsi,rdi               ;#0043FD20: 48:001376                  uv 40 C0  1  69      
;   257         mov rdi,[rsp]
                mov rdi,[rsp]             ;#0043FD23: 48:213074044               vu 80 10  1  69      
;   258         call :%pAllocStr
                call #004420E3 (:%pAllocStr)  ;#0043FD27: 350 B7230000               v  00 00  1  70      
;   259         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043FD2C: 48:213027                  uv 04 80  1  73    *80*
;   260         mov rcx,rsi
                mov rcx,rsi               ;#0043FD2F: 48:213316                  vu 02 40  1  73      
;   261         add rsp,32
                add rsp,32                ;#0043FD32: 48:203304 20               uv 10 10  1  74      
;   262 --DEV try rcx (min string lenth is 31), or for that matter, rsi (null terminator and 5 more 0s)
;   263         mov [rbx+rax*4],cx
                mov word[rbx+rax*4],cx    ;#0043FD36: 146:211014203              vu 00 0B  1  74      
;   264         mov [rbx+rax*4+2],bl        -- and a null terminator
                mov [rbx+rax*4+2],bl      ;#0043FD3A: 210134203 02               uv 00 09  1  75      
;   265         mov [rdi],rax
                mov [rdi],rax             ;#0043FD3E: 48:211007                  vu 00 81  1  75      
;   266         cmp rdx,r15
                cmp rdx,r15               ;#0043FD41: 49:073327                  uv 00 8004  1  76      
;   267 --26/1/15!
;   268 --      jl @f
;   269         jle @f
                jle #0043FD52             ;#0043FD44: 176 0C                     v  00 00  1  76      
;   270             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043FD46: 48:203154223 F0 01         u  00 0C  3  77      
;   271             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043FD4C: 017204 88250000            v  00 00  1  79      
;   272       @@:
;   273         ret
                ret                       ;#0043FD52: 303                        np 00 00  2  80      
;   274     []
;   275 
;   276   ::ApndNewStr
;   277 --------------
;   278     [32]
;   279         mov edi,[esp+12]        -- prepend flag
;   280         push eax                --[1] save char
;   281         lea ecx,[edx+1]         -- original length+1
;   282         call :%pAllocStr        -- damages eax only
;   283         lea edi,[edi+eax*4]     -- edi -> new[1] for append, new[2] for prepend
;   284         mov ecx,edx
;   285 ----DEV:
;   286 --                   -- This shaves about 9% off the total time for append():
;   287 --                   shr ecx,2
;   288 --                   and dl,0x3
;   289 --                   rep movsd
;   290 --                   mov cl,dl
;   291         rep movsb
;   292         mov esi,[esp+4]         -- target address
;   293         pop ecx                 --[1] restore char
;   294         cmp dword[esp+12],0
;   295         je :normalappend
;   296             mov [edi],bl        -- trailing null
;   297             mov [ebx+eax*4],cl  -- plant prepended char at new[1]
;   298             jmp @f
;   299       ::normalappend
;   300             mov [edi],cx        -- includes trailing null
;   301       @@:
;   302         mov edx,[esi]           -- previous value (if any)
;   303         add esp,16
;   304         mov [esi],eax           -- newly allocated ref
;   305         cmp edx,h4
;   306         jle @f
;   307             sub dword[ebx+edx*4-8],1
;   308             jz :%pDealloc
;   309       @@:
;   310         ret
;   311     [64]
;   312         mov rdi,[rsp+24]        -- prepend flag
                mov rdi,[rsp+24]          ;#0043FD53: 48:213174044 18            uv 80 10  1  82      
;   313         push rax                --[1] save char
                push rax                  ;#0043FD58: 48:120                     vu 00 01  1  82      
;   314         lea rcx,[rdx+1]         -- original length+1
                lea rcx,[rdx+1]           ;#0043FD5A: 48:215112 01               uv 02 04  1  83      
;   315         call :%pAllocStr        -- damages eax only
                call #004420E3 (:%pAllocStr)  ;#0043FD5E: 350 80230000               v  00 00  1  83      
;   316         lea rdi,[rdi+rax*4]     -- edi -> new[1] for append, new[2] for prepend
                lea rdi,[rdi+rax*4]       ;#0043FD63: 48:215074207               uv 80 81  1  84      
;   317         mov rcx,rdx
                mov rcx,rdx               ;#0043FD67: 48:213312                  vu 02 04  1  84      
;   318 ----DEV:
;   319 --                   -- This shaves about 9% off the total time for append():
;   320 --                   shr rcx,3
;   321 --                   and dl,0x7
;   322 --                   rep movsq
;   323 --                   mov cl,dl
;   324         rep movsb
                rep movsb                 ;#0043FD6A: 363:244                    np C2 C2  4  87    *80*
;   325         mov rsi,[rsp+8]         -- target address
                mov rsi,[rsp+8]           ;#0043FD6C: 48:213164044 08            uv 40 10  1  91      
;   326         pop rcx                 --[1] restore char
                pop rcx                   ;#0043FD71: 48:131                     vu 02 00  1  91      
;   327         cmp qword[rsp+24],0
                cmp qword[rsp+24],0       ;#0043FD73: 48:203174044 18 00         u  00 10  2  92      
;   328         je :normalappend
                je #0043FD82              ;#0043FD79: 164 07                     v  00 00  1  93      
;   329             mov [rdi],bl        -- trailing null
                    mov [edi],bl          ;#0043FD7B: 210037                     uv 00 88  1  94      
;   330             mov [rbx+rax*4],cl  -- plant prepended char at new[1]
                    mov [rbx+rax*4],cl    ;#0043FD7D: 210014203                  vu 00 0B  1  94      
;   331             jmp @f
                    jmp #0043FD85         ;#0043FD80: 353 03                     v  00 00  1  95      
;   332       ::normalappend
;   333             mov [rdi],cx        -- includes trailing null
                    mov word[edi],cx      ;#0043FD82: 146:211017                 uv 00 82  1  96      
;   334       @@:
;   335         mov rdx,[rsi]           -- previous value (if any)
                mov rdx,[rsi]             ;#0043FD85: 48:213026                  vu 04 40  1  96      
;   336         add rsp,32
                add rsp,32                ;#0043FD88: 48:203304 20               uv 10 10  1  97      
;   337         mov [rsi],rax           -- newly allocated ref
                mov [rsi],rax             ;#0043FD8C: 48:211006                  vu 00 41  1  97      
;   338         cmp rdx,r15
                cmp rdx,r15               ;#0043FD8F: 49:073327                  uv 00 8004  1  98      
;   339         jle @f
                jle #0043FDA0             ;#0043FD92: 176 0C                     v  00 00  1  98      
;   340             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043FD94: 48:203154223 F0 01         u  00 0C  3  99      
;   341             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043FD9A: 017204 3A250000            v  00 00  1 101      
;   342       @@:
;   343         ret
                ret                       ;#0043FDA0: 303                        np 00 00  2 102      
;   344     []
;   345 
;   346   ::ApndExpandString
;   347 --------------------
;   348     [32]
;   349         mov edi,[esp+12]        -- prepend flag...
;   350         push ecx                --[2] save p3 ref
;   351         shl edi,2               --              ...->dword
;   352         lea ecx,[edx+1]         -- length+1
;   353         mov edx,[esp+16]        -- era
;   354         call :%pAllocSeq        -- damages eax only
;   355 --  mov edi,eax
;   356 --  shl edi,2
;   357 --DEV flag (the old PpndExpandString put slack at start, but I doubt that gains any) (done)
;   358         lea edi,[edi+eax*4]     -- edi->(append:new[1], or prepend:new[2])
;   359 --      lea edi,[ebx+eax*4]
;   360         sub ecx,1
;   361         je :ApndExpandZero      -- (append(<empty string>,<non-char>) case)
;   362         push eax                --[3] save new ref
;   363         xor eax,eax
;   364       @@:
;   365         lodsb                   -- mov al,[esi], esi+=1
;   366         stosd                   -- mov [edi],eax; edi+=4
;   367 --      mov al,[esi]
;   368 --      inc esi
;   369 --      mov [edi],eax
;   370 --      add edi,4
;   371         sub ecx,1
;   372         jnz @b
;   373         pop eax                 --[3] restore new ref
;   374      ::ApndExpandZero
;   375         mov esi,[esp+4]         -- target address
;   376         pop ecx                 --[2] restore p3 ref
;   377 --DEV flag (done)
;   378         cmp dword[esp+12],0     -- if prepend
;   379         je @f
;   380             lea edi,[ebx+eax*4] -- replace new[1] (not new[$])
;   381       @@:
;   382         add esp,16
;   383         mov edx,[esi]           -- previous value (if any)
;   384         cmp ecx,h4
;   385         jl @f
;   386 --    ::ApndExpandStrUa:            -- exception here mapped to e92vhnbaavap3feh (now opUnassigned [DEV])
;   387             add dword[ebx+ecx*4-8],1
;   388       @@:
;   389         mov [edi],ecx
;   390         mov [esi],eax           -- newly allocated ref
;   391         cmp edx,h4
;   392         jle @f
;   393             sub dword[ebx+edx*4-8],1
;   394             jz :%pDealloc
;   395       @@:
;   396         ret
;   397     [64]
;   398         mov rdi,[rsp+24]        -- prepend flag...
                mov rdi,[rsp+24]          ;#0043FDA1: 48:213174044 18            uv 80 10  1 104      
;   399         push rcx                --[2] save p3 ref
                push rcx                  ;#0043FDA6: 48:121                     vu 00 02  1 104      
;   400 --      shl rdi,2               --              ...->dword
;   401         shl rdi,3               --              ...->qword
                shl rdi,3                 ;#0043FDA8: 48:301347 03               u  80 80  1 105      
;   402         lea rcx,[rdx+1]         -- length+1
                lea rcx,[rdx+1]           ;#0043FDAC: 48:215112 01               vu 02 04  1 105      
;   403         mov rdx,[rsp+32]        -- era
                mov rdx,[rsp+32]          ;#0043FDB0: 48:213124044 20            uv 04 10  1 106      
;   404         call :%pAllocSeq        -- damages eax only
                call #00442148 (:%pAllocSeq)  ;#0043FDB5: 350 8E230000               v  00 00  1 106      
;   405         lea rdi,[rdi+rax*4]     -- edi->(append:new[1], or prepend:new[2])
                lea rdi,[rdi+rax*4]       ;#0043FDBA: 48:215074207               uv 80 81  1 107      
;   406         sub rcx,1
                sub rcx,1                 ;#0043FDBE: 48:203351 01               vu 02 02  1 107      
;   407         je :ApndExpandZero      -- (append(<empty string>,<non-char>) case)
                je #0043FDD4              ;#0043FDC2: 164 10                     v  00 00  1 108      
;   408         push rax                --[3] save new ref
                push rax                  ;#0043FDC4: 48:120                     uv 00 01  1 109      
;   409         xor rax,rax
                xor rax,rax               ;#0043FDC6: 48:061300                  vu 01 01  1 109      
;   410       @@:
;   411         lodsb                   -- mov al,[rsi], rsi+=1
                lodsb                     ;#0043FDC9: 254                        np 41 40  2 110      
;   412         stosq                   -- mov [rdi],rax; rdi+=8
                stosq                     ;#0043FDCA: 48:253                     np 80 81  3 112      
;   413         sub rcx,1
                sub rcx,1                 ;#0043FDCC: 48:203351 01               uv 02 02  1 115      
;   414         jnz @b
                jnz #0043FDC9             ;#0043FDD0: 165 F7                     v  00 00  1 115      
;   415         pop rax                 --[3] restore new ref
                pop rax                   ;#0043FDD2: 48:130                     uv 01 00  1 116      
;   416      ::ApndExpandZero
;   417 --      mov rsi,[rsp+4]         -- target address
;   418         mov rsi,[rsp+8]         -- target address
                mov rsi,[rsp+8]           ;#0043FDD4: 48:213164044 08            vu 40 10  1 116      
;   419         pop rcx                 --[2] restore p3 ref
                pop rcx                   ;#0043FDD9: 48:131                     uv 02 00  1 117      
;   420         cmp dword[rsp+24],0     -- if prepend
                cmp dword[rsp+24],0       ;#0043FDDB: 203174044 18 00            u  00 10  2 118      
;   421         je @f
                je #0043FDE6              ;#0043FDE0: 164 04                     v  00 00  1 119      
;   422             lea rdi,[rbx+rax*4] -- replace new[1] (not new[$])
                    lea rdi,[rbx+rax*4]   ;#0043FDE2: 48:215074203               uv 80 09  1 120      
;   423       @@:
;   424         add rsp,32
                add rsp,32                ;#0043FDE6: 48:203304 20               vu 10 10  1 120      
;   425         mov rdx,[rsi]           -- previous value (if any)
                mov rdx,[rsi]             ;#0043FDEA: 48:213026                  uv 04 40  1 121      
;   426         cmp rcx,r15
                cmp rcx,r15               ;#0043FDED: 49:073317                  vu 00 8002  1 121      
;   427         jl @f
                jl #0043FDF8              ;#0043FDF0: 174 06                     v  00 00  1 122      
;   428             add qword[rbx+rcx*4-16],1
                    add qword[rbx+rcx*4-16],1  ;#0043FDF2: 48:203104213 F0 01         u  00 0A  3 123      
;   429       @@:
;   430         mov [rdi],rcx
                mov [rdi],rcx             ;#0043FDF8: 48:211017                  vu 00 82  1 125      
;   431         mov [rsi],rax           -- newly allocated ref
                mov [rsi],rax             ;#0043FDFB: 48:211006                  uv 00 41  1 126      
;   432         cmp rdx,r15
                cmp rdx,r15               ;#0043FDFE: 49:073327                  vu 00 8004  1 126      
;   433         jle @f
                jle #0043FE0F             ;#0043FE01: 176 0C                     v  00 00  1 127      
;   434             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043FE03: 48:203154223 F0 01         u  00 0C  3 128      
;   435             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043FE09: 017204 CB240000            v  00 00  1 130      
;   436       @@:
;   437         ret
                ret                       ;#0043FE0F: 303                        np 00 00  2 131      
;   438     []
;   439 
;   440   ::ApndSeq
;   441 -----------
;   442     [32]
;   443         -- recap:
;   444         --  addr p1 (result)    @ [esp]
;   445         --  addr p2 in edi and  @ [esp+4]
;   446         --  addr p3             @ [esp+8]
;   447         --  prepend flag        @ [esp+12]
;   448         --  era                 @ [esp+16]
;   449         --  esi = raw(p2)
;   450         --  edx = length(p2) (==[esi-12])
;   451         --  al is 0x80      (==[esi-1])
;   452         --  ecx is ref(p3)
;   453         --  edi is addr p2
;   454         --
;   455         cmp ecx,h4
;   456         jl @f
;   457             add dword[ebx+ecx*4-8],1
;   458       @@:
;   459         push ecx                --[1] save new element
;   460 --      cmp edi,[esp]           -- must be pbr-optimise (x=append(x,..)) [BUG! (push ecx)]
;   461         cmp edi,[esp+4]         -- must be pbr-optimise (x=append(x,..)) (cmp addr p2, addr p1)
;   462         jne :ApndNewSeq
;   463         cmp dword[esi-8],1      -- check ref count of 1
;   464         jne :ApndNewSeq
;   465 --      cmp edi,[esp+8]         -- and not circular (x=append(x,x)) [BUG! (push ecx)]
;   466         cmp edi,[esp+12]        -- and not circular (x=append(x,x)) (cmp addr p2, addr p3)
;   467         je :ApndNewSeq
;   468 
;   469         lea ecx,[ebx+edx*4+20]  -- required (old) size in bytes
;   470         mov edi,[esi-20]        -- slack (at start/left)
;   471         cmp dword[esp+16],0     -- prepend flag
;   472         jne :PpndSeq
;   473         add ecx,edi
;   474         cmp ecx,[esi-16]        -- check maxlen (allocated size in bytes)
;   475         je :ApndSeqClone        -- (exactly full)
;   476 
;   477         pop eax                 --[1]
;   478         lea ecx,[edx+1]
;   479         mov [esi+edx*4],eax     -- in situ
;   480         mov [esi-12],ecx        -- increase length
;   481         add esp,16
;   482         ret
;   483     [64]
;   484         -- recap:
;   485         --  addr p1 (result)    @ [rsp]
;   486         --  addr p2 in rdi and  @ [rsp+8]
;   487         --  addr p3             @ [rsp+16]
;   488         --  prepend flag        @ [rsp+24]
;   489         --  era                 @ [rsp+32]
;   490         --  rsi = raw(p2)
;   491         --  rdx = length(p2) (==[rsi-24])
;   492         --  al is 0x80      (==[rsi-1])
;   493         --  rcx is ref(p3)
;   494         --  rdi is addr p2
;   495         --
;   496         cmp rcx,r15
                cmp rcx,r15               ;#0043FE10: 49:073317                  uv 00 8002  1 133      
;   497         jl @f
                jl #0043FE1B              ;#0043FE13: 174 06                     v  00 00  1 133      
;   498             add qword[rbx+rcx*4-16],1
                    add qword[rbx+rcx*4-16],1  ;#0043FE15: 48:203104213 F0 01         u  00 0A  3 134      
;   499       @@:
;   500         push rcx                --[1] save new element
                push rcx                  ;#0043FE1B: 48:121                     vu 00 02  1 136      
;   501 --      cmp edi,[esp]           -- must be pbr-optimise (x=append(x,..)) [BUG! (push ecx)]
;   502         cmp rdi,[rsp+8]         -- must be pbr-optimise (x=append(x,..)) (cmp addr p2, addr p1)
                cmp rdi,[rsp+8]           ;#0043FE1D: 48:073174044 08            uv 00 90  2 137      
;   503         jne :ApndNewSeq
                jne #0043FF8F             ;#0043FE22: 017205 67010000            v  00 00  1 138      
;   504         cmp qword[rsi-16],1     -- check ref count of 1
                cmp qword[rsi-16],1       ;#0043FE28: 48:203176 F0 01            u  00 40  2 139      
;   505         jne :ApndNewSeq
                jne #0043FF8F             ;#0043FE2D: 017205 5C010000            v  00 00  1 140      
;   506 --      cmp edi,[esp+8]         -- and not circular (x=append(x,x)) [BUG! (push ecx)]
;   507         cmp rdi,[rsp+24]        -- and not circular (x=append(x,x)) (cmp addr p2, addr p3)
                cmp rdi,[rsp+24]          ;#0043FE33: 48:073174044 18            uv 00 90  2 141      
;   508         je :ApndNewSeq
                je #0043FF8F              ;#0043FE38: 017204 51010000            v  00 00  1 142      
;   509 
;   510 --      lea rcx,[rbx+rdx*4+40]  -- required (old) size in bytes
;   511         lea rcx,[rbx+rdx*4+20]  -- half required (old) size in bytes
                lea rcx,[rbx+rdx*4+20]    ;#0043FE3E: 48:215114223 14            uv 02 0C  1 143      
;   512         mov rdi,[rsi-40]        -- slack (at start/left)
                mov rdi,[rsi-40]          ;#0043FE43: 48:213176 D8               vu 80 40  1 143      
;   513         shl rcx,1               -- required (old) size in bytes
                shl rcx,1                 ;#0043FE47: 48:321341                  u  02 02  1 144      
;   514         cmp qword[rsp+32],0     -- prepend flag
                cmp qword[rsp+32],0       ;#0043FE4A: 48:203174044 20 00         u  00 10  2 145      
;   515         jne :PpndSeq
                jne #0043FE6E             ;#0043FE50: 165 1C                     v  00 00  1 146      
;   516         add rcx,rdi
                add rcx,rdi               ;#0043FE52: 48:001371                  uv 02 82  1 147      
;   517         cmp rcx,[rsi-32]        -- check maxlen (allocated size in bytes)
                cmp rcx,[rsi-32]          ;#0043FE55: 48:073116 E0               uv 00 42  2 148 02   
;   518         je :ApndSeqClone        -- (exactly full)
                je #0043FEBB              ;#0043FE59: 164 60                     v  00 00  1 149      
;   519 
;   520         pop rax                 --[1]
                pop rax                   ;#0043FE5B: 48:130                     uv 01 00  1 150      
;   521         lea rcx,[rdx+1]
                lea rcx,[rdx+1]           ;#0043FE5D: 48:215112 01               vu 02 04  1 150      
;   522         mov [rsi+rdx*8],rax     -- in situ
                mov [rsi+rdx*8],rax       ;#0043FE61: 48:211004326               uv 00 45  1 151      
;   523         mov [rsi-24],rcx        -- increase length
                mov [rsi-24],rcx          ;#0043FE65: 48:211116 E8               vu 00 42  1 151      
;   524         add rsp,32
                add rsp,32                ;#0043FE69: 48:203304 20               uv 10 10  1 152      
;   525         ret
                ret                       ;#0043FE6D: 303                        np 00 00  2 153      
;   526     []
;   527 
;   528   ::PpndSeq
;   529 -----------
;   530     [32]
;   531         test edi,edi            -- is slack 0?
;   532         jz :PpndSeqClone
;   533         -- shift header left and calc/store updated ref
;   534         sub edi,4               -- new slack
;   535         add edx,1               -- new length
;   536         mov ecx,[esi-16]        -- maxlen
;   537         mov [esi-24],edi        -- new slack
;   538         mov [esi-20],ecx        -- copy maxlen
;   539         mov ecx,[esi-4]         -- type/delete routine
;   540         mov edi,[esp+4]         -- addr p1
;   541         mov [esi-16],edx        -- set new length
;   542         mov eax,esi
;   543         mov dword[esi-12],1     -- refcount (we know it is 1)
;   544         sub eax,3
;   545         mov [esi-8],ecx         -- type/delete routine
;   546         ror eax,2
;   547         pop dword[esi-4]        -- new element
;   548         mov [edi],eax           -- new ref of shifted header -> p1
;   549         add esp,16
;   550         ret
;   551     [64]
;   552         test rdi,rdi            -- is slack 0?
                test rdi,rdi              ;#0043FE6E: 48:205377                  uv 00 80  1 155      
;   553         jz :PpndSeqClone
                jz #0043FF06              ;#0043FE71: 017204 8F000000            v  00 00  1 155      
;   554         -- shift header left and calc/store updated ref
;   555         sub rdi,8               -- new slack
                sub rdi,8                 ;#0043FE77: 48:203357 08               uv 80 80  1 156      
;   556         add rdx,1               -- new length
                add rdx,1                 ;#0043FE7B: 48:203302 01               vu 04 04  1 156      
;   557         mov rcx,[rsi-32]        -- maxlen
                mov rcx,[rsi-32]          ;#0043FE7F: 48:213116 E0               uv 02 40  1 157      
;   558         mov [rsi-48],rdi        -- new slack
                mov [rsi-48],rdi          ;#0043FE83: 48:211176 D0               vu 00 C0  1 157      
;   559         mov [esi-40],rcx        -- copy maxlen
                mov [rsi-40],rcx          ;#0043FE87: 48:211116 D8               uv 00 42  1 158      
;   560         mov rcx,[rsi-8]         -- type/delete routine
                mov rcx,[rsi-8]           ;#0043FE8B: 48:213116 F8               vu 02 40  1 158      
;   561         mov rdi,[rsp+8]         -- addr p1
                mov rdi,[rsp+8]           ;#0043FE8F: 48:213174044 08            uv 80 10  1 159      
;   562 --      mov [rsi-24],rdx        -- set new length
;   563         mov [rsi-32],rdx        -- set new length
                mov [rsi-32],rdx          ;#0043FE94: 48:211126 E0               vu 00 44  1 159      
;   564         mov rax,rsi
                mov rax,rsi               ;#0043FE98: 48:213306                  uv 01 40  1 160      
;   565         mov qword[rsi-24],1     -- refcount (we know it is 1)
                mov qword[rsi-24],1       ;#0043FE9B: 48:307106 E8 01000000      vu 00 40  1 160      
;   566         sub rax,7
                sub rax,7                 ;#0043FEA3: 48:203350 07               uv 01 01  1 161      
;   567         mov [rsi-16],rcx        -- type/delete routine
                mov [rsi-16],rcx          ;#0043FEA7: 48:211116 F0               vu 00 42  1 161      
;   568         ror rax,2
                ror rax,2                 ;#0043FEAB: 48:301310 02               np 01 01  1 162      
;   569 --DEV fix this in pilasm.e
;   570         pop qword[rsi-8]        -- new element
                pop qword[rsi-8]          ;#0043FEAF: 147:217106 F8              np 00 40  3 163      
;   571 --      pop rcx                 -- new element
;   572         mov [rdi],rax           -- new ref of shifted header -> p1
                mov [rdi],rax             ;#0043FEB3: 48:211007                  uv 00 81  1 166      
;   573 --      mov [rsi-8],rcx         -- new element
;   574         add rsp,32
                add rsp,32                ;#0043FEB6: 48:203304 20               vu 10 10  1 166      
;   575         ret
                ret                       ;#0043FEBA: 303                        np 00 00  2 167      
;   576     []  
;   577 
;   578   ::ApndSeqClone
;   579 ----------------
;   580         -- Fairly obviously, "clone" differs from "new" in that we just
;   581         --  copy the contents rather than incref/decref each one, and 
;   582         --  pFreePool the old empty container rather than pDealloc it.
;   583         -- An "append clone" always creates a "hard left" sequence; any
;   584         --  subsequent prepend will preserve (some) free space on the 
;   585         --  end, leaving space for both append and prepend to utilise.
;   586     [32]
;   587         --
;   588         -- recap:
;   589         --  ref(p3)             @ [esp]
;   590         --  addr p1 (result)    @ [esp+4]
;   591         --  addr p2             @ [esp+8] (==[esp+4],!=[esp+12])
;   592         --  addr p3             @ [esp+12]
;   593         --  prepend flag        @ [esp+16] (==0)
;   594         --  era                 @ [esp+20]
;   595         --  esi = raw(p2)    ([esi-8]==1)
;   596         --  edx = length(p2) (==[esi-12])
;   597         --  al is 0x80       (==[esi-1])
;   598         --  edi = slack(p2) (==[esi-20])
;   599         --  ecx is edi+edx*4+20 (==[esi-16] aka maxlen)
;   600         --
;   601         push esi                --[2] save p1=p2 raw address
;   602         lea ecx,[edx+1]         -- length+1
;   603         mov edx,[esp+24]        -- era
;   604         call :%pAllocSeq        -- damages eax only
;   605         mov edx,[esi-4]         -- copy type/delete_index
;   606 --DEV have I reintroduced this anywhere? (only applies to append, not prepend, not concat)
;   607 -- 15/06/13 (multithreading issues, content must be in place before ref updated, see pfileioN.e):
;   608 --  mov [edi],eax           -- replace p1 now
;   609         mov [ebx+eax*4-4],edx
;   610         sub ecx,1
;   611         lea edi,[ebx+eax*4]     -- convert to real address (new[1])
;   612 --      mov edx,[esp+4]         -- target address
;   613         mov edx,[esp+8]         -- target address
;   614         rep movsd
;   615 --15/06/13:
;   616         mov [edx],eax
;   617         pop edx                 --[2] raw address of original p1 (=p2)
;   618         pop eax                 --[1] (as pushed by ApndSeq)
;   619         stosd                   -- mov [edi],eax; edi+=4 (not that we need edi again)
;   620         mov ecx,[edx-16]        -- maxlen (allocated size in bytes)
;   621         lea eax,[edx-20]
;   622         add esp,16
;   623         sub eax,[edx-20]        -- account for any slack
;   624         mov edx,[esp]
;   625         jmp :%pFreePool         -- free ecx bytes at eax (ignores any delete_routine)
;   626     [64]
;   627         push rsi                --[2] save p1=p2 raw address
                push rsi                  ;#0043FEBB: 48:126                     uv 00 40  1 169      
;   628         lea rcx,[rdx+1]         -- length+1
                lea rcx,[rdx+1]           ;#0043FEBD: 48:215112 01               vu 02 04  1 169      
;   629         mov rdx,[rsp+48]        -- era
                mov rdx,[rsp+48]          ;#0043FEC1: 48:213124044 30            uv 04 10  1 170      
;   630         call :%pAllocSeq        -- damages eax only
                call #00442148 (:%pAllocSeq)  ;#0043FEC6: 350 7D220000               v  00 00  1 170      
;   631         mov rdx,[rsi-8]         -- copy type/delete_index
                mov rdx,[rsi-8]           ;#0043FECB: 48:213126 F8               uv 04 40  1 171      
;   632         mov [rbx+rax*4-8],rdx
                mov [rbx+rax*4-8],rdx     ;#0043FECF: 48:211124203 F8            uv 00 0D  1 172 04   
;   633         sub rcx,1
                sub rcx,1                 ;#0043FED4: 48:203351 01               vu 02 02  1 172      
;   634         lea rdi,[rbx+rax*4]     -- convert to real address (new[1])
                lea rdi,[rbx+rax*4]       ;#0043FED8: 48:215074203               uv 80 09  1 173      
;   635 --      mov rdx,[rsp+8]         -- target address
;   636         mov rdx,[rsp+16]        -- target address
                mov rdx,[rsp+16]          ;#0043FEDC: 48:213124044 10            vu 04 10  1 173      
;   637         rep movsq
                rep movsq                 ;#0043FEE1: 363:48:245                 np C2 C2  4 176    *80*
;   638         mov [rdx],rax
                mov [rdx],rax             ;#0043FEE4: 48:211002                  uv 00 05  1 182    *04*
;   639         pop rdx                 --[2] raw address of original p1 (=p2)
                pop rdx                   ;#0043FEE7: 48:132                     vu 04 00  1 182      
;   640         pop rax                 --[1] (as pushed by ApndSeq)
                pop rax                   ;#0043FEE9: 48:130                     uv 01 00  1 183      
;   641         stosq                   -- mov [rdi],rax; rdi+=8 (not that we need rdi again)
                stosq                     ;#0043FEEB: 48:253                     np 80 81  3 184      
;   642         mov rcx,[rdx-32]        -- maxlen (allocated size in bytes)
                mov rcx,[rdx-32]          ;#0043FEED: 48:213112 E0               uv 02 04  1 187      
;   643         lea rax,[rdx-40]
                lea rax,[rdx-40]          ;#0043FEF1: 48:215102 D8               vu 01 04  1 187      
;   644         add rsp,32
                add rsp,32                ;#0043FEF5: 48:203304 20               uv 10 10  1 188      
;   645         sub rax,[rdx-40]        -- account for any slack
                sub rax,[rdx-40]          ;#0043FEF9: 48:053102 D8               vu 01 05  2 188      
;   646         mov rdx,[rsp]
                mov rdx,[rsp]             ;#0043FEFD: 48:213024044               uv 04 10  1 191    *10*
;   647         jmp :%pFreePool         -- free rcx bytes at rax (ignores any delete_routine)
                jmp #00441FFA (:%pFreePool)  ;#0043FF01: 351 F4200000               v  00 00  1 191      
;   648     []
;   649 
;   650   ::PpndSeqClone
;   651 ----------------
;   652         --
;   653         -- Request (existing length)*2+1, then plant the header slap in the middle.
;   654         -- This leaves space for both append and prepend to utilise.
;   655         --
;   656         -- Technical/design note: [DEV this isn't helpful...]
;   657         -- Analysis of the worst case scenarios yielded worst case points of:
;   658         --      {0,0,2,7,17,37...} at [0,1,6,16,36,76] (32-bit) and 
;   659         --      {0,2,6,15,33,69,...} at [0,5,14,32,68,140] (64-bit)
;   660         -- ie there are a couple of (frankly rather unlikely) painful/pointless/could 
;   661         -- be done in situ cases, but only on such small sizes no-one really cares, 
;   662         -- and as the sizes start to get larger the low points gradually get less and 
;   663         -- less painful (as well as less and less likely), exactly what we want. What
;   664         -- I mean by worst case scenario, I should perhaps have mentioned, is various
;   665         -- combinations of append/prepend that cause early clones when technically
;   666         -- there is still space, but at the wrong end, compared that is to all-appends 
;   667         -- and all-prepends, which perform about as good as we might hope them to.
;   668         -- I only mention this to avoid anyone else noticing odd/unhelpful behaviour 
;   669         -- (at small sizes) and not seeing the bigger picture, as I first did (before
;   670         -- attempting a much more convoluted strategy, that I never got working, and,
;   671         -- to be frank, was never going to do any better). Just in case you can find
;   672         -- any use for it, the wcs analysis, focusing on a single prepend followed by
;   673         -- enough appends to discard slack and clone to a naievely chosen new size:
;   674         --
;   675         --  --
;   676         --  -- wscditty.exw (worst case scenario analysis)
;   677         --  --
;   678         --  constant MWORD = 4, SBLOCK = 20 -- 32 bit
;   679         --  --constant MWORD = 8, SBLOCK = 36 -- 64 bit
;   680         --  -- (see "Revised Sizes" in pHeap.e for an explanation of SBLOCK being 20/34)
;   681         --  constant SHDR = MWORD*5
;   682         --
;   683         --  integer reqlen, maxlen, allocated, newlen, slack, spare, full, fulllen, afull
;   684         --  puts(1,"--      l       new length    slack(lhs)  spare(rhs)  appfull\n")
;   685         --  for l=1 to MWORD*20 do -- (new length)
;   686         --      reqlen = (l*2-1) -- (=== existinglength*2 /+/ 1)
;   687         --      maxlen = reqlen*MWORD+SHDR
;   688         --      allocated = SBLOCK
;   689         --      while maxlen>allocated-MWORD do allocated*=2 end while
;   690         --      newlen = floor((allocated-(SHDR+MWORD))/MWORD)
;   691         --      spare = newlen-l
;   692         --      slack = floor(spare/2)
;   693         --      spare -= slack
;   694         --      full = spare+l+1
;   695         --      fulllen = full*MWORD+SHDR
;   696         --      allocated = SBLOCK
;   697         --      while fulllen>allocated-MWORD do allocated*=2 end while
;   698         --      afull = (allocated-(SHDR+MWORD))/MWORD
;   699         --      printf(1,"-- %4d(->%2d) %5d->%2d %10d %11d %10d->%2d    (%d)\n",
;   700         --               {l-1,l,reqlen,newlen,slack,spare,full,afull,afull-full})
;   701         --  end for
;   702         --  if getc(0) then end if
;   703 
;   704 --  [1]                               20[#00000014]=4+16            n/a                 n/a
;   705 --  [2]                               40[#00000028]=4+36            x(19)               s[4]
;   706 --  [3]                               80[#00000050]=4+76            x(59)               s[14]
;   707 --  [4]                              160[#000000A0]=4+156           x(139)              s[34]
;   708 --  [5]                              320[#00000140]=4+316           x(299)              s[74]
;   709 
;   710 --      l       new length    slack(lhs)  spare(rhs)  appfull                   ecx     new maxlen      -   slack
;   711 --    0(-> 1)     1-> 4          1           2          4-> 4    (0)            24      36              12    4
;   712 --    1(-> 2)     3-> 4          1           1          4-> 4    (0)            28                      8     4
;   713 --    2(-> 3)     5->14          5           6         10->14    (4)            32      76              44    20
;   714 --    3(-> 4)     7->14          5           5         10->14    (4)            36                      40    20
;   715 --    4(-> 5)     9->14          4           5         11->14    (3)            40                      36    16
;   716 --    5(-> 6)    11->14          4           4         11->14    (3)            44                      32    16
;   717 --    6(-> 7)    13->14          3           4         12->14    (2)            48                      28    12
;   718 --    7(-> 8)    15->34         13          13         22->34    (12)           52      156             104   52
;   719 
;   720 --DEV/DOC
;   721 -- Technical note:
;   722 --  Referring to the "Multithreading issues" as documented in VM/pfileioN.e, prepend
;   723 --  does NOT currently honor any promise of contents in place before ref is updated;
;   724 --  that only applies to append. Of course there is no issue if your table(s) etc are 
;   725 --  properly locked, or if your application is not multi-threaded.
;   726 --
;   727 -- Performance note:
;   728 --  Please don't read this in an alarmist fashion, or be put off from using prepend.
;   729 --  There /is/ a difference, and that difference deserves to be properly documented,
;   730 --  but in reality it is nothing to get all excited or bothered about.
;   731 --
;   732 --  Benchmark speaking, append is a better choice than prepend for top performance.
;   733 --  While prepend on dword-sequences delivers about the same performance as using
;   734 --  append, string = prepend(string,char) exhibits exponentially worse performance 
;   735 --  when compared to string = append(string,char), because strings must always be 
;   736 --  aligned to start on a dword/qword boundary. Also, when append needs to enlarge 
;   737 --  a dword-sequence it places all the spare space at the end, whereas in the same 
;   738 --  situation prepend splits any newly allocated extra space between the front and 
;   739 --  back, so that it is available for both append and prepend to utilise, which
;   740 --  avoids any "shunting" effects should they be mixed. This means that prepend has
;   741 --  "twice the clone overhead" of append, occurring every *1.5 instead of every *2, 
;   742 --  and uses about 25% more memory, which translates to a few percent points slower 
;   743 --  overall, but in most cases that is less than can actually be measured.
;   744 --
;   745 --  Hence, by all means use prepend when it makes your program easier or clearer,
;   746 --  and is unlikely to be invoked more than several million times. You can find
;   747 --  dozens of uses of prepend in the Phix sources, despite the fact that they are
;   748 --  rather aggressively optimised[1], and the same can be said for Edita. Likewise
;   749 --  printf() uses string=prepend(string,char), because "exponentially slower" just
;   750 --  doesn't matter one jot when building ~20 character long strings[2].
;   751 --
;   752 --  [1] Almost no effort has gone into optimising Phix /after/ a fatal error has
;   753 --  occurred, hence prepend tends to be freely used in the error reporting side,
;   754 --  but admittedly not so much in the pre-error-so-must-be-uber-fast bits.
;   755 --  [2] 20 chars takes some N+210 clocks instead of N+20, where N is at the very
;   756 --  least ~20,000: calculating each digit totally swamps any prepend overheads,
;   757 --  and even a report containing 100,000 so-generated numbers won't make that
;   758 --  190 clocks tally up to anywhere near 0.1s, so you and I would have to live
;   759 --  for a very long time indeed to regret such a miniscule overhead. Of course
;   760 --  if your length(string)>20K, then that's a very different matter altogether,
;   761 --  and you would probably be better off building it as a dword-sequence before
;   762 --  packing it back to a string once done, or doing it line-by-line. Also, if I
;   763 --  really wanted to, I could have removed the "offending" code in printf() in
;   764 --  far less time than it just took me to write this paragraph.
;   765 --
;   766 
;   767     [32]
;   768         mov [esp+16],esi            -- save raw address (overwrite prepend flag[==1])
;   769         -- recap:
;   770         --  [p3] (increfed)     @ [esp]
;   771         --  addr p1 (result)    @ [esp+4]   (with a refcount of 1)
;   772         --  addr p2 in edi and  @ [esp+8]   (== addr p1) [pbr-optimise]
;   773         --  addr p3             @ [esp+12]  (!= addr p1) [non-circular]
;   774         --  esi = raw(p2)       = [esp+16]  (was prepend flag of 1)
;   775         --  era                 @ [esp+20]
;   776         --  edi is slack    (==[esi-20]==0)
;   777         --  edx = length(p2) (==[esi-12])
;   778         --  ecx is (edx*4+20), required (old) size in bytes (which might prove useful!)
;   779         --
;   780         mov edi,ecx                 -- save old size in bytes
;   781         lea ecx,[ebx+edx*2+1]       -- length*2+1
;   782         mov edx,[esp+20]            -- era
;   783         call :%pAllocSeq            -- damages eax only
;   784         mov edx,[ebx+eax*4-16]      -- new maxlen
;   785         mov ecx,[esi-12]            -- old length
;   786         push edx                    --[1] copy new maxlen
;   787         sub edx,edi                 -- less old (used) size in bytes
;   788         add ecx,1                   -- new length
;   789         shr edx,1                   -- /2
;   790         push dword[esi-4]           --[2] copy type/delete_rtn
;   791         and edx,#FFFFFFFC           -- new slack, truncated to whole number of dwords
;   792 --DEV sopping great AGI here...
;   793         lea edi,[edx+eax*4+4]       -- new raw address[2]
;   794 --...so, tryme:
;   795 --      lea edi,[ebx+eax*4+4]
;   796 --      add edi,edx
;   797         mov [edx+eax*4-12],ecx      -- set new length
;   798         lea eax,[edx+eax*4+1]       -- new ref part 1 (slack+raw+1)
;   799         mov ecx,[esi-12]            -- original length (for rep movsd)
;   800         -- plant new header and replace ref now...
;   801         mov [edi-24],edx            -- new slack
;   802         ror eax,2                   -- new ref part 2
;   803         mov edx,[esp+12]            -- target addr (p1) [@[esp+4] on entry to PpndSeqClone]
;   804         pop dword[edi-8]            --[2] type/delete_rtn
;   805         pop dword[edi-20]           --[1] copy maxlen
;   806         mov dword[edi-12],1         -- refcount
;   807         mov [edx],eax
;   808         mov edx,esi                 -- (save for pFreePool)
;   809         pop dword[edi-4]            -- new[1]
;   810         rep movsd
;   811         mov ecx,[edx-16]        -- maxlen (allocated size in bytes)
;   812         lea eax,[edx-20]
;   813 --      sub eax,[edx-20]        -- account for any slack    [known to be 0]
;   814         add esp,16
;   815         mov edx,[esp]
;   816         jmp :%pFreePool         -- free ecx bytes at eax (ignoring any delete_routine)
;   817     [64]
;   818         mov [rsp+32],rsi            -- save raw address (overwrite prepend flag[==1])
                mov [rsp+32],rsi          ;#0043FF06: 48:211164044 20            uv 00 50  1 192      
;   819         -- recap:
;   820         --  [p3] (increfed)     @ [rsp]
;   821         --  addr p1 (result)    @ [rsp+8]   (with a refcount of 1)
;   822         --  addr p2 in edi and  @ [rsp+16]  (== addr p1) [pbr-optimise]
;   823         --  addr p3             @ [rsp+24]  (!= addr p1) [non-circular]
;   824         --  rsi = raw(p2)       = [rsp+32]  (was prepend flag of 1)
;   825         --  era                 @ [rsp+40]
;   826         --  rdi is slack    (==[rsi-40]==0)
;   827         --  rdx = length(p2) (==[rsi-24])
;   828 --      --  rcx is (rdx*4+40), required (old) size in bytes (which might prove useful!)
;   829         --  rcx is (rdx*8+40), required (old) size in bytes (which might prove useful!)
;   830         --
;   831         mov rdi,rcx                 -- save old size in bytes
                mov rdi,rcx               ;#0043FF0B: 48:213371                  vu 80 02  1 192      
;   832         lea rcx,[rbx+rdx*2+1]       -- length*2+1
                lea rcx,[rbx+rdx*2+1]     ;#0043FF0E: 48:215114123 01            uv 02 0C  1 193      
;   833         mov rdx,[rsp+40]            -- era
                mov rdx,[rsp+40]          ;#0043FF13: 48:213124044 28            vu 04 10  1 193      
;   834         call :%pAllocSeq            -- damages eax only
                call #00442148 (:%pAllocSeq)  ;#0043FF18: 350 2B220000               v  00 00  1 194      
;   835         mov rdx,[rbx+rax*4-32]      -- new maxlen
                mov rdx,[rbx+rax*4-32]    ;#0043FF1D: 48:213124203 E0            uv 04 09  1 195      
;   836         mov rcx,[rsi-24]            -- old length
                mov rcx,[rsi-24]          ;#0043FF22: 48:213116 E8               vu 02 40  1 195      
;   837         push rdx                    --[1] copy new maxlen
                push rdx                  ;#0043FF26: 48:122                     uv 00 04  1 196      
;   838         sub rdx,rdi                 -- less old (used) size in bytes
                sub rdx,rdi               ;#0043FF28: 48:051372                  vu 04 84  1 196      
;   839         add rcx,1                   -- new length
                add rcx,1                 ;#0043FF2B: 48:203301 01               uv 02 02  1 197      
;   840         shr rdx,1                   -- /2
                shr rdx,1                 ;#0043FF2F: 48:321352                  u  04 04  1 198      
;   841         push qword[rsi-8]           --[2] copy type/delete_rtn
                push qword[rsi-8]         ;#0043FF32: 48:377166 F8               np 00 40  2 199      
;   842         and rdx,#FFFFFFF8           -- new slack, truncated to whole number of qwords
                and rdx,-8                ;#0043FF36: 48:201342 F8FFFFFF         uv 04 04  1 201      
;   843 --DEV sopping great AGI here...
;   844         lea rdi,[rdx+rax*4+8]       -- new raw address[2]
                lea rdi,[rdx+rax*4+8]     ;#0043FF3D: 48:215174202 08            uv 80 05  1 204 04 *04*
;   845 --...so, tryme:
;   846 --      lea rdi,[rbx+rax*4+8]
;   847 --      add rdi,rdx
;   848         mov [rdx+rax*4-24],rcx      -- set new length
                mov [rdx+rax*4-24],rcx    ;#0043FF42: 48:211114202 E8            vu 00 07  1 204      
;   849         lea rax,[rdx+rax*4+1]       -- new ref part 1 (slack+raw+1)
                lea rax,[rdx+rax*4+1]     ;#0043FF47: 48:215104202 01            uv 01 05  1 205      
;   850         mov rcx,[rsi-24]            -- original length (for rep movsd)
                mov rcx,[rsi-24]          ;#0043FF4C: 48:213116 E8               vu 02 40  1 205      
;   851         -- plant new header and replace ref now...
;   852 --      mov [rdi-48],edx            -- new slack (rdi=raw[2], remember)
;   853         mov [rdi-48],rdx            -- new slack (rdi=raw[2], remember)
                mov [rdi-48],rdx          ;#0043FF50: 48:211127 D0               uv 00 84  1 206      
;   854         ror rax,2                   -- new ref part 2
                ror rax,2                 ;#0043FF54: 48:301310 02               np 01 01  1 207      
;   855         mov rdx,[rsp+24]            -- target addr (p1) [@[esp+8] on entry to PpndSeqClone]
                mov rdx,[rsp+24]          ;#0043FF58: 48:213124044 18            uv 04 10  1 208      
;   856 --DEV fix this in pilasm.e
;   857         pop qword[rdi-16]           --[2] type/delete_rtn
                pop qword[rdi-16]         ;#0043FF5D: 147:217107 F0              np 00 80  3 209      
;   858 --pop rdx
;   859 --mov [rdi-16],rdx
;   860         pop qword[rdi-40]           --[1] copy maxlen
                pop qword[rdi-40]         ;#0043FF61: 147:217107 D8              np 00 80  3 212      
;   861         mov qword[rdi-24],1         -- refcount
                mov qword[rdi-24],1       ;#0043FF65: 48:307107 E8 01000000      uv 00 80  1 215      
;   862         mov [rdx],rax
                mov [rdx],rax             ;#0043FF6D: 48:211002                  vu 00 05  1 215      
;   863         mov rdx,rsi                 -- (save for pFreePool)
                mov rdx,rsi               ;#0043FF70: 48:213326                  uv 04 40  1 216      
;   864         pop qword[rdi-8]            -- new[1]
                pop qword[rdi-8]          ;#0043FF73: 147:217107 F8              np 00 80  3 217      
;   865         rep movsq
                rep movsq                 ;#0043FF77: 363:48:245                 np C2 C2  4 220      
;   866         mov rcx,[rdx-32]        -- maxlen (allocated size in bytes)
                mov rcx,[rdx-32]          ;#0043FF7A: 48:213112 E0               uv 02 04  1 224      
;   867         lea rax,[rdx-40]
                lea rax,[rdx-40]          ;#0043FF7E: 48:215102 D8               vu 01 04  1 224      
;   868 --      sub rax,[rdx-40]        -- account for any slack    [known to be 0]
;   869         add rsp,32
                add rsp,32                ;#0043FF82: 48:203304 20               uv 10 10  1 225      
;   870         mov rdx,[rsp]
                mov rdx,[rsp]             ;#0043FF86: 48:213024044               uv 04 10  1 228 10 *10*
;   871         jmp :%pFreePool         -- free rcx bytes at rax (ignoring any delete_routine)
                jmp #00441FFA (:%pFreePool)  ;#0043FF8A: 351 6B200000               v  00 00  1 228      
;   872     []
;   873 
;   874   ::ApndNewSeq
;   875 --------------
;   876     [32]
;   877         -- recap:
;   878         --  ref(p3) in ecx and  @ [esp] (already incref;d) ([1] from ApndSeq)
;   879         --  addr p1 (result)    @ [esp+4]
;   880         --  addr p2 in edi and  @ [esp+8]
;   881         --  addr p3             @ [esp+12]
;   882         --  prepend flag        @ [esp+16]
;   883         --  era                 @ [esp+20]
;   884         --  esi = raw(p2)
;   885         --  edx = length(p2) (==[esi-12])
;   886         --  al is 0x80      (==[esi-1])
;   887         --
;   888         mov edi,[esp+16]        -- prepend flag ...
;   889         mov ecx,edx             -- original length (for loop)
;   890         shl edi,2               --              ...->dword
;   891         add ecx,1               -- increase length by 1
;   892         mov edx,[esp+20]        -- era
;   893         call :%pAllocSeq        -- damages eax only
;   894         push eax                --[2] save new ref
;   895         lea edi,[edi+eax*4]     -- edi -> new[1] for append, or new[2] for prepend
;   896       ::ApndNewSeqLoop
;   897         sub ecx,1
;   898         jz :ANSNewSeqLoopEnd
;   899             lodsd                       -- mov eax,[esi], esi+=4
;   900             stosd                       -- mov [edi],eax; edi+=4
;   901 --          mov eax,[esi]
;   902 --          add esi,4
;   903 --          mov [edi],eax
;   904 --          add edi,4
;   905             cmp eax,h4
;   906             jl :ApndNewSeqLoop
;   907             add dword[ebx+eax*4-8],1
;   908             jmp ApndNewSeqLoop
;   909       ::ANSNewSeqLoopEnd
;   910         mov esi,[esp+8]         -- target address
;   911         pop eax                 --[2] restore new ref
;   912         pop ecx                 --[1] p3 (from ::ApndSeq)
;   913         mov edx,[esi]           -- prev a
;   914         cmp dword[esp+12],0     -- prepend flag
;   915         je :notprepend2
;   916             mov [ebx+eax*4],ecx -- new[1]:=c
;   917             jmp @f
;   918       ::notprepend2
;   919             mov [edi],ecx       -- new[$]:=c
;   920       @@:
;   921         add esp,16
;   922         mov [esi],eax
;   923         cmp edx,h4
;   924         jle @f
;   925             sub dword[ebx+edx*4-8],1
;   926             jz :%pDealloc
;   927       @@:
;   928         ret
;   929     [64]
;   930         -- recap:
;   931         --  ref(p3) in rcx and  @ [rsp] (already incref;d) ([1] from ApndSeq)
;   932         --  addr p1 (result)    @ [rsp+8]
;   933         --  addr p2 in edi and  @ [rsp+16]
;   934         --  addr p3             @ [rsp+24]
;   935         --  prepend flag        @ [rsp+32]
;   936         --  era                 @ [rsp+40]
;   937         --  rsi = raw(p2)
;   938         --  rdx = length(p2) (==[rsi-24])
;   939         --  al is 0x80      (==[rsi-1])
;   940         --
;   941         mov rdi,[rsp+32]        -- prepend flag ...
                mov rdi,[rsp+32]          ;#0043FF8F: 48:213174044 20            uv 80 10  1 229      
;   942         mov rcx,rdx             -- original length (for loop)
                mov rcx,rdx               ;#0043FF94: 48:213312                  vu 02 04  1 229      
;   943 --      shl rdi,2               --              ...->dword
;   944         shl rdi,3               --              ...->qword
                shl rdi,3                 ;#0043FF97: 48:301347 03               u  80 80  1 230      
;   945         add rcx,1               -- increase length by 1
                add rcx,1                 ;#0043FF9B: 48:203301 01               vu 02 02  1 230      
;   946         mov rdx,[rsp+40]        -- era
                mov rdx,[rsp+40]          ;#0043FF9F: 48:213124044 28            uv 04 10  1 231      
;   947         call :%pAllocSeq        -- damages eax only
                call #00442148 (:%pAllocSeq)  ;#0043FFA4: 350 9F210000               v  00 00  1 231      
;   948         push rax                --[2] save new ref
                push rax                  ;#0043FFA9: 48:120                     uv 00 01  1 232      
;   949         lea rdi,[rdi+rax*4]     -- edi -> new[1] for append, or new[2] for prepend
                lea rdi,[rdi+rax*4]       ;#0043FFAB: 48:215074207               vu 80 81  1 232      
;   950       ::ApndNewSeqLoop
;   951         sub rcx,1
                sub rcx,1                 ;#0043FFAF: 48:203351 01               uv 02 02  1 233      
;   952         jz :ANSNewSeqLoopEnd
                jz #0043FFC6              ;#0043FFB3: 164 11                     v  00 00  1 233      
;   953             lodsq                       -- mov rax,[rsi], rsi+=8
                    lodsq                 ;#0043FFB5: 48:255                     np 41 40  2 234      
;   954             stosq                       -- mov [rdi],rax; rdi+=8
                    stosq                 ;#0043FFB7: 48:253                     np 80 81  3 236      
;   955 --          mov rax,[rsi]
;   956 --          add rsi,8
;   957 --          mov [rdi],rax
;   958 --          add rdi,8
;   959             cmp rax,r15
                    cmp rax,r15           ;#0043FFB9: 49:073307                  uv 00 8001  1 239      
;   960             jl :ApndNewSeqLoop
                    jl #0043FFAF          ;#0043FFBC: 174 F1                     v  00 00  1 239      
;   961             add qword[rbx+rax*4-16],1
                    add qword[rbx+rax*4-16],1  ;#0043FFBE: 48:203104203 F0 01         u  00 09  3 240      
;   962             jmp ApndNewSeqLoop
                    jmp #0043FFAF         ;#0043FFC4: 353 E9                     v  00 00  1 242      
;   963       ::ANSNewSeqLoopEnd
;   964         mov rsi,[rsp+16]        -- target address
                mov rsi,[rsp+16]          ;#0043FFC6: 48:213164044 10            uv 40 10  1 243      
;   965         pop rax                 --[2] restore new ref
                pop rax                   ;#0043FFCB: 48:130                     vu 01 00  1 243      
;   966         pop rcx                 --[1] p3 (from ::ApndSeq)
                pop rcx                   ;#0043FFCD: 48:131                     uv 02 00  1 244      
;   967         mov rdx,[rsi]           -- prev p1
                mov rdx,[rsi]             ;#0043FFCF: 48:213026                  uv 04 40  1 246    *40*
;   968         cmp qword[rsp+24],0     -- prepend flag
                cmp qword[rsp+24],0       ;#0043FFD2: 48:203174044 18 00         u  00 10  2 247      
;   969         je :notprepend2
                je #0043FFE0              ;#0043FFD8: 164 06                     v  00 00  1 248      
;   970             mov [rbx+rax*4],rcx -- new[1]:=p3
                    mov [rbx+rax*4],rcx   ;#0043FFDA: 48:211014203               uv 00 0B  1 249      
;   971             jmp @f
                    jmp #0043FFE3         ;#0043FFDE: 353 03                     v  00 00  1 249      
;   972       ::notprepend2
;   973             mov [rdi],rcx       -- new[$]:=p3
                    mov [rdi],rcx         ;#0043FFE0: 48:211017                  uv 00 82  1 250      
;   974       @@:
;   975         add rsp,32
                add rsp,32                ;#0043FFE3: 48:203304 20               vu 10 10  1 250      
;   976         mov [rsi],rax
                mov [rsi],rax             ;#0043FFE7: 48:211006                  uv 00 41  1 251      
;   977         cmp rdx,r15
                cmp rdx,r15               ;#0043FFEA: 49:073327                  vu 00 8004  1 251      
;   978         jle @f
                jle #0043FFFB             ;#0043FFED: 176 0C                     v  00 00  1 252      
;   979             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043FFEF: 48:203154223 F0 01         u  00 0C  3 253      
;   980             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043FFF5: 017204 DF220000            v  00 00  1 255      
;   981       @@:
;   982         ret
                ret                       ;#0043FFFB: 303                        np 00 00  2 256      
;   983     []
;   984 
;   985 
;   986     [32]
;   987   ::ppMap
;   988         -- Maps p1=p2&p3 to p1=prepend(p3,p2) when p2 atom [and p3 is a sequence/string].
;   989         -- When invoked from from opConcat (p1=p2&p3):
;   990         --  addr p1 @ [esp]
;   991         --  addr p2 @ [esp+4]
;   992         --  addr p3 @ [esp+8]
;   993         --  flag(0) @ [esp+12]
;   994         --  esi is [p2] (an atom)
;   995         --  ecx is [p3] (a sequence/string)
;   996         -- Whereas :%opPpndSA (in opApnd) needs:
;   997         --  addr p2 @ [esp+4] to be (opConcat's) addr p3,
;   998         --  addr p3 @ [esp+8] to be (opConcat's) addr p2,
;   999         -- then (switching to opApnd's p2/p3 order)
;  1000         --  edi to be addr p2 (as by now at [esp+4])
;  1001         --  esi to be [p2] (a sequence/string)
;  1002         --  ecx to be [p3] (an atom)
;  1003         -- So we just need to swap a few things around:
;  1004 --DEV re-check that esi==[edi] when this is all done, for e93vhnbaav:
;  1005         mov edi,[esp+4]
;  1006         mov eax,[esp+8]
;  1007         mov [esp+4],eax
;  1008         mov [esp+8],edi
;  1009         xchg esi,ecx
;  1010         mov dword[esp+12],1 -- set prepend flag
;  1011         jmp :%opPpndSA  -- (Note that opApndA is invoked directly, when p3 is an atom.)
;  1012     [64]
;  1013   ::ppMap64
;  1014         -- Maps p1=p2&p3 to p1=prepend(p3,p2) when p2 atom [and p3 is a sequence/string].
;  1015         -- When invoked from from opConcat (p1=p2&p3):
;  1016         --  addr p1 @ [rsp]
;  1017         --  addr p2 @ [rsp+8]
;  1018         --  addr p3 @ [rsp+16]
;  1019         --  flag(0) @ [rsp+24]
;  1020         --  rsi is [p2] (an atom)
;  1021         --  rcx is [p3] (a sequence/string)
;  1022         -- Whereas :%opPpndSA (in opApnd) needs:
;  1023         --  addr p2 @ [rsp+8] to be (opConcat's) addr p3,
;  1024         --  addr p3 @ [rsp+16] to be (opConcat's) addr p2,
;  1025         -- then (switching to opApnd's p2/p3 order)
;  1026         --  rdi to be addr p2 (as by now at [rsp+8])
;  1027         --  rsi to be [p2] (a sequence/string)
;  1028         --  rcx to be [p3] (an atom)
;  1029         -- So we just need to swap a few things around:
;  1030 --DEV re-check that rsi==[rdi] when this is all donw, for e93vhnbaav:
;  1031         mov rdi,[rsp+8]
                mov rdi,[rsp+8]           ;#0043FFFC: 48:213174044 08            uv 80 10  1 258      
;  1032         mov rax,[rsp+16]
                mov rax,[rsp+16]          ;#00440001: 48:213104044 10            vu 01 10  1 258      
;  1033         mov [rsp+8],rax
                mov [rsp+8],rax           ;#00440006: 48:211104044 08            uv 00 11  1 259      
;  1034         mov [rsp+16],rdi
                mov [rsp+16],rdi          ;#0044000B: 48:211174044 10            vu 00 90  1 259      
;  1035         xchg rsi,rcx
                xchg rsi,rcx              ;#00440010: 48:207316                  np 42 42  3 260      
;  1036         mov qword[rsp+24],1 -- set prepend flag
                mov qword[rsp+24],1       ;#00440013: 48:307104044 18 01000000   uv 00 10  1 263      
;  1037         jmp :%opPpndSA  -- (Note that opApndA is invoked directly, when p3 is an atom.)
                jmp #0043FC32 (:%opPpndSA)  ;#0044001C: 351 11FCFFFF               v  00 00  1 263      
;  1038     []
;  1039 
;  1040 --/*
;  1041 procedure :%opConcat(:%)
;  1042 end procedure -- (for Edita/CtrlQ)
;  1043 --*/
;  1044     :%opConcat
;  1045 --------------
;  1046         --
;  1047         --  p1 = p2&p3
;  1048         --
;  1049         --  Map some cases to opApnd (which, obviously, saves duplicating 
;  1050         --  about 800 lines of code). Note that pmain.e often performs a 
;  1051         --  very similar mapping directly (since every clock counts!).
;  1052         --
;  1053         --  if atom(p3) -> p1 = append(p2,p3)
;  1054         --  elsif atom(p2) -> p1 = prepend(p3,p2) (==:%opApnd with swapped args & a flag of 1)
;  1055         --  elsif p1==p2 and refcount(p1)==1 and spare(p1)>=length(p3) and (not string(p2) or string(p3)) -> in situ
;  1056         --  elsif string(p2) and string(p3) -> new str
;  1057         --  else -> new seq
;  1058         --
;  1059     [32]
;  1060         -- calling convention (for p1:=p2&p3):
;  1061         --  lea edx,[p1]    
;  1062         --  lea edi,[p2]    (opUnassigned)
;  1063         --  lea ecx,[p3]    (opUnassigned)
;  1064         --  call :%opConcat             -- [edx]=[edi]&[ecx]
;  1065         push ebx    -- prepend flag (to match :%opApnd, if we map to it)
;  1066         push ecx    -- p3@[esp+8]
;  1067         push edi    -- p2@[esp+4]
;  1068         push edx    -- p1@[esp]
;  1069 
;  1070         mov esi,[edi]           -- ref of p2
;  1071         mov ecx,[ecx]           -- ref of p3
;  1072 
;  1073         -- is p3 an atom?
;  1074         cmp ecx,h4
;  1075         jl :opApndA
;  1076         test byte[ebx+ecx*4-1],#80
;  1077         jz :opApndA
;  1078 
;  1079         -- is p2 an atom?
;  1080         cmp esi,h4
;  1081         jl :ppMap
;  1082         test byte[ebx+esi*4-1],#80
;  1083         jz :ppMap
;  1084 
;  1085         -- so, p2 and p3 are both string/sequence:
;  1086         
;  1087         shl esi,2           -- convert p2 to raw addr
;  1088         shl ecx,2           -- convert p3 to raw addr
;  1089 
;  1090         mov eax,[esi-12]            -- length p2
;  1091         mov edi,[ecx-12]            -- length p3
;  1092         cmp eax,0
;  1093         jnz @f
;  1094             -- ({} or "") & p3 is just p3
;  1095             -- if p1==p3 then just return
;  1096             cmp edx,[esp+8]
;  1097             je :CCret
;  1098             lea eax,[ecx+1]
;  1099             add dword[ecx-8],1      -- increment refcount of p3.
;  1100             ror eax,2
;  1101 --DEV try (or just reload the ref!) [NO: that's an AGI stall, fair bit more than 3 clocks!]
;  1102 --          mov edx,[ecx-8]
;  1103 --          lea eax,[ecx+1]
;  1104 --          inc edx
;  1105 --          ror eax,2
;  1106 --          mov [ecx-8],edx         -- refcount += 1
;  1107             jmp :CCstore
;  1108       @@:
;  1109         cmp edi,0
;  1110         jne @f
;  1111             -- p2 & ("" or {}) is just p2
;  1112             -- if p1==p2 then just return
;  1113             cmp edx,[esp+4]
;  1114             je :CCret
;  1115 --DEV as above
;  1116             lea eax,[esi+1]
;  1117             add dword[esi-8],1      -- increment refcount of p2.
;  1118             ror eax,2
;  1119             jmp :CCstore
;  1120       @@:
;  1121 
;  1122         add edi,eax
;  1123 --DEV I think this can go:
;  1124         mov eax,[edx]           -- target ref (for in situ checks)
;  1125         cmp byte[esi-1],0x82    -- p2 string?
;  1126         jne :CCtwoSeq
;  1127         cmp byte[ecx-1],0x82    -- p3 string?
;  1128         jne :CCstrSeq
;  1129         --
;  1130         -- is the target==p2 (a string), with a refcount of 1, and does it have space?
;  1131         -- (note: ensuring tgt == p2 also ensures that even if it is p3 we will not 
;  1132         --       damage it before we get round to copying it [I got clobbered on that first try])   --???
;  1133         --
;  1134         cmp edx,[esp+4]
;  1135         jne @f
;  1136 --          cmp byte[ebx+eax*4-1],0x82  -- (next test covers this)
;  1137 --          jne @f
;  1138 --          cmp eax,h4
;  1139 --          jne @f
;  1140 --          cmp dword[ebx+eax*4-8],1
;  1141             cmp dword[esi-8],1
;  1142             jne @f
;  1143             -- for a string, [ref*4-16] is maxlen+sHdr+1
;  1144 --          mov ecx,[ebx+eax*4-16]      -- maxlen
;  1145             mov eax,[esi-16]            -- maxlen
;  1146             sub eax,16+1
;  1147             cmp eax,edi
;  1148             jge :CCstringInSitu
;  1149       @@:
;  1150         mov edx,ecx                 -- save raw(p3)
;  1151         mov ecx,edi
;  1152         call :%pAllocStr            -- damages eax only
;  1153         push eax
;  1154         mov ecx,[esi-12]            -- length(p2)
;  1155         lea edi,[ebx+eax*4]
;  1156         rep movsb
;  1157         mov ecx,[edx-12]            -- length(p3)
;  1158         mov esi,edx
;  1159         add ecx,1                   -- include trailing null
;  1160         rep movsb
;  1161         pop eax
;  1162 
;  1163   ::CCstore
;  1164 -----------
;  1165         mov edi,[esp]           -- target addr
;  1166         add esp,16
;  1167 --DEV try some nop here
;  1168         mov edx,[edi]           -- prev ref
;  1169         mov [edi],eax           -- store new ref
;  1170         cmp edx,h4
;  1171         jle @f
;  1172             sub dword[ebx+edx*4-8],1
;  1173             jz :%pDealloc
;  1174       @@:
;  1175         ret
;  1176 
;  1177   ::CCstringInSitu
;  1178 ------------------
;  1179         -- we have proved that tgt=p2, string, refcount is 1, and there is enough space.
;  1180         -- we just need to copy p3 at end of target and update the length.
;  1181         -- recap:
;  1182         --  addr p1,p2,p3,flag @ [esp],[esp+4],[esp+8],[esp+12]
;  1183         --  edi is the new length
;  1184         --  esi is raw(p2)
;  1185         --  ecx is raw(p3)
;  1186         mov eax,[esi-12]            -- length(p2)
;  1187         mov edx,ecx
;  1188         mov ecx,[ecx-12]            -- length(p3)
;  1189         mov [esi-12],edi            -- set new length
;  1190 --      add esi,eax
;  1191         mov edi,esi
;  1192         mov esi,edx
;  1193         add ecx,1
;  1194         add edi,eax
;  1195         rep movsb                   -- copy p3 content and terminating null
;  1196       ::CCret
;  1197         add esp,16
;  1198         ret
;  1199 --/*
;  1200 <DEV>god knows how I got to the above starting from this...:
;  1201 CCstringInSitu:
;  1202     ; we have proved that tgt=p2, hard left, refcount is 1, and there is enough space.
;  1203     ; we just need to copy p3 at end of target.
;  1204     mov [ebx+eax*4-12],edx      ; set new length
;  1205     sub edx,ecx                 ; length original p3
;  1206 if newBase
;  1207     mov esi,edi
;  1208 end if
;  1209     lea edi,[eax*4+ecx]         ; dest is base p2(=tgt)+length p2
;  1210     lea ecx,[edx+1]
;  1211     rep movsb                   ; copy p3 content and terminating null
;  1212     ret
;  1213 --*/
;  1214 
;  1215   ::CCtwoSeq
;  1216 ------------
;  1217         -- p2 is a dword-sequence, and p3 is a seq/str. Neither are length 0
;  1218         -- recap:
;  1219         --  addr p1,p2,p3,flag @ [esp],[esp+4],[esp+8],[esp+12]
;  1220         --  edi is the new length
;  1221         --  esi is raw(p2)
;  1222         --  ecx is raw(p3)
;  1223         --  edx is addr p1 (==[esp])
;  1224         --  eax is [p1] (if that is any help)
;  1225         cmp edx,[esp+4]         -- p1==p2?
;  1226         jne :CCnewSeq
;  1227         cmp dword[esi-8],1          -- refcount 1?
;  1228         jne :CCnewSeq
;  1229         mov edx,[esi-16]        -- maxlen
;  1230         sub edx,[esi-20]        -- slack (we make no attempt to use that here)
;  1231         sub edx,20
;  1232         shr edx,2               -- (bytes->dwords)
;  1233         cmp edi,edx
;  1234 -- advice taken, 30/1/15:
;  1235 --jg?
;  1236 --      jl :CCnewSeq
;  1237         jg :CCnewSeq
;  1238         mov edx,[esi-12]        -- length(p2)
;  1239         cmp byte[ecx-1],#82
;  1240 --17/6/15:
;  1241         push dword[ecx-12]
;  1242         mov [esi-12],edi        -- replace length now
;  1243         lea edi,[esi+edx*4]
;  1244         mov esi,ecx
;  1245 --NO!; x &= x will have just clobbered this!
;  1246 -->!        mov ecx,[ecx-12]        -- length(p3)
;  1247         pop ecx
;  1248         jne :CCSeqSeqInSitu
;  1249         -- expand the string
;  1250         xor eax,eax
;  1251       @@:
;  1252         lodsb
;  1253         stosd
;  1254         sub ecx,1
;  1255         jnz @b
;  1256         add esp,16
;  1257         ret
;  1258 
;  1259   ::CCSeqSeqInSitu
;  1260 ------------------
;  1261         lodsd
;  1262         stosd
;  1263         cmp eax,h4
;  1264         jl @f
;  1265           add dword[ebx+eax*4-8],1
;  1266       @@:
;  1267         sub ecx,1
;  1268         jnz :CCSeqSeqInSitu
;  1269         add esp,16
;  1270         ret
;  1271 
;  1272   ::CCnewSeq
;  1273 ------------
;  1274         -- p2 is a dword-sequence, and p3 is a seq/str. Neither are length 0
;  1275         -- recap:
;  1276         --  addr p1,p2,p3,flag,era @ [esp],[esp+4],[esp+8],[esp+12],[esp+16]
;  1277         --  edi is the new length
;  1278         --  esi is raw(p2)
;  1279         --  ecx is raw(p3)
;  1280         --  edx is unknown
;  1281 --      --  eax is [p1] (if that is any help) [may try removing that anyway]
;  1282 --      mov edx,ecx
;  1283         mov edx,[esp+16]            -- era
;  1284         push ecx
;  1285         mov ecx,edi
;  1286         call :%pAllocSeq
;  1287         pop edx
;  1288         lea edi,[ebx+eax*4]
;  1289         push eax
;  1290         mov ecx,[esi-12]
;  1291       ::CCnsClonep2Loop 
;  1292         lodsd
;  1293         stosd
;  1294         cmp eax,h4
;  1295         jl @f
;  1296           add dword[ebx+eax*4-8],1
;  1297       @@:
;  1298         sub ecx,1
;  1299         jnz :CCnsClonep2Loop
;  1300         mov ecx,[edx-12]            -- length p3
;  1301         mov esi,edx
;  1302         cmp byte[edx-1],#82
;  1303         jne :CCnsClonep3Loop
;  1304         xor eax,eax
;  1305       ::CCnsExpandp3Loop 
;  1306         lodsb
;  1307         stosd
;  1308         sub ecx,1
;  1309         jnz :CCnsExpandp3Loop
;  1310         pop eax
;  1311         jmp :CCstore
;  1312 
;  1313       ::CCnsClonep3Loop     -- (also used by CCstrSeq)
;  1314         lodsd
;  1315         stosd
;  1316         cmp eax,h4
;  1317         jl @f
;  1318           add dword[ebx+eax*4-8],1
;  1319       @@:
;  1320         sub ecx,1
;  1321         jnz :CCnsClonep3Loop
;  1322         pop eax
;  1323         jmp :CCstore
;  1324     
;  1325   ::CCstrSeq
;  1326 ------------
;  1327         -- p2 is a string, p3 is a dword-sequence. Neither are length 0
;  1328         -- recap:
;  1329         --  addr p1,p2,p3,flag,era @ [esp],[esp+4],[esp+8],[esp+12],[esp+16]
;  1330         --  edi is the new length
;  1331         --  esi is raw(p2)
;  1332         --  ecx is raw(p3)
;  1333         --  edx is addr p1 (==[esp])
;  1334         --  eax is [p1] (if that is any help)
;  1335 --      mov edx,ecx
;  1336         mov edx,[esp+16]            -- era
;  1337         push ecx
;  1338         mov ecx,edi
;  1339         call :%pAllocSeq
;  1340         pop edx
;  1341         lea edi,[ebx+eax*4]
;  1342         push eax
;  1343         mov ecx,[esi-12]
;  1344         xor eax,eax
;  1345       ::CCssExpandp2Loop 
;  1346         lodsb
;  1347         stosd
;  1348         sub ecx,1
;  1349         jnz :CCssExpandp2Loop
;  1350         mov ecx,[edx-12]            -- length p3
;  1351         mov esi,edx
;  1352         jmp :CCnsClonep3Loop
;  1353     
;  1354     [64]
;  1355         -- calling convention (for p1:=p2&p3):
;  1356         --  lea rdx,[p1]    
;  1357         --  lea rdi,[p2]    (opUnassigned)
;  1358         --  lea rcx,[p3]    (opUnassigned)
;  1359         --  call :%opConcat             -- [rdx]=[rdi]&[rcx]
;  1360         push rbx    -- prepend flag (to match :%opApnd, if we map to it)
                push rbx                  ;#00440021: 48:123                     uv 00 08  1 264      
;  1361         push rcx    -- p3@[rsp+16]
                push rcx                  ;#00440023: 48:121                     vu 00 02  1 264      
;  1362         push rdi    -- p2@[rsp+8]
                push rdi                  ;#00440025: 48:127                     uv 00 80  1 265      
;  1363         push rdx    -- p1@[rsp]
                push rdx                  ;#00440027: 48:122                     vu 00 04  1 265      
;  1364 
;  1365         mov rsi,[rdi]           -- ref of p2
                mov rsi,[rdi]             ;#00440029: 48:213067                  uv 40 80  1 266      
;  1366         mov rcx,[rcx]           -- ref of p3
                mov rcx,[rcx]             ;#0044002C: 48:213011                  vu 02 02  1 266      
;  1367         mov r15,h4
                mov r15,h4                ;#0044002F: 49:277 0000000000000040    uv 8000 00  1 267      
;  1368 
;  1369         -- is p3 an atom?
;  1370         cmp rcx,r15
                cmp rcx,r15               ;#00440039: 49:073317                  uv 00 8002  1 268 8000   
;  1371         jl :opApndA
                jl #0043FC23              ;#0044003C: 017214 E1FBFFFF            v  00 00  1 268      
;  1372         test byte[rbx+rcx*4-1],#80
                test byte[rbx+rcx*4-1],#80  ;#00440042: 366104213 FF 80            u  00 0A  2 269      
;  1373         jz :opApndA
                jz #0043FC23              ;#00440047: 017204 D6FBFFFF            v  00 00  1 270      
;  1374 
;  1375         -- is p2 an atom?
;  1376         cmp rsi,r15
                cmp rsi,r15               ;#0044004D: 49:073367                  uv 00 8040  1 271      
;  1377         jl :ppMap64
                jl #0043FFFC              ;#00440050: 174 AA                     v  00 00  1 271      
;  1378         test byte[rbx+rsi*4-1],#80
                test byte[rbx+rsi*4-1],#80  ;#00440052: 366104263 FF 80            u  00 48  2 272      
;  1379         jz :ppMap64
                jz #0043FFFC              ;#00440057: 164 A3                     v  00 00  1 273      
;  1380 
;  1381         -- so, p2 and p3 are both string/sequence:
;  1382         
;  1383         shl rsi,2           -- convert p2 to raw addr
                shl rsi,2                 ;#00440059: 48:301346 02               u  40 40  1 274      
;  1384         shl rcx,2           -- convert p3 to raw addr
                shl rcx,2                 ;#0044005D: 48:301341 02               u  02 02  1 275      
;  1385 
;  1386         mov rax,[rsi-24]            -- length p2
                mov rax,[rsi-24]          ;#00440061: 48:213106 E8               uv 01 40  1 277    *40*
;  1387         mov rdi,[rcx-24]            -- length p3
                mov rdi,[rcx-24]          ;#00440065: 48:213171 E8               uv 80 02  1 279    *02*
;  1388         cmp rax,0
                cmp rax,0                 ;#00440069: 48:203370 00               vu 00 01  1 279      
;  1389         jnz @f
                jnz #00440089             ;#0044006D: 165 1A                     v  00 00  1 280      
;  1390             -- ({} or "") & p3 is just p3
;  1391             -- if p1==p3 then just return
;  1392             cmp rdx,[rsp+16]        -- DEV might refs (rather that addrs) be better?
                    cmp rdx,[rsp+16]      ;#0044006F: 48:073124044 10            uv 00 14  2 281      
;  1393             je :CCret64
                    je #0044013F          ;#00440074: 017204 C5000000            v  00 00  1 282      
;  1394             lea rax,[rcx+1]
                    lea rax,[rcx+1]       ;#0044007A: 48:215101 01               uv 01 02  1 283      
;  1395             add qword[rcx-16],1     -- increment refcount of p3.
                    add qword[rcx-16],1   ;#0044007E: 48:203101 F0 01            u  00 02  3 284      
;  1396             ror rax,2
                    ror rax,2             ;#00440083: 48:301310 02               np 01 01  1 287      
;  1397             jmp :CCstore64
                    jmp #00440101         ;#00440087: 353 78                     v  00 00  1 288      
;  1398       @@:
;  1399         cmp rdi,0
                cmp rdi,0                 ;#00440089: 48:203377 00               uv 00 80  1 289      
;  1400         jne @f
                jne #004400A9             ;#0044008D: 165 1A                     v  00 00  1 289      
;  1401             -- p2 & ("" or {}) is just p2
;  1402             -- if p1==p2 then just return
;  1403             cmp rdx,[rsp+8]         -- ditto
                    cmp rdx,[rsp+8]       ;#0044008F: 48:073124044 08            uv 00 14  2 290      
;  1404             je :CCret64
                    je #0044013F          ;#00440094: 017204 A5000000            v  00 00  1 291      
;  1405             lea rax,[rsi+1]
                    lea rax,[rsi+1]       ;#0044009A: 48:215106 01               uv 01 40  1 292      
;  1406             add qword[rsi-16],1     -- increment refcount of p2.
                    add qword[rsi-16],1   ;#0044009E: 48:203106 F0 01            u  00 40  3 293      
;  1407             ror rax,2
                    ror rax,2             ;#004400A3: 48:301310 02               np 01 01  1 296      
;  1408             jmp :CCstore64
                    jmp #00440101         ;#004400A7: 353 58                     v  00 00  1 297      
;  1409       @@:
;  1410 
;  1411         add rdi,rax
                add rdi,rax               ;#004400A9: 48:001307                  uv 80 81  1 298      
;  1412 --DEV I think this can go:
;  1413 --      mov rax,[rdx]           -- target ref (for in situ checks)
;  1414         cmp byte[rsi-1],0x82    -- p2 string?
                cmp byte[rsi-1],#82       ;#004400AC: 200176 FF 82               u  00 40  2 299      
;  1415         jne :CCtwoSeq64
                jne #00440144             ;#004400B0: 017205 8E000000            v  00 00  1 300      
;  1416         cmp byte[rcx-1],0x82    -- p3 string?
                cmp byte[rcx-1],#82       ;#004400B6: 200171 FF 82               u  00 02  2 301      
;  1417         jne :CCstrSeq64
                jne #00440219             ;#004400BA: 017205 59010000            v  00 00  1 302      
;  1418         --
;  1419         -- is the target==p2 (a string), with a refcount of 1, and does it have space?
;  1420         -- (note: ensuring tgt == p2 also ensures that even if it is p3 we will not 
;  1421         --       damage it before we get round to copying it [I got clobbered on that first try])   --???
;  1422         --
;  1423         cmp rdx,[rsp+8]
                cmp rdx,[rsp+8]           ;#004400C0: 48:073124044 08            uv 00 14  2 303      
;  1424         jne @f
                jne #004400DB             ;#004400C5: 165 14                     v  00 00  1 304      
;  1425             cmp qword[rsi-16],1
                    cmp qword[rsi-16],1   ;#004400C7: 48:203176 F0 01            u  00 40  2 305      
;  1426             jne @f
                    jne #004400DB         ;#004400CC: 165 0D                     v  00 00  1 306      
;  1427             mov rax,[rsi-32]            -- maxlen
                    mov rax,[rsi-32]      ;#004400CE: 48:213106 E0               uv 01 40  1 307      
;  1428             sub rax,32+1
                    sub rax,33            ;#004400D2: 48:203350 21               uv 01 01  1 308 01   
;  1429             cmp rax,rdi
                    cmp rax,rdi           ;#004400D6: 48:071370                  uv 00 81  1 309 01   
;  1430             jge :CCstringInSitu64
                    jge #00440121         ;#004400D9: 175 46                     v  00 00  1 309      
;  1431       @@:
;  1432         mov rdx,rcx                 -- save raw(p3)
                mov rdx,rcx               ;#004400DB: 48:213321                  uv 04 02  1 310      
;  1433         mov rcx,rdi
                mov rcx,rdi               ;#004400DE: 48:213317                  vu 02 80  1 310      
;  1434         call :%pAllocStr            -- damages eax only
                call #004420E3 (:%pAllocStr)  ;#004400E1: 350 FD1F0000               v  00 00  1 311      
;  1435         push rax
                push rax                  ;#004400E6: 48:120                     uv 00 01  1 312      
;  1436         mov rcx,[rsi-24]            -- length(p2)
                mov rcx,[rsi-24]          ;#004400E8: 48:213116 E8               vu 02 40  1 312      
;  1437         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#004400EC: 48:215074203               uv 80 09  1 313      
;  1438         rep movsb
                rep movsb                 ;#004400F0: 363:244                    np C2 C2  4 316    *80*
;  1439         mov rcx,[rdx-24]            -- length(p3)
                mov rcx,[rdx-24]          ;#004400F2: 48:213112 E8               uv 02 04  1 320      
;  1440         mov rsi,rdx
                mov rsi,rdx               ;#004400F6: 48:213362                  vu 40 04  1 320      
;  1441         add rcx,1                   -- include trailing null
                add rcx,1                 ;#004400F9: 48:203301 01               uv 02 02  1 321      
;  1442         rep movsb
                rep movsb                 ;#004400FD: 363:244                    np C2 C2  4 323    *40*
;  1443         pop rax
                pop rax                   ;#004400FF: 48:130                     uv 01 00  1 327      
;  1444 
;  1445   ::CCstore64
;  1446 -------------
;  1447         mov rdi,[rsp]           -- target addr
                mov rdi,[rsp]             ;#00440101: 48:213074044               vu 80 10  1 327      
;  1448         add rsp,32
                add rsp,32                ;#00440105: 48:203304 20               uv 10 10  1 328      
;  1449 --DEV try some nop here
;  1450         mov rdx,[rdi]           -- prev ref
                mov rdx,[rdi]             ;#00440109: 48:213027                  uv 04 80  1 330    *80*
;  1451         mov [rdi],rax           -- store new ref
                mov [rdi],rax             ;#0044010C: 48:211007                  vu 00 81  1 330      
;  1452         cmp rdx,r15
                cmp rdx,r15               ;#0044010F: 49:073327                  uv 00 8004  1 331      
;  1453         jle @f
                jle #00440120             ;#00440112: 176 0C                     v  00 00  1 331      
;  1454             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#00440114: 48:203154223 F0 01         u  00 0C  3 332      
;  1455             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0044011A: 017204 BA210000            v  00 00  1 334      
;  1456       @@:
;  1457         ret
                ret                       ;#00440120: 303                        np 00 00  2 335      
;  1458 
;  1459   ::CCstringInSitu64
;  1460 --------------------
;  1461         -- we have proved that tgt=p2, string, refcount is 1, and there is enough space.
;  1462         -- we just need to copy p3 at end of target and update the length.
;  1463         -- recap:
;  1464         --  addr p1,p2,p3,flag @ [rsp],[rsp+8],[rsp+16],[rsp+24]
;  1465         --  rdi is the new length
;  1466         --  rsi is raw(p2)
;  1467         --  rcx is raw(p3)
;  1468         mov rax,[rsi-24]            -- length(p2)
                mov rax,[rsi-24]          ;#00440121: 48:213106 E8               uv 01 40  1 337      
;  1469         mov rdx,rcx
                mov rdx,rcx               ;#00440125: 48:213321                  vu 04 02  1 337      
;  1470         mov rcx,[rcx-24]            -- length(p3)
                mov rcx,[rcx-24]          ;#00440128: 48:213111 E8               uv 02 02  1 338      
;  1471         mov [rsi-24],rdi            -- set new length
                mov [rsi-24],rdi          ;#0044012C: 48:211176 E8               vu 00 C0  1 338      
;  1472         mov rdi,rsi
                mov rdi,rsi               ;#00440130: 48:213376                  uv 80 40  1 339      
;  1473         mov rsi,rdx
                mov rsi,rdx               ;#00440133: 48:213362                  vu 40 04  1 339      
;  1474         add rcx,1
                add rcx,1                 ;#00440136: 48:203301 01               uv 02 02  1 340      
;  1475         add rdi,rax
                add rdi,rax               ;#0044013A: 48:001307                  vu 80 81  1 340      
;  1476         rep movsb                   -- copy p3 content and terminating null
                rep movsb                 ;#0044013D: 363:244                    np C2 C2  4 343    *80*
;  1477       ::CCret64
;  1478         add rsp,32
                add rsp,32                ;#0044013F: 48:203304 20               uv 10 10  1 347      
;  1479         ret
                ret                       ;#00440143: 303                        np 00 00  2 348      
;  1480 
;  1481   ::CCtwoSeq64
;  1482 --------------
;  1483         -- p2 is a dword-sequence, and p3 is a seq/str. Neither are length 0
;  1484         -- recap:
;  1485         --  addr p1,p2,p3,flag @ [rsp],[rsp+8],[rsp+16],[rsp+24]
;  1486         --  rdi is the new length
;  1487         --  rsi is raw(p2)
;  1488         --  rcx is raw(p3)
;  1489         --  rdx is addr p1 (==[rsp])
;  1490 --      --  rax is [p1] (if that is any help) [removed]
;  1491         cmp rdx,[rsp+8]         -- p1==p2?
                cmp rdx,[rsp+8]           ;#00440144: 48:073124044 08            uv 00 14  2 350      
;  1492         jne :CCnewSeq64
                jne #004401AD             ;#00440149: 165 62                     v  00 00  1 351      
;  1493         cmp qword[rsi-16],1         -- refcount 1?
                cmp qword[rsi-16],1       ;#0044014B: 48:203176 F0 01            u  00 40  2 352      
;  1494         jne :CCnewSeq64
                jne #004401AD             ;#00440150: 165 5B                     v  00 00  1 353      
;  1495         mov rdx,[rsi-32]        -- maxlen
                mov rdx,[rsi-32]          ;#00440152: 48:213126 E0               uv 04 40  1 354      
;  1496         sub rdx,[rsi-40]        -- slack (we make no attempt to use that here)
                sub rdx,[rsi-40]          ;#00440156: 48:053126 D8               uv 04 44  2 355 04   
;  1497         sub rdx,40
                sub rdx,40                ;#0044015A: 48:203352 28               uv 04 04  1 357 04   
;  1498         shr rdx,3               -- (bytes->qwords)
                shr rdx,3                 ;#0044015E: 48:301352 03               u  04 04  1 358      
;  1499         cmp rdi,rdx
                cmp rdi,rdx               ;#00440162: 48:071327                  uv 00 84  1 359 04   
;  1500 --jg?
;  1501         jl :CCnewSeq64
                jl #004401AD              ;#00440165: 174 46                     v  00 00  1 359      
;  1502         mov rdx,[rsi-24]        -- length(p2)
                mov rdx,[rsi-24]          ;#00440167: 48:213126 E8               uv 04 40  1 360      
;  1503         cmp byte[rcx-1],#82
                cmp byte[rcx-1],#82       ;#0044016B: 200171 FF 82               u  00 02  2 361      
;  1504 --17/6/15:
;  1505         push qword[rcx-24]
                push qword[rcx-24]        ;#0044016F: 48:377161 E8               np 00 02  2 363      
;  1506         mov [rsi-24],rdi        -- replace length now
                mov [rsi-24],rdi          ;#00440173: 48:211176 E8               uv 00 C0  1 365      
;  1507         lea rdi,[rsi+rdx*4]
                lea rdi,[rsi+rdx*4]       ;#00440177: 48:215074226               vu 80 44  1 365      
;  1508         mov rsi,rcx
                mov rsi,rcx               ;#0044017B: 48:213361                  uv 40 02  1 366      
;  1509 --NO!; x &= x will have just clobbered this!
;  1510 -->     mov rcx,[rcx-24]        -- length(p3)
;  1511         pop rcx
                pop rcx                   ;#0044017E: 48:131                     vu 02 00  1 366      
;  1512         jne :CCSeqSeqInSitu64
                jne #00440193             ;#00440180: 165 11                     v  00 00  1 367      
;  1513         -- expand the string
;  1514         xor rax,rax
                xor rax,rax               ;#00440182: 48:061300                  uv 01 01  1 368      
;  1515       @@:
;  1516         lodsb
                lodsb                     ;#00440185: 254                        np 41 40  2 369      
;  1517         stosq
                stosq                     ;#00440186: 48:253                     np 80 81  3 371      
;  1518         sub rcx,1
                sub rcx,1                 ;#00440188: 48:203351 01               uv 02 02  1 374      
;  1519         jnz @b
                jnz #00440185             ;#0044018C: 165 F7                     v  00 00  1 374      
;  1520         add rsp,32
                add rsp,32                ;#0044018E: 48:203304 20               uv 10 10  1 375      
;  1521         ret
                ret                       ;#00440192: 303                        np 00 00  2 376      
;  1522 
;  1523   ::CCSeqSeqInSitu64
;  1524 --------------------
;  1525         lodsq
                lodsq                     ;#00440193: 48:255                     np 41 40  2 378      
;  1526         stosq
                stosq                     ;#00440195: 48:253                     np 80 81  3 380      
;  1527         cmp rax,r15
                cmp rax,r15               ;#00440197: 49:073307                  uv 00 8001  1 383      
;  1528         jl @f
                jl #004401A2              ;#0044019A: 174 06                     v  00 00  1 383      
;  1529           add qword[rbx+rax*4-16],1
                  add qword[rbx+rax*4-16],1  ;#0044019C: 48:203104203 F0 01         u  00 09  3 384      
;  1530       @@:
;  1531         sub rcx,1
                sub rcx,1                 ;#004401A2: 48:203351 01               vu 02 02  1 386      
;  1532         jnz :CCSeqSeqInSitu64
                jnz #00440193             ;#004401A6: 165 EB                     v  00 00  1 387      
;  1533         add rsp,32
                add rsp,32                ;#004401A8: 48:203304 20               uv 10 10  1 388      
;  1534         ret
                ret                       ;#004401AC: 303                        np 00 00  2 389      
;  1535 
;  1536   ::CCnewSeq64
;  1537 --------------
;  1538         -- p2 is a dword-sequence, and p3 is a seq/str. Neither are length 0
;  1539         -- recap:
;  1540         --  addr p1,p2,p3,flag,era @ [rsp],[rsp+8],[rsp+16],[rsp+24],[rsp+32]
;  1541         --  edi is the new length
;  1542         --  esi is raw(p2)
;  1543         --  ecx is raw(p3)
;  1544         --  edx is unknown
;  1545 --      --  eax is [p1] (if that is any help) [may try removing that anyway][have]
;  1546 --      mov rdx,rcx
;  1547         mov rdx,[rsp+32]            -- era
                mov rdx,[rsp+32]          ;#004401AD: 48:213124044 20            uv 04 10  1 391      
;  1548         push rcx
                push rcx                  ;#004401B2: 48:121                     vu 00 02  1 391      
;  1549         mov rcx,rdi
                mov rcx,rdi               ;#004401B4: 48:213317                  uv 02 80  1 392      
;  1550         call :%pAllocSeq
                call #00442148 (:%pAllocSeq)  ;#004401B7: 350 8C1F0000               v  00 00  1 392      
;  1551         pop rdx
                pop rdx                   ;#004401BC: 48:132                     uv 04 00  1 393      
;  1552         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#004401BE: 48:215074203               vu 80 09  1 393      
;  1553         push rax
                push rax                  ;#004401C2: 48:120                     uv 00 01  1 394      
;  1554         mov rcx,[rsi-24]
                mov rcx,[rsi-24]          ;#004401C4: 48:213116 E8               vu 02 40  1 394      
;  1555       ::CCnsClonep2Loop64
;  1556         lodsq
                lodsq                     ;#004401C8: 48:255                     np 41 40  2 395      
;  1557         stosq
                stosq                     ;#004401CA: 48:253                     np 80 81  3 397      
;  1558         cmp rax,r15
                cmp rax,r15               ;#004401CC: 49:073307                  uv 00 8001  1 400      
;  1559         jl @f
                jl #004401D7              ;#004401CF: 174 06                     v  00 00  1 400      
;  1560           add qword[rbx+rax*4-16],1
                  add qword[rbx+rax*4-16],1  ;#004401D1: 48:203104203 F0 01         u  00 09  3 401      
;  1561       @@:
;  1562         sub rcx,1
                sub rcx,1                 ;#004401D7: 48:203351 01               vu 02 02  1 403      
;  1563         jnz :CCnsClonep2Loop64
                jnz #004401C8             ;#004401DB: 165 EB                     v  00 00  1 404      
;  1564 --      mov rcx,[rdx-12]            -- length p3
;  1565         mov rcx,[rdx-24]            -- length p3
                mov rcx,[rdx-24]          ;#004401DD: 48:213112 E8               uv 02 04  1 405      
;  1566         mov rsi,rdx
                mov rsi,rdx               ;#004401E1: 48:213362                  vu 40 04  1 405      
;  1567         cmp byte[rdx-1],#82
                cmp byte[rdx-1],#82       ;#004401E4: 200172 FF 82               u  00 04  2 406      
;  1568         jne :CCnsClonep3Loop64
                jne #004401FD             ;#004401E8: 165 13                     v  00 00  1 407      
;  1569         xor rax,rax
                xor rax,rax               ;#004401EA: 48:061300                  uv 01 01  1 408      
;  1570       ::CCnsExpandp3Loop64
;  1571         lodsb
                lodsb                     ;#004401ED: 254                        np 41 40  2 409      
;  1572         stosq
                stosq                     ;#004401EE: 48:253                     np 80 81  3 411      
;  1573         sub rcx,1
                sub rcx,1                 ;#004401F0: 48:203351 01               uv 02 02  1 414      
;  1574         jnz :CCnsExpandp3Loop64
                jnz #004401ED             ;#004401F4: 165 F7                     v  00 00  1 414      
;  1575         pop rax
                pop rax                   ;#004401F6: 48:130                     uv 01 00  1 415      
;  1576         jmp :CCstore64
                jmp #00440101             ;#004401F8: 351 04FFFFFF               v  00 00  1 415      
;  1577 
;  1578       ::CCnsClonep3Loop64   -- (also used by CCstrSeq)
;  1579         lodsq
                lodsq                     ;#004401FD: 48:255                     np 41 40  2 416      
;  1580         stosq
                stosq                     ;#004401FF: 48:253                     np 80 81  3 418      
;  1581         cmp rax,r15
                cmp rax,r15               ;#00440201: 49:073307                  uv 00 8001  1 421      
;  1582         jl @f
                jl #0044020C              ;#00440204: 174 06                     v  00 00  1 421      
;  1583           add qword[rbx+rax*4-16],1
                  add qword[rbx+rax*4-16],1  ;#00440206: 48:203104203 F0 01         u  00 09  3 422      
;  1584       @@:
;  1585         sub rcx,1
                sub rcx,1                 ;#0044020C: 48:203351 01               vu 02 02  1 424      
;  1586         jnz :CCnsClonep3Loop64
                jnz #004401FD             ;#00440210: 165 EB                     v  00 00  1 425      
;  1587         pop rax
                pop rax                   ;#00440212: 48:130                     uv 01 00  1 426      
;  1588         jmp :CCstore64
                jmp #00440101             ;#00440214: 351 E8FEFFFF               v  00 00  1 426      
;  1589     
;  1590   ::CCstrSeq64
;  1591 --------------
;  1592         -- p2 is a string, p3 is a dword-sequence. Neither are length 0
;  1593         -- recap:
;  1594         --  addr p1,p2,p3,flag,era @ [rsp],[rsp+8],[rsp+16],[rsp+24],[rsp+32]
;  1595         --  edi is the new length
;  1596         --  esi is raw(p2)
;  1597         --  ecx is raw(p3)
;  1598         --  edx is addr p1 (==[esp])
;  1599         --  eax is [p1] (if that is any help)
;  1600 --      mov rdx,rcx
;  1601         mov rdx,[rsp+32]            -- era
                mov rdx,[rsp+32]          ;#00440219: 48:213124044 20            uv 04 10  1 427      
;  1602         push rcx
                push rcx                  ;#0044021E: 48:121                     vu 00 02  1 427      
;  1603         mov rcx,rdi
                mov rcx,rdi               ;#00440220: 48:213317                  uv 02 80  1 428      
;  1604         call :%pAllocSeq
                call #00442148 (:%pAllocSeq)  ;#00440223: 350 201F0000               v  00 00  1 428      
;  1605         pop rdx
                pop rdx                   ;#00440228: 48:132                     uv 04 00  1 429      
;  1606         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#0044022A: 48:215074203               vu 80 09  1 429      
;  1607         push rax
                push rax                  ;#0044022E: 48:120                     uv 00 01  1 430      
;  1608         mov rcx,[rsi-24]
                mov rcx,[rsi-24]          ;#00440230: 48:213116 E8               vu 02 40  1 430      
;  1609         xor rax,rax
                xor rax,rax               ;#00440234: 48:061300                  uv 01 01  1 431      
;  1610       ::CCssExpandp2Loop64
;  1611         lodsb
                lodsb                     ;#00440237: 254                        np 41 40  2 432      
;  1612         stosq
                stosq                     ;#00440238: 48:253                     np 80 81  3 434      
;  1613         sub rcx,1
                sub rcx,1                 ;#0044023A: 48:203351 01               uv 02 02  1 437      
;  1614         jnz :CCssExpandp2Loop64
                jnz #00440237             ;#0044023E: 165 F7                     v  00 00  1 437      
;  1615         mov rcx,[rdx-24]            -- length p3
                mov rcx,[rdx-24]          ;#00440240: 48:213112 E8               uv 02 04  1 438      
;  1616         mov rsi,rdx
                mov rsi,rdx               ;#00440244: 48:213362                  vu 40 04  1 438      
;  1617         jmp :CCnsClonep3Loop64
                jmp #004401FD             ;#00440247: 353 B4                     v  00 00  1 439      
;  1618     []
;  1619 
;  1620 
;  1621 --/*
;  1622 procedure :%opCatsi(:%)
;  1623 end procedure -- (for Edita/CtrlQ)
;  1624 --*/
;  1625     :%opCatsi
;  1626 -------------
;  1627         --
;  1628         --  Optimised form of opConcat for p1&=p2 (===p1:=p2&p2), when p2 
;  1629         --  is integer or sequence of integer (as proven in the gvar_scan) 
;  1630         --  and p1 is a dword-sequence, and p1!=p2 and both p1,p2 are init.
;  1631         --  (So obviously it uses rep movsd instead of a test/incref loop.)
;  1632         --  Maps to opConcat when refcount!=1, insufficient space, etc.
;  1633         --  Calling this with floats/strings/nested sequences in p2 will
;  1634         --  lead to disaster. Originally, p1 had to be sequence of integer,
;  1635         --  but implementation yielded that it can be any dword-sequence,
;  1636         --  including one containing floats/strings/subsequences, because
;  1637         --  any cloning etc is palmed off to opConcat anyway. It may in 
;  1638         --  fact be valid to call this when p1==p2, but that has never 
;  1639         --  been tested and I strongly doubt it would ever gain anything.
;  1640         --
;  1641     [32]
;  1642         --calling convention:
;  1643         --  mov edi,[p1]    -- (ref)
;  1644         --  lea edx,[p1]    -- (address)    -- (must be init sequence of integer)
;  1645         --  lea esi,[p2]    --   ""         -- (must be init [sequence of] integer)
;  1646         --  call :%opCatsi
;  1647         --
;  1648         cmp dword[ebx+edi*4-8],1    -- refcount of tgt (!=1)
;  1649         jne :UseopConcat
;  1650         push edx                    --[1] save addr p1
;  1651         push esi                    --[2] save addr p2
;  1652         mov eax,[esi]               -- src(p2) ref
;  1653         -- how many new dwords do we need?
;  1654         mov ecx,1                   -- default for p1 &= <int> case
;  1655         cmp eax,h4
;  1656         jl @f
;  1657             mov ecx,[ebx+eax*4-12]  -- length(p2)
;  1658             lea esi,[ebx+eax*4]
;  1659       @@:
;  1660         mov eax,[ebx+edi*4-12]      -- original length p1
;  1661         push esi                    --[3] save
;  1662 --      push ecx                    --[4] save no of items to add
;  1663         -- check there is enough space.
;  1664         mov edx,[ebx+edi*4-20]      -- slack
;  1665         mov esi,[ebx+edi*4-16]      --      maxlen
;  1666         add edi,eax                 -- ref+idx(in dwords)
;  1667         add edx,20                  -- plus header
;  1668         shl edi,2                   -- store new here [ref+idx->raw==lea edi,[edi*4+eax*4]]
;  1669         sub esi,edx                 --      less header+slack
;  1670 --      lea edi,[edi+eax*4]         -- store new here (AGI stall)
;  1671         add eax,ecx                 -- new length
;  1672         shr esi,2                   --      bytes->dwords
;  1673         cmp eax,esi                 -- check maxlen
;  1674         jg :UseopConcatPop
;  1675 
;  1676         mov [ebx+edx*4-12],eax  -- set new length
;  1677 --      pop ecx                 --[4] no of items to add
;  1678         pop esi                 --[3] restore
;  1679         add esp,8               --[2,1] discard
;  1680         rep movsd
;  1681         ret
;  1682 
;  1683       ::UseopConcatPop
;  1684 --      pop ecx                 --[4] discard
;  1685         pop esi                 --[3] discard
;  1686         pop esi                 --[2] restore addr p2
;  1687         pop edx                 --[1] restore addr p1
;  1688       ::UseopConcat
;  1689         mov edi,edx
;  1690         mov ecx,esi
;  1691         jmp :%opConcat
;  1692     [64]
;  1693         --calling convention:
;  1694         --  mov rdi,[p1]    -- (ref)
;  1695         --  lea rdx,[p1]    -- (address)    -- (must be init sequence of integer)
;  1696         --  lea rsi,[p2]    --   ""         -- (must be init [sequence of] integer)
;  1697         --  call :%opCatsi
;  1698         --
;  1699         mov r15,h4
                mov r15,h4                ;#00440249: 49:277 0000000000000040    uv 8000 00  1 440      
;  1700         cmp dword[rbx+rdi*4-16],1   -- refcount of tgt (!=1)
                cmp dword[rbx+rdi*4-16],1  ;#00440253: 203174273 F0 01            u  00 88  2 441      
;  1701         jne :UseopConcat64
                jne #004402B7             ;#00440258: 165 5D                     v  00 00  1 442      
;  1702         push rdx                    --[1] save addr p1
                push rdx                  ;#0044025A: 48:122                     uv 00 04  1 443      
;  1703         push rsi                    --[2] save addr p2
                push rsi                  ;#0044025C: 48:126                     vu 00 40  1 443      
;  1704         mov rax,[rsi]               -- src(p2) ref
                mov rax,[rsi]             ;#0044025E: 48:213006                  uv 01 40  1 444      
;  1705         -- how many new dwords do we need?
;  1706         mov rcx,1                   -- default for p1 &= <int> case
                mov rcx,1                 ;#00440261: 48:307301 01000000         vu 02 00  1 444      
;  1707         cmp rax,r15
                cmp rax,r15               ;#00440268: 49:073307                  uv 00 8001  1 445      
;  1708         jl @f
                jl #00440276              ;#0044026B: 174 09                     v  00 00  1 445      
;  1709             mov rcx,[rbx+rax*4-24]  -- length(p2)
                    mov rcx,[rbx+rax*4-24]  ;#0044026D: 48:213114203 E8            uv 02 09  1 446      
;  1710             lea rsi,[rbx+rax*4]
                    lea rsi,[rbx+rax*4]   ;#00440272: 48:215064203               vu 40 09  1 446      
;  1711       @@:
;  1712         mov rax,[rbx+rdi*4-24]      -- original length p1
                mov rax,[rbx+rdi*4-24]    ;#00440276: 48:213104273 E8            uv 01 88  1 447      
;  1713         push rsi                    --[3] save
                push rsi                  ;#0044027B: 48:126                     vu 00 40  1 447      
;  1714 --      push rcx                    --[4] save no of items to add
;  1715         -- check there is enough space.
;  1716         mov rdx,[rbx+rdi*4-40]      -- slack
                mov rdx,[rbx+rdi*4-40]    ;#0044027D: 48:213124273 D8            uv 04 88  1 448      
;  1717         mov rsi,[rbx+rdi*4-32]      --      maxlen
                mov rsi,[rbx+rdi*4-32]    ;#00440282: 48:213164273 E0            vu 40 88  1 448      
;  1718         lea rdi,[rdi+rax*2]         -- ref+idx*2
                lea rdi,[rdi+rax*2]       ;#00440287: 48:215074107               uv 80 81  1 449      
;  1719         add rdx,40                  -- plus header
                add rdx,40                ;#0044028B: 48:203302 28               vu 04 04  1 449      
;  1720         shl rdi,2                   -- store new here [ref+idx*2->raw==lea rdi,[rdi*4+rax*8]]
                shl rdi,2                 ;#0044028F: 48:301347 02               u  80 80  1 450      
;  1721         sub rsi,rdx                 --      less header+slack
                sub rsi,rdx               ;#00440293: 48:051326                  vu 40 44  1 450      
;  1722         add rax,rcx                 -- new length
                add rax,rcx               ;#00440296: 48:001310                  uv 01 03  1 451      
;  1723         shr rsi,3                   --      bytes->qwords
                shr rsi,3                 ;#00440299: 48:301356 03               u  40 40  1 452      
;  1724         cmp rax,rsi                 -- check maxlen
                cmp rax,rsi               ;#0044029D: 48:071360                  uv 00 41  1 453 40   
;  1725         jg :UseopConcatPop64
                jg #004402B1              ;#004402A0: 177 0F                     v  00 00  1 453      
;  1726 
;  1727         mov [rbx+rdx*4-24],rax  -- set new length
                mov [rbx+rdx*4-24],rax    ;#004402A2: 48:211104223 E8            uv 00 0D  1 454      
;  1728 --      pop rcx                 --[4] no of items to add
;  1729         pop rsi                 --[3] restore
                pop rsi                   ;#004402A7: 48:136                     vu 40 00  1 454      
;  1730         add rsp,16              --[2,1] discard
                add rsp,16                ;#004402A9: 48:203304 10               uv 10 10  1 455      
;  1731         rep movsq
                rep movsq                 ;#004402AD: 363:48:245                 np C2 C2  4 457    *40*
;  1732         ret
                ret                       ;#004402B0: 303                        np 00 00  2 461      
;  1733 
;  1734       ::UseopConcatPop64
;  1735 --      pop rcx                 --[4] discard
;  1736         pop rsi                 --[3] discard
                pop rsi                   ;#004402B1: 48:136                     uv 40 00  1 463      
;  1737         pop rsi                 --[2] restore addr p2
                pop rsi                   ;#004402B3: 48:136                     uv 40 00  1 464 40   
;  1738         pop rdx                 --[1] restore addr p1
                pop rdx                   ;#004402B5: 48:132                     vu 04 00  1 464      
;  1739       ::UseopConcat64
;  1740         mov rdi,rdx
                mov rdi,rdx               ;#004402B7: 48:213372                  uv 80 04  1 465      
;  1741         mov rcx,rsi
                mov rcx,rsi               ;#004402BA: 48:213316                  vu 02 40  1 465      
;  1742         jmp :%opConcat
                jmp #00440021 (:%opConcat)  ;#004402BD: 351 5FFDFFFF               v  00 00  1 466      
;  1743     []
;  1744 
;  1745 --/*
;  1746 procedure :%opConcatN(:%)
;  1747 end procedure -- (for Edita/CtrlQ)
;  1748 --*/
;  1749   :%opConcatN
;  1750 -------------
;  1751         --calling convention
;  1752         -- mov ecx,N            -- (literal, >=3)
;  1753         -- push <return address>
;  1754         -- push [pn]..[p1]      -- (opUnassigned) [DEV]
;  1755         -- mov eax,tgt          -- addr tgt
;  1756         -- jmp :%opConcatN      -- [tgt] = p3&p4&..pn
;  1757         --<return address>
;  1758         --
;  1759         --  logic:
;  1760         --      if (sum lengths while string result) then
;  1761         --          create string
;  1762         --      else (continue summing lengths of dword_sequence)
;  1763         --          create dword_sequence
;  1764         --  i.e. there are two near-identical "sum" loops with the first
;  1765         --       jumping into the middle of the second in several places,
;  1766         --       followed by two near-identical "create" loops. Enjoy!
;  1767         --
;  1768         --  special care must be taken to preserve four things:
;  1769         --      edi = [tgt] or 0 if not insitu-able (first loop only),
;  1770         --      N (ecx, which as above counts down twice),
;  1771         --      addr tgt (edx, which can be 0 if we went insitu), 
;  1772         --      and the newly allocated ref (esi, if any)
;  1773         --  (obviously we can't just throw them on the stack once and 
;  1774         --   then forget about them as we're peeling things off that.)
;  1775         --
;  1776         -- Lemma:
;  1777         --  Technically, a=a&...&a&... /is/ possible to do "in situ",
;  1778         --  however the first thing an insitu does is clobber length(p1),
;  1779         --  and I doubt it would improve performance very often anyway,
;  1780         --  especially as big things are very rarely >50% spare space.
;  1781         --
;  1782     [32]
;  1783         xor edx,edx                     -- output length
;  1784         mov esi,esp                     -- scan thru p1..pn on the stack
;  1785         push eax                        --[1] save addr tgt
;  1786         push ecx                        --[2] save N
;  1787         mov edi,[eax]   -- (may validly be h4, or 0 at the get-go, btw)
;  1788         --
;  1789         -- sum lengths while string result, but check for x = x&... case first
;  1790         --
;  1791         lodsd                           -- mov eax,[esi]; esi+=4, aka load p1
;  1792         cmp eax,edi
;  1793         je :opConcatNStrSumMid          -- (nb opposite of subsequent checks)
;  1794         xor edi,edi                     -- signals first not lhs... (no in situ)
;  1795         jmp :opConcatNStrSumMid
;  1796 
;  1797       ::opConcatNStringSumLoop
;  1798         lodsd                           -- next ref (mov eax,[esi]; esi+=4)
;  1799         cmp eax,edi
;  1800         jne :opConcatNStrSumMid
;  1801         xor edi,edi                     -- ... signals >first (also) lhs  (no in situ)
;  1802       ::opConcatNStrSumMid
;  1803         cmp eax,h4
;  1804         jl @f
;  1805             cmp byte[ebx+eax*4-1],0x82
;  1806             jne :opConcatNSeqCont       -- (continue in dword-sequence loop)
;  1807             add edx,[ebx+eax*4-12]      -- sum lengths
;  1808             jmp :opConcatNContinueStringSumLoop
;  1809       @@:
;  1810         cmp eax,#FF
;  1811         ja :opConcatNSeqAdd1            -- (continue in dword-sequence loop)
;  1812         add edx,1
;  1813       ::opConcatNContinueStringSumLoop
;  1814         sub ecx,1
;  1815         jnz opConcatNStringSumLoop
;  1816 
;  1817         --
;  1818         -- if we got here everything (on rhs) was string or char
;  1819         --
;  1820         -- can we do things in situ?
;  1821         --  result must be = first and != any later, as signalled by edi!=0
;  1822         --  result must already be string with refcount 1 and enough space
;  1823         --
;  1824 --      test edi,edi                -- ref result if first & not later, else 0
;  1825 --      jz opConcatNnewStr          -- result not first/not single use
;  1826         cmp edi,h4                  -- check for char=char&... case (covers "")
;  1827         jle opConcatNnewStr         -- (or 0 or unassigned)
;  1828 --      cmp byte[ebx+edi*4-1],#82   -- type byte (must be, as tgt==p1!)
;  1829 --      jne opConcatNnewStr
;  1830         cmp dword[ebx+edi*4-8],1    -- refcount
;  1831         jne opConcatNnewStr
;  1832         mov ecx,[ebx+edi*4-16]      -- maxlen
;  1833         mov eax,[ebx+edi*4-12]      -- length   
;  1834         sub ecx,16
;  1835         cmp ecx,edx
;  1836         jle :opConcatNnewStr        -- insufficient space
;  1837         mov [ebx+edi*4-12],edx      -- set new length
;  1838         pop ecx                     --[2] restore N
;  1839         mov edx,ebx                 -- target address:=0 (insitu occured)
;  1840         add esp,4                   --[1] discard tgt addr
;  1841         lea edi,[eax+edi*4]         -- stick new content here
;  1842         pop eax                     -- discard first
;  1843         sub ecx,1                   -- process one less entry
;  1844         jmp :opConcatNStrLoop
;  1845 
;  1846       ::opConcatNnewStr
;  1847         mov ecx,edx
;  1848         call :%pAllocStr            -- damages eax only
;  1849         pop ecx                     --[2] re-load N
;  1850         pop edx                     --[1] target address (nb must remain undamaged for a long time)
;  1851         mov esi,eax                 -- save newly allocated ref ("")
;  1852         lea edi,[ebx+eax*4]         -- raw addr of newly allocated string
;  1853       ::opConcatNStrLoop
;  1854         pop eax                     -- next ref
;  1855         cmp eax,h4
;  1856         jl :opConcatNcopyChar
;  1857             push ecx                -- (items left on stack)
;  1858             push esi                -- (newly allocated ref)
;  1859             lea esi,[ebx+eax*4]
;  1860             mov ecx,[ebx+eax*4-12]  -- length
;  1861             rep movsb
;  1862             pop esi
;  1863             pop ecx
;  1864             jmp :opConcatNstrContinue
;  1865       ::opConcatNcopyChar
;  1866         stosb
;  1867       ::opConcatNstrContinue
;  1868         sub ecx,1
;  1869         jnz :opConcatNStrLoop
;  1870 
;  1871         xor eax,eax
;  1872         stosb
;  1873         jmp :opConcatNStore
;  1874 
;  1875 
;  1876       ::opConcatNSeqAdd1    -- eax is a short int, (called from above if signed or too big for char), or a float
;  1877         add edx,1
;  1878         sub ecx,1
;  1879         jz :opConcatNSeqSumLoopEnd
;  1880         --
;  1881         -- carry on summing lengths now we know result is a dword-sequence:
;  1882         --
;  1883       ::opConcatNSeqSumLoop
;  1884         lodsd               -- next ref (still from the stack) (mov eax,[esi], esi+=4)
;  1885         cmp eax,edi
;  1886         jne @f
;  1887             xor edi,edi         -- ... signals >first (also) lhs  (no in situ)
;  1888       @@:
;  1889         cmp eax,h4
;  1890         jl :opConcatNSeqAdd1
;  1891       ::opConcatNSeqCont
;  1892         test byte[ebx+eax*4-1],0x80
;  1893         jz opConcatNSeqAdd1
;  1894         add edx,[ebx+eax*4-12]  -- lengths
;  1895         sub ecx,1
;  1896         jnz :opConcatNSeqSumLoop
;  1897 
;  1898       ::opConcatNSeqSumLoopEnd
;  1899         --
;  1900         -- so result needs to be a dword-sequence of length edx
;  1901         --
;  1902         -- can we do things in situ?
;  1903         --  result must be = first and != any later (as signalled by edi!=0)
;  1904         --  result must already be sequence with refcount 1 and enough space
;  1905         --
;  1906 --      test edi,edi                -- ref result if first & not later, else 0
;  1907 --      jz :opConcatNnewSeq         -- result not first/not single use
;  1908         cmp edi,h4                  -- check for int=int&... case (covers "")
;  1909         jle :opConcatNnewSeq
;  1910         cmp dword[ebx+edi*4-8],1    -- refcount
;  1911         jne :opConcatNnewSeq
;  1912         cmp byte[ebx+edi*4-1],#80   -- type byte
;  1913         jne :opConcatNnewSeq
;  1914         mov ecx,[ebx+edi*4-16]      -- maxlen
;  1915         mov eax,[ebx+edi*4-12]      -- length   
;  1916         sub ecx,20
;  1917 --8/2/15:
;  1918 --      mov esi,[ebx+eax*4-20]      -- slack
;  1919         mov esi,[ebx+edi*4-20]      -- slack
;  1920         shl eax,2                   -- length -> dwords
;  1921         sub ecx,esi                 -- (maxlen-hdr-slack)
;  1922         shl edi,2                   -- ref -> raw
;  1923         shr ecx,2                   -- bytes -> dwords
;  1924         cmp ecx,edx
;  1925         jl :opConcatNnewSeq         -- insufficient space
;  1926         mov [edi-12],edx            -- set new length
;  1927         pop ecx                     -- restore N
;  1928         mov edx,ebx                 -- target address:=0 (insitu occurred)
;  1929         add esp,4                   -- discard addr target
;  1930         add edi,eax                 -- stick new content here
;  1931         pop eax                     -- discard first
;  1932         sub ecx,1                   -- process one less entry
;  1933         jmp :opConcatNSeqLoop
;  1934 
;  1935       ::opConcatNnewSeq
;  1936         mov ecx,edx
;  1937 --DEV wronG!! (2/8/15)
;  1938 --      mov edx,[esp+edx*4]         -- era
;  1939         mov edx,[esp]
;  1940         mov edx,[esp+edx*4+8]
;  1941         call :%pAllocSeq            -- damages eax only
;  1942         pop ecx                     -- re-load N
;  1943         pop edx                     -- target address (nb must remain undamaged for a long time)
;  1944         mov esi,eax                 -- save newly allocated ref ("")
;  1945         lea edi,[ebx+eax*4]         -- raw addr of newly allocated sequence
;  1946 
;  1947       ::opConcatNSeqLoop
;  1948         pop eax                     -- next ref
;  1949         cmp eax,h4
;  1950         jl :opConcatNCopyInt
;  1951             test byte[ebx+eax*4-1],0x80
;  1952             jnz @f
;  1953                 -- it is a float then
;  1954                 add dword[ebx+eax*4-8],1
;  1955                 jmp :opConcatNCopyInt
;  1956           @@:
;  1957             push esi                -- newly allocated ref
;  1958             push ecx                -- remaining N
;  1959             lea esi,[ebx+eax*4]
;  1960             mov ecx,[ebx+eax*4-12]  -- length
;  1961             test ecx,ecx
;  1962             jz :opConcatNZeroLengthString
;  1963             cmp byte[esi-1],0x82
;  1964             je :opConcatNCopyStr
;  1965               ::opConcatNCopySeqLoop
;  1966                 lodsd               -- mov eax,[esi], esi+=4
;  1967                 stosd               -- mov [edi],eax; edi+=4
;  1968                 cmp eax,h4
;  1969                 jl @f
;  1970                     add dword[ebx+eax*4-8],1
;  1971               @@:
;  1972                 sub ecx,1
;  1973                 jnz :opConcatNCopySeqLoop 
;  1974                 pop ecx
;  1975                 pop esi
;  1976                 jmp :opConcatNSeqContinue
;  1977               ::opConcatNCopyStr
;  1978                 xor eax,eax
;  1979               ::opConcatNCharLoop
;  1980                 lodsb               -- mov al,[esi], esi+=1
;  1981                 stosd               -- mov [edi],eax; edi+=4
;  1982                 sub ecx,1
;  1983                 jnz :opConcatNCharLoop 
;  1984           ::opConcatNZeroLengthString
;  1985             pop ecx                 -- remaining N
;  1986             pop esi                 -- newly allocated ref
;  1987             jmp :opConcatNSeqContinue
;  1988       ::opConcatNCopyInt
;  1989         stosd                       -- mov [edi],eax; edi+=4
;  1990       ::opConcatNSeqContinue
;  1991         sub ecx,1
;  1992         jnz :opConcatNSeqLoop
;  1993 
;  1994       ::opConcatNStore
;  1995         mov edi,edx
;  1996         test edx,edx
;  1997         jz @f               -- in situ occurred
;  1998             mov edx,[edi]
;  1999             mov [edi],esi
;  2000             cmp edx,h4
;  2001             jle @f
;  2002                 sub dword[ebx+edx*4-8],1
;  2003                 jz :%pDealloc
;  2004       @@:
;  2005         ret
;  2006 
;  2007     [64]
;  2008         mov r15,h4
                mov r15,h4                ;#004402C2: 49:277 0000000000000040    uv 8000 00  1 467      
;  2009         xor rdx,rdx                     -- output length
                xor rdx,rdx               ;#004402CC: 48:061322                  vu 04 04  1 467      
;  2010         mov rsi,rsp                     -- scan thru p1..pn on the stack
                mov rsi,rsp               ;#004402CF: 48:213364                  uv 40 10  1 468      
;  2011         push rax                        --[1] save addr tgt
                push rax                  ;#004402D2: 48:120                     vu 00 01  1 468      
;  2012         push rcx                        --[2] save N
                push rcx                  ;#004402D4: 48:121                     uv 00 02  1 469      
;  2013         mov rdi,[rax]   -- (may validly be h4, or 0 at the get-go, btw)
                mov rdi,[rax]             ;#004402D6: 48:213070                  vu 80 01  1 469      
;  2014         --
;  2015         -- sum lengths while string result, but check for x = x&... case first
;  2016         --
;  2017         lodsq                           -- mov rax,[rsi]; rsi+=8, aka load p1
                lodsq                     ;#004402D9: 48:255                     np 41 40  2 470      
;  2018         cmp rax,rdi
                cmp rax,rdi               ;#004402DB: 48:071370                  uv 00 81  1 472      
;  2019         je :opConcatNStrSumMid64        -- (nb opposite of subsequent checks)
                je #004402EF              ;#004402DE: 164 0F                     v  00 00  1 472      
;  2020         xor rdi,rdi                     -- signals first not lhs... (no in situ)
                xor rdi,rdi               ;#004402E0: 48:061377                  uv 80 80  1 473      
;  2021         jmp :opConcatNStrSumMid64
                jmp #004402EF             ;#004402E3: 353 0A                     v  00 00  1 473      
;  2022 
;  2023       ::opConcatNStringSumLoop64
;  2024         lodsq                           -- next ref (mov rax,[rsi]; rsi+=8)
                lodsq                     ;#004402E5: 48:255                     np 41 40  2 474      
;  2025         cmp rax,rdi
                cmp rax,rdi               ;#004402E7: 48:071370                  uv 00 81  1 476      
;  2026         jne :opConcatNStrSumMid64
                jne #004402EF             ;#004402EA: 165 03                     v  00 00  1 476      
;  2027         xor rdi,rdi                     -- ... signals >first (also) lhs  (no in situ)
                xor rdi,rdi               ;#004402EC: 48:061377                  uv 80 80  1 477      
;  2028       ::opConcatNStrSumMid64
;  2029         cmp rax,r15
                cmp rax,r15               ;#004402EF: 49:073307                  vu 00 8001  1 477      
;  2030         jl @f
                jl #00440306              ;#004402F2: 174 12                     v  00 00  1 478      
;  2031             cmp byte[rbx+rax*4-1],0x82
                    cmp byte[rbx+rax*4-1],#82  ;#004402F4: 200174203 FF 82            u  00 09  2 479      
;  2032             jne :opConcatNSeqCont64     -- (continue in dword-sequence loop)
                    jne #004403AF         ;#004402F9: 017205 B0000000            v  00 00  1 480      
;  2033             add rdx,[rbx+rax*4-24]      -- sum lengths
                    add rdx,[rbx+rax*4-24]  ;#004402FF: 48:003124203 E8            uv 04 0D  2 481      
;  2034             jmp :opConcatNContinueStringSumLoop64
                    jmp #00440317         ;#00440304: 353 11                     v  00 00  1 482      
;  2035       @@:
;  2036         cmp rax,#FF
                cmp rax,255               ;#00440306: 48:201370 FF000000         uv 00 01  1 483      
;  2037         ja :opConcatNSeqAdd164          -- (continue in dword-sequence loop)
                ja #00440396              ;#0044030D: 017207 83000000            v  00 00  1 483      
;  2038         add rdx,1
                add rdx,1                 ;#00440313: 48:203302 01               uv 04 04  1 484      
;  2039       ::opConcatNContinueStringSumLoop64
;  2040         sub rcx,1
                sub rcx,1                 ;#00440317: 48:203351 01               vu 02 02  1 484      
;  2041         jnz opConcatNStringSumLoop64
                jnz #004402E5             ;#0044031B: 165 C8                     v  00 00  1 485      
;  2042 
;  2043         --
;  2044         -- if we got here everything (on rhs) was string or char
;  2045         --
;  2046         -- can we do things in situ?
;  2047         --  result must be = first and != any later, as signalled by edi!=0
;  2048         --  result must already be string with refcount 1 and enough space
;  2049         --
;  2050 --      test rdi,rdi                -- ref result if first & not later, else 0
;  2051 --      jz :opConcatNnewStr64       -- result not first/not single use
;  2052         cmp rdi,r15                 -- check for char=char&... case (covers "")
                cmp rdi,r15               ;#0044031D: 49:073377                  uv 00 8080  1 486      
;  2053         jle :opConcatNnewStr64      -- (or 0 or unassigned)
                jle #00440357             ;#00440320: 176 35                     v  00 00  1 486      
;  2054 --      cmp byte[rbx+rdi*4-1],#82   -- type byte (must be, as tgt==p1!)
;  2055 --      jne :opConcatNnewStr64
;  2056         cmp qword[rbx+rdi*4-16],1   -- refcount
                cmp qword[rbx+rdi*4-16],1  ;#00440322: 48:203174273 F0 01         u  00 88  2 487      
;  2057         jne :opConcatNnewStr64
                jne #00440357             ;#00440328: 165 2D                     v  00 00  1 488      
;  2058         mov rcx,[rbx+rdi*4-32]      -- maxlen
                mov rcx,[rbx+rdi*4-32]    ;#0044032A: 48:213114273 E0            uv 02 88  1 489      
;  2059         mov rax,[rbx+rdi*4-24]      -- length   
                mov rax,[rbx+rdi*4-24]    ;#0044032F: 48:213104273 E8            vu 01 88  1 489      
;  2060         sub rcx,16
                sub rcx,16                ;#00440334: 48:203351 10               uv 02 02  1 490      
;  2061         cmp rcx,rdx
                cmp rcx,rdx               ;#00440338: 48:071321                  uv 00 06  1 491 02   
;  2062         jle :opConcatNnewStr64      -- insufficient space
                jle #00440357             ;#0044033B: 176 1A                     v  00 00  1 491      
;  2063         mov [rbx+rdi*4-24],rdx      -- set new length
                mov [rbx+rdi*4-24],rdx    ;#0044033D: 48:211124273 E8            uv 00 8C  1 492      
;  2064         pop rcx                     --[2] restore N
                pop rcx                   ;#00440342: 48:131                     vu 02 00  1 492      
;  2065         mov rdx,rbx                 -- target address:=0 (insitu occured)
                mov rdx,rbx               ;#00440344: 48:213323                  uv 04 08  1 493      
;  2066         add rsp,8                   --[1] discard tgt addr
                add rsp,8                 ;#00440347: 48:203304 08               vu 10 10  1 493      
;  2067         lea rdi,[rax+rdi*4]         -- stick new content here
                lea rdi,[rax+rdi*4]       ;#0044034B: 48:215074270               uv 80 81  1 494      
;  2068         pop rax                     -- discard first
                pop rax                   ;#0044034F: 48:130                     vu 01 00  1 494      
;  2069         sub rcx,1                   -- process one less entry
                sub rcx,1                 ;#00440351: 48:203351 01               uv 02 02  1 495      
;  2070         jmp :opConcatNStrLoop64
                jmp #0044036A             ;#00440355: 353 13                     v  00 00  1 495      
;  2071 
;  2072       ::opConcatNnewStr64
;  2073         mov rcx,rdx
                mov rcx,rdx               ;#00440357: 48:213312                  uv 02 04  1 496      
;  2074         call :%pAllocStr            -- damages eax only
                call #004420E3 (:%pAllocStr)  ;#0044035A: 350 841D0000               v  00 00  1 496      
;  2075         pop rcx                     --[2] re-load N
                pop rcx                   ;#0044035F: 48:131                     uv 02 00  1 497      
;  2076         pop rdx                     --[1] target address (nb must remain undamaged for a long time)
                pop rdx                   ;#00440361: 48:132                     vu 04 00  1 497      
;  2077         mov rsi,rax                 -- save newly allocated ref ("")
                mov rsi,rax               ;#00440363: 48:213360                  uv 40 01  1 498      
;  2078         lea rdi,[rbx+rax*4]         -- raw addr of newly allocated string
                lea rdi,[rbx+rax*4]       ;#00440366: 48:215074203               vu 80 09  1 498      
;  2079       ::opConcatNStrLoop64
;  2080         pop rax                     -- next ref
                pop rax                   ;#0044036A: 48:130                     uv 01 00  1 499      
;  2081         cmp rax,r15
                cmp rax,r15               ;#0044036C: 49:073307                  uv 00 8001  1 500 01   
;  2082         jl :opConcatNcopyChar64
                jl #00440386              ;#0044036F: 174 15                     v  00 00  1 500      
;  2083             push rcx                -- (items left on stack)
                    push rcx              ;#00440371: 48:121                     uv 00 02  1 501      
;  2084             push rsi                -- (newly allocated ref)
                    push rsi              ;#00440373: 48:126                     vu 00 40  1 501      
;  2085             lea rsi,[rbx+rax*4]
                    lea rsi,[rbx+rax*4]   ;#00440375: 48:215064203               uv 40 09  1 502      
;  2086             mov rcx,[rbx+rax*4-24]  -- length
                    mov rcx,[rbx+rax*4-24]  ;#00440379: 48:213114203 E8            vu 02 09  1 502      
;  2087             rep movsb
                    rep movsb             ;#0044037E: 363:244                    np C2 C2  4 505    *40*
;  2088             pop rsi
                    pop rsi               ;#00440380: 48:136                     uv 40 00  1 509      
;  2089             pop rcx
                    pop rcx               ;#00440382: 48:131                     vu 02 00  1 509      
;  2090             jmp :opConcatNstrContinue64
                    jmp #00440387         ;#00440384: 353 01                     v  00 00  1 510      
;  2091       ::opConcatNcopyChar64
;  2092         stosb
                stosb                     ;#00440386: 252                        np 80 81  3 511      
;  2093       ::opConcatNstrContinue64
;  2094         sub rcx,1
                sub rcx,1                 ;#00440387: 48:203351 01               uv 02 02  1 514      
;  2095         jnz :opConcatNStrLoop64
                jnz #0044036A             ;#0044038B: 165 DD                     v  00 00  1 514      
;  2096 
;  2097         xor rax,rax
                xor rax,rax               ;#0044038D: 48:061300                  uv 01 01  1 515      
;  2098         stosb
                stosb                     ;#00440390: 252                        np 80 81  3 516      
;  2099         jmp :opConcatNStore64
                jmp #00440493             ;#00440391: 351 FD000000               v  00 00  1 519      
;  2100 
;  2101 
;  2102       ::opConcatNSeqAdd164  -- eax is a short int, (called from above if signed or too big for char), or a float
;  2103         add rdx,1
                add rdx,1                 ;#00440396: 48:203302 01               uv 04 04  1 520      
;  2104         sub rcx,1
                sub rcx,1                 ;#0044039A: 48:203351 01               vu 02 02  1 520      
;  2105         jz :opConcatNSeqSumLoopEnd64
                jz #004403C1              ;#0044039E: 164 21                     v  00 00  1 521      
;  2106         --
;  2107         -- carry on summing lengths now we know result is a dword-sequence:
;  2108         --
;  2109       ::opConcatNSeqSumLoop64
;  2110         lodsq               -- next ref (still from the stack) (mov rax,[rsi], rsi+=8)
                lodsq                     ;#004403A0: 48:255                     np 41 40  2 522      
;  2111         cmp rax,rdi
                cmp rax,rdi               ;#004403A2: 48:071370                  uv 00 81  1 524      
;  2112         jne @f
                jne #004403AA             ;#004403A5: 165 03                     v  00 00  1 524      
;  2113             xor rdi,rdi         -- ... signals >first (also) lhs  (no in situ)
                    xor rdi,rdi           ;#004403A7: 48:061377                  uv 80 80  1 525      
;  2114       @@:
;  2115         cmp rax,r15
                cmp rax,r15               ;#004403AA: 49:073307                  vu 00 8001  1 525      
;  2116         jl :opConcatNSeqAdd164
                jl #00440396              ;#004403AD: 174 E7                     v  00 00  1 526      
;  2117       ::opConcatNSeqCont64
;  2118         test byte[rbx+rax*4-1],0x80
                test byte[rbx+rax*4-1],#80  ;#004403AF: 366104203 FF 80            u  00 09  2 527      
;  2119         jz :opConcatNSeqAdd164
                jz #00440396              ;#004403B4: 164 E0                     v  00 00  1 528      
;  2120         add rdx,[rbx+rax*4-24]  -- lengths
                add rdx,[rbx+rax*4-24]    ;#004403B6: 48:003124203 E8            uv 04 0D  2 529      
;  2121         sub rcx,1
                sub rcx,1                 ;#004403BB: 48:203351 01               vu 02 02  1 530      
;  2122         jnz :opConcatNSeqSumLoop64
                jnz #004403A0             ;#004403BF: 165 DF                     v  00 00  1 531      
;  2123 
;  2124       ::opConcatNSeqSumLoopEnd64
;  2125         --
;  2126         -- so result needs to be a dword-sequence of length rdx
;  2127         --
;  2128         -- can we do things in situ?
;  2129         --  result must be = first and != any later (as signalled by edi!=0)
;  2130         --  result must already be sequence with refcount 1 and enough space
;  2131         --
;  2132 --      test rdi,rdi                -- ref result if first & not later, else 0
;  2133 --      jz :opConcatNnewSeq64       -- result not first/not single use
;  2134         cmp rdi,r15                 -- check for int=int&... case (covers "")
                cmp rdi,r15               ;#004403C1: 49:073377                  uv 00 8080  1 532      
;  2135         jle :opConcatNnewSeq64
                jle #00440414             ;#004403C4: 176 4E                     v  00 00  1 532      
;  2136         cmp qword[rbx+rdi*4-16],1   -- refcount
                cmp qword[rbx+rdi*4-16],1  ;#004403C6: 48:203174273 F0 01         u  00 88  2 533      
;  2137         jne :opConcatNnewSeq64
                jne #00440414             ;#004403CC: 165 46                     v  00 00  1 534      
;  2138         cmp byte[rbx+rdi*4-1],#80   -- type byte
                cmp byte[rbx+rdi*4-1],#80  ;#004403CE: 200174273 FF 80            u  00 88  2 535      
;  2139         jne :opConcatNnewSeq64
                jne #00440414             ;#004403D3: 165 3F                     v  00 00  1 536      
;  2140         mov rcx,[rbx+rdi*4-32]      -- maxlen
                mov rcx,[rbx+rdi*4-32]    ;#004403D5: 48:213114273 E0            uv 02 88  1 537      
;  2141         mov rax,[rbx+rdi*4-24]      -- length   
                mov rax,[rbx+rdi*4-24]    ;#004403DA: 48:213104273 E8            vu 01 88  1 537      
;  2142         sub rcx,40
                sub rcx,40                ;#004403DF: 48:203351 28               uv 02 02  1 538      
;  2143 --8/2/15:
;  2144 --      mov rsi,[rbx+rax*4-40]      -- slack
;  2145         mov rsi,[rbx+rdi*4-40]      -- slack
                mov rsi,[rbx+rdi*4-40]    ;#004403E3: 48:213164273 D8            vu 40 88  1 538      
;  2146         shl rax,3                   -- length -> qwords
                shl rax,3                 ;#004403E8: 48:301340 03               u  01 01  1 539      
;  2147         sub rcx,rsi                 -- (maxlen-hdr-slack)
                sub rcx,rsi               ;#004403EC: 48:051361                  vu 02 42  1 539      
;  2148         shl rdi,2                   -- ref -> raw
                shl rdi,2                 ;#004403EF: 48:301347 02               u  80 80  1 540      
;  2149         shr rcx,3                   -- bytes -> qwords
                shr rcx,3                 ;#004403F3: 48:301351 03               u  02 02  1 541      
;  2150         cmp rcx,rdx
                cmp rcx,rdx               ;#004403F7: 48:071321                  uv 00 06  1 542 02   
;  2151         jl :opConcatNnewSeq64       -- insufficient space
                jl #00440414              ;#004403FA: 174 18                     v  00 00  1 542      
;  2152         mov [rdi-24],rdx            -- set new length
                mov [rdi-24],rdx          ;#004403FC: 48:211127 E8               uv 00 84  1 543      
;  2153         pop rcx                     -- restore N
                pop rcx                   ;#00440400: 48:131                     vu 02 00  1 543      
;  2154         mov rdx,rbx                 -- target address:=0 (insitu occurred)
                mov rdx,rbx               ;#00440402: 48:213323                  uv 04 08  1 544      
;  2155         add rsp,8                   -- discard addr target
                add rsp,8                 ;#00440405: 48:203304 08               vu 10 10  1 544      
;  2156         add rdi,rax                 -- stick new content here
                add rdi,rax               ;#00440409: 48:001307                  uv 80 81  1 545      
;  2157         pop rax                     -- discard first
                pop rax                   ;#0044040C: 48:130                     vu 01 00  1 545      
;  2158         sub rcx,1                   -- process one less entry
                sub rcx,1                 ;#0044040E: 48:203351 01               uv 02 02  1 546      
;  2159         jmp :opConcatNSeqLoop64
                jmp #00440430             ;#00440412: 353 1C                     v  00 00  1 546      
;  2160 
;  2161       ::opConcatNnewSeq64
;  2162         mov rcx,rdx
                mov rcx,rdx               ;#00440414: 48:213312                  uv 02 04  1 547      
;  2163 --DEV wronG!! (2/8/15)
;  2164 --      mov rdx,[rsp+rdx*8]         -- era
;  2165         mov rdx,[rsp]
                mov rdx,[rsp]             ;#00440417: 48:213024044               vu 04 10  1 547      
;  2166         mov rdx,[rsp+rdx*8+16]
                mov rdx,[rsp+rdx*8+16]    ;#0044041B: 48:213124324 10            uv 04 14  1 550    *04*
;  2167         call :%pAllocSeq            -- damages eax only
                call #00442148 (:%pAllocSeq)  ;#00440420: 350 231D0000               v  00 00  1 550      
;  2168         pop rcx                     -- re-load N
                pop rcx                   ;#00440425: 48:131                     uv 02 00  1 551      
;  2169         pop rdx                     -- target address (nb must remain undamaged for a long time)
                pop rdx                   ;#00440427: 48:132                     vu 04 00  1 551      
;  2170         mov rsi,rax                 -- save newly allocated ref ("")
                mov rsi,rax               ;#00440429: 48:213360                  uv 40 01  1 552      
;  2171         lea rdi,[rbx+rax*4]         -- raw addr of newly allocated sequence
                lea rdi,[rbx+rax*4]       ;#0044042C: 48:215074203               vu 80 09  1 552      
;  2172 
;  2173       ::opConcatNSeqLoop64
;  2174         pop rax                     -- next ref
                pop rax                   ;#00440430: 48:130                     uv 01 00  1 553      
;  2175         cmp rax,r15
                cmp rax,r15               ;#00440432: 49:073307                  uv 00 8001  1 554 01   
;  2176         jl :opConcatNCopyInt64
                jl #0044048B              ;#00440435: 174 54                     v  00 00  1 554      
;  2177             test byte[rbx+rax*4-1],0x80
                    test byte[rbx+rax*4-1],#80  ;#00440437: 366104203 FF 80            u  00 09  2 555      
;  2178             jnz @f
                    jnz #00440446         ;#0044043C: 165 08                     v  00 00  1 556      
;  2179                 -- it is a float then
;  2180                 add qword[rbx+rax*4-16],1
                        add qword[rbx+rax*4-16],1  ;#0044043E: 48:203104203 F0 01         u  00 09  3 557      
;  2181                 jmp :opConcatNCopyInt64
                        jmp #0044048B     ;#00440444: 353 45                     v  00 00  1 559      
;  2182           @@:
;  2183             push rsi                -- newly allocated ref
                    push rsi              ;#00440446: 48:126                     uv 00 40  1 560      
;  2184             push rcx                -- remaining N
                    push rcx              ;#00440448: 48:121                     vu 00 02  1 560      
;  2185             lea rsi,[rbx+rax*4]
                    lea rsi,[rbx+rax*4]   ;#0044044A: 48:215064203               uv 40 09  1 561      
;  2186             mov rcx,[rbx+rax*4-24]  -- length
                    mov rcx,[rbx+rax*4-24]  ;#0044044E: 48:213114203 E8            vu 02 09  1 561      
;  2187             test rcx,rcx
                    test rcx,rcx          ;#00440453: 48:205311                  uv 00 02  1 562      
;  2188             jz :opConcatNZeroLengthString64
                    jz #00440485          ;#00440456: 164 2D                     v  00 00  1 562      
;  2189             cmp byte[rsi-1],0x82
                    cmp byte[rsi-1],#82   ;#00440458: 200176 FF 82               u  00 40  2 563      
;  2190             je :opConcatNCopyStr64
                    je #00440479          ;#0044045C: 164 1B                     v  00 00  1 564      
;  2191               ::opConcatNCopySeqLoop64
;  2192                 lodsq               -- mov rax,[rsi], rsi+=8
                        lodsq             ;#0044045E: 48:255                     np 41 40  2 565      
;  2193                 stosq               -- mov [rdi],rax; rdi+=8
                        stosq             ;#00440460: 48:253                     np 80 81  3 567      
;  2194                 cmp rax,r15
                        cmp rax,r15       ;#00440462: 49:073307                  uv 00 8001  1 570      
;  2195                 jl @f
                        jl #0044046D      ;#00440465: 174 06                     v  00 00  1 570      
;  2196                     add qword[rbx+rax*4-16],1
                            add qword[rbx+rax*4-16],1  ;#00440467: 48:203104203 F0 01         u  00 09  3 571      
;  2197               @@:
;  2198                 sub rcx,1
                        sub rcx,1         ;#0044046D: 48:203351 01               vu 02 02  1 573      
;  2199                 jnz :opConcatNCopySeqLoop64
                        jnz #0044045E     ;#00440471: 165 EB                     v  00 00  1 574      
;  2200                 pop rcx
                        pop rcx           ;#00440473: 48:131                     uv 02 00  1 575      
;  2201                 pop rsi
                        pop rsi           ;#00440475: 48:136                     vu 40 00  1 575      
;  2202                 jmp :opConcatNSeqContinue64
                        jmp #0044048D     ;#00440477: 353 14                     v  00 00  1 576      
;  2203 
;  2204               ::opConcatNCopyStr64
;  2205                 xor rax,rax
                        xor rax,rax       ;#00440479: 48:061300                  uv 01 01  1 577      
;  2206               ::opConcatNCharLoop64
;  2207                 lodsb               -- mov al,[rsi], rsi+=1
                        lodsb             ;#0044047C: 254                        np 41 40  2 579    *40*
;  2208                 stosq               -- mov [rdi],rax; rdi+=8
                        stosq             ;#0044047D: 48:253                     np 80 81  3 581      
;  2209                 sub rcx,1
                        sub rcx,1         ;#0044047F: 48:203351 01               uv 02 02  1 584      
;  2210                 jnz :opConcatNCharLoop64
                        jnz #0044047C     ;#00440483: 165 F7                     v  00 00  1 584      
;  2211           ::opConcatNZeroLengthString64
;  2212             pop rcx                 -- remaining N
                    pop rcx               ;#00440485: 48:131                     uv 02 00  1 585      
;  2213             pop rsi                 -- newly allocated ref
                    pop rsi               ;#00440487: 48:136                     vu 40 00  1 585      
;  2214             jmp :opConcatNSeqContinue64
                    jmp #0044048D         ;#00440489: 353 02                     v  00 00  1 586      
;  2215 
;  2216       ::opConcatNCopyInt64
;  2217         stosq                       -- mov [rdi],rax; rdi+=8
                stosq                     ;#0044048B: 48:253                     np 80 81  3 587      
;  2218       ::opConcatNSeqContinue64
;  2219         sub rcx,1
                sub rcx,1                 ;#0044048D: 48:203351 01               uv 02 02  1 590      
;  2220         jnz :opConcatNSeqLoop64
                jnz #00440430             ;#00440491: 165 9D                     v  00 00  1 590      
;  2221 
;  2222       ::opConcatNStore64
;  2223         mov rdi,rdx
                mov rdi,rdx               ;#00440493: 48:213372                  uv 80 04  1 591      
;  2224         test rdx,rdx
                test rdx,rdx              ;#00440496: 48:205322                  vu 00 04  1 591      
;  2225         jz @f               -- in situ occurred
                jz #004404B2              ;#00440499: 164 17                     v  00 00  1 592      
;  2226             mov rdx,[rdi]
                    mov rdx,[rdi]         ;#0044049B: 48:213027                  uv 04 80  1 593      
;  2227             mov [rdi],rsi
                    mov [rdi],rsi         ;#0044049E: 48:211067                  vu 00 C0  1 593      
;  2228             cmp rdx,r15
                    cmp rdx,r15           ;#004404A1: 49:073327                  uv 00 8004  1 594      
;  2229             jle @f
                    jle #004404B2         ;#004404A4: 176 0C                     v  00 00  1 594      
;  2230                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#004404A6: 48:203154223 F0 01         u  00 0C  3 595      
;  2231                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#004404AC: 017204 281E0000            v  00 00  1 597      
;  2232       @@:
;  2233         ret
                ret                       ;#004404B2: 303                        np 00 00  2 598      
;  2234     []
;  2235       }
;  2236 
    jmp #0044298D (:%opRetf)              ;#004404B3: 351 D5240000               v  00 00  1 600      
;C:\Program Files (x86)\Phix\builtins\VM\pJcc.e:
;===============================================
;     1 --
;     2 -- pJcc.e
;     3 -- ======
;     4 --
;     5 --  implements :%opJcc and :%opJccE, also [DEV] :%opFind and :%opMatch
;     6 --
;     7 --  Obviously, if the compiler knows a and b are integer, it will just emit a "cmp", 
;     8 --  but if they can be any type, that means comparing ints/floats/strings/sequences 
;     9 --  which is a 4x4 or 16-way task. Things are a little simpler when we only need to 
;    10 --  know eq/ne, as floats/ints are never the same (Phix always stores eg 3.0 as 3) 
;    11 --  and we can cop out early if the lengths do not match. The first two (internal) 
;    12 --  routines, compareSeq and equalSeq, deal with nested sequences, and strings, but 
;    13 --  are also quite happy when given two floats.
;    14 --
;    15 
;    16 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043F88F: 351 F9300000               v  00 00  1   1      
;    17 
;    18 --DEV FIXME: (and the :!bang labels below)
;    19 --  ::e94vhnbaavesi
;    20 --      int3
;    21 --  ::e94vhnbaavedx
;    22 --      int3
;    23     ::e03tfcmbaa
;    24         int3
                int3                      ;#0043F894: 314                        np 00 00 13   2      
;    25 
;    26 --/*
;    27 procedure ::compareSeq(::)
;    28 end procedure -- (for Edita/CtrlQ)
;    29 --*/
;    30     [32]
;    31       ::compareSeq
;    32 ------------------
;    33         -- general compare routine, extended from equalSeq.
;    34         -- use when other than eq or ne (ie lt,le,gt,ge) rqd.
;    35         -- on entry, we have two refs to compare, one in eax,
;    36         --  the other in [edi-4]. (NB this must NOT be called
;    37         --  with short int params or anything unassigned)
;    38         -- Result is the condition code flags
;    39         --  (unlike equalSeq which is just the Z flag)
;    40         -- Assume all registers will be damaged.
;    41         mov edi,[edi-4]
;    42      ::compareSeqR                  -- entry point with refs in eax and edi.
;    43         lea esi,[ebx+eax*4]
;    44         shl edi,2
;    45 --DEV tryme once everything working (avoids an AGI):
;    46 --  mov al,[ebx+eax*4-1]
;    47         mov al,[esi-1]
;    48         cmp edi,esi
;    49         je :compareSeqRet
;    50         mov ah,[edi-1]
;    51         cmp al,0x12
;    52         jne :compareStrX
;    53         cmp ah,0x12
;    54         jne :compareSeqRet          -- sequences > atoms
;    55         -- two floats. First, a direct binary compare allows nan compare:
;    56         mov eax,[edi]
;    57         mov ecx,[edi+4]
;    58         cmp eax,[esi]
;    59         jne @f
;    60             cmp ecx,[esi+4]
;    61             je :compareSeqRet
;    62       @@:
;    63         fld qword[edi]
;    64         fld qword[esi]
;    65         fcompp
;    66         fnstsw ax
;    67         mov ch,ah
;    68 --  and ah,0x7f
;    69 --  shl ch,7
;    70 --  or ah,ch
;    71         mov dh,ah
;    72         and ah,0x7f     -- clear sign
;    73         and dh,0x04     -- keep parity only
;    74         shl ch,7
;    75         shl dh,4        -- parity to Z position
;    76         or ah,ch
;    77         sub ah,dh       -- Clear Z if Parity set
;    78         sahf
;    79       ::compareSeqRet
;    80         ret
;    81 
;    82       ::compareStrX
;    83 
;    84         mov ecx,[esi-12]        -- length
;    85         test ah,0x80            -- type[edi]
;    86 --  jz compareSeqRet0       -- DEV some variation mey be needed here. cmp esi,edi springs to mind...
;    87 --  compareSeqRet0:
;    88         jnz @f
;    89             xor eax,eax
;    90             add eax,1       -- ensure Z=0   [DEV try test esi,esi, since that cannot be zero here]
;    91             ret
;    92       @@:
;    93         mov edx,[edi-12]        -- length
;    94 
;    95         cmp al,0x82             -- type[esi]
;    96         jne :compareSeqX
;    97         -- .. so esi is str
;    98         cmp ah,0x82             -- type[edi]
;    99         jne :compareStrSeq
;   100         -- .. and so is edi
;   101         add ecx,1           ---- include trailing null byte [or hit the edx<ecx case first]
;   102         repe cmpsb
;   103         ret
;   104 
;   105       ::compareStrSeq
;   106         -- .. esi is str, edi is seq
;   107         push ecx
;   108         push edx
;   109         cmp ecx,edx
;   110         jle @f
;   111             mov ecx,edx
;   112       @@:
;   113         add ecx,1           -- as sub ecx,1 at top of loop
;   114         xor eax,eax         -- for lodsb
;   115       ::compareStrVsSeqCharLoop
;   116         sub ecx,1
;   117         jz :compareSeqCompareLengths
;   118         lodsb       -- mov al,[esi], esi+=1
;   119         cmp eax,[edi]
;   120         lea edi,[edi+4]
;   121         je :compareStrVsSeqCharLoop
;   122 --  lea esp,[esp+8]
;   123         pop edx
;   124         pop ecx
;   125         ret
;   126 
;   127       ::compareSeqX
;   128         -- .. so esi is seq
;   129         push ecx
;   130         push edx
;   131         cmp ecx,edx
;   132         jle @f
;   133             mov ecx,edx
;   134       @@:
;   135         cmp ah,0x82                 -- type[edi]
;   136         jne :compareSeqSeq
;   137         -- .. and edi is str
;   138         xchg esi,edi
;   139 --  jmp :compareStrSeq
;   140         add ecx,1           -- as sub ecx,1 at top of loop
;   141         xor eax,eax         -- for lodsb
;   142       ::compareSeqVsStrCharLoop
;   143         sub ecx,1
;   144         jz :compareSeqCompareLengths
;   145         lodsb       -- mov al,[esi], esi+=1
;   146 --  cmp eax,[edi]
;   147         cmp [edi],eax
;   148         lea edi,[edi+4]
;   149         je :compareSeqVsStrCharLoop
;   150 --  lea esp,[esp+8]
;   151         pop edx
;   152         pop ecx
;   153         ret
;   154 
;   155       ::compareSeqSeq
;   156         -- esi and edi are sequences..
;   157         -- we *must* deal with any short ints here...
;   158         or ecx,ecx
;   159         jz :compareSeqCompareLengths
;   160       @@:
;   161         mov edx,[edi]
;   162         lodsd                -- next element of p3 (mov eax,[esi], esi+=4)
;   163         lea edi,[edi+4]
;   164         cmp eax,edx
;   165         je :compareSeqSeqNxt
;   166         cmp eax,h4
;   167         jl :compareSeqReset
;   168         cmp edx,h4
;   169         jl :compareSeqReset
;   170         pushad
;   171         call :compareSeq
;   172         popad
;   173         jnz :compareSeqPop2Ret
;   174       ::compareSeqSeqNxt
;   175         dec ecx
;   176         jnz @b
;   177         nop
;   178       ::compareSeqCompareLengths
;   179         pop edx
;   180         pop ecx
;   181         cmp ecx,edx
;   182         ret
;   183 
;   184       ::compareSeqReset
;   185         cmp eax,edx
;   186       ::compareSeqPop2Ret
;   187 --  lea esp,[esp+8]
;   188         pop edx
;   189         pop ecx
;   190         ret
;   191 
;   192 
;   193 --/*
;   194 procedure ::equalSeq(::)
;   195 end procedure -- (for Edita/CtrlQ)
;   196 --*/
;   197      ::equalSeq -- general equality routine.
;   198 --------------- -- used as the nested part of opFind and opMatch.
;   199                 -- on entry, we have two refs to compare, one in eax,
;   200                 --  the other in [edi-4]. (NB this must NOT be called
;   201                 --  with short int params) Result is Z flag.
;   202                 -- Assume all registers will be damaged
;   203         mov edi,[edi-4]
;   204      ::equalSeqR    -- entry point with refs in eax and edi.
;   205         lea esi,[ebx+eax*4]
;   206         shl edi,2
;   207         mov al,[esi-1]
;   208         cmp edi,esi
;   209         je :equalSeqRet
;   210         cmp al,0x12
;   211         jne :equalStrX
;   212         cmp byte[edi-1],0x12
;   213         jne :equalSeqRet
;   214         -- (direct binary compare allows scan for nan)
;   215         mov eax,[edi]
;   216         mov ecx,[edi+4]
;   217         cmp eax,[esi]
;   218         jne @f
;   219             cmp ecx,[esi+4]
;   220 --je :compareSeqRet -- not needed, removed 21/1/09
;   221       @@:
;   222 --  fld qword[edi]
;   223 --  fld qword[esi]
;   224 --  fcompp
;   225 --  fnstsw ax
;   226 --DEV:
;   227 --  mov ch,ah
;   228 ----    and ah,0x7f
;   229 ----    shl ch,7
;   230 ----    or ah,ch
;   231 --mov dh,ah
;   232 --  and ah,0x7f     -- clear sign
;   233 --and dh,0x04   -- keep parity only
;   234 --  shl ch,7
;   235 --shl dh,4      -- parity to Z position
;   236 --  or ah,ch
;   237 --sub ah,dh     -- Clear Z if Parity set
;   238 --  sahf
;   239         ret
;   240 
;   241       ::equalStrX
;   242         test al,0x80
;   243         jz :equalSeqRet0
;   244         mov dl,[edi-1]                -- type of 2nd param
;   245         mov ecx,[esi-12]        -- length
;   246         test dl,0x80
;   247         jz :equalSeqRet0
;   248         cmp ecx,[edi-12]
;   249         jne :equalSeqRet
;   250         test ecx,ecx
;   251         jz :equalSeqRet
;   252 
;   253         cmp al,0x82
;   254         jne :equalSeqX
;   255         -- .. so esi is str
;   256         cmp dl,0x82
;   257         jne :equalStrSeq
;   258         -- .. and so is edi
;   259         repe cmpsb
;   260         ret
;   261 
;   262       ::equalStrSeq
;   263         -- .. esi is str, edi is seq
;   264         add ecx,1       -- to get Z flag right at end
;   265         xor eax,eax    
;   266       ::equalStrVsSeqCharLoop
;   267         dec ecx
;   268         jz :equalSeqRet
;   269         lodsb       -- mov al,[esi], esi+=1
;   270         cmp eax,[edi]
;   271         lea edi,[edi+4]
;   272         je :equalStrVsSeqCharLoop
;   273         nop
;   274         ret
;   275 
;   276       ::equalSeqX
;   277         cmp al,0x80
;   278         jne :equalSeqRet
;   279         -- .. so esi is seq
;   280         cmp dl,0x82
;   281         jne :equalSeqSeq
;   282         -- .. and edi is str
;   283         xchg esi,edi
;   284         jmp :equalStrSeq
;   285 
;   286       ::equalSeqSeq
;   287         -- esi and edi are sequences, of same length..
;   288         -- we *must* deal with any short ints here...
;   289       @@:
;   290         mov edx,[edi]
;   291         lodsd                -- next element of p3 (mov eax,[esi], esi+=4)
;   292         lea edi,[edi+4]
;   293         cmp eax,edx
;   294         je :equalSeqSeqNxt
;   295         cmp eax,h4
;   296         jl :equalSeqRet
;   297         cmp edx,h4
;   298         jl :equalSeqRet
;   299         pushad
;   300         call :equalSeq
;   301         popad
;   302         jnz :equalSeqRet
;   303       ::equalSeqSeqNxt
;   304         sub ecx,1
;   305         jnz @b
;   306         nop
;   307         ret
;   308 
;   309       ::equalSeqRet0
;   310         --DEV esi and edi are non-zero here, try test esi,esi
;   311         xor eax,eax
;   312         add eax,1       -- ensure Z=0
;   313       ::equalSeqRet
;   314         ret
;   315 
;   316 --/*
;   317 procedure ::compareSeq64(::)
;   318 end procedure -- (for Edita/CtrlQ)
;   319 --*/
;   320     [64]
;   321         ::compareSeq64
;   322 ----------------------
;   323         -- general compare routine.
;   324         -- use when other than eq or ne (ie lt,le,gt,ge) rqd.
;   325         -- on entry, we have two refs to compare, one in rax,
;   326         --  the other in [rdi-8]. (NB this must NOT be called
;   327         --  with short int params or anything unassigned)
;   328         -- Result is the condition code flags
;   329         --  (unlike equalSeq which is just the Z flag)
;   330         -- Assume all registers will be damaged. [DEV currently it is rax/rcx/rdx/rsi/rdi only, r8 on unused]
;   331         mov rdi,[rdi-8]
                mov rdi,[rdi-8]           ;#0043F895: 48:213177 F8               uv 80 80  1  15      
;   332      ::compareSeq64R                    -- entry point with refs in rax and rdi.
;   333         lea rsi,[rbx+rax*4]
                lea rsi,[rbx+rax*4]       ;#0043F899: 48:215064203               vu 40 09  1  15      
;   334         shl rdi,2
                shl rdi,2                 ;#0043F89D: 48:301347 02               u  80 80  1  16      
;   335 --DEV tryme once everything working (avoids an AGI):
;   336 --  mov al,[rbx+rax*4-1]
;   337         mov al,[rsi-1]
                mov al,[esi-1]            ;#0043F8A1: 212106 FF                  uv 01 40  1  18    *40*
;   338         cmp rdi,rsi
                cmp rdi,rsi               ;#0043F8A4: 48:071367                  vu 00 C0  1  18      
;   339         je :compareSeq64Ret
                je #0043F8E5              ;#0043F8A7: 164 3C                     v  00 00  1  19      
;   340         mov ah,[rdi-1]
                mov ah,[edi-1]            ;#0043F8A9: 212147 FF                  uv 01 80  1  20      
;   341         cmp al,0x12
                cmp al,#12                ;#0043F8AC: 200370 12                  uv 00 01  1  21 01   
;   342         jne :compareStr64X
                jne #0043F8E6             ;#0043F8AF: 165 35                     v  00 00  1  21      
;   343         cmp ah,0x12
                cmp ah,#12                ;#0043F8B1: 200374 12                  uv 00 01  1  22      
;   344         jne :compareSeq64Ret            -- sequences > atoms
                jne #0043F8E5             ;#0043F8B4: 165 2F                     v  00 00  1  22      
;   345         -- two floats. First, a direct binary compare allows nan compare:
;   346         mov rax,[rdi]
                mov rax,[rdi]             ;#0043F8B6: 48:213007                  uv 01 80  1  23      
;   347         mov cx,[rdi+8]
                mov cx,word[edi+8]        ;#0043F8B9: 146:213117 08              vu 02 80  1  23      
;   348         cmp rax,[rsi]
                cmp rax,[rsi]             ;#0043F8BD: 48:073006                  uv 00 41  2  24      
;   349         jne @f
                jne #0043F8C8             ;#0043F8C0: 165 06                     v  00 00  1  25      
;   350             cmp cx,[rsi+8]
                    cmp cx,word[esi+8]    ;#0043F8C2: 146:073116 08              uv 00 42  2  26      
;   351             je :compareSeq64Ret
                    je #0043F8E5          ;#0043F8C6: 164 1D                     v  00 00  1  27      
;   352       @@:
;   353         fld tbyte[rdi]
                fld tbyte[rdi]            ;#0043F8C8: 333057                     np 00 80  3  28      
;   354         fld tbyte[rsi]
                fld tbyte[rsi]            ;#0043F8CA: 333056                     np 00 40  3  31      
;   355         fcompp
                fcompp                    ;#0043F8CC: 336331                     np 00 00  1  34      
;   356         fnstsw ax
                fnstsw ax                 ;#0043F8CE: 337340                     np 01 00  6  35      
;   357         mov ch,ah
                mov ch,ah                 ;#0043F8D0: 212354                     uv 02 01  1  41      
;   358         mov dh,ah
                mov dh,ah                 ;#0043F8D2: 212364                     vu 04 01  1  41      
;   359         and ah,0x7f     -- clear sign
                and ah,127                ;#0043F8D4: 200344 7F                  uv 01 01  1  42      
;   360         and dh,0x04     -- keep parity only
                and dh,4                  ;#0043F8D7: 200346 04                  vu 04 04  1  42      
;   361         shl ch,7
                shl ch,7                  ;#0043F8DA: 300345 07                  u  02 02  1  43      
;   362         shl dh,4        -- parity to Z position
                shl dh,4                  ;#0043F8DD: 300346 04                  u  04 04  1  44      
;   363         or ah,ch
                or ah,ch                  ;#0043F8E0: 010354                     vu 01 03  1  44      
;   364         sub ah,dh       -- Clear Z if Parity set
                sub ah,dh                 ;#0043F8E2: 050364                     uv 01 05  1  45      
;   365         sahf
                sahf                      ;#0043F8E4: 236                        np 00 01  2  46      
;   366       ::compareSeq64Ret
;   367         ret
                ret                       ;#0043F8E5: 303                        np 00 00  2  48      
;   368 
;   369       ::compareStr64X
;   370 
;   371         mov rcx,[rsi-24]        -- length
                mov rcx,[rsi-24]          ;#0043F8E6: 48:213116 E8               uv 02 40  1  50      
;   372         test ah,0x80            -- type[rdi]
                test ah,#80               ;#0043F8EA: 366304 80                  vu 00 01  1  50      
;   373 --  compareSeq64Ret0:
;   374         jnz @f
                jnz #0043F8F3             ;#0043F8ED: 165 04                     v  00 00  1  51      
;   375 --          xor eax,eax
;   376 --          add eax,1       -- ensure Z=0   [DEV try test esi,esi, since that cannot be zero here]
;   377             test rsi,rsi    -- ensure Z=0
                    test rsi,rsi          ;#0043F8EF: 48:205366                  uv 00 40  1  52      
;   378             ret
                    ret                   ;#0043F8F2: 303                        np 00 00  2  53      
;   379       @@:
;   380         mov rdx,[rdi-24]        -- length
                mov rdx,[rdi-24]          ;#0043F8F3: 48:213127 E8               uv 04 80  1  55      
;   381 
;   382         cmp al,0x82             -- type[rsi]
                cmp al,#82                ;#0043F8F7: 200370 82                  vu 00 01  1  55      
;   383         jne :compareSeq64X
                jne #0043F934             ;#0043F8FA: 165 38                     v  00 00  1  56      
;   384         -- .. so rsi is str
;   385         cmp ah,0x82             -- type[rdi]
                cmp ah,#82                ;#0043F8FC: 200374 82                  uv 00 01  1  57      
;   386         jne :compareStrSeq64
                jne #0043F908             ;#0043F8FF: 165 07                     v  00 00  1  57      
;   387         -- .. and so is rdi
;   388         add rcx,1           ---- include trailing null byte [or hit the rdx<rcx case first]
                add rcx,1                 ;#0043F901: 48:203301 01               uv 02 02  1  58      
;   389         repe cmpsb
                repe cmpsb                ;#0043F905: 363:246                    np C2 C2  5  59      
;   390         ret
                ret                       ;#0043F907: 303                        np 00 00  2  64      
;   391 
;   392       ::compareStrSeq64
;   393         -- .. rsi is str, rdi is seq
;   394         push rcx
                push rcx                  ;#0043F908: 48:121                     uv 00 02  1  66      
;   395         push rdx
                push rdx                  ;#0043F90A: 48:122                     vu 00 04  1  66      
;   396         cmp rcx,rdx
                cmp rcx,rdx               ;#0043F90C: 48:071321                  uv 00 06  1  67      
;   397         jle @f
                jle #0043F914             ;#0043F90F: 176 03                     v  00 00  1  67      
;   398             mov rcx,rdx
                    mov rcx,rdx           ;#0043F911: 48:213312                  uv 02 04  1  68      
;   399       @@:
;   400         add rcx,1           -- as sub rcx,1 at top of loop
                add rcx,1                 ;#0043F914: 48:203301 01               uv 02 02  1  69 02   
;   401         xor rax,rax         -- for lodsb
                xor rax,rax               ;#0043F918: 48:061300                  vu 01 01  1  69      
;   402       ::compareStrVsSeq64CharLoop
;   403         sub rcx,1
                sub rcx,1                 ;#0043F91B: 48:203351 01               uv 02 02  1  70      
;   404         jz :compareSeq64CompareLengths
                jz #0043F9A5              ;#0043F91F: 017204 80000000            v  00 00  1  70      
;   405         lodsb       -- mov al,[rsi], rsi+=1
                lodsb                     ;#0043F925: 254                        np 41 40  2  71      
;   406         cmp rax,[rdi]
                cmp rax,[rdi]             ;#0043F926: 48:073007                  uv 00 81  2  73      
;   407         lea rdi,[rdi+8]
                lea rdi,[rdi+8]           ;#0043F929: 48:215177 08               vu 80 80  1  74      
;   408         je :compareStrVsSeq64CharLoop
                je #0043F91B              ;#0043F92D: 164 EC                     v  00 00  1  75      
;   409 --  lea rsp,[rsp+16]
;   410         pop rdx
                pop rdx                   ;#0043F92F: 48:132                     uv 04 00  1  76      
;   411         pop rcx
                pop rcx                   ;#0043F931: 48:131                     vu 02 00  1  76      
;   412         ret
                ret                       ;#0043F933: 303                        np 00 00  2  77      
;   413 
;   414       ::compareSeq64X
;   415         -- .. so rsi is seq
;   416         push rcx
                push rcx                  ;#0043F934: 48:121                     uv 00 02  1  79      
;   417         push rdx
                push rdx                  ;#0043F936: 48:122                     vu 00 04  1  79      
;   418         cmp rcx,rdx
                cmp rcx,rdx               ;#0043F938: 48:071321                  uv 00 06  1  80      
;   419         jle @f
                jle #0043F940             ;#0043F93B: 176 03                     v  00 00  1  80      
;   420             mov rcx,rdx
                    mov rcx,rdx           ;#0043F93D: 48:213312                  uv 02 04  1  81      
;   421       @@:
;   422         cmp ah,0x82                 -- type[rdi]
                cmp ah,#82                ;#0043F940: 200374 82                  vu 00 01  1  81      
;   423         jne :compareSeq64Seq
                jne #0043F964             ;#0043F943: 165 1F                     v  00 00  1  82      
;   424         -- .. and rdi is str
;   425         xchg rsi,rdi
                xchg rsi,rdi              ;#0043F945: 48:207376                  np C0 C0  3  83      
;   426 --  jmp :compareStrSeq64
;   427         add rcx,1           -- as sub ecx,1 at top of loop
                add rcx,1                 ;#0043F948: 48:203301 01               uv 02 02  1  86      
;   428         xor rax,rax         -- for lodsb
                xor rax,rax               ;#0043F94C: 48:061300                  vu 01 01  1  86      
;   429       ::compareSeq64VsStrCharLoop
;   430         sub rcx,1
                sub rcx,1                 ;#0043F94F: 48:203351 01               uv 02 02  1  87      
;   431         jz :compareSeq64CompareLengths
                jz #0043F9A5              ;#0043F953: 164 50                     v  00 00  1  87      
;   432         lodsb       -- mov al,[rsi], rsi+=1
                lodsb                     ;#0043F955: 254                        np 41 40  2  88      
;   433 --      cmp rax,[rdi]
;   434         cmp [rdi],rax
                cmp [rdi],rax             ;#0043F956: 48:071007                  uv 00 81  2  90      
;   435         lea rdi,[rdi+8]
                lea rdi,[rdi+8]           ;#0043F959: 48:215177 08               vu 80 80  1  91      
;   436         je :compareSeq64VsStrCharLoop
                je #0043F94F              ;#0043F95D: 164 F0                     v  00 00  1  92      
;   437 --  lea rsp,[rsp+16]
;   438         pop rdx
                pop rdx                   ;#0043F95F: 48:132                     uv 04 00  1  93      
;   439         pop rcx
                pop rcx                   ;#0043F961: 48:131                     vu 02 00  1  93      
;   440         ret
                ret                       ;#0043F963: 303                        np 00 00  2  94      
;   441 
;   442       ::compareSeq64Seq
;   443         -- rsi and rdi are sequences..
;   444         -- we *must* deal with any short ints here...
;   445         test rcx,rcx
                test rcx,rcx              ;#0043F964: 48:205311                  uv 00 02  1  96      
;   446         jz :compareSeq64CompareLengths
                jz #0043F9A5              ;#0043F967: 164 3C                     v  00 00  1  96      
;   447         mov r15,h4
                mov r15,h4                ;#0043F969: 49:277 0000000000000040    uv 8000 00  1  97      
;   448       @@:
;   449         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043F973: 48:213027                  vu 04 80  1  97      
;   450         lodsq                -- next element of p3 (mov rax,[rsi], rsi+=8)
                lodsq                     ;#0043F976: 48:255                     np 41 40  2  98      
;   451         lea rdi,[rdi+8]
                lea rdi,[rdi+8]           ;#0043F978: 48:215177 08               uv 80 80  1 100      
;   452         cmp rax,rdx
                cmp rax,rdx               ;#0043F97C: 48:071320                  vu 00 05  1 100      
;   453         je :compareSeq64SeqNxt
                je #0043F99E              ;#0043F97F: 164 1D                     v  00 00  1 101      
;   454 --      cmp rax,h4
;   455         cmp rax,r15
                cmp rax,r15               ;#0043F981: 49:073307                  uv 00 8001  1 102      
;   456         jl :compareSeq64Reset
                jl #0043F9AD              ;#0043F984: 174 27                     v  00 00  1 102      
;   457 --      cmp rdx,h4
;   458         cmp rdx,r15
                cmp rdx,r15               ;#0043F986: 49:073327                  uv 00 8004  1 103      
;   459         jl :compareSeq64Reset
                jl #0043F9AD              ;#0043F989: 174 22                     v  00 00  1 103      
;   460 --      pushad
;   461 push rsi
        push rsi                          ;#0043F98B: 48:126                     uv 00 40  1 104      
;   462 push rdi
        push rdi                          ;#0043F98D: 48:127                     vu 00 80  1 104      
;   463 push rcx
        push rcx                          ;#0043F98F: 48:121                     uv 00 02  1 105      
;   464         call :compareSeq64
                call #0043F895            ;#0043F991: 350 FFFEFFFF               v  00 00  1 105      
;   465 pop rcx
        pop rcx                           ;#0043F996: 48:131                     uv 02 00  1 106      
;   466 pop rdi
        pop rdi                           ;#0043F998: 48:137                     vu 80 00  1 106      
;   467 pop rsi
        pop rsi                           ;#0043F99A: 48:136                     uv 40 00  1 107      
;   468 --      popad
;   469         jnz :compareSeq64Pop2Ret
                jnz #0043F9B0             ;#0043F99C: 165 12                     v  00 00  1 107      
;   470       ::compareSeq64SeqNxt
;   471         sub rcx,1
                sub rcx,1                 ;#0043F99E: 48:203351 01               uv 02 02  1 108      
;   472         jnz @b
                jnz #0043F973             ;#0043F9A2: 165 CF                     v  00 00  1 108      
;   473         nop
                nop                       ;#0043F9A4: 220                        uv 00 00  1 109      
;   474       ::compareSeq64CompareLengths
;   475         pop rdx
                pop rdx                   ;#0043F9A5: 48:132                     vu 04 00  1 109      
;   476         pop rcx
                pop rcx                   ;#0043F9A7: 48:131                     uv 02 00  1 110      
;   477         cmp rcx,rdx
                cmp rcx,rdx               ;#0043F9A9: 48:071321                  uv 00 06  1 111 02   
;   478         ret
                ret                       ;#0043F9AC: 303                        np 00 00  2 112      
;   479 
;   480       ::compareSeq64Reset
;   481         cmp rax,rdx
                cmp rax,rdx               ;#0043F9AD: 48:071320                  uv 00 05  1 114      
;   482       ::compareSeq64Pop2Ret
;   483 --  lea rsp,[rsp+16]
;   484         pop rdx
                pop rdx                   ;#0043F9B0: 48:132                     vu 04 00  1 114      
;   485         pop rcx
                pop rcx                   ;#0043F9B2: 48:131                     uv 02 00  1 115      
;   486         ret
                ret                       ;#0043F9B4: 303                        np 00 00  2 116      
;   487 
;   488 --/*
;   489 procedure ::equalSeq64(::)
;   490 end procedure -- (for Edita/CtrlQ)
;   491 --*/
;   492      ::equalSeq64 -- nested part of opFind and opMatch...
;   493 ----------------- -- on entry, we have two refs to compare, one in rax,
;   494                   --    the other in [rdi-8]. (NB this must NOT be called
;   495                   --    with short int params) Result is Z flag.
;   496                   -- Damages rax,rcx,rdx,rsi,rdi
;   497         mov rdi,[rdi-8]
                mov rdi,[rdi-8]           ;#0043F9B5: 48:213177 F8               uv 80 80  1 118      
;   498      ::equalSeq64R  -- entry point with refs in rax and rdi.
;   499         lea rsi,[rbx+rax*4]
                lea rsi,[rbx+rax*4]       ;#0043F9B9: 48:215064203               vu 40 09  1 118      
;   500         shl rdi,2
                shl rdi,2                 ;#0043F9BD: 48:301347 02               u  80 80  1 119      
;   501 --DEV (see compare, avoid AGI)
;   502         mov al,[rsi-1]
                mov al,[esi-1]            ;#0043F9C1: 212106 FF                  uv 01 40  1 121    *40*
;   503         cmp rdi,rsi
                cmp rdi,rsi               ;#0043F9C4: 48:071367                  vu 00 C0  1 121      
;   504         je :equalSeq64Ret
                je #0043FA80              ;#0043F9C7: 017204 B3000000            v  00 00  1 122      
;   505         cmp al,0x12
                cmp al,#12                ;#0043F9CD: 200370 12                  uv 00 01  1 123      
;   506         jne :equalStrX64
                jne #0043F9ED             ;#0043F9D0: 165 1B                     v  00 00  1 123      
;   507         cmp byte[rdi-1],0x12
                cmp byte[rdi-1],#12       ;#0043F9D2: 200177 FF 12               u  00 80  2 124      
;   508         jne :equalSeq64Ret
                jne #0043FA80             ;#0043F9D6: 017205 A4000000            v  00 00  1 125      
;   509         -- (direct binary compare allows scan for nan)
;   510         mov rax,[rdi]
                mov rax,[rdi]             ;#0043F9DC: 48:213007                  uv 01 80  1 126      
;   511         mov cx,[rdi+8]
                mov cx,word[edi+8]        ;#0043F9DF: 146:213117 08              vu 02 80  1 126      
;   512         cmp rax,[rsi]
                cmp rax,[rsi]             ;#0043F9E3: 48:073006                  uv 00 41  2 127      
;   513         jne @f
                jne #0043F9EC             ;#0043F9E6: 165 04                     v  00 00  1 128      
;   514             cmp cx,[rsi+8]
                    cmp cx,word[esi+8]    ;#0043F9E8: 146:073116 08              uv 00 42  2 129      
;   515       @@:
;   516         ret
                ret                       ;#0043F9EC: 303                        np 00 00  2 131      
;   517 
;   518       ::equalStrX64
;   519         test al,0x80
                test al,#80               ;#0043F9ED: 250 80                     uv 00 01  1 133      
;   520         jz :equalSeq64Ret0
                jz #0043FA7E              ;#0043F9EF: 017204 89000000            v  00 00  1 133      
;   521         mov dl,[rdi-1]              -- type of 2nd param
                mov dl,[edi-1]            ;#0043F9F5: 212127 FF                  uv 04 80  1 134      
;   522         mov rcx,[rsi-24]            -- length
                mov rcx,[rsi-24]          ;#0043F9F8: 48:213116 E8               vu 02 40  1 134      
;   523         test dl,0x80
                test dl,#80               ;#0043F9FC: 366302 80                  uv 00 04  1 135      
;   524         jz :equalSeq64Ret0
                jz #0043FA7E              ;#0043F9FF: 164 7D                     v  00 00  1 135      
;   525         cmp rcx,[rdi-24]
                cmp rcx,[rdi-24]          ;#0043FA01: 48:073117 E8               uv 00 82  2 136      
;   526         jne :equalSeq64Ret
                jne #0043FA80             ;#0043FA05: 165 79                     v  00 00  1 137      
;   527         test rcx,rcx
                test rcx,rcx              ;#0043FA07: 48:205311                  uv 00 02  1 138      
;   528         jz :equalSeq64Ret
                jz #0043FA80              ;#0043FA0A: 164 74                     v  00 00  1 138      
;   529 
;   530         cmp al,0x82
                cmp al,#82                ;#0043FA0C: 200370 82                  uv 00 01  1 139      
;   531         jne :equalSeq64X
                jne #0043FA32             ;#0043FA0F: 165 21                     v  00 00  1 139      
;   532         -- .. so rsi is str
;   533         cmp dl,0x82
                cmp dl,#82                ;#0043FA11: 200372 82                  uv 00 04  1 140      
;   534         jne :equalStrSeq64
                jne #0043FA19             ;#0043FA14: 165 03                     v  00 00  1 140      
;   535         -- .. and so is rdi
;   536         repe cmpsb
                repe cmpsb                ;#0043FA16: 363:246                    np C2 C2  5 141      
;   537         ret
                ret                       ;#0043FA18: 303                        np 00 00  2 146      
;   538 
;   539       ::equalStrSeq64
;   540         -- .. rsi is str, rdi is seq
;   541         add rcx,1       -- to get Z flag right at end
                add rcx,1                 ;#0043FA19: 48:203301 01               uv 02 02  1 148      
;   542         xor rax,rax    
                xor rax,rax               ;#0043FA1D: 48:061300                  vu 01 01  1 148      
;   543       ::equalStrVsSeq64CharLoop
;   544         sub rcx,1
                sub rcx,1                 ;#0043FA20: 48:203351 01               uv 02 02  1 149      
;   545         jz :equalSeq64Ret
                jz #0043FA80              ;#0043FA24: 164 5A                     v  00 00  1 149      
;   546         lodsb       -- mov al,[rsi], rsi+=1
                lodsb                     ;#0043FA26: 254                        np 41 40  2 150      
;   547         cmp rax,[rdi]
                cmp rax,[rdi]             ;#0043FA27: 48:073007                  uv 00 81  2 152      
;   548         lea rdi,[rdi+8]
                lea rdi,[rdi+8]           ;#0043FA2A: 48:215177 08               vu 80 80  1 153      
;   549         je :equalStrVsSeq64CharLoop
                je #0043FA20              ;#0043FA2E: 164 F0                     v  00 00  1 154      
;   550         nop
                nop                       ;#0043FA30: 220                        uv 00 00  1 155      
;   551         ret
                ret                       ;#0043FA31: 303                        np 00 00  2 156      
;   552 
;   553       ::equalSeq64X
;   554         cmp al,0x80
                cmp al,#80                ;#0043FA32: 200370 80                  uv 00 01  1 158      
;   555         jne :equalSeq64Ret
                jne #0043FA80             ;#0043FA35: 165 49                     v  00 00  1 158      
;   556         -- .. so rsi is seq
;   557         cmp dl,0x82
                cmp dl,#82                ;#0043FA37: 200372 82                  uv 00 04  1 159      
;   558         jne :equalSeq64Seq
                jne #0043FA41             ;#0043FA3A: 165 05                     v  00 00  1 159      
;   559         -- .. and rdi is str
;   560         xchg rsi,rdi
                xchg rsi,rdi              ;#0043FA3C: 48:207376                  np C0 C0  3 160      
;   561         jmp :equalStrSeq64
                jmp #0043FA19             ;#0043FA3F: 353 D8                     v  00 00  1 163      
;   562 
;   563       ::equalSeq64Seq
;   564         -- rsi and rdi are sequences, of same length..
;   565         -- we *must* deal with any short ints here...
;   566         mov r15,h4
                mov r15,h4                ;#0043FA41: 49:277 0000000000000040    uv 8000 00  1 164      
;   567       @@:
;   568         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043FA4B: 48:213027                  uv 04 80  1 166    *80*
;   569         lodsq                -- next element of p3 (mov rax,[rsi], rsi+=8)
                lodsq                     ;#0043FA4E: 48:255                     np 41 40  2 167      
;   570 --      lea rdi,[rdi+4]
;   571         lea rdi,[rdi+8]
                lea rdi,[rdi+8]           ;#0043FA50: 48:215177 08               uv 80 80  1 169      
;   572         cmp rax,rdx
                cmp rax,rdx               ;#0043FA54: 48:071320                  vu 00 05  1 169      
;   573         je :equalSeq64SeqNxt
                je #0043FA76              ;#0043FA57: 164 1D                     v  00 00  1 170      
;   574 --      cmp rax,h4
;   575         cmp rax,r15
                cmp rax,r15               ;#0043FA59: 49:073307                  uv 00 8001  1 171      
;   576         jl :equalSeq64Ret
                jl #0043FA80              ;#0043FA5C: 174 22                     v  00 00  1 171      
;   577 --      cmp rdx,h4
;   578         cmp rdx,r15
                cmp rdx,r15               ;#0043FA5E: 49:073327                  uv 00 8004  1 172      
;   579         jl :equalSeq64Ret
                jl #0043FA80              ;#0043FA61: 174 1D                     v  00 00  1 172      
;   580 --      pushad
;   581 push rsi
        push rsi                          ;#0043FA63: 48:126                     uv 00 40  1 173      
;   582 push rdi
        push rdi                          ;#0043FA65: 48:127                     vu 00 80  1 173      
;   583 push rcx
        push rcx                          ;#0043FA67: 48:121                     uv 00 02  1 174      
;   584         call :equalSeq64
                call #0043F9B5            ;#0043FA69: 350 47FFFFFF               v  00 00  1 174      
;   585 pop rcx
        pop rcx                           ;#0043FA6E: 48:131                     uv 02 00  1 175      
;   586 pop rdi
        pop rdi                           ;#0043FA70: 48:137                     vu 80 00  1 175      
;   587 pop rsi
        pop rsi                           ;#0043FA72: 48:136                     uv 40 00  1 176      
;   588 --      popad
;   589         jnz :equalSeq64Ret
                jnz #0043FA80             ;#0043FA74: 165 0A                     v  00 00  1 176      
;   590       ::equalSeq64SeqNxt
;   591         sub rcx,1
                sub rcx,1                 ;#0043FA76: 48:203351 01               uv 02 02  1 177      
;   592         jnz @b
                jnz #0043FA4B             ;#0043FA7A: 165 CF                     v  00 00  1 177      
;   593         nop
                nop                       ;#0043FA7C: 220                        uv 00 00  1 178      
;   594         ret
                ret                       ;#0043FA7D: 303                        np 00 00  2 179      
;   595 
;   596       ::equalSeq64Ret0
;   597         --DEV esi and edi are non-zero here, try test esi,esi
;   598 --      xor eax,eax
;   599 --      add eax,1       -- ensure Z=0
;   600         test esi,esi    -- ensure Z=0
                test rsi,esi              ;#0043FA7E: 205366                     uv 00 40  1 181      
;   601       ::equalSeq64Ret
;   602         ret
                ret                       ;#0043FA80: 303                        np 00 00  2 182      
;   603     []
;   604 
;   605 --/*    (temp, see pFind.e/pMatch.e for now...)
;   606 --new 29/6/10:
;   607 --calling convention:                               octal:         binary:          code:
;   608 --  mov ecx,p1      -- result location              271         B9 imm32        mov ecx,imm32
;   609 --  mov esi,imm32   -- start from (known/1)         276         BE imm32        mov esi,imm32
;   610 --> or
;   611 --  mov esi,[p4]    -- start from (var)             213 065     8B 35 m32       mov esi,[m32]
;   612 --  mov eax,[p2]    -- ref of p2                    241         A1 m32          mov eax,[m32]
;   613 --  mov edi,[p3]    -- ref of p3                    213 075     8B 3D m32       mov edi,[m32]
;   614 --  mov ebx,p3      -- var no of p3
;   615 --  mov edx,p2      -- var no of p2
;   616 --  call :%opFind   -- [ecx] = find(eax,edi)        350         E8 rel32        call rel32
;   617 --      (if p4 is unassigned just get "invalid find start index")
;   618 
;   619  :%opFind
;   620 --  mov edi,[edx]           -- ref of p3
;   621 --  mov eax,[esi]           -- ref of p2
;   622     cmp edi,h4
;   623     jle :opFindErr          -- p3(ebx) unassigned or e112saofmbs
;   624     shl edi,2
;   625     push ecx                --[1] push target addr
;   626 --stack:
;   627 ?!  mov [p2vno],edx
;   628     test byte[edi-1],0x80
;   629     jz :opFindErrPop1e112   -- second argument of find() must be a sequence
;   630     xor ebx,ebx
;   631     mov edx,[edi-12]        -- length
;   632 sub esi,1
;   633 jz :opFind1
;   634 cmp esi,edx                 -- if start_from is -ve/float/oob then longhand
;   635 --jb @f
;   636 jbe @f
;   637     add esi,1
;   638     jl :opFindfixupNegativeStart
;   639     -- but it might be a float:
;   640     cmp esi,h4
;   641     jle :e21ifsi                -- 0 or >length+1
;   642     cmp byte[ebx+esi*4-1],0x12
;   643     jne :e21ifsi                -- invalid find start index
;   644     fld qword[ebx+esi*4]
;   645 --see pSubse.e(?)
;   646     fldcw [down53]
;   647 --stack
;   648     fistp qword[FltWrk]
;   649     fldcw [near53]
;   650     mov esi,[FltWrk]
;   651     cmp esi,0
;   652     jge :opFindfixupStartNotNegative
;   653   ::opFindfixupNegativeStart
;   654         add esi,edx
;   655 ----DEV try add esi,1
;   656         jmp :opFindNegDone
;   657 --      xor ebx,ebx
;   658 --      cmp esi,edx
;   659 --?     ja :e10sspeosediedxN    -- slice starts past end of sequence (%d > %d)
;   660 --      ret
;   661   ::opFindfixupStartNotNegative
;   662     sub esi,1
;   663   ::opFindNegDone
;   664     xor ebx,ebx
;   665     cmp esi,edx
;   666     ja :e21ifsi                 -- invalid find start index
;   667 --ret
;   668 --=====
;   669 
;   670 --      pop eax
;   671   @@:
;   672     jz :opFindNotFound
;   673 
;   674   ::opFind1
;   675     cmp eax,h4
;   676     jge :opFindRef
;   677     cmp byte[edi-1],0x82
;   678     mov ecx,edx
;   679     je :opFindStrChr
;   680     --
;   681     -- good, looking for short int, in a sequence (not string).
;   682     --
;   683 --  repne scasd         -- cmp eax,[edi], edi+=4
;   684 --  jnz :opFindNotFound
;   685     test edx,edx
;   686     jz :opFindNotFound
;   687 sub ecx,esi
;   688 lea edi,[edi+esi*4]
;   689   @@:
;   690     mov esi,[edi]
;   691     lea edi,[edi+4]
;   692     cmp eax,esi
;   693     je :FindIntFound
;   694     dec ecx
;   695     jnz @b
;   696     xor edx,edx
;   697     jmp @f
;   698 
;   699   ::FindIntFound
;   700     dec ecx
;   701 
;   702     sub edx,ecx
;   703 @@:
;   704     pop edi             -- target addr
;   705     mov ecx,edx
;   706   ::FindResult
;   707     mov edx,[edi]
;   708     mov [edi],ecx
;   709     cmp edx,h4
;   710     jle @f
;   711 ----DEV temp: (removed 14/10/09)
;   712 --1/1/2013 makes no sense...
;   713 --opFindE92: ---- exception here mapped to e30espfeh
;   714         sub dword[ebx+edx*4-8],1
;   715         jz :%pDealloc
;   716   @@:
;   717     ret
;   718 
;   719   ::opFindStrChr
;   720 sub ecx,esi
;   721 lea edi,[edi+esi]
;   722     --
;   723     -- searching a string (p3)
;   724     --
;   725     test eax,0xFFFFFF00
;   726     jne :opFindNotFound         -- must be 8-bit char (and not float/str/seq)
;   727     repne scasb
;   728     jnz :opFindNotFound
;   729     sub edx,ecx
;   730     pop edi                     -- target addr
;   731     mov ecx,edx
;   732     jmp :FindResult
;   733 
;   734   ::opFindFltNotFound
;   735 --DEV fstp st0
;   736 --  fistp [FltWrk]              -- discard st0
;   737     fstp st0                    -- discard st0
;   738 
;   739   ::opFindNotFound
;   740     xor ecx,ecx
;   741     pop edi                     -- target addr
;   742     jmp :FindResult
;   743 
;   744   ::opFindRef
;   745 --  jz :opFinde92espm4m15       -- p2=eax=[[esp]-15]=h4
;   746     jz :opFinde94espm4p2vno     -- era @ [esp+4], p2=[pvnvo]=h4
;   747     shl eax,2
;   748 --BUG 2/4/08: This assumed p3 is sequence!
;   749     cmp byte[edi-1],0x80
;   750     jne :opFindNotFound         -- you can't find a ref of any kind in a string!
;   751 mov ecx,esi
;   752 shl esi,2
;   753 add esi,edi
;   754     cmp byte[eax-1],0x12
;   755     jne :opFindSeqOrStr
;   756     --
;   757     -- search for a float then
;   758     --
;   759     fld qword[eax]
;   760     fstp qword[FltWrk]  -- store as 64-bit float/pop (2 cycle)
;   761     mov edi,[FltWrk]
;   762 --  fld qword[ebx+eax*4]
;   763 --  xor ecx,ecx
;   764 --xor ebx,ebx
;   765   @@:
;   766     add ecx,1
;   767     cmp ecx,edx
;   768     jg :opFindFltNotFound
;   769     lodsd   -- mov eax,[esi]-- esi+=4
;   770     cmp eax,h4
;   771     jl @b
;   772     cmp byte[ebx+eax*4-1],0x12
;   773     jne @b
;   774 -- direct binary compare allows scan for nan
;   775     cmp edi,[ebx+eax*4]     -- first dword of FltWrk already in edi (for speed ---)
;   776     jne @b
;   777 --stack:
;   778     mov edi,[FltWrk+4]
;   779     cmp edi,[ebx+eax*4+4]
;   780     mov edi,[FltWrk]
;   781     jne @b
;   782 --  fld qword[ebx+eax*4]
;   783 --  fcomp
;   784 --  fnstsw ax
;   785 --mov dh,ah
;   786 --  and ah,0x7f     -- clear sign
;   787 --and dh,0x04   -- keep parity only
;   788 --  shl ch,7
;   789 --shl dh,4      -- parity to Z position
;   790 --  or ah,ch
;   791 --sub ah,dh
;   792 --  sahf
;   793 --  jne @b
;   794     pop edi                     -- target addr
;   795 --DEV fstp st0
;   796 --  fistp [FltWrk]              -- discard st0
;   797     fstp st0                    -- discard st0
;   798     jmp :FindResult
;   799 
;   800   ::opFindSeqOrStr
;   801     mov edi,[eax-12]            -- length
;   802 --DEV move ecx,[eax-20] push ecx
;   803     push eax                    -- [1] save start of string p2 on stack
;   804     push edi                    -- [2] save length "" on stack
;   805 --  xor ecx,ecx
;   806     cmp byte[eax-1],0x82
;   807     jne :opFindSeq
;   808     --
;   809     -- searching for a string then...
;   810     --
;   811 --xor ebx,ebx
;   812   @@:
;   813     add ecx,1
;   814     cmp ecx,edx
;   815     jg :opFindStrNotFound
;   816     lodsd       -- mov eax,[esi], esi+=4
;   817     cmp eax,h4                  -- skip short ints
;   818     jl @b
;   819     cmp byte[ebx+eax*4-1],0x82
;   820     jne :opFindStrNotString
;   821     --
;   822     -- good, p2 is string, p3[i] is string
;   823     --
;   824     cmp edi,[ebx+eax*4-12]      -- compare lengths
;   825     jne @b
;   826     push esi                    --[3] save subscript element position on stack
;   827     push ecx                    --[4] and index
;   828     lea esi,[eax*4]
;   829     mov ecx,edi
;   830 --DEV save the base then!
;   831     mov edi,[esp+12]            -- [1] start of string being searched for
;   832     repe cmpsb
;   833     jz :opStringFound
;   834     pop ecx                     --[4]
;   835     pop esi                     --[3]
;   836     mov edi,[esp]               -- [2]
;   837     jmp @b
;   838 
;   839   ::opStringFound
;   840     pop ecx                     --[4]
;   841     add esp,12                  --[3..1]
;   842     pop edi                     -- target addr
;   843     jmp :FindResult
;   844   ::opFindStrNotFound
;   845     add esp,8                   --[2..1]
;   846     jmp :opFindNotFound
;   847 
;   848   ::opFindStrNotString
;   849     cmp byte[ebx+eax*4-1],0x80  -- skip any floats
;   850     jne @b
;   851     cmp edi,[ebx+eax*4-12]      -- compare lengths
;   852     jne @b
;   853     --
;   854     -- p2 is string, p3[i] is sequence, with same lengths.
;   855     -- compare each char with p3 elements as shortints.
;   856     --
;   857     push esi                    -- [3]save subscript element position on stack
;   858     push ecx                    -- [4]and index
;   859 --DEV save the base then!
;   860     mov esi,[esp+12]            --[1] start of string being searched for
;   861     mov ecx,edi
;   862     lea edi,[ebx+eax*4]         -- start of p3[i]
;   863     xor eax,eax
;   864   ::opFindStrVsSeqCharLoop
;   865     sub ecx,1
;   866     jl :opStringFound
;   867     lodsb       -- mov al,[esi], esi+=1
;   868     cmp eax,[edi]
;   869     lea edi,[edi+4]
;   870     je :opFindStrVsSeqCharLoop
;   871     pop ecx                     --[4]
;   872     pop esi                     --[3]
;   873     mov edi,[esp]               -- [2]
;   874     jmp @b
;   875 
;   876   ::opFindSeq
;   877     --
;   878     -- searching for a sequence then...
;   879     --
;   880     -- Scan through the toplevel, ignoring integers and floats, and
;   881     -- sequences/strings of the wrong length. If we find a string,
;   882     -- then compare char-for-short-int here, with the catch that if
;   883     -- we stumble on a non-char in p2, jump to below where we also
;   884     -- skip any further strings in p3. For sequence p3[i], compare
;   885     -- shortints here and pass off any (both) non-ints to the
;   886     -- recursive equalSeq function.
;   887     --
;   888 --  cmp byte[eax-1],0x80            -- should always be sequence here
;   889 --  jne ???                         -- (just did >h4, not 0x12 and not 0x82)
;   890 -- Next four instructions already done:
;   891 --  mov edi,[eax-12]            -- length
;   892 --  push eax                        -- [1]save start of p2 (a sequence) on stack
;   893 --  push edi                        -- [2]save length of p2 on stack
;   894 --  xor ecx,ecx
;   895   @@:
;   896     add ecx,1
;   897     cmp ecx,edx
;   898     jg :opFindStrNotFound
;   899     lodsd                           -- next element of p3 (mov eax,[esi], esi+=4)
;   900     cmp eax,h4                      -- skip shortints
;   901     jl @b
;   902 -- opFindodbfu7:
;   903     cmp byte[ebx+eax*4-1],0x82
;   904 -- opFindodbfu7a:
;   905     jne :opFindSeqNotString
;   906     -- so eax(=p3[ecx]) is a string:
;   907     cmp edi,[ebx+eax*4-12]          -- compare lengths
;   908     jne @b
;   909     --
;   910     -- <this sentence repeated from above:>
;   911     -- compare each char of (string) p3[i] with (sequence) p2[i] as shortint,
;   912     -- with the catch that if p2[i] is non-char, resume in lower loop which 
;   913     -- also skips any further strings in p3.
;   914     --
;   915     push esi                        -- [3]save subscript element position on stack
;   916     push ecx                        -- [4]and index
;   917     lea esi,[ebx+eax*4]             -- start of string p3[i]
;   918     mov ecx,edi
;   919     mov edi,[esp+12]                -- start of sequence being searched for
;   920     xor eax,eax
;   921   ::opFindSeqVsStrCharLoop
;   922     sub ecx,1
;   923     jl :opStringFound
;   924     lodsb                           -- mov al,[esi], esi+=1
;   925     cmp eax,[edi]
;   926     lea edi,[edi+4]
;   927     je :opFindSeqVsStrCharLoop
;   928     mov eax,[edi-4]
;   929     pop ecx                         --[4]
;   930     pop esi                         --[3]
;   931     test eax,0xFFFFFF00
;   932     jne :opFindSeqSkipFurtherStrings
;   933     mov edi,[esp]
;   934     jmp @b
;   935 
;   936   ::opFindSeqNotString
;   937     cmp byte[ebx+eax*4-1],0x80      -- skip floats
;   938     jne @b
;   939     -- so eax(=p3[ecx]) is a sequence, and so is p2:
;   940     cmp edi,[ebx+eax*4-12]          -- compare lengths
;   941     jne @b
;   942     --
;   943     -- <this sentence repeated from above:>
;   944     -- compare sequence(p2) with sequence(p3[i]) then...
;   945     -- handle shortints here, pass off any (both) non-ints to
;   946     -- the recursive equalSeq function
;   947     --
;   948     push esi                        -- [3]save subscript element position on stack
;   949     push ecx                        -- [4]and index
;   950     lea esi,[ebx+eax*4]             -- start of sequence p3[i]
;   951     mov ecx,edi
;   952 --DEV save the base then!
;   953     mov edi,[esp+12]                -- [1] start of sequence being searched for
;   954   ::opFindSeqVsSeqLoop
;   955     sub ecx,1
;   956     jl :opStringFound
;   957     lodsd       -- mov eax,[esi], esi+=4
;   958     cmp eax,[edi]
;   959     lea edi,[edi+4]
;   960     je :opFindSeqVsSeqLoop
;   961     cmp eax,h4
;   962     jl :opFSSmismatch
;   963     cmp dword[edi-4],h4
;   964     jl :opFSSmismatch
;   965 pushad
;   966     call :equalSeq          -- compare ref eax with ref at [edi-4], recursively
;   967 popad                       -- result is Z flag
;   968     je :opFindSeqVsSeqLoop
;   969   ::opFSSmismatch
;   970     pop ecx                 --[4]
;   971     pop esi                 --[3]
;   972     mov edi,[esp]
;   973     jmp @b
;   974 
;   975 
;   976   ::opFindSeqSkipFurtherStrings
;   977     mov edi,[esp]
;   978   @@:
;   979     add ecx,1
;   980     cmp ecx,edx
;   981     jg :opFindStrNotFound
;   982     lodsd                   -- next element of p3 (mov eax,[esi], esi+=4)
;   983     cmp eax,h4
;   984     jl @b
;   985     cmp byte[ebx+eax*4-1],0x80
;   986     jne @b
;   987     cmp edi,[ebx+eax*4-12]
;   988     jne @b
;   989     --
;   990     -- compare sequence(p2) with sequence(p3[i]) then...
;   991     -- handle shortints here, pass off any (both) non-ints to
;   992     -- the recursive equalSeq function
;   993     --
;   994     push esi                        -- [3]save subscript element position on stack
;   995     push ecx                        -- [4]and index
;   996     lea esi,[ebx+eax*4]             -- start of sequence p3[i]
;   997     mov ecx,edi
;   998 --DEV save the base then!
;   999     mov edi,[esp+12]                -- [1] start of sequence being searched for
;  1000   ::opFindSeqVsSeqLoop2
;  1001     dec ecx
;  1002     jl :opStringFound
;  1003     lodsd       -- mov eax,[esi], esi+=4
;  1004     cmp eax,[edi]
;  1005     lea edi,[edi+4]
;  1006     je :opFindSeqVsSeqLoop2
;  1007     cmp eax,h4
;  1008     jl :opFSSmismatch2
;  1009     cmp dword[edi-4],h4
;  1010     jl :opFSSmismatch2
;  1011 pushad
;  1012     call :equalSeq          -- compare ref eax with ref at [edi-4], recursively
;  1013 popad                       -- result is Z flag
;  1014     je :opFindSeqVsSeqLoop2
;  1015   ::opFSSmismatch2
;  1016     pop ecx                 --[4]
;  1017     pop esi                 --[3]
;  1018     mov edi,[esp]
;  1019     jmp @b
;  1020 
;  1021 ::FindMap
;  1022 --  jz opMatchErre92esi
;  1023 --  jz opMatche92espm15
;  1024     jz :opMatche92edx
;  1025 --  cmp edi,h4
;  1026 --  jle opMatchErr          -- unassignededx or e113saommbs
;  1027 --DEV temp, until calling convention of opMatch updated to be same as opFind:
;  1028 --(error handling will be wrong till then)
;  1029 --mov esi,1
;  1030     cmp byte[ebx+edi*4-1],0x80
;  1031     jae :opFind
;  1032 --  mov ebx,[p2vno] -- not needed!
;  1033     jmp :opMatchErr         -- e113saommbs
;  1034 
;  1035  :%opMatch
;  1036 --calling convention: (== opFind)                   octal:         binary:          code:
;  1037 --  mov edx,p3                                      272         BA imm32        mov edx,imm32
;  1038 --  mov esi,p2                                      276         BE imm32        mov esi,imm32
;  1039 --  mov ecx,p1                                      271         B9 imm32        mov ecx,imm32
;  1040 --  call opMatch    -- p1 = match(p2,p3)            350         E8 rel32        call rel32
;  1041 --new 29/6/10:
;  1042 --calling convention:                               octal:         binary:          code:
;  1043 --  mov ecx,p1      -- result location              271         B9 imm32        mov ecx,imm32
;  1044 --  mov esi,imm32   -- start from (known/1)         276         BE imm32        mov esi,imm32
;  1045 --> or
;  1046 --  mov esi,[p4]    -- start from (var)             213 065     8B 35 m32       mov esi,[m32]
;  1047 --  mov eax,[p2]    -- ref of p2                    241         A1 m32          mov eax,[m32]
;  1048 --  mov edi,[p3]    -- ref of p3                    213 075     8B 3D m32       mov edi,[m32]
;  1049 --  mov ebx,p3      -- var no of p3
;  1050 --  mov edx,p2      -- var no of p2
;  1051 --  call opMatch    -- p1 = match(p2,p3,esi)        350         E8 rel32        call rel32
;  1052 --      (if p4 is unassigned just get "invalid match start index")
;  1053 
;  1054 --  mov edi,[edx]           -- ref of p3
;  1055 --  mov eax,[esi]           -- ref of p2
;  1056     cmp edi,h4
;  1057     jle :opMatchErr         -- p3(ebx) unassigned or e113saommbs
;  1058 --stack:
;  1059     mov [p2vno],ebx
;  1060 --  push ebx                -- p2vno
;  1061     xor ebx,ebx
;  1062     cmp eax,h4
;  1063     jle :FindMap            -- treat integer(p2) as find() [after some more error checks] [deviation from RDS]
;  1064 --  shl eax,2
;  1065     shl edi,2
;  1066     test byte[ebx+eax*4-1],0x80
;  1067     jz :%opFind             -- atom(p2) -> find() [deviation from RDS]
;  1068     shl eax,2
;  1069     push ecx                -- result addr
;  1070 --! mov esi,eax
;  1071     xchg esi,eax            -- swap(NB!):: eax:=start idx-- esi:=raw(p2)
;  1072     mov edx,[edi-12]        -- length(p3)
;  1073     mov ecx,[esi-12]        -- length(p2)
;  1074     test ecx,ecx
;  1075     jz :opMatch0            -- match({},x) gives 0 [deviation from RDS]
;  1076 --DEV to go:
;  1077     cmp ecx,edx             -- check if length(p2) > length(p3)
;  1078     jg :opMatch0            -- match(x,{}) or any """ gives 0
;  1079 
;  1080 sub eax,1
;  1081 jz :opMatch1
;  1082 cmp eax,edx                 -- if start_from is -ve/float/oob then longhand
;  1083 --jb @f
;  1084 jbe @f
;  1085     add eax,1
;  1086     jl :opMatchfixupNegativeStart
;  1087     -- but it might be a float:
;  1088     cmp eax,h4
;  1089     jle :e20imsi                -- 0 or >length+1 or unassigned
;  1090     cmp byte[ebx+eax*4-1],0x12
;  1091     jne :e20imsi                -- invalid match start index
;  1092     fld qword[ebx+eax*4]
;  1093 --see pSubse.e(?)
;  1094     fldcw [down53]
;  1095 --stack:
;  1096     fistp qword[FltWrk]
;  1097     fldcw [near53]
;  1098     mov eax,[FltWrk]
;  1099     cmp eax,0
;  1100     jge :opMatchfixupStartNotNegative
;  1101   ::opMatchfixupNegativeStart
;  1102         add eax,edx
;  1103 ----DEV try add eax,1
;  1104         jmp :opMatchNegDone
;  1105 --      xor ebx,ebx
;  1106 --      cmp eax,edx
;  1107 --?     ja :e10sspeosediedxN    -- slice starts past end of sequence (%d > %d)
;  1108 --      ret
;  1109   ::opMatchfixupStartNotNegative
;  1110     sub eax,1
;  1111   ::opMatchNegDone
;  1112     xor ebx,ebx
;  1113     cmp eax,edx
;  1114     ja :e20imsi                 -- invalid match start index
;  1115 --ret
;  1116 --=====
;  1117 
;  1118 --      pop eax
;  1119   @@:
;  1120     jz :opMatch0
;  1121 
;  1122   ::opMatch1
;  1123 
;  1124 --==========
;  1125     --
;  1126     -- esi = raw(p2)        -- ecx = length(p2)
;  1127     -- edi = raw(p3)        -- edx = length(p3)
;  1128     -- eax = start idx (yet to be applied)
;  1129     --
;  1130     sub ecx,1
;  1131     push esi                -- [esp+12]=raw(p2)
;  1132     push edi                -- [esp+8]=raw(p3), adjusted every loop
;  1133     push ecx                -- [esp+4]=length(p2)-1
;  1134     push edx                -- [esp]=length(p3), [NOT] adjusted every loop
;  1135 
;  1136     cmp byte[esi-1],0x82    -- is p2 a string?
;  1137     jne :opMatchSeqX
;  1138     cmp byte[edi-1],0x82
;  1139     jne :opMatchStrSeq
;  1140 
;  1141     -- match(string,string)
;  1142 add edi,eax     -- adjust for start idx
;  1143 sub edx,eax
;  1144   @@:
;  1145     lodsb                   -- mov al,[esi], esi+=1
;  1146     mov ecx,edx             -- remaining chars in p3 [initially all]
;  1147     repne scasb             -- find first char, from [edi] on
;  1148     jnz :opMatchNotFound
;  1149     mov edx,ecx             -- there will be less chars left to scan in the next loop!
;  1150     mov ecx,[esp+4]         -- length(p2)-1
;  1151     cmp ecx,edx
;  1152     jg :opMatchNotFound
;  1153     or ecx,ecx
;  1154     je :opMatchFound        -- (catch the length(p2)=1 case)
;  1155 
;  1156     mov [esp+8],edi         -- save current position in p3
;  1157     repe cmpsb              -- remainder all here?
;  1158     jz :opMatchFound
;  1159     mov esi,[esp+12]        -- reset to p2[2] (after lodsb above!)
;  1160     mov edi,[esp+8]         -- reset position in p3, as just saved
;  1161     jmp @b
;  1162 
;  1163   ::opMatchNotFound
;  1164     add esp,16
;  1165   ::opMatch0
;  1166     xor ecx,ecx
;  1167     jmp :opMatchResult
;  1168 
;  1169   ::opMatchFound
;  1170     pop ecx    
;  1171     add esp,12
;  1172     sub ecx,edx
;  1173   ::opMatchResult
;  1174     pop edi                 -- target addr
;  1175     mov edx,[edi]
;  1176     mov [edi],ecx
;  1177     cmp edx,h4
;  1178     jle @f
;  1179         sub dword[ebx+edx*4-8],1
;  1180         jz :%pDealloc
;  1181   @@:
;  1182     ret
;  1183 
;  1184   ::opMatchStrSeq
;  1185     -- match(string,sequence)
;  1186     -- leap-frog over any non-char found in p3 (a la Boyer-Moore)
;  1187     -- (not that this is a high-performance case, really)
;  1188 
;  1189 lea edi,[edi+eax*4]     -- adjust for start idx
;  1190 sub edx,eax
;  1191 
;  1192     xor eax,eax
;  1193   @@:
;  1194     lodsb                   -- mov al,[esi], esi+=1
;  1195     mov ecx,edx             -- remaining elements of p3 [initially all]
;  1196   ::opMatchStrSeqFirstCharLoop
;  1197 --   repne scasb                                -- find first char, from [edi] on
;  1198 --   jnz :opMatchNotFound
;  1199 --   dec edx
;  1200 --   jl :opMatchNotFound    -- DEV poss jl?
;  1201     mov edx,[edi]
;  1202     lea edi,[edi+4]
;  1203     cmp eax,edx
;  1204     je :opMatchStrSeqFirstCharFound
;  1205     nop
;  1206     dec ecx
;  1207     jnz :opMatchStrSeqFirstCharLoop
;  1208 
;  1209     nop
;  1210     jmp :opMatchNotFound
;  1211 
;  1212   ::opMatchStrSeqFirstCharFound
;  1213 --DEV: lea edx,[ecx-1]
;  1214     dec ecx
;  1215 --stack:
;  1216     mov [MatchEdxSave],ecx  -- there will be less elements left to scan in the next loop!
;  1217 mov edx,ecx
;  1218     mov ecx,[esp+4]         -- length(p2)-1
;  1219 cmp ecx,edx
;  1220 jg :opMatchNotFound
;  1221 or ecx,ecx
;  1222 je :opMatchFound
;  1223     mov [esp+8],edi         -- save current position in p3
;  1224   ::opMatchStrSeqRemainingCharsLoop
;  1225     lodsb                   -- mov al,[esi], esi+=1
;  1226 --DEV cmpsd? (change rqd in opMatchStrSeqMismatch, probably)
;  1227     mov edx,[edi]
;  1228     cmp eax,edx
;  1229     jne :opMatchStrSeqMismatch
;  1230     lea edi,[edi+4]
;  1231     dec ecx
;  1232     jnz :opMatchStrSeqRemainingCharsLoop
;  1233 --stack:
;  1234     mov edx,[MatchEdxSave]
;  1235     jmp :opMatchFound
;  1236 
;  1237   ::opMatchStrSeqMismatch
;  1238     mov esi,[esp+12]                -- reset to p2[2] (after lodsb above!)
;  1239     test edx,0xFFFFFF00
;  1240     jnz :opMatchStrSeqNotChar
;  1241     mov edi,[esp+8]                 -- reset position in p3, as just saved
;  1242 --stack:
;  1243     mov edx,[MatchEdxSave]
;  1244     jmp @b
;  1245 
;  1246   ::opMatchStrSeqNotChar
;  1247     --
;  1248     -- not a char: leave edi as is then!
;  1249     -- (but must adjust edx to match)
;  1250     --
;  1251     mov edx,[esp+8]         -- saved position in p3
;  1252     sub edx,edi             -- less where we got to (so edx now -ve)
;  1253     sar edx,2               -- at 4 bytes per element
;  1254 --stack:
;  1255     add edx,[MatchEdxSave]  -- is adjust to (saved) edx
;  1256     jmp @b
;  1257 
;  1258   ::opMatchSeqX
;  1259     cmp byte[edi-1],0x82
;  1260     jne :opMatchSeqSeq
;  1261     -- match(sequence,string)
;  1262     -- give up the moment any non-char found in p2.
;  1263 
;  1264 add edi,eax     -- adjust for start idx
;  1265 sub edx,eax
;  1266 
;  1267   @@:
;  1268     lodsd       -- mov eax,[esi], esi+=4
;  1269     test eax,0xFFFFFF00
;  1270     jnz :opMatchNotFound
;  1271 
;  1272     mov ecx,edx                 -- remaining chars of p3 [initially all]
;  1273     repne scasb                 -- find first char, from [edi] on
;  1274     jnz :opMatchNotFound
;  1275 --stack:
;  1276     mov [MatchEdxSave],ecx      -- there will be less elements left to scan in the next loop!
;  1277 mov edx,ecx
;  1278     mov ecx,[esp+4]             -- length(p2)-1
;  1279 cmp ecx,edx
;  1280 jg :opMatchNotFound
;  1281 or ecx,ecx
;  1282 je :opMatchFound
;  1283     mov [esp+8],edi             -- save current position in p3
;  1284   ::opMatchSeqStrRemainingCharsLoop
;  1285     lodsd       -- mov eax,[esi], esi+=4
;  1286     test eax,0xFFFFFF00
;  1287     jnz :opMatchNotFound
;  1288 --DEV cmpsb? (change rqd below, probably)
;  1289     cmp al,[edi]
;  1290     jne :opMatchSeqStrMismatch
;  1291     add edi,1
;  1292     sub ecx,1
;  1293     jnz :opMatchSeqStrRemainingCharsLoop
;  1294 
;  1295 --stack:
;  1296     mov edx,[MatchEdxSave]
;  1297     jmp :opMatchFound
;  1298 
;  1299   ::opMatchSeqStrMismatch
;  1300     mov esi,[esp+12]            -- reset to p2[2] (with line+1!)
;  1301     mov edi,[esp+8]             -- reset position in p3, as just saved
;  1302 --   lea esi,[esi+4]
;  1303 --stack:
;  1304     mov edx,[MatchEdxSave]
;  1305     jmp @b
;  1306 
;  1307   ::opMatchSeqSeq
;  1308     cmp byte[edi-1],0x80
;  1309     jne :opMatchErrPop4e113
;  1310     --
;  1311 --push esi                      -- [esp+12]=raw(p2)
;  1312 --push edi                      -- [esp+8]=raw(p3), adjusted every loop
;  1313 --push ecx                      -- [esp+4]=length(p2)-1
;  1314 --push edx                      -- [esp]=length(p3), [NOT] adjusted every loop
;  1315 --
;  1316     -- match(sequence,sequence)
;  1317 
;  1318     mov edx,1                   -- default result
;  1319 
;  1320 lea edi,[edi+eax*4]     -- adjust for start idx
;  1321 add edx,eax
;  1322 
;  1323   @@:                           -- Main Loop (resume scan for all of P2 from P3[edx])
;  1324 --      if res+ls1-1>ls2 then return 0 end if
;  1325     lea eax,[edx+ecx]
;  1326     cmp eax,[esp]               -- length(p3)
;  1327     jg :opMatchNotFound
;  1328 
;  1329     add ecx,1       -- on entry ecx (and [esp+4]) is length(p2)-1
;  1330   ::opMatchSeqSeqNextElement    -- Sub-loop (continue checking p2[i] vs p3[edx+i-1])
;  1331     repe cmpsd
;  1332     jz :opMatchSeqSeqFound
;  1333     --
;  1334     -- if p2[i] is a short int, scan for it in remainder of p3
;  1335     --  eg p2=23431...,
;  1336     --    p3=2343x31...
;  1337     --  from p3[6] on, scanning fwd finds p3[7]=1, which gives
;  1338     --  the earliest point worth re-starting from (ie +=2).
;  1339     --  eg p2=  23431...,
;  1340     --    p3=2343x31...
;  1341     -- (The whole point here is to minimise the number of attempts
;  1342     --  to deep-compare non-integers, btw, and in the example given
;  1343     --  the next loop will re-enter here looking for 2(=p2[1]) and
;  1344     --  not really save anything. However if p2[1..4] and p3[1..6]
;  1345     --  were some big nested sequences, especially when of similar 
;  1346     --  lengths,the saving could be quite dramatic.)
;  1347     --
;  1348     --  if p2i does not occur anywhere later in p3, then
;  1349     --  clearly there will be no match anywhere.
;  1350     --
;  1351     mov eax,[esi-4]
;  1352     cmp eax,h4
;  1353     jg ::opMatchSeqSeqNotInt
;  1354 
;  1355     --
;  1356     -- first, calculate number of remaining elements in p3:
;  1357     --
;  1358     sub ecx,[esp+4] -- -(length(p2)-1)  ~ -1*(elements scanned just now)
;  1359     add ecx,[esp]   -- +length(p3)
;  1360     sub ecx,edx     -- -res
;  1361 
;  1362     --
;  1363     -- now do a scan, updating res by no of items skipped, (ie +ecx--scan---ecx)
;  1364     --
;  1365     add edx,ecx
;  1366     repne scasd
;  1367     jnz :opMatchNotFound 
;  1368     sub edx,ecx
;  1369 
;  1370     --
;  1371     -- ...and resume scan from p3[edx]:
;  1372     --
;  1373     mov edi,[esp+8]             -- start of p3
;  1374     mov esi,[esp+12]            -- reset to p2
;  1375     mov ecx,[esp+4]
;  1376     lea edi,[edi+edx*4-4]       -- resume scan from p3[edx]
;  1377     jmp @b
;  1378 
;  1379 
;  1380   ::opMatchSeqSeqNotInt
;  1381     --
;  1382     -- if p3[i] is a short int, scan for it earlier in p2
;  1383     --
;  1384 --                  -- scan for s2i earlier on in s1
;  1385 --                  -- eg s1=131313x...,
;  1386 --                  --    s2=1313131...
;  1387 --                  -- with s2[7]=1, scanning back two places to s1[5]=1
;  1388 --                  -- gives the earliest point worth re-starting from.
;  1389 --                  -- if s2[7] does not occur anywhere earlier in s1,
;  1390 --                  -- then clearly we should restart from s2[8].
;  1391 --
;  1392 --      mov eax,[edi-4]     -- NO! equalSeq wants ref (from [esi-4]) in eax
;  1393 --      cmp eax,h4
;  1394     cmp dword[edi-4],h4
;  1395     jg :opMatchSeqSeqRefRef
;  1396     neg ecx                 -- negate how-far-we-got,
;  1397     mov eax,[edi-4]
;  1398     add ecx,[esp+4]         -- +length(p2)-1
;  1399     lea edi,[esi-8]         -- start backwards scan from element before mismatch
;  1400     add ecx,1
;  1401     --
;  1402     -- scan, adjusting edx(res).
;  1403     --
;  1404     add edx,ecx
;  1405     std
;  1406     repne scasd
;  1407     cld
;  1408     --
;  1409     -- If we fall off the start of p2, edx adjust is maximal, 
;  1410     -- and the main loop resumes starting after the mismatch.
;  1411     -- Hence no check on result of repne scasd, info we need
;  1412     -- is in [change to] ecx only.
;  1413     --
;  1414     sub edx,ecx
;  1415     --
;  1416     -- ...and resume scan from p3[edx]:
;  1417     --
;  1418 --DEV same as 37 lines earlier:
;  1419     mov edi,[esp+8]             -- start of p3
;  1420     mov esi,[esp+12]            -- reset to p2
;  1421     lea edi,[edi+edx*4-4]       -- resume scan from p3[edx]
;  1422     mov ecx,[esp+4]
;  1423     jmp @b
;  1424 
;  1425   ::opMatchSeqSeqRefRef
;  1426 pushad
;  1427     call :equalSeq
;  1428 popad
;  1429      jz :opMatchSeqSeqNextElement
;  1430 ----DEV this may be superfluous: vvvvvvvvvvvvvv
;  1431 --      jnz :opMatchSeqSeqMismatch
;  1432 --      or ecx,ecx
;  1433 --      jnz :opMatchSeqSeqNextElement 
;  1434 --      nop
;  1435 --      jmp :opMatchSeqSeqFound
;  1436 ----DEV to here ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
;  1437 --   cmpsd        -- esi+=4-- edi+=4
;  1438 --   jmp @b
;  1439 --
;  1440   ::opMatchSeqSeqMismatch
;  1441     mov edi,[esp+8]             -- start of p3
;  1442     mov esi,[esp+12]            -- reset to p2
;  1443     lea edi,[edi+edx*4]         -- resume scan from p3[edx] (NB: no -4 here!)
;  1444     mov ecx,[esp+4]             -- length(p2)-1
;  1445     add edx,1                   -- res+=1
;  1446     jmp @b
;  1447 
;  1448   ::opMatchSeqSeqFound
;  1449     add esp,16
;  1450     mov ecx,edx
;  1451     jmp :opMatchResult
;  1452 --*/
;  1453 
;  1454 --/*
;  1455 procedure :%opJcc(:%)
;  1456 end procedure -- (for Edita/CtrlQ)
;  1457 --*/
;  1458  :%opJcc            -- for opJlt, opJle, opJge, opJgt
;  1459 --------            -- result is condition flags
;  1460                     -- Damages eax,ecx,edx,esi,edi
;  1461     [32]
;  1462         --calling convention:
;  1463         --  mov edi,[p3]        -- ref of p3
;  1464         --  mov eax,[p2]        -- ref of p2
;  1465         --  mov esi,p3          -- var no of p3
;  1466         --  mov edx,p2          -- var no of p2
;  1467         --  call opJcc
;  1468         --  jcc xxx
;  1469 
;  1470 --      xor ebx,ebx
;  1471         cmp eax,h4
;  1472         jge :!Jccp2NotInt
;  1473         cmp edi,h4
;  1474         jge :!Jccp2Intp3Ref
;  1475         cmp eax,edi
;  1476         ret
;  1477 
;  1478       :!Jccp2NotInt
;  1479 --je e94vhnbaavedx
;  1480         mov cl,[ebx+eax*4-1]
;  1481         cmp edi,h4
;  1482         jge :Jccp2Refp3Ref
;  1483         -- p3 is an int
;  1484         cmp cl,0x12
;  1485         jne @f
;  1486         -- p2(eax) flt, p3(edi) int:
;  1487 --use stack:
;  1488 --  mov [FltWrk],edi
;  1489 --  fild [FltWrk]
;  1490         push edi
;  1491         fild dword[esp]
;  1492         add esp,4
;  1493         fld qword[ebx+eax*4]
;  1494         fcompp
;  1495         fnstsw ax
;  1496         mov ch,ah
;  1497 --mov dh,ah
;  1498         and ah,0x7f     -- clear sign
;  1499 --and dh,0x04   -- keep parity only
;  1500         shl ch,7
;  1501 --shl dh,4      -- parity to Z position
;  1502         or ah,ch
;  1503 --sub ah,dh     -- clear Z if parity set
;  1504         sahf
;  1505         ret
;  1506       @@:
;  1507         cmp eax,edi     -- all sequences (eax>h4) deemed greater than int (edx<h4)
;  1508         ret
;  1509 
;  1510       ::Jccp2Refp3Ref
;  1511 --      jne equalSeqR
;  1512         jne :compareSeqR -- (fall thru if edi/p3 unassigned, aka goto compareSeqR unless p3 unassigned)
;  1513 --DEV put this back: (or is letting it fall through ok?)
;  1514 --  jmp e92vhnbaavespm14    --DEV do it inline!
;  1515 --  jmp e94vhnbaavesi
;  1516 --  mov edi,edx
;  1517 --mov edi,[esp]
;  1518 --mov edi,[edi-14]
;  1519 --  lea edi,[edi+4]     -- equalSeq calling convention
;  1520 --  jmp equalSeq
;  1521 
;  1522 --  Jccp2Intp3Ref:  -- exception here mapped to e92vhnbaavespm14feh
;  1523       :!Jccp2Intp3Ref
;  1524 --  je :e94vhnbaavesi
;  1525         cmp byte[ebx+edi*4-1],0x12
;  1526         jne @b          -- all ints (eax<h4) deemed less than sequences (edi>h4)
;  1527         -- p2(eax) int, p3(edi) flt:
;  1528 --  mov [FltWrk],eax
;  1529         push eax
;  1530         fld qword[ebx+edi*4]
;  1531 --  fild [FltWrk]
;  1532         fild dword[esp]
;  1533         add esp,4
;  1534         fcompp
;  1535         fnstsw ax
;  1536         mov ch,ah
;  1537 --  and ah,0x7f
;  1538 --  shl ch,7
;  1539 --  or ah,ch
;  1540 --mov dh,ah
;  1541         and ah,0x7f     -- clear sign
;  1542 --and dh,0x04   -- keep parity only
;  1543         shl ch,7
;  1544 --shl dh,4      -- parity to Z position
;  1545         or ah,ch
;  1546 --sub ah,dh     -- Clear Z if Parity set
;  1547         sahf
;  1548         ret
;  1549 
;  1550     [64]
;  1551         --calling convention:
;  1552         --  mov rdi,[p3]        -- ref of p3        (opUnassigned*2?)
;  1553         --  mov rax,[p2]        -- ref of p2
;  1554 --      --  mov rsi,p3          -- var no of p3
;  1555 --      --  mov rdx,p2          -- var no of p2
;  1556         --  call opJcc
;  1557         --  jcc xxx
;  1558 
;  1559 --      xor rbx,rbx
;  1560         mov r15,h4
                mov r15,h4                ;#0043FA81: 49:277 0000000000000040    uv 8000 00  1 184      
;  1561 --      cmp rax,h4
;  1562         cmp rax,r15
                cmp rax,r15               ;#0043FA8B: 49:073307                  uv 00 8001  1 185 8000   
;  1563         jge :!Jccp2NotInt
                jge #0043FAA1 (:!Jccp2NotInt)  ;#0043FA8E: 017215 0D000000            v  00 00  1 185      
;  1564 --      cmp rdi,h4
;  1565         cmp rdi,r15
                cmp rdi,r15               ;#0043FA94: 49:073377                  uv 00 8080  1 186      
;  1566         jge :!Jccp2Intp3Ref
                jge #0043FAD3 (:!Jccp2Intp3Ref)  ;#0043FA97: 017215 36000000            v  00 00  1 186      
;  1567         cmp rax,rdi
                cmp rax,rdi               ;#0043FA9D: 48:071370                  uv 00 81  1 187      
;  1568         ret
                ret                       ;#0043FAA0: 303                        np 00 00  2 188      
;  1569 
;  1570       :!Jccp2NotInt
;  1571 --je e94vhnbaavedx
;  1572         mov cl,[rbx+rax*4-1]
                mov cl,[rbx+rax*4-1]      ;#0043FAA1: 212114203 FF               uv 02 09  1 190      
;  1573 --      cmp rdi,h4
;  1574         cmp rdi,r15
                cmp rdi,r15               ;#0043FAA5: 49:073377                  vu 00 8080  1 190      
;  1575 --      jge :Jccp2Refp3Ref
;  1576         jge :compareSeq64R
                jge #0043F899             ;#0043FAA8: 017215 EBFDFFFF            v  00 00  1 191      
;  1577         -- p3 is an int
;  1578         cmp cl,0x12
                cmp cl,#12                ;#0043FAAE: 200371 12                  uv 00 02  1 192      
;  1579 --      cmp byte[rbx+rax*4-1],0x12
;  1580         jne @f
                jne #0043FACF             ;#0043FAB1: 165 1C                     v  00 00  1 192      
;  1581         -- p2(rax) flt, p3(rdi) int:
;  1582 --use stack:
;  1583 --  mov [FltWrk],edi
;  1584 --  fild [FltWrk]
;  1585         push rdi
                push rdi                  ;#0043FAB3: 48:127                     uv 00 80  1 193      
;  1586         fild qword[esp]
                fild qword[rsp]           ;#0043FAB5: 337054044                  np 00 10  3 194      
;  1587         add rsp,8
                add rsp,8                 ;#0043FAB8: 48:203304 08               uv 10 10  1 197      
;  1588         fld tbyte[rbx+rax*4]
                fld tbyte[rbx+rax*4]      ;#0043FABC: 333054203                  np 00 09  3 198      
;  1589         fcompp
                fcompp                    ;#0043FABF: 336331                     np 00 00  1 201      
;  1590         fnstsw ax
                fnstsw ax                 ;#0043FAC1: 337340                     np 01 00  6 202      
;  1591         mov ch,ah
                mov ch,ah                 ;#0043FAC3: 212354                     uv 02 01  1 208      
;  1592         and ah,0x7f     -- clear sign
                and ah,127                ;#0043FAC5: 200344 7F                  vu 01 01  1 208      
;  1593         shl ch,7
                shl ch,7                  ;#0043FAC8: 300345 07                  u  02 02  1 209      
;  1594         or ah,ch
                or ah,ch                  ;#0043FACB: 010354                     uv 01 03  1 210 02   
;  1595         sahf
                sahf                      ;#0043FACD: 236                        np 00 01  2 211      
;  1596         ret
                ret                       ;#0043FACE: 303                        np 00 00  2 213      
;  1597 
;  1598       @@:
;  1599         cmp rax,rdi     -- all sequences (rax>h4) deemed greater than int (rdx<h4)
                cmp rax,rdi               ;#0043FACF: 48:071370                  uv 00 81  1 215      
;  1600         ret
                ret                       ;#0043FAD2: 303                        np 00 00  2 216      
;  1601 
;  1602 --    ::Jccp2Refp3Ref
;  1603 --      jne :compareSeq64R -- (fall thru if rdi/p3 unassigned, aka goto compareSeqR unless p3 unassigned)
;  1604       :!Jccp2Intp3Ref
;  1605 --      je :e94vhnbaavesi
;  1606         cmp byte[rbx+rdi*4-1],0x12
                cmp byte[rbx+rdi*4-1],#12  ;#0043FAD3: 200174273 FF 12            u  00 88  2 218      
;  1607         jne @b          -- all ints (rax<h4) deemed less than sequences (rdi>h4)
                jne #0043FACF             ;#0043FAD8: 165 F5                     v  00 00  1 219      
;  1608         -- p2(rax) int, p3(rdi) flt:
;  1609         push rax
                push rax                  ;#0043FADA: 48:120                     uv 00 01  1 220      
;  1610         fld tbyte[rbx+rdi*4]
                fld tbyte[rbx+rdi*4]      ;#0043FADC: 333054273                  np 00 88  3 221      
;  1611         fild qword[rsp]
                fild qword[rsp]           ;#0043FADF: 337054044                  np 00 10  3 224      
;  1612         add rsp,8
                add rsp,8                 ;#0043FAE2: 48:203304 08               uv 10 10  1 227      
;  1613         fcompp
                fcompp                    ;#0043FAE6: 336331                     np 00 00  1 228      
;  1614         fnstsw ax
                fnstsw ax                 ;#0043FAE8: 337340                     np 01 00  6 229      
;  1615         mov ch,ah
                mov ch,ah                 ;#0043FAEA: 212354                     uv 02 01  1 235      
;  1616         and ah,0x7f     -- clear sign
                and ah,127                ;#0043FAEC: 200344 7F                  vu 01 01  1 235      
;  1617         shl ch,7
                shl ch,7                  ;#0043FAEF: 300345 07                  u  02 02  1 236      
;  1618         or ah,ch
                or ah,ch                  ;#0043FAF2: 010354                     uv 01 03  1 237 02   
;  1619         sahf
                sahf                      ;#0043FAF4: 236                        np 00 01  2 238      
;  1620         ret
                ret                       ;#0043FAF5: 303                        np 00 00  2 240      
;  1621     []
;  1622 
;  1623 --/*
;  1624 procedure :%opJccE(:%)
;  1625 end procedure -- (for Edita/CtrlQ)
;  1626 --*/
;  1627  :%opJccE       -- optimised opJcc for opJeq, opJne 
;  1628 ---------       -- (no need to compare int with float, they're simply not equal,
;  1629                 --  plus we can cop out early when lengths do not match)
;  1630                 -- result is Z flag
;  1631                 -- Damages eax,ecx,edx,esi,edi
;  1632     [32]
;  1633         --calling convention: (same as opJcc)
;  1634         --  mov edi,[p3]        -- ref of p3
;  1635         --  mov eax,[p2]        -- ref of p2
;  1636         --  mov esi,p3          -- var no of p3
;  1637         --  mov edx,p2          -- var no of p2
;  1638         --  call opJccE
;  1639         --  jcc xxx
;  1640         -- rationale used: fast path of {any,int} is 3 clocks.
;  1641         --  The first two je :JccEpNe92 will actually both be 
;  1642         --  branch mispredictions when they actually trigger, 
;  1643         --  but as that leads to a fatal error no-one cares,
;  1644         --  and, apart from some pairing loss, they /should/ 
;  1645         --  count as no-penalty nops when they don't trigger.
;  1646         cmp edi,h4
;  1647         jl :JccEp3Int
;  1648         je :JccEp3e92
;  1649         cmp eax,h4
;  1650         jg :equalSeqR
;  1651 --      je :JccEp2e92
;  1652 --      cmp eax,edi
;  1653 --      ret
;  1654 
;  1655       ::JccEp3Int
;  1656         cmp eax,h4
;  1657         je :JccEp2e92
;  1658         cmp eax,edi
;  1659         ret
;  1660 
;  1661       ::JccEp2e92
;  1662         mov esi,edx
;  1663       ::JccEp3e92
;  1664         mov al,92       -- e92vhnbaav(esi)
;  1665         mov edx,[esp]
;  1666         sub edx,1
;  1667         jmp :!iDiag
;  1668         int3
;  1669 
;  1670     [64]
;  1671         --calling convention:
;  1672         --  mov rdi,[p3]        -- ref of p3
;  1673         --  mov rax,[p2]        -- ref of p2
;  1674         --  mov rsi,p3          -- var no of p3
;  1675         --  mov rdx,p2          -- var no of p2
;  1676         --  call opJcc
;  1677         --  jcc xxx
;  1678 -->new code:
;  1679         mov r15,h4
                mov r15,h4                ;#0043FAF6: 49:277 0000000000000040    uv 8000 00  1 242      
;  1680         cmp rdi,r15
                cmp rdi,r15               ;#0043FB00: 49:073377                  uv 00 8080  1 243 8000   
;  1681         jl :JccEp3Int
                jl #0043FB10              ;#0043FB03: 174 0B                     v  00 00  1 243      
;  1682         je :JccEp3e92
                je #0043FB1C              ;#0043FB05: 164 15                     v  00 00  1 244      
;  1683         cmp rax,r15
                cmp rax,r15               ;#0043FB07: 49:073307                  uv 00 8001  1 245      
;  1684         jg :equalSeq64R
                jg #0043F9B9              ;#0043FB0A: 017217 A9FEFFFF            v  00 00  1 245      
;  1685 --      je :JccEp2e92
;  1686 --      cmp rax,rdi
;  1687 --      ret
;  1688 
;  1689       ::JccEp3Int
;  1690         cmp rax,r15
                cmp rax,r15               ;#0043FB10: 49:073307                  uv 00 8001  1 246      
;  1691         je :JccEp2e92
                je #0043FB19              ;#0043FB13: 164 04                     v  00 00  1 246      
;  1692         cmp rax,rdi
                cmp rax,rdi               ;#0043FB15: 48:071370                  uv 00 81  1 247      
;  1693         ret
                ret                       ;#0043FB18: 303                        np 00 00  2 248      
;  1694 
;  1695       ::JccEp2e92
;  1696         mov rsi,rdx
                mov rsi,rdx               ;#0043FB19: 48:213362                  uv 40 04  1 250      
;  1697       ::JccEp3e92
;  1698         mov al,92       -- e92vhnbaav(esi)
                mov al,92                 ;#0043FB1C: 260 5C                     vu 01 00  1 250      
;  1699         mov rdx,[rsp]
                mov rdx,[rsp]             ;#0043FB1E: 48:213024044               uv 04 10  1 251      
;  1700         sub rdx,1
                sub rdx,1                 ;#0043FB22: 48:203352 01               uv 04 04  1 252 04   
;  1701         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#0043FB26: 351 3B330000               v  00 00  1 252      
;  1702         int3
                int3                      ;#0043FB2B: 314                        np 00 00 13 253      
;  1703 
;  1704 --<old code:
;  1705 --/*
;  1706 --      cmp rax,h4
;  1707 --      jle :JccEp2Int
;  1708 --      cmp rdi,h4
;  1709 --      jle :JccEp3Int
;  1710 --      nop
;  1711 --      jmp :equalSeq64R
;  1712 --
;  1713 --    ::JccEp2Int
;  1714 --      je :e94vhnbaavedx
;  1715 --      cmp rdi,h4
;  1716 --    ::JccEp3Int
;  1717 --      je :e94vhnbaavesi
;  1718 --      cmp rax,rdi
;  1719 --      ret
;  1720         mov r15,h4
;  1721         cmp rax,r15
;  1722         jle @f
;  1723         cmp rdi,r15
;  1724         jg :equalSeq64R
;  1725       @@:
;  1726         cmp rax,rdi
;  1727         ret
;  1728 -*/
;  1729     []
;  1730 
;  1731 --/*
;  1732 procedure :%opJif(:%)
;  1733 end procedure -- (for Edita/CtrlQ)
;  1734 --*/
;  1735  :%opJif
;  1736 --------
;  1737     -- Check for unassigned vars and atom conditions, set Z flag.  Also used by opJnot.
;  1738     -- If we know p1 is init atom, just test [p1] directly. This is only used when p1
;  1739     -- may be unassigned or string/sequence. Exactly the same code for opJif & opJnot.
;  1740     [32]
;  1741         --calling convention
;  1742         --  mov eax,[p1]        -- ref of p1
;  1743         --  mov edx,p1          -- var no of p1
;  1744         --  call :%opJif
;  1745         --  jnz xxx             -- (opJif)
;  1746         --  jz xxx              -- (opJnot)
;  1747         --on exit, all regs unaltered, and the Z flag is 1 iff [p1]==0
;  1748         --DEV swapping "mov edx,p1" and "call:%opJif" might save a clock...
;  1749         --    (see the or_esi = peek4u(or_era+6) trick in pdiagN.e)
;  1750         test eax,eax
;  1751         jz @f                   -- if Z=1, act on it (ie jnz for opJif, jz for opJnot)
;  1752         cmp eax,h4
;  1753         jl @f                   -- (Z=0), act on it
;  1754     :!Jife92                    -- exception here mapped to e94vhnbaav(edx)
;  1755         test byte[ebx+eax*4-1],0x80
;  1756         jnz :e03tfcmbaa         -- true/false condition must be an ATOM
;  1757 --20/7/15:
;  1758 --                              -- (Z=0, act on it)
;  1759         test eax,eax            -- (set Z to 0, and act on it)
;  1760       @@:
;  1761         ret
;  1762 
;  1763     [64]
;  1764         --calling convention
;  1765         --  mov rax,[p1]        -- ref of p1
;  1766         --  mov rdx,p1          -- var no of p1
;  1767         --  call :%opJif
;  1768         --  jnz xxx             -- (opJif)
;  1769         --  jz xxx              -- (opJnot)
;  1770         --on exit, all regs unaltered, and the Z flag is 1 iff [p1]==0
;  1771         test rax,rax
                test rax,rax              ;#0043FB2C: 48:205300                  uv 00 01  1 266      
;  1772         jz @f                   -- if Z=1, act on it (ie jnz for opJif, jz for opJnot)
                jz #0043FB4E              ;#0043FB2F: 164 1D                     v  00 00  1 266      
;  1773         mov r15,h4
                mov r15,h4                ;#0043FB31: 49:277 0000000000000040    uv 8000 00  1 267      
;  1774         cmp rax,r15
                cmp rax,r15               ;#0043FB3B: 49:073307                  uv 00 8001  1 268 8000   
;  1775         jl @f                   -- (Z=0), act on it
                jl #0043FB4E              ;#0043FB3E: 174 0E                     v  00 00  1 268      
;  1776     :!Jife92                    -- exception here mapped to e94vhnbaav(edx)
;  1777         test byte[rbx+rax*4-1],0x80
                test byte[rbx+rax*4-1],#80  ;#0043FB40: 366104203 FF 80            u  00 09  2 269      
;  1778         jnz :e03tfcmbaa         -- true/false condition must be an ATOM
                jnz #0043F894             ;#0043FB45: 017205 49FDFFFF            v  00 00  1 270      
;  1779 --20/7/15:
;  1780 --                              -- (Z=0, act on it)
;  1781         test rax,rax            -- (set Z to 0, and act on it)
                test rax,rax              ;#0043FB4B: 48:205300                  uv 00 01  1 271      
;  1782       @@:
;  1783         ret
                ret                       ;#0043FB4E: 303                        np 00 00  2 272      
;  1784     []
;  1785 
;  1786 --DEV might yet need this...
;  1787 ----/*
;  1788 --procedure :%opSeq(:%)
;  1789 --end procedure -- (for Edita/CtrlQ)
;  1790 ----*/
;  1791 -- :%opSeq
;  1792 ----------
;  1793 --  [32]
;  1794 --  []
;  1795 
;  1796 --/*
;  1797 procedure :%opScmp(:%)
;  1798 end procedure -- (for Edita/CtrlQ)
;  1799 --*/
;  1800  :%opScmp
;  1801 ---------
;  1802     [32]
;  1803         --calling convention:
;  1804         --  lea edx,[tgt]
;  1805         --  mov edi,[p3]    (opUnassigned)
;  1806         --  mov eax,[p2]    (opUnassigned)
;  1807         --  call opSgt  [tgt] := -1/0/+1
;  1808         push edx
;  1809         mov edx,[edx]
;  1810         cmp edx,h4
;  1811         jle @f
;  1812             sub dword[ebx+edx*4-8],1
;  1813             jnz @f
;  1814             push edi
;  1815             push eax
;  1816             push dword[esp+12]
;  1817             call :%pDealloc0
;  1818             pop eax
;  1819             pop edi
;  1820       @@:
;  1821         call :%opJcc
;  1822         pop edx
;  1823         mov eax,ebx     -- 0                
;  1824         je @f
;  1825         mov al,1        -- +1
;  1826         jg @f
;  1827         sub eax,2       -- -1
;  1828 --      mov eax,-1
;  1829       @@:
;  1830         mov [edx],eax
;  1831         ret
;  1832     [64]
;  1833         --calling convention:
;  1834         --  lea rdx,[tgt]
;  1835         --  mov rdi,[p3]    (opUnassigned)
;  1836         --  mov rax,[p2]    (opUnassigned)
;  1837         --  call opSgt  [tgt] := -1/0/+1
;  1838         push rdx
                push rdx                  ;#0043FB4F: 48:122                     uv 00 04  1 274      
;  1839         mov rdx,[rdx]
                mov rdx,[rdx]             ;#0043FB51: 48:213022                  vu 04 04  1 274      
;  1840         mov r15,h4
                mov r15,h4                ;#0043FB54: 49:277 0000000000000040    uv 8000 00  1 275      
;  1841         cmp rdx,r15
                cmp rdx,r15               ;#0043FB5E: 49:073327                  uv 00 8004  1 276 8000   
;  1842         jle @f
                jle #0043FB7D             ;#0043FB61: 176 1A                     v  00 00  1 276      
;  1843             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043FB63: 48:203154223 F0 01         u  00 0C  3 277      
;  1844             jnz @f
                    jnz #0043FB7D         ;#0043FB69: 165 12                     v  00 00  1 279      
;  1845             push rdi
                    push rdi              ;#0043FB6B: 48:127                     uv 00 80  1 280      
;  1846             push rax
                    push rax              ;#0043FB6D: 48:120                     vu 00 01  1 280      
;  1847             push qword[rsp+24]
                    push qword[rsp+24]    ;#0043FB6F: 48:377164044 18            np 00 10  2 281      
;  1848             call :%pDealloc0
                    call #004422DE (:%pDealloc0)  ;#0043FB74: 350 65270000               v  00 00  1 283      
;  1849             pop rax
                    pop rax               ;#0043FB79: 48:130                     uv 01 00  1 284      
;  1850             pop rdi
                    pop rdi               ;#0043FB7B: 48:137                     vu 80 00  1 284      
;  1851       @@:
;  1852 --      call :compareSeq64R
;  1853         call :%opJcc
                call #0043FA81 (:%opJcc)  ;#0043FB7D: 350 FFFEFFFF               v  00 00  1 285      
;  1854         pop rdx
                pop rdx                   ;#0043FB82: 48:132                     uv 04 00  1 286      
;  1855         mov rax,rbx     -- 0                
                mov rax,rbx               ;#0043FB84: 48:213303                  vu 01 08  1 286      
;  1856         je @f
                je #0043FB91              ;#0043FB87: 164 08                     v  00 00  1 287      
;  1857         mov al,1        -- +1
                mov al,1                  ;#0043FB89: 260 01                     uv 01 00  1 288      
;  1858         jg @f
                jg #0043FB91              ;#0043FB8B: 177 04                     v  00 00  1 288      
;  1859         sub rax,2       -- -1
                sub rax,2                 ;#0043FB8D: 48:203350 02               uv 01 01  1 289      
;  1860 --      mov rax,-1
;  1861       @@:
;  1862         mov [rdx],rax
                mov [rdx],rax             ;#0043FB91: 48:211002                  uv 00 05  1 290 01   
;  1863         ret
                ret                       ;#0043FB94: 303                        np 00 00  2 291      
;  1864     []
;  1865 
;  1866 --/*
;  1867 procedure :%opInt0(:%)
;  1868 end procedure -- (for Edita/CtrlQ)
;  1869 --*/
;  1870  :%opInt0               -- edx:=integer(eax)
;  1871 ---------
;  1872     [32]
;  1873         --calling convention:
;  1874         --  mov eax,[p1]    (opUnassigned)
;  1875         --  call :%opInt0   edx:=integer(eax)
;  1876         cmp eax,h4
;  1877 --      mov edx,ebx
;  1878 --      setl dl
;  1879         jle :edxI1
;  1880       ::edx0
;  1881         xor edx,edx
;  1882         ret
;  1883       ::edxI1
;  1884         mov edx,1
;  1885 --      je e94vhnbaavecx
;  1886         ret
;  1887     [64]
;  1888         --calling convention:
;  1889         --  mov rax,[p1]    (opUnassigned)
;  1890         --  call :%opInt0   rdx:=integer(rax)
;  1891         mov r15,h4
                mov r15,h4                ;#0043FB95: 49:277 0000000000000040    uv 8000 00  1 293      
;  1892         cmp rax,r15
                cmp rax,r15               ;#0043FB9F: 49:073307                  uv 00 8001  1 294 8000   
;  1893         jle :rdxI1
                jle #0043FBA8             ;#0043FBA2: 176 04                     v  00 00  1 294      
;  1894       ::rdx0
;  1895         xor rdx,rdx
                xor rdx,rdx               ;#0043FBA4: 48:061322                  uv 04 04  1 295      
;  1896         ret
                ret                       ;#0043FBA7: 303                        np 00 00  2 296      
;  1897       ::rdxI1
;  1898         mov rdx,1
                mov rdx,1                 ;#0043FBA8: 48:307302 01000000         uv 04 00  1 298      
;  1899         ret
                ret                       ;#0043FBAF: 303                        np 00 00  2 299      
;  1900     []
;  1901 
;  1902 --/*
;  1903 procedure :%opAtom0(:%)
;  1904 end procedure -- (for Edita/CtrlQ)
;  1905 --*/
;  1906   :%opAtom0             -- edx:=atom(eax)
;  1907 ----------
;  1908     [32]
;  1909         cmp eax,h4
;  1910         jl :edx1
;  1911 --  opAtom0e92:             -- exception mapped to e94vhnbaavecxfeh
;  1912         cmp byte[ebx+eax*4-1],0x12
;  1913         jne :edx0
;  1914       ::edx1
;  1915         mov edx,1
;  1916         ret
;  1917     [64]
;  1918         mov r15,h4
                mov r15,h4                ;#0043FBB0: 49:277 0000000000000040    uv 8000 00  1 301      
;  1919         cmp rax,r15
                cmp rax,r15               ;#0043FBBA: 49:073307                  uv 00 8001  1 302 8000   
;  1920         jl :rdx1
                jl #0043FBC6              ;#0043FBBD: 174 07                     v  00 00  1 302      
;  1921         cmp byte[rbx+rax*4-1],0x12
                cmp byte[rbx+rax*4-1],#12  ;#0043FBBF: 200174203 FF 12            u  00 09  2 303      
;  1922         jne :rdx0
                jne #0043FBA4             ;#0043FBC4: 165 DE                     v  00 00  1 304      
;  1923       ::rdx1
;  1924         mov rdx,1
                mov rdx,1                 ;#0043FBC6: 48:307302 01000000         uv 04 00  1 305      
;  1925         ret
                ret                       ;#0043FBCD: 303                        np 00 00  2 306      
;  1926     []
;  1927 
;  1928 --/*
;  1929 procedure :%opStr0(:%)
;  1930 end procedure -- (for Edita/CtrlQ)
;  1931 --*/
;  1932   :%opStr0              -- edx=string(eax)
;  1933 ----------
;  1934     [32]
;  1935         cmp eax,h4
;  1936         jl :edx0
;  1937 --  opStr0e92:              -- exception mapped to e94vhnbaavecxfeh
;  1938         cmp byte[ebx+eax*4-1],0x82
;  1939         jne :edx0
;  1940         mov edx,1
;  1941         ret
;  1942     [64]
;  1943         mov r15,h4
                mov r15,h4                ;#0043FBCE: 49:277 0000000000000040    uv 8000 00  1 308      
;  1944         cmp rax,r15
                cmp rax,r15               ;#0043FBD8: 49:073307                  uv 00 8001  1 309 8000   
;  1945         jl :rdx0
                jl #0043FBA4              ;#0043FBDB: 174 C7                     v  00 00  1 309      
;  1946         cmp byte[rbx+rax*4-1],0x82
                cmp byte[rbx+rax*4-1],#82  ;#0043FBDD: 200174203 FF 82            u  00 09  2 310      
;  1947         jne :rdx0
                jne #0043FBA4             ;#0043FBE2: 165 C0                     v  00 00  1 311      
;  1948         mov rdx,1
                mov rdx,1                 ;#0043FBE4: 48:307302 01000000         uv 04 00  1 312      
;  1949         ret
                ret                       ;#0043FBEB: 303                        np 00 00  2 313      
;  1950     []
;  1951 
;  1952 --/*
;  1953 procedure :%opSq0(:%)
;  1954 end procedure -- (for Edita/CtrlQ)
;  1955 --*/
;  1956   :%opSq0                   -- edx=sequence(eax)  (NB: opSeq is p1=(p2=p3))
;  1957 ---------
;  1958     [32]
;  1959         cmp eax,h4
;  1960         jl :edx0
;  1961 --  opSq0e92:               -- exception mapped to e94vhnbaavecxfeh
;  1962         test byte[ebx+eax*4-1],0x80
;  1963         jz :edx0
;  1964         mov edx,1
;  1965         ret
;  1966     [64]
;  1967         mov r15,h4
                mov r15,h4                ;#0043FBEC: 49:277 0000000000000040    uv 8000 00  1 315      
;  1968         cmp rax,r15
                cmp rax,r15               ;#0043FBF6: 49:073307                  uv 00 8001  1 316 8000   
;  1969         jl :rdx0
                jl #0043FBA4              ;#0043FBF9: 174 A9                     v  00 00  1 316      
;  1970         test byte[rbx+rax*4-1],0x80
                test byte[rbx+rax*4-1],#80  ;#0043FBFB: 366104203 FF 80            u  00 09  2 317      
;  1971         jz :rdx0
                jz #0043FBA4              ;#0043FC00: 164 A2                     v  00 00  1 318      
;  1972         mov rdx,1
                mov rdx,1                 ;#0043FC02: 48:307302 01000000         uv 04 00  1 319      
;  1973         ret
                ret                       ;#0043FC09: 303                        np 00 00  2 320      
;  1974     []
;  1975       }
    jmp #0044298D (:%opRetf)              ;#0043FC0A: 351 7E2D0000               v  00 00  1 322      
;C:\Program Files (x86)\Phix\builtins\VM\pUnary.e:
;=================================================
;     1 --
;     2 -- pUnary.e
;     3 -- ========
;     4 --
;     5 --  Implements :%opUminus, :%opNot, :%opNotBits, :%opFloor
;     6 --
;     7 --  Note that floor(a/b) is handled in opMath.e (opDivf[2] etc)
;     8 --
;     9 
;    10 include VM\pHeap.e  -- :%pDealloc/:%pStoreFlt
;    11 include VM\pFPU.e   -- :%down53 etc
;    12 
;    13 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043F73D: 351 4B320000               v  00 00  1   1      
;    14 
;    15 --DEV
;    16         ::e1407souma
;    17             int3
                    int3                  ;#0043F742: 314                        np 00 00 13   2      
;    18         ::e1408sona
;    19             int3
                    int3                  ;#0043F743: 314                        np 00 00 13  15      
;    20         ::e1406sofa
;    21             int3
                    int3                  ;#0043F744: 314                        np 00 00 13  28      
;    22         ::e1412sonba
;    23             int3
                    int3                  ;#0043F745: 314                        np 00 00 13  41      
;    24     [32]
;    25         ::e111bolt32besp
;    26             int3
;    27     []
;    28 
;    29 --/*
;    30 procedure :%opUminus(:%)
;    31 end procedure -- (for Edita/CtrlQ)
;    32 --*/
;    33   :%opUminus         -- [edi] = -ecx (integers and floats only)
;    34 ------------
;    35     [32]
;    36         --calling convention:
;    37         --  lea edi,[p1]        -- target
;    38         --  mov ecx,[p2]        -- ref p2 (opUnassigned)
;    39         --  call :%opUminus
;    40         --    all registers trashed unless result is integer, else result in ecx [DEV? (as below)]
;    41 
;    42         cmp ecx,h4
;    43         jge :opUminusN
;    44 
;    45         cmp ecx,0xC0000000
;    46         je :opUminusToN 
;    47 
;    48         neg ecx                 -- eax=-eax (1 clock NP)
;    49 
;    50         mov edx,[edi]           -- previous value of target
;    51         mov [edi],ecx
;    52         cmp edx,h4
;    53         jle @f
;    54             sub dword[ebx+edx*4-8],1
;    55             jz :%pDealloc
;    56       @@:
;    57         ret
;    58 
;    59       ::opUminusToN             -- special case: as integers are -1073741824..+1073741823,
;    60         push ecx                --  -(-1073741824) needs to be stored as a float.
;    61         fild dword[esp]         -- (obviously, we want it signed)
;    62         pop ecx
;    63         jmp opUminusfchs
;    64 
;    65       ::opUminusN
;    66         cmp byte[ebx+ecx*4-1],0x12
;    67         jne :e1407souma             -- sequence op(unary minus) attempted
;    68         fld qword[ebx+ecx*4]
;    69       ::opUminusfchs
;    70         fchs    
;    71         jmp :%pStoreFlt
;    72 
;    73     [64]
;    74         --calling convention:
;    75         --  lea rdi,[p1]        -- target
;    76         --  mov rcx,[p2]        -- ref p2 (opUnassigned)
;    77         --  call :%opUminus
;    78         --    rax/rcx/rdx/rsi/rdi/r14/r15 trashed unless result is integer, left in rcx [DEV? (not true for storeFlt anyway)]
;    79 
;    80 --      cmp rcx,h4
;    81         mov r15,h4
                mov r15,h4                ;#0043F746: 49:277 0000000000000040    uv 8000 00  1  54      
;    82         cmp rcx,r15
                cmp rcx,r15               ;#0043F750: 49:073317                  uv 00 8002  1  55 8000   
;    83         jge :opUminusN
                jge #0043F789             ;#0043F753: 175 34                     v  00 00  1  55      
;    84 
;    85 --      cmp rcx,0xC000000000000000
;    86 --      mov r14,#C000000000000000
;    87         mov r14,#C0000000 --0000 0000
                mov r14,-1073741824       ;#0043F755: 49:307306 000000C0         uv 4000 00  1  56      
;    88         shl r14,32
                shl r14,32                ;#0043F75C: 49:301346 20               u  4000 4000  1  57      
;    89         cmp rcx,r14
                cmp rcx,r14               ;#0043F760: 49:073316                  uv 00 4002  1  58 4000   
;    90         je opUminusToN  
                je #0043F780              ;#0043F763: 164 1B                     v  00 00  1  58      
;    91 
;    92         neg rcx                 -- eax=-eax (1 clock NP)
                neg rcx                   ;#0043F765: 48:367331                  np 02 02  1  59      
;    93 
;    94         mov rdx,[rdi]           -- previous value of target
                mov rdx,[rdi]             ;#0043F768: 48:213027                  uv 04 80  1  60      
;    95         mov [rdi],rcx
                mov [rdi],rcx             ;#0043F76B: 48:211017                  vu 00 82  1  60      
;    96 --      cmp rdx,h4
;    97 --      mov r15,h4
;    98         cmp rdx,r15
                cmp rdx,r15               ;#0043F76E: 49:073327                  uv 00 8004  1  61      
;    99         jle @f
                jle #0043F77F             ;#0043F771: 176 0C                     v  00 00  1  61      
;   100             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043F773: 48:203154223 F0 01         u  00 0C  3  62      
;   101             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043F779: 017204 5B2B0000            v  00 00  1  64      
;   102       @@:
;   103         ret
                ret                       ;#0043F77F: 303                        np 00 00  2  65      
;   104 
;   105       ::opUminusToN             -- special case: as integers are -4611686018427387904..+4611686018427387903,
;   106         push rcx                --  -(-4611686018427387904) needs to be stored as a float.
                push rcx                  ;#0043F780: 48:121                     uv 00 02  1  67      
;   107         fild qword[rsp]         -- (obviously, we want it signed)
                fild qword[rsp]           ;#0043F782: 337054044                  np 00 10  3  68      
;   108         pop rcx
                pop rcx                   ;#0043F785: 48:131                     uv 02 00  1  71      
;   109         jmp opUminusfchs
                jmp #0043F793             ;#0043F787: 353 0A                     v  00 00  1  71      
;   110 
;   111       ::opUminusN
;   112         cmp byte[rbx+rcx*4-1],0x12
                cmp byte[rbx+rcx*4-1],#12  ;#0043F789: 200174213 FF 12            u  00 0A  2  74    *02*
;   113         jne :e1407souma             -- sequence op(unary minus) attempted
                jne #0043F742             ;#0043F78E: 165 B2                     v  00 00  1  75      
;   114         fld tbyte[rbx+rcx*4]
                fld tbyte[rbx+rcx*4]      ;#0043F790: 333054213                  np 00 0A  3  76      
;   115       ::opUminusfchs
;   116         fchs    
                fchs                      ;#0043F793: 331340                     np 00 00  1  79      
;   117         jmp :%pStoreFlt
                jmp #004421B0 (:%pStoreFlt)  ;#0043F795: 351 162A0000               v  00 00  1  80      
;   118     []
;   119 
;   120 --/*
;   121 procedure :%opNot(:%)
;   122 end procedure -- (for Edita/CtrlQ)
;   123 --*/
;   124   :%opNot       -- [edi] = not(ecx), ie sets [edi] to 0 or 1
;   125 ---------       -- Damages eax,edx, plus pDealloc (ie all)
;   126     [32]
;   127         --calling convention:
;   128         --  lea edi,[p1]    -- result location (->0/1)
;   129         --  mov ecx,[p2]    -- ref p2 (opUnassigned)
;   130         --  call :%opNot        -- [edi]=not(ecx)
;   131         xor eax,eax         -- eax=0
;   132         mov edx,[edi]       -- prev
;   133         cmp ecx,h4
;   134         jge :opNotN
;   135         test ecx,ecx
;   136         setz al             -- eax is now 1 or 0
;   137       @@:
;   138         mov [edi],eax       -- 0 or 1
;   139         cmp edx,h4
;   140         jle :opNotNoDealloc
;   141             sub dword[ebx+edx*4-8],1
;   142             jz :%pDealloc
;   143       ::opNotNoDealloc
;   144         ret
;   145 
;   146     ::opNotN
;   147         cmp byte[ebx+ecx*4-1],0x12
;   148         je @b           -- all floats non-0 so result is 0
;   149         jmp :e1408sona  -- sequence op (not) attempted
;   150     [64]
;   151         --calling convention:
;   152         --  lea rdi,[p1]    -- result location (->0/1)
;   153         --  mov rcx,[p2]    -- ref p2 (opUnassigned)
;   154         --  call :%opNot        -- [rdi]=not(rcx)
;   155         xor rax,rax         -- rax=0
                xor rax,rax               ;#0043F79A: 48:061300                  uv 01 01  1  81      
;   156         mov rdx,[rdi]       -- prev
                mov rdx,[rdi]             ;#0043F79D: 48:213027                  vu 04 80  1  81      
;   157 --      cmp rcx,h4
;   158         mov r15,h4
                mov r15,h4                ;#0043F7A0: 49:277 0000000000000040    uv 8000 00  1  82      
;   159         cmp rcx,r15
                cmp rcx,r15               ;#0043F7AA: 49:073317                  uv 00 8002  1  83 8000   
;   160         jge :opNotN
                jge #0043F7CA             ;#0043F7AD: 175 1B                     v  00 00  1  83      
;   161         test rcx,rcx
                test rcx,rcx              ;#0043F7AF: 48:205311                  uv 00 02  1  84      
;   162         setz al             -- rax is now 1 or 0
                setz al                   ;#0043F7B2: 017224300                  np 01 00  2  85      
;   163       @@:
;   164         mov [rdi],rax       -- 0 or 1
                mov [rdi],rax             ;#0043F7B5: 48:211007                  uv 00 81  1  87      
;   165 --      cmp rdx,h4
;   166 --      mov r15,h4
;   167         cmp rdx,r15
                cmp rdx,r15               ;#0043F7B8: 49:073327                  vu 00 8004  1  87      
;   168         jle :opNotNoDealloc
                jle #0043F7C9             ;#0043F7BB: 176 0C                     v  00 00  1  88      
;   169             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043F7BD: 48:203154223 F0 01         u  00 0C  3  89      
;   170             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043F7C3: 017204 112B0000            v  00 00  1  91      
;   171       ::opNotNoDealloc
;   172         ret
                ret                       ;#0043F7C9: 303                        np 00 00  2  92      
;   173 
;   174     ::opNotN
;   175         cmp byte[rbx+rcx*4-1],0x12
                cmp byte[rbx+rcx*4-1],#12  ;#0043F7CA: 200174213 FF 12            u  00 0A  2  94      
;   176         je @b           -- all floats non-0 so result is 0
                je #0043F7B5              ;#0043F7CF: 164 E4                     v  00 00  1  95      
;   177         jmp :e1408sona  -- sequence op (not) attempted
                jmp #0043F743             ;#0043F7D1: 351 6DFFFFFF               v  00 00  1  96      
;   178     []
;   179 
;   180 --/*
;   181 procedure :%opNotBits(:%)
;   182 end procedure -- (for Edita/CtrlQ)
;   183 --*/
;   184   :%opNotBits   -- [edi] = not_bits(eax)
;   185 ---------       -- Damages all registers
;   186     [32]
;   187         --calling convention:
;   188         --  lea edi,[p1]    -- result location (->0/1)
;   189         --  mov eax,[p2]    -- ref p2 (opUnassigned)
;   190         --  call :%opNotBits    -- [edi]=not_bits(eax)
;   191         sub esp,8
;   192         cmp eax,h4 --DEV :%pLoadMint
;   193         jl @f
;   194             cmp byte[ebx+eax*4-1],0x12
;   195             jne :e1412sonba         -- sequence op (not_bits) attempted
;   196             fld qword[ebx+eax*4]
;   197             call :%down53
;   198             fistp qword[esp]    -- store as 64 bits
;   199             call :%near53
;   200             mov eax,[esp]       -- load top 32
;   201 --          cdq                     -- sign extend (to edx)
;   202 --23/2/10:
;   203 --          cmp edx,[esp+4]     -- same as low 32?
;   204             mov edx,[esp+4]
;   205             test edx,edx
;   206             jz @f
;   207                 add edx,1
;   208                 jnz e111bolt32besp      -- bitwise operations limited to 32 bits
;   209 --          jne e111bolt32besp      -- bitwise operations limited to 32 bits
;   210       @@:
;   211 
;   212 --      not eax
;   213 --DEV Agner Fog says: xor eax,-1
;   214         xor eax,-1
;   215 
;   216         mov [esp],eax
;   217         fild dword[esp]
;   218         add esp,8
;   219         jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
;   220     [64]
;   221         --calling convention:
;   222         --  lea rdi,[p1]    -- result location (->0/1)
;   223         --  mov rax,[p2]    -- ref p2 (opUnassigned)
;   224         --  call :%opNotBits    -- [rdi]=not_bits(rax)
;   225         mov r15,h4
                mov r15,h4                ;#0043F7D6: 49:277 0000000000000040    uv 8000 00  1  97      
;   226         sub rsp,8
                sub rsp,8                 ;#0043F7E0: 48:203354 08               vu 10 10  1  97      
;   227         cmp rax,r15
                cmp rax,r15               ;#0043F7E4: 49:073307                  uv 00 8001  1  98      
;   228         jl @f
                jl #0043F808              ;#0043F7E7: 174 1F                     v  00 00  1  98      
;   229             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043F7E9: 200174203 FF 12            u  00 09  2  99      
;   230             jne :e1412sonba         -- sequence op (not_bits) attempted
                    jne #0043F745         ;#0043F7EE: 017205 51FFFFFF            v  00 00  1 100      
;   231             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043F7F4: 333054203                  np 00 09  3 101      
;   232             call :%down64
                    call #0044139E (:%down64)  ;#0043F7F7: 350 A21B0000               v  00 00  1 104      
;   233             fistp qword[rsp]    -- store as 64 bits
                    fistp qword[rsp]      ;#0043F7FC: 337074044                  np 00 10  6 105      
;   234             call :%near64
                    call #004413A5 (:%near64)  ;#0043F7FF: 350 A11B0000               v  00 00  1 111      
;   235             mov rax,[rsp]
                    mov rax,[rsp]         ;#0043F804: 48:213004044               uv 01 10  1 112      
;   236 --          mov edx,[esp+4]
;   237 --          test edx,edx
;   238 --          jz @f
;   239 --              add edx,1
;   240 --              jnz e111bolt32besp      -- bitwise operations limited to 32 bits
;   241       @@:
;   242 
;   243 --      not rax
;   244 --DEV Agner Fog says: xor eax,-1
;   245         xor rax,-1
                xor rax,-1                ;#0043F808: 48:203360 FF               uv 01 01  1 113 01   
;   246 
;   247         mov [rsp],rax
                mov [rsp],rax             ;#0043F80C: 48:211004044               uv 00 11  1 114 01   
;   248         fild qword[rsp]
                fild qword[rsp]           ;#0043F810: 337054044                  np 00 10  3 115      
;   249         add rsp,8
                add rsp,8                 ;#0043F813: 48:203304 08               uv 10 10  1 118      
;   250         jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
                jmp #004421B0 (:%pStoreFlt)  ;#0043F817: 351 94290000               v  00 00  1 118      
;   251     []
;   252 
;   253 --/*
;   254 procedure :%opFloor(:%)
;   255 end procedure -- (for Edita/CtrlQ)
;   256 --*/
;   257   :%opFloor
;   258 -----------
;   259     [32]
;   260         --calling convention:
;   261         --  lea edi,[p1]    -- result location
;   262         --  mov eax,[p2]    -- ref p2 (opUnassigned)
;   263         --  call :%opFloor  -- [edi]=floor(eax)
;   264         --  all regs trashed, unless result is integer, in eax (and [p1]), esi,ecx also trashed
;   265         mov edx,[edi]
;   266         cmp eax,h4
;   267         jl :opFloorStoreInt
;   268         cmp byte[ebx+eax*4-1],0x12
;   269         jne e1406sofa
;   270         sub esp,8
;   271         --
;   272         -- Load a 64-bit float
;   273         --
;   274         fld qword[ebx+eax*4]
;   275         call :%down64
;   276         frndint
;   277 --DEV near64? (spotted in passing)
;   278         call :%near53
;   279 
;   280         fld st0
;   281         fistp qword[esp]        -- store as 64-bit int
;   282         fild dword[esp]         -- and reload lower 32-bits
;   283         mov ecx,[esp]
;   284         fcomp st1               -- pop one
;   285         add esp,8
;   286         fnstsw ax
;   287         sahf
;   288         mov eax,ecx
;   289         jne :%pStoreFlt         -- not 32-bit integer
;   290         shl ecx,1
;   291         jo :%pStoreFlt          -- result bigger than 31 bits
;   292         --
;   293         -- store as short int then
;   294         --
;   295         fstp st0                -- discard copy
;   296 
;   297       ::opFloorStoreInt
;   298         mov [edi],eax
;   299         cmp edx,h4
;   300         jle @f
;   301             sub dword[ebx+edx*4-8],1
;   302             jz :%pDealloc
;   303       @@:
;   304         ret 
;   305 
;   306     [64]
;   307         --calling convention:
;   308         --  lea rdi,[p1]    -- result location
;   309         --  mov rax,[p2]    -- ref p2 (opUnassigned)
;   310         --  call :%opFloor  -- [rdi]=floor(rax)
;   311         --  all regs trashed, unless result is integer, in rax (and [p1]), rsi,rcx also trashed
;   312         mov r15,h4
                mov r15,h4                ;#0043F81C: 49:277 0000000000000040    uv 8000 00  1 119      
;   313         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043F826: 48:213027                  vu 04 80  1 119      
;   314         cmp rax,r15
                cmp rax,r15               ;#0043F829: 49:073307                  uv 00 8001  1 120      
;   315         jl :opFloorStoreInt
                jl #0043F875              ;#0043F82C: 174 47                     v  00 00  1 120      
;   316         cmp byte[rbx+rax*4-1],0x12
                cmp byte[rbx+rax*4-1],#12  ;#0043F82E: 200174203 FF 12            u  00 09  2 121      
;   317         jne e1406sofa
                jne #0043F744             ;#0043F833: 017205 0BFFFFFF            v  00 00  1 122      
;   318         sub rsp,8
                sub rsp,8                 ;#0043F839: 48:203354 08               uv 10 10  1 123      
;   319         --
;   320         -- Load an 80-bit float
;   321         --
;   322         fld tbyte[rbx+rax*4]
                fld tbyte[rbx+rax*4]      ;#0043F83D: 333054203                  np 00 09  3 124      
;   323         call :%down64
                call #0044139E (:%down64)  ;#0043F840: 350 591B0000               v  00 00  1 127      
;   324         frndint             --DEV SLOW!
                frndint                   ;#0043F845: 331374                     np 00 00 20 128      
;   325         call :%near64
                call #004413A5 (:%near64)  ;#0043F847: 350 591B0000               v  00 00  1 148      
;   326 
;   327         fld st0
                fld st0                   ;#0043F84C: 331300                     np 00 00  1 149      
;   328         fistp qword[rsp]        -- store as 64-bit int
                fistp qword[rsp]          ;#0043F84E: 337074044                  np 00 10  6 150      
;   329         fild qword[rsp]         -- and reload
                fild qword[rsp]           ;#0043F851: 337054044                  np 00 10  3 156      
;   330         mov rcx,[rsp]
                mov rcx,[rsp]             ;#0043F854: 48:213014044               uv 02 10  1 159      
;   331         fcomp st1               -- pop one
                fcomp                     ;#0043F858: 330331                     np 00 00  1 160      
;   332         add rsp,8
                add rsp,8                 ;#0043F85A: 48:203304 08               uv 10 10  1 161      
;   333         fnstsw ax
                fnstsw ax                 ;#0043F85E: 337340                     np 01 00  6 162      
;   334         sahf
                sahf                      ;#0043F860: 236                        np 00 01  2 168      
;   335         mov rax,rcx
                mov rax,rcx               ;#0043F861: 48:213301                  uv 01 02  1 170      
;   336         jne :%pStoreFlt         -- not 64-bit integer
                jne #004421B0 (:%pStoreFlt)  ;#0043F864: 017205 46290000            v  00 00  1 170      
;   337         shl rcx,1
                shl rcx,1                 ;#0043F86A: 48:321341                  u  02 02  1 171      
;   338         jo :%pStoreFlt          -- result bigger than 63 bits
                jo #004421B0 (:%pStoreFlt)  ;#0043F86D: 017200 3D290000            v  00 00  1 171      
;   339         --
;   340         -- store as short int then
;   341         --
;   342         fstp st0                -- discard copy
                fstp st0                  ;#0043F873: 335330                     np 00 00  1 172      
;   343 
;   344       ::opFloorStoreInt
;   345         mov [rdi],rax
                mov [rdi],rax             ;#0043F875: 48:211007                  uv 00 81  1 173      
;   346         cmp rdx,r15
                cmp rdx,r15               ;#0043F878: 49:073327                  vu 00 8004  1 173      
;   347         jle @f
                jle #0043F889             ;#0043F87B: 176 0C                     v  00 00  1 174      
;   348             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043F87D: 48:203154223 F0 01         u  00 0C  3 175      
;   349             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043F883: 017204 512A0000            v  00 00  1 177      
;   350       @@:
;   351         ret 
                ret                       ;#0043F889: 303                        np 00 00  2 178      
;   352     []
;   353       }
;   354 
;   355 --global function not_bits(atom a)
;   356 --  return xor_bits(a,-1)
;   357 --end function
;   358 
;C:\Program Files (x86)\Phix\builtins\VM\pMath.e:
;================================================
;     1 --
;     2 -- pMath.e
;     3 -- =======
;     4 --
;     5 --  implements :%opAdd[i], :%opSub[i], :%opDiv[i/f/2], :%opMul[i],
;     6 --             :%opAndBits, :%opOrBits, :%opXorBits
;     7 --
;     8 --  Obviously, the compiler emits "add", "sub", "shr", etc when it can, but one thing we really 
;     9 --  want to avoid are the C style idioms that 2147483647+1 = -2147483648, or that 3/2 is 1. 
;    10 --  In Phix, the result is whatever type it needs to be, so (the integer) 1073741823 + 1 is 
;    11 --  (the atom) 1073741824, 3/2 is 1.5, floor(3/2) is 1, and 1.5+1.5 is (the integer) 3.
;    12 --
;    13 --  Note: These functions require atom arguments, see builtins\psqop.e for explicit function-style
;    14 --        sequence ops. I would not be totally averse to these functions being extended to cater
;    15 --        for (implicit) sequence ops, it is {=,!=,<=,<,>,>=} that I object to, and personally I
;    16 --        believe it is just not worth deliberately doing "half" (ok 26/32) of a job, iyswim. I
;    17 --        would not object to adding say {@==,@!=,@<=,@<,@>,@>=} as explicit infix relops, either.
;    18 --        I could also argue that psqop.e has proved itself to be perfectly fast enough.
;    19 --
;    20 
;    21 include builtins\VM\pFPU.e      -- :%down53, :%near53
;    22 
;    23 -- to force it into p.exe for the optable...
;    24 include builtins\VM\pXor.e      -- not actually used in p.exe, but in optable for pdiagN.e
;    25 
;    26 constant half = 0.5
;    27 
;    28 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043F35A: 351 2E360000               v  00 00  1   1      
;    29 
;    30 --DEV FIXME: (and the :!bang labels below)
;    31     ::e14soa
;    32         int3
                int3                      ;#0043F35F: 314                        np 00 00 13   2      
;    33     ::e01tcfeaxedi
;    34         int3
                int3                      ;#0043F360: 314                        np 00 00 13  15      
;    35 --  ::e01tcfst0edi
;    36 --      int3
;    37     ::e02atdb0pop
;    38         [32]
;    39             add esp,4               -- trash return address (opMathIII)
;    40         [64]
;    41             add rsp,8               -- trash return address (opMathIII)
                    add rsp,8             ;#0043F361: 48:203304 08               uv 10 10  1  28      
;    42         []
;    43     ::e02atdb0
;    44         [32]
;    45             pop edx
;    46             mov al,2
;    47             add edx,-1
;    48         [64]
;    49             pop rdx
                    pop rdx               ;#0043F365: 48:132                     vu 04 00  1  28      
;    50             mov al,2
                    mov al,2              ;#0043F367: 260 02                     uv 01 00  1  29      
;    51             add rdx,-1
                    add rdx,-1            ;#0043F369: 48:203302 FF               vu 04 04  1  29      
;    52         []
;    53             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#0043F36D: 351 F43A0000               v  00 00  1  30      
;    54         int3
                int3                      ;#0043F372: 314                        np 00 00 13  31      
;    55     ::e01tcfeaxplusedxoverecxedi
;    56         int3
                int3                      ;#0043F373: 314                        np 00 00 13  44      
;    57     ::e01tcfediMul
;    58         int3
                int3                      ;#0043F374: 314                        np 00 00 13  57      
;    59 
;    60 --/*
;    61 procedure ::opMath(::)
;    62 end procedure -- (for Edita/CtrlQ)
;    63 --*/
;    64     [32]
;    65       ::opMath
;    66 --------------
;    67         -- internal routine.
;    68         -- on entry,
;    69         --  edi is addr result
;    70         --  ecx is p2 (opUnassigned)
;    71         --  eax is p3 (opUnassigned)
;    72         --  edx is the integer math function (eg :opAddI) (result in ecx)
;    73         --  esi is the floating point math function (eg :opAddF) (result in st0)
;    74         -- (NB: edx/esi are permitted to discard the (new) return address,
;    75         --  finish the job themselves, or whatever else takes their fancy.)
;    76         --  [esp] is the return address
;    77         --  
;    78         cmp ecx,h4
;    79         jge :opMathN
;    80             --
;    81             -- ecx [p2] is an int
;    82             --
;    83             cmp eax,h4
;    84             jl @f
;    85                 --
;    86                 -- ecx/p2 is int, eax/p3 is (must be) a float.
;    87                 --
;    88                 push ecx
;    89                 fild dword[esp]
;    90                 add esp,4
;    91                 cmp byte[ebx+eax*4-1],0x12
;    92                 jne e14soa                  -- sequence op attempted
;    93                 fld qword[ebx+eax*4]
;    94                 call esi                    -- eg faddp
;    95                 jmp :%pStoreFlt
;    96 
;    97           @@:
;    98             call edx                        -- eg add ecx,eax
;    99           ::opMathIII                       -- (opDivI returns via opMathIII or not at all)
;   100             mov eax,ecx
;   101             mov edx,[edi]
;   102             shl ecx,1
;   103             jo opMathIIN                    -- must store as atom
;   104             mov [edi],eax
;   105             cmp edx,h4
;   106             jle @f
;   107                 sub dword[ebx+edx*4-8],1
;   108                 jz :%pDealloc
;   109           @@:
;   110             ret
;   111 
;   112         ::opMathIIN
;   113             --
;   114             -- eax is result but too big for integer.
;   115             --
;   116             push eax
;   117             fild dword[esp]
;   118             add esp,4
;   119             jmp :%pStoreFlt
;   120 
;   121         ::opMathN
;   122             --
;   123             -- load p2 as float, then consider p3
;   124             --
;   125             cmp byte[ebx+ecx*4-1],0x12
;   126             jne e14soa                  -- sequence op attempted
;   127             fld qword[ebx+ecx*4]
;   128 
;   129             cmp eax,h4
;   130             jge :opMathNN
;   131             push eax
;   132             fild dword[esp]
;   133             add esp,4
;   134             call esi                    -- eg faddp
;   135             jmp :%pStoreFlt
;   136 
;   137         ::opMathNN
;   138             --
;   139             -- st0/p2 is loaded, eax/p3 is (must be) a float
;   140             --
;   141             cmp byte[ebx+eax*4-1],0x12
;   142             jne e14soa                  -- sequence op attempted
;   143             fld qword[ebx+eax*4]
;   144             call esi                    -- eg faddp
;   145             jmp :%pStoreFlt
;   146 
;   147     [64]
;   148       ::opMath
;   149 --------------
;   150         -- internal routine.
;   151         -- on entry,
;   152         --  rdi is addr result
;   153         --  rcx is p2 (opUnassigned)
;   154         --  rax is p3 (opUnassigned)
;   155         --  rdx is the integer math function (eg :opAddI)
;   156         --  rsi is the floating point math function (eg :opAddF)
;   157         -- (NB: rdx/rsi are permitted to discard the (new) return address,
;   158         --  finish the job themselves, or whatever else takes their fancy.)
;   159         --  [rsp] is the return address
;   160         --  
;   161         mov r15,h4
                mov r15,h4                ;#0043F375: 49:277 0000000000000040    uv 8000 00  1  70      
;   162 --      cmp rcx,h4
;   163         cmp rcx,r15
                cmp rcx,r15               ;#0043F37F: 49:073317                  uv 00 8002  1  71 8000   
;   164         jge :opMathN
                jge #0043F3D3             ;#0043F382: 175 4F                     v  00 00  1  71      
;   165             --
;   166             -- rcx [p2] is an int
;   167             --
;   168 --          cmp rax,h4
;   169             cmp rax,r15
                    cmp rax,r15           ;#0043F384: 49:073307                  uv 00 8001  1  72      
;   170             jl @f
                    jl #0043F3A3          ;#0043F387: 174 1A                     v  00 00  1  72      
;   171                 --
;   172                 -- rcx/p2 is int, rax/p3 is (must be) a float.
;   173                 --
;   174                 push rcx
                        push rcx          ;#0043F389: 48:121                     uv 00 02  1  73      
;   175                 fild qword[rsp]
                        fild qword[rsp]   ;#0043F38B: 337054044                  np 00 10  3  74      
;   176                 add rsp,8
                        add rsp,8         ;#0043F38E: 48:203304 08               uv 10 10  1  77      
;   177                 cmp byte[rbx+rax*4-1],0x12
                        cmp byte[rbx+rax*4-1],#12  ;#0043F392: 200174203 FF 12            u  00 09  2  78      
;   178                 jne e14soa                  -- sequence op attempted
                        jne #0043F35F     ;#0043F397: 165 C6                     v  00 00  1  79      
;   179                 fld tbyte[rbx+rax*4]
                        fld tbyte[rbx+rax*4]  ;#0043F399: 333054203                  np 00 09  3  80      
;   180                 call rsi                    -- eg faddp
                        call rsi          ;#0043F39C: 377326                     np 00 40  2  83      
;   181                 jmp :%pStoreFlt
                        jmp #004421B0 (:%pStoreFlt)  ;#0043F39E: 351 0D2E0000               v  00 00  1  85      
;   182 
;   183           @@:
;   184             call rdx                        -- eg add rcx,rax
                    call rdx              ;#0043F3A3: 377322                     np 00 04  2  86      
;   185           ::opMathIII                       -- (opDivI returns via opMathIII or not at all)
;   186             mov rax,rcx
                    mov rax,rcx           ;#0043F3A5: 48:213301                  uv 01 02  1  88      
;   187             mov rdx,[rdi]
                    mov rdx,[rdi]         ;#0043F3A8: 48:213027                  vu 04 80  1  88      
;   188             shl rcx,1
                    shl rcx,1             ;#0043F3AB: 48:321341                  u  02 02  1  89      
;   189             jo opMathIIN                    -- must store as atom
                    jo #0043F3C5          ;#0043F3AE: 160 15                     v  00 00  1  89      
;   190             mov [rdi],rax
                    mov [rdi],rax         ;#0043F3B0: 48:211007                  uv 00 81  1  90      
;   191 --          cmp rdx,h4
;   192             cmp rdx,r15
                    cmp rdx,r15           ;#0043F3B3: 49:073327                  vu 00 8004  1  90      
;   193             jle @f
                    jle #0043F3C4         ;#0043F3B6: 176 0C                     v  00 00  1  91      
;   194                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043F3B8: 48:203154223 F0 01         u  00 0C  3  92      
;   195                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043F3BE: 017204 162F0000            v  00 00  1  94      
;   196           @@:
;   197             ret
                    ret                   ;#0043F3C4: 303                        np 00 00  2  95      
;   198 
;   199         ::opMathIIN
;   200             --
;   201             -- rax is result but too big for integer.
;   202             --
;   203             push rax
                    push rax              ;#0043F3C5: 48:120                     uv 00 01  1  97      
;   204             fild qword[rsp]
                    fild qword[rsp]       ;#0043F3C7: 337054044                  np 00 10  3  98      
;   205             add rsp,8
                    add rsp,8             ;#0043F3CA: 48:203304 08               uv 10 10  1 101      
;   206             jmp :%pStoreFlt
                    jmp #004421B0 (:%pStoreFlt)  ;#0043F3CE: 351 DD2D0000               v  00 00  1 101      
;   207 
;   208         ::opMathN
;   209             --
;   210             -- load p2 as float, then consider p3
;   211             --
;   212             cmp byte[rbx+rcx*4-1],0x12
                    cmp byte[rbx+rcx*4-1],#12  ;#0043F3D3: 200174213 FF 12            u  00 0A  2 102      
;   213             jne e14soa                  -- sequence op attempted
                    jne #0043F35F         ;#0043F3D8: 165 85                     v  00 00  1 103      
;   214             fld tbyte[rbx+rcx*4]
                    fld tbyte[rbx+rcx*4]  ;#0043F3DA: 333054213                  np 00 0A  3 104      
;   215 
;   216 --          cmp rax,h4
;   217             cmp rax,r15
                    cmp rax,r15           ;#0043F3DD: 49:073307                  uv 00 8001  1 107      
;   218             jge :opMathNN
                    jge #0043F3F2         ;#0043F3E0: 175 10                     v  00 00  1 107      
;   219             push rax
                    push rax              ;#0043F3E2: 48:120                     uv 00 01  1 108      
;   220             fild qword[rsp]
                    fild qword[rsp]       ;#0043F3E4: 337054044                  np 00 10  3 109      
;   221             add rsp,8
                    add rsp,8             ;#0043F3E7: 48:203304 08               uv 10 10  1 112      
;   222             call rsi                    -- eg faddp
                    call rsi              ;#0043F3EB: 377326                     np 00 40  2 113      
;   223             jmp :%pStoreFlt
                    jmp #004421B0 (:%pStoreFlt)  ;#0043F3ED: 351 BE2D0000               v  00 00  1 115      
;   224 
;   225         ::opMathNN
;   226             --
;   227             -- st0/p2 is loaded, rax/p3 is (must be) a float
;   228             --
;   229             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043F3F2: 200174203 FF 12            u  00 09  2 116      
;   230             jne e14soa                  -- sequence op attempted
                    jne #0043F35F         ;#0043F3F7: 017205 62FFFFFF            v  00 00  1 117      
;   231             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043F3FD: 333054203                  np 00 09  3 118      
;   232             call rsi                    -- eg faddp
                    call rsi              ;#0043F400: 377326                     np 00 40  2 121      
;   233             jmp :%pStoreFlt
                    jmp #004421B0 (:%pStoreFlt)  ;#0043F402: 351 A92D0000               v  00 00  1 123      
;   234 
;   235 --/*
;   236 procedure ::opMathi(::)
;   237 end procedure -- (for Edita/CtrlQ)
;   238 --*/
;   239     [32]
;   240       ::opMathi
;   241 ---------------
;   242         -- as opMath, but result is integer, so this has no dealloc and a builtin type check failure
;   243         --  note that (eg) i=(1.5+1.5) is perfectly valid (so we still need a float math function).
;   244         -- on entry, (exactly the same as above)
;   245         --  edi is addr result
;   246         --  ecx is p2 (opUnassigned)
;   247         --  eax is p3 (opUnassigned)
;   248         --  edx is the integer math function (eg :opAddI)
;   249         --  esi is the floating point math function (eg :opAddF)
;   250         --  [esp] is the return address
;   251         --  
;   252 
;   253         cmp ecx,h4
;   254         jge :opMathiN
;   255             --
;   256             -- ecx [p2] is an int
;   257             --
;   258             cmp eax,h4
;   259             jge :opMathiIN
;   260             call edx                -- eg add ecx,eax
;   261           ::opMathiIII
;   262             mov eax,ecx
;   263 
;   264             shl ecx,1
;   265             jo :e01tcfeaxedi
;   266 
;   267             mov [edi],eax
;   268             ret
;   269 
;   270         ::opMathiIN
;   271             --
;   272             -- ecx/p2 is set, eax/p3 is (must be) a float.
;   273             --
;   274             push ecx
;   275             fild dword[esp]
;   276             add esp,4
;   277             cmp byte[ebx+eax*4-1],0x12
;   278             jne e14soa                  -- sequence op attempted
;   279             fld qword[ebx+eax*4]
;   280             call esi                    -- eg faddp
;   281 
;   282         ::opMathsToNi
;   283             --
;   284             -- result in st0; store as int if possible else typecheck
;   285             --
;   286             sub esp,8
;   287             fld st0                     -- another copy (fist [no-p] cannot store 64-bit ints)
;   288             fistp qword[esp]            -- (immediately discards that copy)
;   289             fild qword[esp]
;   290             fcomp st1
;   291             fnstsw ax
;   292             sahf
;   293 --          jne :e01tcfst0edi
;   294             je @f
;   295                 int3
;   296           @@:
;   297             mov eax,[esp]
;   298             cdq                         -- sign extend eax into edx
;   299             cmp edx,[esp+4]
;   300 --          jne :e01tcfst0edi
;   301             je @f
;   302                 call :%pStoreFlt        -- [edi]:=st0
;   303                 mov al,110              -- e01tce(ecx)
;   304                 mov ecx,edi
;   305                 mov edx,[esp+8]         -- era
;   306                 jmp :!iDiag
;   307                 int3
;   308           @@:
;   309             mov edx,eax
;   310             shl edx,1
;   311 --          jo :e01tcfst0edi
;   312             jno @f
;   313                 int3
;   314           @@:
;   315             fstp st0                    -- discard st0 (31-bit result now in eax)
;   316             mov [edi],eax
;   317             add esp,8
;   318             ret
;   319 
;   320         ::opMathiN
;   321             --
;   322             -- load p2 as float, then consider p3
;   323             --
;   324 -- 22/2/15!
;   325 --          cmp byte[ebx+eax*4-1],0x12
;   326             cmp byte[ebx+ecx*4-1],0x12
;   327             jne e14soa                  -- sequence op attempted
;   328 -- 22/2/15!
;   329 --          fld qword[ebx+eax*4]
;   330             fld qword[ebx+ecx*4]
;   331 
;   332             cmp eax,h4
;   333             jge :opMathiNN
;   334             push eax
;   335             fild dword[esp]
;   336             add esp,4
;   337             call esi                    -- eg faddp
;   338             jmp :opMathsToNi
;   339 
;   340         ::opMathiNN
;   341             --
;   342             -- st0/p2 is loaded, eax/p3 is (must be) a float
;   343             --
;   344             cmp byte[ebx+eax*4-1],0x12
;   345             jne e14soa                  -- sequence op attempted
;   346             fld qword[ebx+eax*4]
;   347             call esi                    -- eg faddp
;   348             jmp :opMathsToNi
;   349 
;   350     [64]
;   351       ::opMathi
;   352 ---------------
;   353         -- as opMath, but result is integer, so this has no dealloc and a builtin type check failure
;   354         --  note that (eg) i=(1.5+1.5) is perfectly valid (so we still need a float math function).
;   355         -- on entry, (exactly the same as above)
;   356         --  rdi is addr result
;   357         --  rcx is p2 (opUnassigned)
;   358         --  rax is p3 (opUnassigned)
;   359         --  rdx is the integer math function (eg :opAddI)
;   360         --  rsi is the floating point math function (eg :opAddF)
;   361         --  [rsp] is the return address
;   362         --  
;   363         mov r15,h4
                mov r15,h4                ;#0043F407: 49:277 0000000000000040    uv 8000 00  1 124      
;   364         cmp rcx,r15
                cmp rcx,r15               ;#0043F411: 49:073317                  uv 00 8002  1 125 8000   
;   365         jge :opMathiN
                jge #0043F46C             ;#0043F414: 175 56                     v  00 00  1 125      
;   366             --
;   367             -- rcx [p2] is an int
;   368             --
;   369             cmp rax,r15
                    cmp rax,r15           ;#0043F416: 49:073307                  uv 00 8001  1 126      
;   370             jge :opMathiIN
                    jge #0043F42D         ;#0043F419: 175 12                     v  00 00  1 126      
;   371             call rdx                -- eg add ecx,eax
                    call rdx              ;#0043F41B: 377322                     np 00 04  2 127      
;   372           ::opMathiIII
;   373             mov rax,rcx
                    mov rax,rcx           ;#0043F41D: 48:213301                  uv 01 02  1 129      
;   374 
;   375             shl rcx,1
                    shl rcx,1             ;#0043F420: 48:321341                  u  02 02  1 130      
;   376             jo :e01tcfeaxedi
                    jo #0043F360          ;#0043F423: 017200 37FFFFFF            v  00 00  1 130      
;   377 
;   378             mov [rdi],rax
                    mov [rdi],rax         ;#0043F429: 48:211007                  uv 00 81  1 131      
;   379             ret
                    ret                   ;#0043F42C: 303                        np 00 00  2 132      
;   380 
;   381         ::opMathiIN
;   382             --
;   383             -- rcx/p2 is int, rax/p3 is (must be) a float.
;   384             --
;   385             push rcx
                    push rcx              ;#0043F42D: 48:121                     uv 00 02  1 134      
;   386             fild qword[rsp]
                    fild qword[rsp]       ;#0043F42F: 337054044                  np 00 10  3 135      
;   387             add rsp,8
                    add rsp,8             ;#0043F432: 48:203304 08               uv 10 10  1 138      
;   388             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043F436: 200174203 FF 12            u  00 09  2 139      
;   389             jne e14soa                  -- sequence op attempted
                    jne #0043F35F         ;#0043F43B: 017205 1EFFFFFF            v  00 00  1 140      
;   390             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043F441: 333054203                  np 00 09  3 141      
;   391             call rsi                    -- eg faddp
                    call rsi              ;#0043F444: 377326                     np 00 40  2 144      
;   392 
;   393         ::opMathsToNi
;   394             --
;   395             -- result in st0; store as int if possible else typecheck
;   396             --
;   397             sub esp,8
                    sub esp,8             ;#0043F446: 203354 08                  uv 10 10  1 146      
;   398             fld st0                     -- another copy (fist [no-p] cannot store 64-bit ints)
                    fld st0               ;#0043F449: 331300                     np 00 00  1 147      
;   399             fistp qword[esp]            -- (immediately discards that copy)
                    fistp qword[rsp]      ;#0043F44B: 337074044                  np 00 10  6 148      
;   400             fild qword[esp]
                    fild qword[rsp]       ;#0043F44E: 337054044                  np 00 10  3 154      
;   401             fcomp st1
                    fcomp                 ;#0043F451: 330331                     np 00 00  1 157      
;   402             fnstsw ax
                    fnstsw ax             ;#0043F453: 337340                     np 01 00  6 158      
;   403             sahf
                    sahf                  ;#0043F455: 236                        np 00 01  2 164      
;   404 --          jne :e01tcfst0edi
;   405             je @f
                    je #0043F459          ;#0043F456: 164 01                     v  00 00  1 166      
;   406                 int3
                        int3              ;#0043F458: 314                        np 00 00 13 167      
;   407           @@:
;   408 --          mov eax,[esp]
;   409 --          cdq                         -- sign extend eax into edx
;   410 ---- (cqo on 64-bit)
;   411 --          cmp edx,[esp+4]
;   412 --          jne :e01tcfst0edi
;   413             mov rdx,rax
                    mov rdx,rax           ;#0043F459: 48:213320                  uv 04 01  1 180      
;   414             shl rdx,1
                    shl rdx,1             ;#0043F45C: 48:321342                  u  04 04  1 181      
;   415 --          jo :e01tcfst0edi
;   416             jno @f
                    jno #0043F462         ;#0043F45F: 161 01                     v  00 00  1 181      
;   417                 int3
                        int3              ;#0043F461: 314                        np 00 00 13 182      
;   418           @@:
;   419             fstp st0                    -- discard st0 (31-bit result now in eax)
                    fstp st0              ;#0043F462: 335330                     np 00 00  1 195      
;   420             mov [rdi],rax
                    mov [rdi],rax         ;#0043F464: 48:211007                  uv 00 81  1 196      
;   421             add rsp,8
                    add rsp,8             ;#0043F467: 48:203304 08               vu 10 10  1 196      
;   422             ret
                    ret                   ;#0043F46B: 303                        np 00 00  2 197      
;   423 
;   424         ::opMathiN
;   425             --
;   426             -- load rcx/p2 as float, then consider rax/p3
;   427             --
;   428             cmp byte[rbx+rcx*4-1],0x12
                    cmp byte[rbx+rcx*4-1],#12  ;#0043F46C: 200174213 FF 12            u  00 0A  2 199      
;   429             jne e14soa                  -- sequence op attempted
                    jne #0043F35F         ;#0043F471: 017205 E8FEFFFF            v  00 00  1 200      
;   430             fld tbyte[rbx+rcx*4]
                    fld tbyte[rbx+rcx*4]  ;#0043F477: 333054213                  np 00 0A  3 201      
;   431 
;   432             mov r15,h4
                    mov r15,h4            ;#0043F47A: 49:277 0000000000000040    uv 8000 00  1 204      
;   433             cmp rax,r15
                    cmp rax,r15           ;#0043F484: 49:073307                  uv 00 8001  1 205 8000   
;   434             jge :opMathiNN
                    jge #0043F496         ;#0043F487: 175 0D                     v  00 00  1 205      
;   435             push rax
                    push rax              ;#0043F489: 48:120                     uv 00 01  1 206      
;   436             fild dword[rsp]
                    fild dword[rsp]       ;#0043F48B: 333004044                  np 00 10  3 207      
;   437             add rsp,8
                    add rsp,8             ;#0043F48E: 48:203304 08               uv 10 10  1 210      
;   438             call rsi                    -- eg faddp
                    call rsi              ;#0043F492: 377326                     np 00 40  2 211      
;   439             jmp :opMathsToNi
                    jmp #0043F446         ;#0043F494: 353 B0                     v  00 00  1 213      
;   440 
;   441         ::opMathiNN
;   442             --
;   443             -- st0/p2 is loaded, rax/p3 is (must be) a float
;   444             --
;   445             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043F496: 200174203 FF 12            u  00 09  2 214      
;   446             jne e14soa                  -- sequence op attempted
                    jne #0043F35F         ;#0043F49B: 017205 BEFEFFFF            v  00 00  1 215      
;   447             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043F4A1: 333054203                  np 00 09  3 216      
;   448             call rsi                    -- eg faddp
                    call rsi              ;#0043F4A4: 377326                     np 00 40  2 219      
;   449             jmp :opMathsToNi
                    jmp #0043F446         ;#0043F4A6: 353 9E                     v  00 00  1 221      
;   450     []
;   451 
;   452 --/*
;   453 procedure :%opAdd(:%)
;   454 end procedure -- (for Edita/CtrlQ)
;   455 --*/
;   456       ::opAddI
;   457     [32]
;   458         add ecx,eax
;   459     [64]
;   460         add rcx,rax
                add rcx,rax               ;#0043F4A8: 48:001301                  uv 02 03  1 222      
;   461     []
;   462         ret
                ret                       ;#0043F4AB: 303                        np 00 00  2 223      
;   463       ::opAddF
;   464         faddp
                faddp st1,st0             ;#0043F4AC: 336301                     np 00 00  3 225      
;   465         ret
                ret                       ;#0043F4AE: 303                        np 00 00  2 228      
;   466         
;   467       :%opAdd               -- [edi]:=ecx+eax
;   468 -------------
;   469 --  [32]
;   470         mov edx,:opAddI
                mov edx,#0043F4A8         ;#0043F4AF: 272 A8F44300               uv 04 00  1 230      
;   471         mov esi,:opAddF
                mov esi,#0043F4AC         ;#0043F4B4: 276 ACF44300               vu 40 00  1 230      
;   472 --  [64]
;   473 --      mov rdx,:opAddI
;   474 --      mov rsi,:opAddF
;   475 --  []
;   476         jmp :opMath
                jmp #0043F375             ;#0043F4B9: 351 B7FEFFFF               v  00 00  1 231      
;   477 
;   478       :%opAddi              -- [edi]:=ecx+eax, no dealloc, builtin typecheck
;   479 --------------
;   480     [32]
;   481         mov edx,:opAddI
;   482         mov esi,:opAddF
;   483     [64]
;   484         mov rdx,:opAddI
                mov rdx,#0043F4A8         ;#0043F4BE: 48:307302 A8F44300         uv 04 00  1 232      
;   485         mov rsi,:opAddF
                mov rsi,#0043F4AC         ;#0043F4C5: 48:307306 ACF44300         vu 40 00  1 232      
;   486     []
;   487         jmp :opMathi
                jmp #0043F407             ;#0043F4CC: 351 36FFFFFF               v  00 00  1 233      
;   488 
;   489 --/*
;   490 procedure :%opSub(:%)
;   491 end procedure -- (for Edita/CtrlQ)
;   492 --*/
;   493       ::opSubI
;   494     [32]
;   495         sub ecx,eax
;   496     [64]
;   497         sub rcx,rax
                sub rcx,rax               ;#0043F4D1: 48:051301                  uv 02 03  1 234      
;   498     []
;   499         ret
                ret                       ;#0043F4D4: 303                        np 00 00  2 235      
;   500       ::opSubF
;   501         fsubp
                fsubp st1,st0             ;#0043F4D5: 336351                     np 00 00  3 237      
;   502         ret
                ret                       ;#0043F4D7: 303                        np 00 00  2 240      
;   503         
;   504       :%opSub               -- [edi]:=ecx-eax
;   505 -------------
;   506     [32]
;   507         mov edx,:opSubI
;   508         mov esi,:opSubF
;   509     [64]
;   510         mov rdx,:opSubI
                mov rdx,#0043F4D1         ;#0043F4D8: 48:307302 D1F44300         uv 04 00  1 242      
;   511         mov rsi,:opSubF
                mov rsi,#0043F4D5         ;#0043F4DF: 48:307306 D5F44300         vu 40 00  1 242      
;   512     []
;   513         jmp :opMath
                jmp #0043F375             ;#0043F4E6: 351 8AFEFFFF               v  00 00  1 243      
;   514 
;   515       :%opSubi              -- [edi]:=ecx-eax, no dealloc, builtin typecheck
;   516 --------------
;   517     [32]
;   518         mov edx,:opSubI
;   519         mov esi,:opSubF
;   520     [64]
;   521         mov rdx,:opSubI
                mov rdx,#0043F4D1         ;#0043F4EB: 48:307302 D1F44300         uv 04 00  1 244      
;   522         mov rsi,:opSubF
                mov rsi,#0043F4D5         ;#0043F4F2: 48:307306 D5F44300         vu 40 00  1 244      
;   523     []
;   524         jmp :opMathi
                jmp #0043F407             ;#0043F4F9: 351 09FFFFFF               v  00 00  1 245      
;   525 
;   526 --/*
;   527 procedure :%opDiv(:%)
;   528 end procedure -- (for Edita/CtrlQ)
;   529 --*/
;   530       ::opDivI
;   531     [32]
;   532         mov esi,ecx             -- save before we trash it...
;   533         xchg eax,ecx
;   534         add esp,4               -- trash return address (opMathIII)
;   535         test ecx,ecx
;   536         jz :e02atdb0            -- attempt to divide by 0
;   537         cdq
;   538         idiv ecx
;   539 --      mov ecx,eax
;   540         test edx,edx            -- check remainder is zero
;   541 --      jz opMathIII
;   542         jnz @f
;   543             mov ecx,eax
;   544             jmp opMathIII
;   545       @@:
;   546         --
;   547         -- two integer params but non-integer result
;   548         --
;   549         push esi
;   550         fild dword[esp]
;   551 --      add esp,4
;   552 --    opDivNI:
;   553         -- p2 in st1, p3 is integer:
;   554 --      push ecx
;   555         mov [esp],ecx
;   556 --      test ecx,ecx
;   557 --      jz :e02atdb0
;   558         fild dword[esp]
;   559         add esp,4
;   560     [64]
;   561         mov rsi,rcx             -- save before we trash it...
                mov rsi,rcx               ;#0043F4FE: 48:213361                  uv 40 02  1 246      
;   562         xchg rax,rcx
                xchg rax,rcx              ;#0043F501: 48:221                     np 03 03  2 247      
;   563         add rsp,8               -- trash return address (opMathIII)
                add rsp,8                 ;#0043F503: 48:203304 08               uv 10 10  1 249      
;   564         test rcx,rcx
                test rcx,rcx              ;#0043F507: 48:205311                  vu 00 02  1 249      
;   565         jz :e02atdb0            -- attempt to divide by 0
                jz #0043F365              ;#0043F50A: 017204 55FEFFFF            v  00 00  1 250      
;   566         cqo
                cqo                       ;#0043F510: 48:231                     np 04 01  2 251      
;   567         idiv rcx
                idiv rcx                  ;#0043F512: 48:367371                  np 05 07 46 253      
;   568         test rdx,rdx            -- check remainder is zero
                test rdx,rdx              ;#0043F515: 48:205322                  uv 00 04  1 299      
;   569 --      jz opMathIII
;   570         jnz @f
                jnz #0043F522             ;#0043F518: 165 08                     v  00 00  1 299      
;   571             mov rcx,rax
                    mov rcx,rax           ;#0043F51A: 48:213310                  uv 02 01  1 300      
;   572             jmp opMathIII
                    jmp #0043F3A5         ;#0043F51D: 351 83FEFFFF               v  00 00  1 300      
;   573       @@:
;   574         --
;   575         -- two integer params but non-integer result
;   576         --
;   577         push rsi
                push rsi                  ;#0043F522: 48:126                     uv 00 40  1 301      
;   578         fild qword[rsp]
                fild qword[rsp]           ;#0043F524: 337054044                  np 00 10  3 302      
;   579         mov [rsp],rcx
                mov [rsp],rcx             ;#0043F527: 48:211014044               uv 00 12  1 305      
;   580         fild qword[rsp]
                fild qword[rsp]           ;#0043F52B: 337054044                  np 00 10  3 306      
;   581 --      add rsp,4
;   582         add rsp,8
                add rsp,8                 ;#0043F52E: 48:203304 08               uv 10 10  1 309      
;   583     []
;   584         fdivp
                fdivp st1,st0             ;#0043F532: 336371                     np 00 00 39 310      
;   585         jmp :%pStoreFlt
                jmp #004421B0 (:%pStoreFlt)  ;#0043F534: 351 772C0000               v  00 00  1 349      
;   586 
;   587       ::opDiviI
;   588     [32]
;   589         mov esi,ecx             -- save before we trash it...
;   590         xchg eax,ecx
;   591         add esp,4               -- trash return address (opMathIII)
;   592         test ecx,ecx
;   593         jz :e02atdb0            -- attempt to divide by 0
;   594         cdq
;   595         idiv ecx
;   596         mov ecx,eax
;   597         test edx,edx            -- check remainder is zero
;   598         jz opMathiIII
;   599         jmp :e01tcfeaxplusedxoverecxedi     -- [DEV or do it here...]
;   600 --      --
;   601 --      -- two integer params but non-integer result
;   602 --      --
;   603 --      push esi
;   604 --      fild dword[esp]
;   605 --      add esp,4
;   606 ----      opDivNI:
;   607 --      -- p2 in st1, p3 is integer:
;   608 --      push ecx
;   609 ----        test ecx,ecx
;   610 ----        jz :e02atdb0
;   611 --      fild dword[esp]
;   612 --      add esp,4
;   613 --      fdivp
;   614 --      jmp :%pStoreFlt
;   615     [64]
;   616         mov rsi,rcx             -- save before we trash it...
                mov rsi,rcx               ;#0043F539: 48:213361                  uv 40 02  1 350      
;   617         xchg rax,rcx
                xchg rax,rcx              ;#0043F53C: 48:221                     np 03 03  2 351      
;   618         add rsp,8               -- trash return address (opMathIII)
                add rsp,8                 ;#0043F53E: 48:203304 08               uv 10 10  1 353      
;   619         test rcx,rcx
                test rcx,rcx              ;#0043F542: 48:205311                  vu 00 02  1 353      
;   620         jz :e02atdb0            -- attempt to divide by 0
                jz #0043F365              ;#0043F545: 017204 1AFEFFFF            v  00 00  1 354      
;   621         cqo
                cqo                       ;#0043F54B: 48:231                     np 04 01  2 355      
;   622         idiv rcx
                idiv rcx                  ;#0043F54D: 48:367371                  np 05 07 46 357      
;   623         mov rcx,rax
                mov rcx,rax               ;#0043F550: 48:213310                  uv 02 01  1 403      
;   624         test rdx,rdx            -- check remainder is zero
                test rdx,rdx              ;#0043F553: 48:205322                  vu 00 04  1 403      
;   625         jz opMathiIII
                jz #0043F41D              ;#0043F556: 017204 C1FEFFFF            v  00 00  1 404      
;   626         jmp :e01tcfeaxplusedxoverecxedi     -- [DEV or do it here...]
                jmp #0043F373             ;#0043F55C: 351 12FEFFFF               v  00 00  1 405      
;   627     []
;   628 
;   629       ::opDivF
;   630         fdivp
                fdivp st1,st0             ;#0043F561: 336371                     np 00 00 39 406      
;   631         ret
                ret                       ;#0043F563: 303                        np 00 00  2 445      
;   632 
;   633       :%opDiv               -- [edi]:=ecx/eax
;   634 -------------
;   635     [32]
;   636         mov edx,:opDivI
;   637         mov esi,:opDivF
;   638     [64]
;   639         mov rdx,:opDivI
                mov rdx,#0043F4FE         ;#0043F564: 48:307302 FEF44300         uv 04 00  1 447      
;   640         mov rsi,:opDivF
                mov rsi,#0043F561         ;#0043F56B: 48:307306 61F54300         vu 40 00  1 447      
;   641     []
;   642         jmp :opMath
                jmp #0043F375             ;#0043F572: 351 FEFDFFFF               v  00 00  1 448      
;   643 
;   644       :%opDivi              -- [edi]:=ecx/eax, no dealloc, builtin typecheck
;   645 --------------
;   646     [32]
;   647         mov edx,:opDiviI
;   648         mov esi,:opDivF
;   649     [64]
;   650         mov rdx,:opDiviI
                mov rdx,#0043F539         ;#0043F577: 48:307302 39F54300         uv 04 00  1 449      
;   651         mov rsi,:opDivF
                mov rsi,#0043F561         ;#0043F57E: 48:307306 61F54300         vu 40 00  1 449      
;   652     []
;   653         jmp :opMathi
                jmp #0043F407             ;#0043F585: 351 7DFEFFFF               v  00 00  1 450      
;   654 
;   655 --/*
;   656 procedure :%opDivf(:%)
;   657 end procedure -- (for Edita/CtrlQ)
;   658 --*/
;   659 
;   660       ::opDivfI
;   661 ---------------
;   662     [32]
;   663         mov esi,ecx                     -- save
;   664         xchg eax,ecx
;   665         test eax,eax
;   666         js @f
;   667             test ecx,ecx
;   668 --          jns :opDivfSubecxm1
;   669             js :opDivfSubecxm1
;   670       ::opDivfNormal
;   671                 mov eax,esi             -- (nop except when from opDivfSubecxm1)
;   672                 test ecx,ecx
;   673                 jz :e02atdb0pop
;   674                 cdq
;   675                 idiv ecx
;   676                 mov ecx,eax
;   677                 ret
;   678       @@:
;   679         test ecx,ecx
;   680 --      jns :opDivfNormal           -- do nowt then
;   681         js :opDivfNormal            -- do nowt then
;   682       ::opDivfSubecxm1
;   683         --
;   684         -- one but not both is signed.
;   685         -- floor(-a/b) is done as -floor((a-(b-1))/b),
;   686         -- eg/ie floor(-3/2) is -2, not -1.
;   687         --
;   688 --      add eax,1
;   689 --      sub eax,ecx
;   690         lea esi,[eax+1]
;   691         sub esi,ecx
;   692         jno opDivfNormal
;   693         --
;   694         -- oops, load both short ints to FPU:
;   695         --
;   696         mov [esp],eax           -- (trashes the return to opMathIII)
;   697         fild dword[esp]
;   698         mov [esp],ecx
;   699         fild dword[esp]
;   700         add esp,4               -- (discard fild/ex-opMathIII)
;   701         fdivp
;   702         jmp :%pStoreFlt
;   703     [64]
;   704         mov rsi,rcx                     -- save
                mov rsi,rcx               ;#0043F58A: 48:213361                  uv 40 02  1 451      
;   705         xchg rax,rcx
                xchg rax,rcx              ;#0043F58D: 48:221                     np 03 03  2 452      
;   706         test rax,rax
                test rax,rax              ;#0043F58F: 48:205300                  uv 00 01  1 454      
;   707         js @f
                js #0043F5AE              ;#0043F592: 170 1A                     v  00 00  1 454      
;   708             test rcx,rcx
                    test rcx,rcx          ;#0043F594: 48:205311                  uv 00 02  1 455      
;   709 --          jns :opDivfSubecxm1
;   710             js :opDivfSubecxm1
                    js #0043F5B3          ;#0043F597: 170 1A                     v  00 00  1 455      
;   711       ::opDivfNormal
;   712                 mov rax,rsi             -- (nop except when from opDivfSubecxm1)
                        mov rax,rsi       ;#0043F599: 48:213306                  uv 01 40  1 456      
;   713                 test rcx,rcx
                        test rcx,rcx      ;#0043F59C: 48:205311                  vu 00 02  1 456      
;   714                 jz :e02atdb0pop
                        jz #0043F361      ;#0043F59F: 017204 BCFDFFFF            v  00 00  1 457      
;   715                 cqo
                        cqo               ;#0043F5A5: 48:231                     np 04 01  2 458      
;   716                 idiv rcx
                        idiv rcx          ;#0043F5A7: 48:367371                  np 05 07 46 460      
;   717                 mov rcx,rax
                        mov rcx,rax       ;#0043F5AA: 48:213310                  uv 02 01  1 506      
;   718                 ret
                        ret               ;#0043F5AD: 303                        np 00 00  2 507      
;   719       @@:
;   720         test rcx,rcx
                test rcx,rcx              ;#0043F5AE: 48:205311                  uv 00 02  1 509      
;   721 --      jns :opDivfNormal           -- do nowt then
;   722         js :opDivfNormal            -- do nowt then
                js #0043F599              ;#0043F5B1: 170 E6                     v  00 00  1 509      
;   723       ::opDivfSubecxm1
;   724         --
;   725         -- one but not both is signed.
;   726         -- floor(-a/b) is done as -floor((a-(b-1))/b),
;   727         -- eg/ie floor(-3/2) is -2, not -1.
;   728         --
;   729 --      add rax,1
;   730 --      sub rax,rcx
;   731         lea rsi,[rax+1]
                lea rsi,[rax+1]           ;#0043F5B3: 48:215160 01               uv 40 01  1 510      
;   732         sub rsi,rcx
                sub rsi,rcx               ;#0043F5B7: 48:051316                  uv 40 42  1 511 40   
;   733         jno opDivfNormal
                jno #0043F599             ;#0043F5BA: 161 DD                     v  00 00  1 511      
;   734         --
;   735         -- oops, load both short ints to FPU:
;   736         --
;   737         mov [rsp],rax           -- (trashes the return to opMathIII)
                mov [rsp],rax             ;#0043F5BC: 48:211004044               uv 00 11  1 512      
;   738         fild qword[rsp]
                fild qword[rsp]           ;#0043F5C0: 337054044                  np 00 10  3 513      
;   739         mov [rsp],rcx
                mov [rsp],rcx             ;#0043F5C3: 48:211014044               uv 00 12  1 516      
;   740         fild qword[rsp]
                fild qword[rsp]           ;#0043F5C7: 337054044                  np 00 10  3 517      
;   741         add rsp,8               -- (discard fild/ex-opMathIII)
                add rsp,8                 ;#0043F5CA: 48:203304 08               uv 10 10  1 520      
;   742         fdivp
                fdivp st1,st0             ;#0043F5CE: 336371                     np 00 00 39 521      
;   743         jmp :%pStoreFlt
                jmp #004421B0 (:%pStoreFlt)  ;#0043F5D0: 351 DB2B0000               v  00 00  1 560      
;   744     []
;   745 
;   746       ::opDivfF
;   747     [32]
;   748         fdivp
;   749         call :%down53
;   750         frndint
;   751         call :%near53
;   752     [64]
;   753         fdivp
                fdivp st1,st0             ;#0043F5D5: 336371                     np 00 00 39 561      
;   754         call :%down64
                call #0044139E (:%down64)  ;#0043F5D7: 350 C21D0000               v  00 00  1 600      
;   755         frndint
                frndint                   ;#0043F5DC: 331374                     np 00 00 20 601      
;   756         call :%near64
                call #004413A5 (:%near64)  ;#0043F5DE: 350 C21D0000               v  00 00  1 621      
;   757     []
;   758         ret
                ret                       ;#0043F5E3: 303                        np 00 00  2 622      
;   759 
;   760       :%opDivf              -- [edi]:=floor(ecx/eax) result may be integer, or atom (as floor(1e308/10) is 1e307)
;   761 --------------
;   762     [32]
;   763         mov edx,:opDivfI
;   764         mov esi,:opDivfF
;   765     [64]
;   766         mov rdx,:opDivfI
                mov rdx,#0043F58A         ;#0043F5E4: 48:307302 8AF54300         uv 04 00  1 624      
;   767         mov rsi,:opDivfF
                mov rsi,#0043F5D5         ;#0043F5EB: 48:307306 D5F54300         vu 40 00  1 624      
;   768     []
;   769         jmp :opMath
                jmp #0043F375             ;#0043F5F2: 351 7EFDFFFF               v  00 00  1 625      
;   770 
;   771       :%opDiv2              -- [edi]:=eax/2    -- eax is init int, result may be int or atom
;   772 --------------
;   773     [32]
;   774 --DEV we may want an add esp,4 here??? (discard return addr) [ADDED]
;   775 --      add esp,4           -- discard return addr (opMathIII) NO!!
;   776         mov edx,[edi]       -- target ref (old)
;   777         sar eax,1           -- /2
;   778         jc :opDiv2flt
;   779         mov [edi],eax
;   780         cmp edx,h4
;   781         jle @f
;   782             sub dword[ebx+edx*4-8],1
;   783             jz :%pDealloc
;   784       @@:
;   785         ret
;   786 
;   787       ::opDiv2flt
;   788         -- eax is result but missing a 0.5:
;   789         mov ecx,[half]
;   790         push eax
;   791         fild dword[esp]
;   792 --DEV testme: -3/2 probably needs fsub... (suggested code completely untested)
;   793 --      test eax,eax
;   794 --      js :opDiv2fsub
;   795 --      fadd qword[ebx+ecx*4]
;   796         fld qword[ebx+ecx*4]
;   797         add esp,4
;   798         faddp
;   799         jmp :%pStoreFlt
;   800 --    ::opDiv2fsub
;   801 --      fsub qword[ebx+ecx*4]
;   802 --      jmp :%pStoreFlt
;   803     [64]
;   804 --      add esp,8           -- discard return addr (opMathIII) NO!!
;   805         mov rdx,[rdi]       -- target ref (old)
                mov rdx,[rdi]             ;#0043F5F7: 48:213027                  uv 04 80  1 626      
;   806         sar rax,1           -- /2
                sar rax,1                 ;#0043F5FA: 48:321370                  u  01 01  1 627      
;   807         jc :opDiv2flt
                jc #0043F61E              ;#0043F5FD: 162 1F                     v  00 00  1 627      
;   808         mov [rdi],rax
                mov [rdi],rax             ;#0043F5FF: 48:211007                  uv 00 81  1 628      
;   809         mov r15,h4
                mov r15,h4                ;#0043F602: 49:277 0000000000000040    vu 8000 00  1 628      
;   810         cmp rdx,r15
                cmp rdx,r15               ;#0043F60C: 49:073327                  uv 00 8004  1 629      
;   811         jle @f
                jle #0043F61D             ;#0043F60F: 176 0C                     v  00 00  1 629      
;   812             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043F611: 48:203154223 F0 01         u  00 0C  3 630      
;   813             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043F617: 017204 BD2C0000            v  00 00  1 632      
;   814       @@:
;   815         ret
                ret                       ;#0043F61D: 303                        np 00 00  2 633      
;   816 
;   817       ::opDiv2flt
;   818         -- rax is result but missing a 0.5:
;   819         mov rcx,[half]
                mov rcx,[#00402F88] (half)  ;#0043F61E: 48:213015 6339FCFF         uv 02 00  1 635      
;   820         push rax
                push rax                  ;#0043F625: 48:120                     vu 00 01  1 635      
;   821         fild qword[rsp]
                fild qword[rsp]           ;#0043F627: 337054044                  np 00 10  3 636      
;   822 --DEV testme: -3/2 probably needs fsub... (suggested code completely untested)
;   823 --      test rax,rax
;   824 --      js :opDiv2fsub
;   825 --      fadd tbyte[rbx+rcx*4]
;   826         fld tbyte[rbx+rcx*4]
                fld tbyte[rbx+rcx*4]      ;#0043F62A: 333054213                  np 00 0A  3 639      
;   827         add rsp,8
                add rsp,8                 ;#0043F62D: 48:203304 08               uv 10 10  1 642      
;   828         faddp
                faddp st1,st0             ;#0043F631: 336301                     np 00 00  3 643      
;   829         jmp :%pStoreFlt
                jmp #004421B0 (:%pStoreFlt)  ;#0043F633: 351 782B0000               v  00 00  1 646      
;   830 --    ::opDiv2fsub
;   831 --      fsub tbyte[rbx+rcx*4]   (unsupported, fixme)
;   832 --      fld tbyte[rbx+rcx*4]
;   833 --      fsubp
;   834 --      jmp :%pStoreFlt
;   835     []
;   836 
;   837 --/*
;   838 procedure :%opMul(:%)
;   839 end procedure -- (for Edita/CtrlQ)
;   840 --*/
;   841 
;   842       ::opMulI
;   843     [32]
;   844         push eax
;   845         imul ecx
;   846         mov esi,edx
;   847         cdq
;   848         cmp esi,edx         -- check for 32-bit result
;   849         je @f
;   850             fild dword[esp]
;   851             mov [esp],ecx
;   852             fild dword[esp]
;   853             add esp,8       -- (also discard return to opMathIII)
;   854             fmulp
;   855             jmp :%pStoreFlt
;   856       @@:
;   857         add esp,4       -- discard the eax we saved, return to opMathIII
;   858         mov ecx,eax
;   859     [64]
;   860         push rax
                push rax                  ;#0043F638: 48:120                     uv 00 01  1 647      
;   861         imul rcx
                imul rcx                  ;#0043F63A: 48:367351                  np 05 03 10 648      
;   862         mov rsi,rdx
                mov rsi,rdx               ;#0043F63D: 48:213362                  uv 40 04  1 658      
;   863         cqo
                cqo                       ;#0043F640: 48:231                     np 04 01  2 659      
;   864         cmp rsi,rdx         -- check for 32-bit result
                cmp rsi,rdx               ;#0043F642: 48:071326                  uv 00 44  1 661      
;   865         je @f
                je #0043F65C              ;#0043F645: 164 15                     v  00 00  1 661      
;   866             fild qword[rsp]
                    fild qword[rsp]       ;#0043F647: 337054044                  np 00 10  3 662      
;   867             mov [rsp],rcx
                    mov [rsp],rcx         ;#0043F64A: 48:211014044               uv 00 12  1 665      
;   868             fild qword[rsp]
                    fild qword[rsp]       ;#0043F64E: 337054044                  np 00 10  3 666      
;   869             add rsp,16      -- (also discard return to opMathIII)
                    add rsp,16            ;#0043F651: 48:203304 10               uv 10 10  1 669      
;   870             fmulp
                    fmulp st1,st0         ;#0043F655: 336311                     np 00 00  3 670      
;   871             jmp :%pStoreFlt
                    jmp #004421B0 (:%pStoreFlt)  ;#0043F657: 351 542B0000               v  00 00  1 673      
;   872       @@:
;   873         add rsp,8       -- discard the rax we saved, return to opMathIII
                add rsp,8                 ;#0043F65C: 48:203304 08               uv 10 10  1 674      
;   874         mov rcx,rax
                mov rcx,rax               ;#0043F660: 48:213310                  vu 02 01  1 674      
;   875     []
;   876         ret
                ret                       ;#0043F663: 303                        np 00 00  2 675      
;   877 
;   878       ::opMuliI
;   879     [32]
;   880         imul ecx
;   881         mov ecx,edx
;   882         cdq
;   883         cmp ecx,edx
;   884         mov ecx,eax
;   885     [64]
;   886         imul rcx
                imul rcx                  ;#0043F664: 48:367351                  np 05 03 10 677      
;   887         mov rcx,rdx
                mov rcx,rdx               ;#0043F667: 48:213312                  uv 02 04  1 687      
;   888         cqo
                cqo                       ;#0043F66A: 48:231                     np 04 01  2 688      
;   889         cmp rcx,rdx
                cmp rcx,rdx               ;#0043F66C: 48:071321                  uv 00 06  1 690      
;   890         mov rcx,rax
                mov rcx,rax               ;#0043F66F: 48:213310                  vu 02 01  1 690      
;   891     []
;   892         jne e01tcfediMul
                jne #0043F374             ;#0043F672: 017205 FCFCFFFF            v  00 00  1 691      
;   893         ret
                ret                       ;#0043F678: 303                        np 00 00  2 692      
;   894 
;   895       ::opMulF
;   896         fmulp
                fmulp st1,st0             ;#0043F679: 336311                     np 00 00  3 694      
;   897         ret
                ret                       ;#0043F67B: 303                        np 00 00  2 697      
;   898 
;   899       :%opMul                   -- [edi]:=ecx*eax
;   900 -------------
;   901     [32]
;   902         mov edx,:opMulI
;   903         mov esi,:opMulF
;   904     [64]
;   905         mov rdx,:opMulI
                mov rdx,#0043F638         ;#0043F67C: 48:307302 38F64300         uv 04 00  1 699      
;   906         mov rsi,:opMulF
                mov rsi,#0043F679         ;#0043F683: 48:307306 79F64300         vu 40 00  1 699      
;   907     []
;   908         jmp :opMath
                jmp #0043F375             ;#0043F68A: 351 E6FCFFFF               v  00 00  1 700      
;   909 
;   910       :%opMuli                  -- [edi]:=ecx*eax, no dealloc, builtin typecheck
;   911 --------------
;   912     [32]
;   913         mov edx,:opMuliI
;   914         mov esi,:opMulF
;   915     [64]
;   916         mov rdx,:opMuliI
                mov rdx,#0043F664         ;#0043F68F: 48:307302 64F64300         uv 04 00  1 701      
;   917         mov rsi,:opMulF
                mov rsi,#0043F679         ;#0043F696: 48:307306 79F64300         vu 40 00  1 701      
;   918     []
;   919         jmp :opMathi
                jmp #0043F407             ;#0043F69D: 351 65FDFFFF               v  00 00  1 702      
;   920 
;   921 --/*
;   922 procedure :%opAndBits(:%)
;   923 end procedure -- (for Edita/CtrlQ)
;   924 --*/
;   925       ::opAndBitsI
;   926     [32]
;   927         and ecx,eax
;   928     [64]
;   929         and rcx,rax
                and rcx,rax               ;#0043F6A2: 48:041301                  uv 02 03  1 703      
;   930     []
;   931         ret
                ret                       ;#0043F6A5: 303                        np 00 00  2 704      
;   932 
;   933       ::opAndBitsF
;   934     [32]
;   935         sub esp,8
;   936         fistp qword[esp]
;   937         mov ecx,[esp]
;   938         fistp qword[esp]
;   939         and ecx,[esp]
;   940         add esp,12
;   941         jmp :opMathIII
;   942     [64]
;   943         sub rsp,8
                sub rsp,8                 ;#0043F6A6: 48:203354 08               uv 10 10  1 706      
;   944         fistp qword[rsp]
                fistp qword[rsp]          ;#0043F6AA: 337074044                  np 00 10  6 709    *10*
;   945         mov rcx,[rsp]
                mov rcx,[rsp]             ;#0043F6AD: 48:213014044               uv 02 10  1 715      
;   946         fistp qword[rsp]
                fistp qword[rsp]          ;#0043F6B1: 337074044                  np 00 10  6 716      
;   947         and rcx,[rsp]
                and rcx,[rsp]             ;#0043F6B4: 48:043014044               uv 02 12  2 722      
;   948         add rsp,16
                add rsp,16                ;#0043F6B8: 48:203304 10               vu 10 10  1 723      
;   949         jmp :opMathIII
                jmp #0043F3A5             ;#0043F6BC: 351 E4FCFFFF               v  00 00  1 724      
;   950     []
;   951         
;   952       :%opAndBits       -- [edi]:=and_bits(ecx,eax) [inlined if ecx and eax are known to be integers]
;   953 -----------------
;   954     [32]
;   955         mov edx,:opAndBitsI
;   956         mov esi,:opAndBitsF
;   957     [64]
;   958         mov rdx,:opAndBitsI
                mov rdx,#0043F6A2         ;#0043F6C1: 48:307302 A2F64300         uv 04 00  1 725      
;   959         mov rsi,:opAndBitsF
                mov rsi,#0043F6A6         ;#0043F6C8: 48:307306 A6F64300         vu 40 00  1 725      
;   960     []
;   961         jmp :opMath
                jmp #0043F375             ;#0043F6CF: 351 A1FCFFFF               v  00 00  1 726      
;   962 
;   963 --/* (DEV/SUG)
;   964       :%opAndBitsi              -- [edi]:=ecx+eax, no dealloc, builtin typecheck
;   965 --------------
;   966     [32]
;   967         mov edx,:opAndBitsI
;   968         mov esi,:opAndBitsiF
;   969     [64]
;   970         mov rdx,:opAndBitsI
;   971         mov rsi,:opAndBitsiF
;   972     []
;   973         jmp :opMathi
;   974 --*/
;   975 
;   976 --/*
;   977 procedure :%opOrBits(:%)
;   978 end procedure -- (for Edita/CtrlQ)
;   979 --*/
;   980       ::opOrBitsI
;   981     [32]
;   982         or ecx,eax
;   983     [64]
;   984         or rcx,rax
                or rcx,rax                ;#0043F6D4: 48:011301                  uv 02 03  1 727      
;   985     []
;   986         ret
                ret                       ;#0043F6D7: 303                        np 00 00  2 728      
;   987 
;   988       ::opOrBitsF
;   989     [32]
;   990         sub esp,8
;   991         fistp qword[esp]
;   992         mov ecx,[esp]
;   993         fistp qword[esp]
;   994         or ecx,[esp]
;   995         add esp,12
;   996         jmp :opMathIII
;   997     [64]
;   998         sub rsp,8
                sub rsp,8                 ;#0043F6D8: 48:203354 08               uv 10 10  1 730      
;   999         fistp qword[rsp]
                fistp qword[rsp]          ;#0043F6DC: 337074044                  np 00 10  6 733    *10*
;  1000         mov rcx,[rsp]
                mov rcx,[rsp]             ;#0043F6DF: 48:213014044               uv 02 10  1 739      
;  1001         fistp qword[rsp]
                fistp qword[rsp]          ;#0043F6E3: 337074044                  np 00 10  6 740      
;  1002         or rcx,[rsp]
                or rcx,[rsp]              ;#0043F6E6: 48:013014044               uv 02 12  2 746      
;  1003         add rsp,16
                add rsp,16                ;#0043F6EA: 48:203304 10               vu 10 10  1 747      
;  1004         jmp :opMathIII
                jmp #0043F3A5             ;#0043F6EE: 351 B2FCFFFF               v  00 00  1 748      
;  1005     []
;  1006         
;  1007       :%opOrBits        -- [edi]:=or_bits(ecx,eax) [inlined if ecx and eax are known to be integers]
;  1008 -----------------
;  1009     [32]
;  1010         mov edx,:opOrBitsI
;  1011         mov esi,:opOrBitsF
;  1012     [64]
;  1013         mov rdx,:opOrBitsI
                mov rdx,#0043F6D4         ;#0043F6F3: 48:307302 D4F64300         uv 04 00  1 749      
;  1014         mov rsi,:opOrBitsF
                mov rsi,#0043F6D8         ;#0043F6FA: 48:307306 D8F64300         vu 40 00  1 749      
;  1015     []
;  1016         jmp :opMath
                jmp #0043F375             ;#0043F701: 351 6FFCFFFF               v  00 00  1 750      
;  1017 
;  1018 --/*
;  1019 procedure :%opXorBits(:%)
;  1020 end procedure -- (for Edita/CtrlQ)
;  1021 --*/
;  1022       ::opXorBitsI
;  1023     [32]
;  1024         xor ecx,eax
;  1025     [64]
;  1026         xor rcx,rax
                xor rcx,rax               ;#0043F706: 48:061301                  uv 02 03  1 751      
;  1027     []
;  1028         ret
                ret                       ;#0043F709: 303                        np 00 00  2 752      
;  1029 
;  1030       ::opXorBitsF
;  1031     [32]
;  1032         sub esp,8
;  1033         fistp qword[esp]
;  1034         mov ecx,[esp]
;  1035         fistp qword[esp]
;  1036         xor ecx,[esp]
;  1037         add esp,12
;  1038         jmp :opMathIII
;  1039     [64]
;  1040         sub rsp,8
                sub rsp,8                 ;#0043F70A: 48:203354 08               uv 10 10  1 754      
;  1041         fistp qword[rsp]
                fistp qword[rsp]          ;#0043F70E: 337074044                  np 00 10  6 757    *10*
;  1042         mov rcx,[rsp]
                mov rcx,[rsp]             ;#0043F711: 48:213014044               uv 02 10  1 763      
;  1043         fistp qword[rsp]
                fistp qword[rsp]          ;#0043F715: 337074044                  np 00 10  6 764      
;  1044         xor rcx,[rsp]
                xor rcx,[rsp]             ;#0043F718: 48:063014044               uv 02 12  2 770      
;  1045         add rsp,16
                add rsp,16                ;#0043F71C: 48:203304 10               vu 10 10  1 771      
;  1046         jmp :opMathIII
                jmp #0043F3A5             ;#0043F720: 351 80FCFFFF               v  00 00  1 772      
;  1047     []
;  1048         
;  1049       :%opXorBits       -- [edi]:=xor_bits(ecx,eax) [inlined if ecx and eax are known to be integers]
;  1050 -----------------       -- (see builtins\VM\pXor.e for a = b xor c, the logic op)
;  1051     [32]
;  1052         mov edx,:opXorBitsI
;  1053         mov esi,:opXorBitsF
;  1054     [64]
;  1055         mov rdx,:opXorBitsI
                mov rdx,#0043F706         ;#0043F725: 48:307302 06F74300         uv 04 00  1 773      
;  1056         mov rsi,:opXorBitsF
                mov rsi,#0043F70A         ;#0043F72C: 48:307306 0AF74300         vu 40 00  1 773      
;  1057     []
;  1058         jmp :opMath
                jmp #0043F375             ;#0043F733: 351 3DFCFFFF               v  00 00  1 774      
;  1059 
;  1060       }
    jmp #0044298D (:%opRetf)              ;#0043F738: 351 50320000               v  00 00  1 775      
;C:\Program Files (x86)\Phix\builtins\VM\pXor.e:
;===============================================
;     1 --
;     2 -- pXor.e
;     3 -- ======
;     4 --
;     5 --  implements :%opXor  (a = b xor c)
;     6 --
;     7 --  Note: "and" and "or" are always short-circuited; opAnd and opOr simply do not exist at all.
;     8 --
;     9 
;    10 include builtins\VM\pFPU.e  -- :%down53, :%near53
;    11 
;    12 --#ilASM{ jmp :%opRetf
;    13 #ilASM{ jmp :!opCallOnceYeNot
                jmp :!opCallOnceYeNot     ;#0043F2CE: 351 0F3B0000               v  00 00  1   1      
;    14 
;    15 --DEV FIXME: (and the :!bang labels below) [should be gone now everything opUnassigned]
;    16     ::e1414soxa
;    17         int3
                int3                      ;#0043F2D3: 314                        np 00 00 13   2      
;    18 
;    19 --/*
;    20 procedure :%opXor(:%)
;    21 end procedure -- (for Edita/CtrlQ)
;    22 --*/
;    23  :%opXor                -- [edi] := eax xor esi (always a 0/1 result)
;    24 --------                -- (LogicOp, for [edi] other than 0 or 1 see opXorBits)
;    25     [32]
;    26         --calling convention:
;    27         --  lea edi,[dest]  -- addr dest
;    28         --  mov eax,[p2]    -- ref p2
;    29         --  mov esi,[p3]    -- ref p3
;    30         --  mov ecx,p2      -- varno of p2
;    31         --  mov edx,p3      -- varno of p3
;    32         --  call :%opXor    -- [edi] = eax xor esi
;    33         -- btw "and", "or" are always short-circuited: opAnd, opOr simply do not exist at all.
;    34 
;    35         cmp eax,h4  --DEV :%pLoadMint
;    36         jl @f
;    37       :!opXore92a                   -- exception here mapped to e94vhnbaavecx
;    38             cmp byte[ebx+eax*4-1],0x12
;    39             jne :e1414soxa
;    40             fld qword[ebx+eax*4]
;    41             call :%down53
;    42             sub esp,8
;    43             fistp qword[esp]
;    44             call :%near53
;    45             mov eax,[esp]
;    46             add esp,8
;    47       @@:
;    48         cmp esi,h4  --DEV :%pLoadMint
;    49         jl @f
;    50       :!opXore92b                   -- exception here mapped to e94vhnbaavedx
;    51             cmp byte[ebx+esi*4-1],0x12
;    52             jne :e1414soxa
;    53             fld qword[ebx+esi*4]
;    54             call :%down53
;    55             sub esp,8
;    56             fistp qword[esp]
;    57             call :%near53
;    58             mov esi,[esp]
;    59             add esp,8
;    60       @@:
;    61         test eax,eax
;    62         jz @f
;    63             mov eax,1 
;    64       @@:
;    65         test esi,esi
;    66         jz @f
;    67             mov esi,1
;    68       @@:
;    69         mov edx,[edi]               -- prev ref, if any
;    70     --DEV tryme:
;    71     --test eax,eax          --1
;    72     --jz XorEaxZero         --1
;    73     --   test esi,esi       --2
;    74     --   jz XorBothZero     --2
;    75     --  XorOneOnly:
;    76     --   mov eax,1          --3
;    77     --   jmp XorStore       --3
;    78     --XorEaxZero:
;    79     --   test esi,esi       --2
;    80     --   jnz XorOneOnly     --2
;    81     --  XorBothZero:
;    82     --   xor eax,eax        --3
;    83     --XorStore:
;    84     --(always 3 vs 3..5 clocks as it now stands) [but xor is so rare this is hardly worth it...]
;    85 
;    86         xor eax,esi
;    87         cmp edx,h4
;    88         mov [edi],eax               -- always 1 or 0
;    89         jle @f
;    90             sub dword[ebx+edx*4-8],1
;    91             jz :%pDealloc
;    92       @@:
;    93         ret
;    94     [64]
;    95         --calling convention:
;    96         --  lea rdi,[dest]  -- addr dest
;    97         --  mov rax,[p2]    -- ref p2
;    98         --  mov rsi,[p3]    -- ref p3
;    99         --  mov rcx,p2      -- varno of p2
;   100         --  mov rdx,p3      -- varno of p3
;   101         --  call :%opXor    -- [rdi] = rax xor rsi
;   102         -- btw "and", "or" are always short-circuited: opAnd, opOr simply do not exist at all.
;   103         mov r15,h4
                mov r15,h4                ;#0043F2D4: 49:277 0000000000000040    uv 8000 00  1  15      
;   104         cmp rax,r15
                cmp rax,r15               ;#0043F2DE: 49:073307                  uv 00 8001  1  16 8000   
;   105         jl @f
                jl #0043F300              ;#0043F2E1: 174 1D                     v  00 00  1  16      
;   106       :!opXore92a                   -- exception here mapped to e91vhnbaavecx
;   107             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043F2E3: 200174203 FF 12            u  00 09  2  17      
;   108             jne :e1414soxa
                    jne #0043F2D3         ;#0043F2E8: 165 E9                     v  00 00  1  18      
;   109             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043F2EA: 333054203                  np 00 09  3  19      
;   110             call :%down64
                    call #0044139E (:%down64)  ;#0043F2ED: 350 AC200000               v  00 00  1  22      
;   111             sub rsp,8
                    sub rsp,8             ;#0043F2F2: 48:203354 08               uv 10 10  1  23      
;   112             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F2F6: 337074044                  np 00 10  6  26    *10*
;   113             call :%near64
                    call #004413A5 (:%near64)  ;#0043F2F9: 350 A7200000               v  00 00  1  32      
;   114             pop rax
                    pop rax               ;#0043F2FE: 48:130                     uv 01 00  1  33      
;   115       @@:
;   116         cmp rsi,r15
                cmp rsi,r15               ;#0043F300: 49:073367                  vu 00 8040  1  33      
;   117         jl @f
                jl #0043F322              ;#0043F303: 174 1D                     v  00 00  1  34      
;   118       :!opXore92b                   -- exception here mapped to e94vhnbaavedx
;   119             cmp byte[rbx+rsi*4-1],0x12
                    cmp byte[rbx+rsi*4-1],#12  ;#0043F305: 200174263 FF 12            u  00 48  2  35      
;   120             jne :e1414soxa
                    jne #0043F2D3         ;#0043F30A: 165 C7                     v  00 00  1  36      
;   121             fld tbyte[rbx+rsi*4]
                    fld tbyte[rbx+rsi*4]  ;#0043F30C: 333054263                  np 00 48  3  37      
;   122             call :%down64
                    call #0044139E (:%down64)  ;#0043F30F: 350 8A200000               v  00 00  1  40      
;   123             sub rsp,8
                    sub rsp,8             ;#0043F314: 48:203354 08               uv 10 10  1  41      
;   124             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F318: 337074044                  np 00 10  6  44    *10*
;   125             call :%near64
                    call #004413A5 (:%near64)  ;#0043F31B: 350 85200000               v  00 00  1  50      
;   126             pop rsi
                    pop rsi               ;#0043F320: 48:136                     uv 40 00  1  51      
;   127       @@:
;   128         test rax,rax
                test rax,rax              ;#0043F322: 48:205300                  vu 00 01  1  51      
;   129         jz @f
                jz #0043F32E              ;#0043F325: 164 07                     v  00 00  1  52      
;   130             mov rax,1 
                    mov rax,1             ;#0043F327: 48:307300 01000000         uv 01 00  1  53      
;   131       @@:
;   132         test rsi,rsi
                test rsi,rsi              ;#0043F32E: 48:205366                  vu 00 40  1  53      
;   133         jz @f
                jz #0043F33A              ;#0043F331: 164 07                     v  00 00  1  54      
;   134             mov rsi,1
                    mov rsi,1             ;#0043F333: 48:307306 01000000         uv 40 00  1  55      
;   135       @@:
;   136         mov rdx,[rdi]               -- prev ref, if any
                mov rdx,[rdi]             ;#0043F33A: 48:213027                  vu 04 80  1  55      
;   137         xor rax,rsi
                xor rax,rsi               ;#0043F33D: 48:061360                  uv 01 41  1  56      
;   138         cmp rdx,r15
                cmp rdx,r15               ;#0043F340: 49:073327                  vu 00 8004  1  56      
;   139         mov [rdi],rax               -- always 1 or 0
                mov [rdi],rax             ;#0043F343: 48:211007                  uv 00 81  1  57      
;   140         jle @f
                jle #0043F354             ;#0043F346: 176 0C                     v  00 00  1  57      
;   141             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043F348: 48:203154223 F0 01         u  00 0C  3  58      
;   142             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043F34E: 017204 862F0000            v  00 00  1  60      
;   143       @@:
;   144         ret
                ret                       ;#0043F354: 303                        np 00 00  2  61      
;   145     []
;   146 
;   147       }
    jmp #0044298D (:%opRetf)              ;#0043F355: 351 33360000               v  00 00  1  63      
;C:\Program Files (x86)\Phix\builtins\VM\pLen.e:
;===============================================
;     1 --
;     2 -- pLen.e
;     3 -- ======
;     4 --
;     5 --  implements :%opLen
;     6 --
;     7 --  Note that l = length(s) is inlined if s is known to be an assigned sequence (so
;     8 --       no need to check for unassigned) and l is an integer (so it does not need 
;     9 --       a decref/dealloc), saving the overhead of both the call/return and those
;    10 --       mentioned unnecessary checks.
;    11 --
;    12 
;    13 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043F288: 351 00370000               v  00 00  1   1      
;    14 
;    15     :%opLen
;    16 -----------
;    17     [32]
;    18         --calling convention:
;    19         --  lea edi,[p1]    -- result location
;    20         --  mov esi,[p2]    -- source ref
;    21         --  mov edx,p2      -- var no of ref
;    22         --  call :%opLen    -- [edi]=length(eax)
;    23         nop -- (DEV force :%opLen not :!opLene36or92 in list.asm...)
;    24       :!opLene36or92
;    25         test byte[ebx+esi*4-1],0x80     -- all strings/sequences have bit #80 set...
;    26         jnz @f
;    27             pop edx
;    28             sub edx,1
;    29             mov al,36   -- e36loaaind
;    30             jmp :!iDiag
;    31             int3
;    32       @@:
;    33         mov edx,[edi]                   -- prev value of target
;    34         mov ecx,[ebx+esi*4-12]          -- get length
;    35         cmp edx,h4
;    36         mov [edi],ecx
;    37         jle @f
;    38             sub dword[ebx+edx*4-8],1
;    39             jz :%pDealloc
;    40       @@:
;    41         ret
;    42     [64]
;    43         --calling convention:
;    44         --  lea rdi,[p1]    -- result location
;    45         --  mov rsi,[p2]    -- source ref
;    46         --  mov rdx,p2      -- var no of ref
;    47         --  call :%opLen    -- [rdi]=length(rax)
;    48         mov r15,h4
                mov r15,h4                ;#0043F28D: 49:277 0000000000000040    uv 8000 00  1   2      
;    49       :!opLene36or92
;    50         test byte[rbx+rsi*4-1],0x80     -- all strings/sequences have bit #80 set...
                test byte[rbx+rsi*4-1],#80  ;#0043F297: 366104263 FF 80            u  00 48  2   3      
;    51         jnz @f
                jnz #0043F2AC             ;#0043F29C: 165 0E                     v  00 00  1   4      
;    52             pop rdx
                    pop rdx               ;#0043F29E: 48:132                     uv 04 00  1   5      
;    53             sub rdx,1
                    sub rdx,1             ;#0043F2A0: 48:203352 01               uv 04 04  1   6 04   
;    54             mov al,36   -- e36loaaind
                    mov al,36             ;#0043F2A4: 260 24                     vu 01 00  1   6      
;    55             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#0043F2A6: 351 BB3B0000               v  00 00  1   7      
;    56             int3
                    int3                  ;#0043F2AB: 314                        np 00 00 13   8      
;    57       @@:
;    58         mov rdx,[rdi]                   -- prev value of target
                mov rdx,[rdi]             ;#0043F2AC: 48:213027                  uv 04 80  1  21      
;    59         mov rcx,[rbx+rsi*4-24]          -- get length
                mov rcx,[rbx+rsi*4-24]    ;#0043F2AF: 48:213114263 E8            vu 02 48  1  21      
;    60         cmp rdx,r15
                cmp rdx,r15               ;#0043F2B4: 49:073327                  uv 00 8004  1  22      
;    61         mov [rdi],rcx
                mov [rdi],rcx             ;#0043F2B7: 48:211017                  vu 00 82  1  22      
;    62         jle @f
                jle #0043F2C8             ;#0043F2BA: 176 0C                     v  00 00  1  23      
;    63             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043F2BC: 48:203154223 F0 01         u  00 0C  3  24      
;    64             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043F2C2: 017204 12300000            v  00 00  1  26      
;    65       @@:
;    66         ret
                ret                       ;#0043F2C8: 303                        np 00 00  2  27      
;    67     []
;    68       }
    jmp #0044298D (:%opRetf)              ;#0043F2C9: 351 BF360000               v  00 00  1  29      
;C:\Program Files (x86)\Phix\builtins\VM\pRmdr.e:
;================================================
;     1 --
;     2 -- pRmdr.e
;     3 -- =======
;     4 --
;     5 --  Implements :%opRmdr
;     6 --
;     7 
;     8 include VM\pHeap.e  -- :%pDealloc/:%pStoreFlt
;     9 
;    10 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043F1EE: 351 9A370000               v  00 00  1   1      
;    11 
;    12 --DEV
;    13         ::e103atgrondb0esp
;    14             int3
                    int3                  ;#0043F1F3: 314                        np 00 00 13   2      
;    15         ::e1405sora
;    16             int3
                    int3                  ;#0043F1F4: 314                        np 00 00 13  15      
;    17 
;    18 --/*
;    19 procedure :%opRmdr(:%)
;    20 end procedure -- (for Edita/CtrlQ)
;    21 --*/
;    22   :%opRmdr      -- [edi] := remainder(eax,ecx) (integers and floats only)
;    23 ---------
;    24     [32]
;    25         --calling convention:
;    26         --  lea edi,[p1]    -- address of target
;    27         --  mov eax,[p2]    -- ref p2 (opUnassigned)
;    28         --  mov ecx,[p3]    -- ref p3 (opUnassigned)
;    29         --  call :%opRmdr
;    30         cmp eax,h4
;    31         jge :opRmdrN
;    32         --
;    33         -- eax [p2] is an int
;    34         --
;    35         cmp ecx,h4
;    36         jge :opRmdrIN
;    37         test ecx,ecx
;    38         jz :e103atgrondb0esp    -- attempt to get remainder of a number divided by 0
;    39         mov edx,eax
;    40         mov esi,[edi]
;    41         sar edx,31
;    42         idiv ecx
;    43         mov [edi],edx
;    44         mov edx,esi
;    45         cmp esi,h4
;    46         jle @f
;    47             sub dword[ebx+edx*4-8],1
;    48             jz :%pDealloc
;    49       @@:
;    50         ret
;    51 
;    52     ::opRmdrIN
;    53         --
;    54         -- eax/p2 is set, ecx/p3 is (must be) a float.
;    55         --
;    56         push eax
;    57         shl ecx,2
;    58         fild dword[esp]
;    59         add esp,4
;    60 --    opRmdre92a:               -- exception here mapped to e92vhnbaavespm9feh
;    61         cmp byte[ecx-1],0x12
;    62         jne :e1405sora          -- sequence op (remainder) attempted
;    63         fld qword[ecx]
;    64         jmp :opRmdrToN
;    65 
;    66     ::opRmdrN
;    67         --
;    68         -- load p2 as float, then consider p3
;    69         --
;    70 --    opRmdre92b:               -- exception here mapped to e92vhnbaavespm15feh
;    71         cmp byte[ebx+eax*4-1],0x12
;    72         jne :e1405sora          -- sequence op (remainder) attempted
;    73         fld qword[ebx+eax*4]
;    74         cmp ecx,h4
;    75         jge :opRmdrNN
;    76         test ecx,ecx
;    77         jz :e103atgrondb0esp    -- attempt to get remainder of a number divided by 0
;    78         push ecx
;    79         fild dword[esp]
;    80         add esp,4
;    81         jmp :opRmdrToN
;    82 
;    83     ::opRmdrNN
;    84         --
;    85         -- st0/p2 is loaded, ecx/p3 is (must be) a float
;    86         --
;    87 --    opRmdre92c:               -- exception here mapped to e92vhnbaavespm9feh
;    88         cmp byte[ebx+ecx*4-1],0x12
;    89         jne :e1405sora          -- sequence op (remainder) attempted
;    90         fld qword[ebx+ecx*4]
;    91     ::opRmdrToN
;    92         fxch
;    93       @@:
;    94         fprem
;    95         fnstsw ax           -- Status Word into AX
;    96         sahf                -- copy to the CPU flags
;    97         jpe @b              -- continue reducing if C2=PF=1 (reduction incomplete)
;    98 
;    99         fstp st1            -- overwrite the 2p with the ST(0) value and POP ST(0)
;   100 
;   101         jmp :%pStoreFlt
;   102     [64]
;   103         --calling convention:
;   104         --  lea rdi,[p1]    -- address of target
;   105         --  mov rax,[p2]    -- ref p2 (opUnassigned)
;   106         --  mov rcx,[p3]    -- ref p3 (opUnassigned)
;   107         --  call :%opRmdr
;   108         mov r15,h4
                mov r15,h4                ;#0043F1F5: 49:277 0000000000000040    uv 8000 00  1  28      
;   109         cmp rax,r15
                cmp rax,r15               ;#0043F1FF: 49:073307                  uv 00 8001  1  29 8000   
;   110         jge :opRmdrN
                jge #0043F24A             ;#0043F202: 175 46                     v  00 00  1  29      
;   111         --
;   112         -- rax [p2] is an int
;   113         --
;   114         cmp rcx,r15
                cmp rcx,r15               ;#0043F204: 49:073317                  uv 00 8002  1  30      
;   115         jge :opRmdrIN
                jge #0043F233             ;#0043F207: 175 2A                     v  00 00  1  30      
;   116         test rcx,rcx
                test rcx,rcx              ;#0043F209: 48:205311                  uv 00 02  1  31      
;   117         jz :e103atgrondb0esp    -- attempt to get remainder of a number divided by 0
                jz #0043F1F3              ;#0043F20C: 164 E5                     v  00 00  1  31      
;   118         mov rdx,rax
                mov rdx,rax               ;#0043F20E: 48:213320                  uv 04 01  1  32      
;   119         mov rsi,[rdi]
                mov rsi,[rdi]             ;#0043F211: 48:213067                  vu 40 80  1  32      
;   120         sar rdx,63
                sar rdx,63                ;#0043F214: 48:301372 3F               u  04 04  1  33      
;   121         idiv rcx
                idiv rcx                  ;#0043F218: 48:367371                  np 05 07 46  34      
;   122         mov [rdi],rdx
                mov [rdi],rdx             ;#0043F21B: 48:211027                  uv 00 84  1  80      
;   123         mov rdx,rsi
                mov rdx,rsi               ;#0043F21E: 48:213326                  vu 04 40  1  80      
;   124         cmp rsi,r15
                cmp rsi,r15               ;#0043F221: 49:073367                  uv 00 8040  1  81      
;   125         jle @f
                jle #0043F232             ;#0043F224: 176 0C                     v  00 00  1  81      
;   126             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043F226: 48:203154223 F0 01         u  00 0C  3  82      
;   127             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043F22C: 017204 A8300000            v  00 00  1  84      
;   128       @@:
;   129         ret
                ret                       ;#0043F232: 303                        np 00 00  2  85      
;   130 
;   131     ::opRmdrIN
;   132         --
;   133         -- rax/p2 is set, rcx/p3 is (must be) a float.
;   134         --
;   135         push rax
                push rax                  ;#0043F233: 48:120                     uv 00 01  1  87      
;   136         shl rcx,2
                shl rcx,2                 ;#0043F235: 48:301341 02               u  02 02  1  88      
;   137         fild qword[rsp]
                fild qword[rsp]           ;#0043F239: 337054044                  np 00 10  3  89      
;   138         add rsp,8
                add rsp,8                 ;#0043F23C: 48:203304 08               uv 10 10  1  92      
;   139 --    opRmdre92a:               -- exception here mapped to e92vhnbaavespm9feh
;   140         cmp byte[rcx-1],0x12
                cmp byte[rcx-1],#12       ;#0043F240: 200171 FF 12               u  00 02  2  93      
;   141         jne :e1405sora          -- sequence op (remainder) attempted
                jne #0043F1F4             ;#0043F244: 165 AE                     v  00 00  1  94      
;   142         fld tbyte[rcx]
                fld tbyte[rcx]            ;#0043F246: 333051                     np 00 02  3  95      
;   143         jmp :opRmdrToN
                jmp #0043F273             ;#0043F248: 353 29                     v  00 00  1  98      
;   144 
;   145     ::opRmdrN
;   146         --
;   147         -- load p2 as float, then consider p3
;   148         --
;   149 --    opRmdre92b:               -- exception here mapped to e92vhnbaavespm15feh
;   150         cmp byte[rbx+rax*4-1],0x12
                cmp byte[rbx+rax*4-1],#12  ;#0043F24A: 200174203 FF 12            u  00 09  2  99      
;   151         jne :e1405sora          -- sequence op (remainder) attempted
                jne #0043F1F4             ;#0043F24F: 165 A3                     v  00 00  1 100      
;   152         fld tbyte[rbx+rax*4]
                fld tbyte[rbx+rax*4]      ;#0043F251: 333054203                  np 00 09  3 101      
;   153         cmp rcx,r15
                cmp rcx,r15               ;#0043F254: 49:073317                  uv 00 8002  1 104      
;   154         jge :opRmdrNN
                jge #0043F269             ;#0043F257: 175 10                     v  00 00  1 104      
;   155         test rcx,rcx
                test rcx,rcx              ;#0043F259: 48:205311                  uv 00 02  1 105      
;   156         jz :e103atgrondb0esp    -- attempt to get remainder of a number divided by 0
                jz #0043F1F3              ;#0043F25C: 164 95                     v  00 00  1 105      
;   157         push rcx
                push rcx                  ;#0043F25E: 48:121                     uv 00 02  1 106      
;   158         fild qword[rsp]
                fild qword[rsp]           ;#0043F260: 337054044                  np 00 10  3 107      
;   159         add rsp,8
                add rsp,8                 ;#0043F263: 48:203304 08               uv 10 10  1 110      
;   160         jmp :opRmdrToN
                jmp #0043F273             ;#0043F267: 353 0A                     v  00 00  1 110      
;   161 
;   162     ::opRmdrNN
;   163         --
;   164         -- st0/p2 is loaded, rcx/p3 is (must be) a float
;   165         --
;   166 --    opRmdre92c:               -- exception here mapped to e92vhnbaavespm9feh
;   167         cmp byte[rbx+rcx*4-1],0x12
                cmp byte[rbx+rcx*4-1],#12  ;#0043F269: 200174213 FF 12            u  00 0A  2 111      
;   168         jne :e1405sora          -- sequence op (remainder) attempted
                jne #0043F1F4             ;#0043F26E: 165 84                     v  00 00  1 112      
;   169         fld tbyte[rbx+rcx*4]
                fld tbyte[rbx+rcx*4]      ;#0043F270: 333054213                  np 00 0A  3 113      
;   170     ::opRmdrToN
;   171         fxch
                fxch                      ;#0043F273: 331311                     np 00 00  1 116      
;   172       @@:
;   173         fprem
                fprem                     ;#0043F275: 331370                     np 00 00 64 117      
;   174         fnstsw ax           -- Status Word into AX
                fnstsw ax                 ;#0043F277: 337340                     np 01 00  6 181      
;   175         sahf                -- copy to the CPU flags
                sahf                      ;#0043F279: 236                        np 00 01  2 187      
;   176         jpe @b              -- continue reducing if C2=PF=1 (reduction incomplete)
                jpe #0043F275             ;#0043F27A: 172 F9                     v  00 00  1 189      
;   177 
;   178         fstp st1            -- overwrite the 2p with the ST(0) value and POP ST(0)
                fstp st1                  ;#0043F27C: 335331                     np 00 00  1 190      
;   179 
;   180         jmp :%pStoreFlt
                jmp #004421B0 (:%pStoreFlt)  ;#0043F27E: 351 2D2F0000               v  00 00  1 191      
;   181     []
;   182       }
    jmp #0044298D (:%opRetf)              ;#0043F283: 351 05370000               v  00 00  1 192      
;C:\Program Files (x86)\Phix\builtins\VM\pMem.e:
;===============================================
;     1 --
;     2 -- pMem.e
;     3 --
;     4 --  implements :%opPeekNx, :%opPeeki, :%opPokeN, :%opPokeNS, :%opMemCopy, :%opMemSet
;     5 
;     6 --SUG: if X64!=1 and emitON then abort("not supported on 32-bit") for peek/poke8
;     7 --  An atom in 32-bit Euphoria is limited to 53 bits of precision, therefore trying
;     8 --  to load/store 64 bit integers on that platform is just going to discard 11 bits, 
;     9 --  every time. Instead, simply use two peek4s/poke4 operations for each qword.
;    10 
;    11 -- SUG: in peek(a)/peek({a,i})/poke(a,x), allow a to be a 2-element sequence of the
;    12 --      form {root,offset}. Ensure [root-8/16] is a pukka pRoot, ie [[root-8/16]]
;    13 --      is #00484253 aka "SBH\0", and offset >=0 and <=nSize aka [root-4/8].
;    14 --      Update the help files accordingly:
;    15 --          NEW: a can also be a 2-element sequence of the form {root,offset}, in
;    16 --               which case peek/poke ensures root is a live block from allocate
;    17 --               (that has not been freed) and 0<=offset<=sizeof(root), iyswim.
;    18 --               Obviously these forms are safer but cannot be used on memory
;    19 --               obtained from system calls, such as GetCommandLine.
;    20 
;    21 include builtins\VM\pFPU.e  -- :%down53, :%near53
;    22 
;    23 --include builtins\VM\pFEH.e    -- DEV/temp
;    24 
;    25 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043ED2B: 351 5D3C0000               v  00 00  1   1      
;    26 
;    27 --DEV FIXME: (and the :!bang labels below, opPeekMLE, opPeeksMLE,)
;    28 --  ::e43atpmbaoso2ap
;    29 --      pop ecx
;    30     ::e43atpmbaoso2a
;    31         int3
                int3                      ;#0043ED30: 314                        np 00 00 13   2      
;    32 --(note: e45 just died)
;    33 --  ::e44atpmbaoso2a
;    34 --      int3
;    35     ::e110opPeekiSeq
;    36         int3
                int3                      ;#0043ED31: 314                        np 00 00 13  15      
;    37 --  ::e41fatpmba
;    38 --      int3
;    39     ::e114stbpmoca
;    40         int3
                int3                      ;#0043ED32: 314                        np 00 00 13  28      
;    41     ::showerror     -- (see also eNNunknown in pApnd.e)
;    42         int3
                int3                      ;#0043ED33: 314                        np 00 00 13  41      
;    43     ::e42fatp4mba
;    44         int3
                int3                      ;#0043ED34: 314                        np 00 00 13  54      
;    45     ::e39atmcmba
;    46         int3
                int3                      ;#0043ED35: 314                        np 00 00 13  67      
;    47     ::e22imcl
;    48         int3
                int3                      ;#0043ED36: 314                        np 00 00 13  80      
;    49     ::e23imsl
;    50         int3
                int3                      ;#0043ED37: 314                        np 00 00 13  93      
;    51     ::e40atmsmba
;    52 --tests, all seem fine ;-)
;    53 --jmp :%opPeek
;    54 --mov eax,:%opPeek
;    55 --jmp :!opPeek4ssMLE
;    56 --mov eax,:!opPeek4ssMLE
;    57 --cmp eax,:!opPeek4ssMLE
;    58 --cmp eax,:!unknoiwn
;    59 ----cmp eax,:%unknoiwn
;    60         int3
                int3                      ;#0043ED38: 314                        np 00 00 13 106      
;    61     ::epeeksize
;    62 --jmp :%feh1
;    63 --mov eax,[ebx]
;    64         int3
                int3                      ;#0043ED39: 314                        np 00 00 13 119      
;    65     ::epokesize
;    66 --jmp :%feh2
;    67 --mov eax,[ebx]
;    68         int3
                int3                      ;#0043ED3A: 314                        np 00 00 13 132      
;    69 
;    70 --DEV this is an alias for peek1u()
;    71 --/*
;    72 procedure :%opPeek(:%)
;    73 end procedure -- (for Edita/CtrlQ)
;    74 --*/
;    75 --/*
;    76   :%opPeek
;    77 ----------
;    78     [32]
;    79         --calling convention
;    80         --  lea edi,[p1]        -- target addr
;    81         --  mov esi,[p2]        -- addr or {addr,len} (opUnassigned)
;    82 --mov ecx,0
;    83 --mov edx,1
;    84 --jmp :%opPeekNx
;    85         xor eax,eax
;    86         cmp esi,h4
;    87         jl @f
;    88             cmp byte[ebx+esi*4-1],0x12
;    89             jne :PeekSeq
;    90             sub esp,8
;    91             fld qword[ebx+esi*4]
;    92             call :%down53
;    93             fistp qword[esp]
;    94             call :%near53
;    95             mov esi,[esp]
;    96             add esp,8
;    97       @@:
;    98         mov edx,[edi]           -- prev
;    99 --    :!opPeekMLE                   -- exception here mapped to e99ipmaespfeh (invalid peek memory address)
;   100         mov al,[esi]
;   101         cmp edx,h4
;   102         mov [edi],eax
;   103         jle @f
;   104             sub dword[ebx+edx*4-8],1
;   105             jz :%pDealloc
;   106       @@:
;   107         ret
;   108 
;   109       ::PeekSeq                 -- peek({addr,len}) case (result is string)
;   110         -- esi is {addr,len}, edi is tgt addr
;   111         cmp byte[ebx+esi*4-1],0x80      -- sequence:
;   112         jnz :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
;   113         cmp dword[ebx+esi*4-12],2       -- of length 2:
;   114         jne :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
;   115         mov ecx,[ebx+esi*4+4]           -- len (ie p2[2])
;   116         cmp ecx,h4
;   117         jle @f
;   118             cmp byte[ebx+ecx*4-1],0x12
;   119             jne :e43atpmbaoso2a     -- argument to peek must be atom or sequence of 2 atoms
;   120             sub esp,8
;   121             fld qword[ebx+ecx*4]
;   122             call :%down53
;   123             fistp qword[esp]
;   124             call :%near53
;   125             mov ecx,[esp]
;   126             add esp,8
;   127       @@:
;   128         mov esi,[ebx+esi*4]         -- addr (ie p2[1])
;   129         push edi                    -- save tgt addr
;   130         cmp esi,h4
;   131         jle @f
;   132             cmp byte[ebx+esi*4-1],0x12
;   133             jne :e43atpmbaoso2ap    -- argument to peek must be atom or sequence of 2 atoms
;   134             sub esp,8
;   135             fld qword[ebx+esi*4]
;   136             call :%down53
;   137             fistp qword[esp]
;   138             call :%near53
;   139             mov esi,[esp]
;   140             add esp,8
;   141       @@:
;   142         -- OK, len in ecx, addr in esi
;   143         call :%pAllocStr            -- damages eax only
;   144         lea edi,[ebx+eax*4]
;   145 --    :!opPeeksMLE                  -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   146         rep movsb
;   147         pop esi
;   148         mov byte[edi],0
;   149         mov edx,[esi]
;   150         mov [esi],eax
;   151         cmp edx,h4
;   152         jle @f
;   153             sub dword[ebx+edx*4-8],1
;   154             jz :%pDealloc
;   155       @@:
;   156         ret
;   157     [64]
;   158         --calling convention
;   159         --  lea rdi,[p1]        -- target addr
;   160         --  mov rsi,[p2]        -- addr or {addr,len} (opUnassigned)
;   161         mov r15,h4
;   162         xor rax,rax
;   163         cmp rsi,r15
;   164         jl @f
;   165             cmp byte[rbx+rsi*4-1],0x12
;   166             jne :PeekSeq64
;   167             sub rsp,8
;   168             fld tbyte[rbx+rsi*4]
;   169             call :%down64
;   170             fistp qword[rsp]
;   171             call :%near64
;   172             pop rsi
;   173       @@:
;   174         mov rdx,[rdi]           -- prev
;   175 --    :!opPeekMLE                   -- exception here mapped to e99ipmaespfeh (invalid peek memory address)
;   176         mov al,[rsi]
;   177         cmp rdx,r15
;   178         mov [rdi],rax
;   179         jle @f
;   180             sub qword[rbx+rdx*4-16],1
;   181             jz :%pDealloc
;   182       @@:
;   183         ret
;   184 
;   185       ::PeekSeq64               -- peek({addr,len}) case (result is string)
;   186         -- rsi is {addr,len}, rdi is tgt addr
;   187         cmp byte[rbx+rsi*4-1],0x80      -- sequence:
;   188         jnz :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
;   189         cmp qword[rbx+rsi*4-24],2       -- of length 2:
;   190         jne :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
;   191         mov rcx,[rbx+rsi*4+8]           -- len (ie p2[2])
;   192         cmp rcx,r15
;   193         jle @f
;   194             cmp byte[rbx+rcx*4-1],0x12
;   195             jne :e43atpmbaoso2a     -- argument to peek must be atom or sequence of 2 atoms
;   196             sub rsp,8
;   197             fld tbyte[rbx+rcx*4]
;   198             call :%down64
;   199             fistp qword[rsp]
;   200             call :%near64
;   201             pop rcx
;   202       @@:
;   203         mov rsi,[rbx+rsi*4]         -- addr (ie p2[1])
;   204         push rdi                    -- save tgt addr
;   205         cmp rsi,r15
;   206         jle @f
;   207             cmp byte[rbx+rsi*4-1],0x12
;   208             jne :e43atpmbaoso2ap    -- argument to peek must be atom or sequence of 2 atoms
;   209             sub rsp,8
;   210             fld tbyte[rbx+rsi*4]
;   211             call :%down64
;   212             fistp qword[rsp]
;   213             call :%near64
;   214             pop rsi
;   215       @@:
;   216         -- OK, len in rcx, addr in rsi
;   217         call :%pAllocStr            -- damages rax only
;   218         lea rdi,[rbx+rax*4]
;   219 --    :!opPeeksMLE                  -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   220         rep movsb
;   221         pop rsi
;   222         mov byte[rdi],0
;   223         mov rdx,[rsi]
;   224         mov [rsi],rax
;   225         cmp rdx,r15
;   226         jle @f
;   227             sub qword[rbx+rdx*4-16],1
;   228             jz :%pDealloc
;   229       @@:
;   230         ret
;   231     []
;   232 --*/
;   233 
;   234 --/*
;   235 procedure :%opPeeki(:%)
;   236 end procedure -- (for Edita/CtrlQ)
;   237 --*/
;   238   :%opPeeki     -- optimised case when result is integer (ie no dealloc)
;   239 -----------     -- (inlined in all cases except when e110opPeekiSeq might trigger...DEV)
;   240     [32]
;   241         --calling convention:
;   242         --  mov esi,[p2]    -- ref addr (and not {addr,len}) (opUnassigned)
;   243         --  call :%opPeeki
;   244         --   only eax is altered
;   245         --  mov [p1],eax
;   246         xor eax,eax
;   247         cmp esi,h4  --DEV :%pLoadMint
;   248         jl @f
;   249             cmp byte[ebx+esi*4-1],0x12
;   250             jne :e110opPeekiSeq
;   251             fld qword[ebx+esi*4]
;   252             sub esp,8
;   253             call :%down53
;   254             fistp qword[esp]
;   255             call :%near53
;   256             mov esi,[esp]
;   257             add esp,8
;   258       @@:
;   259       :!opPeekiRIMA             -- exception here mapped to e99ipmaespfeh (invalid peek memory address)
;   260         mov al,[esi]
;   261         ret
;   262     [64]
;   263         --calling convention:
;   264         --  mov rsi,[p2]    -- ref addr (and not {addr,len}) (opUnassigned)
;   265         --  call :%opPeeki
;   266         --   only rax is altered
;   267         --  mov [p1],rax
;   268         mov r15,h4
                mov r15,h4                ;#0043ED3B: 49:277 0000000000000040    uv 8000 00  1 145      
;   269         xor rax,rax
                xor rax,rax               ;#0043ED45: 48:061300                  vu 01 01  1 145      
;   270         cmp rsi,r15
                cmp rsi,r15               ;#0043ED48: 49:073367                  uv 00 8040  1 146      
;   271         jl @f
                jl #0043ED69 (:!opPeekiRIMA)  ;#0043ED4B: 174 1C                     v  00 00  1 146      
;   272             cmp byte[rbx+rsi*4-1],0x12
                    cmp byte[rbx+rsi*4-1],#12  ;#0043ED4D: 200174263 FF 12            u  00 48  2 147      
;   273             jne :e110opPeekiSeq
                    jne #0043ED31         ;#0043ED52: 165 DD                     v  00 00  1 148      
;   274             fld tbyte[rbx+rsi*4]
                    fld tbyte[rbx+rsi*4]  ;#0043ED54: 333054263                  np 00 48  3 149      
;   275             sub rsp,8
                    sub rsp,8             ;#0043ED57: 48:203354 08               uv 10 10  1 152      
;   276             call :%down64
                    call #0044139E (:%down64)  ;#0043ED5B: 350 3E260000               v  00 00  1 152      
;   277             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043ED60: 337074044                  np 00 10  6 155    *10*
;   278             call :%near64
                    call #004413A5 (:%near64)  ;#0043ED63: 350 3D260000               v  00 00  1 161      
;   279             pop esi
                    pop rsi               ;#0043ED68: 136                        uv 40 00  1 162      
;   280       @@:
;   281       :!opPeekiRIMA             -- exception here mapped to e99ipmaespfeh (invalid peek memory address)
;   282         mov al,[rsi]
                mov al,[esi]              ;#0043ED69: 212006                     uv 01 40  1 165 40 *40*
;   283         ret
                ret                       ;#0043ED6B: 303                        np 00 00  2 166      
;   284     []
;   285 
;   286 --DEV:
;   287 --/*
;   288 procedure :%opPeek4x(:%DEAD)
;   289 end procedure -- (for Edita/CtrlQ)
;   290 --*/
;   291 --/*
;   292   :%opPeek4x
;   293 ------------
;   294     [32]
;   295         --calling convention
;   296         --  lea edi,[p1]        -- target addr
;   297         --  mov esi,[p2]        -- addr or {addr,len} (opUnassigned)
;   298         --  mov ecx,-1          -- opPeek4s
;   299         --  mov ecx,0           -- opPeek4u
;   300         push ecx
;   301         cmp esi,h4
;   302         jl @f
;   303             cmp byte[ebx+esi*4-1],0x12
;   304             jne :Peek4sSeq
;   305             fld qword[ebx+esi*4]
;   306             sub esp,8
;   307             call :%down53
;   308             fistp qword[esp]
;   309             call :%near53
;   310             mov esi,[esp]
;   311             add esp,8
;   312       @@:
;   313 
;   314       :!opPeek4sMLE         -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   315         mov eax,[esi]
;   316         cmp dword[esp],0
;   317         je :opPeek4uAtom
;   318 --    ::opPeek4sAtom
;   319             mov ecx,eax
;   320             shl ecx,1           -- (this is a better test than cmp h4)
;   321             jno :Peek4sStore    -- store #C0000000..#3FFFFFFF (-1073741824..1073741823) in eax as short int
;   322 
;   323             push eax
;   324             fild dword[esp]
;   325             add esp,8           -- (discard eax and sign flag)
;   326             jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
;   327 
;   328       ::opPeek4uAtom
;   329 --          cmp ecx,h4
;   330             cmp eax,h4
;   331             jb :Peek4sStore     -- store unsigned 0..#3FFFFFFF (0..1073741823) in eax as short int
;   332             push ebx
;   333             push eax
;   334             fild qword[esp]
;   335             add esp,12          -- (discard qword and sign flag)
;   336             jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
;   337 
;   338       ::Peek4sSeq                       -- peek4x({addr,len}) case
;   339         push edi                        -- target addr
;   340         cmp byte[ebx+esi*4-1],0x80      -- sequence
;   341         jnz :e44atpmbaoso2a             -- argument to peek4 must be atom or sequence of 2 atoms
;   342         cmp dword[ebx+esi*4-12],2       -- of length 2
;   343         jne :e44atpmbaoso2a             -- argument to peek4 must be atom or sequence of 2 atoms
;   344         mov ecx,[ebx+esi*4+4]           -- len (ie p2[2])
;   345         cmp ecx,h4
;   346         jl @f
;   347             cmp byte[ebx+ecx*4-1],0x12
;   348             jne :e44atpmbaoso2a
;   349             fld qword[ebx+ecx*4]
;   350             sub esp,8
;   351             call :%down53
;   352             fistp qword[esp]
;   353             call :%near53
;   354             mov ecx,[esp]
;   355             add esp,8
;   356       @@:
;   357         mov esi,[ebx+esi*4]             -- addr (ie p2[1])
;   358         cmp esi,h4
;   359         jl @f
;   360             cmp byte[ebx+esi*4-1],0x12
;   361             jne :e44atpmbaoso2a
;   362             fld qword[ebx+esi*4]
;   363             sub esp,8
;   364             call :%down53
;   365             fistp qword[esp]
;   366             call :%near53
;   367             mov esi,[esp]
;   368             add esp,8
;   369       @@:
;   370         -- OK, len in ecx, and addr in esi
;   371         --  era in edx???[DEV]
;   372         call :%pAllocSeq            -- damages eax only
;   373         test ecx,ecx
;   374         jz :Peek4sStore
;   375         lea edi,[ebx+eax*4]
;   376         push eax
;   377       ::opPeek4xLoop
;   378       :!opPeek4ssMLE            -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   379             lodsd               -- mov eax,[esi], esi+=4
;   380             mov edx,eax
;   381             stosd               -- store short ints #C0000000 .. #3FFFFFFF (-1073741824..1073741823) direct
;   382                                 -- (mov [edi],eax; edi+=4)
;   383             cmp dword[esp+8],0
;   384             je :opPeek4uItem
;   385 --        ::opPeek4sItem
;   386             shl edx,1
;   387             jno @f
;   388                 mov [edi-4],ebx     -- 0 (for StoreFlt, cleanup mess we just put there)
;   389                 sub edi,4
;   390                 push eax
;   391                 fild dword[esp]
;   392                 add esp,4
;   393                 call :%pStoreFlt    -- all registers preserved
;   394                 lea edi,[edi+4]
;   395                 jmp @f
;   396           ::opPeek4uItem
;   397             cmp edx,h4
;   398             jb @f
;   399                 mov [edi-4],ebx     -- 0 (for StoreFlt, since new AllocSeq contains garbage)
;   400                 sub edi,4
;   401                 push ebx
;   402                 push eax
;   403                 fild qword[esp]
;   404                 add esp,8
;   405                 call :%pStoreFlt
;   406                 lea edi,[edi+4]
;   407           @@:
;   408             sub ecx,1
;   409             jnz :opPeek4xLoop
;   410 
;   411         pop eax                 -- Newly allocated sequence
;   412         pop edi                 -- target addr
;   413 
;   414       ::Peek4sStore
;   415         mov edx,[edi]
;   416         add esp,4               -- discard peek4s/u flag
;   417         mov [edi],eax
;   418         cmp edx,h4
;   419         jle @f
;   420             sub dword[ebx+edx*4-8],1
;   421             jz :%pDealloc
;   422       @@:
;   423         ret
;   424     [64]
;   425         --calling convention
;   426         --  lea rdi,[p1]        -- target addr
;   427         --  mov rsi,[p2]        -- addr or {addr,len} (opUnassigned)
;   428         --  mov rcx,-1          -- opPeek4s
;   429         --  mov rcx,0           -- opPeek4u
;   430         mov r15,h4
;   431         push rcx
;   432         cmp rsi,r15
;   433         jl @f
;   434             cmp byte[rbx+rsi*4-1],0x12
;   435             jne :Peek4sSeq64
;   436             fld tbyte[rbx+rsi*4]
;   437             sub rsp,8
;   438             call :%down64
;   439             fistp qword[rsp]
;   440             call :%near64
;   441             pop rsi
;   442       @@:
;   443         xor rax,rax
;   444       :!opPeek4sMLE         -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   445         mov eax,dword[rsi]
;   446         cmp qword[rsp],0
;   447         je :Peek4sStore64
;   448         cdqe                -- (sign extend eax to rax)
;   449         jmp :Peek4sStore64
;   450 
;   451       ::Peek4sSeq64                     -- peek4x({addr,len}) case
;   452         push rdi                        -- target addr
;   453         cmp byte[rbx+rsi*4-1],0x80      -- sequence
;   454         jnz :e44atpmbaoso2a             -- argument to peek4 must be atom or sequence of 2 atoms
;   455         cmp qword[rbx+rsi*4-24],2       -- of length 2
;   456         jne :e44atpmbaoso2a             -- argument to peek4 must be atom or sequence of 2 atoms
;   457         mov rcx,[rbx+rsi*4+8]           -- len (ie p2[2])
;   458         cmp rcx,r15
;   459         jl @f
;   460             cmp byte[rbx+rcx*4-1],0x12
;   461             jne :e44atpmbaoso2a
;   462             fld tbyte[rbx+rcx*4]
;   463             sub rsp,8
;   464             call :%down64
;   465             fistp qword[rsp]
;   466             call :%near64
;   467             pop rcx
;   468       @@:
;   469         mov rsi,[rbx+rsi*4]             -- addr (ie p2[1])
;   470         cmp rsi,r15
;   471         jl @f
;   472             cmp byte[rbx+rsi*4-1],0x12
;   473             jne :e44atpmbaoso2a
;   474             fld tbyte[rbx+rsi*4]
;   475             sub rsp,8
;   476             call :%down64
;   477             fistp qword[rsp]
;   478             call :%near64
;   479             pop rsi
;   480       @@:
;   481         -- OK, len in rcx, and addr in rsi
;   482         --  era in edx???[DEV]
;   483         call :%pAllocSeq            -- damages rax only
;   484         test rcx,rcx
;   485         jz :Peek4sStore64
;   486         lea rdi,[rbx+rax*4]
;   487         push rax
;   488         xor rax,rax
;   489       ::opPeek4xLoop64
;   490       :!opPeek4ssMLE            -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   491             lodsd               -- mov eax,[rsi], rsi+=4
;   492             cmp dword[esp+8],0
;   493             je :opPeek4uItem64
;   494                 cdqe            -- (sign extend eax to rax)
;   495           ::opPeek4uItem64
;   496             stosq               -- (mov [rdi],rax; rdi+=8)
;   497                                 -- (will all be short ints:
;   498                                 --   #FFFFFFFF80000000 .. #000000007FFFFFFF for peek4s, 
;   499                                 --   #0000000000000000 .. #00000000FFFFFFFF for peek4u)
;   500             sub rcx,1
;   501             jnz :opPeek4xLoop64
;   502 
;   503         pop rax                 -- Newly allocated sequence
;   504         pop rdi                 -- target addr
;   505 
;   506       ::Peek4sStore64
;   507         mov rdx,[rdi]
;   508         add rsp,8               -- discard peek4s/u flag
;   509         mov [rdi],rax
;   510         cmp rdx,r15
;   511         jle @f
;   512             sub qword[rbx+rdx*4-16],1
;   513             jz :%pDealloc
;   514       @@:
;   515         ret
;   516     []
;   517 --*/
;   518 
;   519 --/*
;   520 procedure :%opPeekNx(:%)
;   521 end procedure -- (for Edita/CtrlQ)
;   522 --*/
;   523   :%opPeekNx
;   524 ------------
;   525     [32]
;   526         --calling convention
;   527         --  lea edi,[p1]        -- target addr
;   528         --  mov esi,[p2]        -- addr or {addr,len} (opUnassigned)
;   529         --  mov ecx,-1/0        -- signed/unsigned (-1 or 0)
;   530         --  mov edx,1/2/4/8     -- size (must be 1, 2, 4, or 8)
;   531         --  call :%opPeekNx
;   532         push edx
;   533         push ecx
;   534         cmp esi,h4  --DEV :%pLoadMint
;   535         jl @f
;   536             cmp byte[ebx+esi*4-1],0x12
;   537             jne :PeekNxSeq
;   538             fld qword[ebx+esi*4]
;   539             sub esp,8
;   540             call :%down53
;   541             fistp qword[esp]
;   542             call :%near53
;   543             mov esi,[esp]
;   544             add esp,8
;   545       @@:
;   546 
;   547         xor eax,eax
;   548         cmp edx,1
;   549         jne @f
;   550           :!opPeek1xMLE         -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   551             mov al,[esi]        -- (era @ [esp+8])
;   552             cmp dword[esp],0
;   553             je :opPeekNxStore
;   554             cbw                 -- (al -> ax)
;   555             cwde                -- (ax -> eax)
;   556             jmp :opPeekNxStore
;   557       @@:
;   558         cmp edx,2
;   559         jne @f
;   560           :!opPeek2xMLE         -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   561             mov ax,[esi]
;   562             cmp dword[esp],0
;   563             je :opPeekNuAtom
;   564             cwde                -- (ax -> eax)
;   565             jmp :opPeekNxStore
;   566       @@:
;   567         cmp edx,4
;   568         jne @f
;   569           :!opPeek4xMLE         -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   570             mov eax,[esi]
;   571             cmp dword[esp],0
;   572             je :opPeekNuAtom
;   573 --        ::opPeekNsAtom
;   574 --        ::opPeek4sAtom
;   575                 mov ecx,eax
;   576                 shl ecx,1           -- (this is a better test than cmp h4)
;   577                 jno :opPeekNxStore  -- store #C0000000..#3FFFFFFF (-1073741824..1073741823) in eax as short int
;   578 
;   579                 push eax
;   580                 fild dword[esp]
;   581                 add esp,12          -- (discard eax, sign flag, and size)
;   582                 jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
;   583 
;   584           ::opPeekNuAtom
;   585                 cmp eax,h4
;   586                 jb :opPeekNxStore   -- store unsigned 0..#3FFFFFFF (0..1073741823) in eax as short int
;   587                 push ebx
;   588                 push eax
;   589                 fild qword[esp]
;   590                 add esp,16          -- (discard qword, sign flag, and size)
;   591                 jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
;   592       @@:
;   593         cmp edx,8
;   594         jne :epeeksize
;   595 --        :!opPeek8xMLE         -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   596 --          cmp dword[esp+8],0
;   597             cmp dword[esp],0        -- signed?
;   598             je :opPeek8uItem
;   599 --            ::opPeek8sItem
;   600                   :!opPeek8xsMLE        -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   601                     fild qword[esi]
;   602                     jmp @f
;   603 
;   604               ::opPeek8uItem
;   605                   :!opPeek8xuMLE        -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   606                     mov eax,[esi]
;   607                     mov edx,[esi+4]
;   608                     -- to load unsigned, right shift edx:eax by 1, save odd bit in ecx, then *2+[0|1]
;   609                     mov ecx,ebx
;   610                     shr edx,1
;   611                     rcr eax,1
;   612                     rcl ecx,1
;   613                     push edx
;   614                     push eax
;   615                     push ecx
;   616                     fild dword[esp]
;   617                     fild qword[esp+4]
;   618                     add esp,12
;   619                     fadd st0,st0
;   620                     faddp
;   621                   @@:
;   622 --                  fist qword[esp] (oops, the hardware does not support this)
;   623                     fld st0
;   624                     fistp qword[esp]
;   625                     mov eax,[esp]
;   626                     mov edx,[esp+4]
;   627                     add esp,8
;   628                     cmp eax,[esi]
;   629                     jne @f
;   630                         cmp edx,[esi+4]
;   631                         je :%pStoreFlt  -- store result (invokes dealloc if needed)
;   632                   @@:
;   633                     sub esp,8           -- (put back sign/size space, for opPeekNxStorePop2 only, no matter if they got damaged)
;   634                     push edi            --[1]target addr (as per PeekNxSeq)
;   635                     mov eax,[esi]
;   636                     mov edx,[esi+4]
;   637                     fstp st0            -- discard
;   638                     push ebx
;   639                     push eax            -- {hi_dword,lo_dword} order
;   640                     fild qword[esp]
;   641                     mov [esp],edx
;   642                     fild qword[esp]
;   643                     add esp,8
;   644                     mov ecx,2
;   645                     mov edx,[esp+12]        -- era
;   646                     call :%pAllocSeq
;   647                     push eax            --[2] (as per opPeekNxLoop-1)
;   648                     mov [ebx+eax*4],ebx
;   649                     lea edi,[ebx+eax*4]
;   650                     call :%pStoreFlt
;   651                     mov [edi+4],ebx
;   652                     add edi,4
;   653                     call :%pStoreFlt
;   654                     jmp :opPeekNxStorePop2
;   655 
;   656       ::PeekNxSeq                       -- peek4x({addr,len}) case
;   657 -----------------
;   658         push edi                        -- [1]target addr
;   659         cmp byte[ebx+esi*4-1],0x80      -- sequence
;   660         jnz :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
;   661         cmp dword[ebx+esi*4-12],2       -- of length 2
;   662         jne :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
;   663         mov ecx,[ebx+esi*4+4]           -- len (ie p2[2])
;   664         cmp ecx,h4  --DEV :%pLoadMint
;   665         jl @f
;   666             cmp byte[ebx+ecx*4-1],0x12
;   667             jne :e43atpmbaoso2a
;   668             fld qword[ebx+ecx*4]
;   669             sub esp,8
;   670             call :%down53
;   671             fistp qword[esp]
;   672             call :%near53
;   673             mov ecx,[esp]
;   674             add esp,8
;   675       @@:
;   676         mov esi,[ebx+esi*4]             -- addr (ie p2[1])
;   677         cmp esi,h4 --DEV :%pLoadMint
;   678         jl @f
;   679             cmp byte[ebx+esi*4-1],0x12
;   680             jne :e43atpmbaoso2a
;   681             fld qword[ebx+esi*4]
;   682             sub esp,8
;   683             call :%down53
;   684             fistp qword[esp]
;   685             call :%near53
;   686             mov esi,[esp]
;   687             add esp,8
;   688       @@:
;   689         -- OK, len in ecx, and addr in esi
;   690         cmp dword[esp+4],0              -- if unsigned..
;   691         jne @f
;   692             cmp dword[esp+8],1          --    ..bytes (ie opPeek aka opPeek1u)
;   693             jne @f
;   694                 call :%pAllocStr        --           .. then a string will be fine
;   695                 mov [ecx+eax*4],bl      --  plant the terminating 0 now
;   696                 jmp :opPeekNxTestEcx
;   697       @@:
;   698         mov edx,[esp+12]                -- era
;   699         call :%pAllocSeq                -- damages eax only
;   700       ::opPeekNxTestEcx
;   701         test ecx,ecx
;   702 --23/5/15
;   703 --      jz :opPeekNxStore
;   704         jnz @f
;   705             add esp,4                   --[1] aka pop edi
;   706             jmp :opPeekNxStore
;   707       @@:
;   708         lea edi,[ebx+eax*4]
;   709         push eax                        --[2]
;   710       ::opPeekNxLoop
;   711             mov edx,[esp+12]            -- size (1/2/4/8)
;   712             cmp edx,1
;   713             jne @f
;   714               :!opPeek1xsMLE            -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   715                 lodsb                   -- (era @ [esp+16])
;   716                 cmp dword[esp+8],0      -- sign (0=unsigned, -1=signed)
;   717                 je :opPeek1us
;   718                     cbw                 -- (al -> ax)
;   719                     cwde                -- (ax -> eax)
;   720                     stosd
;   721                     jmp :opPeekNxsNxt
;   722               ::opPeek1us
;   723 --                  and eax,#FF -- (no need)
;   724                     stosb
;   725                     jmp :opPeekNxsNxt
;   726           @@:
;   727             cmp edx,2
;   728             jne @f
;   729               :!opPeek2xsMLE            -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   730                 lodsw
;   731                 and eax,#FFFF
;   732                 cmp dword[esp+8],0
;   733                 je :opPeek2us
;   734                     cwde                -- (ax -> eax)
;   735               ::opPeek2us
;   736                 stosd
;   737                 jmp :opPeekNxsNxt
;   738           @@:
;   739             cmp edx,4
;   740             jne @f
;   741               :!opPeek4xsMLE            -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   742                 lodsd                   -- mov eax,[esi], esi+=4
;   743                 mov edx,eax
;   744                 stosd                   -- store short ints #C0000000 .. #3FFFFFFF (-1073741824..1073741823) direct
;   745                                         -- (mov [edi],eax; edi+=4)
;   746                 cmp dword[esp+8],0
;   747                 je :opPeek4usItem
;   748 --            ::opPeek4sItem
;   749                     shl edx,1
;   750                     jno :opPeekNxsNxt
;   751                     mov [edi-4],ebx         -- 0 (for StoreFlt, cleanup mess we just put there)
;   752                     sub edi,4
;   753                     push eax
;   754                     fild dword[esp]
;   755                     add esp,4
;   756                     call :%pStoreFlt        -- all registers preserved
;   757                     lea edi,[edi+4]
;   758                     jmp :opPeekNxsNxt
;   759               ::opPeek4usItem
;   760                     cmp edx,h4
;   761                     jb :opPeekNxsNxt
;   762                     mov [edi-4],ebx         -- 0 (for StoreFlt, since new AllocSeq contains garbage)
;   763                     sub edi,4
;   764                     push ebx
;   765                     push eax
;   766                     fild qword[esp]
;   767                     add esp,8
;   768                     call :%pStoreFlt
;   769                     lea edi,[edi+4]
;   770                     jmp :opPeekNxsNxt
;   771           @@:
;   772             cmp edx,8
;   773             jne :epeeksize
;   774                 cmp dword[esp+8],0
;   775                 je :opPeek8usItem
;   776 --            ::opPeek8ssItem
;   777                   :!opPeek8xsMLE2           -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   778                     fild qword[esi]
;   779                     jmp @f
;   780 --pop al -- check for precision loss...
;   781 ----also, we forgot edi, and [edi]
;   782 --                  call :%pStoreFlt        -- all registers preserved
;   783 --                  add esi,8
;   784 --                  jmp :opPeekNxsNxt
;   785               ::opPeek8usItem
;   786                   :!opPeek8xuMLE2           -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;   787                     push ecx                --[1]
;   788                     mov eax,[esi]
;   789                     mov edx,[esi+4]
;   790                     -- to load unsigned, right shift edx:eax by 1, saving odd bit in ecx, then *2 + that[0|1]:
;   791                     mov ecx,ebx
;   792                     shr edx,1
;   793                     rcr eax,1
;   794                     rcl ecx,1
;   795                     push edx
;   796                     push eax
;   797                     push ecx
;   798                     fild dword[esp]
;   799                     fild qword[esp+4]
;   800                     add esp,12
;   801                     fadd st0,st0
;   802                     pop ecx                 --[1]
;   803                     faddp
;   804                   @@:
;   805                     mov [edi],ebx       -- 0 (for StoreFlt, since new AllocSeq contains garbage)
;   806                     -- check for precision loss (not needed on 64-bit!)
;   807                     sub esp,8
;   808 --                  fist qword[esp] (oops, the hardware does not support this)
;   809                     fld st0
;   810                     fistp qword[esp]
;   811                     mov eax,[esp]
;   812                     mov edx,[esp+4]
;   813                     add esp,8
;   814                     cmp eax,[esi]
;   815                     jne @f
;   816                     cmp edx,[esi+4]
;   817                     jne @f
;   818                         call :%pStoreFlt
;   819                         add esi,8
;   820                         add edi,4
;   821                         jmp :opPeekNxsNxt
;   822                   @@:
;   823                     add edi,4           -- next ([edi-4] stored below)
;   824                     mov eax,[esi]
;   825                     mov edx,[esi+4]
;   826                     fstp st0            -- discard
;   827                     push edi            ---[1]
;   828                     push ebx
;   829                     push eax            -- {hi_dword,lo_dword} order
;   830                     fild qword[esp]
;   831                     mov [esp],edx
;   832                     fild qword[esp]
;   833                     add esp,8
;   834                     push ecx            --[2]
;   835                     mov ecx,2
;   836                     mov edx,[esp+16]    -- era
;   837                     call :%pAllocSeq    -- damages eax only
;   838                     mov [edi-4],eax
;   839                     lea edi,[ebx+eax*4]
;   840                     mov [ebx+eax*4],ebx
;   841                     call :%pStoreFlt
;   842                     mov [edi+4],ebx
;   843                     add edi,4
;   844                     call :%pStoreFlt
;   845                     add esi,8
;   846                     pop ecx             --[2]
;   847                     pop edi             --[1]
;   848 
;   849           ::opPeekNxsNxt
;   850             sub ecx,1
;   851             jnz :opPeekNxLoop
;   852 
;   853       ::opPeekNxStorePop2
;   854         pop eax                 -- [2]Newly allocated sequence
;   855         pop edi                 -- [1]target addr
;   856 
;   857       ::opPeekNxStore
;   858         mov edx,[edi]
;   859         add esp,8               -- discard sign flag and size
;   860         mov [edi],eax
;   861         cmp edx,h4
;   862         jle @f
;   863             sub dword[ebx+edx*4-8],1
;   864             jz :%pDealloc
;   865       @@:
;   866         ret
;   867     [64]
;   868         --calling convention
;   869         --  lea rdi,[p1]        -- target addr
;   870         --  mov rsi,[p2]        -- addr or {addr,len} (opUnassigned)
;   871         --  mov rcx,-1/0        -- signed/unsigned (-1 or 0)
;   872         --  mov rdx,1/2/4/8     -- size (must be 1, 2, 4, or 8)
;   873         --  call :%opPeekNx
;   874         mov r15,h4
                mov r15,h4                ;#0043ED6C: 49:277 0000000000000040    uv 8000 00  1 168      
;   875         push rdx
                push rdx                  ;#0043ED76: 48:122                     vu 00 04  1 168      
;   876         push rcx
                push rcx                  ;#0043ED78: 48:121                     uv 00 02  1 169      
;   877         cmp rsi,r15
                cmp rsi,r15               ;#0043ED7A: 49:073367                  vu 00 8040  1 169      
;   878         jl @f
                jl #0043EDA0              ;#0043ED7D: 174 21                     v  00 00  1 170      
;   879             cmp byte[rbx+rsi*4-1],0x12
                    cmp byte[rbx+rsi*4-1],#12  ;#0043ED7F: 200174263 FF 12            u  00 48  2 171      
;   880             jne :PeekNxSeq64
                    jne #0043EE45         ;#0043ED84: 017205 BB000000            v  00 00  1 172      
;   881             fld tbyte[rbx+rsi*4]
                    fld tbyte[rbx+rsi*4]  ;#0043ED8A: 333054263                  np 00 48  3 173      
;   882             sub rsp,8
                    sub rsp,8             ;#0043ED8D: 48:203354 08               uv 10 10  1 176      
;   883             call :%down64
                    call #0044139E (:%down64)  ;#0043ED91: 350 08260000               v  00 00  1 176      
;   884             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043ED96: 337074044                  np 00 10  6 179    *10*
;   885             call :%near64
                    call #004413A5 (:%near64)  ;#0043ED99: 350 07260000               v  00 00  1 185      
;   886             pop rsi
                    pop rsi               ;#0043ED9E: 48:136                     uv 40 00  1 186      
;   887       @@:
;   888 
;   889         xor rax,rax
                xor rax,rax               ;#0043EDA0: 48:061300                  vu 01 01  1 186      
;   890         cmp rdx,1
                cmp rdx,1                 ;#0043EDA3: 48:203372 01               uv 00 04  1 187      
;   891         jne @f
                jne #0043EDC0             ;#0043EDA7: 165 17                     v  00 00  1 187      
;   892           :!opPeek1xMLE64           -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   893             mov al,[rsi]            -- (era @ [rsp+16])
                    mov al,[esi]          ;#0043EDA9: 212006                     uv 01 40  1 188      
;   894             cmp qword[rsp],0
                    cmp qword[rsp],0      ;#0043EDAB: 48:203074044 00            vu 00 10  2 188      
;   895             je :opPeekNxStore64
                    je #0043EF88          ;#0043EDB0: 017204 D2010000            v  00 00  1 189      
;   896             cbw                     -- (al -> ax)
                    cbw                   ;#0043EDB6: 146:230                    np 01 01  3 190      
;   897             cwde                    -- (ax -> eax)
                    cwde                  ;#0043EDB8: 230                        np 01 01  3 193      
;   898             cdqe                    -- (sign extend eax to rax)
                    cdqe                  ;#0043EDB9: 48:230                     np 01 01  3 196      
;   899             jmp :opPeekNxStore64
                    jmp #0043EF88         ;#0043EDBB: 351 C8010000               v  00 00  1 199      
;   900       @@:
;   901         cmp rdx,2
                cmp rdx,2                 ;#0043EDC0: 48:203372 02               uv 00 04  1 200      
;   902         jne @f
                jne #0043EDDC             ;#0043EDC4: 165 16                     v  00 00  1 200      
;   903           :!opPeek2xMLE64           -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   904             mov ax,[rsi]
                    mov ax,word[esi]      ;#0043EDC6: 146:213006                 uv 01 40  1 201      
;   905             cmp qword[rsp],0
                    cmp qword[rsp],0      ;#0043EDC9: 48:203074044 00            vu 00 10  2 201      
;   906             je :opPeekNxStore64
                    je #0043EF88          ;#0043EDCE: 017204 B4010000            v  00 00  1 202      
;   907             cwde                    -- (ax -> eax)
                    cwde                  ;#0043EDD4: 230                        np 01 01  3 203      
;   908             cdqe                    -- (sign extend eax to rax)
                    cdqe                  ;#0043EDD5: 48:230                     np 01 01  3 206      
;   909             jmp :opPeekNxStore64
                    jmp #0043EF88         ;#0043EDD7: 351 AC010000               v  00 00  1 209      
;   910       @@:
;   911         cmp rdx,4
                cmp rdx,4                 ;#0043EDDC: 48:203372 04               uv 00 04  1 210      
;   912         jne @f
                jne #0043EDF5             ;#0043EDE0: 165 13                     v  00 00  1 210      
;   913           :!opPeek4xMLE64           -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   914             mov eax,[rsi]
                    mov eax,[esi]         ;#0043EDE2: 213006                     uv 01 40  1 211      
;   915             cmp dword[rsp],0
                    cmp dword[rsp],0      ;#0043EDE4: 203074044 00               vu 00 10  2 211      
;   916             je :opPeekNxStore64
                    je #0043EF88          ;#0043EDE8: 017204 9A010000            v  00 00  1 212      
;   917             cdqe                    -- (sign extend eax to rax)
                    cdqe                  ;#0043EDEE: 48:230                     np 01 01  3 213      
;   918             jmp :opPeekNxStore64
                    jmp #0043EF88         ;#0043EDF0: 351 93010000               v  00 00  1 216      
;   919 --?             mov ecx,eax
;   920 --              shl ecx,1           -- (this is a better test than cmp h4)
;   921 --              jno :opPeekNxStore  -- store #C0000000..#3FFFFFFF (-1073741824..1073741823) in eax as short int
;   922 
;   923 --              push eax
;   924 --              fild dword[esp]
;   925 --              add esp,12          -- (discard eax, sign flag, and size)
;   926 --              jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
;   927 
;   928 --?       ::opPeekNuAtom64
;   929 --              cmp rax,r15
;   930 --              jb :opPeekNxStore64 -- store unsigned 0..#3FFFFFFFFFFFFFFF in rax as short int
;   931 --              push rbx
;   932 --              fild qword[rsp]
;   933 --              add rsp,16          -- (discard qword, sign flag, and size)
;   934 --              jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
;   935       @@:
;   936         cmp rdx,8
                cmp rdx,8                 ;#0043EDF5: 48:203372 08               uv 00 04  1 217      
;   937         jne :epeeksize
                jne #0043ED39             ;#0043EDF9: 017205 3AFFFFFF            v  00 00  1 217      
;   938           :!opPeek8xMLE64           -- exception here mapped to e99ipmaespp4feh (invalid peek memory address)
;   939             mov rax,[rsi]
                    mov rax,[rsi]         ;#0043EDFF: 48:213006                  uv 01 40  1 218      
;   940 --          cmp dword[esp+8],0
;   941             cmp qword[rsp],0        -- signed?
                    cmp qword[rsp],0      ;#0043EE02: 48:203074044 00            vu 00 10  2 218      
;   942             je :opPeek8uItem64
                    je #0043EE20          ;#0043EE07: 164 17                     v  00 00  1 219      
;   943 --            ::opPeek8sItem64
;   944                 mov rcx,rax
                        mov rcx,rax       ;#0043EE09: 48:213310                  uv 02 01  1 220      
;   945                 shl rcx,1               -- (this is a better test than cmp h4)
                        shl rcx,1         ;#0043EE0C: 48:321341                  u  02 02  1 221      
;   946                 jno :opPeekNxStore64    -- store #C00000000000000..#3FFFFFFFFFFFFFFF in rax as short int
                        jno #0043EF88     ;#0043EE0F: 017201 73010000            v  00 00  1 221      
;   947 
;   948                 fild qword[esi]
                        fild qword[rsi]   ;#0043EE15: 337056                     np 00 40  3 222      
;   949 --              jmp @f
;   950                 add rsp,16
                        add rsp,16        ;#0043EE17: 48:203304 10               uv 10 10  1 225      
;   951                 jmp :%pStoreFlt
                        jmp #004421B0 (:%pStoreFlt)  ;#0043EE1B: 351 90330000               v  00 00  1 225      
;   952 
;   953           ::opPeek8uItem64
;   954                 -- to load unsigned, right shift rax by 1, save odd bit in rcx, then *2+[0|1]
;   955                 mov rcx,rbx
                        mov rcx,rbx       ;#0043EE20: 48:213313                  uv 02 08  1 226      
;   956                 shr rax,1
                        shr rax,1         ;#0043EE23: 48:321350                  u  01 01  1 227      
;   957                 rcl rcx,1
                        rcl rcx,1         ;#0043EE26: 48:321321                  u  02 02  1 228      
;   958                 push rax
                        push rax          ;#0043EE29: 48:120                     vu 00 01  1 228      
;   959                 push rcx
                        push rcx          ;#0043EE2B: 48:121                     uv 00 02  1 229      
;   960                 fild qword[rsp]
                        fild qword[rsp]   ;#0043EE2D: 337054044                  np 00 10  3 230      
;   961                 fild qword[rsp+8]
                        fild qword[rsp+8]  ;#0043EE30: 337154044 08               np 00 10  3 233      
;   962                 add rsp,16
                        add rsp,16        ;#0043EE34: 48:203304 10               uv 10 10  1 236      
;   963                 fadd st0,st0
                        fadd st0,st0      ;#0043EE38: 330300                     np 00 00  3 237      
;   964                 faddp
                        faddp st1,st0     ;#0043EE3A: 336301                     np 00 00  3 240      
;   965 --            @@:
;   966 --              fist qword[rsp] (oops, the hardware does not support this)
;   967 --              fld st0
;   968 --              fistp qword[rsp]
;   969 --              mov rax,[rsp]
;   970                 add rsp,16
                        add rsp,16        ;#0043EE3C: 48:203304 10               uv 10 10  1 243      
;   971 --              cmp rax,[rsi]
;   972 --              je :%pStoreFlt      -- store result (invokes dealloc if needed)
;   973                 jmp :%pStoreFlt     -- store result (invokes dealloc if needed)
                        jmp #004421B0 (:%pStoreFlt)  ;#0043EE40: 351 6B330000               v  00 00  1 243      
;   974 
;   975       ::PeekNxSeq64                     -- peekNx({addr,len}) case
;   976 -----------------
;   977         push rdi                        -- [1]target addr
                push rdi                  ;#0043EE45: 48:127                     uv 00 80  1 244      
;   978         cmp byte[rbx+rsi*4-1],0x80      -- sequence
                cmp byte[rbx+rsi*4-1],#80  ;#0043EE47: 200174263 FF 80            u  00 48  2 245      
;   979         jnz :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
                jnz #0043ED30             ;#0043EE4C: 017205 DEFEFFFF            v  00 00  1 246      
;   980         cmp qword[rbx+rsi*4-24],2       -- of length 2
                cmp qword[rbx+rsi*4-24],2  ;#0043EE52: 48:203174263 E8 02         u  00 48  2 247      
;   981         jne :e43atpmbaoso2a             -- argument to peek must be atom or sequence of 2 atoms
                jne #0043ED30             ;#0043EE58: 017205 D2FEFFFF            v  00 00  1 248      
;   982         mov rcx,[rbx+rsi*4+8]           -- len (ie p2[2])
                mov rcx,[rbx+rsi*4+8]     ;#0043EE5E: 48:213114263 08            uv 02 48  1 249      
;   983         cmp rcx,r15
                cmp rcx,r15               ;#0043EE63: 49:073317                  uv 00 8002  1 250 02   
;   984         jl @f
                jl #0043EE89              ;#0043EE66: 174 21                     v  00 00  1 250      
;   985             cmp byte[rbx+rcx*4-1],0x12
                    cmp byte[rbx+rcx*4-1],#12  ;#0043EE68: 200174213 FF 12            u  00 0A  2 251      
;   986             jne :e43atpmbaoso2a
                    jne #0043ED30         ;#0043EE6D: 017205 BDFEFFFF            v  00 00  1 252      
;   987             fld tbyte[rbx+rcx*4]
                    fld tbyte[rbx+rcx*4]  ;#0043EE73: 333054213                  np 00 0A  3 253      
;   988             sub rsp,8
                    sub rsp,8             ;#0043EE76: 48:203354 08               uv 10 10  1 256      
;   989             call :%down64
                    call #0044139E (:%down64)  ;#0043EE7A: 350 1F250000               v  00 00  1 256      
;   990             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043EE7F: 337074044                  np 00 10  6 259    *10*
;   991             call :%near64
                    call #004413A5 (:%near64)  ;#0043EE82: 350 1E250000               v  00 00  1 265      
;   992             pop rcx
                    pop rcx               ;#0043EE87: 48:131                     uv 02 00  1 266      
;   993       @@:
;   994         mov rsi,[rbx+rsi*4]             -- addr (ie p2[1])
                mov rsi,[rbx+rsi*4]       ;#0043EE89: 48:213064263               vu 40 48  1 266      
;   995         cmp rsi,r15
                cmp rsi,r15               ;#0043EE8D: 49:073367                  uv 00 8040  1 267      
;   996         jl @f
                jl #0043EEB3              ;#0043EE90: 174 21                     v  00 00  1 267      
;   997             cmp byte[rbx+rsi*4-1],0x12
                    cmp byte[rbx+rsi*4-1],#12  ;#0043EE92: 200174263 FF 12            u  00 48  2 268      
;   998             jne :e43atpmbaoso2a
                    jne #0043ED30         ;#0043EE97: 017205 93FEFFFF            v  00 00  1 269      
;   999             fld tbyte[rbx+rsi*4]
                    fld tbyte[rbx+rsi*4]  ;#0043EE9D: 333054263                  np 00 48  3 270      
;  1000             sub rsp,8
                    sub rsp,8             ;#0043EEA0: 48:203354 08               uv 10 10  1 273      
;  1001             call :%down64
                    call #0044139E (:%down64)  ;#0043EEA4: 350 F5240000               v  00 00  1 273      
;  1002             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043EEA9: 337074044                  np 00 10  6 276    *10*
;  1003             call :%near64
                    call #004413A5 (:%near64)  ;#0043EEAC: 350 F4240000               v  00 00  1 282      
;  1004             pop rsi
                    pop rsi               ;#0043EEB1: 48:136                     uv 40 00  1 283      
;  1005       @@:
;  1006         -- OK, len in rcx, and addr in rsi
;  1007         cmp qword[rsp+8],0              -- if unsigned..
                cmp qword[rsp+8],0        ;#0043EEB3: 48:203174044 08 00         u  00 10  2 284      
;  1008         jne @f
                jne #0043EECD             ;#0043EEB9: 165 12                     v  00 00  1 285      
;  1009             cmp qword[rsp+16],1         --    ..bytes (ie opPeek aka opPeek1u)
                    cmp qword[rsp+16],1   ;#0043EEBB: 48:203174044 10 01         u  00 10  2 286      
;  1010             jne @f
                    jne #0043EECD         ;#0043EEC1: 165 0A                     v  00 00  1 287      
;  1011                 call :%pAllocStr        --           .. then a string will be fine
                        call #004420E3 (:%pAllocStr)  ;#0043EEC3: 350 1B320000               v  00 00  1 288      
;  1012                 mov [rcx+rax*4],bl      --  plant the terminating 0 now
                        mov [rcx+rax*4],bl  ;#0043EEC8: 210034201                  uv 00 0B  1 289      
;  1013                 jmp :opPeekNxTestRcx
                        jmp #0043EED7     ;#0043EECB: 353 0A                     v  00 00  1 289      
;  1014       @@:
;  1015         mov rdx,[rsp+24]                -- era
                mov rdx,[rsp+24]          ;#0043EECD: 48:213124044 18            uv 04 10  1 290      
;  1016         call :%pAllocSeq                -- damages rax only
                call #00442148 (:%pAllocSeq)  ;#0043EED2: 350 71320000               v  00 00  1 290      
;  1017       ::opPeekNxTestRcx
;  1018         test rcx,rcx
                test rcx,rcx              ;#0043EED7: 48:205311                  uv 00 02  1 291      
;  1019 --23/5/15:
;  1020 --      jz :opPeekNxStore64
;  1021         jnz @f
                jnz #0043EEE5             ;#0043EEDA: 165 09                     v  00 00  1 291      
;  1022             sub rsp,8                   --[1] aka pop rdi
                    sub rsp,8             ;#0043EEDC: 48:203354 08               uv 10 10  1 292      
;  1023             jmp :opPeekNxStore64
                    jmp #0043EF88         ;#0043EEE0: 351 A3000000               v  00 00  1 292      
;  1024       @@:
;  1025         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#0043EEE5: 48:215074203               uv 80 09  1 293      
;  1026         push rax                        --[2]
                push rax                  ;#0043EEE9: 48:120                     vu 00 01  1 293      
;  1027       ::opPeekNxLoop64
;  1028             mov rdx,[rsp+24]            -- size (1/2/4/8)
                    mov rdx,[rsp+24]      ;#0043EEEB: 48:213124044 18            uv 04 10  1 294      
;  1029             xor rax,rax
                    xor rax,rax           ;#0043EEF0: 48:061300                  vu 01 01  1 294      
;  1030             cmp rdx,1
                    cmp rdx,1             ;#0043EEF3: 48:203372 01               uv 00 04  1 295      
;  1031             jne @f
                    jne #0043EF0E         ;#0043EEF7: 165 15                     v  00 00  1 295      
;  1032               :!opPeek1xsMLE64          -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;  1033                 lodsb                   -- (era @ [rsp+32])
                        lodsb             ;#0043EEF9: 254                        np 41 40  2 296      
;  1034                 cmp qword[rsp+16],0     -- sign (0=unsigned, -1=signed)
                        cmp qword[rsp+16],0  ;#0043EEFA: 48:203174044 10 00         u  00 10  2 298      
;  1035                 je :opPeek1us64
                        je #0043EF0B      ;#0043EF00: 164 09                     v  00 00  1 299      
;  1036                     cbw                 -- (al -> ax)
                            cbw           ;#0043EF02: 146:230                    np 01 01  3 300      
;  1037                   ::opPeek2ss64
;  1038                     cwde                -- (ax -> eax)
                            cwde          ;#0043EF04: 230                        np 01 01  3 303      
;  1039                   ::opPeek4ss64
;  1040                     cdqe                -- (sign extend eax to rax)
                            cdqe          ;#0043EF05: 48:230                     np 01 01  3 306      
;  1041                     stosq
                            stosq         ;#0043EF07: 48:253                     np 80 81  3 309      
;  1042                     jmp :opPeekNxsNxt64
                            jmp #0043EF7A  ;#0043EF09: 353 6F                     v  00 00  1 312      
;  1043               ::opPeek1us64
;  1044                     stosb
                            stosb         ;#0043EF0B: 252                        np 80 81  3 315    *80*
;  1045                     jmp :opPeekNxsNxt64
                            jmp #0043EF7A  ;#0043EF0C: 353 6C                     v  00 00  1 318      
;  1046           @@:
;  1047             cmp rdx,2
                    cmp rdx,2             ;#0043EF0E: 48:203372 02               uv 00 04  1 319      
;  1048             jne @f
                    jne #0043EF22         ;#0043EF12: 165 0E                     v  00 00  1 319      
;  1049               :!opPeek2xsMLE64          -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;  1050                 lodsw
                        lodsw             ;#0043EF14: 146:255                    np 41 40  2 320      
;  1051                 cmp qword[rsp+16],0
                        cmp qword[rsp+16],0  ;#0043EF16: 48:203174044 10 00         u  00 10  2 322      
;  1052                 jne :opPeek2ss64
                        jne #0043EF04     ;#0043EF1C: 165 E6                     v  00 00  1 323      
;  1053                 stosq
                        stosq             ;#0043EF1E: 48:253                     np 80 81  3 324      
;  1054                 jmp :opPeekNxsNxt64
                        jmp #0043EF7A     ;#0043EF20: 353 58                     v  00 00  1 327      
;  1055           @@:
;  1056             cmp rdx,4
                    cmp rdx,4             ;#0043EF22: 48:203372 04               uv 00 04  1 328      
;  1057             jne @f
                    jne #0043EF35         ;#0043EF26: 165 0D                     v  00 00  1 328      
;  1058               :!opPeek4xsMLE64          -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;  1059                 lodsd                   -- mov eax,[rsi], rsi+=4
                        lodsd             ;#0043EF28: 255                        np 41 40  2 329      
;  1060                 cmp qword[rsp+16],0
                        cmp qword[rsp+16],0  ;#0043EF29: 48:203174044 10 00         u  00 10  2 331      
;  1061                 jne :opPeek4ss64
                        jne #0043EF05     ;#0043EF2F: 165 D4                     v  00 00  1 332      
;  1062                 stosq
                        stosq             ;#0043EF31: 48:253                     np 80 81  3 333      
;  1063                 jmp :opPeekNxsNxt64
                        jmp #0043EF7A     ;#0043EF33: 353 45                     v  00 00  1 336      
;  1064           @@:
;  1065             cmp rdx,8
                    cmp rdx,8             ;#0043EF35: 48:203372 08               uv 00 04  1 337      
;  1066             jne :epeeksize
                    jne #0043ED39         ;#0043EF39: 017205 FAFDFFFF            v  00 00  1 337      
;  1067                 cmp qword[rsp+16],0
                        cmp qword[rsp+16],0  ;#0043EF3F: 48:203174044 10 00         u  00 10  2 338      
;  1068                 je :opPeek8usItem64
                        je #0043EF4B (:!opPeek8xuMLE264)  ;#0043EF45: 164 04                     v  00 00  1 339      
;  1069 --            ::opPeek8ssItem64
;  1070                   :!opPeek8xsMLE264     -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;  1071                     fild qword[esi]
                            fild qword[rsi]  ;#0043EF47: 337056                     np 00 40  3 340      
;  1072                     jmp @f
                            jmp #0043EF6C  ;#0043EF49: 353 21                     v  00 00  1 343      
;  1073 --                  mov [edi],rbx
;  1074 --                  call :%pStoreFlt    -- all registers preserved
;  1075 --                  add esi,8
;  1076 --                  add edi,8
;  1077 --                  jmp :opPeekNxsNxt64
;  1078               ::opPeek8usItem64
;  1079                   :!opPeek8xuMLE264     -- exception here mapped to e99ipmaespp8feh (invalid peek memory address)
;  1080                     push rcx            --[3]
                            push rcx      ;#0043EF4B: 48:121                     uv 00 02  1 344      
;  1081                     mov rax,[rsi]
                            mov rax,[rsi]  ;#0043EF4D: 48:213006                  vu 01 40  1 344      
;  1082                     -- to load unsigned, right shift rax by 1, saving odd bit in rcx, then *2 + that[0|1]:
;  1083                     mov rcx,rbx
                            mov rcx,rbx   ;#0043EF50: 48:213313                  uv 02 08  1 345      
;  1084                     shr rax,1
                            shr rax,1     ;#0043EF53: 48:321350                  u  01 01  1 346      
;  1085                     rcl rcx,1
                            rcl rcx,1     ;#0043EF56: 48:321321                  u  02 02  1 347      
;  1086                     push rax
                            push rax      ;#0043EF59: 48:120                     vu 00 01  1 347      
;  1087                     push rcx
                            push rcx      ;#0043EF5B: 48:121                     uv 00 02  1 348      
;  1088                     fild qword[rsp]
                            fild qword[rsp]  ;#0043EF5D: 337054044                  np 00 10  3 349      
;  1089                     fild qword[rsp+8]
                            fild qword[rsp+8]  ;#0043EF60: 337154044 08               np 00 10  3 352      
;  1090                     add esp,16
                            add esp,16    ;#0043EF64: 203304 10                  uv 10 10  1 355      
;  1091                     fadd st0,st0
                            fadd st0,st0  ;#0043EF67: 330300                     np 00 00  3 356      
;  1092                     pop ecx             --[3]
                            pop rcx       ;#0043EF69: 131                        uv 02 00  1 359      
;  1093                     faddp
                            faddp st1,st0  ;#0043EF6A: 336301                     np 00 00  3 360      
;  1094                   @@:
;  1095                     mov [rdi],rbx   -- 0 (for StoreFlt, since new AllocSeq contains garbage)
                            mov [rdi],rbx  ;#0043EF6C: 48:211037                  uv 00 88  1 363      
;  1096                     call :%pStoreFlt
                            call #004421B0 (:%pStoreFlt)  ;#0043EF6F: 350 3C320000               v  00 00  1 363      
;  1097                     add esi,8
                            add esi,8     ;#0043EF74: 203306 08                  uv 40 40  1 364      
;  1098                     add edi,8
                            add edi,8     ;#0043EF77: 203307 08                  vu 80 80  1 364      
;  1099 
;  1100           ::opPeekNxsNxt64
;  1101             sub rcx,1
                    sub rcx,1             ;#0043EF7A: 48:203351 01               uv 02 02  1 365      
;  1102             jnz :opPeekNxLoop64
                    jnz #0043EEEB         ;#0043EF7E: 017205 67FFFFFF            v  00 00  1 365      
;  1103 
;  1104         pop rax                 -- [2]Newly allocated sequence
                pop rax                   ;#0043EF84: 48:130                     uv 01 00  1 366      
;  1105         pop rdi                 -- [1]target addr
                pop rdi                   ;#0043EF86: 48:137                     vu 80 00  1 366      
;  1106 
;  1107       ::opPeekNxStore64
;  1108         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043EF88: 48:213027                  uv 04 80  1 369    *80*
;  1109         add rsp,16              -- discard sign flag and size
                add rsp,16                ;#0043EF8B: 48:203304 10               vu 10 10  1 369      
;  1110         mov [rdi],rax
                mov [rdi],rax             ;#0043EF8F: 48:211007                  uv 00 81  1 370      
;  1111         cmp rdx,r15
                cmp rdx,r15               ;#0043EF92: 49:073327                  vu 00 8004  1 370      
;  1112         jle @f
                jle #0043EFA3             ;#0043EF95: 176 0C                     v  00 00  1 371      
;  1113             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043EF97: 48:203154223 F0 01         u  00 0C  3 372      
;  1114             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043EF9D: 017204 37330000            v  00 00  1 374      
;  1115       @@:
;  1116         ret
                ret                       ;#0043EFA3: 303                        np 00 00  2 375      
;  1117     []
;  1118 
;  1119 --/*
;  1120 procedure :%opPokeNS(:%)
;  1121 end procedure -- (for Edita/CtrlQ)
;  1122 --*/
;  1123 --/*
;  1124   :%opPokeNS    -- (additional safety checks)
;  1125 -----------
;  1126     [32]
;  1127         --calling convention as per opPokeN, plus
;  1128         --  mov esi,[offset]    -- (opUnassigned)
;  1129         cmp edi,h4              -- base
;  1130         jl @f
;  1131             cmp byte[ebx+edi*4-1],0x12
;  1132             jne :e42fatp4mba        -- first argument to poke4 must be atom
;  1133             fld qword[ebx+edi*4]
;  1134             sub esp,8
;  1135             call :%down53
;  1136             fistp qword[esp]
;  1137             call :%near53
;  1138             mov edi,[esp]
;  1139             add esp,8
;  1140       @@:
;  1141         cmp esi,h4              -- offset
;  1142         jl @f
;  1143             cmp byte[ebx+esi*4-1],0x12
;  1144 --          jne :PokeNSerror
;  1145             fld qword[ebx+eax*4]
;  1146             sub esp,8
;  1147 --          call :%down53
;  1148             call :%trunc53
;  1149             fistp qword[esp]
;  1150             call :%near53
;  1151             mov esi,[esp]
;  1152             add esp,8
;  1153       @@:
;  1154         push ecx
;  1155         push esi
;  1156         mov esi,[edi-8]             -- pRoot
;  1157         test esi,#01
;  1158         jz :!opPokeNSmagic
;  1159             int3
;  1160       :!opPokeNSmagic
;  1161         cmp dword[esi],#00484253    -- dwMagic ("SBH\0")
;  1162         je @f
;  1163       @@:
;  1164 --      mov esi,[edi-4]             -- nSize
;  1165         cmp eax,h4                  -- value
;  1166         jl @f
;  1167             cmp byte[ebx+eax*4-1],0x12
;  1168             jne @f
;  1169             push eax
;  1170             push edx
;  1171             mov eax,[ebx+eax*4-12]  -- length
;  1172             xor edx,edx
;  1173             imul ecx
;  1174             mov ecx,eax
;  1175             pop edx
;  1176             pop eax
;  1177       @@:
;  1178         add ecx,[esp]               -- + offset
;  1179         cmp ecx,[edi-4]
;  1180 --      ja :!opPokeNSfatal
;  1181         jbe @f
;  1182             int3
;  1183       @@:
;  1184         pop esi                     -- offset
;  1185         pop ecx                     -- 1/2/4/8
;  1186         add edi,esi
;  1187         jmp :opPokeNediset
;  1188     [64]
;  1189         pop al
;  1190     []
;  1191 --*/
;  1192 --/*
;  1193 procedure :%opPokeN(:%)
;  1194 end procedure -- (for Edita/CtrlQ)
;  1195 --*/
;  1196   :%opPokeN
;  1197 -----------
;  1198     [32]
;  1199         --calling convention
;  1200         --  mov edi,[p1] -- addr (opUnassigned)
;  1201         --  mov eax,[p2] -- object to poke (opUnassigned)
;  1202         --  mov ecx,1/2/4/8
;  1203         --  xor edx,edx     -- (poke8 only) [eax is float flag]
;  1204         --  call :%opPokeN  -- poke1/2/4/8(edi,eax)
;  1205         cmp edi,h4 --DEV :%pLoadMint
;  1206         jl @f
;  1207             cmp byte[ebx+edi*4-1],0x12
;  1208             jne :e42fatp4mba        -- first argument to poke4 must be atom
;  1209             fld qword[ebx+edi*4]
;  1210             sub esp,8
;  1211             call :%down53
;  1212             fistp qword[esp]
;  1213             call :%near53
;  1214             mov edi,[esp]
;  1215             add esp,8
;  1216       @@:
;  1217 --    ::opPokeNediset
;  1218         cmp eax,h4
;  1219         jl @f
;  1220             cmp byte[ebx+eax*4-1],0x12
;  1221             jne :PokeNSeq
;  1222             fld qword[ebx+eax*4]
;  1223             sub esp,8
;  1224 --          call :%down53
;  1225             call :%trunc53
;  1226             fistp qword[esp]
;  1227             call :%near53
;  1228             mov esi,eax             -- (for poke8)
;  1229             mov eax,[esp]
;  1230 --          mov edx,[esp+4]         -- (for poke8)
;  1231             mov edx,1               -- (for poke8)
;  1232             add esp,8
;  1233       @@:
;  1234         cmp ecx,1
;  1235         jne @f
;  1236           :!PokeN1E30               -- exception here mapped to e100ipmafeh
;  1237             mov byte[edi],al
;  1238             ret
;  1239       @@:
;  1240         cmp ecx,2
;  1241         jne @f
;  1242           :!PokeN2E30               -- exception here mapped to e100ipmafeh
;  1243             mov word[edi],ax
;  1244             ret
;  1245       @@:
;  1246         cmp ecx,4
;  1247         jne @f
;  1248           :!PokeN4E30               -- exception here mapped to e100ipmafeh
;  1249             mov dword[edi],eax
;  1250             ret
;  1251       @@:
;  1252         cmp ecx,8
;  1253         jne :epokesize
;  1254             cmp edx,0
;  1255             je @f
;  1256 --!!eax!! (I think)
;  1257                 fld qword[ebx+esi*4]
;  1258 --              fld qword[ebx+eax*4]
;  1259                 sub esp,12
;  1260 --              call :%down64
;  1261                 call :%trunc64
;  1262 --              fistp tbyte[esp]    -- oh dear, no such thing...
;  1263                 fistp qword[esp]
;  1264                 call :%near53
;  1265                 mov eax,dword[esp]
;  1266                 mov edx,dword[esp+4]
;  1267                 add esp,12
;  1268                 jmp :opPoke8edieaxedx
;  1269           @@:
;  1270             cdq                     -- eax -> edx:eax
;  1271           ::opPoke8edieaxedx
;  1272           :!PokeN8E30               -- exception here mapped to e100ipmafeh
;  1273             mov dword[edi],eax
;  1274             mov dword[edi+4],edx
;  1275           @@:
;  1276             ret
;  1277 
;  1278       ::PokeNSeq
;  1279         mov edx,ecx
;  1280         mov ecx,[ebx+eax*4-12]      -- length
;  1281         lea esi,[ebx+eax*4]
;  1282         -- edi now contains addr, esi raw addr of seq/str(p2), ecx the length
;  1283         cmp ecx,0
;  1284         je @b
;  1285         cmp byte[ebx+eax*4-1],0x80
;  1286         jne :PokeNStr
;  1287 --      cmp ecx,8
;  1288         cmp edx,8
;  1289         je :Poke8SeqLoop
;  1290 
;  1291       ::PokeNSeqLoop
;  1292             mov eax,[esi]
;  1293             cmp eax,h4  --DEV :%pLoadMint
;  1294             jl @f
;  1295             cmp byte[ebx+eax*4-1],0x12
;  1296             jne :e114stbpmoca           -- sequence to be poked must only contain atoms
;  1297             fld qword[ebx+eax*4]
;  1298             sub esp,8
;  1299 --          call :%down53
;  1300             call :%trunc53
;  1301             fistp qword[esp]
;  1302             call :%near53
;  1303             mov eax,[esp]
;  1304             add esp,8
;  1305           @@:
;  1306             cmp edx,1
;  1307             jne @f
;  1308               :!Poke1SeqE30                  -- exception here mapped to e100ipmafeh
;  1309                 stosb
;  1310                 jmp :PokeNSeqNext
;  1311           @@:
;  1312             cmp edx,2
;  1313             jne @f
;  1314               :!Poke2SeqE30                  -- exception here mapped to e100ipmafeh
;  1315                 stosw
;  1316                 jmp :PokeNSeqNext
;  1317           @@:
;  1318             cmp edx,4
;  1319             jne :epokesize
;  1320               :!Poke3SeqE30                  -- exception here mapped to e100ipmafeh
;  1321                 stosd                   -- mov [edi],eax; edi+=4
;  1322           ::PokeNSeqNext
;  1323             lea esi,[esi+4]
;  1324             sub ecx,1
;  1325             jnz :PokeNSeqLoop
;  1326         nop
;  1327         ret
;  1328 
;  1329       ::Poke8SeqLoop
;  1330             mov eax,[esi]
;  1331             cmp eax,h4
;  1332             jl @f
;  1333                 cmp byte[ebx+eax*4-1],0x12
;  1334 --DEV or, if it is a sequence of 2 atoms, poke4 them...
;  1335                 jne :e114stbpmoca           -- sequence to be poked must only contain atoms
;  1336                 fld qword[ebx+eax*4]
;  1337                 sub esp,8
;  1338 --              call :%down64
;  1339                 call :%trunc64
;  1340 --              fistp tbyte[esp]    -- oh dear, no such thing...
;  1341                 fistp dword[esp]
;  1342                 call :%near53
;  1343                 mov eax,[esp]
;  1344                 mov edx,[esp+4]
;  1345                 add esp,8
;  1346                 jmp :Poke8sedxeax
;  1347           @@:
;  1348             cdq                 -- eax -> edx:eax
;  1349           ::Poke8sedxeax
;  1350           :!Poke8SeqE30                  -- exception here mapped to e100ipmafeh
;  1351             mov dword[edi],eax
;  1352           :!Poke1SeqE30a                 -- exception here mapped to e100ipmafeh
;  1353             mov dword[edi+4],edx
;  1354             add edi,8
;  1355             lea esi,[esi+4]
;  1356             sub ecx,1
;  1357             jnz :Poke8SeqLoop
;  1358         nop
;  1359         ret
;  1360                 
;  1361       ::PokeNStr
;  1362         -- edi now contains addr, esi raw addr of string(p2), ecx the length
;  1363         cmp byte[ebx+eax*4-1],0x82
;  1364         jne :showerror          -- unknown type byte (not 0x12, 0x80, or 0x82)
;  1365         cmp edx,1
;  1366         jne @f
;  1367           :!PokeN1StrE30                -- exception here mapped to e100ipmafeh
;  1368             rep movsb
;  1369             ret
;  1370       @@:
;  1371         xor eax,eax
;  1372       ::PokeNStrLoop
;  1373         lodsb                   -- mov al,[esi]; esi+=1
;  1374         cmp edx,2
;  1375         jne @f
;  1376           :!PokeN2StrE30            -- exception here mapped to e100ipmafeh
;  1377             stosw               -- mov [edi],ax; edi+=2
;  1378             jmp :PokeNStrNext
;  1379       @@:
;  1380         cmp edx,4
;  1381         jne @f
;  1382           :!PokeN4StrE30            -- exception here mapped to e100ipmafeh
;  1383             stosd               -- mov [edi],eax; edi+=4
;  1384             jmp :PokeNStrNext
;  1385       @@:
;  1386         cmp edx,8
;  1387         jne :epokesize
;  1388           :!PokeN8StrE30            -- exception here mapped to e100ipmafeh
;  1389             stosd
;  1390             mov dword[edi],ebx
;  1391             add edi,4
;  1392 
;  1393       ::PokeNStrNext
;  1394         sub ecx,1
;  1395         jnz :PokeNStrLoop
;  1396 
;  1397         nop
;  1398         ret
;  1399     [64]
;  1400         --calling convention
;  1401         --  mov rdi,[p1] -- addr (opUnassigned)
;  1402         --  mov rax,[p2] -- object to poke (opUnassigned)
;  1403         --  mov rcx,1/2/4/8
;  1404         --  call :%opPokeN  -- poke1/2/4/8(rdi,rax)
;  1405         mov r15,h4
                mov r15,h4                ;#0043EFA4: 49:277 0000000000000040    uv 8000 00  1 377      
;  1406         xor rdx,rdx
                xor rdx,rdx               ;#0043EFAE: 48:061322                  vu 04 04  1 377      
;  1407         cmp rdi,r15
                cmp rdi,r15               ;#0043EFB1: 49:073377                  uv 00 8080  1 378      
;  1408         jl @f
                jl #0043EFD7              ;#0043EFB4: 174 21                     v  00 00  1 378      
;  1409             cmp byte[rbx+rdi*4-1],0x12
                    cmp byte[rbx+rdi*4-1],#12  ;#0043EFB6: 200174273 FF 12            u  00 88  2 379      
;  1410             jne :e42fatp4mba        -- first argument to poke4 must be atom
                    jne #0043ED34         ;#0043EFBB: 017205 73FDFFFF            v  00 00  1 380      
;  1411             fld tbyte[rbx+rdi*4]
                    fld tbyte[rbx+rdi*4]  ;#0043EFC1: 333054273                  np 00 88  3 381      
;  1412             sub rsp,8
                    sub rsp,8             ;#0043EFC4: 48:203354 08               uv 10 10  1 384      
;  1413             call :%down64
                    call #0044139E (:%down64)  ;#0043EFC8: 350 D1230000               v  00 00  1 384      
;  1414             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043EFCD: 337074044                  np 00 10  6 387    *10*
;  1415             call :%near64
                    call #004413A5 (:%near64)  ;#0043EFD0: 350 D0230000               v  00 00  1 393      
;  1416             pop rdi
                    pop rdi               ;#0043EFD5: 48:137                     uv 80 00  1 394      
;  1417       @@:
;  1418         cmp rax,r15
                cmp rax,r15               ;#0043EFD7: 49:073307                  vu 00 8001  1 394      
;  1419         jl @f
                jl #0043EFF9              ;#0043EFDA: 174 1D                     v  00 00  1 395      
;  1420             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043EFDC: 200174203 FF 12            u  00 09  2 396      
;  1421             jne :PokeNSeq64
                    jne #0043F023         ;#0043EFE1: 165 40                     v  00 00  1 397      
;  1422             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043EFE3: 333054203                  np 00 09  3 398      
;  1423             sub rsp,8
                    sub rsp,8             ;#0043EFE6: 48:203354 08               uv 10 10  1 401      
;  1424 --          call :%down64
;  1425             call :%trunc64
                    call #004413AC (:%trunc64)  ;#0043EFEA: 350 BD230000               v  00 00  1 401      
;  1426             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043EFEF: 337074044                  np 00 10  6 404    *10*
;  1427             call :%near64
                    call #004413A5 (:%near64)  ;#0043EFF2: 350 AE230000               v  00 00  1 410      
;  1428             pop rax
                    pop rax               ;#0043EFF7: 48:130                     uv 01 00  1 411      
;  1429       @@:
;  1430         cmp rcx,1
                cmp rcx,1                 ;#0043EFF9: 48:203371 01               vu 00 02  1 411      
;  1431         jne @f
                jne #0043F002             ;#0043EFFD: 165 03                     v  00 00  1 412      
;  1432           :!PokeN1E30               -- exception here mapped to e100ipmafeh
;  1433             mov byte[rdi],al
                    mov [edi],al          ;#0043EFFF: 210007                     uv 00 81  1 413      
;  1434             ret
                    ret                   ;#0043F001: 303                        np 00 00  2 414      
;  1435       @@:
;  1436         cmp rcx,2
                cmp rcx,2                 ;#0043F002: 48:203371 02               uv 00 02  1 416      
;  1437         jne @f
                jne #0043F00C             ;#0043F006: 165 04                     v  00 00  1 416      
;  1438           :!PokeN2E30               -- exception here mapped to e100ipmafeh
;  1439             mov word[rdi],ax
                    mov word[edi],ax      ;#0043F008: 146:211007                 uv 00 81  1 417      
;  1440             ret
                    ret                   ;#0043F00B: 303                        np 00 00  2 418      
;  1441       @@:
;  1442         cmp rcx,4
                cmp rcx,4                 ;#0043F00C: 48:203371 04               uv 00 02  1 420      
;  1443         jne @f
                jne #0043F015             ;#0043F010: 165 03                     v  00 00  1 420      
;  1444           :!PokeN4E30               -- exception here mapped to e100ipmafeh
;  1445             mov dword[rdi],eax
                    mov [edi],eax         ;#0043F012: 211007                     uv 00 81  1 421      
;  1446             ret
                    ret                   ;#0043F014: 303                        np 00 00  2 422      
;  1447       @@:
;  1448         cmp rcx,8
                cmp rcx,8                 ;#0043F015: 48:203371 08               uv 00 02  1 424      
;  1449         jne :epokesize
                jne #0043ED3A             ;#0043F019: 017205 1BFDFFFF            v  00 00  1 424      
;  1450           :!PokeN8E30               -- exception here mapped to e100ipmafeh
;  1451             mov qword[rdi],rax
                    mov [rdi],rax         ;#0043F01F: 48:211007                  uv 00 81  1 425      
;  1452           @@:
;  1453             ret
                    ret                   ;#0043F022: 303                        np 00 00  2 426      
;  1454 
;  1455       ::PokeNSeq64
;  1456         mov rdx,rcx
                mov rdx,rcx               ;#0043F023: 48:213321                  uv 04 02  1 428      
;  1457         mov rcx,[rbx+rax*4-24]      -- length
                mov rcx,[rbx+rax*4-24]    ;#0043F026: 48:213114203 E8            vu 02 09  1 428      
;  1458         lea rsi,[rbx+rax*4]
                lea rsi,[rbx+rax*4]       ;#0043F02B: 48:215064203               uv 40 09  1 429      
;  1459         -- rdi now contains addr, rsi raw addr of seq/str(p2), rcx the length
;  1460         cmp rcx,0
                cmp rcx,0                 ;#0043F02F: 48:203371 00               vu 00 02  1 429      
;  1461         je @b
                je #0043F022              ;#0043F033: 164 ED                     v  00 00  1 430      
;  1462         cmp byte[rbx+rax*4-1],0x80
                cmp byte[rbx+rax*4-1],#80  ;#0043F035: 200174203 FF 80            u  00 09  2 431      
;  1463         jne :PokeNStr64
                jne #0043F098             ;#0043F03A: 165 5C                     v  00 00  1 432      
;  1464 --      cmp rdx,8
;  1465 --      je :Poke8SeqLoop
;  1466 
;  1467       ::PokeNSeqLoop64
;  1468             mov rax,[rsi]
                    mov rax,[rsi]         ;#0043F03C: 48:213006                  uv 01 40  1 433      
;  1469             add rsi,8
                    add rsi,8             ;#0043F03F: 48:203306 08               vu 40 40  1 433      
;  1470             cmp rax,r15
                    cmp rax,r15           ;#0043F043: 49:073307                  uv 00 8001  1 434      
;  1471             jl @f
                    jl #0043F069          ;#0043F046: 174 21                     v  00 00  1 434      
;  1472                 cmp byte[rbx+rax*4-1],0x12
                        cmp byte[rbx+rax*4-1],#12  ;#0043F048: 200174203 FF 12            u  00 09  2 435      
;  1473                 jne :e114stbpmoca           -- sequence to be poked must only contain atoms
                        jne #0043ED32     ;#0043F04D: 017205 DFFCFFFF            v  00 00  1 436      
;  1474                 fld tbyte[rbx+rax*4]
                        fld tbyte[rbx+rax*4]  ;#0043F053: 333054203                  np 00 09  3 437      
;  1475                 sub rsp,8
                        sub rsp,8         ;#0043F056: 48:203354 08               uv 10 10  1 440      
;  1476 --              call :%down64
;  1477                 call :%trunc64
                        call #004413AC (:%trunc64)  ;#0043F05A: 350 4D230000               v  00 00  1 440      
;  1478                 fistp qword[rsp]
                        fistp qword[rsp]  ;#0043F05F: 337074044                  np 00 10  6 443    *10*
;  1479                 call :%near64
                        call #004413A5 (:%near64)  ;#0043F062: 350 3E230000               v  00 00  1 449      
;  1480                 pop rax
                        pop rax           ;#0043F067: 48:130                     uv 01 00  1 450      
;  1481           @@:
;  1482             cmp rdx,1
                    cmp rdx,1             ;#0043F069: 48:203372 01               vu 00 04  1 450      
;  1483             jne @f
                    jne #0043F072         ;#0043F06D: 165 03                     v  00 00  1 451      
;  1484               :!Poke1SeqE30                  -- exception here mapped to e100ipmafeh
;  1485                 stosb
                        stosb             ;#0043F06F: 252                        np 80 81  3 452      
;  1486                 jmp :PokeNSeqNext64
                        jmp #0043F091     ;#0043F070: 353 1F                     v  00 00  1 455      
;  1487           @@:
;  1488             cmp rdx,2
                    cmp rdx,2             ;#0043F072: 48:203372 02               uv 00 04  1 456      
;  1489             jne @f
                    jne #0043F07C         ;#0043F076: 165 04                     v  00 00  1 456      
;  1490               :!Poke2SeqE30                  -- exception here mapped to e100ipmafeh
;  1491                 stosw
                        stosw             ;#0043F078: 146:253                    np 80 81  3 457      
;  1492                 jmp :PokeNSeqNext64
                        jmp #0043F091     ;#0043F07A: 353 15                     v  00 00  1 460      
;  1493           @@:
;  1494             cmp rdx,4
                    cmp rdx,4             ;#0043F07C: 48:203372 04               uv 00 04  1 461      
;  1495             jne @f
                    jne #0043F085         ;#0043F080: 165 03                     v  00 00  1 461      
;  1496               :!Poke4SeqE30                 -- exception here mapped to e100ipmafeh
;  1497                 stosd                       -- mov [edi],eax; edi+=4
                        stosd             ;#0043F082: 253                        np 80 81  3 462      
;  1498                 jmp :PokeNSeqNext64
                        jmp #0043F091     ;#0043F083: 353 0C                     v  00 00  1 465      
;  1499 
;  1500           @@:
;  1501             cmp rdx,8
                    cmp rdx,8             ;#0043F085: 48:203372 08               uv 00 04  1 466      
;  1502             jne :epokesize
                    jne #0043ED3A         ;#0043F089: 017205 ABFCFFFF            v  00 00  1 466      
;  1503               :!Poke8SeqE30                 -- exception here mapped to e100ipmafeh
;  1504                 stosq                       -- mov [rdi],rax; rdi+=4
                        stosq             ;#0043F08F: 48:253                     np 80 81  3 467      
;  1505 
;  1506           ::PokeNSeqNext64
;  1507             sub ecx,1
                    sub ecx,1             ;#0043F091: 203351 01                  uv 02 02  1 470      
;  1508             jnz :PokeNSeqLoop64
                    jnz #0043F03C         ;#0043F094: 165 A6                     v  00 00  1 470      
;  1509         nop
                nop                       ;#0043F096: 220                        uv 00 00  1 471      
;  1510         ret
                ret                       ;#0043F097: 303                        np 00 00  2 472      
;  1511 
;  1512       ::PokeNStr64
;  1513         -- rdi now contains addr, rsi raw addr of string(p2), rcx the length
;  1514         cmp byte[rbx+rax*4-1],0x82
                cmp byte[rbx+rax*4-1],#82  ;#0043F098: 200174203 FF 82            u  00 09  2 474      
;  1515         jne :showerror          -- unknown type byte (not 0x12, 0x80, or 0x82)
                jne #0043ED33             ;#0043F09D: 017205 90FCFFFF            v  00 00  1 475      
;  1516         cmp rdx,1
                cmp rdx,1                 ;#0043F0A3: 48:203372 01               uv 00 04  1 476      
;  1517         jne @f
                jne #0043F0AC             ;#0043F0A7: 165 03                     v  00 00  1 476      
;  1518           :!PokeN1StrE30        -- exception here mapped to e100ipmafeh
;  1519             rep movsb
                    rep movsb             ;#0043F0A9: 363:244                    np C2 C2  4 477      
;  1520             ret
                    ret                   ;#0043F0AB: 303                        np 00 00  2 481      
;  1521       @@:
;  1522         xor rax,rax
                xor rax,rax               ;#0043F0AC: 48:061300                  uv 01 01  1 483      
;  1523       ::PokeNStrLoop64
;  1524         lodsb                   -- mov al,[rsi]; rsi+=1
                lodsb                     ;#0043F0AF: 254                        np 41 40  2 485    *40*
;  1525         cmp rdx,2
                cmp rdx,2                 ;#0043F0B0: 48:203372 02               uv 00 04  1 487      
;  1526         jne @f
                jne #0043F0BA             ;#0043F0B4: 165 04                     v  00 00  1 487      
;  1527           :!PokeN2StrE30        -- exception here mapped to e100ipmafeh
;  1528             stosw               -- mov [rdi],ax; rdi+=2
                    stosw                 ;#0043F0B6: 146:253                    np 80 81  3 488      
;  1529             jmp :PokeNStrNext64
                    jmp #0043F0CF         ;#0043F0B8: 353 15                     v  00 00  1 491      
;  1530       @@:
;  1531         cmp rdx,4
                cmp rdx,4                 ;#0043F0BA: 48:203372 04               uv 00 04  1 492      
;  1532         jne @f
                jne #0043F0C3             ;#0043F0BE: 165 03                     v  00 00  1 492      
;  1533           :!PokeN4StrE30        -- exception here mapped to e100ipmafeh
;  1534             stosd               -- mov [edi],eax; edi+=4
                    stosd                 ;#0043F0C0: 253                        np 80 81  3 493      
;  1535             jmp :PokeNStrNext64
                    jmp #0043F0CF         ;#0043F0C1: 353 0C                     v  00 00  1 496      
;  1536       @@:
;  1537         cmp rdx,8
                cmp rdx,8                 ;#0043F0C3: 48:203372 08               uv 00 04  1 497      
;  1538         jne :epokesize
                jne #0043ED3A             ;#0043F0C7: 017205 6DFCFFFF            v  00 00  1 497      
;  1539           :!PokeN8StrE30            -- exception here mapped to e100ipmafeh
;  1540             stosq
                    stosq                 ;#0043F0CD: 48:253                     np 80 81  3 498      
;  1541 
;  1542       ::PokeNStrNext64
;  1543         sub rcx,1
                sub rcx,1                 ;#0043F0CF: 48:203351 01               uv 02 02  1 501      
;  1544         jnz :PokeNStrLoop64
                jnz #0043F0AF             ;#0043F0D3: 165 DA                     v  00 00  1 501      
;  1545 
;  1546         nop
                nop                       ;#0043F0D5: 220                        uv 00 00  1 502      
;  1547         ret
                ret                       ;#0043F0D6: 303                        np 00 00  2 503      
;  1548     []
;  1549 
;  1550 --/*
;  1551 procedure :%opMemCopy(:%)
;  1552 end procedure -- (for Edita/CtrlQ)
;  1553 --*/
;  1554   :%opMemCopy
;  1555 -------------
;  1556     [32]
;  1557         -- calling convention:
;  1558         --  mov esi,[p1]        -- source addr
;  1559         --  mov edi,[p2]        -- dest addr
;  1560         --  mov ecx,[p3]        -- copy length
;  1561         --  call :%opMemCopy    -- mem_copy(esi,edi,ecx)
;  1562         cmp ecx,h4 --DEV :%pLoadMint
;  1563         jl @f
;  1564             cmp byte[ebx+ecx*4-1],0x12
;  1565             jne :e39atmcmba    -- arguments to mem_copy must be atoms
;  1566             fld qword[ebx+ecx*4]
;  1567             sub esp,8
;  1568             call :%down53
;  1569             fistp qword[esp]
;  1570             call :%near53
;  1571             mov ecx,[esp]
;  1572             add esp,8
;  1573       @@:
;  1574         cmp ecx,0
;  1575         jl :e22imcl             -- invalid mem_copy length
;  1576 
;  1577         cmp esi,h4 --DEV :%pLoadMint
;  1578         jl @f
;  1579             cmp byte[ebx+esi*4-1],0x12
;  1580             jne :e39atmcmba    -- arguments to mem_copy must be atoms
;  1581             fld qword[ebx+esi*4]
;  1582             sub esp,8
;  1583             call :%down53
;  1584             fistp qword[esp]
;  1585             call :%near53
;  1586             mov esi,[esp]
;  1587             add esp,8
;  1588       @@:
;  1589         cmp edi,h4 --DEV :%pLoadMint
;  1590         jl @f
;  1591             cmp byte[ebx+edi*4-1],0x12
;  1592             jne :e39atmcmba    -- arguments to mem_copy must be atoms
;  1593             fld qword[ebx+edi*4]
;  1594             sub esp,8
;  1595             call :%down53
;  1596             fistp qword[esp]
;  1597             call :%near53
;  1598             mov edi,[esp]
;  1599             add esp,8
;  1600       @@:
;  1601   :!MemCopyIMA  -- exception here mapped to e24imcmafeh
;  1602         rep movsb
;  1603         ret
;  1604     [64]
;  1605         -- calling convention:
;  1606         --  mov rsi,[p1]        -- source addr
;  1607         --  mov rdi,[p2]        -- dest addr
;  1608         --  mov rcx,[p3]        -- copy length
;  1609         --  call :%opMemCopy    -- mem_copy(rsi,rdi,rcx)
;  1610         mov r15,h4
                mov r15,h4                ;#0043F0D7: 49:277 0000000000000040    uv 8000 00  1 505      
;  1611         cmp rcx,r15
                cmp rcx,r15               ;#0043F0E1: 49:073317                  uv 00 8002  1 506 8000   
;  1612         jl @f
                jl #0043F107              ;#0043F0E4: 174 21                     v  00 00  1 506      
;  1613             cmp byte[rbx+rcx*4-1],0x12
                    cmp byte[rbx+rcx*4-1],#12  ;#0043F0E6: 200174213 FF 12            u  00 0A  2 507      
;  1614             jne :e39atmcmba    -- arguments to mem_copy must be atoms
                    jne #0043ED35         ;#0043F0EB: 017205 44FCFFFF            v  00 00  1 508      
;  1615             fld tbyte[rbx+rcx*4]
                    fld tbyte[rbx+rcx*4]  ;#0043F0F1: 333054213                  np 00 0A  3 509      
;  1616             sub rsp,8
                    sub rsp,8             ;#0043F0F4: 48:203354 08               uv 10 10  1 512      
;  1617             call :%down64
                    call #0044139E (:%down64)  ;#0043F0F8: 350 A1220000               v  00 00  1 512      
;  1618             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F0FD: 337074044                  np 00 10  6 515    *10*
;  1619             call :%near64
                    call #004413A5 (:%near64)  ;#0043F100: 350 A0220000               v  00 00  1 521      
;  1620             pop rcx
                    pop rcx               ;#0043F105: 48:131                     uv 02 00  1 522      
;  1621       @@:
;  1622         cmp rcx,0
                cmp rcx,0                 ;#0043F107: 48:203371 00               uv 00 02  1 523 02   
;  1623         jl :e22imcl             -- invalid mem_copy length
                jl #0043ED36              ;#0043F10B: 017214 25FCFFFF            v  00 00  1 523      
;  1624 
;  1625         cmp rsi,r15
                cmp rsi,r15               ;#0043F111: 49:073367                  uv 00 8040  1 524      
;  1626         jl @f
                jl #0043F137              ;#0043F114: 174 21                     v  00 00  1 524      
;  1627             cmp byte[rbx+rsi*4-1],0x12
                    cmp byte[rbx+rsi*4-1],#12  ;#0043F116: 200174263 FF 12            u  00 48  2 525      
;  1628             jne :e39atmcmba    -- arguments to mem_copy must be atoms
                    jne #0043ED35         ;#0043F11B: 017205 14FCFFFF            v  00 00  1 526      
;  1629             fld tbyte[rbx+rsi*4]
                    fld tbyte[rbx+rsi*4]  ;#0043F121: 333054263                  np 00 48  3 527      
;  1630             sub rsp,8
                    sub rsp,8             ;#0043F124: 48:203354 08               uv 10 10  1 530      
;  1631             call :%down64
                    call #0044139E (:%down64)  ;#0043F128: 350 71220000               v  00 00  1 530      
;  1632             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F12D: 337074044                  np 00 10  6 533    *10*
;  1633             call :%near64
                    call #004413A5 (:%near64)  ;#0043F130: 350 70220000               v  00 00  1 539      
;  1634             pop rsi
                    pop rsi               ;#0043F135: 48:136                     uv 40 00  1 540      
;  1635       @@:
;  1636         cmp rdi,r15
                cmp rdi,r15               ;#0043F137: 49:073377                  vu 00 8080  1 540      
;  1637         jl @f
                jl #0043F15D (:!MemCopyIMA)  ;#0043F13A: 174 21                     v  00 00  1 541      
;  1638             cmp byte[rbx+rdi*4-1],0x12
                    cmp byte[rbx+rdi*4-1],#12  ;#0043F13C: 200174273 FF 12            u  00 88  2 542      
;  1639             jne :e39atmcmba    -- arguments to mem_copy must be atoms
                    jne #0043ED35         ;#0043F141: 017205 EEFBFFFF            v  00 00  1 543      
;  1640             fld tbyte[rbx+rdi*4]
                    fld tbyte[rbx+rdi*4]  ;#0043F147: 333054273                  np 00 88  3 544      
;  1641             sub rsp,8
                    sub rsp,8             ;#0043F14A: 48:203354 08               uv 10 10  1 547      
;  1642             call :%down64
                    call #0044139E (:%down64)  ;#0043F14E: 350 4B220000               v  00 00  1 547      
;  1643             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F153: 337074044                  np 00 10  6 550    *10*
;  1644             call :%near64
                    call #004413A5 (:%near64)  ;#0043F156: 350 4A220000               v  00 00  1 556      
;  1645             pop rdi
                    pop rdi               ;#0043F15B: 48:137                     uv 80 00  1 557      
;  1646       @@:
;  1647   :!MemCopyIMA  -- exception here mapped to e24imcmafeh
;  1648         rep movsb
                rep movsb                 ;#0043F15D: 363:244                    np C2 C2  4 560    *80*
;  1649         ret
                ret                       ;#0043F15F: 303                        np 00 00  2 564      
;  1650     []
;  1651 
;  1652 --/*
;  1653 procedure :%opMemSet(:%)
;  1654 end procedure -- (for Edita/CtrlQ)
;  1655 --*/
;  1656   :%opMemSet
;  1657 -------------
;  1658     [32]
;  1659         -- calling convention:
;  1660         --  mov edi,[p1]        -- dest addr    (opUnassigned)
;  1661         --  mov eax,[p2]        -- value (byte) (opUnassigned)
;  1662         --  mov ecx,[p3]        -- length       (opUnassigned)
;  1663         --  call :%opMemSet     -- mem_set(edi,eax,ecx)
;  1664         cmp eax,h4      -- value --DEV :%pLoadMint
;  1665         jl @f
;  1666             cmp byte[ebx+eax*4-1],0x12
;  1667             jne :e40atmsmba    -- arguments to mem_set must be atoms
;  1668             fld qword[ebx+eax*4]
;  1669             sub esp,8
;  1670             call :%down53
;  1671             fistp qword[esp]
;  1672             call :%near53
;  1673             mov eax,[esp]
;  1674             add esp,8
;  1675       @@:
;  1676         cmp ecx,h4      -- length --DEV :%pLoadMint
;  1677         jl @f
;  1678             cmp byte[ebx+ecx*4-1],0x12
;  1679             jne :e40atmsmba    -- arguments to mem_set must be atoms
;  1680             fld qword[ebx+ecx*4]
;  1681             sub esp,8
;  1682             call :%down53
;  1683             fistp qword[esp]
;  1684             call :%near53
;  1685             mov ecx,[esp]
;  1686             add esp,8
;  1687       @@:
;  1688         cmp ecx,0
;  1689         jl :e23imsl             -- invalid mem_set length
;  1690 
;  1691         cmp edi,h4      -- memory address --DEV :%pLoadMint
;  1692         jl @f
;  1693             cmp byte[ebx+edi*4-1],0x12
;  1694             jne :e40atmsmba     -- arguments to mem_set must be atoms
;  1695             fld qword[ebx+edi*4]
;  1696             sub esp,8
;  1697             call :%down53
;  1698             fistp qword[esp]
;  1699             call :%near53
;  1700             mov edi,[esp]
;  1701             add esp,8
;  1702       @@:
;  1703   :!MemSetIMA   -- exception here mapped to e25imsmafeh
;  1704         rep stosb
;  1705         ret
;  1706     [64]
;  1707         -- calling convention:
;  1708         --  mov rdi,[p1]        -- dest addr    (opUnassigned)
;  1709         --  mov rax,[p2]        -- value (byte) (opUnassigned)
;  1710         --  mov rcx,[p3]        -- length       (opUnassigned)
;  1711         --  call :%opMemSet     -- mem_set(rdi,rax,rcx)
;  1712         mov r15,h4
                mov r15,h4                ;#0043F160: 49:277 0000000000000040    uv 8000 00  1 566      
;  1713         cmp rax,r15     -- value
                cmp rax,r15               ;#0043F16A: 49:073307                  uv 00 8001  1 567 8000   
;  1714         jl @f
                jl #0043F190              ;#0043F16D: 174 21                     v  00 00  1 567      
;  1715             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043F16F: 200174203 FF 12            u  00 09  2 568      
;  1716             jne :e40atmsmba    -- arguments to mem_set must be atoms
                    jne #0043ED38         ;#0043F174: 017205 BEFBFFFF            v  00 00  1 569      
;  1717             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043F17A: 333054203                  np 00 09  3 570      
;  1718             sub rsp,8
                    sub rsp,8             ;#0043F17D: 48:203354 08               uv 10 10  1 573      
;  1719             call :%down64
                    call #0044139E (:%down64)  ;#0043F181: 350 18220000               v  00 00  1 573      
;  1720             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F186: 337074044                  np 00 10  6 576    *10*
;  1721             call :%near64
                    call #004413A5 (:%near64)  ;#0043F189: 350 17220000               v  00 00  1 582      
;  1722             pop rax
                    pop rax               ;#0043F18E: 48:130                     uv 01 00  1 583      
;  1723       @@:
;  1724         cmp rcx,r15     -- length
                cmp rcx,r15               ;#0043F190: 49:073317                  vu 00 8002  1 583      
;  1725         jl @f
                jl #0043F1B6              ;#0043F193: 174 21                     v  00 00  1 584      
;  1726             cmp byte[rbx+rcx*4-1],0x12
                    cmp byte[rbx+rcx*4-1],#12  ;#0043F195: 200174213 FF 12            u  00 0A  2 585      
;  1727             jne :e40atmsmba    -- arguments to mem_set must be atoms
                    jne #0043ED38         ;#0043F19A: 017205 98FBFFFF            v  00 00  1 586      
;  1728             fld tbyte[rbx+rcx*4]
                    fld tbyte[rbx+rcx*4]  ;#0043F1A0: 333054213                  np 00 0A  3 587      
;  1729             sub rsp,8
                    sub rsp,8             ;#0043F1A3: 48:203354 08               uv 10 10  1 590      
;  1730             call :%down64
                    call #0044139E (:%down64)  ;#0043F1A7: 350 F2210000               v  00 00  1 590      
;  1731             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F1AC: 337074044                  np 00 10  6 593    *10*
;  1732             call :%near64
                    call #004413A5 (:%near64)  ;#0043F1AF: 350 F1210000               v  00 00  1 599      
;  1733             pop rcx
                    pop rcx               ;#0043F1B4: 48:131                     uv 02 00  1 600      
;  1734       @@:
;  1735         cmp rcx,0
                cmp rcx,0                 ;#0043F1B6: 48:203371 00               uv 00 02  1 601 02   
;  1736         jl :e23imsl             -- invalid mem_set length
                jl #0043ED37              ;#0043F1BA: 017214 77FBFFFF            v  00 00  1 601      
;  1737 
;  1738         cmp rdi,r15     -- memory address
                cmp rdi,r15               ;#0043F1C0: 49:073377                  uv 00 8080  1 602      
;  1739         jl @f
                jl #0043F1E6 (:!MemSetIMA)  ;#0043F1C3: 174 21                     v  00 00  1 602      
;  1740             cmp byte[rbx+rdi*4-1],0x12
                    cmp byte[rbx+rdi*4-1],#12  ;#0043F1C5: 200174273 FF 12            u  00 88  2 603      
;  1741             jne :e40atmsmba     -- arguments to mem_set must be atoms
                    jne #0043ED38         ;#0043F1CA: 017205 68FBFFFF            v  00 00  1 604      
;  1742             fld tbyte[rbx+rdi*4]
                    fld tbyte[rbx+rdi*4]  ;#0043F1D0: 333054273                  np 00 88  3 605      
;  1743             sub rsp,8
                    sub rsp,8             ;#0043F1D3: 48:203354 08               uv 10 10  1 608      
;  1744             call :%down64
                    call #0044139E (:%down64)  ;#0043F1D7: 350 C2210000               v  00 00  1 608      
;  1745             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043F1DC: 337074044                  np 00 10  6 611    *10*
;  1746             call :%near64
                    call #004413A5 (:%near64)  ;#0043F1DF: 350 C1210000               v  00 00  1 617      
;  1747             pop rdi
                    pop rdi               ;#0043F1E4: 48:137                     uv 80 00  1 618      
;  1748       @@:
;  1749   :!MemSetIMA   -- exception here mapped to e25imsmafeh
;  1750         rep stosb
                rep stosb                 ;#0043F1E6: 363:252                    np 82 83  3 621    *80*
;  1751         ret
                ret                       ;#0043F1E8: 303                        np 00 00  2 624      
;  1752     []
;  1753       }
;  1754 
    jmp #0044298D (:%opRetf)              ;#0043F1E9: 351 9F370000               v  00 00  1 626      
;C:\Program Files (x86)\Phix\builtins\VM\pfileioN.e:
;===================================================
;     1 --
;     2 -- pfileioN.e  (Phix compatible 0.6.4)
;     3 -- =========
;     4 --
;     5 --DEV newsize
;     6 --DEV new/64 bit version of open_dll etc
;     7 --DEV "" pCritSec.e (which may as well go into pHeap.e)
;     8 
;     9 --DEV need saving/restoring over opInterp: fdtbl/fdmax/freelist/(finit) [use bang labels!]
;    10 --DEV wrap/scroll/text_rows/bk_color/text_color/clear_screen/free_console/position
;    11 
;    12 include builtins\VM\pUnassigned.e   -- :%pRTErn (DEV/temp)
;    13 --
;    14 --  Phix implementation of fast buffered and thread safe file i/o, namely the 
;    15 --  routines open/puts/getc/gets/seek/where/flush/close, and also the related
;    16 --  get_text/wrap/scroll/text_rows/bk_color/text_color/position/free_console/
;    17 --  clear_screen.
;    18 --
;    19 --  This is an auto-include file; there is no need to manually include it, unless 
;    20 --  for some reason you want a namespace.
;    21 --
;    22 --DEV:
;    23 --  NB: This file is part of the optable: while you can test any modifications
;    24 --      using "p -c test" (p -d -run test?), you will need to run p -cp before
;    25 --      changes here will have any effect on "p test".
;    26 --
;    27 --/*
;    28 This will not work on RDS Eu/OpenEuphoria!!
;    29 --*/
;    30 --without debug -- (barely measurable savings, but [DEV] will want for release?)
;    31 
;    32 --  STATUS: EXPERIMENTAL/IN PROGRESS [DEV] [EXCELLENT, UP TO SPEED! 23/6/2013] [gets finished 30/6; puts probably needed soon [DONE]]
;    33 --
;    34 --  <glossary>
;    35 --      When I say "the asm", I tend to mean the older closed source backend,
;    36 --      whereas when I mean the #ilASM in here, I intend to say "the ilASM".
;    37 --  </glossary>
;    38 --
;    39 --  Originally, file i/o was coded in (closed source) assembly; this is a port
;    40 --  of that to (an eclectic mix of) (open source) hll (normal Phix code) and 
;    41 --  ilASM (inline assembly). It may not be very pretty, but is designed to:
;    42 --
;    43 --      * provide the best possible performance (especially getc)
;    44 --      * hide grubby details away, and keep day-to-day code clean
;    45 --      * be thread-safe (the asm version was most definitely not)
;    46 --      * fully support file i/o above 4GB (asm version was partial)    [DEV proper testing rqd]
;    47 --      * cope with redirected stdin/stdout (asm version did not)       [""]
;    48 --
;    49 --  Technically, of course, this is part of the Phix Virtual Machine, the mapping
;    50 --  between the simple "fn = open(name,mode)" and the raw hardware. It should be
;    51 --  considered part of the compiler, and thus no different to writing PE headers,
;    52 --  RVA entries, raw machine code, and other such nasties. If you think this is a 
;    53 --  bit difficult to read, trust me, it was much more difficult to write, but was
;    54 --  worth the effort because it improves the performance of almost every program.
;    55 --  And, believe it or not, this is /miles/ clearer than the stuff it replaced!
;    56 --
;    57 --  An obvious benefit is that you can safely take a copy of this and fiddle with 
;    58 --  or hack it to your hearts content (rename all the globals, obviously), unlike 
;    59 --  the asm, which was all-or-nothing, updates involving thousands of tiny little 
;    60 --  steps, any that broke anything had to be immediately undone, and an alternate 
;    61 --  and ever more circuitous route devised.
;    62 --
;    63 --  Experiments with the hll version to get redirection working took maybe around
;    64 --  two hours, maybe less, in contrast to several failed attempts on the original
;    65 --  asm version, spread out over more months than I care to admit.
;    66 --
;    67 --  The now-commented-out n_diag routine was trivial to write; the equivalent in 
;    68 --  the original asm backend code would certainly be far more difficult.
;    69 --
;    70 
;    71 -- Performance considerations
;    72 -- ==========================
;    73 --  The original hll implementation showed that, in particular for getc(), an
;    74 --  opFrame/opRetf overhead was unacceptable. This lead to the introduction and
;    75 --  use of global labels (":%" in file-level #ilASM). An unplanned benefit of
;    76 --  said introduction is that it promises a means of implementing opFrame/Retf
;    77 --  in hll/ilASM, as obviously they could never be implemented via themselves.
;    78 --
;    79 --      <aside>
;    80 --          I still firmly maintain that opFrame/opRetf are perfectly fast
;    81 --          enough; just because I found a case where //billions// of calls
;    82 --          could be done noticeably faster, it does not mean I would ever 
;    83 --          consider completely throwing away all ability to debug things.
;    84 --      </aside>
;    85 --
;    86 --  The original hll implementation (pfileio.e) is included in the distribution 
;    87 --  since it may prove easier to debug or test some enhancement.
;    88 --
;    89 --  While some ilASM is used to improve performance, the majority of such code 
;    90 --  is probably more likely to have been added to make things thread-safe and 
;    91 --  re-entrant, since that is generally speaking the one thing that file-level 
;    92 --  code was never meant to be. Typically that means allocating all work space 
;    93 --  on the system stack.
;    94 --
;    95 --  Further performance improvements are no doubt possible, so far I have only
;    96 --  focused on the worst offenders (according to with profile[_time]).
;    97 --
;    98 --DEV fixme (figure out how to invoke hll from ilASM, and dealloc as rqd) [DONE, see :%opOpen]
;    99 --  One known issue is puts(1[or 2],<dword_sequence>). The console (correctly)
;   100 --  has no buffer, so this resorts to displaying one-character-at-a-time, which
;   101 --  could get quite slow. The solution is to code something like:
;   102 --      if not string(s) then s = toString(s) end if
;   103 --      puts(1,s)
;   104 --  (you may have to copy the toString in here as it is not global.) Obviously
;   105 --  you do not need to bother with this when outputting to a file.
;   106 --
;   107 --with profile_time
;   108 
;   109 -- Technical notes
;   110 -- ===============
;   111 --  As we open each file, we allocate(FDSIZE32/64), a reusable block of memory which
;   112 --  contains handles, flags, indexes, a 64-bit position, and a buffer. Location of a 
;   113 --  block is stored in sequence fdtbl. A file handle is in fact an index to fdtbl; 
;   114 --  given 0/1/2 are stdin/stdout/stderr, 3 corresponds to fdtbl[1], 4 to [2], etc. 
;   115 --  Keeping all the necesary information about a file in such blocks both aids in
;   116 --  performance and minimises multithreading issues, covered in more depth below. 
;   117 --  Now, we could store the result from allocate(FDSIZE32/64) as an atom in fdtbl[i], 
;   118 --  but that would probably require code such as:
;   119 --
;   120 --      #ilASM{ mov edi,[fdtbl]
;   121 --              shl edi,2               -- (ref->raw addr)
;   122 --              mov esi,[edi+eax*4]     -- ("this:=fdtbl[fn-2]")
;   123 --              ...
;   124 --              cmp esi,h4
;   125 --              jl @f
;   126 --                  sub esp,8
;   127 --                  fld qword[ebx+esi*4]
;   128 --                  fistp qword[esp]
;   129 --                  pop esi
;   130 --                  add esp,4
;   131 --            @@:
;   132 --              mov edx,[esi+MODE]
;   133 --              ... }
;   134 --
;   135 --  Alternatively we can recognise that the result from allocate() is always a
;   136 --  multiple of 4, and divide by 4 so that fdtbl entries are always integer,
;   137 --  in which case we can instead (of between the ...) use (eg):
;   138 --
;   139 --      #ilASM{ ...
;   140 --              mov edx,[ebx+esi*4+MODE]
;   141 --              ... }
;   142 --
;   143 --  A more complete example: The hll variable "iThis" is often used as follows:
;   144 --
;   145 --      integer iThis
;   146 --      ...
;   147 --          iThis = floor(allocate(FDSIZE32)/4)     -- ("open()")
;   148 --          fdtbl = append(fdtbl,iThis)
;   149 --      else
;   150 --          iThis = fdtbl[i]                        -- ("getc()" etc)
;   151 --      ...
;   152 --      #ilASM{ mov esi,[iThis]
;   153 --              shl esi,2
;   154 --              ...
;   155 --              mov edx,[esi+MODE]
;   156 --              ... }
;   157 --
;   158 --  This (final) step gained the final 10% in performance to match the original
;   159 --  assembly code. (At least for the getc() tests I was running.)
;   160 --
;   161 
;   162 -- Multithreading issues
;   163 -- =====================
;   164 --  It should be no surprise to anyone that multiple threads acting on the same
;   165 --  file, without locking, are not going to be thread safe. Generally speaking,
;   166 --  each file handle should be owned exclusively by a single thread, or covered
;   167 --  by appropriate critical section handling (ie enter_cs).
;   168 --
;   169 --  Clearly close(-1) and flush(-1) could wreak havoc in a multithreaded program.
;   170 --  The main thread executes a close(-1) on termination; it is entirely up to the 
;   171 --  programmer to ensure any and all child threads (that use file i/o) properly 
;   172 --  terminate before exiting(/letting that close(-1) transpire). [DEV write a demo]
;   173 --
;   174 --  Obviously there should be no problem with one thread creating/processing a 
;   175 --  file and then "handing it over" to another thread, but sharing may require 
;   176 --  extensive locking at the application level. That applies equally to stdin, 
;   177 --  stdout, and stderr, not that slightly garbled error messages once or twice 
;   178 --  a year justifies panic. The rest of this section discusses a (minor) issue
;   179 --  with (eg) Thread A operating on file 3 while Thread B opens file 4.
;   180 --
;   181 --  Locking is needed to cover fdtbl/freelist updates in open/close, otherwise 
;   182 --  these routines are thread safe, except for the following race condition:
;   183 --      Thread A (many):        this = fdtbl[fidx]
;   184 --      Thread B (open):        fdtbl = append(fdtbl,this)
;   185 --  The line in Thread A would succeed if performed either wholly before or 
;   186 --  after the line in Thread B, however if Thread B reallocates fdtbl *AND* 
;   187 --  either it or something else manages to re-use the just-freed old memory, 
;   188 --  during the (very brief) moment that Thread A is still referencing it, we 
;   189 --  might have a problem. While I am happy to lock open/close, adding such
;   190 --  to getc (etc) would (without any doubt whatsoever) cripple performance. 
;   191 --  However, given that the pseudo-code for append (nb *NOT* prepend) is:
;   192 --      if <out of space> then
;   193 --          allocate a larger memory block
;   194 --          copy the contents (rep movsd, without refcounting etc)  [3]
;   195 --          replace the ref (ie [fdtbl], as per edi below)          [4]
;   196 --          free the previous memory
;   197 --      end if
;   198 --  and critically that [3][4] occur in that order, then a simple retry loop 
;   199 --  in all such Thread A code solves the issue, ie/eg change:
;   200 --
;   201 --          mov edx,[index]
;   202 --          mov edi,[fdtbl]
;   203 --          mov esi,[edi+edx] (esi:=fdtbl[fidx], shifting/scaling omitted)
;   204 --
;   205 --      to:
;   206 --
;   207 --          mov edx,[index]
;   208 --        ::retry
;   209 --          mov edi,[fdtbl]                                         [X]
;   210 --          mov esi,[edi+edx]                                       [Y]
;   211 --          cmp edi,[fdtbl]                                         [Z]
;   212 --          jne :retry
;   213 --
;   214 --  This effectively and efficiently makes the ([X][Y]) pair atomic, and is the
;   215 --  reason why fdtbl is always (except when locked) subscripted using #ilASM{}.
;   216 --  Of course any non-h4 value in [fdtbl] will always point to valid memory, even 
;   217 --  if that memory has been reused, and transiently loading complete and utter 
;   218 --  garbage into esi is no problem, as long as we do not use it/correct it soon.
;   219 --  (I suppose that technically this makes the ABA problem highly unlikely rather 
;   220 --   than impossible: *lots* would have to happen /both/ between X and Y, /and/ 
;   221 --   between Y and Z, for fdtbl to be replaced twice and esi left invalid. An ABA 
;   222 --   can occur /either/ side of Y without problem, as long as either XY or YZ 
;   223 --   behave atomically, and as the 3 are consecutive, one pair probably will.
;   224 --   If the highly improbable happens, then you will either have to add locking
;   225 --   in hll, or create a separate thread to handle all an application's file io.
;   226 --   It is of course unreasonable to deliberately slow everyone down for the one
;   227 --   in a million billion trillion chance that will quite probably never happen.)
;   228 --  (Update: if you can, get rid of the AGI stall on [Y], and focus on forcing
;   229 --   YZ to pair, which they should, that is if you have a problem.)
;   230 --  
;   231 --  A similar situation exists for length(fdtbl); so instead we use fdmax (ie the
;   232 --  latter is always in a fixed location and is always "good enough": it will cover
;   233 --  all files the current thread could possibly know about but may exclude 1 or 2
;   234 --  which have recently been created in other threads, that you could not legally  
;   235 --  want to access anyway, whereas length(fdtbl) moves during the append and hence 
;   236 --  could theoretically yield garbage, if the freed memory got reused quickly).
;   237 --
;   238 --  Also note that builtins\database.e has not been assessed for thread safety;
;   239 --  it is assumed that all database operations will occur in the same thread.
;   240 --  (It may already be perfectly thread safe, though to be honest I would be
;   241 --   more than a little gobsmacked, but I haven't even looked.)
;   242 --
;   243 
;   244 constant
;   245     INVALID_HANDLE_VALUE     = -1,
;   246     STD_INPUT_HANDLE         = -10,
;   247     STD_OUTPUT_HANDLE        = -11,
;   248     STD_ERROR_HANDLE         = -12,
;   249 
;   250 --DEV?? (this /is/ defined as such in psym.e)
;   251 --  C_PTR = C_POINTER,
;   252 
;   253 --  FDSIZE = 28,--8192,         -- an FD block is ... [DEV]
;   254 --DEV newsize (different for 32/64 bit)
;   255 --< [9]       8736[#00002220]       8704[#00002200]=8+8696      x(8,663)        s[1,082]            so, FDSIZE64=8688
;   256 --  [9]       9248[#00002420]       9216[#00002400]=8+9208      x(9,175)        s[1,146]            so, FDSIZE64=9200
;   257 -- [10]      10260[#00002814]      10240[#00002800]=4+10236         x(10,219)           s[2,554]    so, FDSIZE32=10232
;   258 --SUG:
;   259 --  FDSIZE = iff(machine_bits()=32,10232,8688)
;   260 --  FDSIZE = iff(machine_bits()=32,10232,9200)
;   261     FDSIZE32 = 8192,            -- an FD block is ... [DEV]
;   262     BUFFERSIZE32 = FDSIZE32-24, -- 24 bytes for header fields
;   263 
;   264     FDSIZE64 = 8192,            -- an FD block is ... [DEV]
;   265 --  FDSIZE64 = 44,          -- an FD block is ... [DEV]
;   266 --  FDSIZE64 = 120,         -- an FD block is ... [DEV]
;   267     BUFFERSIZE64 = FDSIZE64-40  -- 40 bytes for header fields
;   268 
;   269 ---- COORD structure (pDEST):
;   270 --constant
;   271 ----    C_SIZEX = 0,
;   272 ----    C_SIZEY = 2,
;   273 --  sizeof_COORD = 4
;   274 
;   275 -- CONSOLE_SCREEN_BUFFER_INFO structure:
;   276 constant
;   277     CSBI_SIZEX  = 0,    --  COORD      dwSize
;   278     CSBI_SIZEY  = 2,
;   279     CSBI_CPOSX  = 4,    --  COORD      dwCursorPosition
;   280     CSBI_CPOSY  = 6,
;   281     CSBI_ATTR   = 8,    --  WORD       wAttributes
;   282 --  CSBI_WINX1  = 10,   --  SMALL_RECT srWindow
;   283 --  CSBI_WINY1  = 12,
;   284 --  CSBI_WINX2  = 14,
;   285 --  CSBI_WINY2  = 16,
;   286 --  CSBI_MAXX   = 18,   --  COORD      dwMaximumWindowSize
;   287 --  CSBI_MAXY   = 20,
;   288 --  sizeof_CSBI = 22
;   289     sizeof_CSBI = 24,   -- (rounded up to whole dwords)
;   290     sizeof_CSBI64 = 24  -- (rounded up to whole qwords/keeps code looking right)
;   291 
;   292 
;   293 -- BY_HANDLE_FILE_INFORMATION structure
;   294 constant
;   295 --  BHFI_ATTR   = 0,    --  DWORD    dwFileAttributes
;   296 --  BHFI_CTIME  = 4,    --  FILETIME ftCreationTime
;   297 --  BHFI_ATIME  = 12,   --  FILETIME ftLastAccessTime
;   298 --  BHFI_UTIME  = 20,   --  FILETIME ftLastWriteTime
;   299 --  BHFI_SNUMB  = 28,   --  DWORD    dwVolumeSerialNumber
;   300     BHFI_FSHI   = 32,   --  DWORD    nFileSizeHigh
;   301     BHFI_FSLO   = 36,   --  DWORD    nFileSizeLow
;   302     BHFI_NLINK  = 40,   --  DWORD    nNumberOfLinks
;   303 --  BHFI_FIHI   = 44,   --  DWORD    nFileIndexHigh
;   304 --  BHFI_FILO   = 48,   --  DWORD    nFileIndexLow
;   305     sizeof_BHFI = 52,
;   306     sizeof_BHFI64 = 56  -- (rounded up to whole quadwords) [64 might be even better]
;   307 
;   308 -- OVERLAPPED structure (simplified)
;   309 constant
;   310 --  OV_INT      = 0,    --  ULONG_PTR Internal
;   311 --  OV_IHI      = 4,    --  ULONG_PTR InternalHigh
;   312     OV_OFFSET   = 8,    --  DWORD Offset
;   313     OV_OFFHI    = 12,   --  DWORD OffsetHigh
;   314     OV_EVENT    = 16,   --  HANDLE  hEvent
;   315     sizeof_OVERLAPPED = 20,
;   316     sizeof_OVERLAPPED64 = 24 -- (rounded up to whole quadwords) [32 might be even better]
;   317                              -- (actually, I think HANDLE is 8 bytes on 64-bit anyway)
;   318 
;   319 --/*
;   320 BHFI:   BYHANDLEFILEINFO structure
;   321 ;   BHFIdwFileAttributes     dd ?   ; DWORD    dwFileAttributes;        (offset 0)
;   322 ;   BHFIftCreationTime       dq ?   ; FILETIME ftCreationTime;          (offset 4)
;   323 ;   BHFIftLastAccessTime     dq ?   ; FILETIME ftLastAccessTime;        (offset 12)
;   324 ;   BHFIftLastWriteTime      dq ?   ; FILETIME ftLastWriteTime;         (offset 20)
;   325 ;   BHFIdwVolumeSerialNumber dd ?   ; DWORD    dwVolumeSerialNumber;    (offset 28)
;   326     rb 32
;   327     BHFInFileSizeHigh        dd ?   ; DWORD    nFileSizeHigh;           (offset 32)
;   328     BHFInFileSizeLow         dd ?   ; DWORD    nFileSizeLow;            (offset 36)
;   329 ;   BHFInNumberOfLinks       dd ?   ; DWORD    nNumberOfLinks;          (offset 40)
;   330 ;   BHFInFileIndexHigh       dd ?   ; DWORD    nFileIndexHigh;          (offset 44)
;   331 ;   BHFInFileIndexLow        dd ?   ; DWORD    nFileIndexLow;           (offset 48)
;   332     rb 12
;   333 --*/
;   334 
;   335 ---- SMALL_RECT structure (pSMALLRECT):
;   336 --constant
;   337 --  SR_Left = 0,
;   338 --  SR_Top = 2,
;   339 --  SR_Right = 4,
;   340 --  SR_Bottom = 6,
;   341 --  sizeof_SMALL_RECT = 8,
;   342 --  sizeof_SMALL_RECT64 = 8 -- (rounded for stack alignment/keeps code looking right)
;   343 
;   344 -- CHAR_INFO structure (pCHARINFO):
;   345 --constant
;   346 --  CI_UnicodeChar = 0,     -- Unicode or ANSI character
;   347 --  CI_Attributes = 2,      -- text and background colors
;   348 --  sizeof_CHAR_INFO = 4,
;   349 --  sizeof_CHAR_INFO64 = 4  -- (rounded up for stack alignment)
;   350 
;   351 
;   352 --DEV include kernel32.e
;   353 --atom kernel32,
;   354 --  xGetStdHandle,
;   355 --  xCreateFile,
;   356 --  xReadFile,
;   357 --  xWriteFile,
;   358 --  xSetFilePointer,
;   359 --  xGetFileInformationByHandle,
;   360 --  xLockFile,
;   361 --  xUnlockFile,
;   362 --  xGetFileSize,
;   363 --  xCloseHandle,
;   364 --  xAllocConsole,
;   365 --  xFreeConsole,
;   366 --  xSetConsoleMode,
;   367 --  xReadConsole,
;   368 --  xWriteConsole,
;   369 --  xGetConsoleMode,
;   370 --  xGetConsoleScreenBufferInfo,
;   371 --  xSetConsoleScreenBufferSize,
;   372 --  xScrollConsoleScreenBuffer,
;   373 --  xSetConsoleTextAttribute,
;   374 --  xGetLastError
;   375 --  xCSBI,
;   376 --DEV not thread-safe: (first pass completed)
;   377 --  pDword,         -- general purpose pointer to dword (bytes read/written/etc) [should be write-only] [DEV 26/05/2013 is now "safe"]
;   378 --  pSMALLRECT,
;   379 --  pCHARINFO
;   380 --  LF,
;   381 --  CRLF
;   382 --  back3,
;   383 --  pHigh
;   384 
;   385 constant
;   386     CREATE_NEW               = 1,
;   387 --  CREATE_ALWAYS            = 2,
;   388     OPEN_EXISTING            = 3,
;   389     OPEN_ALWAYS              = 4,
;   390     TRUNCATE_EXISTING        = 5,
;   391 --  GENERIC_READ             = #80000000,   -- Too big for forward init!
;   392 --  GENERIC_WRITE            = #40000000,   -- ""
;   393 --DEV newsize
;   394     GENERIC_READo4           = #20000000,   -- (#80000000 really | stored /4)
;   395     GENERIC_WRITEo4          = #10000000,   -- (#40000000 really | stored /4)
;   396     FILE_SHARE_READ          = 1,
;   397     FILE_SHARE_WRITE         = 2,
;   398     FILE_ATTRIBUTE_NORMAL    = #80,
;   399 --  FILE_FLAG_RANDOM_ACCESS  = #10000000,
;   400 -- SetFilePointer methods
;   401     FILE_BEGIN               = 0,
;   402 --  FILE_CURRENT             = 1,
;   403     FILE_END                 = 2,
;   404     NO_ERROR                 = 0,
;   405 
;   406     ENABLE_PROCESSED_INPUT   = 1,
;   407 --  ENABLE_LINE_INPUT        = 2,
;   408 --  ENABLE_ECHO_INPUT        = 4,
;   409 --  ENABLE_WINDOW_INPUT      = 8,
;   410 --  ENABLE_MOUSE_INPUT       = #10,
;   411 --  ENABLE_PROCESSED_OUTPUT  = 1,
;   412     ENABLE_WRAP_AT_EOL_OUTPUT = 2
;   413 
;   414     --DEV (suppress unused warnings, should prolly be using this in h_puts)
;   415 --  if ENABLE_PROCESSED_OUTPUT then end if
;   416 
;   417 --DEV newsize
;   418 --atom GENERIC_READ,        -- = #80000000,   -- Too big for forward init!
;   419 --   GENERIC_WRITE      -- = #40000000,   -- ""
;   420 
;   421 include VM\pHeap.e          -- init_cs etc
;   422 include VM\pStack.e
;   423 
;   424 atom fdcs -- critical section for locking fdtbl and freelist (in open/close only)
;   425 
;   426 --DEV need saving/restoring over opInterp...
;   427 sequence fdtbl      -- memory blocks, allocate(FDSIZE32/64)/4, as above
;   428                     -- Note that stdin/stdout/stderr (0/1/2) operate directly
;   429                     --  on real file handles without any special buffering.
;   430                     -- Hence (eg) getc(3) operates on fdtbl[1], and so on.
;   431 integer fdmax = 0   -- length(fdtbl), but thread-safe.
;   432 integer freelist = 0    -- free list pointer for fdtbl (lock before using/modifying)
;   433 
;   434 --sequence filenames
;   435 
;   436 -- verify fdtbl is a sequence of integer:
;   437 --!/**/ #isginfo{fdtbl,0b0100,MIN,MAX,integer,-2}
;   438 
;   439 --Layout of the FDSIZE32 memory blocks:
;   440 --==================================
;   441 --  +0  handle, also used for freelist
;   442 --  +4  fmode, see F_XXX flags below
;   443 --  +8  posn, read/write position, index to buffer
;   444 --  +12 fend, used part, index to buffer
;   445 --  +16 frealposn, 64 bit qword, see notes below
;   446 --DEV newsize (it will be fine like this but we may as well use pHeap sizes)
;   447 --  +24 buffer, 8192-24 = 8168 bytes
;   448 
;   449 constant HNDL = 0,
;   450          MODE = 4,  -- (could be a byte if that helps)
;   451          POSN = 8,  -- (could be a word if that helps)
;   452          FEND = 12, -- (could be a word if that helps)
;   453          POSL = 16, -- (real pos lodword)
;   454          POSH = 20, -- (real pos hidword)
;   455          BUFF = 24,
;   456         
;   457          HNDL64 = 0,
;   458          MODE64 = 8,    -- (could be a byte if that helps)
;   459          POSN64 = 16,   -- (could be a word if that helps)
;   460          FEND64 = 24,   -- (could be a word if that helps)
;   461          RPOS64 = 32,
;   462          BUFF64 = 40
;   463 
;   464 -- bit settings for fmode:
;   465 constant F_CLOSED   = #00,  -- file is closed/available for re-use (see flist)
;   466          F_READ     = #01,  -- file has read permission
;   467          F_WRITE    = #02,  -- file has write permission
;   468          F_BINARY   = #04,  -- binary mode
;   469          F_DIRTY    = #08   -- write cache flag
;   470 
;   471 -- If fmode has the F_DIRTY bit set, ie we have modified buffer but not written it out
;   472 --  to file, then frealposn corresponds to the start of the buffer, otherwise, ie we
;   473 --  have read something into the buffer but not altered it, frealposn corresponds to 
;   474 --  the fend of the buffer. Naturally, if we modify a clean buffer we must reposition
;   475 --  (via SetFilePointer) at the point we set F_DIRTY, for a subsequent write, but only
;   476 --  if there is something worth keeping in the (clean) buffer.
;   477 -- The use of atom to hold/modify frealposn (instead of a true 64-bit integer) limits
;   478 --  file sizes on 32-bit to 9,007,199,254,740,992 (not 18,446,744,073,709,551,616). 
;   479 --  In 2013 the largest drive available is 12TB, so you would need to plug together 
;   480 --  683 of them (somehow) to breach that. There is no such artificial limit on 64-bit,
;   481 --  where the limit is as expected(/predicted) 18 million TB, aka 4GB squared.
;   482 -- A posn of 1 and fend of 0 is the standard "empty" state.
;   483 
;   484 --DEV [ftbl]!=h4
;   485 integer finit
;   486         finit = 0
;   487 
;   488 procedure initF()
;   489 --/*
;   490     kernel32 = open_dll("kernel32.dll")
;   491 --#without reformat
;   492     xGetStdHandle = define_c_func(kernel32,"GetStdHandle",
;   493         {C_UINT},   --  DWORD  nStdHandle   // input, output, or error device
;   494 --DEV C_PTR?
;   495         C_INT)      -- HANDLE
;   496     xCreateFile = define_c_func(kernel32,"CreateFileA",
;   497         {C_PTR,     --  LPCTSTR  lpFileName,    // address of name of the file
;   498          C_LONG,    --  DWORD  dwDesiredAccess, // access (read-write) mode
;   499          C_LONG,    --  DWORD  dwShareMode, // share mode
;   500          C_PTR,     --  LPSECURITY_ATTRIBUTES  lpSecurityAttributes,    // address of security descriptor
;   501          C_LONG,    --  DWORD  dwCreationDistribution,  // how to create
;   502          C_LONG,    --  DWORD  dwFlagsAndAttributes,    // file attributes
;   503          C_PTR},    --  HANDLE  hTemplateFile   // handle of file with attributes to copy
;   504         C_INT)      -- HANDLE
;   505 --  xReadFile   = define_c_func(kernel32,"ReadFile",
;   506 --      {C_PTR,     --  HANDLE  hFile,  // handle of file to read
;   507 --       C_PTR,     --  LPVOID  lpBuffer,   // address of buffer that receives data
;   508 --       C_LONG,    --  DWORD  nNumberOfBytesToRead,    // number of bytes to read
;   509 --       C_PTR,     --  LPDWORD  lpNumberOfBytesRead,   // address of number of bytes read
;   510 --       C_PTR},    --  LPOVERLAPPED  lpOverlapped  // address of structure for data
;   511 --      C_INT)      -- BOOL
;   512 --  xWriteFile  = define_c_func(kernel32,"WriteFile",
;   513 --      {C_PTR,     --  HANDLE  hFile,  // handle of file to write to
;   514 --       C_PTR,     --  LPCVOID  lpBuffer,  // address of data to write to file
;   515 --       C_LONG,    --  DWORD  nNumberOfBytesToWrite,   // number of bytes to write
;   516 --       C_PTR,     --  LPDWORD  lpNumberOfBytesWritten,    // address of number of bytes written
;   517 --       C_PTR},    --  LPOVERLAPPED  lpOverlapped  // addr. of structure needed for overlapped I/O
;   518 --      C_INT)      -- BOOL
;   519 --  pHigh = allocate(4) -- for SetFilePointer's lpDistanceToMoveHigh
;   520     xSetFilePointer = define_c_func(kernel32,"SetFilePointer",
;   521         {C_PTR,     --  HANDLE  hFile,  // handle of file
;   522          C_LONG,    --  LONG  lDistanceToMove,  // number of bytes to move file pointer
;   523          C_PTR,     --  PLONG  lpDistanceToMoveHigh,    // address of high-order word of distance to move
;   524          C_LONG},   --  DWORD  dwMoveMethod     // how to move
;   525         C_LONG)     -- DWORD
;   526     xGetFileInformationByHandle = define_c_func(kernel32,"GetFileInformationByHandle",
;   527         {C_PTR,     --  HANDLE hFile
;   528          C_PTR},    --  LPBY_HANDLE_FILE_INFORMATION lpFileInformation
;   529         C_INT)      -- BOOL
;   530     xLockFile = define_c_func(kernel32,"LockFile",
;   531         {C_PTR,     --  HANDLE hFile
;   532          C_LONG,    --  DWORD dwFileOffsetLow
;   533          C_LONG,    --  DWORD dwFileOffsetHigh,
;   534          C_LONG,    --  DWORD nNumberOfBytesToLockLow,
;   535          C_LONG},   --  DWORD nNumberOfBytesToLockHigh
;   536         C_INT)      -- BOOL
;   537     xUnlockFile = define_c_func(kernel32,"UnlockFile",
;   538         {C_PTR,     --  HANDLE hFile
;   539          C_LONG,    --  DWORD dwFileOffsetLow
;   540          C_LONG,    --  DWORD dwFileOffsetHigh,
;   541          C_LONG,    --  DWORD nNumberOfBytesToUnlockLow,
;   542          C_LONG},   --  DWORD nNumberOfBytesToUnlockHigh
;   543         C_INT)      -- BOOL
;   544 --  xGetFileSize = define_c_func(kernel32,"GetFileSize",
;   545 --      {C_PTR,     --  HANDLE  hFile,  // handle of file to get size of
;   546 --       C_PTR},    --  LPDWORD  lpFileSizeHigh,    // address of high-order word for file size
;   547 --      C_LONG)     -- DWORD
;   548     xCloseHandle = define_c_func(kernel32,"CloseHandle",
;   549         {C_PTR},    --  HANDLE  hObject     // handle of object to close
;   550         C_INT)      -- BOOL
;   551     xAllocConsole = define_c_func(kernel32,"AllocConsole",
;   552         {},         --  no parameters
;   553         C_INT)      -- BOOL
;   554     xFreeConsole = define_c_func(kernel32,"FreeConsole",
;   555         {},         --  no parameters
;   556         C_INT)      -- BOOL
;   557     xSetConsoleMode = define_c_func(kernel32,"SetConsoleMode",
;   558         {C_PTR,     --  HANDLE  hConsole,   // handle of console input or screen buffer
;   559          C_LONG},   --  DWORD  fdwMode      // input or output mode to set
;   560         C_INT)      -- BOOL
;   561     xGetConsoleMode = define_c_func(kernel32,"GetConsoleMode",
;   562         {C_PTR,     --  HANDLE  hConsole,   // handle of console input or screen buffer
;   563          C_PTR},    --  LPDWORD  lpMode     // current mode flags
;   564         C_INT)      -- BOOL
;   565 --  xReadConsole = define_c_func(kernel32,"ReadConsoleA",
;   566 --      {C_PTR,     --  HANDLE  hConsoleInput,      // handle of a console input buffer
;   567 --       C_PTR,     --  LPVOID  lpvBuffer,  // address of buffer to receive data
;   568 --       C_LONG,    --  DWORD  cchToRead,   // number of characters to read
;   569 --       C_PTR,     --  LPDWORD  lpcchRead, // address of number of characters read
;   570 --       C_PTR},    --  LPVOID  lpvReserved         // reserved
;   571 --      C_INT)      -- BOOL
;   572     xWriteConsole = define_c_func(kernel32,"WriteConsoleA",
;   573         {C_PTR,     --  HANDLE  hConsoleOutput, // handle of a console screen buffer
;   574          C_PTR,     --  CONST VOID  *lpvBuffer, // address of buffer to write from
;   575          C_LONG,    --  DWORD  cchToWrite,      // number of characters to write
;   576          C_PTR,     --  LPDWORD  lpcchWritten,  // address of number of characters written
;   577          C_PTR},    --  LPVOID  lpvReserved     // reserved
;   578         C_INT)      -- BOOL
;   579     xGetConsoleScreenBufferInfo = define_c_func(kernel32,"GetConsoleScreenBufferInfo",
;   580         {C_PTR,     --  HANDLE  hConsoleOutput, // handle of console screen buffer
;   581          C_PTR},    --  PCONSOLE_SCREEN_BUFFER_INFO  // address of screen buffer info
;   582         C_INT)      -- BOOL
;   583     xSetConsoleScreenBufferSize = define_c_func(kernel32,"GetConsoleScreenBufferInfo",
;   584         {C_PTR,     --  HANDLE  hConsoleOutput, // handle of console screen buffer
;   585          C_INT},    --  COORD  coordSize    // new size in character rows and cols
;   586         C_INT)      -- BOOL
;   587     xScrollConsoleScreenBuffer = define_c_func(kernel32,"ScrollConsoleScreenBufferA",
;   588         {C_PTR,     --  HANDLE  hConsoleOutput, // handle of console screen buffer
;   589          C_PTR,     --  PSMALL_RECT  psrctSourceRect, // address of screen buffer rect. to move
;   590          C_PTR,     --  PSMALL_RECT  psrctClipRect, // address of affected screen buffer rect.
;   591          C_INT,     --  COORD  coordDestOrigin, // new location of screen buffer rect.
;   592          C_PTR},    --  PCHAR_INFO  pchiFill    // address of fill character and color
;   593         C_INT)      -- BOOL
;   594     xSetConsoleTextAttribute = define_c_func(kernel32,"SetConsoleTextAttribute",
;   595         {C_PTR,     --  HANDLE  hConsoleOutput, // handle of console screen buffer
;   596          C_INT},    --  WORD wAttributes
;   597         C_INT)      -- BOOL
;   598     xGetLastError = define_c_func(kernel32, "GetLastError",
;   599         {},
;   600         C_INT)      -- DWORD
;   601 --#without reformat
;   602     --
;   603     -- These must be initialised inside initF() because they are stored
;   604     -- as floats, ... and only short literal integers are auto-initialised
;   605     -- in forward referenced routines!
;   606     --
;   607 --DEV newsize
;   608 --  GENERIC_READ             = #80000000    -- Too big for forward init!
;   609 --  GENERIC_WRITE            = #40000000    -- ""
;   610 --*/
;   611     fdtbl = {}
    mov rsi,qword[#004022C8]              ;#0043B5D9: 48:213065 E86CFCFF         uv 40 00  1   1      
    mov rdx,[#004030D0] (fdtbl)           ;#0043B5E0: 48:213025 E97AFCFF         vu 04 00  1   1      
    mov r15,h4                            ;#0043B5E7: 49:277 0000000000000040    uv 8000 00  1   2      
    cmp rsi,r15                           ;#0043B5F1: 4C:071376                  uv 00 8040  1   3 8000   
    jl #0043B5FC                          ;#0043B5F4: 174 06                     v  00 00  1   3      
    add qword[rbx+rsi*4-16],1             ;#0043B5F6: 48:203104263 F0 01         u  00 48  3   4      
    mov [#004030D0] (fdtbl),rsi           ;#0043B5FC: 48:211065 CD7AFCFF         vu 00 40  1   6      
    mov r15,h4                            ;#0043B603: 49:277 0000000000000040    uv 8000 00  1   7      
    cmp rdx,r15                           ;#0043B60D: 4C:071372                  uv 00 8004  1   8 8000   
    jle #0043B61F                         ;#0043B610: 176 0D                     v  00 00  1   8      
    sub qword[rbx+rdx*4-16],1             ;#0043B612: 48:203154223 F0 01         u  00 0C  3   9      
    jne #0043B61F                         ;#0043B618: 165 05                     v  00 00  1  11      
    call #004422DA (:%pDealloc)           ;#0043B61A: 350 BB6C0000               v  00 00  1  12      
;   612 --  filenames = {}
;   613     fdcs = init_cs()
    lea rdi,[#004030C8] (fdcs)            ;#0043B61F: 48:215075 A27AFCFF         uv 80 00  1  13      
    call #0044250E (:%pInitCS)            ;#0043B626: 350 E36E0000               v  00 00  1  13      
;   614 --  pDword = allocate(4)    --DEV /4?
;   615 --  LF = allocate(1)
;   616 --  CRLF = allocate(2)  --DEV /4? or inline this?
;   617 --  poke(CRLF,"\r\n")
;   618 --  LF = CRLF+1
;   619 --  back3 = allocate(3)
;   620 --  poke(back3,{8,' ',8})
;   621 
;   622     finit = 1
    mov qword[#00403178] (finit),1        ;#0043B62B: 48:307005 427BFCFF 01000000 uv 00 00  1  14      
    jmp #0044298D (:%opRetf)              ;#0043B636: 351 52730000               v  00 00  1  14      
;   623 end procedure
;   624 
;   625 
;   626 --constant e57ifn = 57  -- "invalid file name"
;   627 --constant e59wfmfao = 59 -- "wrong file mode for attempted operation"
;   628 --constant e65sfics = 65    -- "sequence found in character string"
;   629 
;   630 --DEV remove this...? (see eg seek, open) [test as you go and get the era right!]
;   631 procedure iofatal(integer errcode, integer ep1=0)
    mov rdi,[rbp-8] (ep1)                 ;#0043C328: 48:213175 F8               uv 80 20  1   1      
    mov r15,h4                            ;#0043C32C: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0043C336: 4C:071377                  uv 00 8080  1   2      
    jne #0043C33F                         ;#0043C339: 165 04                     v  00 00  1   2      
    mov [rbp-8] (ep1),rbx                 ;#0043C33B: 48:211135 F8               uv 00 28  1   3      
;   632     #ilASM{
;   633         [32]
;   634             mov eax,[errcode]
;   635             mov edi,[ep1]
;   636             xor esi,esi     -- ep2 unused
;   637             mov ebp,[ebp+20]    -- ebp_prev --(?is this just to counteract iofatal?)
;   638             call :%pRTErn       -- fatal error
;   639         [64]
;   640             mov rax,[errcode]
                    mov rax,[rbp] (errcode)  ;#0043C33F: 48:213105 00               vu 01 20  1   3      
;   641             mov rdi,[ep1]
                    mov rdi,[rbp-8] (ep1)  ;#0043C343: 48:213175 F8               uv 80 20  1   4      
;   642             xor rsi,rsi     -- ep2 unused
                    xor rsi,rsi           ;#0043C347: 48:061366                  vu 40 40  1   4      
;   643             mov rbp,[rbp+40]    -- ebp_prev
                    mov rbp,[rbp+40] (prevebp)  ;#0043C34A: 48:213155 28               uv 20 20  1   5      
;   644             call :%pRTErn       -- fatal error
                    call #00442DC8 (:%pRTErn)  ;#0043C34E: 350 756A0000               v  00 00  1   5      
;   645         []
;   646           }
;   647     ?9/0
    call #00442DD2 (:%pDiv0)              ;#0043C353: 350 7A6A0000               v  00 00  1   6      
    jmp #0044298D (:%opRetf)              ;#0043C358: 351 30660000               v  00 00  1   7      
;   648 end procedure
;   649 
;   650 --/*
;   651 --DEV ,atom era?
;   652 old function toString(sequence name, integer errno)
;   653 -- explicitly convert a dword-sequence to an 8-bit string.
;   654 -- errno should be one of the constants just defined (e57ifn..e65sfics)
;   655 string res
;   656 integer nlen
;   657 object ch
;   658     nlen = length(name)
;   659     res = repeat(' ',nlen)
;   660     for i=1 to nlen do
;   661         ch = name[i]
;   662         if not atom(ch) then
;   663             iofatal(errno)
;   664         end if
;   665         ch = and_bits(ch,#FF)
;   666         res[i] = ch
;   667     end for
;   668 --DEV (alternative to below)
;   669     name = ""
;   670     return res
;   671 end function
;   672 --DEV compiler thingy... (xType=0 on symtab[1548] (name)) (methinks because routine is being optimised away but still analysed)
;   673 --{} = toString("123",57)
;   674 --*/
;   675 
;   676 function toStringN(sequence name)
;   677 -- explicitly convert a dword-sequence to an 8-bit string.
;   678 -- returns {flag,res}; if flag is 0 a non-char/subsequence was found (and res is partial).
;   679 integer nlen
;   680 object ch
;   681 string res
;   682 integer flag = 1
    mov qword[rbp-32] (flag),1            ;#0043D9D9: 48:307105 E0 01000000      uv 00 20  1   1      
;   683     nlen = length(name)
    mov rdi,[rbp] (name)                  ;#0043D9E1: 48:213175 00               vu 80 20  1   1      
    mov rcx,[rbx+rdi*4-24]                ;#0043D9E5: 48:48:213114273 E8         uv 02 88  1   4    *80*
    mov [rbp-8] (nlen),rcx                ;#0043D9EB: 48:211115 F8               uv 00 22  1   5 02   
;   684     res = repeat(' ',nlen)
    lea rdi,[rbp-24] (res)                ;#0043D9EF: 48:215175 E8               vu 80 20  1   5      
    mov rax,32                            ;#0043D9F3: 48:307300 20000000         uv 01 00  1   6      
    call #0043B1E1 (:%opRepCh)            ;#0043D9FA: 350 E2D7FFFF               v  00 00  1   6      
;   685     for i=1 to nlen do
    mov rsi,[rbp-8] (nlen)                ;#0043D9FF: 48:213165 F8               uv 40 20  1   7      
    mov [rbp-40] (symtab[978]),rsi        ;#0043DA03: 48:211165 D8               uv 00 60  1   8 40   
    mov qword[rbp-48] (i),1               ;#0043DA07: 48:307105 D0 01000000      vu 00 20  1   8      
    cmp rsi,1                             ;#0043DA0F: 48:201376 01000000         uv 00 40  1   9      
    jl #0043DA8D                          ;#0043DA16: 174 75                     v  00 00  1   9      
;   686         ch = name[i]
    mov rdi,[rbp-48] (i)                  ;#0043DA18: 48:213175 D0               uv 80 20  1  10      
    lea rcx,[rbp-16] (ch)                 ;#0043DA1C: 48:215115 F0               vu 02 20  1  10      
    mov rsi,[rbp] (name)                  ;#0043DA20: 48:213165 00               uv 40 20  1  11      
    mov rdx,973                           ;#0043DA24: 48:307302 CD030000         vu 04 00  1  11      
    call #00441675 (:%pSubse1)            ;#0043DA2B: 350 453C0000               v  00 00  1  12      
;   687         if not atom(ch) then
    mov rax,[rbp-16] (ch)                 ;#0043DA30: 48:213105 F0               uv 01 20  1  13      
    mov r15,h4                            ;#0043DA34: 49:277 0000000000000040    vu 8000 00  1  13      
    cmp rax,r15                           ;#0043DA3E: 4C:071370                  uv 00 8001  1  14      
    jl #0043DA50                          ;#0043DA41: 174 0D                     v  00 00  1  14      
    cmp byte[rbx+rax*4-1],#12             ;#0043DA43: 200174203 FF 12            u  00 09  2  15      
    je #0043DA50                          ;#0043DA48: 164 06                     v  00 00  1  16      
;   688             flag = 0
    mov [rbp-32] (flag),rbx               ;#0043DA4A: 48:211135 E0               uv 00 28  1  17      
;   689             exit
    jmp #0043DA8D                         ;#0043DA4E: 353 3D                     v  00 00  1  17      
;   690         end if
;   691         ch = and_bits(ch,#FF)
    lea rdi,[rbp-16] (ch)                 ;#0043DA50: 48:215175 F0               uv 80 20  1  18      
    mov rcx,rax                           ;#0043DA54: 48:211301                  vu 02 01  1  18      
    mov rax,qword[#00402268]              ;#0043DA57: 48:213005 0A48FCFF         uv 01 00  1  19      
    call #0043F6C1 (:%opAndBits)          ;#0043DA5E: 350 5E1C0000               v  00 00  1  19      
;   692         res[i] = ch
    mov rdi,[rbp-48] (i)                  ;#0043DA63: 48:213175 D0               uv 80 20  1  20      
    mov rcx,[rbp-16] (ch)                 ;#0043DA67: 48:213115 F0               vu 02 20  1  20      
    mov rsi,[rbp-24] (res)                ;#0043DA6B: 48:213165 E8               uv 40 20  1  21      
    lea rax,[rbp-24] (res)                ;#0043DA6F: 48:215105 E8               vu 01 20  1  21      
    call #00440EB1 (:%pRepe1is)           ;#0043DA73: 350 39340000               v  00 00  1  22      
;   693     end for
    mov rax,[rbp-48] (i)                  ;#0043DA78: 48:213105 D0               uv 01 20  1  23      
    mov rdi,[rbp-40] (symtab[978])        ;#0043DA7C: 48:213175 D8               vu 80 20  1  23      
    add rax,1                             ;#0043DA80: 48:203300 01               uv 01 01  1  24      
    cmp rax,rdi                           ;#0043DA84: 48:073307                  uv 00 81  1  25 01   
    mov [rbp-48] (i),rax                  ;#0043DA87: 48:211105 D0               vu 00 21  1  25      
    jle #0043DA18                         ;#0043DA8B: 176 8B                     v  00 00  1  26      
;   694     return {flag,res}
    lea rax,[rbp-56] (symtab[980])        ;#0043DA8D: 48:215105 C8               uv 01 20  1  27      
    mov rdx,2                             ;#0043DA91: 48:307302 02000000         vu 04 00  1  27      
    push #0043DAC9                        ;#0043DA98: 150 C9DA4300               uv 00 00  1  28      
    push rax                              ;#0043DA9D: 120                        vu 00 01  1  28      
    mov rcx,[rbp-24] (res)                ;#0043DA9E: 48:213115 E8               uv 02 20  1  29      
    mov r15,h4                            ;#0043DAA2: 49:277 0000000000000040    vu 8000 00  1  29      
    cmp rcx,r15                           ;#0043DAAC: 4C:071371                  uv 00 8002  1  30      
    jl #0043DABC                          ;#0043DAAF: 174 0B                     v  00 00  1  30      
    add qword[rbx+rcx*4-16],1             ;#0043DAB1: 48:203104213 F0 01         u  00 0A  3  31      
    cmp eax,976                           ;#0043DAB7: 075 D0030000               vu 00 01  1  33      
    push rcx                              ;#0043DABC: 121                        uv 00 02  1  34      
    push qword[rbp-32] (flag)             ;#0043DABD: 377165 E0                  np 00 20  2  35      
    mov rdi,[rbp-56] (symtab[980])        ;#0043DAC0: 48:213175 C8               uv 80 20  1  37      
    jmp #004404BD (:%pMkSq)               ;#0043DAC4: 351 F4290000               v  00 00  1  37      
    mov rax,[rbp-56] (symtab[980])        ;#0043DAC9: 48:213105 C8               uv 01 20  1  38      
    mov [rbp-56] (symtab[980]),rbx        ;#0043DACD: 48:211135 C8               vu 00 28  1  38      
    jmp #0044298D (:%opRetf)              ;#0043DAD1: 351 B74E0000               v  00 00  1  39      
;   695 end function
;   696 
;   697 --DEV newEmit (global)
;   698 --global function open(sequence filepath, object openmode)
;   699 function fopen(sequence filepath, object openmode) -- (see :%opOpen)
    mov rsi,[rbp] (filepath)              ;#0043D2D5: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0043D2D9: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0043D2E3: 4C:071376                  uv 00 8040  1   2      
    jl #0043D2EF                          ;#0043D2E6: 174 07                     v  00 00  1   2      
    test byte[rbx+rsi*4-1],#80            ;#0043D2E8: 366104263 FF 80            u  00 48  2   3      
    jne #0043D2FB                         ;#0043D2ED: 165 0C                     v  00 00  1   4      
    mov rcx,983                           ;#0043D2EF: 48:307301 D7030000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0043D2F6: 350 5D570000               v  00 00  1   5      
;   700 --
;   701 -- Open a file or device, to get the file number. -1 is returned if the open fails.
;   702 -- Single character modes are used for text handling: "r"ead, "w"rite, "u"pdate, "a"ppend.
;   703 -- Output to text files will have carriage-return characters (\r) automatically added before
;   704 -- linefeed characters (\n). On input, these carriage-return characters are removed.
;   705 -- A control-Z character (ASCII 26) will signal an immediate end of file. [DEV]
;   706 -- Binary mode uses the same one-character mode as above plus a "b", ie "rb","wb","ub","ab".
;   707 --
;   708 -- Note: open(xxx,'a') is perfectly valid and the same as open(xxx,"a"), but on Phix only.
;   709 --
;   710 integer res, imode, fmode
;   711 integer accessmode, createmode, sharemode
;   712 atom fhandle
;   713 integer iThis
;   714 --atom frealposn
;   715 
;   716     if not finit then initF() end if
    mov rcx,[#00403178] (finit)           ;#0043D2FB: 48:213015 765EFCFF         uv 02 00  1   6      
    test rcx,rcx                          ;#0043D302: 48:205311                  uv 00 02  1   7 02   
    jne #0043D323                         ;#0043D305: 165 1C                     v  00 00  1   7      
    xor rcx,rcx                           ;#0043D307: 48:061311                  uv 02 02  1   8      
    mov rdx,967                           ;#0043D30A: 48:307302 C7030000         vu 04 00  1   8      
    call #004428DB (:%opFrame) (initF)    ;#0043D311: 350 C5550000               v  00 00  1   9      
    mov qword[retaddr],#0043D323          ;#0043D316: 48:307105 20 23D34300      uv 00 20  1  10      
    jmp #0043B5D9 (code:initF)            ;#0043D31E: 351 B6E2FFFF               v  00 00  1  10      
;   717     fmode = 0                                   -- assume text mode
    mov [rbp-32] (fmode),rbx              ;#0043D323: 48:211135 E0               uv 00 28  1  11      
;   718     if sequence(openmode) then                  -- allow open(<file>,'r') as well as open(<file>,"r")
    mov rdi,[rbp-8] (openmode)            ;#0043D327: 48:213175 F8               vu 80 20  1  11      
    mov r15,h4                            ;#0043D32B: 49:277 0000000000000040    uv 8000 00  1  12      
    cmp rdi,r15                           ;#0043D335: 4C:071377                  uv 00 8080  1  13 8000   
    jl #0043D429                          ;#0043D338: 017214 EB000000            v  00 00  1  13      
    test byte[rbx+rdi*4-1],#80            ;#0043D33E: 366104273 FF 80            u  00 88  2  14      
    je #0043D429                          ;#0043D343: 017204 E0000000            v  00 00  1  15      
;   719         if length(openmode)=2 then
    mov rax,[rbx+rdi*4-24]                ;#0043D349: 48:48:213104273 E8         uv 01 88  1  16      
    cmp rax,2                             ;#0043D34F: 48:203370 02               uv 00 01  1  17 01   
    jne #0043D3F8                         ;#0043D353: 017205 9F000000            v  00 00  1  17      
;   720             if find(openmode[2],"bB") then
    mov rdi,2                             ;#0043D359: 48:307307 02000000         uv 80 00  1  18      
    lea rcx,[rbp-88] (symtab[994])        ;#0043D360: 48:215115 A8               vu 02 20  1  18      
    mov rsi,[rbp-8] (openmode)            ;#0043D364: 48:213165 F8               uv 40 20  1  19      
    mov rdx,984                           ;#0043D368: 48:307302 D8030000         vu 04 00  1  19      
    call #00441675 (:%pSubse1)            ;#0043D36F: 350 01430000               v  00 00  1  20      
    mov rcx,7                             ;#0043D374: 48:307301 07000000         uv 02 00  1  21      
    mov rdx,75                            ;#0043D37B: 48:307302 4B000000         vu 04 00  1  21      
    call #004428DB (:%opFrame) (find)     ;#0043D382: 350 54550000               v  00 00  1  22      
    mov rdi,[rbp+40] (prevebp)            ;#0043D387: 48:213175 28               uv 80 20  1  23      
    mov rax,[rdi-88]                      ;#0043D38B: 48:213107 A8               uv 01 80  1  26 80 *80*
    xor rbx,rbx                           ;#0043D38F: 48:061333                  vu 08 08  1  26      
    mov r15,h4                            ;#0043D392: 49:277 0000000000000040    uv 8000 00  1  27      
    cmp rax,r15                           ;#0043D39C: 4C:071370                  uv 00 8001  1  28 8000   
    jl #0043D3AC                          ;#0043D39F: 174 0B                     v  00 00  1  28      
    add qword[rbx+rax*4-16],1             ;#0043D3A1: 48:203104203 F0 01         u  00 09  3  29      
    cmp eax,994                           ;#0043D3A7: 075 E2030000               vu 00 01  1  31      
    mov [rbp] (x),rax                     ;#0043D3AC: 48:211105 00               uv 00 21  1  32      
    mov rcx,qword[#00403180]              ;#0043D3B0: 48:213015 C95DFCFF         vu 02 00  1  32      
    mov [rbp-8] (s),rcx                   ;#0043D3B7: 48:211115 F8               uv 00 22  1  33      
    add qword[rbx+rcx*4-16],1             ;#0043D3BB: 48:203104213 F0 01         u  00 0A  3  35    *02*
    mov qword[retaddr],#0043D3CE          ;#0043D3C1: 48:307105 20 CED34300      vu 00 20  1  37      
    jmp #0043DAD6 (code:find)             ;#0043D3C9: 351 08070000               v  00 00  1  38      
    test rax,rax                          ;#0043D3CE: 48:205300                  uv 00 01  1  39      
    je #0043D429                          ;#0043D3D1: 164 56                     v  00 00  1  39      
;   721                 fmode = F_BINARY
    mov qword[rbp-32] (fmode),4           ;#0043D3D3: 48:307105 E0 04000000      uv 00 20  1  40      
;   722                 openmode = openmode[1]          -- make openmode a char
    mov rdi,1                             ;#0043D3DB: 48:307307 01000000         vu 80 00  1  40      
    lea rcx,[rbp-8] (openmode)            ;#0043D3E2: 48:215115 F8               uv 02 20  1  41      
    mov rsi,[rbp-8] (openmode)            ;#0043D3E6: 48:213165 F8               vu 40 20  1  41      
    mov rdx,984                           ;#0043D3EA: 48:307302 D8030000         uv 04 00  1  42      
    call #00441675 (:%pSubse1)            ;#0043D3F1: 350 7F420000               v  00 00  1  42      
;   723              end if
    jmp #0043D429                         ;#0043D3F6: 353 31                     v  00 00  1  43      
;   724         elsif length(openmode)=1 then
    lea rdi,[rbp-80] (symtab[993])        ;#0043D3F8: 48:215175 B0               uv 80 20  1  44      
    mov rsi,[rbp-8] (openmode)            ;#0043D3FC: 48:213165 F8               vu 40 20  1  44      
    mov rdx,984                           ;#0043D400: 48:307302 D8030000         uv 04 00  1  45      
    call #0043F28D (:%opLen)              ;#0043D407: 350 811E0000               v  00 00  1  45      
    cmp rcx,1                             ;#0043D40C: 48:203371 01               uv 00 02  1  46      
    jne #0043D429                         ;#0043D410: 165 17                     v  00 00  1  46      
;   725             openmode = openmode[1]              -- make openmode a char
    mov rdi,1                             ;#0043D412: 48:307307 01000000         uv 80 00  1  47      
    lea rcx,[rbp-8] (openmode)            ;#0043D419: 48:215115 F8               vu 02 20  1  47      
    mov rdx,984                           ;#0043D41D: 48:307302 D8030000         uv 04 00  1  48      
    call #00441675 (:%pSubse1)            ;#0043D424: 350 4C420000               v  00 00  1  48      
;   726 --      else invalid length, triggers invalid open mode next
;   727         end if
;   728     end if
;   729 
;   730     if not string(filepath) then
    mov rdi,[rbp] (filepath)              ;#0043D429: 48:213175 00               uv 80 20  1  49      
    cmp byte[rbx+rdi*4-1],#82             ;#0043D42D: 200174273 FF 82            u  00 88  2  52    *80*
    je #0043D536                          ;#0043D432: 017204 FE000000            v  00 00  1  53      
;   731 --      filepath = toString(filepath,e57ifn)
;   732         {res,filepath} = toStringN(filepath)
    mov rcx,8                             ;#0043D438: 48:307301 08000000         uv 02 00  1  54      
    mov rdx,972                           ;#0043D43F: 48:307302 CC030000         vu 04 00  1  54      
    call :%opFrame (toStringN)            ;#0043D446: 350 90540000               v  00 00  1  55      
    mov rdi,[rbp+40] (prevebp)            ;#0043D44B: 48:213175 28               uv 80 20  1  56      
    mov rax,[rdi]                         ;#0043D44F: 48:213007                  uv 01 80  1  59 80 *80*
    xor rbx,rbx                           ;#0043D452: 48:061333                  vu 08 08  1  59      
    mov r15,h4                            ;#0043D455: 49:277 0000000000000040    uv 8000 00  1  60      
    cmp rax,r15                           ;#0043D45F: 4C:071370                  uv 00 8001  1  61 8000   
    jl #0043D46F                          ;#0043D462: 174 0B                     v  00 00  1  61      
    add qword[rbx+rax*4-16],1             ;#0043D464: 48:203104203 F0 01         u  00 09  3  62      
    cmp eax,983                           ;#0043D46A: 075 D7030000               vu 00 01  1  64      
    mov [rbp] (name),rax                  ;#0043D46F: 48:211105 00               uv 00 21  1  65      
    mov qword[retaddr],#0043D480          ;#0043D473: 48:307105 20 80D44300      vu 00 20  1  65      
    jmp #0043D9D9 (code:toStringN)        ;#0043D47B: 351 59050000               v  00 00  1  66      
    push rax                              ;#0043D480: 120                        uv 00 01  1  67      
    mov rcx,[rbp-96] (symtab[996])        ;#0043D481: 48:213115 A0               vu 02 20  1  67      
    mov r15,h4                            ;#0043D485: 49:277 0000000000000040    uv 8000 00  1  68      
    cmp rcx,r15                           ;#0043D48F: 4C:071371                  uv 00 8002  1  69 8000   
    jle #0043D4A4                         ;#0043D492: 176 10                     v  00 00  1  69      
    sub qword[rbx+rcx*4-16],1             ;#0043D494: 48:203154213 F0 01         u  00 0A  3  70      
    jne #0043D4A4                         ;#0043D49A: 165 08                     v  00 00  1  72      
    mov rdx,rcx                           ;#0043D49C: 48:213321                  uv 04 02  1  73      
    call #004422DA (:%pDealloc)           ;#0043D49F: 350 364E0000               v  00 00  1  73      
    pop dword[rbp-96] (symtab[996])       ;#0043D4A4: 217105 A0                  np 00 20  3  74      
    mov rdi,2                             ;#0043D4A7: 48:307307 02000000         uv 80 00  1  77      
    mov rcx,rbp                           ;#0043D4AE: 48:213315                  vu 02 20  1  77      
    mov rsi,[rbp-96] (symtab[996])        ;#0043D4B1: 48:213165 A0               uv 40 20  1  78      
    mov rdx,996                           ;#0043D4B5: 48:307302 E4030000         vu 04 00  1  78      
    call #00441675 (:%pSubse1)            ;#0043D4BC: 350 B4410000               v  00 00  1  79      
    mov rdi,[rbp] (filepath)              ;#0043D4C1: 48:213175 00               uv 80 20  1  80      
    mov r15,h4                            ;#0043D4C5: 49:277 0000000000000040    vu 8000 00  1  80      
    cmp rdi,r15                           ;#0043D4CF: 4C:071377                  uv 00 8080  1  81      
    jl #0043D4DB                          ;#0043D4D2: 174 07                     v  00 00  1  81      
    test byte[rbx+rdi*4-1],#80            ;#0043D4D4: 366104273 FF 80            u  00 88  2  82      
    jne #0043D4E7                         ;#0043D4D9: 165 0C                     v  00 00  1  83      
    mov rcx,983                           ;#0043D4DB: 48:307301 D7030000         uv 02 00  1  84      
    call #00442A58 (:%opTchkFail)         ;#0043D4E2: 350 71550000               v  00 00  1  84      
    mov rdi,1                             ;#0043D4E7: 48:307307 01000000         uv 80 00  1  85      
    lea rcx,[rbp-16] (res)                ;#0043D4EE: 48:215115 F0               vu 02 20  1  85      
    mov rsi,[rbp-96] (symtab[996])        ;#0043D4F2: 48:213165 A0               uv 40 20  1  86      
    mov rdx,996                           ;#0043D4F6: 48:307302 E4030000         vu 04 00  1  86      
    call #004416F2 (:%pSubse1i)           ;#0043D4FD: 350 F0410000               v  00 00  1  87      
    mov r15,h4                            ;#0043D502: 49:277 0000000000000040    uv 8000 00  1  88      
    cmp rax,r15                           ;#0043D50C: 4C:071370                  uv 00 8001  1  89 8000   
    jl #0043D51D                          ;#0043D50F: 174 0C                     v  00 00  1  89      
    mov rcx,985                           ;#0043D511: 48:307301 D9030000         uv 02 00  1  90      
    call #00442A58 (:%opTchkFail)         ;#0043D518: 350 3B550000               v  00 00  1  90      
;   733         if res=0 then
    cmp rax,0                             ;#0043D51D: 48:203370 00               uv 00 01  1  91      
    jne #0043D536                         ;#0043D521: 165 13                     v  00 00  1  91      
;   734 --          iofatal(e57ifn)
;   735             #ilASM{
;   736                 [32]
;   737                     mov edx,[ebp+12]                    -- "called from" address
;   738                     mov ebp,[ebp+20]                    -- prev_ebp
;   739                     mov al,57                           -- e57ifn: "invalid file name"
;   740 --                  xor edi,edi                         -- ep1 unused
;   741 --                  xor esi,esi                         -- ep2 unused
;   742                     sub edx,1
;   743                 [64]
;   744                     mov rdx,[rbp+24]                    -- "called from" address
                            mov rdx,[rbp+24]  ;#0043D523: 48:213125 18               uv 04 20  1  92      
;   745                     mov rbp,[rbp+40]                    -- prev_ebp
                            mov rbp,[rbp+40] (prevebp)  ;#0043D527: 48:213155 28               vu 20 20  1  92      
;   746                     mov al,57                           -- e57ifn: "invalid file name"
                            mov al,57     ;#0043D52B: 260 39                     uv 01 00  1  93      
;   747 --                  xor rdi,rdi                         -- ep1 unused
;   748 --                  xor rsi,rsi                         -- ep2 unused
;   749                     sub rdx,1
                            sub rdx,1     ;#0043D52D: 48:203352 01               vu 04 04  1  93      
;   750                 []
;   751                     jmp :!iDiag
                            jmp #00442E66 (:!iDiag)  ;#0043D531: 351 30590000               v  00 00  1  94      
;   752                   }
;   753         end if
;   754     end if
;   755     if openmode<'a' then
    mov rdi,97                            ;#0043D536: 48:307307 61000000         uv 80 00  1  95      
    mov rax,[rbp-8] (openmode)            ;#0043D53D: 48:213105 F8               vu 01 20  1  95      
    mov rsi,128                           ;#0043D541: 48:307306 80000000         uv 40 00  1  96      
    mov rdx,984                           ;#0043D548: 48:307302 D8030000         vu 04 00  1  96      
    call #0043FA81 (:%opJcc)              ;#0043D54F: 350 2D250000               v  00 00  1  97      
    jge #0043D56A                         ;#0043D554: 175 14                     v  00 00  1  98      
;   756         openmode += 'a'-'A'
    lea rdi,[rbp-8] (openmode)            ;#0043D556: 48:215175 F8               uv 80 20  1  99      
    mov rcx,[rbp-8] (openmode)            ;#0043D55A: 48:213115 F8               vu 02 20  1  99      
    mov rax,[MB_ICONQUESTION]             ;#0043D55E: 48:213005 0B4CFCFF         uv 01 00  1 100      
    call #0043F4AF (:%opAdd)              ;#0043D565: 350 451F0000               v  00 00  1 100      
;   757     end if
;   758     if openmode='r' then        -- read
    mov rdi,[rbp-8] (openmode)            ;#0043D56A: 48:213175 F8               uv 80 20  1 101      
    cmp rdi,114                           ;#0043D56E: 48:203377 72               uv 00 80  1 102 80   
    jne #0043D599                         ;#0043D572: 165 25                     v  00 00  1 102      
;   759         accessmode = GENERIC_READo4
    mov qword[accessmode],536870912       ;#0043D574: 48:307105 D8 00000020      uv 00 20  1 103      
;   760         sharemode = FILE_SHARE_READ
    mov qword[rbp-56] (sharemode),1       ;#0043D57C: 48:307105 C8 01000000      vu 00 20  1 103      
;   761         createmode = OPEN_EXISTING
    mov qword[rbp-48] (createmode),3      ;#0043D584: 48:307105 D0 03000000      uv 00 20  1 104      
;   762         imode = F_READ
    mov qword[rbp-24] (imode),1           ;#0043D58C: 48:307105 E8 01000000      vu 00 20  1 104      
    jmp #0043D64C                         ;#0043D594: 351 B3000000               v  00 00  1 105      
;   763     elsif openmode='w' then     -- write
    cmp rdi,119                           ;#0043D599: 48:203377 77               uv 00 80  1 106      
    jne #0043D5D5                         ;#0043D59D: 165 36                     v  00 00  1 106      
;   764         accessmode = GENERIC_WRITEo4
    mov qword[accessmode],268435456       ;#0043D59F: 48:307105 D8 00000010      uv 00 20  1 107      
;   765 --DEV test:
;   766 --      sharemode = FILE_SHARE_WRITE
;   767         if fmode=F_BINARY then
    mov rsi,[rbp-32] (fmode)              ;#0043D5A7: 48:213165 E0               vu 40 20  1 107      
    cmp rsi,4                             ;#0043D5AB: 48:203376 04               uv 00 40  1 108      
    jne #0043D5BB                         ;#0043D5AF: 165 0A                     v  00 00  1 108      
;   768             sharemode = FILE_SHARE_READ+FILE_SHARE_WRITE
    mov qword[rbp-56] (sharemode),3       ;#0043D5B1: 48:307105 C8 03000000      uv 00 20  1 109      
    jmp #0043D5C3                         ;#0043D5B9: 353 08                     v  00 00  1 109      
;   769         else
;   770             sharemode = FILE_SHARE_WRITE
    mov qword[rbp-56] (sharemode),2       ;#0043D5BB: 48:307105 C8 02000000      uv 00 20  1 110      
;   771         end if
;   772         createmode = TRUNCATE_EXISTING
    mov qword[rbp-48] (createmode),5      ;#0043D5C3: 48:307105 D0 05000000      vu 00 20  1 110      
;   773         imode = F_WRITE
    mov qword[rbp-24] (imode),2           ;#0043D5CB: 48:307105 E8 02000000      uv 00 20  1 111      
    jmp #0043D64C                         ;#0043D5D3: 353 77                     v  00 00  1 111      
;   774     elsif openmode='u' then     -- update
    cmp rdi,117                           ;#0043D5D5: 48:203377 75               uv 00 80  1 112      
    jne #0043D5FD                         ;#0043D5D9: 165 22                     v  00 00  1 112      
;   775         accessmode = GENERIC_READo4+GENERIC_WRITEo4
    mov qword[accessmode],805306368       ;#0043D5DB: 48:307105 D8 00000030      uv 00 20  1 113      
;   776         sharemode = FILE_SHARE_READ+FILE_SHARE_WRITE
    mov qword[rbp-56] (sharemode),3       ;#0043D5E3: 48:307105 C8 03000000      vu 00 20  1 113      
;   777         createmode = OPEN_EXISTING
    mov qword[rbp-48] (createmode),3      ;#0043D5EB: 48:307105 D0 03000000      uv 00 20  1 114      
;   778         imode = F_READ+F_WRITE
    mov qword[rbp-24] (imode),3           ;#0043D5F3: 48:307105 E8 03000000      vu 00 20  1 114      
    jmp #0043D64C                         ;#0043D5FB: 353 4F                     v  00 00  1 115      
;   779     elsif openmode='a' then     -- append
    cmp rdi,97                            ;#0043D5FD: 48:203377 61               uv 00 80  1 116      
    jne #0043D639                         ;#0043D601: 165 36                     v  00 00  1 116      
;   780         accessmode = GENERIC_WRITEo4
    mov qword[accessmode],268435456       ;#0043D603: 48:307105 D8 00000010      uv 00 20  1 117      
;   781 --DEV test:
;   782 --      sharemode = FILE_SHARE_WRITE
;   783         if fmode=F_BINARY then
    mov rcx,[rbp-32] (fmode)              ;#0043D60B: 48:213115 E0               vu 02 20  1 117      
    cmp rcx,4                             ;#0043D60F: 48:203371 04               uv 00 02  1 118      
    jne #0043D61F                         ;#0043D613: 165 0A                     v  00 00  1 118      
;   784             sharemode = FILE_SHARE_READ+FILE_SHARE_WRITE
    mov qword[rbp-56] (sharemode),3       ;#0043D615: 48:307105 C8 03000000      uv 00 20  1 119      
    jmp #0043D627                         ;#0043D61D: 353 08                     v  00 00  1 119      
;   785         else
;   786             sharemode = FILE_SHARE_WRITE
    mov qword[rbp-56] (sharemode),2       ;#0043D61F: 48:307105 C8 02000000      uv 00 20  1 120      
;   787         end if
;   788         createmode = OPEN_ALWAYS
    mov qword[rbp-48] (createmode),4      ;#0043D627: 48:307105 D0 04000000      vu 00 20  1 120      
;   789         imode = F_WRITE
    mov qword[rbp-24] (imode),2           ;#0043D62F: 48:307105 E8 02000000      uv 00 20  1 121      
    jmp #0043D64C                         ;#0043D637: 353 13                     v  00 00  1 121      
;   790     else
;   791 --      iofatal(61) -- "invalid open mode"
;   792         #ilASM{
;   793             [32]
;   794                 mov edx,[ebp+12]                    -- "called from" address
;   795                 mov ebp,[ebp+20]                    -- prev_ebp
;   796                 mov al,61                           -- e61iom: "invalid open mode"
;   797                 sub edx,1
;   798             [64]
;   799                 mov rdx,[rbp+24]                    -- "called from" address
                        mov rdx,[rbp+24]  ;#0043D639: 48:213125 18               uv 04 20  1 122      
;   800                 mov rbp,[rbp+40]                    -- prev_ebp
                        mov rbp,[rbp+40] (prevebp)  ;#0043D63D: 48:213155 28               vu 20 20  1 122      
;   801                 mov al,61                           -- e61iom: "invalid open mode"
                        mov al,61         ;#0043D641: 260 3D                     uv 01 00  1 123      
;   802                 sub rdx,1
                        sub rdx,1         ;#0043D643: 48:203352 01               vu 04 04  1 123      
;   803             []
;   804                 jmp :!iDiag
                        jmp #00442E66 (:!iDiag)  ;#0043D647: 351 1A580000               v  00 00  1 124      
;   805               }
;   806     end if
;   807 
;   808     --
;   809     -- If opening for write and the file does not exist, TRUNCATE_EXISTING will
;   810     -- fail, so in that one case retry with CREATE_NEW.
;   811     --
;   812     while 1 do  -- (max 2 iterations)
;   813 -->
;   814 --      fhandle = c_func(xCreateFile,{filepath,accessmode,sharemode,0,createmode,FILE_ATTRIBUTE_NORMAL,0})
;   815 --DEV newsize
;   816 --  make accessmode an integer, stored /4 to avoid int/float conversions
;   817 --  make sharemode and createmode integers too
;   818 --!/*
;   819         #ilASM{
;   820             [PE32]
;   821                 mov eax,[accessmode]            -- (/4)
;   822                 mov esi,[filepath]
;   823                 shl eax,2
;   824                 shl esi,2
;   825                 push ebx                        -- hTemplateFile (NULL)
;   826                 push FILE_ATTRIBUTE_NORMAL      -- dwFlagsAndAttributes
;   827                 push [createmode]               -- dwCreationDisposition
;   828                 push ebx                        -- lpSecurityAttributes (NULL)
;   829                 push [sharemode]                -- dwShareMode
;   830                 push eax                        -- dwDesiredAccess
;   831                 push esi                        -- lpFileName
;   832                 call "kernel32.dll","CreateFileA"
;   833 --              mov [fhandle],eax
;   834                 lea edi,[fhandle]
;   835                 call :%pStoreMint               -- [edi]:=eax as 31-bit int or float if needed
;   836             [PE64]
;   837                 mov rdx,[accessmode]            -- (/4)
                        mov rdx,[rbp-40] (accessmode)  ;#0043D64C: 48:213125 D8               uv 04 20  1 125      
;   838                 mov rcx,[filepath]
                        mov rcx,[rbp] (filepath)  ;#0043D650: 48:213115 00               vu 02 20  1 125      
;   839                 shl rdx,2
                        shl rdx,2         ;#0043D654: 48:301342 02               u  04 04  1 126      
;   840                 shl rcx,2
                        shl rcx,2         ;#0043D658: 48:301341 02               u  02 02  1 127      
;   841                 mov r8,[sharemode]
                        mov r8,[rbp-56] (sharemode)  ;#0043D65C: 4C:213105 C8               vu 100 20  1 127      
;   842                 mov r9,rbx
                        mov r9,rbx        ;#0043D660: 4C:213313                  uv 200 08  1 128      
;   843                 mov rax,[createmode]
                        mov rax,[rbp-48] (createmode)  ;#0043D663: 48:213105 D0               vu 01 20  1 128      
;   844                 sub rsp,8*7                         -- minimum 4 param shadow space, and align(none here)
                        sub rsp,56        ;#0043D667: 48:203354 38               uv 10 10  1 129      
;   845                 mov r10,FILE_ATTRIBUTE_NORMAL
                        mov r10,128       ;#0043D66B: 49:307302 80000000         vu 400 00  1 129      
;   846                 mov [rsp+48],rbx                    -- hTemplateFile (NULL)
                        mov [rsp+48],rbx  ;#0043D672: 48:211134044 30            uv 00 18  1 132    *10*
;   847                 mov [rsp+40],r10                    -- dwFlagsAndAttributes
                        mov [rsp+40],r10  ;#0043D677: 4C:211124044 28            vu 00 410  1 132      
;   848                 mov [rsp+32],rax                    -- dwCreationDisposition
                        mov [rsp+32],rax  ;#0043D67C: 48:211104044 20            uv 00 11  1 133      
;   849 --              (r9)                                -- lpSecurityAttributes (NULL)
;   850 --              (r8)                                -- dwShareMode
;   851 --              (rdx)                               -- dwDesiredAccess
;   852 --              (rcx)                               -- lpFileName
;   853                 call "kernel32.dll","CreateFileA"
                        call [#00401038] (CreateFileA)  ;#0043D681: 377025 B139FCFF            np 00 00  2 134      
;   854                 add rsp,8*7
                        add rsp,56        ;#0043D687: 48:203304 38               uv 10 10  1 136      
;   855 --              mov [fhandle],eax
;   856                 lea edi,[fhandle]
                        lea edi,[rbp-64] (fhandle)  ;#0043D68B: 215175 C0                  vu 80 20  1 136      
;   857                 call :%pStoreMint               -- [edi]:=eax as 31-bit int or float if needed
                        call #0044228A (:%pStoreMint)  ;#0043D68E: 350 F74B0000               v  00 00  1 137      
;   858             [ELF32]
;   859                 pop al
;   860             [ELF64]
;   861                 pop al
;   862             []
;   863               }
;   864 --!*/
;   865         if fhandle!=INVALID_HANDLE_VALUE then exit end if                   -- success!
    mov rdi,-1                            ;#0043D693: 48:307307 FFFFFFFF         uv 80 00  1 138      
    mov rax,[rbp-64] (fhandle)            ;#0043D69A: 48:213105 C0               vu 01 20  1 138      
    mov rsi,906                           ;#0043D69E: 48:307306 8A030000         uv 40 00  1 139      
    mov rdx,991                           ;#0043D6A5: 48:307302 DF030000         vu 04 00  1 139      
    call #0043FAF6 (:%opJccE)             ;#0043D6AC: 350 45240000               v  00 00  1 140      
    jne #0043D6EC                         ;#0043D6B1: 165 39                     v  00 00  1 141      
;   866 
;   867         -- loop once if 'w'/TRUNCATE_EXISTING, retry as CREATE_NEW:
;   868         if createmode!=TRUNCATE_EXISTING then return -1 end if              -- failure!
    mov rdi,5                             ;#0043D6B3: 48:307307 05000000         uv 80 00  1 142      
    mov rax,[rbp-48] (createmode)         ;#0043D6BA: 48:213105 D0               vu 01 20  1 142      
    mov rsi,933                           ;#0043D6BE: 48:307306 A5030000         uv 40 00  1 143      
    mov rdx,989                           ;#0043D6C5: 48:307302 DD030000         vu 04 00  1 143      
    call #0043FAF6 (:%opJccE)             ;#0043D6CC: 350 25240000               v  00 00  1 144      
    je #0043D6DF                          ;#0043D6D1: 164 0C                     v  00 00  1 145      
    mov rax,-1                            ;#0043D6D3: 48:307300 FFFFFFFF         uv 01 00  1 146      
    jmp #0044298D (:%opRetf)              ;#0043D6DA: 351 AE520000               v  00 00  1 146      
;   869         createmode = CREATE_NEW
    mov qword[rbp-48] (createmode),1      ;#0043D6DF: 48:307105 D0 01000000      uv 00 20  1 147      
;   870     end while
    jmp #0043D64C                         ;#0043D6E7: 351 60FFFFFF               v  00 00  1 147      
;   871 
;   872     enter_cs(fdcs)
    mov rsi,[#004030C8] (fdcs)            ;#0043D6EC: 48:213065 D559FCFF         uv 40 00  1 148      
    mov r15,h4                            ;#0043D6F3: 49:277 0000000000000040    vu 8000 00  1 148      
    cmp rsi,r15                           ;#0043D6FD: 4C:071376                  uv 00 8040  1 149      
    jne #0043D70E                         ;#0043D700: 165 0C                     v  00 00  1 149      
    mov rsi,944                           ;#0043D702: 48:307306 B0030000         uv 40 00  1 150      
    call #00442D75 (:%pUnassigned)        ;#0043D709: 350 67560000               v  00 00  1 150      
    mov rcx,rsi                           ;#0043D70E: 48:211361                  uv 02 40  1 151      
    call #0044258C (:%pEnterCS)           ;#0043D711: 350 764E0000               v  00 00  1 151      
;   873     if freelist=0 then
    mov rdi,[#004030E0] (freelist)        ;#0043D716: 48:213075 C359FCFF         uv 80 00  1 152      
    cmp rdi,0                             ;#0043D71D: 48:203377 00               uv 00 80  1 153 80   
    jne #0043D7DE                         ;#0043D721: 017205 B7000000            v  00 00  1 153      
;   874         if machine_bits()=32 then
;   875             iThis = floor(allocate(FDSIZE32)/4)
;   876         else
;   877             iThis = floor(allocate(FDSIZE64)/4)
    mov rcx,8192                          ;#0043D727: 48:307301 00200000         uv 02 00  1 154      
    lea rdi,[rbp-104] (symtab[1001])      ;#0043D72E: 48:215175 98               vu 80 20  1 154      
    call #00442460 (:%pAlloc)             ;#0043D732: 350 294D0000               v  00 00  1 155      
    lea rdi,[rbp-72] (iThis)              ;#0043D737: 48:215175 B8               uv 80 20  1 156      
    mov rcx,[rbp-104] (symtab[1001])      ;#0043D73B: 48:213115 98               vu 02 20  1 156      
    mov rax,[#004020A8] (D_YEAR)          ;#0043D73F: 48:213005 6249FCFF         uv 01 00  1 157      
    call #0043F5E4 (:%opDivf)             ;#0043D746: 350 991E0000               v  00 00  1 157      
    mov rsi,[rbp-72] (iThis)              ;#0043D74B: 48:213165 B8               uv 40 20  1 158      
    mov r15,h4                            ;#0043D74F: 49:277 0000000000000040    vu 8000 00  1 158      
    cmp rsi,r15                           ;#0043D759: 4C:071376                  uv 00 8040  1 159      
    jl #0043D76A                          ;#0043D75C: 174 0C                     v  00 00  1 159      
    mov rcx,992                           ;#0043D75E: 48:307301 E0030000         uv 02 00  1 160      
    call #00442A58 (:%opTchkFail)         ;#0043D765: 350 EE520000               v  00 00  1 160      
;   878         end if
;   879         fdtbl = append(fdtbl,iThis)
    mov rdi,[#004030D0] (fdtbl)           ;#0043D76A: 48:213075 5F59FCFF         uv 80 00  1 161      
    mov r15,h4                            ;#0043D771: 49:277 0000000000000040    vu 8000 00  1 161      
    cmp rdi,r15                           ;#0043D77B: 4C:071377                  uv 00 8080  1 162      
    jne #0043D78C                         ;#0043D77E: 165 0C                     v  00 00  1 162      
    mov rsi,945                           ;#0043D780: 48:307306 B1030000         uv 40 00  1 163      
    call #00442D75 (:%pUnassigned)        ;#0043D787: 350 E9550000               v  00 00  1 163      
    mov r15,h4                            ;#0043D78C: 49:277 0000000000000040    uv 8000 00  1 164      
    cmp rsi,r15                           ;#0043D796: 4C:071376                  uv 00 8040  1 165 8000   
    jne #0043D7A7                         ;#0043D799: 165 0C                     v  00 00  1 165      
    mov rsi,992                           ;#0043D79B: 48:307306 E0030000         uv 40 00  1 166      
    call #00442D75 (:%pUnassigned)        ;#0043D7A2: 350 CE550000               v  00 00  1 166      
    lea rdx,[#004030D0] (fdtbl)           ;#0043D7A7: 48:215025 2259FCFF         uv 04 00  1 167      
    lea rdi,[#004030D0] (fdtbl)           ;#0043D7AE: 48:215075 1B59FCFF         vu 80 00  1 167      
    lea rcx,[rbp-72] (iThis)              ;#0043D7B5: 48:215115 B8               uv 02 20  1 168      
    xor rax,rax                           ;#0043D7B9: 48:061300                  vu 01 01  1 168      
    call #0043FC15 (:%opApnd)             ;#0043D7BC: 350 54240000               v  00 00  1 169      
;   880         fdmax = length(fdtbl)
    mov rcx,[#004030D0] (fdtbl)           ;#0043D7C1: 48:213015 0859FCFF         uv 02 00  1 170      
    mov rax,[rbx+rcx*4-24]                ;#0043D7C8: 48:48:213104213 E8         uv 01 0A  1 173 02 *02*
    mov [#004030D8] (fdmax),rax           ;#0043D7CE: 48:211005 0359FCFF         uv 00 01  1 174 01   
;   881         res = fdmax
    mov [rbp-16] (res),rax                ;#0043D7D5: 48:211105 F0               vu 00 21  1 174      
;   882 --      filenames = append(filenames,filepath)
    jmp #0043D8B1                         ;#0043D7D9: 351 D3000000               v  00 00  1 175      
;   883     else
;   884         res = freelist
    mov [rbp-16] (res),rdi                ;#0043D7DE: 48:211175 F0               uv 00 A0  1 176      
;   885         iThis = fdtbl[freelist]
    mov rsi,[#004030D0] (fdtbl)           ;#0043D7E2: 48:213065 E758FCFF         vu 40 00  1 176      
    mov r15,h4                            ;#0043D7E9: 49:277 0000000000000040    uv 8000 00  1 177      
    cmp rsi,r15                           ;#0043D7F3: 4C:071376                  uv 00 8040  1 178 8000   
    jne #0043D804                         ;#0043D7F6: 165 0C                     v  00 00  1 178      
    mov rsi,945                           ;#0043D7F8: 48:307306 B1030000         uv 40 00  1 179      
    call #00442D75 (:%pUnassigned)        ;#0043D7FF: 350 71550000               v  00 00  1 179      
    mov rdx,945                           ;#0043D804: 48:307302 B1030000         uv 04 00  1 180      
    call #00441744 (:%pSubse1ip)          ;#0043D80B: 350 343F0000               v  00 00  1 180      
    mov [rbp-72] (iThis),rax              ;#0043D810: 48:211105 B8               uv 00 21  1 181      
;   886         freelist = peek4u(iThis*4)
    lea rdi,[rbp-104] (symtab[1001])      ;#0043D814: 48:215175 98               vu 80 20  1 181      
    mov rcx,rax                           ;#0043D818: 48:211301                  uv 02 01  1 182      
    mov rax,[#004020A8] (D_YEAR)          ;#0043D81B: 48:213005 8648FCFF         vu 01 00  1 182      
    call #0043F67C (:%opMul)              ;#0043D822: 350 551E0000               v  00 00  1 183      
    lea rdi,[#004030E0] (freelist)        ;#0043D827: 48:215075 B258FCFF         uv 80 00  1 184      
    mov rsi,[rbp-104] (symtab[1001])      ;#0043D82E: 48:213165 98               vu 40 20  1 184      
    xor rcx,rcx                           ;#0043D832: 48:061311                  uv 02 02  1 185      
    mov rdx,4                             ;#0043D835: 48:307302 04000000         vu 04 00  1 185      
    call #0043ED6C (:%opPeekNx)           ;#0043D83C: 350 2B150000               v  00 00  1 186      
    mov rcx,[#004030E0] (freelist)        ;#0043D841: 48:213015 9858FCFF         uv 02 00  1 187      
    mov r15,h4                            ;#0043D848: 49:277 0000000000000040    vu 8000 00  1 187      
    cmp rcx,r15                           ;#0043D852: 4C:071371                  uv 00 8002  1 188      
    jl #0043D863                          ;#0043D855: 174 0C                     v  00 00  1 188      
    mov rcx,947                           ;#0043D857: 48:307301 B3030000         uv 02 00  1 189      
    call #00442A58 (:%opTchkFail)         ;#0043D85E: 350 F5510000               v  00 00  1 189      
;   887         if peek4u(iThis*4+MODE)!=0 then ?9/0 end if
    lea rdi,[rbp-104] (symtab[1001])      ;#0043D863: 48:215175 98               uv 80 20  1 190      
    mov rcx,[rbp-72] (iThis)              ;#0043D867: 48:213115 B8               vu 02 20  1 190      
    mov rax,[#004020A8] (D_YEAR)          ;#0043D86B: 48:213005 3648FCFF         uv 01 00  1 191      
    call #0043F67C (:%opMul)              ;#0043D872: 350 051E0000               v  00 00  1 191      
    lea rdi,[rbp-112] (symtab[1002])      ;#0043D877: 48:215175 90               uv 80 20  1 192      
    mov rcx,[rbp-104] (symtab[1001])      ;#0043D87B: 48:213115 98               vu 02 20  1 192      
    mov rax,[#004030F0] (MODE)            ;#0043D87F: 48:213005 6A58FCFF         uv 01 00  1 193      
    call #0043F4AF (:%opAdd)              ;#0043D886: 350 241C0000               v  00 00  1 193      
    lea rdi,[rbp-88] (symtab[994])        ;#0043D88B: 48:215175 A8               uv 80 20  1 194      
    mov rsi,[rbp-112] (symtab[1002])      ;#0043D88F: 48:213165 90               vu 40 20  1 194      
    xor rcx,rcx                           ;#0043D893: 48:061311                  uv 02 02  1 195      
    mov rdx,4                             ;#0043D896: 48:307302 04000000         vu 04 00  1 195      
    call #0043ED6C (:%opPeekNx)           ;#0043D89D: 350 CA140000               v  00 00  1 196      
    mov rdi,[rbp-88] (symtab[994])        ;#0043D8A2: 48:213175 A8               uv 80 20  1 197      
    cmp rdi,0                             ;#0043D8A6: 48:203377 00               uv 00 80  1 198 80   
    je #0043D8B1                          ;#0043D8AA: 164 05                     v  00 00  1 198      
    call #00442DD2 (:%pDiv0)              ;#0043D8AC: 350 21550000               v  00 00  1 199      
;   888 --      if length(filenames[res]) then ?9/0 end if
;   889 --      filenames[res] = filepath
;   890     end if
;   891     leave_cs(fdcs)
    mov rcx,[#004030C8] (fdcs)            ;#0043D8B1: 48:213015 1058FCFF         uv 02 00  1 200      
    mov r15,h4                            ;#0043D8B8: 49:277 0000000000000040    vu 8000 00  1 200      
    cmp rcx,r15                           ;#0043D8C2: 4C:071371                  uv 00 8002  1 201      
    jne #0043D8D3                         ;#0043D8C5: 165 0C                     v  00 00  1 201      
    mov rsi,944                           ;#0043D8C7: 48:307306 B0030000         uv 40 00  1 202      
    call #00442D75 (:%pUnassigned)        ;#0043D8CE: 350 A2540000               v  00 00  1 202      
    call #004425E9 (:%pLeaveCS)           ;#0043D8D3: 350 114D0000               v  00 00  1 203      
;   892 
;   893     fmode += imode
    mov rax,[rbp-24] (imode)              ;#0043D8D8: 48:213105 E8               uv 01 20  1 204      
    mov r15,h4                            ;#0043D8DC: 49:277 0000000000000040    vu 8000 00  1 204      
    cmp rax,r15                           ;#0043D8E6: 4C:071370                  uv 00 8001  1 205      
    jne #0043D8F7                         ;#0043D8E9: 165 0C                     v  00 00  1 205      
    mov rsi,986                           ;#0043D8EB: 48:307306 DA030000         uv 40 00  1 206      
    call #00442D75 (:%pUnassigned)        ;#0043D8F2: 350 7E540000               v  00 00  1 206      
    lea rdi,[rbp-32] (fmode)              ;#0043D8F7: 48:215175 E0               uv 80 20  1 207      
    mov rcx,[rbp-32] (fmode)              ;#0043D8FB: 48:213115 E0               vu 02 20  1 207      
    call #0043F4BE (:%opAddi)             ;#0043D8FF: 350 BA1B0000               v  00 00  1 208      
;   894 --DEV/SUG: (is it easier to load from [iThis*4+HDNL] than cmp [fhandle],h4 etc?)
;   895 --  poke4(iThis*4+HNDL,handle)
;   896 
;   897 --DEV newsize [PE32]
;   898     #ilASM{
;   899         [32]
;   900             mov eax,[fhandle]
;   901             mov ecx,ebx                         -- rposn loword (set to 0)
;   902             mov edx,ebx                         -- rposn hiword (set to 0)
;   903             cmp eax,h4  --DEV :%pLoadMint
;   904             jl @f
;   905                 sub esp,8
;   906                 fld qword[ebx+eax*4]
;   907                 fistp qword[esp]
;   908                 pop eax
;   909                 add esp,4
;   910           @@:
;   911             mov edi,[openmode]
;   912             cmp edi,'a'
;   913             jne :nota
;   914                 push eax        -- save
;   915         [PE32]
;   916                 push ebx        --[1] DistanceToMoveHigh (0), and rposn hiword (edx)
;   917                 mov edi,esp
;   918                 push FILE_END                   -- dwMoveMethod
;   919                 push edi                        -- lpDistanceToMoveHigh
;   920                 push ebx                        -- lDistanceToMove (0)
;   921                 push eax                        -- hFile
;   922                 call "kernel32.dll","SetFilePointer"
;   923                 mov ecx,eax     -- rposn loword
;   924                 pop edx         --[1] rposn hiword
;   925                 cmp eax,-1      -- INVALID_SET_FILE_POINTER (may be a valid loword)
;   926                 jne @f
;   927                     call "kernel32.dll","GetLastError"
;   928                     cmp eax,NO_ERROR
;   929                     je @f
;   930 -- warning, untested code: [done, opOpen03 (p7 only)]
;   931 --                      mov al,64               -- e64sfooa: "seek fail on open append"
;   932 --                      xor edi,edi -- ep1 unused
;   933 --                      xor esi,esi -- ep2 unused
;   934 --                      call :%pRTErn
;   935 --better?
;   936                         mov al,64               -- e64sfooa: "seek fail on open append"
;   937                         mov edx,[ebp+12]        -- "called from" address
;   938                         mov ebp,[ebp+20]        -- prev_ebp
;   939                         sub edx,1
;   940                         jmp :!iDiag
;   941                         int3
;   942               @@:
;   943         [ELF32]
;   944                 pop al
;   945         [32]
;   946                 pop eax     -- restore
;   947           ::nota
;   948             mov esi,[iThis]
;   949             shl esi,2
;   950             mov edi,[fmode]
;   951             mov [esi+HNDL],eax
;   952             mov [esi+MODE],edi
;   953             mov [esi+POSN],dword 1
;   954             mov [esi+FEND],ebx --(0)
;   955             mov [esi+POSL],ecx
;   956             mov [esi+POSH],edx
;   957         [64]
;   958             mov rax,[fhandle]
                    mov rax,[rbp-64] (fhandle)  ;#0043D904: 48:213105 C0               uv 01 20  1 209      
;   959             mov rcx,rbx                         -- rposn loword (set to 0)
                    mov rcx,rbx           ;#0043D908: 48:213313                  vu 02 08  1 209      
;   960             mov rdx,rbx                         -- rposn hiword (set to 0)
                    mov rdx,rbx           ;#0043D90B: 48:213323                  uv 04 08  1 210      
;   961             mov r15,h4
                    mov r15,h4            ;#0043D90E: 49:277 0000000000000040    vu 8000 00  1 210      
;   962             cmp rax,r15
                    cmp rax,r15           ;#0043D918: 49:073307                  uv 00 8001  1 211      
;   963             jl @f
                    jl #0043D929          ;#0043D91B: 174 0C                     v  00 00  1 211      
;   964                 sub rsp,8
                        sub rsp,8         ;#0043D91D: 48:203354 08               uv 10 10  1 212      
;   965                 fld tbyte[rbx+rax*4]
                        fld tbyte[rbx+rax*4]  ;#0043D921: 333054203                  np 00 09  3 213      
;   966                 fistp qword[rsp]
                        fistp qword[rsp]  ;#0043D924: 337074044                  np 00 10  6 216      
;   967                 pop rax
                        pop rax           ;#0043D927: 48:130                     uv 01 00  1 222      
;   968           @@:
;   969             mov rdi,[openmode]
                    mov rdi,[rbp-8] (openmode)  ;#0043D929: 48:213175 F8               vu 80 20  1 222      
;   970             cmp rdi,'a'
                    cmp edi,97            ;#0043D92D: 203377 61                  uv 00 80  1 223      
;   971             jne :nota
                    jne #0043D97B         ;#0043D930: 165 49                     v  00 00  1 223      
;   972 --              push rax        -- save
;   973         [PE64]
;   974             sub rsp,8*7                         -- minimum 4 param shadow space, newFilePointer, save rax, and align
                    sub rsp,56            ;#0043D932: 48:203354 38               uv 10 10  1 224      
;   975             mov [rsp+40],rax                    -- save
                    mov [rsp+40],rax      ;#0043D936: 48:211104044 28            uv 00 11  1 227 10 *10*
;   976             mov r9,FILE_END                     -- dwMoveMethod
                    mov r9,2              ;#0043D93B: 49:307301 02000000         vu 200 00  1 227      
;   977             lea r8,[rsp+32]                     -- lpNewFilePointer
                    lea r8,[rsp+32]       ;#0043D942: 4C:215104044 20            uv 100 10  1 228      
;   978             mov rdx,rbx                         -- liDistanceToMove (0)
                    mov rdx,rbx           ;#0043D947: 48:213323                  vu 04 08  1 228      
;   979             mov rcx,rax                         -- hFile
                    mov rcx,rax           ;#0043D94A: 48:213310                  uv 02 01  1 229      
;   980             call "kernel32.dll","SetFilePointerEx"
                    call [#00401128] (SetFilePointerEx)  ;#0043D94D: 377025 D537FCFF            np 00 00  2 230      
;   981             cmp rax,0
                    cmp rax,0             ;#0043D953: 48:203370 00               uv 00 01  1 232      
;   982             jne @f
                    jne #0043D96D         ;#0043D957: 165 14                     v  00 00  1 232      
;   983                 mov al,64                       -- e64sfooa: "seek fail on open append"
                        mov al,64         ;#0043D959: 260 40                     uv 01 00  1 233      
;   984                 mov rdx,[rbp+24]                -- "called from" address
                        mov rdx,[rbp+24]  ;#0043D95B: 48:213125 18               vu 04 20  1 233      
;   985                 mov rbp,[rbp+40]                -- prev_ebp
                        mov rbp,[rbp+40] (prevebp)  ;#0043D95F: 48:213155 28               uv 20 20  1 234      
;   986                 sub rdx,1
                        sub rdx,1         ;#0043D963: 48:203352 01               vu 04 04  1 234      
;   987                 jmp :!iDiag
                        jmp #00442E66 (:!iDiag)  ;#0043D967: 351 FA540000               v  00 00  1 235      
;   988                 int3
                        int3              ;#0043D96C: 314                        np 00 00 13 236      
;   989           @@:
;   990             mov rcx,[rsp+32]
                    mov rcx,[rsp+32]      ;#0043D96D: 48:213114044 20            uv 02 10  1 249      
;   991             mov rax,[rsp+40]
                    mov rax,[rsp+40]      ;#0043D972: 48:213104044 28            vu 01 10  1 249      
;   992             add rsp,8*7
                    add rsp,56            ;#0043D977: 48:203304 38               uv 10 10  1 250      
;   993         [ELF64]
;   994             pop al
;   995         [64]
;   996 --              pop eax     -- restore
;   997           ::nota
;   998             mov rsi,[iThis]
                    mov rsi,[rbp-72] (iThis)  ;#0043D97B: 48:213165 B8               vu 40 20  1 250      
;   999             shl rsi,2
                    shl rsi,2             ;#0043D97F: 48:301346 02               u  40 40  1 251      
;  1000             mov rdi,[fmode]
                    mov rdi,[rbp-32] (fmode)  ;#0043D983: 48:213175 E0               vu 80 20  1 251      
;  1001 --          mov [rsi+HNDL64],eax
;  1002             mov [rsi+HNDL64],rax
                    mov [rsi],rax         ;#0043D987: 48:211006                  uv 00 41  1 254    *40*
;  1003             mov [rsi+MODE64],rdi
                    mov [rsi+8],rdi       ;#0043D98A: 48:211176 08               vu 00 C0  1 254      
;  1004             mov [rsi+POSN64],qword 1
                    mov qword[rsi+16],1   ;#0043D98E: 48:307106 10 01000000      uv 00 40  1 255      
;  1005 --          mov [rsi+FEND64],ebx --(0)
;  1006             mov [rsi+FEND64],rbx --(0)
                    mov [rsi+24],rbx      ;#0043D996: 48:211136 18               vu 00 48  1 255      
;  1007             mov [rsi+RPOS64],rcx
                    mov [rsi+32],rcx      ;#0043D99A: 48:211116 20               uv 00 42  1 256      
;  1008         []
;  1009           }
;  1010     res += 2
    mov rsi,[rbp-16] (res)                ;#0043D99E: 48:213165 F0               vu 40 20  1 256      
    mov r15,h4                            ;#0043D9A2: 49:277 0000000000000040    uv 8000 00  1 257      
    cmp rsi,r15                           ;#0043D9AC: 4C:071376                  uv 00 8040  1 258 8000   
    jne #0043D9BD                         ;#0043D9AF: 165 0C                     v  00 00  1 258      
    mov rsi,985                           ;#0043D9B1: 48:307306 D9030000         uv 40 00  1 259      
    call #00442D75 (:%pUnassigned)        ;#0043D9B8: 350 B8530000               v  00 00  1 259      
    lea rdi,[rbp-16] (res)                ;#0043D9BD: 48:215175 F0               uv 80 20  1 260      
    mov rcx,rsi                           ;#0043D9C1: 48:211361                  vu 02 40  1 260      
    mov rax,[#00402098] (WIN32)           ;#0043D9C4: 48:213005 CD46FCFF         uv 01 00  1 261      
    call #0043F4BE (:%opAddi)             ;#0043D9CB: 350 EE1A0000               v  00 00  1 261      
;  1011     return res
    mov rax,[rbp-16] (res)                ;#0043D9D0: 48:213105 F0               uv 01 20  1 262      
    jmp #0044298D (:%opRetf)              ;#0043D9D4: 351 B44F0000               v  00 00  1 262      
;  1012 end function
;  1013 
;  1014 integer stdin=0,
;  1015         stdout=0,
;  1016         stderr
;  1017 
;  1018 integer cinit = 0
;  1019 integer stdin_redirected = 0
;  1020 
;  1021 procedure initConsole()
;  1022     if not finit then initF() end if
    mov rdi,[#00403178] (finit)           ;#0043B59C: 48:213075 D57BFCFF         uv 80 00  1   1      
    test rdi,rdi                          ;#0043B5A3: 48:205377                  uv 00 80  1   2 80   
    jne #0043B5C4                         ;#0043B5A6: 165 1C                     v  00 00  1   2      
    xor rcx,rcx                           ;#0043B5A8: 48:061311                  uv 02 02  1   3      
    mov rdx,967                           ;#0043B5AB: 48:307302 C7030000         vu 04 00  1   3      
    call #004428DB (:%opFrame) (initF)    ;#0043B5B2: 350 24730000               v  00 00  1   4      
    mov qword[retaddr],#0043B5C4          ;#0043B5B7: 48:307105 20 C4B54300      uv 00 20  1   5      
    jmp #0043B5D9 (code:initF)            ;#0043B5BF: 351 15000000               v  00 00  1   5      
;  1023 --DEV call :%n_initC??
;  1024 -->
;  1025 --  {} = c_func(xAllocConsole,{})
;  1026 --  stdin = c_func(xGetStdHandle,{STD_INPUT_HANDLE})
;  1027 --  stdout = c_func(xGetStdHandle,{STD_OUTPUT_HANDLE})
;  1028 --  stderr = c_func(xGetStdHandle,{STD_ERROR_HANDLE})
;  1029 --  -- nb following is not ENABLE_LINE_INPUT and not ENABLE_ECHO_INPUT
;  1030 --  if not c_func(xSetConsoleMode,{stdin,ENABLE_PROCESSED_INPUT}) then
;  1031 --      stdin_redirected = 1
;  1032 --  end if
;  1033     #ilASM { call :%n_initC }
    call #0043DCFD (:%n_initC)            ;#0043B5C4: 350 34270000               v  00 00  1   6      
;  1034 --DEV newsize - make these local/use the stack
;  1035 --  pSMALLRECT = allocate(sizeof_SMALL_RECT)
;  1036 --  pCHARINFO = allocate(sizeof_CHAR_INFO)
;  1037 --DEV?
;  1038 --  -- set initial foreground and background colours
;  1039 --  getConsoleScreenBufferInfo()
;  1040 --  fg_colour = peek2u(xCSBI+CSBI_ATTR)
;  1041 --  bg_colour = and_bits(fg_colour,#F0)/#10
;  1042 --  fg_colour = and_bits(fg_colour,#F)
;  1043     cinit = 1
    mov qword[#004031C0] (cinit),1        ;#0043B5C9: 48:307005 EC7BFCFF 01000000 uv 00 00  1   7      
    jmp #0044298D (:%opRetf)              ;#0043B5D4: 351 B4730000               v  00 00  1   7      
;  1044 end procedure
;  1045 
;  1046 --DEV use elsewhere (I have tagged several places with get_this()?)
;  1047 function get_this(integer fn)
;  1048 integer iThis = 0
    mov [rbp-8] (iThis),rbx               ;#0043C667: 48:211135 F8               uv 00 28  1   1      
;  1049 integer fidx = fn-2
    mov rdi,[rbp] (fn)                    ;#0043C66B: 48:213175 00               vu 80 20  1   1      
    sub rdi,2                             ;#0043C66F: 48:203357 02               uv 80 80  1   2      
    mov rdx,rdi                           ;#0043C673: 48:213327                  uv 04 80  1   3 80   
    mov [rbp-16] (fidx),rdi               ;#0043C676: 48:211175 F0               vu 00 A0  1   3      
    shl rdx,1                             ;#0043C67A: 48:321342                  u  04 04  1   4      
    jno #0043C688                         ;#0043C67D: 161 09                     v  00 00  1   4      
    lea rdi,[rbp-16] (fidx)               ;#0043C67F: 48:215175 F0               uv 80 20  1   5      
    call #00442DA9 (:%pAddiii)            ;#0043C683: 350 21670000               v  00 00  1   5      
;  1050 integer fmode = 0
    mov [rbp-24] (fmode),rbx              ;#0043C688: 48:211135 E8               uv 00 28  1   6      
;  1051     if fidx>=1 and fidx<=fdmax then
    mov rsi,[rbp-16] (fidx)               ;#0043C68C: 48:213165 F0               vu 40 20  1   6      
    cmp rsi,1                             ;#0043C690: 48:203376 01               uv 00 40  1   7      
    jl #0043C725                          ;#0043C694: 017214 8B000000            v  00 00  1   7      
    mov rcx,[#004030D8] (fdmax)           ;#0043C69A: 48:213015 376AFCFF         uv 02 00  1   8      
    cmp rsi,rcx                           ;#0043C6A1: 48:071316                  uv 00 42  1   9 02   
    jg #0043C725                          ;#0043C6A4: 177 7F                     v  00 00  1   9      
;  1052         iThis = 1   --DEV fix this!
    mov qword[rbp-8] (iThis),1            ;#0043C6A6: 48:307105 F8 01000000      uv 00 20  1  10      
;  1053         #ilASM{
;  1054             [32]
;  1055                 mov edx,[fidx]
;  1056                 shl edx,2
;  1057               @@:
;  1058                 mov edi,[fdtbl]
;  1059                 mov esi,[edi*4+edx-4]   -- esi:=fdtbl[fidx] (nb fidx=fn-2)
;  1060                 cmp edi,[fdtbl]
;  1061                 jne @b
;  1062                 mov [iThis],esi
;  1063             [64] --and next... [and fix "that bug" otherwise fmode will be treated as 0 next!]
;  1064                 mov rdx,[fidx]
                        mov rdx,[rbp-16] (fidx)  ;#0043C6AE: 48:213125 F0               vu 04 20  1  10      
;  1065                 shl rdx,3
                        shl rdx,3         ;#0043C6B2: 48:301342 03               u  04 04  1  11      
;  1066               @@:
;  1067                 mov rdi,[fdtbl]
                        mov rdi,[#004030D0] (fdtbl)  ;#0043C6B6: 48:213075 136AFCFF         vu 80 00  1  11      
;  1068                 mov rsi,[rdi*4+rdx-8]   -- esi:=fdtbl[fidx] (nb fidx=fn-2)
                        mov rsi,[rdx+rdi*4-8]  ;#0043C6BD: 48:213164272 F8            uv 40 84  1  14    *84*
;  1069                 cmp rdi,[fdtbl]
                        cmp rdi,[#004030D0] (fdtbl)  ;#0043C6C2: 48:073075 076AFCFF         vu 00 80  2  14      
;  1070                 jne @b
                        jne #0043C6B6     ;#0043C6C9: 165 EB                     v  00 00  1  15      
;  1071                 mov [iThis],rsi
                        mov [rbp-8] (iThis),rsi  ;#0043C6CB: 48:211165 F8               uv 00 60  1  16      
;  1072               }
;  1073         if machine_bits()=32 then
;  1074             fmode = peek4u(iThis*4+MODE)
;  1075         else
;  1076 --          ?9/0
;  1077             fmode = peek8u(iThis*4+MODE64)
    lea rdi,[rbp-32] (symtab[1015])       ;#0043C6CF: 48:215175 E0               vu 80 20  1  16      
    mov rcx,[rbp-8] (iThis)               ;#0043C6D3: 48:213115 F8               uv 02 20  1  17      
    mov rax,[#004020A8] (D_YEAR)          ;#0043C6D7: 48:213005 CA59FCFF         vu 01 00  1  17      
    call #0043F67C (:%opMul)              ;#0043C6DE: 350 992F0000               v  00 00  1  18      
    mov rdi,[rbp-32] (symtab[1015])       ;#0043C6E3: 48:213175 E0               uv 80 20  1  19      
    add rdi,8                             ;#0043C6E7: 48:203307 08               uv 80 80  1  20 80   
    mov [rbp-40] (symtab[1016]),rdi       ;#0043C6EB: 48:211175 D8               uv 00 A0  1  21 80   
    lea rdi,[rbp-24] (fmode)              ;#0043C6EF: 48:215175 E8               vu 80 20  1  21      
    mov rsi,[rbp-40] (symtab[1016])       ;#0043C6F3: 48:213165 D8               uv 40 20  1  22      
    xor rcx,rcx                           ;#0043C6F7: 48:061311                  vu 02 02  1  22      
    mov rdx,8                             ;#0043C6FA: 48:307302 08000000         uv 04 00  1  23      
    call #0043ED6C (:%opPeekNx)           ;#0043C701: 350 66260000               v  00 00  1  23      
    mov rcx,[rbp-24] (fmode)              ;#0043C706: 48:213115 E8               uv 02 20  1  24      
    mov r15,h4                            ;#0043C70A: 49:277 0000000000000040    vu 8000 00  1  24      
    cmp rcx,r15                           ;#0043C714: 4C:071371                  uv 00 8002  1  25      
    jl #0043C725                          ;#0043C717: 174 0C                     v  00 00  1  25      
    mov rcx,1014                          ;#0043C719: 48:307301 F6030000         uv 02 00  1  26      
    call #00442A58 (:%opTchkFail)         ;#0043C720: 350 33630000               v  00 00  1  26      
;  1078         end if
;  1079     end if
;  1080     if fmode=0 then
    mov rax,[rbp-24] (fmode)              ;#0043C725: 48:213105 E8               uv 01 20  1  27      
    cmp rax,0                             ;#0043C729: 48:203370 00               uv 00 01  1  28 01   
    jne #0043C742                         ;#0043C72D: 165 13                     v  00 00  1  28      
;  1081 --      iofatal(58,fn)  -- "invalid file number (%d)"
;  1082         #ilASM{
;  1083             [32]
;  1084                 mov edx,[ebp+12]                    -- "called from" address
;  1085                 mov ebp,[ebp+20]                    -- prev_ebp
;  1086                 mov al,58                           -- e58ifn: "invalid file number"
;  1087                 sub edx,1
;  1088             [64]
;  1089                 mov rdx,[rbp+24]                    -- "called from" address
                        mov rdx,[rbp+24]  ;#0043C72F: 48:213125 18               uv 04 20  1  29      
;  1090                 mov rbp,[rbp+40]                    -- prev_ebp
                        mov rbp,[rbp+40] (prevebp)  ;#0043C733: 48:213155 28               vu 20 20  1  29      
;  1091                 mov al,58                           -- e58ifn: "invalid file number"
                        mov al,58         ;#0043C737: 260 3A                     uv 01 00  1  30      
;  1092                 sub rdx,1
                        sub rdx,1         ;#0043C739: 48:203352 01               vu 04 04  1  30      
;  1093             []
;  1094                 jmp :!iDiag
                        jmp #00442E66 (:!iDiag)  ;#0043C73D: 351 24670000               v  00 00  1  31      
;  1095               }
;  1096     end if
;  1097     return iThis
    mov rax,[rbp-8] (iThis)               ;#0043C742: 48:213105 F8               uv 01 20  1  32      
    jmp #0044298D (:%opRetf)              ;#0043C746: 351 42620000               v  00 00  1  32      
;  1098 --DEV/SUG:
;  1099 --- return {iThis,fmode,fhandle}
    call #00442D91 (:%pBadRetf)           ;#0043C74B: 350 41660000               v  00 00  1  33      
;  1100 end function
;  1101 
;  1102 --
;  1103 -- Internal routine flushfidx.
;  1104 --
;  1105 --DEV newsize [PE32]
;  1106     #ilASM{ jmp :fin
                    jmp #0043ED26         ;#0043DB73: 351 AE110000               v  00 00  1   1      
;  1107 --/*
;  1108 global procedure :%n_flush_esiedi(:%)
;  1109 end procedure -- (for Edita/CtrlQ)
;  1110 --*/
;  1111         [32]
;  1112           :%n_flush_esiedi
;  1113             -- On entry, esi is fdtbl[fn-2] shl 2, and
;  1114             --           edi is fmode ([esi+MODE], adjusted)
;  1115 --resets edi
;  1116             --           preserves esi, everything else gets trashed
;  1117             mov [esi+MODE],edi
;  1118           :%n_flush_esi2
;  1119             mov edx,[esi+FEND]
;  1120             test edx,edx
;  1121             jz @f
;  1122 --/*
;  1123             fild qword[esi+POSL]
;  1124             fild dword[esi+FEND]
;  1125             faddp st1,st0
;  1126             fistp qword[esi+POSL]
;  1127 --*/
;  1128             mov eax,[esi+POSL]
;  1129             mov ecx,[esi+POSH]
;  1130             add eax,edx -- frealposn += fend
;  1131             adc ecx,ebx
;  1132             mov [esi+POSL],eax
;  1133             mov [esi+POSH],ecx
;  1134             lea edi,[esi+BUFF]
;  1135         [PE32]
;  1136             push ebx                                    -- lpOverlapped (NULL)
;  1137             push esp                                    -- lpNumberOfBytesWritten
;  1138             push edx                                    -- nNumberOfBytesToWrite (fend)
;  1139             push edi                                    -- lpBuffer
;  1140             push dword[esi]                             -- hFile
;  1141             call "kernel32.dll","WriteFile"
;  1142             test eax,eax
;  1143             jnz @f
;  1144                 call "kernel32.dll","GetLastError"
;  1145                 mov edi,eax                             -- ep1
;  1146                 mov al,98                               -- e98fiofe -- flush error [ep1]
;  1147                 xor esi,esi                             -- ep2 unused
;  1148                 jmp :%pRTErn                            -- fatal error
;  1149           @@:
;  1150             ret
;  1151         [ELF32]
;  1152             pop al
;  1153 --/*
;  1154 global procedure :%n_flush_rsirdi(:%)
;  1155 end procedure -- (for Edita/CtrlQ)
;  1156 --*/
;  1157         [64]
;  1158           :%n_flush_rsirdi
;  1159             -- On entry, rsi is fdtbl[fn-2] shl 2, and
;  1160             --           rdi is fmode ([rsi+MODE64], adjusted)
;  1161 --resets rdi
;  1162             --           preserves rsi, everything else gets trashed
;  1163             mov [rsi+MODE64],rdi
                    mov [rsi+8],rdi       ;#0043DB78: 48:211176 08               uv 00 C0  1   2      
;  1164           :%n_flush_rsi2
;  1165             mov r8,[rsi+FEND64]
                    mov r8,[rsi+24]       ;#0043DB7C: 4C:213106 18               vu 100 40  1   2      
;  1166             test r8,r8
                    test r8,r8            ;#0043DB80: 4D:205300                  uv 00 100  1   3      
;  1167             jz @f
                    jz #0043DBD2          ;#0043DB83: 164 4D                     v  00 00  1   3      
;  1168             mov rax,[rsi+RPOS64]
                    mov rax,[rsi+32]      ;#0043DB85: 48:213106 20               uv 01 40  1   4      
;  1169             add rax,r8 -- frealposn += fend
                    add rax,r8            ;#0043DB89: 49:003300                  uv 01 101  1   5 01   
;  1170             mov [rsi+RPOS64],rax
                    mov [rsi+32],rax      ;#0043DB8C: 48:211106 20               uv 00 41  1   6 01   
;  1171             lea rdi,[rsi+BUFF64]
                    lea rdi,[rsi+40]      ;#0043DB90: 48:215176 28               vu 80 40  1   6      
;  1172         [PE64]
;  1173             mov rcx,rsp -- put 2 copies of rsp onto the stack...
                    mov rcx,rsp           ;#0043DB94: 48:213314                  uv 02 10  1   7      
;  1174             push rsp
                    push rsp              ;#0043DB97: 48:124                     vu 00 10  1   7      
;  1175             push rcx
                    push rcx              ;#0043DB99: 48:121                     uv 00 02  1   8      
;  1176             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#0043DB9B: 48:203314 08               vu 10 10  1   8      
;  1177                         -- if on entry rsp was xxx8: both copies remain on the stack
;  1178                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1179                         -- obviously rsp is now xxx8, whichever alignment we started with
;  1180             sub rsp,8*5     -- minimum 4 param shadow space, lpOverlapped, and align (none in this case)
                    sub rsp,40            ;#0043DB9F: 48:203354 28               uv 10 10  1   9      
;  1181             mov [rsp+32],rbx                            -- lpOverlapped (NULL)
                    mov [rsp+32],rbx      ;#0043DBA3: 48:211134044 20            uv 00 18  1  12 10 *10*
;  1182 --          mov r9,rbx                                  -- lpNumberOfBytesWritten (NULL)    -- NO: can only be NULL when lpOverlappend is non-NULL!!
;  1183             lea r9,[rsp+32]                             -- lpNumberOfBytesWritten
                    lea r9,[rsp+32]       ;#0043DBA8: 4C:215114044 20            vu 200 10  1  12      
;  1184 --          (r8 already set)                            -- nNumberOfBytesToWrite (fend)
;  1185             lea rdx,[rsi+BUFF64]                        -- lpBuffer
                    lea rdx,[rsi+40]      ;#0043DBAD: 48:215126 28               uv 04 40  1  13      
;  1186             mov rcx,[rsi+HNDL64]                        -- hFile
                    mov rcx,[rsi]         ;#0043DBB1: 48:213016                  vu 02 40  1  13      
;  1187             call "kernel32.dll","WriteFile"
                    call [#00401150] (WriteFile)  ;#0043DBB4: 377025 9635FCFF            np 00 00  2  14      
;  1188             test rax,rax
                    test rax,rax          ;#0043DBBA: 48:205300                  uv 00 01  1  16      
;  1189             jnz @f
                    jnz #0043DBD2         ;#0043DBBD: 165 13                     v  00 00  1  16      
;  1190                 call "kernel32.dll","GetLastError"
                        call [#004010A0] (GetLastError)  ;#0043DBBF: 377025 DB34FCFF            np 00 00  2  17      
;  1191                 mov rdi,rax                             -- ep1
                        mov rdi,rax       ;#0043DBC5: 48:213370                  uv 80 01  1  19      
;  1192                 mov al,98                               -- e98fiofe -- flush error [ep1]
                        mov al,98         ;#0043DBC8: 260 62                     vu 01 00  1  19      
;  1193                 xor rsi,rsi                             -- ep2 unused
                        xor rsi,rsi       ;#0043DBCA: 48:061366                  uv 40 40  1  20      
;  1194                 jmp :%pRTErn                            -- fatal error
                        jmp #00442DC8 (:%pRTErn)  ;#0043DBCD: 351 F6510000               v  00 00  1  20      
;  1195           @@:
;  1196 --          add rsp,8*5
;  1197 --          pop rsp
;  1198             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#0043DBD2: 48:213144044 28            uv 10 10  1  21      
;  1199             ret
                    ret                   ;#0043DBD7: 303                        np 00 00  2  22      
;  1200         [ELF64]
;  1201             pop al
;  1202         []
;  1203           ::fin }
;  1204 
;  1205 --global procedure flush(integer fn)
;  1206 procedure fflush(integer fn)
    mov rax,[rbp] (fn)                    ;#0043D19B: 48:213105 00               uv 01 20  1   1      
    mov r15,h4                            ;#0043D19F: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rax,r15                           ;#0043D1A9: 4C:071370                  uv 00 8001  1   2      
    jl #0043D1BA                          ;#0043D1AC: 174 0C                     v  00 00  1   2      
    mov rcx,1018                          ;#0043D1AE: 48:307301 FA030000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043D1B5: 350 9E580000               v  00 00  1   3      
;  1207 -- write any output still in a buffer to disk.
;  1208 -- this is performed automatically by close.
;  1209 -- flush(1) may sometimes be needed (eg when i/o is redirected) before 
;  1210 -- a getc or gets(0), to force display before input.
;  1211 -- flush(-1) flushes all open files (but not the console).
;  1212 integer fidx
;  1213 --atom fhandle
;  1214 
;  1215 --DEV -9?
;  1216     if fn=-1 then
    cmp rax,-1                            ;#0043D1BA: 48:203370 FF               uv 00 01  1   4      
    jne #0043D20A                         ;#0043D1BE: 165 4A                     v  00 00  1   4      
;  1217         for i=1 to fdmax do
    mov rdi,[#004030D8] (fdmax)           ;#0043D1C0: 48:213075 115FFCFF         uv 80 00  1   5      
    mov [rbp-16] (symtab[1020]),rdi       ;#0043D1C7: 48:211175 F0               uv 00 A0  1   6 80   
    mov qword[rbp-24] (i),1               ;#0043D1CB: 48:307105 E8 01000000      vu 00 20  1   6      
    cmp rdi,1                             ;#0043D1D3: 48:201377 01000000         uv 00 80  1   7      
    jl #0043D205                          ;#0043D1DA: 174 29                     v  00 00  1   7      
;  1218             flush(i+2)  --DEV better!
    mov rsi,[rbp-24] (i)                  ;#0043D1DC: 48:213165 E8               uv 40 20  1   8      
    add rsi,2                             ;#0043D1E0: 48:203306 02               uv 40 40  1   9 40   
    mov [rbp-32] (symtab[1022]),rsi       ;#0043D1E4: 48:211165 E0               uv 00 60  1  10 40   
    mov rax,rsi                           ;#0043D1E8: 48:211360                  vu 01 40  1  10      
    call #0043E8B4 (:%opFlush)            ;#0043D1EB: 350 C4160000               v  00 00  1  11      
;  1219 --/*
;  1220             #ilASM{
;  1221                 [32]
;  1222                     mov edx,[i]
;  1223                     shl edx,2   -- edx:=i*4
;  1224                   @@:
;  1225                     mov edi,[fdtbl]
;  1226                     mov esi,[edi*4+edx-4] -- edi:=fdtbl[i]
;  1227                     cmp edi,[fdtbl]
;  1228                     jne @b
;  1229                     mov edi,[ebx+esi*4+MODE]
;  1230                     test edi,F_DIRTY
;  1231                     jz @f
;  1232                         shl esi,2
;  1233                         sub edi,F_DIRTY
;  1234                         call :%n_flush_esiedi
;  1235                   @@:
;  1236                 [64]
;  1237                     pop al
;  1238                 []
;  1239                     }
;  1240 --*/
;  1241         end for
    mov rcx,[rbp-24] (i)                  ;#0043D1F0: 48:213115 E8               uv 02 20  1  12      
    mov rax,[rbp-16] (symtab[1020])       ;#0043D1F4: 48:213105 F0               vu 01 20  1  12      
    add rcx,1                             ;#0043D1F8: 48:203301 01               uv 02 02  1  13      
    cmp rcx,rax                           ;#0043D1FC: 48:073310                  uv 00 03  1  14 02   
    mov [rbp-24] (i),rcx                  ;#0043D1FF: 48:211115 E8               vu 00 22  1  14      
    jle #0043D1DC                         ;#0043D203: 176 D7                     v  00 00  1  15      
;  1242         return
    jmp #0044298D (:%opRetf)              ;#0043D205: 351 83570000               v  00 00  1  16      
;  1243     end if
;  1244     if fn>2 then
    cmp rax,2                             ;#0043D20A: 48:203370 02               uv 00 01  1  17      
    jle #0043D285                         ;#0043D20E: 176 75                     v  00 00  1  17      
;  1245         fidx = fn-2
    sub rax,2                             ;#0043D210: 48:203350 02               uv 01 01  1  18      
    mov rdx,rax                           ;#0043D214: 48:213320                  uv 04 01  1  19 01   
    mov [rbp-8] (fidx),rax                ;#0043D217: 48:211105 F8               vu 00 21  1  19      
    shl rdx,1                             ;#0043D21B: 48:321342                  u  04 04  1  20      
    jno #0043D229                         ;#0043D21E: 161 09                     v  00 00  1  20      
    lea rdi,[rbp-8] (fidx)                ;#0043D220: 48:215175 F8               uv 80 20  1  21      
    call #00442DA9 (:%pAddiii)            ;#0043D224: 350 805B0000               v  00 00  1  21      
;  1246         if fidx<=fdmax then
    mov rdi,[#004030D8] (fdmax)           ;#0043D229: 48:213075 A85EFCFF         uv 80 00  1  22      
    cmp rax,rdi                           ;#0043D230: 48:071370                  uv 00 81  1  23 80   
    jg #0043D2D0                          ;#0043D233: 017217 97000000            v  00 00  1  23      
;  1247 --DEV newsize [PE32], get_this()?
;  1248 --          {iThis,fidx,...} = get_this(fn,F_DIRTY)
;  1249             #ilASM{
;  1250                 [32]
;  1251                     mov edx,[fidx]
;  1252                     shl edx,2               -- edx:=(fidx*4) (nb fidx=fn-2)
;  1253                   @@:
;  1254                     mov edi,[fdtbl]
;  1255                     mov esi,[edi*4+edx-4]   -- esi:=fdtbl[fidx]
;  1256                     cmp edi,[fdtbl]
;  1257                     jne @b
;  1258                     push dword[ebx+esi*4]           -- hFile (param for FlushFileBuffers)
;  1259                     mov edi,[ebx+esi*4+MODE]
;  1260 --                  test edi,edi
;  1261 --                  jnz @f
;  1262 --                      -- e62fnnino:"file number %d is not open"
;  1263 --                      mov al,e62
;  1264 --                      mov edi,[fn]        -- ep1:=fn
;  1265 --                      xor esi,esi         -- ep2 unused
;  1266 --                      call :%pRTErn       -- fatal error
;  1267 --               @@:
;  1268                     test edi,F_DIRTY
;  1269                     jz @f
;  1270                         shl esi,2
;  1271                         sub edi,F_DIRTY
;  1272                         call :%n_flush_esiedi
;  1273                   @@:
;  1274                 [PE32]
;  1275                     call "kernel32.dll","FlushFileBuffers"
;  1276                 [ELF32]
;  1277                     pop al
;  1278                 [64]
;  1279                     mov rdx,[fidx]
                            mov rdx,[rbp-8] (fidx)  ;#0043D239: 48:213125 F8               uv 04 20  1  24      
;  1280                     shl rdx,3               -- rdx:=(fidx*8) (nb fidx=fn-2)
                            shl rdx,3     ;#0043D23D: 48:301342 03               u  04 04  1  25      
;  1281                   @@:
;  1282                     mov rdi,[fdtbl]
                            mov rdi,[#004030D0] (fdtbl)  ;#0043D241: 48:213075 885EFCFF         vu 80 00  1  25      
;  1283                     mov rsi,[rdi*4+rdx-8]   -- rsi:=fdtbl[fidx]
                            mov rsi,[rdx+rdi*4-8]  ;#0043D248: 48:213164272 F8            uv 40 84  1  28    *84*
;  1284                     cmp rdi,[fdtbl]
                            cmp rdi,[#004030D0] (fdtbl)  ;#0043D24D: 48:073075 7C5EFCFF         vu 00 80  2  28      
;  1285                     jne @b
                            jne #0043D241  ;#0043D254: 165 EB                     v  00 00  1  29      
;  1286                     mov rdi,[rbx+rsi*4+MODE64]
                            mov rdi,[rbx+rsi*4+8]  ;#0043D256: 48:213174263 08            uv 80 48  1  30      
;  1287                     test rdi,F_DIRTY
                            test rdi,8    ;#0043D25B: 48:367307 08000000         uv 00 80  1  31 80   
;  1288                     jz @f
                            jz #0043D271  ;#0043D262: 164 0D                     v  00 00  1  31      
;  1289                         shl rsi,2
                                shl rsi,2  ;#0043D264: 48:301346 02               u  40 40  1  32      
;  1290                         sub rdi,F_DIRTY
                                sub rdi,8  ;#0043D268: 48:203357 08               vu 80 80  1  32      
;  1291                         call :%n_flush_rsirdi       -- (rsi is preserved)
                                call :%n_flush_rsirdi  ;#0043D26C: 350 07090000               v  00 00  1  33      
;  1292                   @@:
;  1293                 [PE64]
;  1294                     sub rsp,8*5
                            sub rsp,40    ;#0043D271: 48:203354 28               uv 10 10  1  34      
;  1295                     mov rcx,[rbx+rsi*4]                 -- hFile
                            mov rcx,[rbx+rsi*4]  ;#0043D275: 48:213014263               vu 02 48  1  34      
;  1296                     call "kernel32.dll","FlushFileBuffers"
                            call [#00401068] (FlushFileBuffers)  ;#0043D279: 377025 E93DFCFF            np 00 00  2  35      
;  1297                     add rsp,8*5
                            add rsp,40    ;#0043D27F: 48:203304 28               uv 10 10  1  37      
;  1298                 [ELF64]
;  1299                     pop al
;  1300                 []
;  1301                   }
;  1302         end if
    jmp #0043D2D0                         ;#0043D283: 353 4B                     v  00 00  1  37      
;  1303     elsif fn<=0 then
    cmp rax,0                             ;#0043D285: 48:203370 00               uv 00 01  1  38      
    jg #0043D2A0                          ;#0043D289: 177 15                     v  00 00  1  38      
;  1304         -- flush(0) [stdin] is clearly a programming error
;  1305 --      iofatal(e59wfmfao)
;  1306         #ilASM{
;  1307             [32]
;  1308                 mov edx,[ebp+12]                    -- "called from" address
;  1309                 mov ebp,[ebp+20]                    -- prev_ebp
;  1310                 mov al,59                           -- e59wfmfao: "wrong file mode for attempted operation"
;  1311                 sub edx,1
;  1312             [64]
;  1313                 mov rdx,[rbp+24]                    -- "called from" address
                        mov rdx,[rbp+24]  ;#0043D28B: 48:213125 18               uv 04 20  1  39      
;  1314                 mov rbp,[rbp+40]                    -- prev_ebp
                        mov rbp,[rbp+40] (prevebp)  ;#0043D28F: 48:213155 28               vu 20 20  1  39      
;  1315                 mov al,59                           -- e59wfmfao: "wrong file mode for attempted operation"
                        mov al,59         ;#0043D293: 260 3B                     uv 01 00  1  40      
;  1316                 sub rdx,1
                        sub rdx,1         ;#0043D295: 48:203352 01               vu 04 04  1  40      
;  1317             []
;  1318                 jmp :!iDiag
                        jmp #00442E66 (:!iDiag)  ;#0043D299: 351 C85B0000               v  00 00  1  41      
;  1319               }
    jmp #0043D2D0                         ;#0043D29E: 353 30                     v  00 00  1  42      
;  1320     else -- fn=1 (stdout) or fn=2 (stderr)
;  1321 --      if not cinit then initConsole() end if
;  1322 --DEV newsize [PE32]
;  1323         #ilASM{
;  1324             [32]
;  1325                 mov eax,[stdout]
;  1326                 test eax,eax
;  1327                 jnz @f
;  1328                     call :%n_initC -- (preserves eax)
;  1329 --                  mov eax,[stdout]
;  1330               @@:
;  1331                 cmp [fn],1
;  1332                 je @f
;  1333 --                  jl :e59wfmfao   -- flush(0[=stdin]) => "wrong file mode for attempted operation"
;  1334                     mov eax,[stderr]
;  1335               @@:
;  1336             [PE32]
;  1337                 push eax                            -- hFile
;  1338                 call "kernel32.dll","FlushFileBuffers"
;  1339             [ELF32]
;  1340                 pop al
;  1341             [64]
;  1342                 mov rax,[stdout]
                        mov rax,[#004031B0] (stdout)  ;#0043D2A0: 48:213005 095FFCFF         uv 01 00  1  43      
;  1343                 test rax,rax
                        test rax,rax      ;#0043D2A7: 48:205300                  uv 00 01  1  44 01   
;  1344                 jnz @f
                        jnz #0043D2B1     ;#0043D2AA: 165 05                     v  00 00  1  44      
;  1345                     call :%n_initC -- (preserves rax)
                            call #0043DCFD (:%n_initC)  ;#0043D2AC: 350 4C0A0000               v  00 00  1  45      
;  1346 --                  mov rax,[stdout]
;  1347               @@:
;  1348                 cmp [fn],1
                        cmp qword[rbp] (fn),1  ;#0043D2B1: 48:203175 00 01            u  00 20  2  46      
;  1349                 je @f
                        je #0043D2BF      ;#0043D2B6: 164 07                     v  00 00  1  47      
;  1350 --                  jl :e59wfmfao   -- flush(0[=stdin]) => "wrong file mode for attempted operation"
;  1351                     mov rax,[stderr]
                            mov rax,[#004031B8] (stderr)  ;#0043D2B8: 48:213005 F95EFCFF         uv 01 00  1  48      
;  1352               @@:
;  1353             [PE64]
;  1354                 sub rsp,8*5
                        sub rsp,40        ;#0043D2BF: 48:203354 28               vu 10 10  1  48      
;  1355                 mov rcx,rax                         -- hFile
                        mov rcx,rax       ;#0043D2C3: 48:213310                  uv 02 01  1  49      
;  1356                 call "kernel32.dll","FlushFileBuffers"
                        call [#00401068] (FlushFileBuffers)  ;#0043D2C6: 377025 9C3DFCFF            np 00 00  2  50      
;  1357                 add rsp,8*5
                        add rsp,40        ;#0043D2CC: 48:203304 28               uv 10 10  1  52      
;  1358             [ELF64]
;  1359                 pop al
;  1360             []
;  1361               }
;  1362     end if
    jmp #0044298D (:%opRetf)              ;#0043D2D0: 351 B8560000               v  00 00  1  52      
;  1363 end procedure
;  1364 
;  1365 --global procedure close(integer fn)
;  1366 procedure fclose(integer fn)
    mov rsi,[rbp] (fn)                    ;#0043CF81: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0043CF85: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0043CF8F: 4C:071376                  uv 00 8040  1   2      
    jl #0043CFA0                          ;#0043CF92: 174 0C                     v  00 00  1   2      
    mov rcx,1024                          ;#0043CF94: 48:307301 00040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043CF9B: 350 B85A0000               v  00 00  1   3      
;  1367 --
;  1368 -- Close a file or device and flush out any still-buffered characters. 
;  1369 -- It is not particularly an error to close the same file twice, the
;  1370 -- second and subsequent calls will simply have no effect.
;  1371 -- close(-9) closes all open files. Used as part of the normal shutdown process. 
;  1372 --  Be warned however this will cause catastrophic failure on a multithreaded 
;  1373 --  program if any still-running threads attempt any further file access.
;  1374 --
;  1375 integer fidx
;  1376 --integer fmode
;  1377 --DEV fmode=0?
;  1378 --atom fhandle
;  1379 --atom this
;  1380 integer iThis
;  1381 
;  1382     if fn=-9 then
    cmp rsi,-9                            ;#0043CFA0: 48:203376 F7               uv 00 40  1   4      
    jne #0043D033                         ;#0043CFA4: 017205 89000000            v  00 00  1   4      
;  1383         if finit then
    mov rcx,[#00403178] (finit)           ;#0043CFAA: 48:213015 C761FCFF         uv 02 00  1   5      
    test rcx,rcx                          ;#0043CFB1: 48:205311                  uv 00 02  1   6 02   
    je #0043D196                          ;#0043CFB4: 017204 DC010000            v  00 00  1   6      
;  1384             for i=1 to fdmax do -- (file nos 3 and up)
    mov rax,[#004030D8] (fdmax)           ;#0043CFBA: 48:213005 1761FCFF         uv 01 00  1   7      
    mov [rbp-24] (symtab[1027]),rax       ;#0043CFC1: 48:211105 E8               uv 00 21  1   8 01   
    mov qword[rbp-32] (i),1               ;#0043CFC5: 48:307105 E0 01000000      vu 00 20  1   8      
    cmp rax,1                             ;#0043CFCD: 48:075 01000000            uv 00 01  1   9      
    jl #0043D196                          ;#0043CFD3: 017214 BD010000            v  00 00  1   9      
;  1385                 --DEV/SUG (add locking?)
;  1386 --              if length(filenames[i]) then
;  1387 --                  printf(1,"warning: close(-9) automatically closing %s\n",{filenames[i]})
;  1388                 fclose(i+2)
    lea rdi,[rbp-40] (symtab[1029])       ;#0043CFD9: 48:215175 D8               uv 80 20  1  10      
    mov rcx,[rbp-32] (i)                  ;#0043CFDD: 48:213115 E0               vu 02 20  1  10      
    mov rax,[#00402098] (WIN32)           ;#0043CFE1: 48:213005 B050FCFF         uv 01 00  1  11      
    call #0043F4AF (:%opAdd)              ;#0043CFE8: 350 C2240000               v  00 00  1  11      
    mov rcx,6                             ;#0043CFED: 48:307301 06000000         uv 02 00  1  12      
    mov rdx,1023                          ;#0043CFF4: 48:307302 FF030000         vu 04 00  1  12      
    call #004428DB (:%opFrame) (fclose)   ;#0043CFFB: 350 DB580000               v  00 00  1  13      
    mov rdi,[rbp+40] (prevebp)            ;#0043D000: 48:213175 28               uv 80 20  1  14      
    mov rax,[rdi-40]                      ;#0043D004: 48:213107 D8               uv 01 80  1  17 80 *80*
    mov [rbp] (fn),rax                    ;#0043D008: 48:211105 00               uv 00 21  1  18 01   
    mov qword[retaddr],#0043D019          ;#0043D00C: 48:307105 20 19D04300      vu 00 20  1  18      
    jmp #0043CF81 (code:fclose)           ;#0043D014: 351 68FFFFFF               v  00 00  1  19      
;  1389 --                  filenames[i] = ""
;  1390 --              end if
;  1391             end for
    mov rdi,[rbp-32] (i)                  ;#0043D019: 48:213175 E0               uv 80 20  1  20      
    mov rsi,[rbp-24] (symtab[1027])       ;#0043D01D: 48:213165 E8               vu 40 20  1  20      
    add rdi,1                             ;#0043D021: 48:203307 01               uv 80 80  1  21      
    cmp rdi,rsi                           ;#0043D025: 48:073376                  uv 00 C0  1  22 80   
    mov [rbp-32] (i),rdi                  ;#0043D028: 48:211175 E0               vu 00 A0  1  22      
    jle #0043CFD9                         ;#0043D02C: 176 AB                     v  00 00  1  23      
;  1392             -- (DEV) may want a few free() here...
;  1393 --(eg)
;  1394 --/*
;  1395             enter_cs(fdcs)
;  1396             for i=1 to fdmax do -- (file nos 3 and up)
;  1397                 iThis = fdtbl[i]
;  1398 --              fdtbl[i] = 0
;  1399                 free(iThis*4)           
;  1400             end for
;  1401             fdtbl = {}
;  1402             freelist = 0
;  1403             fdmax = 0
;  1404             leave_cs(fdcs)
;  1405 -- and possibly:
;  1406             delete_cs(fdcs)
;  1407             finit = 0
;  1408 --*/
;  1409         end if
    jmp #0043D196                         ;#0043D02E: 351 63010000               v  00 00  1  24      
;  1410     elsif fn>2 then
    cmp rsi,2                             ;#0043D033: 48:203376 02               uv 00 40  1  25      
    jle #0043D196                         ;#0043D037: 017216 59010000            v  00 00  1  25      
;  1411 --      {iThis,fidx,..} = get_this(fn,F_DIRTY)
;  1412         if not finit then initF() end if
    mov rcx,[#00403178] (finit)           ;#0043D03D: 48:213015 3461FCFF         uv 02 00  1  26      
    test rcx,rcx                          ;#0043D044: 48:205311                  uv 00 02  1  27 02   
    jne #0043D065                         ;#0043D047: 165 1C                     v  00 00  1  27      
    xor rcx,rcx                           ;#0043D049: 48:061311                  uv 02 02  1  28      
    mov rdx,967                           ;#0043D04C: 48:307302 C7030000         vu 04 00  1  28      
    call #004428DB (:%opFrame) (initF)    ;#0043D053: 350 83580000               v  00 00  1  29      
    mov qword[retaddr],#0043D065          ;#0043D058: 48:307105 20 65D04300      uv 00 20  1  30      
    jmp #0043B5D9 (code:initF)            ;#0043D060: 351 74E5FFFF               v  00 00  1  30      
;  1413         fidx = fn-2
    mov rax,[rbp] (fn)                    ;#0043D065: 48:213105 00               uv 01 20  1  31      
    sub rax,2                             ;#0043D069: 48:203350 02               uv 01 01  1  32 01   
    mov rdx,rax                           ;#0043D06D: 48:213320                  uv 04 01  1  33 01   
    mov [rbp-8] (fidx),rax                ;#0043D070: 48:211105 F8               vu 00 21  1  33      
    shl rdx,1                             ;#0043D074: 48:321342                  u  04 04  1  34      
    jno #0043D082                         ;#0043D077: 161 09                     v  00 00  1  34      
    lea rdi,[rbp-8] (fidx)                ;#0043D079: 48:215175 F8               uv 80 20  1  35      
    call #00442DA9 (:%pAddiii)            ;#0043D07D: 350 275D0000               v  00 00  1  35      
;  1414         if fidx<=fdmax then
    mov rdi,[#004030D8] (fdmax)           ;#0043D082: 48:213075 4F60FCFF         uv 80 00  1  36      
    cmp rax,rdi                           ;#0043D089: 48:071370                  uv 00 81  1  37 80   
    jg #0043D196                          ;#0043D08C: 017217 04010000            v  00 00  1  37      
;  1415 --DEV newsize [PE32,ELF32], get_this()?
;  1416             #ilASM{
;  1417                 [32]
;  1418                     mov edx,[fidx]
;  1419                     shl edx,2
;  1420                   @@:
;  1421                     mov edi,[fdtbl]
;  1422                     mov esi,[edx+edi*4-4]   -- esi:=fdtbl[fidx]
;  1423                     cmp edi,[fdtbl]
;  1424                     jne @b
;  1425                     mov eax,[ebx+esi*4+MODE]
;  1426                     mov [iThis],esi
;  1427 --                  mov [fmode],eax
;  1428 --DEV move down? (/make all (including E/LCS, which are in p -imports) of this asm)
;  1429 --          fhandle = peek4u(iThis*4+HNDL)
;  1430 --          fmode = peek4u(iThis*4+MODE)
;  1431 --          if fmode!=0 then
;  1432                     test eax,eax
;  1433                     jz :alreadyclosed
;  1434 --              if and_bits(fmode,F_DIRTY) then
;  1435                     test eax,F_DIRTY
;  1436                     jz @f
;  1437 --                      mov esi,[iThis]
;  1438                         push esi
;  1439                         xor edi,edi         -- mov edi,0 (F_CLOSED)
;  1440                         shl esi,2
;  1441                         call :%n_flush_esiedi
;  1442                         pop esi
;  1443 --              end if
;  1444                    @@:
;  1445 --              poke4(iThis*4+MODE,F_CLOSED)
;  1446                     mov dword[ebx+esi*4+MODE],F_CLOSED
;  1447 --              if c_func(xCloseHandle,{fhandle}) then end if
;  1448                 [PE32]
;  1449                     push dword[ebx+esi*4+HNDL]      -- hObject
;  1450                     call "kernel32.dll","CloseHandle"
;  1451                 [ELF32]
;  1452                     pop al
;  1453                 [64]
;  1454                     mov rdx,[fidx]
                            mov rdx,[rbp-8] (fidx)  ;#0043D092: 48:213125 F8               uv 04 20  1  38      
;  1455                     shl rdx,3
                            shl rdx,3     ;#0043D096: 48:301342 03               u  04 04  1  39      
;  1456                   @@:
;  1457                     mov rdi,[fdtbl]
                            mov rdi,[#004030D0] (fdtbl)  ;#0043D09A: 48:213075 2F60FCFF         vu 80 00  1  39      
;  1458                     mov rsi,[rdx+rdi*4-8]   -- esi:=fdtbl[fidx]
                            mov rsi,[rdx+rdi*4-8]  ;#0043D0A1: 48:213164272 F8            uv 40 84  1  42    *84*
;  1459                     cmp rdi,[fdtbl]
                            cmp rdi,[#004030D0] (fdtbl)  ;#0043D0A6: 48:073075 2360FCFF         vu 00 80  2  42      
;  1460                     jne @b
                            jne #0043D09A  ;#0043D0AD: 165 EB                     v  00 00  1  43      
;  1461                     mov rax,[rbx+rsi*4+MODE64]
                            mov rax,[rbx+rsi*4+8]  ;#0043D0AF: 48:213104263 08            uv 01 48  1  44      
;  1462                     mov [iThis],rsi
                            mov [rbp-16] (iThis),rsi  ;#0043D0B4: 48:211165 F0               vu 00 60  1  44      
;  1463                     test rax,rax
                            test rax,rax  ;#0043D0B8: 48:205300                  uv 00 01  1  45      
;  1464                     jz :alreadyclosed
                            jz #0043D196  ;#0043D0BB: 017204 D5000000            v  00 00  1  45      
;  1465                     test rax,F_DIRTY
                            test rax,8    ;#0043D0C1: 48:367300 08000000         uv 00 01  1  46      
;  1466                     jz @f
                            jz #0043D0DA  ;#0043D0C8: 164 10                     v  00 00  1  46      
;  1467                         push rsi
                                push rsi  ;#0043D0CA: 48:126                     uv 00 40  1  47      
;  1468                         xor rdi,rdi         -- mov edi,0 (F_CLOSED)
                                xor rdi,rdi  ;#0043D0CC: 48:061377                  vu 80 80  1  47      
;  1469                         shl rsi,2
                                shl rsi,2  ;#0043D0CF: 48:301346 02               u  40 40  1  48      
;  1470                         call :%n_flush_rsirdi   -- (preserves rsi, ..., but we damaged it)
                                call :%n_flush_rsirdi  ;#0043D0D3: 350 A00A0000               v  00 00  1  48      
;  1471                         pop rsi
                                pop rsi   ;#0043D0D8: 48:136                     uv 40 00  1  49      
;  1472                    @@:
;  1473                     mov dword[rbx+rsi*4+MODE64],F_CLOSED
                            mov [rbx+rsi*4+8], dword 0  ;#0043D0DA: 307104263 08 00000000      uv 00 48  1  52 40 *40*
;  1474                 [PE64]
;  1475                     sub rsp,8*5
                            sub rsp,40    ;#0043D0E2: 48:203354 28               vu 10 10  1  52      
;  1476                     mov rcx,[rbx+rsi*4+HNDL64]      -- hObject
                            mov rcx,[rbx+rsi*4]  ;#0043D0E6: 48:213014263               uv 02 48  1  53      
;  1477                     call "kernel32.dll","CloseHandle"
                            call [#00401030] (CloseHandle)  ;#0043D0EA: 377025 403FFCFF            np 00 00  2  54      
;  1478                     add rsp,8*5
                            add rsp,40    ;#0043D0F0: 48:203304 28               uv 10 10  1  56      
;  1479                 [ELF64]
;  1480                     pop al
;  1481                 []
;  1482                   }
;  1483             -- and add to freelist
;  1484             enter_cs(fdcs)
    mov rsi,[#004030C8] (fdcs)            ;#0043D0F4: 48:213065 CD5FFCFF         vu 40 00  1  56      
    mov r15,h4                            ;#0043D0FB: 49:277 0000000000000040    uv 8000 00  1  57      
    cmp rsi,r15                           ;#0043D105: 4C:071376                  uv 00 8040  1  58 8000   
    jne #0043D116                         ;#0043D108: 165 0C                     v  00 00  1  58      
    mov rsi,944                           ;#0043D10A: 48:307306 B0030000         uv 40 00  1  59      
    call #00442D75 (:%pUnassigned)        ;#0043D111: 350 5F5C0000               v  00 00  1  59      
    mov rcx,rsi                           ;#0043D116: 48:211361                  uv 02 40  1  60      
    call #0044258C (:%pEnterCS)           ;#0043D119: 350 6E540000               v  00 00  1  60      
;  1485             poke4(iThis*4,freelist)
    mov rcx,[rbp-16] (iThis)              ;#0043D11E: 48:213115 F0               uv 02 20  1  61      
    mov r15,h4                            ;#0043D122: 49:277 0000000000000040    vu 8000 00  1  61      
    cmp rcx,r15                           ;#0043D12C: 4C:071371                  uv 00 8002  1  62      
    jne #0043D13D                         ;#0043D12F: 165 0C                     v  00 00  1  62      
    mov rsi,1026                          ;#0043D131: 48:307306 02040000         uv 40 00  1  63      
    call #00442D75 (:%pUnassigned)        ;#0043D138: 350 385C0000               v  00 00  1  63      
    lea rdi,[rbp-40] (symtab[1029])       ;#0043D13D: 48:215175 D8               uv 80 20  1  64      
    mov rax,[#004020A8] (D_YEAR)          ;#0043D141: 48:213005 604FFCFF         vu 01 00  1  64      
    call #0043F67C (:%opMul)              ;#0043D148: 350 2F250000               v  00 00  1  65      
    mov rax,[#004030E0] (freelist)        ;#0043D14D: 48:213005 8C5FFCFF         uv 01 00  1  66      
    mov rdi,[rbp-40] (symtab[1029])       ;#0043D154: 48:213175 D8               vu 80 20  1  66      
    mov rcx,4                             ;#0043D158: 48:307301 04000000         uv 02 00  1  67      
    call #0043EFA4 (:%opPokeN)            ;#0043D15F: 350 401E0000               v  00 00  1  67      
;  1486             freelist = fidx
    mov rsi,[rbp-8] (fidx)                ;#0043D164: 48:213165 F8               uv 40 20  1  68      
    mov [#004030E0] (freelist),rsi        ;#0043D168: 48:211065 715FFCFF         uv 00 40  1  69 40   
;  1487             leave_cs(fdcs)
    mov rcx,[#004030C8] (fdcs)            ;#0043D16F: 48:213015 525FFCFF         vu 02 00  1  69      
    mov r15,h4                            ;#0043D176: 49:277 0000000000000040    uv 8000 00  1  70      
    cmp rcx,r15                           ;#0043D180: 4C:071371                  uv 00 8002  1  71 8000   
    jne #0043D191                         ;#0043D183: 165 0C                     v  00 00  1  71      
    mov rsi,944                           ;#0043D185: 48:307306 B0030000         uv 40 00  1  72      
    call #00442D75 (:%pUnassigned)        ;#0043D18C: 350 E45B0000               v  00 00  1  72      
    call #004425E9 (:%pLeaveCS)           ;#0043D191: 350 53540000               v  00 00  1  73      
;  1488 --          end if
;  1489             #ilASM { ::alreadyclosed }
;  1490         end if
;  1491     end if
    jmp #0044298D (:%opRetf)              ;#0043D196: 351 F2570000               v  00 00  1  74      
;  1492 end procedure
;  1493 --DEV set callback here... (for opClosem1)
;  1494 
;  1495 
;  1496 --DEV builtin? [DONE]
;  1497 --/*
;  1498 old function peek8u(atom addr)
;  1499 -- (Use of atoms limits accuracy to 2^53 or 9,007,199,254,740,992
;  1500 --                  instead of 2^64 or 18,446,744,073,709,551,616.)
;  1501 atom res
;  1502 --DEV newsize [PE32],:%pStoreFlt
;  1503     #ilASM{
;  1504         [32]
;  1505             mov eax,[addr]
;  1506             lea edi,[res]
;  1507             cmp eax,h4
;  1508             jl @f
;  1509                 sub esp,8
;  1510                 fld qword[ebx+eax*4]
;  1511                 fistp qword[esp]
;  1512                 pop eax
;  1513                 add esp,4
;  1514           @@:
;  1515             fild qword[eax]
;  1516             call :%pStoreFlt    -- ([edi]:=ST0)
;  1517         [64]
;  1518             mov r15,h4
;  1519             mov rax,[addr]
;  1520             lea rdi,[res]
;  1521             cmp rax,r15
;  1522             jl @f
;  1523                 sub rsp,8
;  1524                 fld tbyte[rbx+rax*4]
;  1525                 fistp qword[rsp]
;  1526                 pop rax
;  1527           @@:
;  1528             fild qword[rax]
;  1529             call :%pStoreFlt    -- ([rdi]:=ST0)
;  1530           }
;  1531     return res
;  1532 end function
;  1533 --*/
;  1534 
;  1535 --DEV... allow overrides?
;  1536 --/*
;  1537 old procedure poke8(atom addr, atom a)
;  1538 -- (Use of atoms limits accuracy to 2^53 or 9,007,199,254,740,992
;  1539 --   on 32-bit Phix instead of 2^64 or 18,446,744,073,709,551,616.)
;  1540     #ilASM{
;  1541         [32]
;  1542             mov eax,[addr]
;  1543             mov ecx,[a]
;  1544             cmp eax,h4
;  1545             jl @f
;  1546                 sub esp,8
;  1547                 fld qword[ebx+eax*4]
;  1548                 fistp qword[esp]
;  1549                 pop eax
;  1550                 add esp,4
;  1551           @@:
;  1552             push ebx -- (0)
;  1553             push ecx
;  1554             cmp ecx,h4
;  1555             jl @f
;  1556                 fld qword[ebx+ecx*4]
;  1557                 fistp qword[esp]
;  1558           @@:
;  1559             fild qword[esp]
;  1560             add esp,8
;  1561             fistp qword[eax]
;  1562         [64]
;  1563             mov r15,h4
;  1564             mov rax,[addr]
;  1565             sub rsp,8
;  1566             mov rcx,[a]
;  1567             cmp rax,r15
;  1568             jl @f
;  1569                 fld tbyte[rbx+rax*4]
;  1570                 fistp qword[rsp]
;  1571                 mov rax,[rsp]
;  1572           @@:
;  1573             cmp rcx,r15
;  1574             jl @f
;  1575                 fld tbyte[rbx+rcx*4]
;  1576                 fistp qword[rsp]
;  1577                 mov rcx,[rsp]
;  1578           @@:
;  1579             add rsp,8
;  1580             mov [rax],rcx
;  1581           }
;  1582 end procedure
;  1583 --*/
;  1584 
;  1585 --global function seek(integer fn, atom pos)
;  1586 function fseek(integer fn, atom pos)
    mov rdi,[rbp] (fn)                    ;#0043C978: 48:213175 00               uv 80 20  1   1      
    mov r15,h4                            ;#0043C97C: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0043C986: 4C:071377                  uv 00 8080  1   2      
    jl #0043C997                          ;#0043C989: 174 0C                     v  00 00  1   2      
    mov rcx,1032                          ;#0043C98B: 48:307301 08040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043C992: 350 C1600000               v  00 00  1   3      
    mov rcx,[rbp-8] (pos)                 ;#0043C997: 48:213115 F8               uv 02 20  1   4      
    mov r15,h4                            ;#0043C99B: 49:277 0000000000000040    vu 8000 00  1   4      
    cmp rcx,r15                           ;#0043C9A5: 4C:071371                  uv 00 8002  1   5      
    jl #0043C9BD                          ;#0043C9A8: 174 13                     v  00 00  1   5      
    cmp byte[rbx+rcx*4-1],#12             ;#0043C9AA: 200174213 FF 12            u  00 0A  2   6      
    je #0043C9BD                          ;#0043C9AF: 164 0C                     v  00 00  1   7      
    mov rcx,1033                          ;#0043C9B1: 48:307301 09040000         uv 02 00  1   8      
    call #00442A58 (:%opTchkFail)         ;#0043C9B8: 350 9B600000               v  00 00  1   8      
;  1587 --
;  1588 -- usage:
;  1589 --          if seek(fn,pos)!=SEEK_OK then
;  1590 --              ?9/0 -- some error
;  1591 --          end if
;  1592 --
;  1593 -- If you find any code that does not use SEEK_OK (defined as 0 in psym.e)
;  1594 --  either a) change it to use SEEK_OK or b) be advised that seek returns 0 
;  1595 --  if the seek was successful, 1 if it was not (somewhat counter-intuitive,
;  1596 --  but not worth changing given that it will break mountains of legacy code).
;  1597 --
;  1598 integer fidx
;  1599 integer fmode
;  1600 integer fend
;  1601 --atom fhandle
;  1602 atom workpos    -- (may exceed integer during tests)
;  1603 atom frealposn
;  1604 integer iThis
;  1605 
;  1606     if not finit then initF() end if
    mov rsi,[#00403178] (finit)           ;#0043C9BD: 48:213065 B467FCFF         uv 40 00  1   9      
    test rsi,rsi                          ;#0043C9C4: 48:205366                  uv 00 40  1  10 40   
    jne #0043C9E5                         ;#0043C9C7: 165 1C                     v  00 00  1  10      
    xor rcx,rcx                           ;#0043C9C9: 48:061311                  uv 02 02  1  11      
    mov rdx,967                           ;#0043C9CC: 48:307302 C7030000         vu 04 00  1  11      
    call #004428DB (:%opFrame) (initF)    ;#0043C9D3: 350 035F0000               v  00 00  1  12      
    mov qword[retaddr],#0043C9E5          ;#0043C9D8: 48:307105 20 E5C94300      uv 00 20  1  13      
    jmp #0043B5D9 (code:initF)            ;#0043C9E0: 351 F4EBFFFF               v  00 00  1  13      
;  1607     fidx = fn-2
    mov rax,[rbp] (fn)                    ;#0043C9E5: 48:213105 00               uv 01 20  1  14      
    sub rax,2                             ;#0043C9E9: 48:203350 02               uv 01 01  1  15 01   
    mov rdx,rax                           ;#0043C9ED: 48:213320                  uv 04 01  1  16 01   
    mov [rbp-16] (fidx),rax               ;#0043C9F0: 48:211105 F0               vu 00 21  1  16      
    shl rdx,1                             ;#0043C9F4: 48:321342                  u  04 04  1  17      
    jno #0043CA02                         ;#0043C9F7: 161 09                     v  00 00  1  17      
    lea rdi,[rbp-16] (fidx)               ;#0043C9F9: 48:215175 F0               uv 80 20  1  18      
    call #00442DA9 (:%pAddiii)            ;#0043C9FD: 350 A7630000               v  00 00  1  18      
;  1608     fmode = 0
    mov [rbp-24] (fmode),rbx              ;#0043CA02: 48:211135 E8               uv 00 28  1  19      
;  1609     if fidx>=1 and fidx<=fdmax then
    cmp rax,1                             ;#0043CA06: 48:203370 01               vu 00 01  1  19      
    jl #0043CA4A                          ;#0043CA0A: 174 3E                     v  00 00  1  20      
    mov rdi,[#004030D8] (fdmax)           ;#0043CA0C: 48:213075 C566FCFF         uv 80 00  1  21      
    cmp rax,rdi                           ;#0043CA13: 48:071370                  uv 00 81  1  22 80   
    jg #0043CA4A                          ;#0043CA16: 177 32                     v  00 00  1  22      
;  1610 --DEV/SUG:
;  1611 --      {iThis,fidx,..} = get_this(fn,F_DIRTY)
;  1612 --      fmode = peek4u(iThis*4+MODE)
;  1613         fmode = 1   --DEV should really fix this... (compiler issue)
    mov qword[rbp-24] (fmode),1           ;#0043CA18: 48:307105 E8 01000000      uv 00 20  1  23      
;  1614         #ilASM{
;  1615             [32]
;  1616                 mov edx,[fidx]
;  1617                 shl edx,2
;  1618               @@:
;  1619                 mov edi,[fdtbl]
;  1620                 mov esi,[edi*4+edx-4]   -- esi:=fdtbl[fidx]
;  1621                 cmp edi,[fdtbl]
;  1622                 jne @b
;  1623                 mov eax,[ebx+esi*4+MODE]
;  1624                 mov [iThis],esi
;  1625                 mov [fmode],eax
;  1626             [64]
;  1627                 mov rdx,[fidx]
                        mov rdx,[rbp-16] (fidx)  ;#0043CA20: 48:213125 F0               vu 04 20  1  23      
;  1628                 shl rdx,3
                        shl rdx,3         ;#0043CA24: 48:301342 03               u  04 04  1  24      
;  1629               @@:
;  1630                 mov rdi,[fdtbl]
                        mov rdi,[#004030D0] (fdtbl)  ;#0043CA28: 48:213075 A166FCFF         vu 80 00  1  24      
;  1631                 mov rsi,[rdi*4+rdx-8]   -- esi:=fdtbl[fidx]
                        mov rsi,[rdx+rdi*4-8]  ;#0043CA2F: 48:213164272 F8            uv 40 84  1  27    *84*
;  1632                 cmp rdi,[fdtbl]
                        cmp rdi,[#004030D0] (fdtbl)  ;#0043CA34: 48:073075 9566FCFF         vu 00 80  2  27      
;  1633                 jne @b
                        jne #0043CA28     ;#0043CA3B: 165 EB                     v  00 00  1  28      
;  1634                 mov rax,[rbx+rsi*4+MODE64]
                        mov rax,[rbx+rsi*4+8]  ;#0043CA3D: 48:213104263 08            uv 01 48  1  29      
;  1635                 mov [iThis],rsi
                        mov [rbp-56] (iThis),rsi  ;#0043CA42: 48:211165 C8               vu 00 60  1  29      
;  1636                 mov [fmode],rax
                        mov [rbp-24] (fmode),rax  ;#0043CA46: 48:211105 E8               uv 00 21  1  30      
;  1637               }
;  1638     end if
;  1639     if fmode=0 then
    mov rcx,[rbp-24] (fmode)              ;#0043CA4A: 48:213115 E8               vu 02 20  1  30      
    cmp rcx,0                             ;#0043CA4E: 48:203371 00               uv 00 02  1  31      
    jne #0043CA6E                         ;#0043CA52: 165 1A                     v  00 00  1  31      
;  1640 --      iofatal(58,fn)  -- "invalid file number (%d)"
;  1641         #ilASM{
;  1642             [32]
;  1643                 mov edi,[fn]                        -- ep1:=fn
;  1644 --              pop edx
;  1645 --              mov edx,[ebp+16]                    -- return address
;  1646                 mov edx,[ebp+12]                    -- "called from" address
;  1647                 mov ebp,[ebp+20]                    -- prev_ebp
;  1648                 mov al,58                           -- e58bfn: "bad file number"
;  1649                 xor esi,esi                         -- ep2 unused
;  1650                 sub edx,1
;  1651             [64]
;  1652                 mov rdi,[fn]                        -- ep1:=fn
                        mov rdi,[rbp] (fn)  ;#0043CA54: 48:213175 00               uv 80 20  1  32      
;  1653 --              mov rdx,[rbp+32]                    -- return address
;  1654                 mov rdx,[rbp+24]                    -- "called from" address
                        mov rdx,[rbp+24]  ;#0043CA58: 48:213125 18               vu 04 20  1  32      
;  1655                 mov rbp,[rbp+40]                    -- prev_ebp
                        mov rbp,[rbp+40] (prevebp)  ;#0043CA5C: 48:213155 28               uv 20 20  1  33      
;  1656                 mov al,58                           -- e58bfn: "bad file number"
                        mov al,58         ;#0043CA60: 260 3A                     vu 01 00  1  33      
;  1657                 xor rsi,rsi                         -- ep2 unused
                        xor rsi,rsi       ;#0043CA62: 48:061366                  uv 40 40  1  34      
;  1658                 sub rdx,1
                        sub rdx,1         ;#0043CA65: 48:203352 01               vu 04 04  1  34      
;  1659             []
;  1660                 jmp :!iDiag
                        jmp #00442E66 (:!iDiag)  ;#0043CA69: 351 F8630000               v  00 00  1  35      
;  1661               }
;  1662     end if
;  1663     if pos=-1 then -- eof
    mov rsi,[rbp-8] (pos)                 ;#0043CA6E: 48:213165 F8               uv 40 20  1  36      
    cmp rsi,-1                            ;#0043CA72: 48:203376 FF               uv 00 40  1  37 40   
    jne #0043CAEC                         ;#0043CA76: 165 74                     v  00 00  1  37      
;  1664         if and_bits(fmode,F_DIRTY) then
    mov rax,[rbp-24] (fmode)              ;#0043CA78: 48:213105 E8               uv 01 20  1  38      
    and rax,8                             ;#0043CA7C: 48:203340 08               uv 01 01  1  39 01   
    je #0043CA97                          ;#0043CA80: 164 15                     v  00 00  1  39      
;  1665             #ilASM{
;  1666                 [32]
;  1667                     mov esi,[iThis]
;  1668                     mov edi,[fmode]
;  1669                     shl esi,2
;  1670                     sub edi,F_DIRTY
;  1671                     call :%n_flush_esiedi
;  1672                 [64]
;  1673                     mov rsi,[iThis]
                            mov rsi,[rbp-56] (iThis)  ;#0043CA82: 48:213165 C8               uv 40 20  1  40      
;  1674                     mov rdi,[fmode]
                            mov rdi,[rbp-24] (fmode)  ;#0043CA86: 48:213175 E8               vu 80 20  1  40      
;  1675                     shl rsi,2
                            shl rsi,2     ;#0043CA8A: 48:301346 02               u  40 40  1  41      
;  1676                     sub rdi,F_DIRTY
                            sub rdi,8     ;#0043CA8E: 48:203357 08               vu 80 80  1  41      
;  1677                     call :%n_flush_rsirdi
                            call :%n_flush_rsirdi  ;#0043CA92: 350 E1100000               v  00 00  1  42      
;  1678                   }
;  1679         end if
;  1680         #ilASM{
;  1681             [PE32]
;  1682                 mov esi,[iThis]
;  1683                 push ebx        -- DistanceToMoveHigh (0), and rposn hiword (edx)
;  1684                 shl esi,2
;  1685                 mov edi,esp
;  1686                 push esi        -- save [DEV better:restore iThis b4 cmp eax,-1 and use ebx+esi*4?] (spotted in passing)
;  1687                 push FILE_END                       -- dwMoveMethod
;  1688                 push edi                            -- lpDistanceToMoveHigh
;  1689                 push ebx                            -- lDistanceToMove (0)
;  1690                 push dword[esi]                     -- hFile
;  1691                 call "kernel32.dll","SetFilePointer"
;  1692                 mov ecx,eax     -- rposn loword
;  1693                 cmp eax,-1
;  1694                 jne @f
;  1695                     call "kernel32.dll","GetLastError"
;  1696                     cmp eax,NO_ERROR
;  1697                     jne @f
;  1698                         -- return 1
;  1699                         mov eax,1
;  1700                         jmp :%opRetf
;  1701               @@:
;  1702                 pop esi     -- restore
;  1703                 pop edx     -- rposn hiword
;  1704                 mov [esi+POSN],dword 1
;  1705                 mov [esi+FEND],ebx --(0)
;  1706                 mov [esi+POSL],ecx
;  1707                 mov [esi+POSH],edx
;  1708             [ELF32]
;  1709                 pop al
;  1710             [PE64]
;  1711                 mov rsi,[iThis]
                        mov rsi,[rbp-56] (iThis)  ;#0043CA97: 48:213165 C8               uv 40 20  1  43      
;  1712                 sub rsp,8*5                         -- minimum 4 param shadow space, newFilePointer, save rax, and align
                        sub rsp,40        ;#0043CA9B: 48:203354 28               vu 10 10  1  43      
;  1713                 mov r9,FILE_END                     -- dwMoveMethod
                        mov r9,2          ;#0043CA9F: 49:307301 02000000         uv 200 00  1  44      
;  1714                 lea r8,[rsp+32]                     -- lpNewFilePointer
                        lea r8,[rsp+32]   ;#0043CAA6: 4C:215104044 20            uv 100 10  1  46    *10*
;  1715                 mov rdx,rbx                         -- liDistanceToMove (0)
                        mov rdx,rbx       ;#0043CAAB: 48:213323                  vu 04 08  1  46      
;  1716                 mov rcx,[rbx+rsi*4+HNDL64]          -- hFile
                        mov rcx,[rbx+rsi*4]  ;#0043CAAE: 48:213014263               uv 02 48  1  47      
;  1717                 call "kernel32.dll","SetFilePointerEx"
                        call [#00401128] (SetFilePointerEx)  ;#0043CAB2: 377025 7046FCFF            np 00 00  2  48      
;  1718                 cmp rax,0
                        cmp rax,0         ;#0043CAB8: 48:203370 00               uv 00 01  1  50      
;  1719                 jne @f
                        jne #0043CAC8     ;#0043CABC: 165 0A                     v  00 00  1  50      
;  1720                     -- return 1
;  1721                     mov eax,1
                            mov eax,1     ;#0043CABE: 270 01000000               uv 01 00  1  51      
;  1722                     jmp :%opRetf
                            jmp #0044298D (:%opRetf)  ;#0043CAC3: 351 C55E0000               v  00 00  1  51      
;  1723               @@:
;  1724                 mov rcx,[rsp+32]
                        mov rcx,[rsp+32]  ;#0043CAC8: 48:213114044 20            uv 02 10  1  52      
;  1725                 add rsp,8*5
                        add rsp,40        ;#0043CACD: 48:203304 28               vu 10 10  1  52      
;  1726                 mov [rbx+rsi*4+POSN64],qword 1
                        mov qword[rbx+rsi*4+16],1  ;#0043CAD1: 48:307104263 10 01000000   uv 00 48  1  53      
;  1727                 mov [rbx+rsi*4+FEND64],rbx --(0)
                        mov [rbx+rsi*4+24],rbx  ;#0043CADA: 48:211134263 18            vu 00 48  1  53      
;  1728                 mov [rbx+rsi*4+RPOS64],rcx
                        mov [rbx+rsi*4+32],rcx  ;#0043CADF: 48:211114263 20            uv 00 4A  1  54      
;  1729             [ELF64]
;  1730                 pop al
;  1731               }
;  1732         return 0                            -- success
    xor rax,rax                           ;#0043CAE4: 48:061300                  vu 01 01  1  54      
    jmp #0044298D (:%opRetf)              ;#0043CAE7: 351 A15E0000               v  00 00  1  55      
;  1733     end if
;  1734 
;  1735     if machine_bits()=32 then
;  1736 --      frealposn = peek8u(iThis*4+POSL)
;  1737         frealposn = peek4u(iThis*4+POSL)+(peek4u(iThis*4+POSH)*#100000000)
;  1738         fend = peek4u(iThis*4+FEND)
;  1739     else -- machine_bits()=64
;  1740         frealposn = peek8u(iThis*4+RPOS64)
    mov rdi,[rbp-56] (iThis)              ;#0043CAEC: 48:213175 C8               uv 80 20  1  56      
    mov r15,h4                            ;#0043CAF0: 49:277 0000000000000040    vu 8000 00  1  56      
    cmp rdi,r15                           ;#0043CAFA: 4C:071377                  uv 00 8080  1  57      
    jne #0043CB0B                         ;#0043CAFD: 165 0C                     v  00 00  1  57      
    mov rsi,1039                          ;#0043CAFF: 48:307306 0F040000         uv 40 00  1  58      
    call #00442D75 (:%pUnassigned)        ;#0043CB06: 350 6A620000               v  00 00  1  58      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CB0B: 48:215175 C0               uv 80 20  1  59      
    mov rcx,[rbp-56] (iThis)              ;#0043CB0F: 48:213115 C8               vu 02 20  1  59      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CB13: 48:213005 8E55FCFF         uv 01 00  1  60      
    call #0043F67C (:%opMul)              ;#0043CB1A: 350 5D2B0000               v  00 00  1  60      
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CB1F: 48:215175 B8               uv 80 20  1  61      
    mov rcx,[rbp-64] (symtab[1040])       ;#0043CB23: 48:213115 C0               vu 02 20  1  61      
    mov rax,[#00403140] (RPOS64)          ;#0043CB27: 48:213005 1266FCFF         uv 01 00  1  62      
    call #0043F4AF (:%opAdd)              ;#0043CB2E: 350 7C290000               v  00 00  1  62      
    lea rdi,[rbp-48] (frealposn)          ;#0043CB33: 48:215175 D0               uv 80 20  1  63      
    mov rsi,[rbp-72] (symtab[1041])       ;#0043CB37: 48:213165 B8               vu 40 20  1  63      
    xor rcx,rcx                           ;#0043CB3B: 48:061311                  uv 02 02  1  64      
    mov rdx,8                             ;#0043CB3E: 48:307302 08000000         vu 04 00  1  64      
    call #0043ED6C (:%opPeekNx)           ;#0043CB45: 350 22220000               v  00 00  1  65      
;  1741         fend = peek8u(iThis*4+FEND64)
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CB4A: 48:215175 B8               uv 80 20  1  66      
    mov rcx,[rbp-56] (iThis)              ;#0043CB4E: 48:213115 C8               vu 02 20  1  66      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CB52: 48:213005 4F55FCFF         uv 01 00  1  67      
    call #0043F67C (:%opMul)              ;#0043CB59: 350 1E2B0000               v  00 00  1  67      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CB5E: 48:215175 C0               uv 80 20  1  68      
    mov rcx,[rbp-72] (symtab[1041])       ;#0043CB62: 48:213115 B8               vu 02 20  1  68      
    mov rax,[#00403138] (FEND64)          ;#0043CB66: 48:213005 CB65FCFF         uv 01 00  1  69      
    call #0043F4AF (:%opAdd)              ;#0043CB6D: 350 3D290000               v  00 00  1  69      
    lea rdi,[rbp-32] (fend)               ;#0043CB72: 48:215175 E0               uv 80 20  1  70      
    mov rsi,[rbp-64] (symtab[1040])       ;#0043CB76: 48:213165 C0               vu 40 20  1  70      
    xor rcx,rcx                           ;#0043CB7A: 48:061311                  uv 02 02  1  71      
    mov rdx,8                             ;#0043CB7D: 48:307302 08000000         vu 04 00  1  71      
    call #0043ED6C (:%opPeekNx)           ;#0043CB84: 350 E3210000               v  00 00  1  72      
    mov rdi,[rbp-32] (fend)               ;#0043CB89: 48:213175 E0               uv 80 20  1  73      
    mov r15,h4                            ;#0043CB8D: 49:277 0000000000000040    vu 8000 00  1  73      
    cmp rdi,r15                           ;#0043CB97: 4C:071377                  uv 00 8080  1  74      
    jl #0043CBA8                          ;#0043CB9A: 174 0C                     v  00 00  1  74      
    mov rcx,1036                          ;#0043CB9C: 48:307301 0C040000         uv 02 00  1  75      
    call #00442A58 (:%opTchkFail)         ;#0043CBA3: 350 B05E0000               v  00 00  1  75      
;  1742     end if
;  1743     if and_bits(fmode,F_DIRTY) then
    mov rcx,[rbp-24] (fmode)              ;#0043CBA8: 48:213115 E8               uv 02 20  1  76      
    and rcx,8                             ;#0043CBAC: 48:203341 08               uv 02 02  1  77 02   
    je #0043CD82                          ;#0043CBB0: 017204 CC010000            v  00 00  1  77      
;  1744         -- realposn corresponds to the \\start\\ of the buffer,
;  1745         -- and we can extend/write beyond fend upto BUFFERSIZE.
;  1746         workpos = pos-frealposn+1
    mov rax,[rbp-48] (frealposn)          ;#0043CBB6: 48:213105 D0               uv 01 20  1  78      
    mov r15,h4                            ;#0043CBBA: 49:277 0000000000000040    vu 8000 00  1  78      
    cmp rax,r15                           ;#0043CBC4: 4C:071370                  uv 00 8001  1  79      
    jne #0043CBD5                         ;#0043CBC7: 165 0C                     v  00 00  1  79      
    mov rsi,1038                          ;#0043CBC9: 48:307306 0E040000         uv 40 00  1  80      
    call #00442D75 (:%pUnassigned)        ;#0043CBD0: 350 A0610000               v  00 00  1  80      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CBD5: 48:215175 C0               uv 80 20  1  81      
    mov rcx,[rbp-8] (pos)                 ;#0043CBD9: 48:213115 F8               vu 02 20  1  81      
    call #0043F4D8 (:%opSub)              ;#0043CBDD: 350 F6280000               v  00 00  1  82      
    lea rdi,[rbp-40] (workpos)            ;#0043CBE2: 48:215175 D8               uv 80 20  1  83      
    mov rcx,[rbp-64] (symtab[1040])       ;#0043CBE6: 48:213115 C0               vu 02 20  1  83      
    mov rax,qword[#00402030]              ;#0043CBEA: 48:213005 3F54FCFF         uv 01 00  1  84      
    call #0043F4AF (:%opAdd)              ;#0043CBF1: 350 B9280000               v  00 00  1  84      
;  1747         if machine_bits()=32 then
;  1748             if workpos>=1 and workpos<=BUFFERSIZE32 and workpos<=fend+1 then
;  1749                 poke4(iThis*4+POSN,workpos)
;  1750                 return 0                            -- success
;  1751             end if
;  1752         else -- machine_bits()=64
;  1753             if workpos>=1 and workpos<=BUFFERSIZE64 and workpos<=fend+1 then
    mov rdi,1                             ;#0043CBF6: 48:307307 01000000         uv 80 00  1  85      
    mov rax,[rbp-40] (workpos)            ;#0043CBFD: 48:213105 D8               vu 01 20  1  85      
    mov rsi,26                            ;#0043CC01: 48:307306 1A000000         uv 40 00  1  86      
    mov rdx,1037                          ;#0043CC08: 48:307302 0D040000         vu 04 00  1  86      
    call #0043FA81 (:%opJcc)              ;#0043CC0F: 350 6D2E0000               v  00 00  1  87      
    jl #0043CD68                          ;#0043CC14: 017214 4E010000            v  00 00  1  88      
    mov rdi,8152                          ;#0043CC1A: 48:307307 D81F0000         uv 80 00  1  89      
    mov rax,[rbp-40] (workpos)            ;#0043CC21: 48:213105 D8               vu 01 20  1  89      
    mov rsi,915                           ;#0043CC25: 48:307306 93030000         uv 40 00  1  90      
    mov rdx,1037                          ;#0043CC2C: 48:307302 0D040000         vu 04 00  1  90      
    call #0043FA81 (:%opJcc)              ;#0043CC33: 350 492E0000               v  00 00  1  91      
    jg #0043CD68                          ;#0043CC38: 017217 2A010000            v  00 00  1  92      
    mov rsi,[rbp-32] (fend)               ;#0043CC3E: 48:213165 E0               uv 40 20  1  93      
    mov r15,h4                            ;#0043CC42: 49:277 0000000000000040    vu 8000 00  1  93      
    cmp rsi,r15                           ;#0043CC4C: 4C:071376                  uv 00 8040  1  94      
    jne #0043CC5D                         ;#0043CC4F: 165 0C                     v  00 00  1  94      
    mov rsi,1036                          ;#0043CC51: 48:307306 0C040000         uv 40 00  1  95      
    call #00442D75 (:%pUnassigned)        ;#0043CC58: 350 18610000               v  00 00  1  95      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CC5D: 48:215175 C0               uv 80 20  1  96      
    mov rcx,rsi                           ;#0043CC61: 48:211361                  vu 02 40  1  96      
    mov rax,qword[#00402030]              ;#0043CC64: 48:213005 C553FCFF         uv 01 00  1  97      
    call #0043F4AF (:%opAdd)              ;#0043CC6B: 350 3F280000               v  00 00  1  97      
    mov rdi,[rbp-64] (symtab[1040])       ;#0043CC70: 48:213175 C0               uv 80 20  1  98      
    mov rax,[rbp-40] (workpos)            ;#0043CC74: 48:213105 D8               vu 01 20  1  98      
    mov rsi,1040                          ;#0043CC78: 48:307306 10040000         uv 40 00  1  99      
    mov rdx,1037                          ;#0043CC7F: 48:307302 0D040000         vu 04 00  1  99      
    call #0043FA81 (:%opJcc)              ;#0043CC86: 350 F62D0000               v  00 00  1 100      
    jg #0043CD68                          ;#0043CC8B: 017217 D7000000            v  00 00  1 101      
;  1754 --DEV (compiler crashes)
;  1755 --              poke8(iThis*4+POSN64,workpos)
;  1756                 poke4(iThis*4+POSN64,and_bits(workpos,#FFFFFFFF))
    mov rcx,[rbp-56] (iThis)              ;#0043CC91: 48:213115 C8               uv 02 20  1 102      
    mov r15,h4                            ;#0043CC95: 49:277 0000000000000040    vu 8000 00  1 102      
    cmp rcx,r15                           ;#0043CC9F: 4C:071371                  uv 00 8002  1 103      
    jne #0043CCB0                         ;#0043CCA2: 165 0C                     v  00 00  1 103      
    mov rsi,1039                          ;#0043CCA4: 48:307306 0F040000         uv 40 00  1 104      
    call #00442D75 (:%pUnassigned)        ;#0043CCAB: 350 C5600000               v  00 00  1 104      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CCB0: 48:215175 C0               uv 80 20  1 105      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CCB4: 48:213005 ED53FCFF         vu 01 00  1 105      
    call #0043F67C (:%opMul)              ;#0043CCBB: 350 BC290000               v  00 00  1 106      
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CCC0: 48:215175 B8               uv 80 20  1 107      
    mov rcx,[rbp-64] (symtab[1040])       ;#0043CCC4: 48:213115 C0               vu 02 20  1 107      
    mov rax,[#00403130] (POSN64)          ;#0043CCC8: 48:213005 6164FCFF         uv 01 00  1 108      
    call #0043F4AF (:%opAdd)              ;#0043CCCF: 350 DB270000               v  00 00  1 108      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CCD4: 48:215175 C0               uv 80 20  1 109      
    mov rcx,[rbp-40] (workpos)            ;#0043CCD8: 48:213115 D8               vu 02 20  1 109      
    mov rax,[#00402198] (INFINITE)        ;#0043CCDC: 48:213005 B554FCFF         uv 01 00  1 110      
    call #0043F6C1 (:%opAndBits)          ;#0043CCE3: 350 D9290000               v  00 00  1 110      
    mov rax,[rbp-64] (symtab[1040])       ;#0043CCE8: 48:213105 C0               uv 01 20  1 111      
    mov rdi,[rbp-72] (symtab[1041])       ;#0043CCEC: 48:213175 B8               vu 80 20  1 111      
    mov rcx,4                             ;#0043CCF0: 48:307301 04000000         uv 02 00  1 112      
    call #0043EFA4 (:%opPokeN)            ;#0043CCF7: 350 A8220000               v  00 00  1 112      
;  1757                 poke4(iThis*4+POSN64+4,floor(workpos/#100000000))
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CCFC: 48:215175 B8               uv 80 20  1 113      
    mov rcx,[rbp-56] (iThis)              ;#0043CD00: 48:213115 C8               vu 02 20  1 113      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CD04: 48:213005 9D53FCFF         uv 01 00  1 114      
    call #0043F67C (:%opMul)              ;#0043CD0B: 350 6C290000               v  00 00  1 114      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CD10: 48:215175 C0               uv 80 20  1 115      
    mov rcx,[rbp-72] (symtab[1041])       ;#0043CD14: 48:213115 B8               vu 02 20  1 115      
    mov rax,[#00403130] (POSN64)          ;#0043CD18: 48:213005 1164FCFF         uv 01 00  1 116      
    call #0043F4AF (:%opAdd)              ;#0043CD1F: 350 8B270000               v  00 00  1 116      
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CD24: 48:215175 B8               uv 80 20  1 117      
    mov rcx,[rbp-64] (symtab[1040])       ;#0043CD28: 48:213115 C0               vu 02 20  1 117      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CD2C: 48:213005 7553FCFF         uv 01 00  1 118      
    call #0043F4AF (:%opAdd)              ;#0043CD33: 350 77270000               v  00 00  1 118      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CD38: 48:215175 C0               uv 80 20  1 119      
    mov rcx,[rbp-40] (workpos)            ;#0043CD3C: 48:213115 D8               vu 02 20  1 119      
    mov rax,qword[#00402D28]              ;#0043CD40: 48:213005 E15FFCFF         uv 01 00  1 120      
    call #0043F5E4 (:%opDivf)             ;#0043CD47: 350 98280000               v  00 00  1 120      
    mov rax,[rbp-64] (symtab[1040])       ;#0043CD4C: 48:213105 C0               uv 01 20  1 121      
    mov rdi,[rbp-72] (symtab[1041])       ;#0043CD50: 48:213175 B8               vu 80 20  1 121      
    mov rcx,4                             ;#0043CD54: 48:307301 04000000         uv 02 00  1 122      
    call #0043EFA4 (:%opPokeN)            ;#0043CD5B: 350 44220000               v  00 00  1 122      
;  1758                 return 0                            -- success
    xor rax,rax                           ;#0043CD60: 48:061300                  uv 01 01  1 123      
    jmp #0044298D (:%opRetf)              ;#0043CD63: 351 255C0000               v  00 00  1 123      
;  1759             end if
;  1760         end if
;  1761         #ilASM{
;  1762             [32]
;  1763                 mov esi,[iThis]
;  1764                 mov edi,[fmode]
;  1765                 shl esi,2
;  1766                 sub edi,F_DIRTY
;  1767                 call :%n_flush_esiedi
;  1768             [64]
;  1769                 mov rsi,[iThis]
                        mov rsi,[rbp-56] (iThis)  ;#0043CD68: 48:213165 C8               uv 40 20  1 124      
;  1770                 mov rdi,[fmode]
                        mov rdi,[rbp-24] (fmode)  ;#0043CD6C: 48:213175 E8               vu 80 20  1 124      
;  1771                 shl rsi,2
                        shl rsi,2         ;#0043CD70: 48:301346 02               u  40 40  1 125      
;  1772                 sub rdi,F_DIRTY
                        sub rdi,8         ;#0043CD74: 48:203357 08               vu 80 80  1 125      
;  1773                 call :%n_flush_rsirdi
                        call :%n_flush_rsirdi  ;#0043CD78: 350 FB0D0000               v  00 00  1 126      
;  1774               }
    jmp #0043CF10                         ;#0043CD7D: 351 8E010000               v  00 00  1 127      
;  1775     else
;  1776         -- realposn corresponds to the \\end\\ of the buffer, but
;  1777         -- in this case fend is the hard limit of readable bytes.
;  1778         workpos = pos-(frealposn-fend)+1
    mov rsi,[rbp-48] (frealposn)          ;#0043CD82: 48:213165 D0               uv 40 20  1 128      
    mov r15,h4                            ;#0043CD86: 49:277 0000000000000040    vu 8000 00  1 128      
    cmp rsi,r15                           ;#0043CD90: 4C:071376                  uv 00 8040  1 129      
    jne #0043CDA1                         ;#0043CD93: 165 0C                     v  00 00  1 129      
    mov rsi,1038                          ;#0043CD95: 48:307306 0E040000         uv 40 00  1 130      
    call #00442D75 (:%pUnassigned)        ;#0043CD9C: 350 D45F0000               v  00 00  1 130      
    mov r15,h4                            ;#0043CDA1: 49:277 0000000000000040    uv 8000 00  1 131      
    cmp rdi,r15                           ;#0043CDAB: 4C:071377                  uv 00 8080  1 132 8000   
    jne #0043CDBC                         ;#0043CDAE: 165 0C                     v  00 00  1 132      
    mov rsi,1036                          ;#0043CDB0: 48:307306 0C040000         uv 40 00  1 133      
    call #00442D75 (:%pUnassigned)        ;#0043CDB7: 350 B95F0000               v  00 00  1 133      
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CDBC: 48:215175 B8               uv 80 20  1 134      
    mov rcx,rsi                           ;#0043CDC0: 48:211361                  vu 02 40  1 134      
    mov rax,[rbp-32] (fend)               ;#0043CDC3: 48:213105 E0               uv 01 20  1 135      
    call #0043F4D8 (:%opSub)              ;#0043CDC7: 350 0C270000               v  00 00  1 135      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CDCC: 48:215175 C0               uv 80 20  1 136      
    mov rcx,[rbp-8] (pos)                 ;#0043CDD0: 48:213115 F8               vu 02 20  1 136      
    mov rax,[rbp-72] (symtab[1041])       ;#0043CDD4: 48:213105 B8               uv 01 20  1 137      
    call #0043F4D8 (:%opSub)              ;#0043CDD8: 350 FB260000               v  00 00  1 137      
    lea rdi,[rbp-40] (workpos)            ;#0043CDDD: 48:215175 D8               uv 80 20  1 138      
    mov rcx,[rbp-64] (symtab[1040])       ;#0043CDE1: 48:213115 C0               vu 02 20  1 138      
    mov rax,qword[#00402030]              ;#0043CDE5: 48:213005 4452FCFF         uv 01 00  1 139      
    call #0043F4AF (:%opAdd)              ;#0043CDEC: 350 BE260000               v  00 00  1 139      
;  1779         if workpos>=1 and workpos<=fend then
    mov rdi,1                             ;#0043CDF1: 48:307307 01000000         uv 80 00  1 140      
    mov rax,[rbp-40] (workpos)            ;#0043CDF8: 48:213105 D8               vu 01 20  1 140      
    mov rsi,26                            ;#0043CDFC: 48:307306 1A000000         uv 40 00  1 141      
    mov rdx,1037                          ;#0043CE03: 48:307302 0D040000         vu 04 00  1 141      
    call #0043FA81 (:%opJcc)              ;#0043CE0A: 350 722C0000               v  00 00  1 142      
    jl #0043CF10                          ;#0043CE0F: 017214 FB000000            v  00 00  1 143      
    mov rdi,[rbp-32] (fend)               ;#0043CE15: 48:213175 E0               uv 80 20  1 144      
    mov rax,[rbp-40] (workpos)            ;#0043CE19: 48:213105 D8               vu 01 20  1 144      
    mov rsi,1036                          ;#0043CE1D: 48:307306 0C040000         uv 40 00  1 145      
    mov rdx,1037                          ;#0043CE24: 48:307302 0D040000         vu 04 00  1 145      
    call #0043FA81 (:%opJcc)              ;#0043CE2B: 350 512C0000               v  00 00  1 146      
    jg #0043CF10                          ;#0043CE30: 017217 DA000000            v  00 00  1 147      
;  1780             if machine_bits()=32 then
;  1781                 poke4(iThis*4+POSN,workpos)
;  1782             else --64
;  1783 --DEV as above...
;  1784 --              poke8(iThis*4+POSN64,workpos)
;  1785                 poke4(iThis*4+POSN64,and_bits(workpos,#FFFFFFFF))
    mov rsi,[rbp-56] (iThis)              ;#0043CE36: 48:213165 C8               uv 40 20  1 148      
    mov r15,h4                            ;#0043CE3A: 49:277 0000000000000040    vu 8000 00  1 148      
    cmp rsi,r15                           ;#0043CE44: 4C:071376                  uv 00 8040  1 149      
    jne #0043CE55                         ;#0043CE47: 165 0C                     v  00 00  1 149      
    mov rsi,1039                          ;#0043CE49: 48:307306 0F040000         uv 40 00  1 150      
    call #00442D75 (:%pUnassigned)        ;#0043CE50: 350 205F0000               v  00 00  1 150      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CE55: 48:215175 C0               uv 80 20  1 151      
    mov rcx,rsi                           ;#0043CE59: 48:211361                  vu 02 40  1 151      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CE5C: 48:213005 4552FCFF         uv 01 00  1 152      
    call #0043F67C (:%opMul)              ;#0043CE63: 350 14280000               v  00 00  1 152      
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CE68: 48:215175 B8               uv 80 20  1 153      
    mov rcx,[rbp-64] (symtab[1040])       ;#0043CE6C: 48:213115 C0               vu 02 20  1 153      
    mov rax,[#00403130] (POSN64)          ;#0043CE70: 48:213005 B962FCFF         uv 01 00  1 154      
    call #0043F4AF (:%opAdd)              ;#0043CE77: 350 33260000               v  00 00  1 154      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CE7C: 48:215175 C0               uv 80 20  1 155      
    mov rcx,[rbp-40] (workpos)            ;#0043CE80: 48:213115 D8               vu 02 20  1 155      
    mov rax,[#00402198] (INFINITE)        ;#0043CE84: 48:213005 0D53FCFF         uv 01 00  1 156      
    call #0043F6C1 (:%opAndBits)          ;#0043CE8B: 350 31280000               v  00 00  1 156      
    mov rax,[rbp-64] (symtab[1040])       ;#0043CE90: 48:213105 C0               uv 01 20  1 157      
    mov rdi,[rbp-72] (symtab[1041])       ;#0043CE94: 48:213175 B8               vu 80 20  1 157      
    mov rcx,4                             ;#0043CE98: 48:307301 04000000         uv 02 00  1 158      
    call #0043EFA4 (:%opPokeN)            ;#0043CE9F: 350 00210000               v  00 00  1 158      
;  1786                 poke4(iThis*4+POSN64+4,floor(workpos/#100000000))
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CEA4: 48:215175 B8               uv 80 20  1 159      
    mov rcx,[rbp-56] (iThis)              ;#0043CEA8: 48:213115 C8               vu 02 20  1 159      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CEAC: 48:213005 F551FCFF         uv 01 00  1 160      
    call #0043F67C (:%opMul)              ;#0043CEB3: 350 C4270000               v  00 00  1 160      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CEB8: 48:215175 C0               uv 80 20  1 161      
    mov rcx,[rbp-72] (symtab[1041])       ;#0043CEBC: 48:213115 B8               vu 02 20  1 161      
    mov rax,[#00403130] (POSN64)          ;#0043CEC0: 48:213005 6962FCFF         uv 01 00  1 162      
    call #0043F4AF (:%opAdd)              ;#0043CEC7: 350 E3250000               v  00 00  1 162      
    lea rdi,[rbp-72] (symtab[1041])       ;#0043CECC: 48:215175 B8               uv 80 20  1 163      
    mov rcx,[rbp-64] (symtab[1040])       ;#0043CED0: 48:213115 C0               vu 02 20  1 163      
    mov rax,[#004020A8] (D_YEAR)          ;#0043CED4: 48:213005 CD51FCFF         uv 01 00  1 164      
    call #0043F4AF (:%opAdd)              ;#0043CEDB: 350 CF250000               v  00 00  1 164      
    lea rdi,[rbp-64] (symtab[1040])       ;#0043CEE0: 48:215175 C0               uv 80 20  1 165      
    mov rcx,[rbp-40] (workpos)            ;#0043CEE4: 48:213115 D8               vu 02 20  1 165      
    mov rax,qword[#00402D28]              ;#0043CEE8: 48:213005 395EFCFF         uv 01 00  1 166      
    call #0043F5E4 (:%opDivf)             ;#0043CEEF: 350 F0260000               v  00 00  1 166      
    mov rax,[rbp-64] (symtab[1040])       ;#0043CEF4: 48:213105 C0               uv 01 20  1 167      
    mov rdi,[rbp-72] (symtab[1041])       ;#0043CEF8: 48:213175 B8               vu 80 20  1 167      
    mov rcx,4                             ;#0043CEFC: 48:307301 04000000         uv 02 00  1 168      
    call #0043EFA4 (:%opPokeN)            ;#0043CF03: 350 9C200000               v  00 00  1 168      
;  1787             end if
;  1788             return 0                            -- success
    xor rax,rax                           ;#0043CF08: 48:061300                  uv 01 01  1 169      
    jmp #0044298D (:%opRetf)              ;#0043CF0B: 351 7D5A0000               v  00 00  1 169      
;  1789         end if
;  1790     end if
;  1791 --DEV newsize [PE32,ELF32]
;  1792     #ilASM{
;  1793         [32]
;  1794             mov esi,[iThis]
;  1795             push ebx                                -- DistanceToMoveHigh (0), and rposn hiword (edx)
;  1796             shl esi,2
;  1797             mov ecx,[pos]
;  1798             mov edi,esp                             -- (lpDistanceToMoveHigh)
;  1799             cmp ecx,h4  --DEV :%pLoadMint
;  1800             jl @f
;  1801                 push ebx
;  1802 --              fld qword[ebx+eax*4]
;  1803                 fld qword[ebx+ecx*4]
;  1804                 fistp qword[esp]                    -- nb: [esp+4]=[edi]=*lpDistanceToMoveHigh just got set
;  1805                 pop ecx                             -- DistanceToMove (loword)
;  1806           @@:
;  1807         [PE32]
;  1808             push esi                                -- save
;  1809             push FILE_BEGIN                         -- dwMoveMethod
;  1810             push edi                                -- lpDistanceToMoveHigh
;  1811             push ecx                                -- lDistanceToMove
;  1812             push dword[esi+HNDL]                    -- hFile
;  1813             call "kernel32.dll","SetFilePointer"
;  1814             mov ecx,eax     -- rposn loword
;  1815             cmp eax,-1
;  1816             jne @f
;  1817                 call "kernel32.dll","GetLastError"
;  1818                 cmp eax,NO_ERROR
;  1819                 jne @f
;  1820                     add esp,8
;  1821                     -- return 1 (failure)
;  1822                     mov eax,1
;  1823                     jmp :%opRetf
;  1824           @@:
;  1825             pop esi                                 -- restore
;  1826             pop edx                                 -- rposn hiword
;  1827             mov [esi+POSN],dword 1
;  1828             mov [esi+FEND],ebx -- (0)
;  1829             mov [esi+POSL],ecx
;  1830             mov [esi+POSH],edx
;  1831         [ELF32]
;  1832             pop al
;  1833         [64]
;  1834             mov rsi,[iThis]
                    mov rsi,[rbp-56] (iThis)  ;#0043CF10: 48:213165 C8               uv 40 20  1 170      
;  1835             mov rdx,[pos]
                    mov rdx,[rbp-8] (pos)  ;#0043CF14: 48:213125 F8               vu 04 20  1 170      
;  1836             mov r15,h4
                    mov r15,h4            ;#0043CF18: 49:277 0000000000000040    uv 8000 00  1 171      
;  1837             cmp rdx,r15
                    cmp rdx,r15           ;#0043CF22: 49:073327                  uv 00 8004  1 172 8000   
;  1838             jl @f
                    jl #0043CF31          ;#0043CF25: 174 0A                     v  00 00  1 172      
;  1839                 push rbx
                        push rbx          ;#0043CF27: 48:123                     uv 00 08  1 173      
;  1840                 fld tbyte[rbx+rdx*4]
                        fld tbyte[rbx+rdx*4]  ;#0043CF29: 333054223                  np 00 0C  3 174      
;  1841                 fistp qword[rsp]
                        fistp qword[rsp]  ;#0043CF2C: 337074044                  np 00 10  6 177      
;  1842                 pop rdx
                        pop rdx           ;#0043CF2F: 48:132                     uv 04 00  1 183      
;  1843           @@:
;  1844         [PE64]
;  1845             sub rsp,8*5                         -- minimum 4 param shadow space, newFilePointer, and align(0)
                    sub rsp,40            ;#0043CF31: 48:203354 28               vu 10 10  1 183      
;  1846             mov r9,FILE_BEGIN                   -- dwMoveMethod
                    mov r9,0              ;#0043CF35: 49:307301 00000000         uv 200 00  1 184      
;  1847             lea r8,[rsp+32]                     -- lpNewFilePointer
                    lea r8,[rsp+32]       ;#0043CF3C: 4C:215104044 20            uv 100 10  1 186    *10*
;  1848 --          (rdx)                               -- liDistanceToMove
;  1849             mov rcx,[rbx+rsi*4+HNDL64]          -- hFile
                    mov rcx,[rbx+rsi*4]   ;#0043CF41: 48:213014263               vu 02 48  1 186      
;  1850             call "kernel32.dll","SetFilePointerEx"
                    call [#00401128] (SetFilePointerEx)  ;#0043CF45: 377025 DD41FCFF            np 00 00  2 187      
;  1851             cmp rax,0
                    cmp rax,0             ;#0043CF4B: 48:203370 00               uv 00 01  1 189      
;  1852             jne @f
                    jne #0043CF5D         ;#0043CF4F: 165 0C                     v  00 00  1 189      
;  1853                 -- return 1 (failure)
;  1854                 mov rax,1
                        mov rax,1         ;#0043CF51: 48:307300 01000000         uv 01 00  1 190      
;  1855                 jmp :%opRetf
                        jmp #0044298D (:%opRetf)  ;#0043CF58: 351 305A0000               v  00 00  1 190      
;  1856           @@:
;  1857             mov rcx,[rsp+32]
                    mov rcx,[rsp+32]      ;#0043CF5D: 48:213114044 20            uv 02 10  1 191      
;  1858             add rsp,8*5
                    add rsp,40            ;#0043CF62: 48:203304 28               vu 10 10  1 191      
;  1859             mov [rbx+rsi*4+POSN64],qword 1
                    mov qword[rbx+rsi*4+16],1  ;#0043CF66: 48:307104263 10 01000000   uv 00 48  1 192      
;  1860             mov [rbx+rsi*4+FEND64],rbx --(0)
                    mov [rbx+rsi*4+24],rbx  ;#0043CF6F: 48:211134263 18            vu 00 48  1 192      
;  1861             mov [rbx+rsi*4+RPOS64],rcx
                    mov [rbx+rsi*4+32],rcx  ;#0043CF74: 48:211114263 20            uv 00 4A  1 193      
;  1862         [ELF64]
;  1863             pop al
;  1864           }
;  1865     return 0                                -- success
    xor rax,rax                           ;#0043CF79: 48:061300                  vu 01 01  1 193      
    jmp #0044298D (:%opRetf)              ;#0043CF7C: 351 0C5A0000               v  00 00  1 194      
;  1866 end function
;  1867 
;  1868 --global function where(integer fn)
;  1869 function fwhere(integer fn)
    mov rsi,[rbp] (fn)                    ;#0043C84C: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0043C850: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0043C85A: 4C:071376                  uv 00 8040  1   2      
    jl #0043C86B                          ;#0043C85D: 174 0C                     v  00 00  1   2      
    mov rcx,1044                          ;#0043C85F: 48:307301 14040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043C866: 350 ED610000               v  00 00  1   3      
;  1870 integer fidx
;  1871 --integer fmode
;  1872 --integer fend
;  1873 --integer fposn
;  1874 atom frealposn
;  1875 --atom this
;  1876 --integer iThis
;  1877 
;  1878 --  {iThis,fidx,fmode,..} = get_this(fn,0)
;  1879     if not finit then initF() end if
    mov rdi,[#00403178] (finit)           ;#0043C86B: 48:213075 0669FCFF         uv 80 00  1   4      
    test rdi,rdi                          ;#0043C872: 48:205377                  uv 00 80  1   5 80   
    jne #0043C893                         ;#0043C875: 165 1C                     v  00 00  1   5      
    xor rcx,rcx                           ;#0043C877: 48:061311                  uv 02 02  1   6      
    mov rdx,967                           ;#0043C87A: 48:307302 C7030000         vu 04 00  1   6      
    call #004428DB (:%opFrame) (initF)    ;#0043C881: 350 55600000               v  00 00  1   7      
    mov qword[retaddr],#0043C893          ;#0043C886: 48:307105 20 93C84300      uv 00 20  1   8      
    jmp #0043B5D9 (code:initF)            ;#0043C88E: 351 46EDFFFF               v  00 00  1   8      
;  1880     fidx = fn-2
    mov rcx,[rbp] (fn)                    ;#0043C893: 48:213115 00               uv 02 20  1   9      
    sub rcx,2                             ;#0043C897: 48:203351 02               uv 02 02  1  10 02   
    mov rdx,rcx                           ;#0043C89B: 48:213321                  uv 04 02  1  11 02   
    mov [rbp-8] (fidx),rcx                ;#0043C89E: 48:211115 F8               vu 00 22  1  11      
    shl rdx,1                             ;#0043C8A2: 48:321342                  u  04 04  1  12      
    jno #0043C8B0                         ;#0043C8A5: 161 09                     v  00 00  1  12      
    lea rdi,[rbp-8] (fidx)                ;#0043C8A7: 48:215175 F8               uv 80 20  1  13      
    call #00442DA9 (:%pAddiii)            ;#0043C8AB: 350 F9640000               v  00 00  1  13      
;  1881     if fidx<1 or fidx>fdmax then
    cmp rcx,1                             ;#0043C8B0: 48:203371 01               uv 00 02  1  14      
    jl #0043C8C2                          ;#0043C8B4: 174 0C                     v  00 00  1  14      
    mov rax,[#004030D8] (fdmax)           ;#0043C8B6: 48:213005 1B68FCFF         uv 01 00  1  15      
    cmp rcx,rax                           ;#0043C8BD: 48:071301                  uv 00 03  1  16 01   
    jle #0043C8F5                         ;#0043C8C0: 176 33                     v  00 00  1  16      
;  1882         iofatal(58,fn)  -- "invalid file number (%d)"
    mov rcx,2                             ;#0043C8C2: 48:307301 02000000         uv 02 00  1  17      
    mov rdx,968                           ;#0043C8C9: 48:307302 C8030000         vu 04 00  1  17      
    call #004428DB (:%opFrame) (iofatal)  ;#0043C8D0: 350 06600000               v  00 00  1  18      
    mov qword[rbp] (errcode),58           ;#0043C8D5: 48:307105 00 3A000000      uv 00 20  1  19      
    mov rdi,[rbp+40] (prevebp)            ;#0043C8DD: 48:213175 28               vu 80 20  1  19      
    mov rax,[rdi]                         ;#0043C8E1: 48:213007                  uv 01 80  1  22    *80*
    mov [rbp-8] (ep1),rax                 ;#0043C8E4: 48:211105 F8               uv 00 21  1  23 01   
    mov qword[retaddr],#0043C8F5          ;#0043C8E8: 48:307105 20 F5C84300      vu 00 20  1  23      
    jmp #0043C328 (code:iofatal)          ;#0043C8F0: 351 33FAFFFF               v  00 00  1  24      
;  1883 --/*
;  1884         #ilASM{
;  1885             [32]
;  1886                 mov edx,[ebp+12]                    -- "called from" address
;  1887                 mov ebp,[ebp+20]                    -- prev_ebp
;  1888                 mov al,57                           -- e57ifn: "invalid file name"
;  1889                 sub edx,1
;  1890             [64]
;  1891                 mov rdx,[rbp+24]                    -- "called from" address
;  1892                 mov rbp,[rbp+40]                    -- prev_ebp
;  1893                 mov al,57                           -- e57ifn: "invalid file name"
;  1894                 sub rdx,1
;  1895             []
;  1896                 jmp :!iDiag
;  1897               }
;  1898 --*/
;  1899     end if
;  1900 --DEV newsize [PE32,ELF32], get_this()?
;  1901     #ilASM{
;  1902         [32]
;  1903             mov edx,[fidx]
;  1904             shl edx,2
;  1905           @@:
;  1906             mov edi,[fdtbl]
;  1907             mov esi,[edx+edi*4-4]   -- esi:=fdtbl[fidx]
;  1908             cmp edi,[fdtbl]
;  1909             jne @b
;  1910             mov eax,[ebx+esi*4+MODE]
;  1911 --          mov ecx,[ebx+esi*4+POSN]
;  1912 --          mov [iThis],esi
;  1913 --          mov [fmode],eax
;  1914 --          mov [fposn],ecx
;  1915             fild qword[ebx+esi*4+POSL]
;  1916             fild dword[ebx+esi*4+POSN]
;  1917             faddp st1,st0
;  1918             test eax,F_DIRTY
;  1919             jnz @f
;  1920                 fild dword[ebx+esi*4+FEND]
;  1921                 fsubp st1,st0
;  1922           @@:
;  1923             lea edi,[frealposn]
;  1924             call :%pStoreFlt
;  1925         [64]
;  1926             mov rdx,[fidx]
                    mov rdx,[rbp-8] (fidx)  ;#0043C8F5: 48:213125 F8               uv 04 20  1  25      
;  1927 --          shl rdx,2
;  1928             shl rdx,3
                    shl rdx,3             ;#0043C8F9: 48:301342 03               u  04 04  1  26      
;  1929           @@:
;  1930             mov rdi,[fdtbl]
                    mov rdi,[#004030D0] (fdtbl)  ;#0043C8FD: 48:213075 CC67FCFF         vu 80 00  1  26      
;  1931             mov rsi,[rdx+rdi*4-8]   -- rsi:=fdtbl[fidx]
                    mov rsi,[rdx+rdi*4-8]  ;#0043C904: 48:213164272 F8            uv 40 84  1  29    *84*
;  1932             cmp rdi,[fdtbl]
                    cmp rdi,[#004030D0] (fdtbl)  ;#0043C909: 48:073075 C067FCFF         vu 00 80  2  29      
;  1933             jne @b
                    jne #0043C8FD         ;#0043C910: 165 EB                     v  00 00  1  30      
;  1934             mov rax,[rbx+rsi*4+MODE64]
                    mov rax,[rbx+rsi*4+8]  ;#0043C912: 48:213104263 08            uv 01 48  1  31      
;  1935             fild qword[rbx+rsi*4+RPOS64]
                    fild qword[rbx+rsi*4+32]  ;#0043C917: 337154263 20               np 00 48  3  32      
;  1936             fild qword[rbx+rsi*4+POSN64]
                    fild qword[rbx+rsi*4+16]  ;#0043C91B: 337154263 10               np 00 48  3  35      
;  1937             faddp st1,st0
                    faddp st1,st0         ;#0043C91F: 336301                     np 00 00  3  38      
;  1938             test rax,F_DIRTY
                    test rax,8            ;#0043C921: 48:367300 08000000         uv 00 01  1  41      
;  1939             jnz @f
                    jnz #0043C930         ;#0043C928: 165 06                     v  00 00  1  41      
;  1940                 fild qword[rbx+rsi*4+FEND64]
                        fild qword[rbx+rsi*4+24]  ;#0043C92A: 337154263 18               np 00 48  3  42      
;  1941                 fsubp st1,st0
                        fsubp st1,st0     ;#0043C92E: 336351                     np 00 00  3  45      
;  1942           @@:
;  1943             lea rdi,[frealposn]
                    lea rdi,[rbp-16] (frealposn)  ;#0043C930: 48:215175 F0               uv 80 20  1  48      
;  1944             call :%pStoreFlt
                    call #004421B0 (:%pStoreFlt)  ;#0043C934: 350 77580000               v  00 00  1  48      
;  1945           }
;  1946 --DEV newsize [32,64]/machine_bits()
;  1947 --  frealposn = peek8u(iThis*4+POSL)
;  1948 --  fposn = peek4u(iThis*4+POSN)
;  1949 --  frealposn += fposn-1
;  1950 --  fmode = peek4u(iThis*4+MODE)
;  1951 --  if not and_bits(fmode,F_DIRTY) then
;  1952 --      fend = peek4u(iThis*4+FEND)
;  1953 --      frealposn -= fend
;  1954 --  end if
;  1955     frealposn -= 1
    mov rsi,[rbp-16] (frealposn)          ;#0043C939: 48:213165 F0               uv 40 20  1  49      
    mov r15,h4                            ;#0043C93D: 49:277 0000000000000040    vu 8000 00  1  49      
    cmp rsi,r15                           ;#0043C947: 4C:071376                  uv 00 8040  1  50      
    jne #0043C958                         ;#0043C94A: 165 0C                     v  00 00  1  50      
    mov rsi,1046                          ;#0043C94C: 48:307306 16040000         uv 40 00  1  51      
    call #00442D75 (:%pUnassigned)        ;#0043C953: 350 1D640000               v  00 00  1  51      
    lea rdi,[rbp-16] (frealposn)          ;#0043C958: 48:215175 F0               uv 80 20  1  52      
    mov rcx,rsi                           ;#0043C95C: 48:211361                  vu 02 40  1  52      
    mov rax,qword[#00402030]              ;#0043C95F: 48:213005 CA56FCFF         uv 01 00  1  53      
    call #0043F4D8 (:%opSub)              ;#0043C966: 350 6D2B0000               v  00 00  1  53      
;  1956     return frealposn
    mov rax,[rbp-16] (frealposn)          ;#0043C96B: 48:213105 F0               uv 01 20  1  54      
    mov [rbp-16] (frealposn),rbx          ;#0043C96F: 48:211135 F0               vu 00 28  1  54      
    jmp #0044298D (:%opRetf)              ;#0043C973: 351 15600000               v  00 00  1  55      
;  1957 end function
;  1958 
;  1959 --[DEV] epic fail: (DOH, was not setting up eax/stdout!!) [btw: there's another commented-out puts1seq below]
;  1960 --procedure puts1seq(sequence s)
;  1961 --? if not cinit then initConsole() end if
;  1962 --  if not string(s) then
;  1963 --      s = toString(s,e65sfics)
;  1964 --  end if
;  1965 --DEV newsize [PE32]
;  1966 --  #ilASM{
;  1967 --      [32]
;  1968 --          cmp [stdout],0
;  1969 --          jne @f
;  1970 --              call :%n_initC -- (preserves eax)
;  1971 --        @@:
;  1972 --          mov edx,[s]
;  1973 --          mov ecx,[ebx+edx*4-12]      -- length
;  1974 --          shl edx,2
;  1975 --          push ebx                    -- lpOverlapped (NULL)
;  1976 --          push esp                    -- lpNumberOfBytesWritten
;  1977 --          push ecx                    -- nNumberOfBytesToWrite
;  1978 --          push edx                    -- lpBuffer
;  1979 --          push [stdout]               -- hFile,
;  1980 --          call "kernel32.dll","WriteFile"
;  1981 --      [64]
;  1982 --          pop al
;  1983 --      [ELF32]
;  1984 --          pop al
;  1985 --      [PE64]
;  1986 --          pop al
;  1987 --      [ELF64]
;  1988 --          pop al
;  1989 --        }
;  1990 --end procedure
;  1991 --
;  1992 --puts1seq({'a','b','\n'})
;  1993 
;  1994 --DEV newsize [PE32]
;  1995 #ilASM{ jmp :fin
                jmp #0043ED26             ;#0043DBD8: 351 49110000               v  00 00  1   1      
;  1996 --/*
;  1997 global function getc(integer fn, :%opGetc)
;  1998 end function
;  1999 --*/
;  2000   :%opGetc
;  2001 ----------
;  2002     [32]
;  2003         -- fn in eax
;  2004         -- dest in edi
;  2005         -- if dest is integer, result in ecx, range -1..255, done by opGetc in pilx86.e
;  2006         push dword[edi]
;  2007         push edi
;  2008         lea ecx,[ebx+eax*4]                     -- ecx:=fn*4 [fn->0-based byte idx+12]
;  2009         mov edi,[fdtbl]
;  2010         sub eax,3 -- [fn->0-based idx]
;  2011         jb :getc0
;  2012         cmp eax,[fdmax]
;  2013         jb @f
;  2014       ::getce58bfn
;  2015             add esp,8
;  2016       ::getce58bfnNP
;  2017             lea edi,[eax+3]                     -- ep1:=fn
;  2018             mov al,58                           -- e58bfn: "bad file number"
;  2019             pop edx
;  2020             xor esi,esi                         -- ep2 unused
;  2021 --          call :%pRTErn                       -- fatal error
;  2022             sub edx,1
;  2023             jmp :!iDiag
;  2024       ::retryx
;  2025           mov edi,[fdtbl]
;  2026       @@:
;  2027         mov esi,[edi*4+ecx-12]                  -- esi:=fdtbl[fn-2]
;  2028         cmp edi,[fdtbl]
;  2029         jne :retryx
;  2030         shl esi,2
;  2031         mov edi,[esi+MODE]
;  2032         mov eax,[esi+POSN]
;  2033         test edi,F_READ
;  2034         jz :e59wfmfao
;  2035         mov ecx,ebx                             -- ecx:=0
;  2036       ::looptop
;  2037         cmp eax,[esi+FEND]
;  2038         jle :notfull                            -- jl @f    [?] [DEV]
;  2039             push esi
;  2040             mov edi,[esi+MODE]
;  2041             test edi,F_DIRTY
;  2042             jz @f
;  2043                 sub edi,F_DIRTY
;  2044                 call :%n_flush_esiedi
;  2045                 mov esi,[esp]
;  2046           @@:
;  2047             lea ecx,[esi+FEND]
;  2048             lea edi,[esi+BUFF]
;  2049         [PE32]
;  2050             push ebx                                        -- lpOverlapped (NULL)
;  2051             push ecx                                        -- lpNumberOfBytesRead (fend)
;  2052             push BUFFERSIZE32                               -- nNumberOfBytesToRead
;  2053             push edi                                        -- lpBuffer
;  2054             push [esi+HNDL]                                 -- hFile
;  2055             call "kernel32.dll","ReadFile"
;  2056         [ELF32]
;  2057             pop al
;  2058         [32]
;  2059             pop esi
;  2060             test eax,eax
;  2061             jz :retm1
;  2062             cmp dword[esi+FEND],0
;  2063             je :retm1
;  2064 --DEV replace with proper 64-bit maths:
;  2065             fild qword[esi+POSL]
;  2066             fild dword[esi+FEND]
;  2067             mov ecx,ebx -- ecx:=0
;  2068             faddp
;  2069             mov eax,1
;  2070             fistp qword[esi+POSL]
;  2071 --/*
;  2072             mov eax,[esi+POSL]
;  2073             mov ecx,[esi+POSH]
;  2074 --          add eax,edx -- frealposn += fend
;  2075             add eax,[esi+FEND] -- frealposn += fend
;  2076             adc ecx,ebx
;  2077             mov edi,1
;  2078             mov [esi+POSL],eax
;  2079             mov [esi+POSH],ecx
;  2080             mov [esi+POSN],edi
;  2081 --*/
;  2082 --          mov [esi+POSN],eax (unnecessary?)
;  2083       ::notfull
;  2084         mov cl,byte[esi+eax+BUFF-1]
;  2085         add eax,1                                           -- fposn+=1
;  2086         cmp cl,'\r'
;  2087         jne @f
;  2088         test dword[esi+MODE],F_BINARY
;  2089         jz :looptop
;  2090       @@:
;  2091         mov [esi+POSN],eax
;  2092       ::opGetcStoreEcx
;  2093         pop edi
;  2094         pop edx
;  2095         cmp edx,h4
;  2096         mov [edi],ecx
;  2097         jle @f
;  2098             sub dword[ebx+edx*4-8],1
;  2099             je :%pDealloc
;  2100       @@:
;  2101         ret
;  2102 
;  2103       ::retm1
;  2104         mov ecx,-1
;  2105         jmp :opGetcStoreEcx
;  2106 
;  2107     [64]
;  2108         -- fn in rax
;  2109         -- dest in rdi
;  2110         -- if dest is integer, result in rcx, range -1..255, done by opGetc in pilx86.e
;  2111         push qword[rdi]
                push qword[rdi]           ;#0043DBDD: 48:377067                  np 00 80  2   2      
;  2112         push rdi
                push rdi                  ;#0043DBE0: 48:127                     uv 00 80  1   4      
;  2113         lea rcx,[rbx+rax*8]                     -- ecx:=fn*8 [fn->0-based byte idx+24]
                lea rcx,[rbx+rax*8]       ;#0043DBE2: 48:215014303               vu 02 09  1   4      
;  2114         mov rdi,[fdtbl]
                mov rdi,[#004030D0] (fdtbl)  ;#0043DBE6: 48:213075 E354FCFF         uv 80 00  1   5      
;  2115         sub rax,3 -- [fn->0-based idx]
                sub rax,3                 ;#0043DBED: 48:203350 03               vu 01 01  1   5      
;  2116         jb :getc0
                jb #0043DD6C              ;#0043DBF1: 017202 75010000            v  00 00  1   6      
;  2117         cmp rax,[fdmax]
                cmp rax,[#004030D8] (fdmax)  ;#0043DBF7: 48:073005 DA54FCFF         uv 00 01  2   7      
;  2118         jb @f
                jb #0043DC1F              ;#0043DBFE: 162 1F                     v  00 00  1   8      
;  2119       ::getce58bfn
;  2120             add rsp,16
                    add rsp,16            ;#0043DC00: 48:203304 10               uv 10 10  1   9      
;  2121       ::getce58bfnNP
;  2122             lea rdi,[rax+3]                     -- ep1:=fn
                    lea rdi,[rax+3]       ;#0043DC04: 48:215170 03               vu 80 01  1   9      
;  2123             mov al,58                           -- e58bfn: "bad file number"
                    mov al,58             ;#0043DC08: 260 3A                     uv 01 00  1  10      
;  2124             pop rdx
                    pop rdx               ;#0043DC0A: 48:132                     vu 04 00  1  10      
;  2125             xor rsi,rsi                         -- ep2 unused
                    xor rsi,rsi           ;#0043DC0C: 48:061366                  uv 40 40  1  11      
;  2126 --          call :%pRTErn                       -- fatal error
;  2127             sub rdx,1
                    sub rdx,1             ;#0043DC0F: 48:203352 01               vu 04 04  1  11      
;  2128             jmp :!iDiag
                    jmp #00442E66 (:!iDiag)  ;#0043DC13: 351 4E520000               v  00 00  1  12      
;  2129       ::retryx
;  2130           mov rdi,[fdtbl]
                  mov rdi,[#004030D0] (fdtbl)  ;#0043DC18: 48:213075 B154FCFF         uv 80 00  1  13      
;  2131       @@:
;  2132         mov rsi,[rdi*4+rcx-24]                  -- rsi:=fdtbl[fn-2]
                mov rsi,[rcx+rdi*4-24]    ;#0043DC1F: 48:213164271 E8            uv 40 82  1  16 80 *80*
;  2133         cmp rdi,[fdtbl]
                cmp rdi,[#004030D0] (fdtbl)  ;#0043DC24: 48:073075 A554FCFF         vu 00 80  2  16      
;  2134         jne :retryx
                jne #0043DC18             ;#0043DC2B: 165 EB                     v  00 00  1  17      
;  2135         shl rsi,2
                shl rsi,2                 ;#0043DC2D: 48:301346 02               u  40 40  1  18      
;  2136         mov rdi,[rsi+MODE64]
                mov rdi,[rsi+8]           ;#0043DC31: 48:213176 08               uv 80 40  1  21 40 *40*
;  2137         mov rax,[rsi+POSN64]
                mov rax,[rsi+16]          ;#0043DC35: 48:213106 10               vu 01 40  1  21      
;  2138         test rdi,F_READ
                test rdi,1                ;#0043DC39: 48:367307 01000000         uv 00 80  1  22      
;  2139         jz :e59wfmfao
                jz #0043DCF0              ;#0043DC40: 017204 AA000000            v  00 00  1  22      
;  2140         mov rcx,rbx                             -- rcx:=0
                mov rcx,rbx               ;#0043DC46: 48:213313                  uv 02 08  1  23      
;  2141       ::looptop
;  2142         cmp rax,[rsi+FEND64]
                cmp rax,[rsi+24]          ;#0043DC49: 48:073106 18               vu 00 41  2  23      
;  2143         jle :notfull                            -- jl @f    [?] [DEV]
                jle #0043DCAC             ;#0043DC4D: 176 5D                     v  00 00  1  24      
;  2144             mov rdi,[rsi+MODE64]
                    mov rdi,[rsi+8]       ;#0043DC4F: 48:213176 08               uv 80 40  1  25      
;  2145             test rdi,F_DIRTY
                    test rdi,8            ;#0043DC53: 48:367307 08000000         uv 00 80  1  26 80   
;  2146             jz @f
                    jz #0043DC65          ;#0043DC5A: 164 09                     v  00 00  1  26      
;  2147                 sub rdi,F_DIRTY
                        sub rdi,8         ;#0043DC5C: 48:203357 08               uv 80 80  1  27      
;  2148                 call :%n_flush_rsirdi           -- (rsi is preserved)
                        call :%n_flush_rsirdi  ;#0043DC60: 350 13FFFFFF               v  00 00  1  27      
;  2149           @@:
;  2150         [PE64]
;  2151             sub rsp,8*5                         -- minimum 4 param shadow space, lpOverlapped, and align(none here)
                    sub rsp,40            ;#0043DC65: 48:203354 28               uv 10 10  1  28      
;  2152             mov [rsp+32],rbx                    -- lpOverlapped (NULL)
                    mov [rsp+32],rbx      ;#0043DC69: 48:211134044 20            uv 00 18  1  31 10 *10*
;  2153             lea r9,[rsi+FEND64]                 -- lpNumberOfBytesRead (fend) [DWORD, but should be fine]
                    lea r9,[rsi+24]       ;#0043DC6E: 4C:215116 18               vu 200 40  1  31      
;  2154             mov r8,BUFFERSIZE64                 -- nNumberOfBytesToRead
                    mov r8,8152           ;#0043DC72: 49:307300 D81F0000         uv 100 00  1  32      
;  2155             lea rdx,[rsi+BUFF64]                -- lpBuffer
                    lea rdx,[rsi+40]      ;#0043DC79: 48:215126 28               vu 04 40  1  32      
;  2156             mov rcx,[rsi+HNDL64]                -- hFile
                    mov rcx,[rsi]         ;#0043DC7D: 48:213016                  uv 02 40  1  33      
;  2157             call "kernel32.dll","ReadFile"
                    call [#00401100] (ReadFile)  ;#0043DC80: 377025 7A34FCFF            np 00 00  2  34      
;  2158             add rsp,8*5
                    add rsp,40            ;#0043DC86: 48:203304 28               uv 10 10  1  36      
;  2159         [ELF64]
;  2160             pop al
;  2161         [64]
;  2162             test rax,rax
                    test rax,rax          ;#0043DC8A: 48:205300                  vu 00 01  1  36      
;  2163             jz :retm1
                    jz #0043DCE7          ;#0043DC8D: 164 58                     v  00 00  1  37      
;  2164             mov rax,[rsi+RPOS64]
                    mov rax,[rsi+32]      ;#0043DC8F: 48:213106 20               uv 01 40  1  38      
;  2165             mov rcx,[rsi+FEND64]
                    mov rcx,[rsi+24]      ;#0043DC93: 48:213116 18               vu 02 40  1  38      
;  2166             cmp rcx,0
                    cmp rcx,0             ;#0043DC97: 48:203371 00               uv 00 02  1  39      
;  2167             je :retm1
                    je #0043DCE7          ;#0043DC9B: 164 4A                     v  00 00  1  39      
;  2168             add rax,rcx -- frealposn += fend
                    add rax,rcx           ;#0043DC9D: 48:001310                  uv 01 03  1  40      
;  2169             mov rcx,rbx -- rcx:=0
                    mov rcx,rbx           ;#0043DCA0: 48:213313                  vu 02 08  1  40      
;  2170             mov [rsi+RPOS64],rax
                    mov [rsi+32],rax      ;#0043DCA3: 48:211106 20               uv 00 41  1  41      
;  2171             mov eax,1
                    mov eax,1             ;#0043DCA7: 270 01000000               vu 01 00  1  41      
;  2172 --          mov [rsi+POSN64],rax
;  2173       ::notfull
;  2174         mov cl,byte[rsi+rax+BUFF64-1]
                mov cl,[rsi+rax+39]       ;#0043DCAC: 212114006 27               uv 02 41  1  44    *01*
;  2175         add rax,1                                           -- fposn+=1
                add rax,1                 ;#0043DCB0: 48:203300 01               vu 01 01  1  44      
;  2176         cmp cl,'\r'
                cmp cl,13                 ;#0043DCB4: 200371 0D                  uv 00 02  1  45      
;  2177         jne @f
                jne #0043DCC0             ;#0043DCB7: 165 07                     v  00 00  1  45      
;  2178         test qword[rsi+MODE64],F_BINARY
                test byte[rsi+8],4        ;#0043DCB9: 48:366106 08 04            u  00 40  2  46      
;  2179         jz :looptop
                jz #0043DC49              ;#0043DCBE: 164 89                     v  00 00  1  47      
;  2180       @@:
;  2181         mov [rsi+POSN64],rax
                mov [rsi+16],rax          ;#0043DCC0: 48:211106 10               uv 00 41  1  48      
;  2182       ::opGetcStoreRcx
;  2183         pop rdi
                pop rdi                   ;#0043DCC4: 48:137                     vu 80 00  1  48      
;  2184         pop rdx
                pop rdx                   ;#0043DCC6: 48:132                     uv 04 00  1  49      
;  2185         mov r15,h4
                mov r15,h4                ;#0043DCC8: 49:277 0000000000000040    vu 8000 00  1  49      
;  2186         cmp rdx,r15
                cmp rdx,r15               ;#0043DCD2: 49:073327                  uv 00 8004  1  50      
;  2187         mov [rdi],rcx
                mov [rdi],rcx             ;#0043DCD5: 48:211017                  vu 00 82  1  50      
;  2188         jle @f
                jle #0043DCE6             ;#0043DCD8: 176 0C                     v  00 00  1  51      
;  2189             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043DCDA: 48:203154223 F0 01         u  00 0C  3  52      
;  2190             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043DCE0: 017204 F4450000            v  00 00  1  54      
;  2191       @@:
;  2192         ret
                ret                       ;#0043DCE6: 303                        np 00 00  2  55      
;  2193 
;  2194   ::retm1
;  2195 ---------
;  2196         mov rcx,-1
                mov rcx,-1                ;#0043DCE7: 48:307301 FFFFFFFF         uv 02 00  1  57      
;  2197         jmp :opGetcStoreRcx
                jmp #0043DCC4             ;#0043DCEE: 353 D4                     v  00 00  1  57      
;  2198     []
;  2199 
;  2200 --/*
;  2201         ch = 255    -- bugfix (without this the compiler assumes ch is -1..-1 (from below), and 
;  2202                     --          hence getc always returns -1; naturally this makes it -1..255.)
;  2203                 ch = -1
;  2204 --*/
;  2205   ::e59wfmfao
;  2206 -------------
;  2207         -- e59wfmfao: "wrong file mode for attempted operation"
;  2208         mov al,59
                mov al,59                 ;#0043DCF0: 260 3B                     uv 01 00  1  58      
;  2209     [32]
;  2210         xor edi,edi                         -- ep1 unused
;  2211         xor esi,esi                         -- ep2 unused
;  2212     [64]
;  2213         xor rdi,rdi                         -- ep1 unused
                xor rdi,rdi               ;#0043DCF2: 48:061377                  vu 80 80  1  58      
;  2214         xor rsi,rsi                         -- ep2 unused
                xor rsi,rsi               ;#0043DCF5: 48:061366                  uv 40 40  1  59      
;  2215     []
;  2216 --DEV
;  2217         call :%pRTErn                       -- fatal error
                call #00442DC8 (:%pRTErn)  ;#0043DCF8: 350 CB500000               v  00 00  1  59      
;  2218 
;  2219 --/*
;  2220 global procedure :%n_initC(:%)
;  2221 end procedure -- (for Edita/CtrlQ)
;  2222 --*/
;  2223   :%n_initC
;  2224 -----------
;  2225     [PE32]
;  2226         push eax    -- save
;  2227         call "kernel32.dll","AllocConsole"
;  2228         push STD_OUTPUT_HANDLE              -- nStdHandle
;  2229         call "kernel32.dll","GetStdHandle"
;  2230         mov [stdout],eax
;  2231         push STD_ERROR_HANDLE               -- nStdHandle
;  2232         call "kernel32.dll","GetStdHandle"
;  2233         mov [stderr],eax
;  2234         push STD_INPUT_HANDLE               -- nStdHandle
;  2235         call "kernel32.dll","GetStdHandle"
;  2236         mov [stdin],eax
;  2237         push ENABLE_PROCESSED_INPUT         -- fdwMode
;  2238         push eax                            -- hConsole
;  2239         call "kernel32.dll","SetConsoleMode"
;  2240         test eax,eax
;  2241         jnz @f
;  2242             mov [stdin_redirected],1
;  2243       @@:
;  2244         pop eax     -- restore
;  2245         ret
;  2246     [ELF32]
;  2247         pop al
;  2248     [PE64]
;  2249         push rax    -- save
                push rax                  ;#0043DCFD: 48:120                     uv 00 01  1  60      
;  2250         sub rsp,8*4
                sub rsp,32                ;#0043DCFF: 48:203354 20               vu 10 10  1  60      
;  2251         call "kernel32.dll","AllocConsole"
                call [#00401028] (AllocConsole)  ;#0043DD03: 377025 1F33FCFF            np 00 00  2  61      
;  2252         mov rcx,STD_OUTPUT_HANDLE           -- nStdHandle
                mov rcx,-11               ;#0043DD09: 48:307301 F5FFFFFF         uv 02 00  1  63      
;  2253         call "kernel32.dll","GetStdHandle"
                call [#004010B8] (GetStdHandle)  ;#0043DD10: 377025 A233FCFF            np 00 00  2  64      
;  2254         mov [stdout],rax
                mov [#004031B0] (stdout),rax  ;#0043DD16: 48:211005 9354FCFF         uv 00 01  1  66      
;  2255         mov rcx,STD_ERROR_HANDLE            -- nStdHandle
                mov rcx,-12               ;#0043DD1D: 48:307301 F4FFFFFF         vu 02 00  1  66      
;  2256         call "kernel32.dll","GetStdHandle"
                call [#004010B8] (GetStdHandle)  ;#0043DD24: 377025 8E33FCFF            np 00 00  2  67      
;  2257         mov [stderr],rax
                mov [#004031B8] (stderr),rax  ;#0043DD2A: 48:211005 8754FCFF         uv 00 01  1  69      
;  2258         mov rcx,STD_INPUT_HANDLE            -- nStdHandle
                mov rcx,-10               ;#0043DD31: 48:307301 F6FFFFFF         vu 02 00  1  69      
;  2259         call "kernel32.dll","GetStdHandle"
                call [#004010B8] (GetStdHandle)  ;#0043DD38: 377025 7A33FCFF            np 00 00  2  70      
;  2260         mov [stdin],rax
                mov [#004031A8] (stdin),rax  ;#0043DD3E: 48:211005 6354FCFF         uv 00 01  1  72      
;  2261         mov rdx,ENABLE_PROCESSED_INPUT      -- fdwMode
                mov rdx,1                 ;#0043DD45: 48:307302 01000000         vu 04 00  1  72      
;  2262         mov rcx,rax                         -- hConsole
                mov rcx,rax               ;#0043DD4C: 48:213310                  uv 02 01  1  73      
;  2263         call "kernel32.dll","SetConsoleMode"
                call [#00401110] (SetConsoleMode)  ;#0043DD4F: 377025 BB33FCFF            np 00 00  2  74      
;  2264         test rax,rax
                test rax,rax              ;#0043DD55: 48:205300                  uv 00 01  1  76      
;  2265         jnz @f
                jnz #0043DD65             ;#0043DD58: 165 0B                     v  00 00  1  76      
;  2266             mov [stdin_redirected],1
                    mov qword[stdin_redirected],1  ;#0043DD5A: 48:307005 6354FCFF 01000000 uv 00 00  1  77      
;  2267       @@:
;  2268         add rsp,8*4
                add rsp,32                ;#0043DD65: 48:203304 20               vu 10 10  1  77      
;  2269         pop rax     -- restore
                pop rax                   ;#0043DD69: 48:130                     uv 01 00  1  78      
;  2270         ret
                ret                       ;#0043DD6B: 303                        np 00 00  2  79      
;  2271     [ELF64]
;  2272         pop al
;  2273     []
;  2274 
;  2275 --/*
;  2276 global procedure ::getc0(::)
;  2277 end procedure -- (for Edita/CtrlQ)
;  2278 --*/
;  2279   ::getc0
;  2280 ---------
;  2281     [32]
;  2282         cmp [stdout],0
;  2283         jne @f
;  2284             call :%n_initC -- (preserves eax)
;  2285       @@:
;  2286         add eax,3 -- (undo sub3 above and test)
;  2287         jnz :e59wfmfao
;  2288 --DEV clear_debug
;  2289 --      #ilASM{ call :%opClrDbg }
;  2290         push ebx            -- reserve space for buffer (1 byte realy)
;  2291         mov esi,esp
;  2292         push ebx            -- reserve space for NumberOfBytesRead
;  2293         mov edi,esp
;  2294     [PE32]
;  2295         push ebx                                        -- lpOverlapped
;  2296         push edi                                        -- lpNumberOfBytesRead
;  2297         push dword 1                                    -- nNumberOfBytesToRead (1)
;  2298         push esi                                        -- lbBuffer
;  2299         push [stdin]                                    -- hFile
;  2300         call "kernel32.dll","ReadFile"
;  2301     [ELF32]
;  2302         pop al
;  2303     [32]
;  2304         pop edx         -- NumberOfBytesRead
;  2305         pop ecx         -- buffer (1 byte)
;  2306         test eax,eax
;  2307         jz :retm1
;  2308         test edx,edx
;  2309         jz :retm1
;  2310 --      mov eax,ecx
;  2311 --/*
;  2312 --DEV still outstanding...::
;  2313 --DEV as per gets....
;  2314 --DEV 0 & 9 loop, 26 -> -1
;  2315 --          if ch!='\r' then exit end if                -- skip cr...
;  2316 --          -- (file 0 is always text mode)
;  2317 --      end while
;  2318 --*/
;  2319         jmp :opGetcStoreEcx
;  2320     [64]
;  2321         cmp [stdout],0
                cmp qword[#004031B0] (stdout),0  ;#0043DD6C: 48:203075 3C54FCFF 00      u  00 00  2  81      
;  2322         jne @f
                jne #0043DD7B             ;#0043DD74: 165 05                     v  00 00  1  82      
;  2323             call :%n_initC -- (preserves rax)
                    call #0043DCFD (:%n_initC)  ;#0043DD76: 350 82FFFFFF               v  00 00  1  83      
;  2324       @@:
;  2325         add rax,3 -- (undo sub3 above and test)
                add rax,3                 ;#0043DD7B: 48:203300 03               uv 01 01  1  84      
;  2326         jnz :e59wfmfao
                jnz #0043DCF0             ;#0043DD7F: 017205 6BFFFFFF            v  00 00  1  84      
;  2327 --DEV clear_debug
;  2328 --      #ilASM{ call :%opClrDbg }
;  2329     [PE64]
;  2330         sub rsp,8*7
                sub rsp,56                ;#0043DD85: 48:203354 38               uv 10 10  1  85      
;  2331         mov [rsp+48],rbx    -- NumberOfBytesRead
                mov [rsp+48],rbx          ;#0043DD89: 48:211134044 30            uv 00 18  1  88 10 *10*
;  2332         mov [rsp+40],rbx    -- buffer (1 byte really)
                mov [rsp+40],rbx          ;#0043DD8E: 48:211134044 28            vu 00 18  1  88      
;  2333         mov [rsp+32],rbx                                -- lpOverlapped (NULL)
                mov [rsp+32],rbx          ;#0043DD93: 48:211134044 20            uv 00 18  1  89      
;  2334         lea r9,[rsp+48]                                 -- lpNumberOfBytesRead
                lea r9,[rsp+48]           ;#0043DD98: 4C:215114044 30            vu 200 10  1  89      
;  2335         mov r8,1                                        -- nNumberOfBytesToRead (1)
                mov r8,1                  ;#0043DD9D: 49:307300 01000000         uv 100 00  1  90      
;  2336         lea rdx,[rsp+40]                                -- lbBuffer
                lea rdx,[rsp+40]          ;#0043DDA4: 48:215124044 28            vu 04 10  1  90      
;  2337         mov rcx,[stdin]                                 -- hFile
                mov rcx,[#004031A8] (stdin)  ;#0043DDA9: 48:213015 F853FCFF         uv 02 00  1  91      
;  2338         call "kernel32.dll","ReadFile"
                call [#00401100] (ReadFile)  ;#0043DDB0: 377025 4A33FCFF            np 00 00  2  92      
;  2339     [ELF64]
;  2340         pop al
;  2341     [64]
;  2342         pop rdx         -- NumberOfBytesRead
                pop rdx                   ;#0043DDB6: 48:132                     uv 04 00  1  94      
;  2343         pop rcx         -- buffer (1 byte)
                pop rcx                   ;#0043DDB8: 48:131                     vu 02 00  1  94      
;  2344         add rsp,8*5
                add rsp,40                ;#0043DDBA: 48:203304 28               uv 10 10  1  95      
;  2345         test rax,rax
                test rax,rax              ;#0043DDBE: 48:205300                  vu 00 01  1  95      
;  2346         jz :retm1
                jz #0043DCE7              ;#0043DDC1: 017204 20FFFFFF            v  00 00  1  96      
;  2347         test rdx,rdx
                test rdx,rdx              ;#0043DDC7: 48:205322                  uv 00 04  1  97      
;  2348         jz :retm1
                jz #0043DCE7              ;#0043DDCA: 017204 17FFFFFF            v  00 00  1  97      
;  2349 --      mov eax,ecx
;  2350 --/*
;  2351 --DEV still outstanding...::
;  2352 --DEV as per gets....
;  2353 --DEV 0 & 9 loop, 26 -> -1
;  2354 --          if ch!='\r' then exit end if                -- skip cr...
;  2355 --          -- (file 0 is always text mode)
;  2356 --      end while
;  2357 --*/
;  2358         jmp :opGetcStoreRcx
                jmp #0043DCC4             ;#0043DDD0: 351 EFFEFFFF               v  00 00  1  98      
;  2359     []
;  2360 
;  2361 --/*
;  2362 global function gets(integer fn, :%opGets)
;  2363 end function
;  2364 --*/
;  2365   :%opGets
;  2366 ----------
;  2367     [32]
;  2368 --DEV proper calling convention...
;  2369         -- fn in eax
;  2370         -- dest in edi
;  2371         push dword[edi]
;  2372         push edi
;  2373         lea ecx,[ebx+eax*4]                     -- ecx:=fn*4 [fn->0-based byte idx+12]
;  2374         mov edi,[fdtbl]
;  2375 --      cmp eax,3 -- NO!
;  2376         sub eax,3 -- [fn->0-based idx, for comparison against fdmax]
;  2377         jb :gets0
;  2378         cmp eax,[fdmax]
;  2379         jae :getce58bfn
;  2380       @@:
;  2381         mov esi,[edi*4+ecx-12]                  -- esi:=fdtbl[fn-2]
;  2382         cmp edi,[fdtbl]
;  2383         je @f
;  2384             mov edi,[fdtbl]
;  2385             jmp @b
;  2386       @@:
;  2387         test dword[ebx+esi*4+MODE],F_READ
;  2388         jz :e59wfmfao
;  2389         shl esi,2
;  2390         push -1                                 -- partial result @ [esp+4]
;  2391         push esi                                -- this @ [esp]
;  2392       ::looptop2
;  2393             mov edi,[esi+POSN]
;  2394           ::looptop7
;  2395             mov edx,[esi+FEND]
;  2396             cmp edi,edx
;  2397             jle :notfull2
;  2398                 mov edi,[esi+MODE]
;  2399                 test edi,F_DIRTY
;  2400                 jz @f
;  2401                     sub edi,F_DIRTY
;  2402                     call :%n_flush_esiedi
;  2403                     mov esi,[esp]
;  2404               @@:
;  2405                 lea edx,[esi+FEND]
;  2406                 lea edi,[esi+BUFF]
;  2407             [PE32]
;  2408                 push ebx                        -- lpOverlapped (NULL)
;  2409                 push edx                        -- lpNumberOfBytesRead (==addr fend)
;  2410                 push BUFFERSIZE32               -- nNumberOfBytesToRead
;  2411                 push edi                        -- lpBuffer
;  2412                 push dword[esi+HNDL]            -- hFile
;  2413                 call "kernel32.dll","ReadFile"
;  2414             [ELF32]
;  2415                 pop al
;  2416             [32]
;  2417                 test eax,eax
;  2418                 jz :exitwhile
;  2419                 mov edx,[esi+FEND]
;  2420                 cmp edx,0
;  2421 --              cmp dword[esi+FEND],0   -- no!!
;  2422                 je :exitwhile
;  2423 --DEV proper way to do 64-bit math:
;  2424 --/*
;  2425 ; x86 assembly, Intel syntax
;  2426 ; adds ebx:edx to ecx:eax
;  2427 add eax, edx
;  2428 adc ecx, ebx
;  2429 --*/
;  2430                 mov eax,[esi+POSL]
;  2431                 mov ecx,[esi+POSH]
;  2432                 add eax,edx -- frealposn += fend
;  2433                 adc ecx,ebx
;  2434                 mov edi,1
;  2435                 mov [esi+POSL],eax
;  2436                 mov [esi+POSH],ecx
;  2437                 mov [esi+POSN],edi
;  2438 --/*
;  2439                 fild qword[esi+POSL]
;  2440                 fild dword[esi+FEND]
;  2441                 mov edi,1
;  2442                 faddp   -- frealposn += fend
;  2443                 mov [esi+POSN],edi
;  2444                 fistp qword[esi+POSL]
;  2445 --*/
;  2446           ::notfull2
;  2447             --
;  2448             -- reminder:
;  2449             --  esi is this (=[esp], becomes [esp+4] rsn)
;  2450             --  edx is FEND
;  2451             --  edi is POSN
;  2452             --  partial result in [esp+4], becomes [esp+8] rsn (may still be -1)
;  2453             --
;  2454             lea esi,[esi+edi+BUFF-1]
;  2455             mov ecx,ebx -- ecx:=0 (bytes to copy)
;  2456             push esi
;  2457             sub edx,edi -- <bytes left - 1>
;  2458           @@:
;  2459             lodsb   -- al:=[esi++]
;  2460             cmp al,26
;  2461             jb :checkterm
;  2462           ::nextch
;  2463             add ecx,1
;  2464             cmp ecx,edx
;  2465             jle @b
;  2466             -- (at this point (ie fallthrough/end of buffer) ecx!=0 and al!='\n')
;  2467           ::copybytes
;  2468             --
;  2469             -- reminder:
;  2470             --  if al=='\n' then exit (after copy) else unused/goto looptop2
;  2471             --  ecx is bytes to copy (shd not be 0 here)
;  2472             --  [esp] is buffer[fposn] from when we started scanning
;  2473             --  [esp+4] is this (ie fdtbl[fn-2]*4)
;  2474             --  [esp+8] is partial result or -1
;  2475             --  edi is POSN
;  2476             --
;  2477             mov edx,[esp+4] -- iThis
;  2478             add edi,ecx
;  2479             mov [edx+POSN],edi
;  2480             push eax    -- save ch
;  2481             -- not ecx,ebx,
;  2482             mov edi,[esp+12]    -- partial result
;  2483             cmp edi,-1
;  2484             je :nopartialyet
;  2485                 push ecx
;  2486                 mov edx,[ebx+edi*4-12]  -- length(partial)
;  2487                 mov esi,[ebx+edi*4-16]  -- maxlen(partial)
;  2488                 sub esi,16              -- less headers
;  2489                 sub esi,edx             -- less already used
;  2490                 cmp esi,ecx             -- does it fit?
;  2491                 jle @f
;  2492                     add ecx,edx
;  2493                     mov [ebx+edi*4-12],ecx -- set new length
;  2494                     lea edi,[edx+edi*4]
;  2495                     pop ecx
;  2496                     jmp :copyinsitu
;  2497               @@:
;  2498                 lea esi,[ebx+edi*4]     -- partial[1], for rep movsd
;  2499                 add ecx,edx
;  2500                 call :%pAllocStr    -- damages eax only [?]
;  2501                 lea edi,[ebx+eax*4]
;  2502                 mov ecx,edx
;  2503                 rep movsb
;  2504                 mov edx,[esp+16]    -- partial (for deallocate)
;  2505                 push edi
;  2506                 push eax
;  2507                 push dword[esp+36]
;  2508                 call :%pDealloc0
;  2509                 pop eax
;  2510                 pop edi
;  2511                 pop ecx
;  2512                 jmp :copyremainder
;  2513           ::nopartialyet
;  2514 --              mov edx,ecx
;  2515                 call :%pAllocStr    -- damages eax only
;  2516                 lea edi,[ebx+eax*4]
;  2517           ::copyremainder
;  2518             mov [esp+12],eax    -- save new partial
;  2519           ::copyinsitu
;  2520             pop eax
;  2521             pop esi
;  2522             rep movsb
;  2523             mov byte[edi],0
;  2524             cmp al,'\n'
;  2525             je :exitwhile
;  2526             mov esi,[esp]
;  2527             jmp :looptop2
;  2528 
;  2529           ::checkterm
;  2530             jne :getsnotcz
;  2531             -- (al is 26 (Ctrl Z) here)
;  2532             mov al,'\n'
;  2533             add edi,1
;  2534             test ecx,ecx
;  2535             jnz :copybytes
;  2536             mov edx,[esp+4] -- iThis
;  2537             mov [edx+POSN],edi
;  2538             jmp :exitwhile
;  2539 
;  2540           ::getsnotcz
;  2541             cmp al,'\r'
;  2542             jne :notcr5
;  2543                 -- (not ecx, edx, ebx, esi, edi: -> must use eax)
;  2544                 mov eax,[esp+4] -- iThis
;  2545                 test byte[eax+MODE],F_BINARY
;  2546                 jnz :nextch
;  2547                 test ecx,ecx
;  2548                 jnz @f
;  2549                     mov esi,eax
;  2550                     add esp,4 -- discard that saved buffer[posn]
;  2551                     add edi,1
;  2552                     jmp :looptop7
;  2553               @@:
;  2554                 mov al,'\r'
;  2555                 add edi,1
;  2556                 jmp :copybytes
;  2557           ::notcr5
;  2558             cmp al,'\n'
;  2559             jne :nextch
;  2560             add ecx,1
;  2561             jmp :copybytes
;  2562       ::exitwhile
;  2563         add esp,4
;  2564         pop eax
;  2565       ::opGetsStoreEax
;  2566         pop edi
;  2567         pop edx
;  2568         cmp edx,h4
;  2569         mov [edi],eax
;  2570         jle @f
;  2571             sub dword[ebx+edx*4-8],1
;  2572             je :%pDealloc
;  2573       @@:
;  2574         ret
;  2575     [64]
;  2576 --DEV calling convention:
;  2577         -- fn in rax
;  2578         -- dest in rdi
;  2579         push qword[rdi]
                push qword[rdi]           ;#0043DDD5: 48:377067                  np 00 80  2  99      
;  2580         push rdi
                push rdi                  ;#0043DDD8: 48:127                     uv 00 80  1 101      
;  2581         lea rcx,[rbx+rax*8]                     -- rcx:=fn*8 [fn->0-based byte idx+24]
                lea rcx,[rbx+rax*8]       ;#0043DDDA: 48:215014303               vu 02 09  1 101      
;  2582         mov rdi,[fdtbl]
                mov rdi,[#004030D0] (fdtbl)  ;#0043DDDE: 48:213075 EB52FCFF         uv 80 00  1 102      
;  2583 --      cmp rax,3 -- NO!
;  2584         sub rax,3 -- [fn->0-based idx, for comparison against fdmax]
                sub rax,3                 ;#0043DDE5: 48:203350 03               vu 01 01  1 102      
;  2585         jb :gets0
                jb #0043DFDD              ;#0043DDE9: 017202 EE010000            v  00 00  1 103      
;  2586         cmp rax,[fdmax]
                cmp rax,[#004030D8] (fdmax)  ;#0043DDEF: 48:073005 E252FCFF         uv 00 01  2 104      
;  2587         jae :getce58bfn
                jae #0043DC00             ;#0043DDF6: 017203 04FEFFFF            v  00 00  1 105      
;  2588       @@:
;  2589         mov rsi,[rdi*4+rcx-24]                  -- rsi:=fdtbl[fn-2]
                mov rsi,[rcx+rdi*4-24]    ;#0043DDFC: 48:213164271 E8            uv 40 82  1 106      
;  2590         cmp rdi,[fdtbl]
                cmp rdi,[#004030D0] (fdtbl)  ;#0043DE01: 48:073075 C852FCFF         vu 00 80  2 106      
;  2591         je @f
                je #0043DE13              ;#0043DE08: 164 09                     v  00 00  1 107      
;  2592             mov rdi,[fdtbl]
                    mov rdi,[#004030D0] (fdtbl)  ;#0043DE0A: 48:213075 BF52FCFF         uv 80 00  1 108      
;  2593             jmp @b
                    jmp #0043DDFC         ;#0043DE11: 353 E9                     v  00 00  1 108      
;  2594       @@:
;  2595         test qword[rbx+rsi*4+MODE64],F_READ
                test byte[rbx+rsi*4+8],1  ;#0043DE13: 48:366104263 08 01         u  00 48  2 109      
;  2596         jz :e59wfmfao
                jz #0043DCF0              ;#0043DE19: 017204 D1FEFFFF            v  00 00  1 110      
;  2597         shl rsi,2
                shl rsi,2                 ;#0043DE1F: 48:301346 02               u  40 40  1 111      
;  2598         push -1                                 -- partial result @ [rsp+8]
                push -1                   ;#0043DE23: 152 FF                     vu 00 00  1 111      
;  2599         push rsi                                -- this @ [rsp]
                push rsi                  ;#0043DE25: 48:126                     uv 00 40  1 112      
;  2600       ::looptop2
;  2601             mov rdi,[rsi+POSN64]
                    mov rdi,[rsi+16]      ;#0043DE27: 48:213176 10               uv 80 40  1 114    *40*
;  2602           ::looptop7
;  2603             mov rdx,[rsi+FEND64]
                    mov rdx,[rsi+24]      ;#0043DE2B: 48:213126 18               vu 04 40  1 114      
;  2604             cmp rdi,rdx
                    cmp rdi,rdx           ;#0043DE2F: 48:071327                  uv 00 84  1 115      
;  2605             jle :notfull2
                    jle #0043DE9B         ;#0043DE32: 176 67                     v  00 00  1 115      
;  2606                 mov rdi,[rsi+MODE64]
                        mov rdi,[rsi+8]   ;#0043DE34: 48:213176 08               uv 80 40  1 116      
;  2607                 test rdi,F_DIRTY
                        test rdi,8        ;#0043DE38: 48:367307 08000000         uv 00 80  1 117 80   
;  2608                 jz @f
                        jz #0043DE4A      ;#0043DE3F: 164 09                     v  00 00  1 117      
;  2609                     sub rdi,F_DIRTY
                            sub rdi,8     ;#0043DE41: 48:203357 08               uv 80 80  1 118      
;  2610                     call :%n_flush_rsirdi       -- (preserves rsi)
                            call :%n_flush_rsirdi  ;#0043DE45: 350 2EFDFFFF               v  00 00  1 118      
;  2611               @@:
;  2612             [PE64]
;  2613                 sub rsp,8*5                     -- minimum 4 param shadow space, lpOverlapped, and align(none here)
                        sub rsp,40        ;#0043DE4A: 48:203354 28               uv 10 10  1 119      
;  2614                 mov [rsp+32],rbx                -- lpOverlapped (NULL)
                        mov [rsp+32],rbx  ;#0043DE4E: 48:211134044 20            uv 00 18  1 122 10 *10*
;  2615                 lea r9,[rsi+FEND64]             -- lpNumberOfBytesRead (fend) [DWORD, but should be fine]
                        lea r9,[rsi+24]   ;#0043DE53: 4C:215116 18               vu 200 40  1 122      
;  2616                 mov r8,BUFFERSIZE64             -- nNumberOfBytesToRead
                        mov r8,8152       ;#0043DE57: 49:307300 D81F0000         uv 100 00  1 123      
;  2617                 lea rdx,[rsi+BUFF64]            -- lpBuffer
                        lea rdx,[rsi+40]  ;#0043DE5E: 48:215126 28               vu 04 40  1 123      
;  2618                 mov rcx,[rsi+HNDL64]            -- hFile
                        mov rcx,[rsi]     ;#0043DE62: 48:213016                  uv 02 40  1 124      
;  2619                 call "kernel32.dll","ReadFile"
                        call [#00401100] (ReadFile)  ;#0043DE65: 377025 9532FCFF            np 00 00  2 125      
;  2620                 add rsp,8*5
                        add rsp,40        ;#0043DE6B: 48:203304 28               uv 10 10  1 127      
;  2621             [ELF64]
;  2622                 pop al
;  2623             [64]
;  2624                 test eax,eax
                        test rax,eax      ;#0043DE6F: 205300                     vu 00 01  1 127      
;  2625                 jz :exitwhile
                        jz #0043DFB4      ;#0043DE71: 017204 3D010000            v  00 00  1 128      
;  2626                 mov rdx,[rsi+FEND64]
                        mov rdx,[rsi+24]  ;#0043DE77: 48:213126 18               uv 04 40  1 129      
;  2627                 cmp rdx,0
                        cmp rdx,0         ;#0043DE7B: 48:203372 00               uv 00 04  1 130 04   
;  2628                 je :exitwhile
                        je #0043DFB4      ;#0043DE7F: 017204 2F010000            v  00 00  1 130      
;  2629                 mov rax,[rsi+RPOS64]
                        mov rax,[rsi+32]  ;#0043DE85: 48:213106 20               uv 01 40  1 131      
;  2630                 add rax,rdx -- frealposn += fend
                        add rax,rdx       ;#0043DE89: 48:001320                  uv 01 05  1 132 01   
;  2631                 mov rdi,1
                        mov rdi,1         ;#0043DE8C: 48:307307 01000000         vu 80 00  1 132      
;  2632                 mov [rsi+RPOS64],rax
                        mov [rsi+32],rax  ;#0043DE93: 48:211106 20               uv 00 41  1 133      
;  2633                 mov [rsi+POSN64],rdi
                        mov [rsi+16],rdi  ;#0043DE97: 48:211176 10               vu 00 C0  1 133      
;  2634           ::notfull2
;  2635             --
;  2636             -- reminder:
;  2637             --  rsi is this (=[rsp], becomes [rsp+8] rsn)
;  2638             --  rdx is FEND
;  2639             --  rdi is POSN
;  2640             --  partial result in [rsp+8], becomes [rsp+16] rsn (may still be -1)
;  2641             --
;  2642             lea rsi,[rsi+rdi+BUFF64-1]
                    lea rsi,[rsi+rdi+39]  ;#0043DE9B: 48:215164076 27            uv 40 C0  1 134      
;  2643             mov rcx,rbx -- ecx:=0 (bytes to copy)
                    mov rcx,rbx           ;#0043DEA0: 48:213313                  vu 02 08  1 134      
;  2644             push rsi
                    push rsi              ;#0043DEA3: 48:126                     uv 00 40  1 135      
;  2645             sub rdx,rdi -- <bytes left - 1>
                    sub rdx,rdi           ;#0043DEA5: 48:051372                  vu 04 84  1 135      
;  2646           @@:
;  2647             lodsb   -- al:=[rsi++]
                    lodsb                 ;#0043DEA8: 254                        np 41 40  2 136      
;  2648             cmp al,26
                    cmp al,26             ;#0043DEA9: 200370 1A                  uv 00 01  1 138      
;  2649             jb :checkterm
                    jb #0043DF51          ;#0043DEAC: 017202 9F000000            v  00 00  1 138      
;  2650           ::nextch
;  2651             add rcx,1
                    add rcx,1             ;#0043DEB2: 48:203301 01               uv 02 02  1 139      
;  2652             cmp rcx,rdx
                    cmp rcx,rdx           ;#0043DEB6: 48:071321                  uv 00 06  1 140 02   
;  2653             jle @b
                    jle #0043DEA8         ;#0043DEB9: 176 ED                     v  00 00  1 140      
;  2654             -- (at this point (ie fallthrough/end of buffer) rcx!=0 and al!='\n')
;  2655           ::copybytes
;  2656             --
;  2657             -- reminder:
;  2658             --  if al=='\n' then exit (after copy) else unused/goto looptop2
;  2659             --  rcx is bytes to copy (shd not be 0 here)
;  2660             --  [rsp] is buffer[fposn] from when we started scanning
;  2661             --  [rsp+8] is iThis (ie fdtbl[fn-2]) shl 2
;  2662             --  [rsp+16] is partial result or -1
;  2663             --  rdi is POSN
;  2664             --
;  2665             mov rdx,[rsp+8] -- iThis shl 2
                    mov rdx,[rsp+8]       ;#0043DEBB: 48:213124044 08            uv 04 10  1 141      
;  2666             add rdi,rcx
                    add rdi,rcx           ;#0043DEC0: 48:001317                  vu 80 82  1 141      
;  2667             mov [rdx+POSN64],rdi
                    mov [rdx+16],rdi      ;#0043DEC3: 48:211172 10               uv 00 84  1 144    *04*
;  2668             push rax    -- save ch
                    push rax              ;#0043DEC7: 48:120                     vu 00 01  1 144      
;  2669             -- not rcx,ebx,
;  2670             mov rdi,[rsp+24]    -- partial result
                    mov rdi,[rsp+24]      ;#0043DEC9: 48:213174044 18            uv 80 10  1 145      
;  2671             cmp rdi,-1
                    cmp rdi,-1            ;#0043DECE: 48:203377 FF               uv 00 80  1 146 80   
;  2672             je :nopartialyet
                    je #0043DF2C          ;#0043DED2: 164 58                     v  00 00  1 146      
;  2673                 push rcx
                        push rcx          ;#0043DED4: 48:121                     uv 00 02  1 147      
;  2674                 mov rdx,[rbx+rdi*4-24]  -- length(partial)
                        mov rdx,[rbx+rdi*4-24]  ;#0043DED6: 48:213124273 E8            vu 04 88  1 147      
;  2675                 mov rsi,[rbx+rdi*4-32]  -- maxlen(partial)
                        mov rsi,[rbx+rdi*4-32]  ;#0043DEDB: 48:213164273 E0            uv 40 88  1 148      
;  2676                 sub rsi,32              -- less headers
                        sub rsi,32        ;#0043DEE0: 48:203356 20               uv 40 40  1 149 40   
;  2677                 sub rsi,rdx             -- less already used
                        sub rsi,rdx       ;#0043DEE4: 48:051326                  uv 40 44  1 150 40   
;  2678                 cmp rsi,rcx             -- does it fit?
                        cmp rsi,rcx       ;#0043DEE7: 48:071316                  uv 00 42  1 151 40   
;  2679                 jle @f
                        jle #0043DEFC     ;#0043DEEA: 176 10                     v  00 00  1 151      
;  2680                     add rcx,rdx
                            add rcx,rdx   ;#0043DEEC: 48:001321                  uv 02 06  1 152      
;  2681                     mov [rbx+rdi*4-24],rcx -- set new length
                            mov [rbx+rdi*4-24],rcx  ;#0043DEEF: 48:211114273 E8            uv 00 8A  1 153 02   
;  2682                     lea rdi,[rdx+rdi*4]
                            lea rdi,[rdx+rdi*4]  ;#0043DEF4: 48:215074272               vu 80 84  1 153      
;  2683                     pop rcx
                            pop rcx       ;#0043DEF8: 48:131                     uv 02 00  1 154      
;  2684                     jmp :copyinsitu
                            jmp #0043DF3A  ;#0043DEFA: 353 3E                     v  00 00  1 154      
;  2685               @@:
;  2686                 lea rsi,[rbx+rdi*4]     -- partial[1], for rep movsd
                        lea rsi,[rbx+rdi*4]  ;#0043DEFC: 48:215064273               uv 40 88  1 155      
;  2687                 add rcx,rdx
                        add rcx,rdx       ;#0043DF00: 48:001321                  vu 02 06  1 155      
;  2688                 call :%pAllocStr    -- damages eax only
                        call #004420E3 (:%pAllocStr)  ;#0043DF03: 350 DB410000               v  00 00  1 156      
;  2689                 lea rdi,[rbx+rax*4]
                        lea rdi,[rbx+rax*4]  ;#0043DF08: 48:215074203               uv 80 09  1 157      
;  2690                 mov rcx,rdx
                        mov rcx,rdx       ;#0043DF0C: 48:213312                  vu 02 04  1 157      
;  2691                 rep movsb
                        rep movsb         ;#0043DF0F: 363:244                    np C2 C2  4 160    *80*
;  2692                 mov rdx,[rsp+32]    -- partial (for deallocate)
                        mov rdx,[rsp+32]  ;#0043DF11: 48:213124044 20            uv 04 10  1 164      
;  2693                 push rdi
                        push rdi          ;#0043DF16: 48:127                     vu 00 80  1 164      
;  2694                 push rax
                        push rax          ;#0043DF18: 48:120                     uv 00 01  1 165      
;  2695                 push qword[rsp+9*8]
                        push qword[rsp+72]  ;#0043DF1A: 48:377164044 48            np 00 10  2 166      
;  2696                 call :%pDealloc0
                        call #004422DE (:%pDealloc0)  ;#0043DF1F: 350 BA430000               v  00 00  1 168      
;  2697                 pop rax
                        pop rax           ;#0043DF24: 48:130                     uv 01 00  1 169      
;  2698                 pop rdi
                        pop rdi           ;#0043DF26: 48:137                     vu 80 00  1 169      
;  2699                 pop rcx
                        pop rcx           ;#0043DF28: 48:131                     uv 02 00  1 170      
;  2700                 jmp :copyremainder
                        jmp #0043DF35     ;#0043DF2A: 353 09                     v  00 00  1 170      
;  2701           ::nopartialyet
;  2702 --              mov rdx,rcx
;  2703                 call :%pAllocStr    -- damages eax only [?]
                        call #004420E3 (:%pAllocStr)  ;#0043DF2C: 350 B2410000               v  00 00  1 171      
;  2704                 lea rdi,[rbx+rax*4]
                        lea rdi,[rbx+rax*4]  ;#0043DF31: 48:215074203               uv 80 09  1 172      
;  2705           ::copyremainder
;  2706             mov [rsp+24],rax    -- save new partial
                    mov [rsp+24],rax      ;#0043DF35: 48:211104044 18            vu 00 11  1 172      
;  2707           ::copyinsitu
;  2708             pop rax
                    pop rax               ;#0043DF3A: 48:130                     uv 01 00  1 173      
;  2709             pop rsi
                    pop rsi               ;#0043DF3C: 48:136                     vu 40 00  1 173      
;  2710             rep movsb
                    rep movsb             ;#0043DF3E: 363:244                    np C2 C2  4 176    *40*
;  2711             mov byte[rdi],0
                    mov [rdi], byte 0     ;#0043DF40: 306007 00                  uv 00 80  1 181    *80*
;  2712             cmp al,'\n'
                    cmp al,10             ;#0043DF43: 200370 0A                  vu 00 01  1 181      
;  2713             je :exitwhile
                    je #0043DFB4          ;#0043DF46: 164 6C                     v  00 00  1 182      
;  2714             mov rsi,[rsp]
                    mov rsi,[rsp]         ;#0043DF48: 48:213064044               uv 40 10  1 183      
;  2715             jmp :looptop2
                    jmp #0043DE27         ;#0043DF4C: 351 D6FEFFFF               v  00 00  1 183      
;  2716 
;  2717           ::checkterm
;  2718             jne :getsnotcz
                    jne #0043DF6D         ;#0043DF51: 165 1A                     v  00 00  1 184      
;  2719             -- (al is 26 (Ctrl Z) here)
;  2720             mov al,'\n'
                    mov al,10             ;#0043DF53: 260 0A                     uv 01 00  1 185      
;  2721             add rdi,1
                    add rdi,1             ;#0043DF55: 48:203307 01               vu 80 80  1 185      
;  2722             test rcx,rcx
                    test rcx,rcx          ;#0043DF59: 48:205311                  uv 00 02  1 186      
;  2723             jnz :copybytes
                    jnz #0043DEBB         ;#0043DF5C: 017205 59FFFFFF            v  00 00  1 186      
;  2724             mov rdx,[rsp+8] -- iThis
                    mov rdx,[rsp+8]       ;#0043DF62: 48:213124044 08            uv 04 10  1 187      
;  2725             mov [rdx+POSN64],rdi
                    mov [rdx+16],rdi      ;#0043DF67: 48:211172 10               uv 00 84  1 190 04 *04*
;  2726             jmp :exitwhile
                    jmp #0043DFB4         ;#0043DF6B: 353 47                     v  00 00  1 190      
;  2727 
;  2728           ::getsnotcz
;  2729             cmp al,'\r'
                    cmp al,13             ;#0043DF6D: 200370 0D                  uv 00 01  1 191      
;  2730             jne :notcr5
                    jne #0043DFA2         ;#0043DF70: 165 30                     v  00 00  1 191      
;  2731                 -- (not ecx, edx, ebx, esi, edi: -> must use eax)
;  2732                 mov rax,[rsp+8] -- iThis
                        mov rax,[rsp+8]   ;#0043DF72: 48:213104044 08            uv 01 10  1 192      
;  2733                 test qword[rax+MODE64],F_BINARY
                        test byte[rax+8],4  ;#0043DF77: 48:366100 08 04            u  00 01  2 195    *01*
;  2734                 jnz :nextch
                        jnz #0043DEB2     ;#0043DF7C: 017205 30FFFFFF            v  00 00  1 196      
;  2735                 test rcx,rcx
                        test rcx,rcx      ;#0043DF82: 48:205311                  uv 00 02  1 197      
;  2736                 jnz @f
                        jnz #0043DF97     ;#0043DF85: 165 10                     v  00 00  1 197      
;  2737                     mov rsi,rax
                            mov rsi,rax   ;#0043DF87: 48:213360                  uv 40 01  1 198      
;  2738                     add rsp,8 -- discard that saved buffer[posn]
                            add rsp,8     ;#0043DF8A: 48:203304 08               vu 10 10  1 198      
;  2739                     add rdi,1
                            add rdi,1     ;#0043DF8E: 48:203307 01               uv 80 80  1 199      
;  2740                     jmp :looptop7
                            jmp #0043DE2B  ;#0043DF92: 351 94FEFFFF               v  00 00  1 199      
;  2741               @@:
;  2742                 mov al,'\r'
                        mov al,13         ;#0043DF97: 260 0D                     uv 01 00  1 200      
;  2743                 add rdi,1
                        add rdi,1         ;#0043DF99: 48:203307 01               vu 80 80  1 200      
;  2744                 jmp :copybytes
                        jmp #0043DEBB     ;#0043DF9D: 351 19FFFFFF               v  00 00  1 201      
;  2745           ::notcr5
;  2746             cmp al,'\n'
                    cmp al,10             ;#0043DFA2: 200370 0A                  uv 00 01  1 202      
;  2747             jne :nextch
                    jne #0043DEB2         ;#0043DFA5: 017205 07FFFFFF            v  00 00  1 202      
;  2748             add rcx,1
                    add rcx,1             ;#0043DFAB: 48:203301 01               uv 02 02  1 203      
;  2749             jmp :copybytes
                    jmp #0043DEBB         ;#0043DFAF: 351 07FFFFFF               v  00 00  1 203      
;  2750       ::exitwhile
;  2751         add rsp,8
                add rsp,8                 ;#0043DFB4: 48:203304 08               uv 10 10  1 204      
;  2752         pop rax
                pop rax                   ;#0043DFB8: 48:130                     vu 01 00  1 204      
;  2753       ::opGetsStoreRax
;  2754         pop rdi
                pop rdi                   ;#0043DFBA: 48:137                     uv 80 00  1 205      
;  2755         pop rdx
                pop rdx                   ;#0043DFBC: 48:132                     vu 04 00  1 205      
;  2756         mov r15,h4
                mov r15,h4                ;#0043DFBE: 49:277 0000000000000040    uv 8000 00  1 206      
;  2757         cmp rdx,r15
                cmp rdx,r15               ;#0043DFC8: 49:073327                  uv 00 8004  1 207 8000   
;  2758         mov [rdi],rax
                mov [rdi],rax             ;#0043DFCB: 48:211007                  vu 00 81  1 207      
;  2759         jle @f
                jle #0043DFDC             ;#0043DFCE: 176 0C                     v  00 00  1 208      
;  2760             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043DFD0: 48:203154223 F0 01         u  00 0C  3 209      
;  2761             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043DFD6: 017204 FE420000            v  00 00  1 211      
;  2762       @@:
;  2763         ret
                ret                       ;#0043DFDC: 303                        np 00 00  2 212      
;  2764     []
;  2765 
;  2766 --/*
;  2767         ch = 255    -- bugfix (without this the compiler assumes ch is -1..-1 (from below), and 
;  2768                     --          hence getc always returns -1; naturally this makes it -1..255.)
;  2769                 ch = -1
;  2770 --*/
;  2771 --/*
;  2772 global procedure ::gets0(::)
;  2773 end procedure -- (for Edita/CtrlQ)
;  2774 --*/
;  2775   ::gets0           -- fn (eax)<3
;  2776 ---------
;  2777     [32]
;  2778         -- [esp]    edi
;  2779         -- [esp+4]  prev [edi]
;  2780         -- [esp+8]  <return address>
;  2781         add eax,3 -- (undo sub3 above and test) [fn]
;  2782         jnz :e59wfmfao      -- only gets(0) valid
;  2783         cmp [stdout],0
;  2784         jne @f
;  2785             call :%n_initC -- (preserves eax, not that we need it anymore)
;  2786       @@:
;  2787 --      #ilASM{ call :%opClrDbg }
;  2788 --      r = ""
;  2789         xor ecx,ecx -- length
;  2790         call :%pAllocStr        -- damages eax only
;  2791         push eax
;  2792 --/*
;  2793         mov eax,[esp]
;  2794         mov ecx,[ebx+eax*4-12]      -- length
;  2795         mov edi,[ebx+eax*4-16]      -- maxlen
;  2796 --      mov [esp+4],ecx
;  2797         sub edi,16
;  2798 --      mov [esp+8],edi
;  2799 --*/
;  2800 --/*
;  2801 --      to add ch (in cl [maybe with ch=0]):
;  2802         mov eax,[esp]
;  2803         mov edx,[ebx+eax*4-12]      -- length
;  2804         mov edi,[ebx+eax*4-16]      -- maxlen
;  2805         add edx, 1
;  2806         sub edi,16
;  2807         cmp edx,edi                 -- cmp length,maxlen
;  2808         jl @f
;  2809 --          push whatever we need to save
;  2810             push ecx                -- save
;  2811             push edx                -- save
;  2812             call :%pAllocStr        -- damages eax only
;  2813             lea esi,[ebx+?*4]
;  2814             lea edi,[ebx+eax*4]
;  2815             mov ecx,edx
;  2816             rep movsb
;  2817 --          swap refs
;  2818             pop edx
;  2819             push eax
;  2820             call %pDealloc
;  2821 --          pop whatever we need to restore
;  2822             pop edx                 -- restore
;  2823             pop ecx                 -- restore
;  2824             mov eax,[esp]
;  2825       @@:
;  2826         mov word[edx+eax*4],cx  -- (or leave planting the final \0 to the end)
;  2827 --*/
;  2828       ::looptop3
;  2829 --      while 1 do
;  2830             push ebx        -- reserve space for buffer (1 byte realy)
;  2831             mov edi,esp
;  2832             push ebx        -- reserve space for NumberOfBytesRead
;  2833             mov edx,esp
;  2834         [PE32]
;  2835             push ebx                        -- lpOverlapped (NULL)
;  2836             push edx                        -- lpNumberOfBytesRead
;  2837             push 1                          -- nNumberOfBytesToRead (1)
;  2838             push edi                        -- lbBuffer
;  2839             push [stdin]                    -- hFile
;  2840             call "kernel32.dll","ReadFile"
;  2841         [ELF32]
;  2842             pop al
;  2843         [32]
;  2844             pop edx         -- NumberOfBytesRead
;  2845             pop ecx         -- buffer
;  2846             test eax,eax    -- (0 = fail)
;  2847 --          setz dl
;  2848             jz :set26
;  2849             test edx,edx
;  2850             jnz @f
;  2851           ::set26
;  2852                 mov cl,26 -- (Ctrl Z)
;  2853           @@:
;  2854 --          mov [ch],ecx
;  2855 --DEV what if ch='\n'? (test with various redirected files)
;  2856 --          if ch='\r' then         -- CR
;  2857             cmp cl,'\r'
;  2858             jne :notcr
;  2859                 cmp [stdin_redirected],0
;  2860                 je :addlf
;  2861 --              push ecx        -- save
;  2862                 push ebx        --[1] reserve space for buffer (1 byte realy)
;  2863                 mov edi,esp
;  2864                 push ebx                        -- lpOverlapped (NULL)
;  2865                 push esp                        -- lpNumberOfBytesRead
;  2866                 push 1                          -- nNumberOfBytesToRead (1)
;  2867                 push edi                        -- lbBuffer
;  2868                 push [stdin]                    -- hFile
;  2869                 call  "kernel32.dll","ReadFile"
;  2870                 pop eax         --[1] discard
;  2871 --              pop ecx         -- restore
;  2872 --            @@:
;  2873                 jmp :addlf
;  2874           ::notcr
;  2875 --          elsif ch=26 then        -- Ctrl Z
;  2876             cmp cl,26   -- CtrlZ
;  2877             jne :notcz
;  2878 --              if length(r)=0 then
;  2879 --                  return -1
;  2880 --              else
;  2881 --                  return r
;  2882 --              end if
;  2883                 pop eax                             -- newly allocated string
;  2884                 mov edx,[ebx+eax*4-12]              -- length("")
;  2885                 test edx,edx
;  2886                 jnz :opGetsStoreEax
;  2887                 mov edx,eax
;  2888                 push dword[esp+8]
;  2889                 call :%pDealloc0                    -- discard
;  2890                 mov eax,-1                          -- return -1
;  2891                 jmp :opGetsStoreEax
;  2892           ::notcz
;  2893 --          elsif ch=8 then         -- backspace
;  2894             cmp cl,8    -- backspace
;  2895             jne :notbs
;  2896 --              if length(r) then
;  2897                 mov eax,[esp]                       -- newly allocated string
;  2898                 mov edx,[ebx+eax*4-12]              -- length("")
;  2899                 sub edx,1
;  2900                 jl :looptop3                        -- already empty
;  2901 --              r = r[1..-2]
;  2902                 mov [ebx+eax*4-12],edx              -- length -= 1
;  2903                 mov [edx+eax*4],bl                  -- plant new terminator
;  2904 --                  if not stdin_redirected then
;  2905                 cmp [stdin_redirected],0
;  2906                 jne :looptop3
;  2907                 push 0x21082008 -- back,space,back (buffer) [with a '!' (#21) that should not be seen/used]
;  2908                 mov esi,esp
;  2909             [PE32]
;  2910                 push ebx                            -- lpvReserved (NULL)
;  2911                 push esp                            -- lpcchWritten
;  2912                 push dword 3                        -- cchToWrite (3)
;  2913                 push esi                            -- lpvBuffer
;  2914                 push [stdout]                       -- hConsoleOutput
;  2915                 call "kernel32.dll","WriteConsoleA"
;  2916             [ELF32]
;  2917                 pop al
;  2918             [32]
;  2919                 pop eax         -- (discard buffer [0x21082008])
;  2920 --                  end if
;  2921 --              end if
;  2922                 jmp :looptop3
;  2923           ::notbs
;  2924 --          else
;  2925 --              r &= ch
;  2926                 mov eax,[esp]                       -- newly allocated string
;  2927                 mov edx,[ebx+eax*4-12]              -- length
;  2928                 mov edi,[ebx+eax*4-16]              -- maxlen
;  2929                 add edx, 1
;  2930                 sub edi,16
;  2931                 cmp edx,edi                         -- cmp length,maxlen
;  2932                 jl @f
;  2933                     lea esi,[ebx+eax*4]
;  2934 --                  push whatever we need to save
;  2935                     push ecx                        -- save (char)
;  2936                     push edx                        -- save (new length)
;  2937 --                  push eax                        -- save for deallocation
;  2938                     mov ecx,edx
;  2939                     call :%pAllocStr                -- damages eax only
;  2940                     lea edi,[ebx+eax*4]
;  2941                     rep movsb
;  2942 --                  swap refs
;  2943 --                  pop edx
;  2944 --                  push eax
;  2945                     mov edx,[esp+8]                 -- prev allocated string
;  2946                     mov [esp+8],eax                 -- update with replacement
;  2947                     push dword[esp+5*4]             -- era
;  2948                     call :%pDealloc0
;  2949                     pop edx                         -- restore (new length)
;  2950                     pop ecx                         -- restore (char)
;  2951                     mov eax,[esp]
;  2952               @@:
;  2953                 mov word[edx+eax*4-1],cx    -- (or leave planting the final \0 to the end)
;  2954                 mov [ebx+eax*4-12],edx      -- length
;  2955 --              if not stdin_redirected then
;  2956                 cmp [stdin_redirected],0
;  2957                 jnz :looptop3
;  2958 --              mov eax,[ch]
;  2959 --              push eax
;  2960                 push ecx
;  2961                 mov eax,esp
;  2962             [PE32]
;  2963                 push ebx                        -- lpvReserved
;  2964                 push esp                        -- lpcchWritten
;  2965                 push 1                          -- cchToWrite (1)
;  2966                 push eax                        -- lpvBuffer
;  2967                 push [stdout]                   -- hConsoleOutput
;  2968                 call "kernel32.dll","WriteConsoleA"
;  2969             [ELF32]
;  2970                 pop al
;  2971             [32]
;  2972                 pop eax -- (discard buffer)
;  2973 --              end if
;  2974 --          end if
;  2975             jmp :looptop3
;  2976 --      end while
;  2977       ::addlf
;  2978 --      r &= '\n'
;  2979         mov eax,[esp]                           -- newly allocated string
;  2980         mov edx,[ebx+eax*4-12]                  -- length
;  2981         mov edi,[ebx+eax*4-16]                  -- maxlen
;  2982         add edx,1
;  2983         sub edi,16
;  2984         cmp edx,edi                             -- cmp length,maxlen
;  2985         jl @f
;  2986 --          push whatever we need to save
;  2987             lea esi,[ebx+eax*4]
;  2988             push ecx                            -- save (char)
;  2989             push edx                            -- save (new length)
;  2990             mov ecx,edx
;  2991             call :%pAllocStr                    -- damages eax only
;  2992             lea edi,[ebx+eax*4]
;  2993             rep movsb
;  2994 --          swap refs
;  2995 --          pop edx
;  2996 --          push eax
;  2997             mov edx,[esp+8]                     -- prev allocated string
;  2998             mov [esp+8],eax                     -- update with replacement
;  2999             push dword[esp+5*4]                 -- era
;  3000             call :%pDealloc0
;  3001             pop edx                             -- restore (new length)
;  3002             pop ecx                             -- restore
;  3003             mov eax,[esp]                       -- newly allocated string
;  3004       @@:
;  3005         mov [ebx+eax*4-12],edx                  -- update length
;  3006         mov word[edx+eax*4-1],0x000A            -- "\n\0"
;  3007 --      return r
;  3008         pop eax
;  3009         jmp :opGetsStoreEax
;  3010     [64]
;  3011 --DEV calling convention
;  3012         -- [rsp]    rdi
;  3013         -- [rsp+8]  prev [rdi]
;  3014         -- [rsp+12] <return address>
;  3015         add rax,3 -- (undo sub3 above and test)
                add rax,3                 ;#0043DFDD: 48:203300 03               uv 01 01  1 214      
;  3016         jnz :e59wfmfao      -- only gets(0) valid
                jnz #0043DCF0             ;#0043DFE1: 017205 09FDFFFF            v  00 00  1 214      
;  3017         cmp [stdout],0
                cmp qword[#004031B0] (stdout),0  ;#0043DFE7: 48:203075 C151FCFF 00      u  00 00  2 215      
;  3018         jne @f
                jne #0043DFF6             ;#0043DFEF: 165 05                     v  00 00  1 216      
;  3019             call :%n_initC -- (preserves rax, not that we need it)
                    call #0043DCFD (:%n_initC)  ;#0043DFF1: 350 07FDFFFF               v  00 00  1 217      
;  3020       @@:
;  3021 --      #ilASM{ call :%opClrDbg }
;  3022 --      r = ""
;  3023         xor rcx,rcx -- length
                xor rcx,rcx               ;#0043DFF6: 48:061311                  uv 02 02  1 218      
;  3024         call :%pAllocStr        -- damages eax only
                call #004420E3 (:%pAllocStr)  ;#0043DFF9: 350 E5400000               v  00 00  1 218      
;  3025         push rax
                push rax                  ;#0043DFFE: 48:120                     uv 00 01  1 219      
;  3026       ::looptop3
;  3027 --      while 1 do
;  3028         [PE64]
;  3029             sub rsp,8*7
                    sub rsp,56            ;#0043E000: 48:203354 38               vu 10 10  1 219      
;  3030             mov [rsp+48],rbx                -- NumberOfBytesRead
                    mov [rsp+48],rbx      ;#0043E004: 48:211134044 30            uv 00 18  1 222    *10*
;  3031             mov [rsp+40],rbx                -- buffer (1 byte really)
                    mov [rsp+40],rbx      ;#0043E009: 48:211134044 28            vu 00 18  1 222      
;  3032             mov [rsp+32],rbx                -- lpOverlapped (NULL)
                    mov [rsp+32],rbx      ;#0043E00E: 48:211134044 20            uv 00 18  1 223      
;  3033             lea r9,[rsp+48]                 -- lpNumberOfBytesRead
                    lea r9,[rsp+48]       ;#0043E013: 4C:215114044 30            vu 200 10  1 223      
;  3034             mov r8,1                        -- nNumberOfBytesToRead (1)
                    mov r8,1              ;#0043E018: 49:307300 01000000         uv 100 00  1 224      
;  3035             lea rdx,[rsp+40]                -- lbBuffer
                    lea rdx,[rsp+40]      ;#0043E01F: 48:215124044 28            vu 04 10  1 224      
;  3036             mov rcx,[stdin]                 -- hFile
                    mov rcx,[#004031A8] (stdin)  ;#0043E024: 48:213015 7D51FCFF         uv 02 00  1 225      
;  3037             call "kernel32.dll","ReadFile"
                    call [#00401100] (ReadFile)  ;#0043E02B: 377025 CF30FCFF            np 00 00  2 226      
;  3038             pop rdx             -- NumberOfBytesRead
                    pop rdx               ;#0043E031: 48:132                     uv 04 00  1 228      
;  3039             pop rcx             -- buffer (1 byte)
                    pop rcx               ;#0043E033: 48:131                     vu 02 00  1 228      
;  3040             add rsp,8*5
                    add rsp,40            ;#0043E035: 48:203304 28               uv 10 10  1 229      
;  3041         [ELF64]
;  3042             pop al
;  3043         [64]
;  3044             test rax,rax
                    test rax,rax          ;#0043E039: 48:205300                  vu 00 01  1 229      
;  3045 --          setz dl
;  3046             jz :set26
                    jz #0043E043          ;#0043E03C: 164 05                     v  00 00  1 230      
;  3047             test rdx,rdx
                    test rdx,rdx          ;#0043E03E: 48:205322                  uv 00 04  1 231      
;  3048             jnz @f
                    jnz #0043E045         ;#0043E041: 165 02                     v  00 00  1 231      
;  3049           ::set26
;  3050                 mov cl,26 -- (Ctrl Z)
                        mov cl,26         ;#0043E043: 261 1A                     uv 02 00  1 232      
;  3051           @@:
;  3052 --          mov [ch],ecx
;  3053 --DEV what if ch='\n'? (test with various redirected files)
;  3054 --          if ch='\r' then         -- CR
;  3055             cmp cl,'\r'
                    cmp cl,13             ;#0043E045: 200371 0D                  uv 00 02  1 233 02   
;  3056             jne :notcr
                    jne #0043E092         ;#0043E048: 165 48                     v  00 00  1 233      
;  3057                 cmp [stdin_redirected],0
                        cmp qword[stdin_redirected],0  ;#0043E04A: 48:203075 7651FCFF 00      u  00 00  2 234      
;  3058                 je :addlf
                        je #0043E1B8      ;#0043E052: 017204 60010000            v  00 00  1 235      
;  3059                 --DEV might be better to mov [skipstdinlf],1...
;  3060             [PE64]
;  3061                 sub rsp,8*7
                        sub rsp,56        ;#0043E058: 48:203354 38               uv 10 10  1 236      
;  3062                 mov [rsp+48],rbx    -- NumberOfBytesRead
                        mov [rsp+48],rbx  ;#0043E05C: 48:211134044 30            uv 00 18  1 239 10 *10*
;  3063                 mov [rsp+40],rbx    -- buffer (1 byte really)
                        mov [rsp+40],rbx  ;#0043E061: 48:211134044 28            vu 00 18  1 239      
;  3064                 mov [rsp+32],rbx                                -- lpOverlapped (NULL)
                        mov [rsp+32],rbx  ;#0043E066: 48:211134044 20            uv 00 18  1 240      
;  3065                 lea r9,[rsp+48]                                 -- lpNumberOfBytesRead
                        lea r9,[rsp+48]   ;#0043E06B: 4C:215114044 30            vu 200 10  1 240      
;  3066                 mov r8,1                                        -- nNumberOfBytesToRead (1)
                        mov r8,1          ;#0043E070: 49:307300 01000000         uv 100 00  1 241      
;  3067                 lea rdx,[rsp+40]                                -- lbBuffer
                        lea rdx,[rsp+40]  ;#0043E077: 48:215124044 28            vu 04 10  1 241      
;  3068                 mov rcx,[stdin]                                 -- hFile
                        mov rcx,[#004031A8] (stdin)  ;#0043E07C: 48:213015 2551FCFF         uv 02 00  1 242      
;  3069                 call "kernel32.dll","ReadFile"
                        call [#00401100] (ReadFile)  ;#0043E083: 377025 7730FCFF            np 00 00  2 243      
;  3070                 add rsp,8*7
                        add rsp,56        ;#0043E089: 48:203304 38               uv 10 10  1 245      
;  3071             [ELF64]
;  3072                 pop al
;  3073             [64]
;  3074                 jmp :addlf
                        jmp #0043E1B8     ;#0043E08D: 351 26010000               v  00 00  1 245      
;  3075           ::notcr
;  3076 --          elsif ch=26 then        -- Ctrl Z
;  3077             cmp cl,26   -- CtrlZ
                    cmp cl,26             ;#0043E092: 200371 1A                  uv 00 02  1 246      
;  3078             jne :notcz
                    jne #0043E0C0         ;#0043E095: 165 29                     v  00 00  1 246      
;  3079 --              if length(r)=0 then
;  3080 --                  return -1
;  3081 --              else
;  3082 --                  return r
;  3083 --              end if
;  3084                 pop rax
                        pop rax           ;#0043E097: 48:130                     uv 01 00  1 247      
;  3085                 mov rdx,[rbx+rax*4-24]
                        mov rdx,[rbx+rax*4-24]  ;#0043E099: 48:213124203 E8            uv 04 09  1 250 01 *01*
;  3086                 test rdx,rdx
                        test rdx,rdx      ;#0043E09E: 48:205322                  uv 00 04  1 251 04   
;  3087                 jnz :opGetsStoreRax
                        jnz #0043DFBA     ;#0043E0A1: 017205 13FFFFFF            v  00 00  1 251      
;  3088                 mov rdx,rax
                        mov rdx,rax       ;#0043E0A7: 48:213320                  uv 04 01  1 252      
;  3089                 push qword[rsp+24]      -- era
                        push qword[rsp+24]  ;#0043E0AA: 48:377164044 18            np 00 10  2 253      
;  3090                 call :%pDealloc0
                        call #004422DE (:%pDealloc0)  ;#0043E0AF: 350 2A420000               v  00 00  1 255      
;  3091                 mov rax,-1
                        mov rax,-1        ;#0043E0B4: 48:307300 FFFFFFFF         uv 01 00  1 256      
;  3092                 jmp :opGetsStoreRax
                        jmp #0043DFBA     ;#0043E0BB: 351 FAFEFFFF               v  00 00  1 256      
;  3093           ::notcz
;  3094 --          elsif ch=8 then         -- backspace
;  3095             cmp cl,8    -- backspace
                    cmp cl,8              ;#0043E0C0: 200371 08                  uv 00 02  1 257      
;  3096             jne :notbs
                    jne #0043E122         ;#0043E0C3: 165 5D                     v  00 00  1 257      
;  3097 --              if length(r) then
;  3098                 mov rax,[rsp]
                        mov rax,[rsp]     ;#0043E0C5: 48:213004044               uv 01 10  1 258      
;  3099                 mov rdx,[rbx+rax*4-24]
                        mov rdx,[rbx+rax*4-24]  ;#0043E0C9: 48:213124203 E8            uv 04 09  1 261 01 *01*
;  3100                 sub rdx,1
                        sub rdx,1         ;#0043E0CE: 48:203352 01               uv 04 04  1 262 04   
;  3101                 jl :looptop3
                        jl #0043E000      ;#0043E0D2: 017214 28FFFFFF            v  00 00  1 262      
;  3102 --              r = r[1..-2]
;  3103                 mov [rbx+rax*4-24],rdx
                        mov [rbx+rax*4-24],rdx  ;#0043E0D8: 48:211124203 E8            uv 00 0D  1 263      
;  3104                 mov [rdx+rax*4],bl
                        mov [rdx+rax*4],bl  ;#0043E0DD: 210034202                  uv 00 0D  1 265    *04*
;  3105 --                  if not stdin_redirected then
;  3106                 cmp [stdin_redirected],0
                        cmp qword[stdin_redirected],0  ;#0043E0E0: 48:203075 E050FCFF 00      u  00 00  2 266      
;  3107                 jne :looptop3
                        jne #0043E000     ;#0043E0E8: 017205 12FFFFFF            v  00 00  1 267      
;  3108             [PE64]
;  3109                 push 0x21082008 -- back,space,back (buffer) [with a '!' (#21) that should not be seen/used]
                        push 554180616    ;#0043E0EE: 150 08200821               uv 00 00  1 268      
;  3110                 sub rsp,8*6
                        sub rsp,48        ;#0043E0F3: 48:203354 30               vu 10 10  1 268      
;  3111                 mov [rsp+32],rbx                        -- lpvReserved (NULL)
                        mov [rsp+32],rbx  ;#0043E0F7: 48:211134044 20            uv 00 18  1 271    *10*
;  3112                 lea r9,[rsp+40]                         -- lpcchWritten
                        lea r9,[rsp+40]   ;#0043E0FC: 4C:215114044 28            vu 200 10  1 271      
;  3113                 mov r8,3                                -- cchToWrite (3)
                        mov r8,3          ;#0043E101: 49:307300 03000000         uv 100 00  1 272      
;  3114                 lea edx,[rsp+48]                        -- lpvBuffer (the push)
                        lea edx,[rsp+48]  ;#0043E108: 215124044 30               vu 04 10  1 272      
;  3115                 mov rcx,[stdout]                        -- hConsoleOutput
                        mov rcx,[#004031B0] (stdout)  ;#0043E10C: 48:213015 9D50FCFF         uv 02 00  1 273      
;  3116                 call "kernel32.dll","WriteConsoleA"
                        call [#00401148] (WriteConsoleA)  ;#0043E113: 377025 2F30FCFF            np 00 00  2 274      
;  3117                 add rsp,8*7
                        add rsp,56        ;#0043E119: 48:203304 38               uv 10 10  1 276      
;  3118             [ELF64]
;  3119                 pop al
;  3120             [64]
;  3121 --                  end if
;  3122 --              end if
;  3123                 jmp :looptop3
                        jmp #0043E000     ;#0043E11D: 351 DEFEFFFF               v  00 00  1 276      
;  3124           ::notbs
;  3125 --          else
;  3126 --              r &= ch
;  3127                 mov rax,[rsp]
                        mov rax,[rsp]     ;#0043E122: 48:213004044               uv 01 10  1 279    *10*
;  3128                 mov rdx,[rbx+rax*4-24]      -- length
                        mov rdx,[rbx+rax*4-24]  ;#0043E126: 48:213124203 E8            uv 04 09  1 282 01 *01*
;  3129                 mov rdi,[rbx+rax*4-32]      -- maxlen
                        mov rdi,[rbx+rax*4-32]  ;#0043E12B: 48:213174203 E0            vu 80 09  1 282      
;  3130                 add rdx,1
                        add rdx,1         ;#0043E130: 48:203302 01               uv 04 04  1 283      
;  3131                 sub rdi,32
                        sub rdi,32        ;#0043E134: 48:203357 20               vu 80 80  1 283      
;  3132                 cmp rdx,rdi                 -- cmp length,maxlen
                        cmp rdx,rdi       ;#0043E138: 48:071372                  uv 00 84  1 284      
;  3133                 jl @f
                        jl #0043E16F      ;#0043E13B: 174 32                     v  00 00  1 284      
;  3134                     lea rsi,[rbx+rax*4]
                            lea rsi,[rbx+rax*4]  ;#0043E13D: 48:215064203               uv 40 09  1 285      
;  3135 --                  push whatever we need to save
;  3136                     push rcx                -- save
                            push rcx      ;#0043E141: 48:121                     vu 00 02  1 285      
;  3137                     push rdx                -- save
                            push rdx      ;#0043E143: 48:122                     uv 00 04  1 286      
;  3138 --                  push rax                -- save for deallocation
;  3139                     mov rcx,rdx
                            mov rcx,rdx   ;#0043E145: 48:213312                  vu 02 04  1 286      
;  3140                     call :%pAllocStr        -- damages eax only
                            call #004420E3 (:%pAllocStr)  ;#0043E148: 350 963F0000               v  00 00  1 287      
;  3141                     lea rdi,[rbx+rax*4]
                            lea rdi,[rbx+rax*4]  ;#0043E14D: 48:215074203               uv 80 09  1 288      
;  3142                     rep movsb
                            rep movsb     ;#0043E151: 363:244                    np C2 C2  4 291    *80*
;  3143 --                  swap refs
;  3144 --                  pop edx
;  3145 --                  push eax
;  3146                     mov rdx,[rsp+16]
                            mov rdx,[rsp+16]  ;#0043E153: 48:213124044 10            uv 04 10  1 295      
;  3147                     mov [rsp+16],rax
                            mov [rsp+16],rax  ;#0043E158: 48:211104044 10            vu 00 11  1 295      
;  3148                     push qword[rsp+5*8]     -- era
                            push qword[rsp+40]  ;#0043E15D: 48:377164044 28            np 00 10  2 296      
;  3149                     call :%pDealloc0
                            call #004422DE (:%pDealloc0)  ;#0043E162: 350 77410000               v  00 00  1 298      
;  3150                     pop rdx                 -- restore
                            pop rdx       ;#0043E167: 48:132                     uv 04 00  1 299      
;  3151                     pop rcx                 -- restore
                            pop rcx       ;#0043E169: 48:131                     vu 02 00  1 299      
;  3152                     mov rax,[rsp]
                            mov rax,[rsp]  ;#0043E16B: 48:213004044               uv 01 10  1 300      
;  3153               @@:
;  3154                 mov word[rdx+rax*4-1],cx    -- (or leave planting the final \0 to the end)
                        mov word[rdx+rax*4-1],cx  ;#0043E16F: 146:211114202 FF           uv 00 07  1 303 01 *05*
;  3155                 mov [rbx+rax*4-24],rdx      -- length
                        mov [rbx+rax*4-24],rdx  ;#0043E174: 48:211124203 E8            vu 00 0D  1 303      
;  3156 --              if not stdin_redirected then
;  3157                 cmp [stdin_redirected],0
                        cmp qword[stdin_redirected],0  ;#0043E179: 48:203075 4750FCFF 00      u  00 00  2 304      
;  3158                 jnz :looptop3
                        jnz #0043E000     ;#0043E181: 017205 79FEFFFF            v  00 00  1 305      
;  3159             [PE64]
;  3160                 push rcx
                        push rcx          ;#0043E187: 48:121                     uv 00 02  1 306      
;  3161                 sub rsp,8*6
                        sub rsp,48        ;#0043E189: 48:203354 30               vu 10 10  1 306      
;  3162                 mov [rsp+32],rbx                        -- lpvReserved (NULL)
                        mov [rsp+32],rbx  ;#0043E18D: 48:211134044 20            uv 00 18  1 309    *10*
;  3163                 lea r9,[rsp+40]                         -- lpcchWritten
                        lea r9,[rsp+40]   ;#0043E192: 4C:215114044 28            vu 200 10  1 309      
;  3164                 mov r8,1                                -- cchToWrite (1)
                        mov r8,1          ;#0043E197: 49:307300 01000000         uv 100 00  1 310      
;  3165                 lea edx,[rsp+48]                        -- lpvBuffer (the push)
                        lea edx,[rsp+48]  ;#0043E19E: 215124044 30               vu 04 10  1 310      
;  3166                 mov rcx,[stdout]                        -- hConsoleOutput
                        mov rcx,[#004031B0] (stdout)  ;#0043E1A2: 48:213015 0750FCFF         uv 02 00  1 311      
;  3167                 call "kernel32.dll","WriteConsoleA"
                        call [#00401148] (WriteConsoleA)  ;#0043E1A9: 377025 992FFCFF            np 00 00  2 312      
;  3168                 add rsp,8*7
                        add rsp,56        ;#0043E1AF: 48:203304 38               uv 10 10  1 314      
;  3169             [ELF64]
;  3170                 pop al
;  3171             [64]
;  3172 --              end if
;  3173 --          end if
;  3174             jmp :looptop3
                    jmp #0043E000         ;#0043E1B3: 351 48FEFFFF               v  00 00  1 314      
;  3175 --      end while
;  3176       ::addlf
;  3177 --      r &= '\n'
;  3178         mov rax,[rsp]
                mov rax,[rsp]             ;#0043E1B8: 48:213004044               uv 01 10  1 317    *10*
;  3179         mov rdx,[rbx+rax*4-24]      -- length
                mov rdx,[rbx+rax*4-24]    ;#0043E1BC: 48:213124203 E8            uv 04 09  1 320 01 *01*
;  3180         mov rdi,[rbx+rax*4-32]      -- maxlen
                mov rdi,[rbx+rax*4-32]    ;#0043E1C1: 48:213174203 E0            vu 80 09  1 320      
;  3181         add rdx,1
                add rdx,1                 ;#0043E1C6: 48:203302 01               uv 04 04  1 321      
;  3182         sub rdi,32
                sub rdi,32                ;#0043E1CA: 48:203357 20               vu 80 80  1 321      
;  3183         cmp rdx,rdi                 -- cmp length,maxlen
                cmp rdx,rdi               ;#0043E1CE: 48:071372                  uv 00 84  1 322      
;  3184         jl @f
                jl #0043E205              ;#0043E1D1: 174 32                     v  00 00  1 322      
;  3185 --          push whatever we need to save
;  3186             lea rsi,[rbx+rax*4]
                    lea rsi,[rbx+rax*4]   ;#0043E1D3: 48:215064203               uv 40 09  1 323      
;  3187             push rcx                -- save
                    push rcx              ;#0043E1D7: 48:121                     vu 00 02  1 323      
;  3188             push rdx                -- save
                    push rdx              ;#0043E1D9: 48:122                     uv 00 04  1 324      
;  3189             mov rcx,rdx
                    mov rcx,rdx           ;#0043E1DB: 48:213312                  vu 02 04  1 324      
;  3190             call :%pAllocStr        -- damages eax only
                    call #004420E3 (:%pAllocStr)  ;#0043E1DE: 350 003F0000               v  00 00  1 325      
;  3191             lea rdi,[rbx+rax*4]
                    lea rdi,[rbx+rax*4]   ;#0043E1E3: 48:215074203               uv 80 09  1 326      
;  3192             rep movsb
                    rep movsb             ;#0043E1E7: 363:244                    np C2 C2  4 329    *80*
;  3193 --          swap refs
;  3194 --          pop rdx
;  3195 --          push rax
;  3196             mov rdx,[rsp+16]
                    mov rdx,[rsp+16]      ;#0043E1E9: 48:213124044 10            uv 04 10  1 333      
;  3197             mov [rsp+16],rax
                    mov [rsp+16],rax      ;#0043E1EE: 48:211104044 10            vu 00 11  1 333      
;  3198             push qword[rsp+5*8]     -- era
                    push qword[rsp+40]    ;#0043E1F3: 48:377164044 28            np 00 10  2 334      
;  3199             call :%pDealloc0
                    call #004422DE (:%pDealloc0)  ;#0043E1F8: 350 E1400000               v  00 00  1 336      
;  3200 --          pop whatever we need to restore
;  3201             pop rdx                 -- restore
                    pop rdx               ;#0043E1FD: 48:132                     uv 04 00  1 337      
;  3202             pop rcx                 -- restore
                    pop rcx               ;#0043E1FF: 48:131                     vu 02 00  1 337      
;  3203             mov rax,[rsp]
                    mov rax,[rsp]         ;#0043E201: 48:213004044               uv 01 10  1 338      
;  3204       @@:
;  3205         mov [rbx+rax*4-24],rdx      -- length
                mov [rbx+rax*4-24],rdx    ;#0043E205: 48:211124203 E8            uv 00 0D  1 341 01 *01*
;  3206         mov word[rdx+rax*4-1],0x000A    -- "\n\0"
                mov word[rdx+rax*4-1], word 10  ;#0043E20A: 146:307104202 FF 0A00      vu 00 05  1 341      
;  3207 --      return r
;  3208         pop rax
                pop rax                   ;#0043E211: 48:130                     uv 01 00  1 342      
;  3209         jmp :opGetsStoreRax
                jmp #0043DFBA             ;#0043E213: 351 A2FDFFFF               v  00 00  1 342      
;  3210     []
;  3211 --/*
;  3212 --DEV still outstanding...::
;  3213 --DEV as per gets....
;  3214 --DEV 0 & 9 loop, 26 -> -1
;  3215 --          if ch!='\r' then exit end if                -- skip cr...
;  3216 --          -- (file 0 is always text mode)
;  3217 --      end while
;  3218         ret
;  3219 --*/
;  3220 
;  3221 --/*
;  3222 global procedure puts(integer fn, object x, :%opPuts)
;  3223 end procedure
;  3224 --*/
;  3225   :%opPuts
;  3226 ----------
;  3227     [32]
;  3228         -- fn in eax
;  3229         -- object to print in edx
;  3230         lea ecx,[ebx+eax*4]                     -- ecx:=fn*4 [fn->0-based byte idx+12]
;  3231         mov edi,[fdtbl]
;  3232 --      cmp eax,3 -- NO!
;  3233         sub eax,3 -- [fn->0-based idx, for comparison against fdmax]
;  3234         jb :puts1
;  3235         cmp eax,[fdmax]
;  3236         jae :getce58bfnNP
;  3237       @@:
;  3238         mov esi,[edi*4+ecx-12]                  -- esi:=fdtbl[fn-2]
;  3239         cmp edi,[fdtbl]
;  3240         je @f
;  3241             mov edi,[fdtbl]
;  3242             jmp @b
;  3243       @@:
;  3244         mov edi,[ebx+esi*4+MODE]
;  3245         shl esi,2
;  3246         push edx
;  3247         test edi,F_WRITE
;  3248         jz :e59wfmfao   -- (may need a pop?)
;  3249         test edi,F_DIRTY
;  3250         jnz @f
;  3251             or edi,F_DIRTY
;  3252             mov ecx,[esi+POSN]
;  3253             mov eax,[esi+FEND]
;  3254             mov [esi+MODE],edi
;  3255             cmp ecx,eax
;  3256             jg :clearbuff
;  3257                 fild qword[esi+POSL]
;  3258                 fild dword[esi+FEND]
;  3259                 fsubp st1,st0
;  3260                 fistp qword[esi+POSL] -- (realpos -= fend)
;  3261                 push edx -- save
;  3262                 lea ecx,[esi+POSH]
;  3263             [PE32]
;  3264                 push FILE_BEGIN                     -- dwMoveMethod
;  3265                 push ecx                            -- lpDistanceToMoveHigh
;  3266                 push dword[esi+POSL]                -- lDistanceToMove (0)
;  3267                 push dword[esi+HNDL]                -- hFile
;  3268                 call "kernel32.dll","SetFilePointer"
;  3269             [ELF32]
;  3270                 pop al
;  3271             [32]
;  3272                 pop edx -- restore
;  3273                 jmp @f
;  3274           ::clearbuff
;  3275                 mov [esi+POSN],dword 1
;  3276                 mov [esi+FEND],ebx
;  3277       @@:
;  3278         cmp edx,h4
;  3279         jl @f
;  3280             -- nb: pilx86.e is expected to opUnassigned edx (and eax)
;  3281             cmp byte[ebx+edx*4-1],#12
;  3282             jne :putstr                 -- (may jump to putsq, after getting the length)
;  3283             fld qword[ebx+edx*4]
;  3284             fistp dword[esp]
;  3285             mov edx,[esp]
;  3286       @@:
;  3287         mov ecx,1
;  3288         mov eax,[esi+POSN]
;  3289         cmp dl,'\n'
;  3290         jne @f
;  3291             test edi,F_BINARY
;  3292             jnz @f
;  3293                 mov dword[esp],#00000A0D  --(\r\n)
;  3294                 mov ecx,2
;  3295       @@:
;  3296         --
;  3297         -- reminder:
;  3298         --  esi is this (fdtbl[fn-2]*4)
;  3299         --  edi is mode (not used again)
;  3300         --  ecx is length (1 or 2)
;  3301         --  buffer is [esp] ("")
;  3302         --  eax is posn
;  3303         --
;  3304 --DEV lea edi here seems a better idea!
;  3305         lea edx,[esi+eax+BUFF-1]
;  3306         add eax,ecx
;  3307 --      cmp eax,BUFFERSIZE32
;  3308         cmp eax,BUFFERSIZE32+1
;  3309         jle @f
;  3310             push edx
;  3311             push ecx
;  3312             push esi
;  3313             call :%n_flush_esi2
;  3314             pop esi
;  3315             pop ecx
;  3316             pop edx
;  3317 --          mov [esi+POSN],dword 1
;  3318             mov eax,ecx
;  3319             mov [esi+FEND],ebx
;  3320             add eax,1
;  3321 --Ditto (edi)
;  3322             lea edx,[esi+BUFF]
;  3323       @@:
;  3324 --      sub eax,ecx
;  3325 --      lea edi,[esi+eax+BUFF-1]
;  3326         mov edi,edx
;  3327         mov edx,esi
;  3328         mov esi,esp
;  3329         rep movsb
;  3330         mov edi,[edx+FEND]
;  3331         mov [edx+POSN],eax
;  3332         sub eax,1
;  3333         add esp,4
;  3334         cmp eax,edi
;  3335         jle @f
;  3336 --          add eax,1
;  3337             mov [edx+FEND],eax
;  3338       @@:
;  3339         ret
;  3340     [64]
;  3341         -- fn in rax
;  3342         -- object to print in rdx
;  3343         lea rcx,[rbx+rax*8]                     -- rcx:=fn*8 [fn->0-based byte idx+24]
                lea rcx,[rbx+rax*8]       ;#0043E218: 48:215014303               uv 02 09  1 345    *01*
;  3344         mov rdi,[fdtbl]
                mov rdi,[#004030D0] (fdtbl)  ;#0043E21C: 48:213075 AD4EFCFF         vu 80 00  1 345      
;  3345 --      cmp eax,3 -- NO!
;  3346         sub rax,3 -- [fn->0-based idx, for comparison against fdmax]
                sub rax,3                 ;#0043E223: 48:203350 03               uv 01 01  1 346      
;  3347         jb :puts1
                jb #0043E594              ;#0043E227: 017202 67030000            v  00 00  1 346      
;  3348         cmp rax,[fdmax]
                cmp rax,[#004030D8] (fdmax)  ;#0043E22D: 48:073005 A44EFCFF         uv 00 01  2 347      
;  3349         jae :getce58bfnNP
                jae #0043DC04             ;#0043E234: 017203 CAF9FFFF            v  00 00  1 348      
;  3350       @@:
;  3351         mov rsi,[rdi*4+rcx-24]                  -- esi:=fdtbl[fn-2]
                mov rsi,[rcx+rdi*4-24]    ;#0043E23A: 48:213164271 E8            uv 40 82  1 349      
;  3352         cmp rdi,[fdtbl]
                cmp rdi,[#004030D0] (fdtbl)  ;#0043E23F: 48:073075 8A4EFCFF         vu 00 80  2 349      
;  3353         je @f
                je #0043E251              ;#0043E246: 164 09                     v  00 00  1 350      
;  3354             mov rdi,[fdtbl]
                    mov rdi,[#004030D0] (fdtbl)  ;#0043E248: 48:213075 814EFCFF         uv 80 00  1 351      
;  3355             jmp @b
                    jmp #0043E23A         ;#0043E24F: 353 E9                     v  00 00  1 351      
;  3356       @@:
;  3357         mov rdi,[rbx+rsi*4+MODE64]
                mov rdi,[rbx+rsi*4+8]     ;#0043E251: 48:213174263 08            uv 80 48  1 352      
;  3358         mov r15,h4
                mov r15,h4                ;#0043E256: 49:277 0000000000000040    vu 8000 00  1 352      
;  3359         shl rsi,2
                shl rsi,2                 ;#0043E260: 48:301346 02               u  40 40  1 353      
;  3360         push rdx
                push rdx                  ;#0043E264: 48:122                     vu 00 04  1 353      
;  3361         test rdi,F_WRITE
                test rdi,2                ;#0043E266: 48:367307 02000000         uv 00 80  1 354      
;  3362         jz :e59wfmfao   -- (may need a pop?)
                jz #0043DCF0              ;#0043E26D: 017204 7DFAFFFF            v  00 00  1 354      
;  3363         test rdi,F_DIRTY
                test rdi,8                ;#0043E273: 48:367307 08000000         uv 00 80  1 355      
;  3364         jnz @f
                jnz #0043E2CC             ;#0043E27A: 165 50                     v  00 00  1 355      
;  3365             or rdi,F_DIRTY
                    or rdi,8              ;#0043E27C: 48:203317 08               uv 80 80  1 356      
;  3366             mov rcx,[rsi+POSN64]
                    mov rcx,[rsi+16]      ;#0043E280: 48:213116 10               vu 02 40  1 356      
;  3367             mov rax,[rsi+FEND64]
                    mov rax,[rsi+24]      ;#0043E284: 48:213106 18               uv 01 40  1 357      
;  3368             mov [rsi+MODE64],rdi
                    mov [rsi+8],rdi       ;#0043E288: 48:211176 08               vu 00 C0  1 357      
;  3369             cmp rcx,rax
                    cmp rcx,rax           ;#0043E28C: 48:071301                  uv 00 03  1 358      
;  3370             jg :clearbuff
                    jg #0043E2C0          ;#0043E28F: 177 2F                     v  00 00  1 358      
;  3371                 sub [rsi+RPOS64],rax    -- (realpos -= fend)
                        sub [rsi+32],rax  ;#0043E291: 48:051106 20               uv 00 41  3 359      
;  3372             [PE64]
;  3373                 sub rsp,8*5 -- minimum 4 param shadow space, save rdx, and align(0)
                        sub rsp,40        ;#0043E295: 48:203354 28               vu 10 10  1 361      
;  3374                 mov [rsp+40],rdx    -- save
                        mov [rsp+40],rdx  ;#0043E299: 48:211124044 28            uv 00 14  1 364    *10*
;  3375                 mov r9,FILE_BEGIN                       -- dwMoveMethod
                        mov r9,0          ;#0043E29E: 49:307301 00000000         vu 200 00  1 364      
;  3376                 mov r8,rbx                              -- lpNewFilePointer (NULL)
                        mov r8,rbx        ;#0043E2A5: 4C:213303                  uv 100 08  1 365      
;  3377                 mov rdx,[rsi+RPOS64]                    -- liDistanceToMove
                        mov rdx,[rsi+32]  ;#0043E2A8: 48:213126 20               vu 04 40  1 365      
;  3378                 mov rcx,[rsi+HNDL64]                    -- hFile
                        mov rcx,[rsi]     ;#0043E2AC: 48:213016                  uv 02 40  1 366      
;  3379                 call "kernel32.dll","SetFilePointerEx"
                        call [#00401128] (SetFilePointerEx)  ;#0043E2AF: 377025 732EFCFF            np 00 00  2 367      
;  3380 --              cmp rax,0
;  3381 --              jne ??
;  3382                 mov rdx,[rsp+40] -- restore
                        mov rdx,[rsp+40]  ;#0043E2B5: 48:213124044 28            uv 04 10  1 369      
;  3383                 add rsp,8*5
                        add rsp,40        ;#0043E2BA: 48:203304 28               vu 10 10  1 369      
;  3384             [ELF64]
;  3385                 pop al
;  3386             [64]
;  3387                 jmp @f
                        jmp #0043E2CC     ;#0043E2BE: 353 0C                     v  00 00  1 370      
;  3388           ::clearbuff
;  3389                 mov [rsi+POSN64],qword 1
                        mov qword[rsi+16],1  ;#0043E2C0: 48:307106 10 01000000      uv 00 40  1 371      
;  3390                 mov [rsi+FEND64],rbx
                        mov [rsi+24],rbx  ;#0043E2C8: 48:211136 18               vu 00 48  1 371      
;  3391       @@:
;  3392         cmp rdx,r15
                cmp rdx,r15               ;#0043E2CC: 49:073327                  uv 00 8004  1 372      
;  3393         jl @f
                jl #0043E2E6              ;#0043E2CF: 174 15                     v  00 00  1 372      
;  3394             -- nb: pilx86.e is expected to opUnassigned edx (and eax)
;  3395             cmp byte[rbx+rdx*4-1],#12
                    cmp byte[rbx+rdx*4-1],#12  ;#0043E2D1: 200174223 FF 12            u  00 0C  2 373      
;  3396             jne :putstr                 -- (may jump to putsq, after getting the length)
                    jne #0043E35D         ;#0043E2D6: 017205 81000000            v  00 00  1 374      
;  3397             fld tbyte[rbx+rdx*4]
                    fld tbyte[rbx+rdx*4]  ;#0043E2DC: 333054223                  np 00 0C  3 375      
;  3398             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043E2DF: 337074044                  np 00 10  6 378      
;  3399             mov rdx,[rsp]
                    mov rdx,[rsp]         ;#0043E2E2: 48:213024044               uv 04 10  1 384      
;  3400       @@:
;  3401         mov rcx,1
                mov rcx,1                 ;#0043E2E6: 48:307301 01000000         vu 02 00  1 384      
;  3402         mov rax,[rsi+POSN64]
                mov rax,[rsi+16]          ;#0043E2ED: 48:213106 10               uv 01 40  1 385      
;  3403         cmp dl,'\n'
                cmp dl,10                 ;#0043E2F1: 200372 0A                  vu 00 04  1 385      
;  3404         jne @f
                jne #0043E30E             ;#0043E2F4: 165 18                     v  00 00  1 386      
;  3405             test rdi,F_BINARY
                    test rdi,4            ;#0043E2F6: 48:367307 04000000         uv 00 80  1 387      
;  3406             jnz @f
                    jnz #0043E30E         ;#0043E2FD: 165 0F                     v  00 00  1 387      
;  3407                 mov qword[rsp],#00000A0D  --(\r\n)
                        mov qword[rsp],2573  ;#0043E2FF: 48:307004044 0D0A0000      uv 00 10  1 388      
;  3408                 mov rcx,2
                        mov rcx,2         ;#0043E307: 48:307301 02000000         vu 02 00  1 388      
;  3409       @@:
;  3410         --
;  3411         -- reminder:
;  3412         --  rsi is this (fdtbl[fn-2]*4)
;  3413         --  rdi is mode (not used again)
;  3414         --  rcx is length (1 or 2)
;  3415         --  buffer is [rsp] ("")
;  3416         --  rax is posn
;  3417         --
;  3418         lea rdi,[rsi+rax+BUFF64-1]
                lea rdi,[rsi+rax+39]      ;#0043E30E: 48:215174006 27            uv 80 41  1 389      
;  3419         add rax,rcx
                add rax,rcx               ;#0043E313: 48:001310                  vu 01 03  1 389      
;  3420         cmp rax,BUFFERSIZE64+1
                cmp rax,8153              ;#0043E316: 48:201370 D91F0000         uv 00 01  1 390      
;  3421         jle @f
                jle #0043E33B             ;#0043E31D: 176 1C                     v  00 00  1 390      
;  3422 --          push rdx
;  3423             push rcx
                    push rcx              ;#0043E31F: 48:121                     uv 00 02  1 391      
;  3424             push rsi
                    push rsi              ;#0043E321: 48:126                     vu 00 40  1 391      
;  3425             call :%n_flush_rsi2
                    call #0043DB7C (:%n_flush_rsi2)  ;#0043E323: 350 54F8FFFF               v  00 00  1 392      
;  3426             pop rsi
                    pop rsi               ;#0043E328: 48:136                     uv 40 00  1 393      
;  3427             pop rcx
                    pop rcx               ;#0043E32A: 48:131                     vu 02 00  1 393      
;  3428 --          pop rdx
;  3429             mov rax,rcx
                    mov rax,rcx           ;#0043E32C: 48:213301                  uv 01 02  1 394      
;  3430             mov [rsi+FEND64],rbx
                    mov [rsi+24],rbx      ;#0043E32F: 48:211136 18               uv 00 48  1 396    *40*
;  3431             add rax,1
                    add rax,1             ;#0043E333: 48:203300 01               vu 01 01  1 396      
;  3432             lea rdi,[rsi+BUFF64]
                    lea rdi,[rsi+40]      ;#0043E337: 48:215176 28               uv 80 40  1 397      
;  3433       @@:
;  3434         mov rdx,rsi
                mov rdx,rsi               ;#0043E33B: 48:213326                  vu 04 40  1 397      
;  3435         mov rsi,rsp
                mov rsi,rsp               ;#0043E33E: 48:213364                  uv 40 10  1 398      
;  3436         rep movsb
                rep movsb                 ;#0043E341: 363:244                    np C2 C2  4 401    *C0*
;  3437         mov rdi,[rdx+FEND64]
                mov rdi,[rdx+24]          ;#0043E343: 48:213172 18               uv 80 04  1 405      
;  3438         mov [rdx+POSN64],rax
                mov [rdx+16],rax          ;#0043E347: 48:211102 10               vu 00 05  1 405      
;  3439         sub rax,1
                sub rax,1                 ;#0043E34B: 48:203350 01               uv 01 01  1 406      
;  3440         add rsp,8
                add rsp,8                 ;#0043E34F: 48:203304 08               vu 10 10  1 406      
;  3441         cmp rax,rdi
                cmp rax,rdi               ;#0043E353: 48:071370                  uv 00 81  1 407      
;  3442         jle @f
                jle #0043E35C             ;#0043E356: 176 04                     v  00 00  1 407      
;  3443             mov [rdx+FEND64],rax
                    mov [rdx+24],rax      ;#0043E358: 48:211102 18               uv 00 05  1 408      
;  3444       @@:
;  3445         ret
                ret                       ;#0043E35C: 303                        np 00 00  2 409      
;  3446     []
;  3447 
;  3448 --/*
;  3449 global procedure ::putstr(::)
;  3450 end procedure -- (for Edita/CtrlQ)
;  3451 --*/
;  3452   ::putstr
;  3453 ----------
;  3454     [32]
;  3455         add esp,4
;  3456         mov ecx,[ebx+edx*4-12]      -- length
;  3457         mov eax,[esi+POSN]
;  3458         test ecx,ecx
;  3459         jz @b
;  3460         cmp byte[ebx+edx*4-1],#82
;  3461         jne :putsq
;  3462         --
;  3463         -- reminder:
;  3464         --  esi is this (fdtbl[fn-2]*4)
;  3465         --  edi is mode
;  3466         --  ecx is length (non-zero, in case that matters)
;  3467         --  edx is string to print (ref)
;  3468         --  eax is fposn
;  3469         --
;  3470         test edi,F_BINARY
;  3471         jz :putstrtxt
;  3472         add eax,ecx
;  3473         cmp eax,BUFFERSIZE32+1
;  3474         jle @f
;  3475             cmp dword[esi+FEND],0
;  3476             je :putstrnoflush
;  3477                 push edx
;  3478                 push ecx
;  3479                 -- (remove dirty flag in case we writefile direct) [DEV we didn't test it was dirty!?]
;  3480                 sub edi,F_DIRTY
;  3481                 call :%n_flush_esiedi
;  3482                 pop ecx
;  3483                 mov eax,1
;  3484                 pop edx
;  3485                 mov [esi+POSN],eax
;  3486                 mov [esi+FEND],ebx
;  3487                 add eax,ecx
;  3488           ::putstrnoflush
;  3489             cmp ecx,BUFFERSIZE32
;  3490             jle :putstrinbuffer
;  3491                 mov eax,[esi+POSL]
;  3492                 mov edi,[esi+POSH]
;  3493                 add eax,ecx -- frealposn += len
;  3494                 adc edi,ebx
;  3495                 mov [esi+POSL],eax
;  3496                 mov [esi+POSH],edi
;  3497                 mov eax,[esi+HNDL]
;  3498                 shl edx,2
;  3499             [PE32]
;  3500                 push ebx                        -- lpOverlapped (NULL)
;  3501                 push esp                        -- lpNumberOfBytesWritten
;  3502                 push ecx                        -- nNumberOfBytesToWrite
;  3503                 push edx                        -- lpBuffer
;  3504                 push eax                        -- hFile,
;  3505                 call "kernel32.dll","WriteFile"
;  3506             [ELF32]
;  3507                 pop al
;  3508             [32]
;  3509                 ret
;  3510           ::putstrinbuffer
;  3511             --
;  3512             -- reminder:
;  3513             --  esi is this
;  3514             --  ecx is len
;  3515             --  edx is string to print (ref)
;  3516             --  eax is posn+len
;  3517             --
;  3518             or dword[esi+MODE],F_DIRTY
;  3519       @@:
;  3520         mov edi,[esi+POSN]
;  3521         push esi
;  3522         mov [esi+POSN],eax
;  3523         sub eax,1
;  3524         lea edi,[esi+edi+BUFF-1]
;  3525         lea esi,[ebx+edx*4]
;  3526         pop edx
;  3527         rep movsb
;  3528         cmp eax,[edx+FEND]
;  3529         jle @f
;  3530             mov [edx+FEND],eax
;  3531       @@:
;  3532         ret
;  3533     [64]
;  3534         add rsp,8
                add rsp,8                 ;#0043E35D: 48:203304 08               uv 10 10  1 411      
;  3535         mov rcx,[rbx+rdx*4-24]      -- length
                mov rcx,[rbx+rdx*4-24]    ;#0043E361: 48:213114223 E8            vu 02 0C  1 411      
;  3536         mov rax,[rsi+POSN64]
                mov rax,[rsi+16]          ;#0043E366: 48:213106 10               uv 01 40  1 412      
;  3537         test rcx,rcx
                test rcx,rcx              ;#0043E36A: 48:205311                  vu 00 02  1 412      
;  3538         jz @b
                jz #0043E35C              ;#0043E36D: 164 ED                     v  00 00  1 413      
;  3539         cmp byte[rbx+rdx*4-1],#82
                cmp byte[rbx+rdx*4-1],#82  ;#0043E36F: 200174223 FF 82            u  00 0C  2 414      
;  3540         jne :putsq
                jne #0043E4C3             ;#0043E374: 017205 49010000            v  00 00  1 415      
;  3541         --
;  3542         -- reminder:
;  3543         --  rsi is this (fdtbl[fn-2]*4)
;  3544         --  rdi is mode
;  3545         --  rcx is length (non-zero, in case that matters)
;  3546         --  rdx is string to print (ref)
;  3547         --  rax is fposn
;  3548         --
;  3549         test rdi,F_BINARY
                test rdi,4                ;#0043E37A: 48:367307 04000000         uv 00 80  1 416      
;  3550         jz :putstrtxt
                jz #0043E426              ;#0043E381: 017204 9F000000            v  00 00  1 416      
;  3551         add rax,rcx
                add rax,rcx               ;#0043E387: 48:001310                  uv 01 03  1 417      
;  3552         cmp rax,BUFFERSIZE64+1
                cmp rax,8153              ;#0043E38A: 48:201370 D91F0000         uv 00 01  1 418 01   
;  3553         jle @f
                jle #0043E400             ;#0043E391: 176 6D                     v  00 00  1 418      
;  3554             cmp qword[rsi+FEND64],0
                    cmp qword[rsi+24],0   ;#0043E393: 48:203176 18 00            u  00 40  2 419      
;  3555             je :putstrnoflush
                    je #0043E3BD          ;#0043E398: 164 23                     v  00 00  1 420      
;  3556                 push rdx
                        push rdx          ;#0043E39A: 48:122                     uv 00 04  1 421      
;  3557                 push rcx
                        push rcx          ;#0043E39C: 48:121                     vu 00 02  1 421      
;  3558                 -- (remove dirty flag in case we writefile direct) [DEV we didn't test it was dirty!?]
;  3559                 sub rdi,F_DIRTY
                        sub rdi,8         ;#0043E39E: 48:203357 08               uv 80 80  1 422      
;  3560                 call :%n_flush_rsirdi
                        call :%n_flush_rsirdi  ;#0043E3A2: 350 D1F7FFFF               v  00 00  1 422      
;  3561                 pop rcx
                        pop rcx           ;#0043E3A7: 48:131                     uv 02 00  1 423      
;  3562                 mov rax,1
                        mov rax,1         ;#0043E3A9: 48:307300 01000000         vu 01 00  1 423      
;  3563                 pop rdx
                        pop rdx           ;#0043E3B0: 48:132                     uv 04 00  1 424      
;  3564                 mov [rsi+POSN64],rax
                        mov [rsi+16],rax  ;#0043E3B2: 48:211106 10               vu 00 41  1 424      
;  3565                 mov [rsi+FEND64],rbx
                        mov [rsi+24],rbx  ;#0043E3B6: 48:211136 18               uv 00 48  1 425      
;  3566                 add rax,rcx
                        add rax,rcx       ;#0043E3BA: 48:001310                  vu 01 03  1 425      
;  3567           ::putstrnoflush
;  3568             cmp rcx,BUFFERSIZE64
                    cmp rcx,8152          ;#0043E3BD: 48:201371 D81F0000         uv 00 02  1 426      
;  3569             jle :putstrinbuffer
                    jle #0043E3FB         ;#0043E3C4: 176 35                     v  00 00  1 426      
;  3570                 mov rax,[rsi+RPOS64]
                        mov rax,[rsi+32]  ;#0043E3C6: 48:213106 20               uv 01 40  1 427      
;  3571                 add rax,rcx -- frealposn += len
                        add rax,rcx       ;#0043E3CA: 48:001310                  uv 01 03  1 428 01   
;  3572                 mov [rsi+RPOS64],rax
                        mov [rsi+32],rax  ;#0043E3CD: 48:211106 20               uv 00 41  1 429 01   
;  3573                 mov rax,[rsi+HNDL64]
                        mov rax,[rsi]     ;#0043E3D1: 48:213006                  vu 01 40  1 429      
;  3574                 shl rdx,2
                        shl rdx,2         ;#0043E3D4: 48:301342 02               u  04 04  1 430      
;  3575             [PE64]
;  3576                 sub rsp,8*5     -- minimum 4 param shadow space, lpOverlapped, and align (none in this case)
                        sub rsp,40        ;#0043E3D8: 48:203354 28               vu 10 10  1 430      
;  3577                 mov [rsp+32],rbx                            -- lpOverlapped (NULL)
                        mov [rsp+32],rbx  ;#0043E3DC: 48:211134044 20            uv 00 18  1 433    *10*
;  3578 --              mov r9,rbx                                  -- lpNumberOfBytesWritten (NULL)    -- NO!
;  3579                 lea r9,[rsp+32]                             -- lpNumberOfBytesWritten
                        lea r9,[rsp+32]   ;#0043E3E1: 4C:215114044 20            vu 200 10  1 433      
;  3580                 mov r8,rcx                                  -- nNumberOfBytesToWrite (fend)
                        mov r8,rcx        ;#0043E3E6: 4C:213301                  uv 100 02  1 434      
;  3581                 lea rdx,[rsi+BUFF64]                        -- lpBuffer
                        lea rdx,[rsi+40]  ;#0043E3E9: 48:215126 28               vu 04 40  1 434      
;  3582                 mov rcx,[rsi+HNDL64]                        -- hFile
                        mov rcx,[rsi]     ;#0043E3ED: 48:213016                  uv 02 40  1 435      
;  3583                 call "kernel32.dll","WriteFile"
                        call [#00401150] (WriteFile)  ;#0043E3F0: 377025 5A2DFCFF            np 00 00  2 436      
;  3584 --/* (DEV: we should probably do this, but the 32-bit version don't, and we'd need a new error code)
;  3585                 test rax,rax
;  3586                 jnz @f
;  3587                     call "kernel32.dll","GetLastError"
;  3588                     mov rdi,rax                             -- ep1
;  3589                     mov al,98                               -- e98fiofe -- flush error [ep1]
;  3590                     xor rsi,rsi                             -- ep2 unused
;  3591                     jmp :%pRTErn                            -- fatal error
;  3592               @@:
;  3593 --*/
;  3594                 add rsp,8*5
                        add rsp,40        ;#0043E3F6: 48:203304 28               uv 10 10  1 438      
;  3595             [ELF64]
;  3596                 pop al
;  3597             [64]
;  3598                 ret
                        ret               ;#0043E3FA: 303                        np 00 00  2 439      
;  3599           ::putstrinbuffer
;  3600             --
;  3601             -- reminder:
;  3602             --  rsi is this
;  3603             --  rcx is len
;  3604             --  rdx is string to print (ref)
;  3605             --  rax is posn+len
;  3606             --
;  3607             or qword[rsi+MODE64],F_DIRTY
                    or qword[rsi+8],8     ;#0043E3FB: 48:203116 08 08            u  00 40  3 441      
;  3608       @@:
;  3609         mov rdi,[rsi+POSN64]
                mov rdi,[rsi+16]          ;#0043E400: 48:213176 10               vu 80 40  1 443      
;  3610         push rsi
                push rsi                  ;#0043E404: 48:126                     uv 00 40  1 444      
;  3611         mov [rsi+POSN64],rax
                mov [rsi+16],rax          ;#0043E406: 48:211106 10               vu 00 41  1 444      
;  3612         sub rax,1
                sub rax,1                 ;#0043E40A: 48:203350 01               uv 01 01  1 445      
;  3613         lea rdi,[rsi+rdi+BUFF64-1]
                lea rdi,[rsi+rdi+39]      ;#0043E40E: 48:215174076 27            vu 80 C0  1 445      
;  3614         lea rsi,[rbx+rdx*4]
                lea rsi,[rbx+rdx*4]       ;#0043E413: 48:215064223               uv 40 0C  1 446      
;  3615         pop rdx
                pop rdx                   ;#0043E417: 48:132                     vu 04 00  1 446      
;  3616         rep movsb
                rep movsb                 ;#0043E419: 363:244                    np C2 C2  4 449    *40*
;  3617         cmp rax,[rdx+FEND64]
                cmp rax,[rdx+24]          ;#0043E41B: 48:073102 18               uv 00 05  2 455    *04*
;  3618         jle @f
                jle #0043E425             ;#0043E41F: 176 04                     v  00 00  1 456      
;  3619             mov [rdx+FEND64],rax
                    mov [rdx+24],rax      ;#0043E421: 48:211102 18               uv 00 05  1 457      
;  3620       @@:
;  3621         ret
                ret                       ;#0043E425: 303                        np 00 00  2 458      
;  3622     []
;  3623 
;  3624 --/*
;  3625 global procedure ::putstrtxt(::)
;  3626 end procedure -- (for Edita/CtrlQ)
;  3627 --*/
;  3628   ::putstrtxt
;  3629 -------------
;  3630         -- write string, inserting carriage-return characters before linefeeds
;  3631     [32]
;  3632         push esi
;  3633         lea edi,[esi+eax+BUFF-1]
;  3634         lea esi,[ebx+edx*4]
;  3635 --      mov edx,[esi+POSN]
;  3636         mov edx,eax -- posn
;  3637 
;  3638       ::putstrtxtlooptop
;  3639         cmp edx,BUFFERSIZE32
;  3640         jle @f
;  3641 --DEV common code with below
;  3642             push esi
;  3643             mov esi,[esp+4]
;  3644             push ecx
;  3645             mov dword[esi+FEND],BUFFERSIZE32
;  3646             call :%n_flush_esi2
;  3647             pop ecx
;  3648             mov [esi+FEND],ebx
;  3649             pop esi
;  3650             mov edx,1
;  3651       @@:
;  3652         lodsb
;  3653         cmp al,'\n'
;  3654         jne @f
;  3655             mov byte[edi],'\r'
;  3656             add edx,1
;  3657             add edi,1
;  3658             cmp edx,BUFFERSIZE32
;  3659             jle @f
;  3660 --DEV common code with above (up to mov al,'\n')
;  3661                 push esi
;  3662                 mov esi,[esp+4]
;  3663                 push ecx
;  3664                 mov dword[esi+FEND],BUFFERSIZE32
;  3665                 call :%n_flush_esi2
;  3666                 pop ecx
;  3667                 mov [esi+FEND],ebx
;  3668                 pop esi
;  3669                 mov edx,1
;  3670                 mov al,'\n'
;  3671       @@:
;  3672         stosb
;  3673         add edx,1
;  3674         sub ecx,1
;  3675         jg :putstrtxtlooptop
;  3676         pop esi
;  3677         mov [esi+POSN],edx
;  3678         sub edx,1
;  3679         cmp [esi+FEND],edx
;  3680         jge @f
;  3681             mov [esi+FEND],edx
;  3682       @@:
;  3683         ret
;  3684     [64]
;  3685         push rsi
                push rsi                  ;#0043E426: 48:126                     uv 00 40  1 460      
;  3686         lea rdi,[rsi+rax+BUFF64-1]
                lea rdi,[rsi+rax+39]      ;#0043E428: 48:215174006 27            vu 80 41  1 460      
;  3687         lea rsi,[rbx+rdx*4]
                lea rsi,[rbx+rdx*4]       ;#0043E42D: 48:215064223               uv 40 0C  1 461      
;  3688 --      mov rdx,[rsi+POSN64]
;  3689         mov rdx,rax -- posn
                mov rdx,rax               ;#0043E431: 48:213320                  vu 04 01  1 461      
;  3690 
;  3691       ::putstrtxtlooptop
;  3692         cmp rdx,BUFFERSIZE64
                cmp rdx,8152              ;#0043E434: 48:201372 D81F0000         uv 00 04  1 462      
;  3693         jle @f
                jle #0043E462             ;#0043E43B: 176 25                     v  00 00  1 462      
;  3694 --DEV common code with below
;  3695             push rsi
                    push rsi              ;#0043E43D: 48:126                     uv 00 40  1 463      
;  3696             mov rsi,[rsp+8]
                    mov rsi,[rsp+8]       ;#0043E43F: 48:213164044 08            vu 40 10  1 463      
;  3697             push rcx
                    push rcx              ;#0043E444: 48:121                     uv 00 02  1 464      
;  3698             mov qword[rsi+FEND64],BUFFERSIZE64
                    mov qword[rsi+24],8152  ;#0043E446: 48:307106 18 D81F0000      uv 00 40  1 466    *40*
;  3699             call :%n_flush_rsi2
                    call #0043DB7C (:%n_flush_rsi2)  ;#0043E44E: 350 29F7FFFF               v  00 00  1 466      
;  3700             pop rcx
                    pop rcx               ;#0043E453: 48:131                     uv 02 00  1 467      
;  3701             mov [rsi+FEND64],rbx
                    mov [rsi+24],rbx      ;#0043E455: 48:211136 18               vu 00 48  1 467      
;  3702             pop rsi
                    pop rsi               ;#0043E459: 48:136                     uv 40 00  1 468      
;  3703             mov rdx,1
                    mov rdx,1             ;#0043E45B: 48:307302 01000000         vu 04 00  1 468      
;  3704       @@:
;  3705         lodsb
                lodsb                     ;#0043E462: 254                        np 41 40  2 471    *40*
;  3706         cmp al,'\n'
                cmp al,10                 ;#0043E463: 200370 0A                  uv 00 01  1 473      
;  3707         jne @f
                jne #0043E4A3             ;#0043E466: 165 3B                     v  00 00  1 473      
;  3708             mov byte[rdi],'\r'
                    mov [rdi], byte 13    ;#0043E468: 306007 0D                  uv 00 80  1 474      
;  3709             add rdx,1
                    add rdx,1             ;#0043E46B: 48:203302 01               vu 04 04  1 474      
;  3710             add rdi,1
                    add rdi,1             ;#0043E46F: 48:203307 01               uv 80 80  1 475      
;  3711             cmp rdx,BUFFERSIZE64
                    cmp rdx,8152          ;#0043E473: 48:201372 D81F0000         vu 00 04  1 475      
;  3712             jle @f
                    jle #0043E4A3         ;#0043E47A: 176 27                     v  00 00  1 476      
;  3713 --DEV common code with above (up to mov al,'\n')
;  3714                 push rsi
                        push rsi          ;#0043E47C: 48:126                     uv 00 40  1 477      
;  3715                 mov rsi,[rsp+8]
                        mov rsi,[rsp+8]   ;#0043E47E: 48:213164044 08            vu 40 10  1 477      
;  3716                 push rcx
                        push rcx          ;#0043E483: 48:121                     uv 00 02  1 478      
;  3717                 mov qword[rsi+FEND64],BUFFERSIZE64
                        mov qword[rsi+24],8152  ;#0043E485: 48:307106 18 D81F0000      uv 00 40  1 480    *40*
;  3718                 call :%n_flush_rsi2
                        call #0043DB7C (:%n_flush_rsi2)  ;#0043E48D: 350 EAF6FFFF               v  00 00  1 480      
;  3719                 pop rcx
                        pop rcx           ;#0043E492: 48:131                     uv 02 00  1 481      
;  3720                 mov [rsi+FEND64],rbx
                        mov [rsi+24],rbx  ;#0043E494: 48:211136 18               vu 00 48  1 481      
;  3721                 pop rsi
                        pop rsi           ;#0043E498: 48:136                     uv 40 00  1 482      
;  3722                 mov rdx,1
                        mov rdx,1         ;#0043E49A: 48:307302 01000000         vu 04 00  1 482      
;  3723                 mov al,'\n'
                        mov al,10         ;#0043E4A1: 260 0A                     uv 01 00  1 483      
;  3724       @@:
;  3725         stosb
                stosb                     ;#0043E4A3: 252                        np 80 81  3 484      
;  3726         add rdx,1
                add rdx,1                 ;#0043E4A4: 48:203302 01               uv 04 04  1 487      
;  3727         sub rcx,1
                sub rcx,1                 ;#0043E4A8: 48:203351 01               vu 02 02  1 487      
;  3728         jg :putstrtxtlooptop
                jg #0043E434              ;#0043E4AC: 177 86                     v  00 00  1 488      
;  3729         pop rsi
                pop rsi                   ;#0043E4AE: 48:136                     uv 40 00  1 489      
;  3730         mov [rsi+POSN64],rdx
                mov [rsi+16],rdx          ;#0043E4B0: 48:211126 10               uv 00 44  1 492 40 *40*
;  3731         sub rdx,1
                sub rdx,1                 ;#0043E4B4: 48:203352 01               vu 04 04  1 492      
;  3732         cmp [rsi+FEND64],rdx
                cmp [rsi+24],rdx          ;#0043E4B8: 48:071126 18               uv 00 44  2 493      
;  3733         jge @f
                jge #0043E4C2             ;#0043E4BC: 175 04                     v  00 00  1 494      
;  3734             mov [rsi+FEND64],rdx
                    mov [rsi+24],rdx      ;#0043E4BE: 48:211126 18               uv 00 44  1 495      
;  3735       @@:
;  3736         ret
                ret                       ;#0043E4C2: 303                        np 00 00  2 496      
;  3737     []
;  3738 
;  3739 --/*
;  3740 global procedure ::putsq(::)
;  3741 end procedure -- (for Edita/CtrlQ)
;  3742 --*/
;  3743   ::putsq
;  3744 ---------
;  3745         -- write a dword-sequence, which must not contain any subsequences,
;  3746         -- as 1-byte chars, and if in binary mode then insert cr before lf.
;  3747     [32]
;  3748         push esi
;  3749 --6/5/15:
;  3750 --      lea edi,[esi+BUFF]
;  3751         lea edi,[esi+eax+BUFF-1]
;  3752         lea esi,[ebx+edx*4]
;  3753 --      mov edx,[esi+POSN]
;  3754         mov edx,eax -- posn
;  3755 
;  3756       ::putsqlooptop
;  3757         cmp edx,BUFFERSIZE32
;  3758         jle @f
;  3759             push esi
;  3760             mov esi,[esp+4]
;  3761             push ecx
;  3762             mov dword[esi+FEND],BUFFERSIZE32
;  3763             call :%n_flush_esi2
;  3764             pop ecx
;  3765             mov [esi+FEND],ebx
;  3766             pop esi
;  3767             mov edx,1
;  3768       @@:
;  3769         lodsd
;  3770         cmp eax,h4
;  3771         jl @f
;  3772             push ebx
;  3773             cmp byte[ebx+eax*4-1],#12
;  3774             jne :putsqe65sfics
;  3775             fld qword[ebx+eax*4]
;  3776             fistp dword[esp]
;  3777             pop eax
;  3778       @@:
;  3779         cmp al,'\n'
;  3780         jne @f
;  3781             mov eax,[esp]
;  3782             test dword[eax+MODE],F_BINARY
;  3783 --12/5/15:
;  3784 --          jz :putsqresetal
;  3785             jnz :putsqresetal
;  3786             mov byte[edi],'\r'
;  3787             add edx,1
;  3788             add edi,1
;  3789             cmp edx,BUFFERSIZE32
;  3790 --12/5/15:
;  3791 --          jle @f
;  3792             jle :putsqresetal
;  3793                 push esi
;  3794                 mov esi,[esp+4]
;  3795                 push ecx
;  3796                 mov dword[esi+FEND],BUFFERSIZE32
;  3797                 call :%n_flush_esi2
;  3798                 pop ecx
;  3799                 mov [esi+FEND],ebx
;  3800                 pop esi
;  3801                 mov edx,1
;  3802           ::putsqresetal
;  3803                 mov al,'\n'
;  3804       @@:
;  3805 --DEV stosb? (6/5/15)
;  3806 --      movsb
;  3807         stosb
;  3808         add edx,1
;  3809         sub ecx,1
;  3810         jg :putsqlooptop
;  3811         pop esi
;  3812         mov [esi+POSN],edx
;  3813         sub edx,1
;  3814         cmp [esi+FEND],edx
;  3815         jge @f
;  3816             mov [esi+FEND],edx
;  3817       @@:
;  3818         ret
;  3819     [64]
;  3820         push rsi
                push rsi                  ;#0043E4C3: 48:126                     uv 00 40  1 498      
;  3821 --6/5/15:
;  3822 --      lea rdi,[rsi+BUFF64]
;  3823         lea rdi,[rsi+rax+BUFF64-1]
                lea rdi,[rsi+rax+39]      ;#0043E4C5: 48:215174006 27            vu 80 41  1 498      
;  3824         lea rsi,[rbx+rdx*4]
                lea rsi,[rbx+rdx*4]       ;#0043E4CA: 48:215064223               uv 40 0C  1 499      
;  3825 --      mov rdx,[rsi+POSN64]
;  3826         mov rdx,rax -- posn
                mov rdx,rax               ;#0043E4CE: 48:213320                  vu 04 01  1 499      
;  3827         mov r15,h4
                mov r15,h4                ;#0043E4D1: 49:277 0000000000000040    uv 8000 00  1 500      
;  3828 
;  3829       ::putsqlooptop
;  3830         cmp rdx,BUFFERSIZE64
                cmp rdx,8152              ;#0043E4DB: 48:201372 D81F0000         vu 00 04  1 500      
;  3831         jle @f
                jle #0043E509             ;#0043E4E2: 176 25                     v  00 00  1 501      
;  3832             push rsi
                    push rsi              ;#0043E4E4: 48:126                     uv 00 40  1 502      
;  3833             mov rsi,[rsp+8]
                    mov rsi,[rsp+8]       ;#0043E4E6: 48:213164044 08            vu 40 10  1 502      
;  3834             push rcx
                    push rcx              ;#0043E4EB: 48:121                     uv 00 02  1 503      
;  3835             mov qword[rsi+FEND64],BUFFERSIZE64
                    mov qword[rsi+24],8152  ;#0043E4ED: 48:307106 18 D81F0000      uv 00 40  1 505    *40*
;  3836             call :%n_flush_rsi2
                    call #0043DB7C (:%n_flush_rsi2)  ;#0043E4F5: 350 82F6FFFF               v  00 00  1 505      
;  3837             pop rcx
                    pop rcx               ;#0043E4FA: 48:131                     uv 02 00  1 506      
;  3838             mov [rsi+FEND64],rbx
                    mov [rsi+24],rbx      ;#0043E4FC: 48:211136 18               vu 00 48  1 506      
;  3839             pop rsi
                    pop rsi               ;#0043E500: 48:136                     uv 40 00  1 507      
;  3840             mov rdx,1
                    mov rdx,1             ;#0043E502: 48:307302 01000000         vu 04 00  1 507      
;  3841       @@:
;  3842         lodsq
                lodsq                     ;#0043E509: 48:255                     np 41 40  2 510    *40*
;  3843         cmp rax,r15
                cmp rax,r15               ;#0043E50B: 49:073307                  uv 00 8001  1 512      
;  3844         jl @f
                jl #0043E525              ;#0043E50E: 174 15                     v  00 00  1 512      
;  3845             push rbx
                    push rbx              ;#0043E510: 48:123                     uv 00 08  1 513      
;  3846             cmp byte[rbx+rax*4-1],#12
                    cmp byte[rbx+rax*4-1],#12  ;#0043E512: 200174203 FF 12            u  00 09  2 514      
;  3847             jne :putsqe65sfics
                    jne #0043E6D2         ;#0043E517: 017205 B5010000            v  00 00  1 515      
;  3848             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043E51D: 333054203                  np 00 09  3 516      
;  3849             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043E520: 337074044                  np 00 10  6 519      
;  3850             pop rax
                    pop rax               ;#0043E523: 48:130                     uv 01 00  1 525      
;  3851       @@:
;  3852         cmp al,'\n'
                cmp al,10                 ;#0043E525: 200370 0A                  uv 00 01  1 526 01   
;  3853         jne @f
                jne #0043E570             ;#0043E528: 165 46                     v  00 00  1 526      
;  3854             mov rax,[rsp]
                    mov rax,[rsp]         ;#0043E52A: 48:213004044               uv 01 10  1 527      
;  3855             test qword[rax+MODE64],F_BINARY
                    test byte[rax+8],4    ;#0043E52E: 48:366100 08 04            u  00 01  2 530    *01*
;  3856 -- 12/5/15:
;  3857 --          jz :putsqresetal
;  3858             jnz :putsqresetal
                    jnz #0043E56E         ;#0043E533: 165 39                     v  00 00  1 531      
;  3859             mov byte[rdi],'\r'
                    mov [rdi], byte 13    ;#0043E535: 306007 0D                  uv 00 80  1 532      
;  3860             add rdx,1
                    add rdx,1             ;#0043E538: 48:203302 01               vu 04 04  1 532      
;  3861             add rdi,1
                    add rdi,1             ;#0043E53C: 48:203307 01               uv 80 80  1 533      
;  3862             cmp rdx,BUFFERSIZE64
                    cmp rdx,8152          ;#0043E540: 48:201372 D81F0000         vu 00 04  1 533      
;  3863 -- 12/5/15:
;  3864 --          jle @f
;  3865             jle :putsqresetal
                    jle #0043E56E         ;#0043E547: 176 25                     v  00 00  1 534      
;  3866                 push rsi
                        push rsi          ;#0043E549: 48:126                     uv 00 40  1 535      
;  3867                 mov rsi,[rsp+8]
                        mov rsi,[rsp+8]   ;#0043E54B: 48:213164044 08            vu 40 10  1 535      
;  3868                 push rcx
                        push rcx          ;#0043E550: 48:121                     uv 00 02  1 536      
;  3869                 mov qword[rsi+FEND64],BUFFERSIZE64
                        mov qword[rsi+24],8152  ;#0043E552: 48:307106 18 D81F0000      uv 00 40  1 538    *40*
;  3870                 call :%n_flush_rsi2
                        call #0043DB7C (:%n_flush_rsi2)  ;#0043E55A: 350 1DF6FFFF               v  00 00  1 538      
;  3871                 pop rcx
                        pop rcx           ;#0043E55F: 48:131                     uv 02 00  1 539      
;  3872                 mov [rsi+FEND64],rbx
                        mov [rsi+24],rbx  ;#0043E561: 48:211136 18               vu 00 48  1 539      
;  3873                 pop rsi
                        pop rsi           ;#0043E565: 48:136                     uv 40 00  1 540      
;  3874                 mov rdx,1
                        mov rdx,1         ;#0043E567: 48:307302 01000000         vu 04 00  1 540      
;  3875           ::putsqresetal
;  3876                 mov al,'\n'
                        mov al,10         ;#0043E56E: 260 0A                     uv 01 00  1 541      
;  3877       @@:
;  3878 --DEV stosb? (6/5/15)
;  3879 --      movsb
;  3880         stosb
                stosb                     ;#0043E570: 252                        np 80 81  3 542      
;  3881         add rdx,1
                add rdx,1                 ;#0043E571: 48:203302 01               uv 04 04  1 545      
;  3882         sub rcx,1
                sub rcx,1                 ;#0043E575: 48:203351 01               vu 02 02  1 545      
;  3883         jg :putsqlooptop
                jg #0043E4DB              ;#0043E579: 017217 5CFFFFFF            v  00 00  1 546      
;  3884         pop rsi
                pop rsi                   ;#0043E57F: 48:136                     uv 40 00  1 547      
;  3885         mov [rsi+POSN64],rdx
                mov [rsi+16],rdx          ;#0043E581: 48:211126 10               uv 00 44  1 550 40 *40*
;  3886         sub rdx,1
                sub rdx,1                 ;#0043E585: 48:203352 01               vu 04 04  1 550      
;  3887         cmp [rsi+FEND64],rdx
                cmp [rsi+24],rdx          ;#0043E589: 48:071126 18               uv 00 44  2 551      
;  3888         jge @f
                jge #0043E593             ;#0043E58D: 175 04                     v  00 00  1 552      
;  3889             mov [rsi+FEND64],rdx
                    mov [rsi+24],rdx      ;#0043E58F: 48:211126 18               uv 00 44  1 553      
;  3890       @@:
;  3891         ret
                ret                       ;#0043E593: 303                        np 00 00  2 554      
;  3892     []
;  3893 
;  3894 --/*
;  3895 global procedure ::puts1(::)
;  3896 end procedure -- (for Edita/CtrlQ)
;  3897 --*/
;  3898   ::puts1           -- fn (eax)<3
;  3899 ---------
;  3900     [32]
;  3901         add eax,3 -- (undo sub3 above and test)
;  3902         jle :e59wfmfao      -- only puts(1|2) valid
;  3903         push edx
;  3904         cmp [stdout],0
;  3905         jne @f
;  3906             call :%n_initC -- (preserves eax)
;  3907             mov edx,[esp]
;  3908       @@:
;  3909         cmp eax,1
;  3910         je :putstdout
;  3911             mov eax,[stderr]
;  3912             jmp @f
;  3913       ::putstdout
;  3914             mov eax,[stdout]
;  3915       @@:
;  3916 --      #ilASM{ call :%opClrDbg }
;  3917         cmp edx,h4
;  3918         jl @f
;  3919             -- nb: pilx86.e is expected to opUnassigned edx (and eax)
;  3920             cmp byte[ebx+edx*4-1],#12
;  3921             jne :puts1str
;  3922             fld qword[ebx+edx*4]
;  3923             fistp dword[esp]
;  3924       @@:
;  3925     [PE32]
;  3926         mov edx,esp
;  3927         push ebx                    -- lpOverlapped (NULL)
;  3928         push esp                    -- lpNumberOfBytesWritten
;  3929         push dword 1                -- nNumberOfBytesToWrite (1)
;  3930         push edx                    -- lpBuffer
;  3931         push eax                    -- hFile,
;  3932         call "kernel32.dll","WriteFile"
;  3933         pop edx     -- discard (one byte) buffer
;  3934     [ELF32]
;  3935         pop al
;  3936     [32]
;  3937         ret
;  3938     [64]
;  3939         add rax,3 -- (undo sub3 above and test)
                add rax,3                 ;#0043E594: 48:203300 03               uv 01 01  1 556      
;  3940         jle :e59wfmfao      -- only puts(1|2) valid
                jle #0043DCF0             ;#0043E598: 017216 52F7FFFF            v  00 00  1 556      
;  3941         push rdx
                push rdx                  ;#0043E59E: 48:122                     uv 00 04  1 557      
;  3942         mov r15,h4
                mov r15,h4                ;#0043E5A0: 49:277 0000000000000040    vu 8000 00  1 557      
;  3943         cmp [stdout],0
                cmp qword[#004031B0] (stdout),0  ;#0043E5AA: 48:203075 FE4BFCFF 00      u  00 00  2 558      
;  3944         jne @f
                jne #0043E5BD             ;#0043E5B2: 165 09                     v  00 00  1 559      
;  3945             call :%n_initC -- (preserves rax)
                    call #0043DCFD (:%n_initC)  ;#0043E5B4: 350 44F7FFFF               v  00 00  1 560      
;  3946             mov rdx,[rsp]
                    mov rdx,[rsp]         ;#0043E5B9: 48:213024044               uv 04 10  1 561      
;  3947       @@:
;  3948         cmp rax,1
                cmp rax,1                 ;#0043E5BD: 48:203370 01               vu 00 01  1 561      
;  3949         je :putstdout
                je #0043E5CC              ;#0043E5C1: 164 09                     v  00 00  1 562      
;  3950             mov rax,[stderr]
                    mov rax,[#004031B8] (stderr)  ;#0043E5C3: 48:213005 EE4BFCFF         uv 01 00  1 563      
;  3951             jmp @f
                    jmp #0043E5D3         ;#0043E5CA: 353 07                     v  00 00  1 563      
;  3952       ::putstdout
;  3953             mov rax,[stdout]
                    mov rax,[#004031B0] (stdout)  ;#0043E5CC: 48:213005 DD4BFCFF         uv 01 00  1 564      
;  3954       @@:
;  3955 --      #ilASM{ call :%opClrDbg }
;  3956         cmp rdx,r15
                cmp rdx,r15               ;#0043E5D3: 49:073327                  vu 00 8004  1 564      
;  3957         jl @f
                jl #0043E5E5              ;#0043E5D6: 174 0D                     v  00 00  1 565      
;  3958             -- nb: pilx86.e is expected to opUnassigned rdx (and rax)
;  3959             cmp byte[rbx+rdx*4-1],#12
                    cmp byte[rbx+rdx*4-1],#12  ;#0043E5D8: 200174223 FF 12            u  00 0C  2 566      
;  3960             jne :puts1str
                    jne #0043E60D         ;#0043E5DD: 165 2E                     v  00 00  1 567      
;  3961             fld tbyte[rbx+rdx*4]
                    fld tbyte[rbx+rdx*4]  ;#0043E5DF: 333054223                  np 00 0C  3 568      
;  3962             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043E5E2: 337074044                  np 00 10  6 571      
;  3963       @@:
;  3964     [PE64]
;  3965         sub rsp,8*6     -- minimum 4 param shadow space, lpOverlapped, align, and buffer(/edx already pushed)
                sub rsp,48                ;#0043E5E5: 48:203354 30               uv 10 10  1 577      
;  3966         mov [rsp+32],rbx                -- lpOverlapped (NULL)
                mov [rsp+32],rbx          ;#0043E5E9: 48:211134044 20            uv 00 18  1 580 10 *10*
;  3967 --      mov r9,rbx                      -- lpNumberOfBytesWritten (NULL)    -- NO!
;  3968         lea r9,[rsp+32]                 -- lpNumberOfBytesWritten
                lea r9,[rsp+32]           ;#0043E5EE: 4C:215114044 20            vu 200 10  1 580      
;  3969         mov r8,1                        -- nNumberOfBytesToWrite
                mov r8,1                  ;#0043E5F3: 49:307300 01000000         uv 100 00  1 581      
;  3970         lea rdx,[rsp+48]                -- lpBuffer (that rdx we pushed)
                lea rdx,[rsp+48]          ;#0043E5FA: 48:215124044 30            vu 04 10  1 581      
;  3971         mov rcx,rax                     -- hFile
                mov rcx,rax               ;#0043E5FF: 48:213310                  uv 02 01  1 582      
;  3972         call "kernel32.dll","WriteFile"
                call [#00401150] (WriteFile)  ;#0043E602: 377025 482BFCFF            np 00 00  2 583      
;  3973         add rsp,8*7
                add rsp,56                ;#0043E608: 48:203304 38               uv 10 10  1 585      
;  3974     [ELF64]
;  3975         pop al
;  3976     [64]
;  3977         ret
                ret                       ;#0043E60C: 303                        np 00 00  2 586      
;  3978     []
;  3979 
;  3980 --/*
;  3981 global procedure ::puts1str(::)
;  3982 end procedure -- (for Edita/CtrlQ)
;  3983 --*/
;  3984   ::puts1str
;  3985 ------------
;  3986         -- write a string to the console
;  3987     [32]
;  3988         add esp,4 -- (discard the edx we pushed above)
;  3989         mov ecx,[ebx+edx*4-12]      -- length
;  3990         cmp byte[ebx+edx*4-1],#82
;  3991         jne :puts1sq
;  3992 --      jne :%n_opPuts1Sq
;  3993         lea edx,[ebx+edx*4]
;  3994         --
;  3995         -- Bugfix 23/01/2014: was getting ERROR_NOT_ENOUGH_MEMORY when displaying strings 
;  3996         --  over 62,600 bytes in length, not something I recommend, but a "?s" should not 
;  3997         --  just display nowt because of some internal limit being exceeded; -> 8k blocks.
;  3998         --
;  3999       ::p1blockloop
;  4000         cmp ecx,8192    -- (reasonable for both 32 and 64-bit, btw)
;  4001         jle :p1oneblock
;  4002         push ecx
;  4003         push edx
;  4004         push eax
;  4005         mov ecx,8192
;  4006         call :p1oneblock
;  4007         pop eax
;  4008         pop edx
;  4009         pop ecx
;  4010         add edx,8192
;  4011         sub ecx,8192
;  4012         jmp :p1blockloop
;  4013       ::p1oneblock
;  4014     [PE32]
;  4015         push ebx                    -- lpOverlapped (NULL)
;  4016         push esp                    -- lpNumberOfBytesWritten
;  4017         push ecx                    -- nNumberOfBytesToWrite
;  4018         push edx                    -- lpBuffer
;  4019         push eax                    -- hFile,
;  4020         call "kernel32.dll","WriteFile"
;  4021 --      test eax,eax
;  4022 --      jz :puts1err
;  4023     [ELF32]
;  4024         pop al
;  4025     [64]
;  4026         add rsp,8 -- (discard the rdx we pushed above)
                add rsp,8                 ;#0043E60D: 48:203304 08               uv 10 10  1 588      
;  4027         mov rcx,[rbx+rdx*4-24]      -- length
                mov rcx,[rbx+rdx*4-24]    ;#0043E611: 48:213114223 E8            vu 02 0C  1 588      
;  4028         cmp byte[rbx+rdx*4-1],#82
                cmp byte[rbx+rdx*4-1],#82  ;#0043E616: 200174223 FF 82            u  00 0C  2 589      
;  4029         jne :puts1sq
                jne #0043E671             ;#0043E61B: 165 54                     v  00 00  1 590      
;  4030 --      jne :%n_opPuts1Sq
;  4031         lea rdx,[rbx+rdx*4]
                lea rdx,[rbx+rdx*4]       ;#0043E61D: 48:215024223               uv 04 0C  1 591      
;  4032       ::p1blockloop
;  4033         cmp rcx,8192    -- (reasonable for both 32 and 64-bit, btw)
                cmp rcx,8192              ;#0043E621: 48:201371 00200000         vu 00 02  1 591      
;  4034         jle :p1oneblock
                jle #0043E652             ;#0043E628: 176 28                     v  00 00  1 592      
;  4035         push rcx
                push rcx                  ;#0043E62A: 48:121                     uv 00 02  1 593      
;  4036         push rdx
                push rdx                  ;#0043E62C: 48:122                     vu 00 04  1 593      
;  4037         push rax
                push rax                  ;#0043E62E: 48:120                     uv 00 01  1 594      
;  4038         mov rcx,8192
                mov rcx,8192              ;#0043E630: 48:307301 00200000         vu 02 00  1 594      
;  4039         call :p1oneblock
                call #0043E652            ;#0043E637: 350 16000000               v  00 00  1 595      
;  4040         pop rax
                pop rax                   ;#0043E63C: 48:130                     uv 01 00  1 596      
;  4041         pop rdx
                pop rdx                   ;#0043E63E: 48:132                     vu 04 00  1 596      
;  4042         pop rcx
                pop rcx                   ;#0043E640: 48:131                     uv 02 00  1 597      
;  4043         add rdx,8192
                add rdx,8192              ;#0043E642: 48:201302 00200000         vu 04 04  1 597      
;  4044         sub rcx,8192
                sub rcx,8192              ;#0043E649: 48:201351 00200000         uv 02 02  1 598      
;  4045         jmp :p1blockloop
                jmp #0043E621             ;#0043E650: 353 CF                     v  00 00  1 598      
;  4046       ::p1oneblock
;  4047     [PE64]
;  4048         sub rsp,8*5     -- minimum 4 param shadow space, lpOverlapped, and align (none in this case)
                sub rsp,40                ;#0043E652: 48:203354 28               uv 10 10  1 599      
;  4049         mov [rsp+32],rbx                -- lpOverlapped (NULL)
                mov [rsp+32],rbx          ;#0043E656: 48:211134044 20            uv 00 18  1 602 10 *10*
;  4050 --      mov r9,rbx                      -- lpNumberOfBytesWritten (NULL)    -- NO!
;  4051         lea r9,[rsp+32]                 -- lpNumberOfBytesWritten
                lea r9,[rsp+32]           ;#0043E65B: 4C:215114044 20            vu 200 10  1 602      
;  4052         mov r8,rcx                      -- nNumberOfBytesToWrite
                mov r8,rcx                ;#0043E660: 4C:213301                  uv 100 02  1 603      
;  4053 --      (rdx already set)               -- lpBuffer
;  4054         mov rcx,rax                     -- hFile
                mov rcx,rax               ;#0043E663: 48:213310                  vu 02 01  1 603      
;  4055         call "kernel32.dll","WriteFile"
                call [#00401150] (WriteFile)  ;#0043E666: 377025 E42AFCFF            np 00 00  2 604      
;  4056         add rsp,8*5
                add rsp,40                ;#0043E66C: 48:203304 28               uv 10 10  1 606      
;  4057 --      test rax,rax
;  4058 --      jz :puts1err
;  4059     [ELF64]
;  4060         pop al
;  4061     []
;  4062       @@:
;  4063         ret
                ret                       ;#0043E670: 303                        np 00 00  2 607      
;  4064 --    ::puts1err
;  4065 --      call "kernel32.dll","GetLastError"
;  4066 --      mov edi,eax
;  4067 ----DEV temp:
;  4068 --      mov al,58
;  4069 --      xor esi,esi     -- ep2 unused
;  4070 --      jmp %pRTErn     -- fatal error
;  4071 
;  4072 
;  4073 --/*
;  4074 global procedure ::puts1sq(::)
;  4075 end procedure -- (for Edita/CtrlQ)
;  4076 --*/
;  4077 -- old (working but slower) code
;  4078   ::puts1sq
;  4079 -----------
;  4080         -- Note: puts(1,{'a','b','c'}) is going to be quite slow.
;  4081         --       For redirected output, we should [DEV] allocate
;  4082         --       a (byte-)buffer and WriteFile just the once.
;  4083     [32]
;  4084         lea esi,[ebx+edx*4]
;  4085         mov edi,eax
;  4086       ::puts1sqlooptop
;  4087         sub ecx,1
;  4088         jl @b
;  4089         lodsd           -- eax:=[esi++]
;  4090         push edi        -- save
;  4091         push esi        -- save
;  4092         push ecx        -- save
;  4093         push eax        -- Buffer (of one byte)
;  4094         mov edx,esp
;  4095         cmp eax,h4
;  4096         jl @f
;  4097             cmp byte[ebx+eax*4-1],#12
;  4098             jne :puts1sqe65sfics
;  4099             fld qword[ebx+eax*4]
;  4100             fistp dword[esp]
;  4101       @@:
;  4102     [PE32]
;  4103         push ebx                    -- lpOverlapped (NULL)
;  4104         push esp                    -- lpNumberOfBytesWritten
;  4105         push 1                      -- nNumberOfBytesToWrite (1)
;  4106         push edx                    -- lpBuffer
;  4107         push edi                    -- hFile,
;  4108         call "kernel32.dll","WriteFile"
;  4109     [ELF32]
;  4110         pop al
;  4111     [32]
;  4112         pop eax         -- discard
;  4113         pop ecx         -- restore
;  4114         pop esi         -- restore
;  4115         pop edi         -- restore
;  4116         jmp :puts1sqlooptop
;  4117 
;  4118       ::puts1sqe65sfics
;  4119         add esp,16      -- (locates era properly)
;  4120       ::putsqe65sfics   -- DEV "" to do
;  4121         mov al,65       -- "sequence found in character string"
;  4122         xor edi,edi     -- ep1 unused
;  4123         xor esi,esi     -- ep2 unused
;  4124         jmp :%pRTErn    -- fatal error
;  4125     [64]
;  4126         lea rsi,[rbx+rdx*4]
                lea rsi,[rbx+rdx*4]       ;#0043E671: 48:215064223               uv 40 0C  1 609      
;  4127         mov rdi,rax     -- hFile
                mov rdi,rax               ;#0043E675: 48:213370                  vu 80 01  1 609      
;  4128       ::puts1sqlooptop
;  4129         sub rcx,1
                sub rcx,1                 ;#0043E678: 48:203351 01               uv 02 02  1 610      
;  4130         jl @b
                jl #0043E670              ;#0043E67C: 174 F2                     v  00 00  1 610      
;  4131         lodsq           -- rax:=[rsi++]
                lodsq                     ;#0043E67E: 48:255                     np 41 40  2 611      
;  4132         push rdi        -- save
                push rdi                  ;#0043E680: 48:127                     uv 00 80  1 613      
;  4133         push rsi        -- save
                push rsi                  ;#0043E682: 48:126                     vu 00 40  1 613      
;  4134         push rcx        -- save
                push rcx                  ;#0043E684: 48:121                     uv 00 02  1 614      
;  4135         push rax        -- Buffer (of one byte)
                push rax                  ;#0043E686: 48:120                     vu 00 01  1 614      
;  4136         mov rdx,rsp
                mov rdx,rsp               ;#0043E688: 48:213324                  uv 04 10  1 615      
;  4137         cmp rax,r15
                cmp rax,r15               ;#0043E68B: 49:073307                  vu 00 8001  1 615      
;  4138         jl @f
                jl #0043E69D              ;#0043E68E: 174 0D                     v  00 00  1 616      
;  4139             cmp byte[rbx+rax*4-1],#12
                    cmp byte[rbx+rax*4-1],#12  ;#0043E690: 200174203 FF 12            u  00 09  2 617      
;  4140             jne :puts1sqe65sfics
                    jne #0043E6CE         ;#0043E695: 165 37                     v  00 00  1 618      
;  4141             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043E697: 333054203                  np 00 09  3 619      
;  4142             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043E69A: 337074044                  np 00 10  6 622      
;  4143       @@:
;  4144     [PE64]
;  4145         sub rsp,8*5     -- minimum 4 param shadow space, lpOverlapped, and align (none in this case)
                sub rsp,40                ;#0043E69D: 48:203354 28               uv 10 10  1 628      
;  4146         mov [rsp+40],rax                -- char/buffer
                mov [rsp+40],rax          ;#0043E6A1: 48:211104044 28            uv 00 11  1 631 10 *10*
;  4147         mov [rsp+32],rbx                -- lpOverlapped (NULL)
                mov [rsp+32],rbx          ;#0043E6A6: 48:211134044 20            vu 00 18  1 631      
;  4148 --      mov r9,rbx                      -- lpNumberOfBytesWritten (NULL)    -- NO!
;  4149         lea r9,[rsp+32]                 -- lpNumberOfBytesWritten
                lea r9,[rsp+32]           ;#0043E6AB: 4C:215114044 20            uv 200 10  1 632      
;  4150         mov r8,1                        -- nNumberOfBytesToWrite (1)
                mov r8,1                  ;#0043E6B0: 49:307300 01000000         vu 100 00  1 632      
;  4151 --      (rdx already set)               -- lpBuffer
;  4152         mov rcx,rdi                     -- hFile
                mov rcx,rdi               ;#0043E6B7: 48:213317                  uv 02 80  1 633      
;  4153         call "kernel32.dll","WriteFile"
                call [#00401150] (WriteFile)  ;#0043E6BA: 377025 902AFCFF            np 00 00  2 634      
;  4154         add rsp,8*5
                add rsp,40                ;#0043E6C0: 48:203304 28               uv 10 10  1 636      
;  4155     [ELF64]
;  4156         pop al
;  4157     [64]
;  4158         pop rax         -- discard
                pop rax                   ;#0043E6C4: 48:130                     vu 01 00  1 636      
;  4159         pop rcx         -- restore
                pop rcx                   ;#0043E6C6: 48:131                     uv 02 00  1 637      
;  4160         pop rsi         -- restore
                pop rsi                   ;#0043E6C8: 48:136                     vu 40 00  1 637      
;  4161         pop rdi         -- restore
                pop rdi                   ;#0043E6CA: 48:137                     uv 80 00  1 638      
;  4162         jmp :puts1sqlooptop
                jmp #0043E678             ;#0043E6CC: 353 AA                     v  00 00  1 638      
;  4163 
;  4164       ::puts1sqe65sfics
;  4165         add rsp,32      -- (locates era properly[?])
                add rsp,32                ;#0043E6CE: 48:203304 20               uv 10 10  1 639      
;  4166       ::putsqe65sfics   -- DEV "" to do
;  4167         mov al,65       -- "sequence found in character string"
                mov al,65                 ;#0043E6D2: 260 41                     vu 01 00  1 639      
;  4168         xor rdi,rdi     -- ep1 unused
                xor rdi,rdi               ;#0043E6D4: 48:061377                  uv 80 80  1 640      
;  4169         xor rsi,rsi     -- ep2 unused
                xor rsi,rsi               ;#0043E6D7: 48:061366                  vu 40 40  1 640      
;  4170         jmp :%pRTErn    -- fatal error
                jmp #00442DC8 (:%pRTErn)  ;#0043E6DA: 351 E9460000               v  00 00  1 641      
;  4171     []
;  4172 
;  4173 --/*
;  4174 global function get_key(, :%opGetKey)
;  4175 -- Return next key that was pressed by the user, without waiting.
;  4176 -- Return -1 if no key was pressed.
;  4177 end function
;  4178 --*/
;  4179     :%opGetKey                     -- [edi]=get_key()
;  4180 --------------
;  4181     [32]
;  4182         -- calling convention:
;  4183         --  lea edi,[p1]    -- result location
;  4184         --  call :%opGetKey
;  4185         push edi
;  4186         cmp [stdout],0
;  4187         jne @f
;  4188             call :%n_initC -- (preserves eax)
;  4189       @@:
;  4190 --      call clear_debug [DEV]
;  4191         sub esp,20 -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD])
;  4192         mov edi,esp -- (preserved over api calls)
;  4193         push ebx    -- DWORD NumberOfEventsRead(:=0)
;  4194       @@:
;  4195     [PE32]
;  4196         push esp                                -- lpNumberOfEventsRead
;  4197         push 1                                  -- nLength
;  4198         push edi                                -- lpBuffer
;  4199         push [stdin]                            -- hConsoleInput
;  4200         call "kernel32.dll","PeekConsoleInputA"
;  4201     [ELF32]
;  4202         pop al
;  4203     [32]
;  4204         mov eax,-1
;  4205         cmp dword[esp],0
;  4206         je @f
;  4207         [PE32]
;  4208             push esp                                -- lpNumberOfEventsRead
;  4209             push 1                                  -- nLength
;  4210             push edi                                -- lpBuffer
;  4211             push [stdin]                            -- hConsoleInput
;  4212             call "kernel32.dll","ReadConsoleInputA"
;  4213         [ELF32]
;  4214             pop al -- (and very probably all what follows!)
;  4215         [32]
;  4216             cmp word[edi],0x0001                    -- lpBuffer.EventType=KEY_EVENT?
;  4217             jne @b
;  4218             cmp dword[edi+4],0x00000001             -- lpBuffer.keyDown(ignore key up events)
;  4219             jne @b
;  4220             xor eax,eax
;  4221             mov al,[edi+14]                         -- lpBuffer.keyChar
;  4222             or ax,ax
;  4223             jne @f
;  4224                 mov ax,256
;  4225                 add ax,[edi+12]                     -- lpBuffer.keyScan
;  4226                 --
;  4227                 -- Skip control, alt, shift and caps lock keys.
;  4228                 -- Note that shift, ctrl, alt, and caps lock keys will repeat 
;  4229                 -- while they are held down, so a routine which wants to detect
;  4230                 -- them pressed on their own cannot accept eg <Ctrl A>, or even
;  4231                 -- <Shift 1>, aka '!'. If you _do_ want to detect them on their 
;  4232                 -- own, just make a copy of this routine minus these lines.
;  4233                 -- Note values determined by experimentation, not documentation!
;  4234                 --
;  4235                 cmp ax,298  -- shift key
;  4236                 je @b
;  4237                 cmp ax,285  -- ctrl key
;  4238                 je @b
;  4239                 cmp ax,312  -- alt key
;  4240                 je @b
;  4241 -- actually, RDS lets this through...
;  4242 --              cmp ax,314  -- caps lock
;  4243 --              je @b
;  4244       @@:
;  4245         add esp,24  -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD] and DWORD NumberOfEventsRead)
;  4246 --      jmp @f
;  4247         pop edi
;  4248         mov edx,[edi]
;  4249         mov [edi],eax
;  4250         cmp edx,h4
;  4251         jle @f                          -- this jump almost always taken
;  4252             sub dword[ebx+edx*4-8],1    -- <any object> := wait_key() case [rare, tgt is usually an int]
;  4253             jz :%pDealloc
;  4254       @@:
;  4255         ret
;  4256     [64]
;  4257         -- calling convention:
;  4258         --  lea rdi,[p1]    -- result location
;  4259         --  call :%opGetKey
;  4260         push rdi
                push rdi                  ;#0043E6DF: 48:127                     uv 00 80  1 642      
;  4261         cmp [stdout],0
                cmp qword[#004031B0] (stdout),0  ;#0043E6E1: 48:203075 C74AFCFF 00      u  00 00  2 643      
;  4262         jne @f
                jne #0043E6F0             ;#0043E6E9: 165 05                     v  00 00  1 644      
;  4263             call :%n_initC -- (preserves rax)
                    call #0043DCFD (:%n_initC)  ;#0043E6EB: 350 0DF6FFFF               v  00 00  1 645      
;  4264       @@:
;  4265 --      call clear_debug [DEV]
;  4266     [PE64]
;  4267         sub rsp,24 -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD]) (rounded up to qwords)
                sub rsp,24                ;#0043E6F0: 48:203354 18               uv 10 10  1 646      
;  4268         mov rdi,rsp -- (preserved over api calls)
                mov rdi,rsp               ;#0043E6F4: 48:213374                  uv 80 10  1 647 10   
;  4269 --      push rbx    -- DWORD NumberOfEventsRead(:=0) (rounded up to a whole qword)
;  4270 
;  4271         sub rsp,8*5 -- shadow space for 4 params and NumberOfEventsRead
                sub rsp,40                ;#0043E6F7: 48:203354 28               vu 10 10  1 647      
;  4272       @@:
;  4273         mov [rsp+32],rbx
                mov [rsp+32],rbx          ;#0043E6FB: 48:211134044 20            uv 00 18  1 650    *10*
;  4274         lea r9,[rsp+32]                         -- lpNumberOfEventsRead
                lea r9,[rsp+32]           ;#0043E700: 4C:215114044 20            vu 200 10  1 650      
;  4275         mov r8,1                                -- nLength
                mov r8,1                  ;#0043E705: 49:307300 01000000         uv 100 00  1 651      
;  4276         mov rdx,rdi                             -- lpBuffer
                mov rdx,rdi               ;#0043E70C: 48:213327                  vu 04 80  1 651      
;  4277         mov rcx,[stdin]                         -- hConsoleInput
                mov rcx,[#004031A8] (stdin)  ;#0043E70F: 48:213015 924AFCFF         uv 02 00  1 652      
;  4278         call "kernel32.dll","PeekConsoleInputA"
                call [#004010F0] (PeekConsoleInputA)  ;#0043E716: 377025 D429FCFF            np 00 00  2 653      
;  4279         mov rax,-1
                mov rax,-1                ;#0043E71C: 48:307300 FFFFFFFF         uv 01 00  1 655      
;  4280         cmp dword[rsp+32],0
                cmp dword[rsp+32],0       ;#0043E723: 203174044 20 00            u  00 10  2 656      
;  4281         je @f
                je #0043E77A              ;#0043E728: 164 50                     v  00 00  1 657      
;  4282             lea r9,[rsp+32]                         -- lpNumberOfEventsRead
                    lea r9,[rsp+32]       ;#0043E72A: 4C:215114044 20            uv 200 10  1 658      
;  4283             mov r8,1                                -- nLength
                    mov r8,1              ;#0043E72F: 49:307300 01000000         vu 100 00  1 658      
;  4284             mov rdx,rdi                             -- lpBuffer
                    mov rdx,rdi           ;#0043E736: 48:213327                  uv 04 80  1 659      
;  4285             mov rcx,[stdin]                         -- hConsoleInput
                    mov rcx,[#004031A8] (stdin)  ;#0043E739: 48:213015 684AFCFF         vu 02 00  1 659      
;  4286             call "kernel32.dll","ReadConsoleInputA"
                    call [#004010F8] (ReadConsoleInputA)  ;#0043E740: 377025 B229FCFF            np 00 00  2 660      
;  4287             cmp word[rdi],0x0001                    -- lpBuffer.EventType=KEY_EVENT?
                    cmp word[rdi],1       ;#0043E746: 146:203077 01              uv 00 80  2 662      
;  4288             jne @b
                    jne #0043E6FB         ;#0043E74A: 165 AF                     v  00 00  1 663      
;  4289             cmp dword[rdi+4],0x00000001             -- lpBuffer.keyDown(ignore key up events)
                    cmp dword[rdi+4],1    ;#0043E74C: 203177 04 01               u  00 80  2 664      
;  4290             jne @b
                    jne #0043E6FB         ;#0043E750: 165 A9                     v  00 00  1 665      
;  4291             xor rax,rax
                    xor rax,rax           ;#0043E752: 48:061300                  uv 01 01  1 666      
;  4292             mov al,[rdi+14]                         -- lpBuffer.keyChar
                    mov al,[edi+14]       ;#0043E755: 212107 0E                  uv 01 80  1 667 01   
;  4293             or ax,ax
                    or ax,ax              ;#0043E758: 146:011300                 uv 01 01  1 668 01   
;  4294             jne @f
                    jne #0043E77A         ;#0043E75B: 165 1D                     v  00 00  1 668      
;  4295                 mov ax,256
                        mov ax,256        ;#0043E75D: 146:270 0001               uv 01 00  1 669      
;  4296                 add ax,[rdi+12]                     -- lpBuffer.keyScan
                        add ax,word[edi+12]  ;#0043E761: 146:003107 0C              uv 01 81  2 670 01   
;  4297                 --
;  4298                 -- Skip control, alt, shift and caps lock keys.
;  4299                 -- Note that shift, ctrl, alt, and caps lock keys will repeat 
;  4300                 -- while they are held down, so a routine which wants to detect
;  4301                 -- them pressed on their own cannot accept eg <Ctrl A>, or even
;  4302                 -- <Shift 1>, aka '!'. If you _do_ want to detect them on their 
;  4303                 -- own, just make a copy of this routine minus these lines.
;  4304                 -- Note values determined by experimentation, not documentation!
;  4305                 --
;  4306                 cmp ax,298  -- shift key
                        cmp ax,298        ;#0043E765: 146:201370 2A01            uv 00 01  1 672 01   
;  4307                 je @b
                        je #0043E6FB      ;#0043E76A: 164 8F                     v  00 00  1 672      
;  4308                 cmp ax,285  -- ctrl key
                        cmp ax,285        ;#0043E76C: 146:201370 1D01            uv 00 01  1 673      
;  4309                 je @b
                        je #0043E6FB      ;#0043E771: 164 88                     v  00 00  1 673      
;  4310                 cmp ax,312  -- alt key
                        cmp ax,312        ;#0043E773: 146:201370 3801            uv 00 01  1 674      
;  4311                 je @b
                        je #0043E6FB      ;#0043E778: 164 81                     v  00 00  1 674      
;  4312 -- actually, RDS lets this through...
;  4313 --              cmp ax,314  -- caps lock
;  4314 --              je @b
;  4315       @@:
;  4316         add rsp,24+8*5  -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD] and shadowspace/NumberOfEventsRead)
                add rsp,160               ;#0043E77A: 48:201304 A0000000         uv 10 10  1 675      
;  4317     [ELF64]
;  4318         pop al
;  4319     [64]
;  4320 --      jmp @f
;  4321         pop rdi
                pop rdi                   ;#0043E781: 48:137                     vu 80 00  1 675      
;  4322         mov r15,h4
                mov r15,h4                ;#0043E783: 49:277 0000000000000040    uv 8000 00  1 676      
;  4323         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043E78D: 48:213027                  uv 04 80  1 678    *80*
;  4324         mov [rdi],rax
                mov [rdi],rax             ;#0043E790: 48:211007                  vu 00 81  1 678      
;  4325         cmp rdx,r15
                cmp rdx,r15               ;#0043E793: 49:073327                  uv 00 8004  1 679      
;  4326         jle @f                          -- this jump almost always taken
                jle #0043E7A4             ;#0043E796: 176 0C                     v  00 00  1 679      
;  4327             sub qword[rbx+rdx*4-16],1   -- <any object> := wait_key() case [rare, tgt is usually an int]
                    sub qword[rbx+rdx*4-16],1  ;#0043E798: 48:203154223 F0 01         u  00 0C  3 680      
;  4328             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043E79E: 017204 363B0000            v  00 00  1 682      
;  4329       @@:
;  4330         ret
                ret                       ;#0043E7A4: 303                        np 00 00  2 683      
;  4331     []
;  4332 
;  4333 --/*
;  4334 BOOL WINAPI PeekConsoleInput(
;  4335   _In_   HANDLE ,
;  4336   _Out_  PINPUT_RECORD lpBuffer,
;  4337   _In_   DWORD nLength,
;  4338   _Out_  LPDWORD lpNumberOfEventsRead
;  4339 );
;  4340 ;typedef struct _INPUT_RECORD { // ir
;  4341 ;   WORD EventType;
;  4342 ;   union {
;  4343 ;       KEY_EVENT_RECORD KeyEvent;
;  4344 ;       MOUSE_EVENT_RECORD MouseEvent;
;  4345 ;       WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
;  4346 ;       MENU_EVENT_RECORD MenuEvent;
;  4347 ;       FOCUS_EVENT_RECORD FocusEvent;
;  4348 ;   } Event;
;  4349 ;} INPUT_RECORD;
;  4350 ;typedef struct _KEY_EVENT_RECORD { // ker
;  4351 ;   BOOL bKeyDown;
;  4352 ;   WORD wRepeatCount;
;  4353 ;   WORD wVirtualKeyCode;
;  4354 ;   WORD wVirtualScanCode;
;  4355 ;   union {
;  4356 ;       WCHAR UnicodeChar;
;  4357 ;       CHAR  AsciiChar;
;  4358 ;   } uChar;
;  4359 ;   DWORD dwControlKeyState;
;  4360 ;} KEY_EVENT_RECORD;
;  4361 
;  4362 lpBuffer:       ; INPUT_RECORD, KEY_EVENT_RECORD flavour
;  4363   .EventType dw ?   (0)
;  4364         .crud     dw ?      ; (uH? probably it must dword-align before the union)
;  4365     .keyDown    dd ? (4)
;  4366     .keyRepeat  dw ? (8)
;  4367     .keyVirt    dw ? (10)
;  4368     .keyScan    dw ? (12)
;  4369     .keyChar    db ? (14)
;  4370                 db ?
;  4371     .keyState   dd ? (16)
;  4372 --*/
;  4373 
;  4374 --/*
;  4375 global function wait_key(, :%opWaitKey)
;  4376 -- Get the next key pressed by the user.
;  4377 -- Wait until a key is pressed.
;  4378 end function
;  4379 --*/
;  4380 
;  4381   :%opWaitKey                      -- [edi]=wait_key()
;  4382 -------------
;  4383     [32]
;  4384         -- calling convention:
;  4385         --  lea edi,[p1]    -- result location
;  4386         --  call :%opWaitKey
;  4387         push edi
;  4388         cmp [stdout],0
;  4389         jne @f
;  4390             call :%n_initC -- (preserves eax)
;  4391       @@:
;  4392 --      call clear_debug [DEV]
;  4393     [PE32]
;  4394         sub esp,20 -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD])
;  4395         mov edi,esp -- (preserved over api calls)
;  4396         push ebx    -- DWORD NumberOfEventsRead(:=0)
;  4397       @@:
;  4398         push esp                                -- lpNumberOfEventsRead
;  4399         push 1                                  -- nLength
;  4400         push edi                                -- lpBuffer
;  4401         push [stdin]                            -- hConsoleInput
;  4402         call "kernel32.dll","ReadConsoleInputA"
;  4403         cmp word[edi],0x0001                    -- lpBuffer.EventType=KEY_EVENT?
;  4404         jne @b
;  4405         cmp dword[edi+4],0x00000001             -- lpBuffer.keyDown(ignore key up events)
;  4406         jne @b
;  4407         xor eax,eax
;  4408         mov al,[edi+14]                         -- lpBuffer.keyChar
;  4409         or ax,ax
;  4410         jne @f
;  4411             mov ax,256
;  4412             add ax,[edi+12]                     -- lpBuffer.keyScan
;  4413             --
;  4414             -- Skip control, alt, shift and caps lock keys.
;  4415             -- Note that shift, ctrl, alt, and caps lock keys will repeat 
;  4416             -- while they are held down, so a routine which wants to detect
;  4417             -- them pressed on their own cannot accept eg <Ctrl A>, or even
;  4418             -- <Shift 1>, aka '!'. If you _do_ want to detect them on their 
;  4419             -- own, just make a copy of this routine minus these lines.
;  4420             -- Note values determined by experimentation, not documentation!
;  4421             --
;  4422             cmp ax,298  -- shift key
;  4423             je @b
;  4424             cmp ax,285  -- ctrl key
;  4425             je @b
;  4426             cmp ax,312  -- alt key
;  4427             je @b
;  4428 -- actually, RDS lets this through...
;  4429 --              cmp ax,314  -- caps lock
;  4430 --              je @b
;  4431 --          xor ah,ah
;  4432       @@:
;  4433         add esp,24  -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD] and DWORD NumberOfEventsRead)
;  4434     [ELF32]
;  4435         pop al
;  4436     [32]
;  4437         pop edi
;  4438         mov edx,[edi]
;  4439         mov [edi],eax
;  4440         cmp edx,h4
;  4441         jle @f                          -- this jump almost always taken
;  4442             sub dword[ebx+edx*4-8],1    -- <any object> := wait_key() case [rare, tgt is usually an int]
;  4443             jz :%pDealloc
;  4444       @@:       
;  4445         ret
;  4446     [64]
;  4447         -- calling convention:
;  4448         --  lea rdi,[p1]    -- result location
;  4449         --  call :%opWaitKey
;  4450         push rdi
                push rdi                  ;#0043E7A5: 48:127                     uv 00 80  1 685      
;  4451         cmp [stdout],0
                cmp qword[#004031B0] (stdout),0  ;#0043E7A7: 48:203075 014AFCFF 00      u  00 00  2 686      
;  4452         jne @f
                jne #0043E7B6             ;#0043E7AF: 165 05                     v  00 00  1 687      
;  4453             call :%n_initC -- (preserves eax)
                    call #0043DCFD (:%n_initC)  ;#0043E7B1: 350 47F5FFFF               v  00 00  1 688      
;  4454       @@:
;  4455 --      call clear_debug [DEV]
;  4456     [PE64]
;  4457         sub rsp,24 -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD])   (rounded up to whole qwords)
                sub rsp,24                ;#0043E7B6: 48:203354 18               uv 10 10  1 689      
;  4458         mov rdi,rsp -- (preserved over api calls)
                mov rdi,rsp               ;#0043E7BA: 48:213374                  uv 80 10  1 690 10   
;  4459         sub rsp,8*5
                sub rsp,40                ;#0043E7BD: 48:203354 28               vu 10 10  1 690      
;  4460       @@:
;  4461         mov [rsp+32],rbx
                mov [rsp+32],rbx          ;#0043E7C1: 48:211134044 20            uv 00 18  1 693    *10*
;  4462         lea r9,[rsp+32]                         -- lpNumberOfEventsRead
                lea r9,[rsp+32]           ;#0043E7C6: 4C:215114044 20            vu 200 10  1 693      
;  4463         mov r8,1                                -- nLength
                mov r8,1                  ;#0043E7CB: 49:307300 01000000         uv 100 00  1 694      
;  4464         mov rdx,rdi                             -- lpBuffer
                mov rdx,rdi               ;#0043E7D2: 48:213327                  vu 04 80  1 694      
;  4465         mov rcx,[stdin]                         -- hConsoleInput
                mov rcx,[#004031A8] (stdin)  ;#0043E7D5: 48:213015 CC49FCFF         uv 02 00  1 695      
;  4466         call "kernel32.dll","ReadConsoleInputA"
                call [#004010F8] (ReadConsoleInputA)  ;#0043E7DC: 377025 1629FCFF            np 00 00  2 696      
;  4467         cmp word[rdi],0x0001                    -- lpBuffer.EventType=KEY_EVENT?
                cmp word[rdi],1           ;#0043E7E2: 146:203077 01              uv 00 80  2 698      
;  4468         jne @b
                jne #0043E7C1             ;#0043E7E6: 165 D9                     v  00 00  1 699      
;  4469         cmp dword[rdi+4],0x00000001             -- lpBuffer.keyDown(ignore key up events)
                cmp dword[rdi+4],1        ;#0043E7E8: 203177 04 01               u  00 80  2 700      
;  4470         jne @b
                jne #0043E7C1             ;#0043E7EC: 165 D3                     v  00 00  1 701      
;  4471         xor rax,rax
                xor rax,rax               ;#0043E7EE: 48:061300                  uv 01 01  1 702      
;  4472         mov al,[rdi+14]                         -- lpBuffer.keyChar
                mov al,[edi+14]           ;#0043E7F1: 212107 0E                  uv 01 80  1 703 01   
;  4473         or ax,ax
                or ax,ax                  ;#0043E7F4: 146:011300                 uv 01 01  1 704 01   
;  4474         jne @f
                jne #0043E818             ;#0043E7F7: 165 1F                     v  00 00  1 704      
;  4475             mov ax,256
                    mov ax,256            ;#0043E7F9: 146:270 0001               uv 01 00  1 705      
;  4476             add ax,[rdi+12]                     -- lpBuffer.keyScan
                    add ax,word[edi+12]   ;#0043E7FD: 146:003107 0C              uv 01 81  2 706 01   
;  4477             --
;  4478             -- Skip control, alt, shift and caps lock keys.
;  4479             -- Note that shift, ctrl, alt, and caps lock keys will repeat 
;  4480             -- while they are held down, so a routine which wants to detect
;  4481             -- them pressed on their own cannot accept eg <Ctrl A>, or even
;  4482             -- <Shift 1>, aka '!'. If you _do_ want to detect them on their 
;  4483             -- own, just make a copy of this routine minus these lines.
;  4484             -- Note values determined by experimentation, not documentation!
;  4485             --
;  4486             cmp ax,298  -- shift key
                    cmp ax,298            ;#0043E801: 146:201370 2A01            uv 00 01  1 708 01   
;  4487             je @b
                    je #0043E7C1          ;#0043E806: 164 B9                     v  00 00  1 708      
;  4488             cmp ax,285  -- ctrl key
                    cmp ax,285            ;#0043E808: 146:201370 1D01            uv 00 01  1 709      
;  4489             je @b
                    je #0043E7C1          ;#0043E80D: 164 B2                     v  00 00  1 709      
;  4490             cmp ax,312  -- alt key
                    cmp ax,312            ;#0043E80F: 146:201370 3801            uv 00 01  1 710      
;  4491             je @b
                    je #0043E7C1          ;#0043E814: 164 AB                     v  00 00  1 710      
;  4492 -- actually, RDS lets this through...
;  4493 --              cmp ax,314  -- caps lock
;  4494 --              je @b
;  4495             xor ah,ah
                    xor ah,ah             ;#0043E816: 060344                     uv 01 01  1 711      
;  4496       @@:
;  4497 --      add rsp,24+8*5  -- sizeof(INPUT_RECORD[/KEY_EVENT_RECORD] and shadowspace/DWORD NumberOfEventsRead)
;  4498         add rsp,24+40   -- (19/8/15 oops, above became add rsp,160 ie 32*5)
                add rsp,64                ;#0043E818: 48:203304 40               vu 10 10  1 711      
;  4499     [ELF64]
;  4500         pop al
;  4501     [64]
;  4502         pop rdi
                pop rdi                   ;#0043E81C: 48:137                     uv 80 00  1 712      
;  4503         mov r15,h4
                mov r15,h4                ;#0043E81E: 49:277 0000000000000040    vu 8000 00  1 712      
;  4504         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043E828: 48:213027                  uv 04 80  1 715    *80*
;  4505         mov [rdi],rax
                mov [rdi],rax             ;#0043E82B: 48:211007                  vu 00 81  1 715      
;  4506         cmp rdx,r15
                cmp rdx,r15               ;#0043E82E: 49:073327                  uv 00 8004  1 716      
;  4507         jle @f                          -- this jump almost always taken
                jle #0043E83F             ;#0043E831: 176 0C                     v  00 00  1 716      
;  4508             sub qword[rbx+rdx*4-16],1   -- <any object> := wait_key() case [rare, tgt is usually an int]
                    sub qword[rbx+rdx*4-16],1  ;#0043E833: 48:203154223 F0 01         u  00 0C  3 717      
;  4509             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043E839: 017204 9B3A0000            v  00 00  1 719      
;  4510       @@:       
;  4511         ret
                ret                       ;#0043E83F: 303                        np 00 00  2 720      
;  4512     []
;  4513 
;  4514 --    ::wait_key
;  4515 ------------------
;  4516 --    @@:
;  4517 --      call clear_debug
;  4518 --      invoke  ReadConsoleInput,[stdin],lpBuffer,1,lpEventsRead
;  4519 --      cmp [lpBuffer.EventType],0x0001 --KEY_EVENT
;  4520 --      jne @b
;  4521 --              cmp [lpBuffer.keyDown],0x00000001 --ignore key up events
;  4522 --              jne @b
;  4523 
;  4524 --              xor eax,eax
;  4525 --              mov al,[lpBuffer.keyChar]
;  4526 --              or ax,ax
;  4527 --              jne @f
;  4528 --              mov ax,256
;  4529 --              add ax,[lpBuffer.keyScan]
;  4530 --
;  4531 -- Skip control, alt, shift and caps lock keys.
;  4532 -- Note that shift, ctrl, alt, and caps lock keys will repeat 
;  4533 -- while they are held down, so a routine which wants to detect
;  4534 -- them pressed on their own cannot accept eg <Ctrl A>, or even
;  4535 -- <Shift 1>, aka '!'. If you _do_ want to detect them on their 
;  4536 -- own, just make a copy of this routine minus these lines.
;  4537 -- Note values determined by experimentation, not documentation!
;  4538 --
;  4539 --              cmp ax,298  -- shift key
;  4540 --              je @b
;  4541 --              cmp ax,285  -- ctrl key
;  4542 --              je @b
;  4543 --              cmp ax,312  -- alt key
;  4544 --              je @b
;  4545 -- actually, RDS lets this through...
;  4546 --       cmp ax,314  -- caps lock
;  4547 --       je @b
;  4548 --              ret
;  4549 --        @@:
;  4550 --       xor eax,eax
;  4551 --       mov al,[lpBuffer.keyChar]
;  4552 -- instead I've just used the byte from keyState, again, maybe
;  4553 -- my definition of lbBuffer is not quite right, but it works.
;  4554 --              xor ah,ah
;  4555 --      ret
;  4556 --endp
;  4557 
;  4558       ::fin
;  4559       }
;  4560 --test with: (and later make pilx86.e emit)
;  4561 --#ilASM{ mov eax,[fn]
;  4562 --      call :%opGetc
;  4563 --      mov [ch],eax }
;  4564 
;  4565 --/*
;  4566 --[DEV] untested (search for opPuts1Sq [in this source]):
;  4567 --procedure puts1seq()--sequence s)
;  4568 --sequence s
;  4569 --  #ilASM{
;  4570 --      [32]
;  4571 --          pop esi
;  4572 --          mov [s],esi     -- (incref'd on the push in :%n_opPuts1Sq)
;  4573 --      [64]
;  4574 --          pop rsi
;  4575 --          mov [s],rsi     -- (incref'd on the push in :%n_opPuts1Sq)
;  4576 --        }
;  4577 ----DEV or use mov edx,routine_id("toStringN") etc
;  4578 --  s = toString(s,e65sfics)
;  4579 ----DEV newsize [PE32] (or, use something from above...)
;  4580 --  #ilASM{
;  4581 --      [PE32]
;  4582 --          mov edx,[s]
;  4583 --          mov ecx,[ebx+edx*4-12]      -- length
;  4584 --          shl edx,2
;  4585 --          pop eax
;  4586 --          push ebx                    -- lpOverlapped (NULL)
;  4587 --          push esp                    -- lpNumberOfBytesWritten
;  4588 --          push ecx                    -- nNumberOfBytesToWrite
;  4589 --          push edx                    -- lpBuffer
;  4590 --          push eax                    -- hFile,
;  4591 --          call "kernel32.dll","WriteFile"
;  4592 --      [ELF32]
;  4593 --          pop al
;  4594 --      [PE64]
;  4595 --          pop al
;  4596 --      [ELF64]
;  4597 --          pop al
;  4598 --        }
;  4599 --end procedure
;  4600 --*/
;  4601 --/*
;  4602 #ilASM{
;  4603   :%n_opPuts1Sq
;  4604     [32]
;  4605         push eax    -- stdout/stderr (DEV from where? update:it is [stdout|stderr] by the time we get here)
;  4606         add dword[ebx+edx*4-8],1    -- incref
;  4607         push edx    -- the dword sequence to be displayed
;  4608     [64]
;  4609         pop al
;  4610       }
;  4611 --better: use the mov edx,routine_id() thing...
;  4612 puts1seq()
;  4613 #ilASM{ ret }
;  4614 --*/
;  4615 
;  4616 --DEV we might want to allow forward types after all...
;  4617 -- for now, just make them local...
;  4618 --global 
;  4619 type lock_type(integer t)
    mov rcx,[rbp] (t)                     ;#0043C80A: 48:213115 00               uv 02 20  1   1      
    mov r15,h4                            ;#0043C80E: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rcx,r15                           ;#0043C818: 4C:071371                  uv 00 8002  1   2      
    jl #0043C829                          ;#0043C81B: 174 0C                     v  00 00  1   2      
    mov rcx,1049                          ;#0043C81D: 48:307301 19040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043C824: 350 2F620000               v  00 00  1   3      
;  4620     return t = LOCK_SHARED or t = LOCK_EXCLUSIVE
    cmp rcx,1                             ;#0043C829: 48:203371 01               uv 00 02  1   4      
    je #0043C83B                          ;#0043C82D: 164 0C                     v  00 00  1   4      
    cmp rcx,2                             ;#0043C82F: 48:203371 02               uv 00 02  1   5      
    je #0043C83B                          ;#0043C833: 164 06                     v  00 00  1   5      
    mov [rbp-8] (symtab[1050]),rbx        ;#0043C835: 48:211135 F8               uv 00 28  1   6      
    jmp #0043C843                         ;#0043C839: 353 08                     v  00 00  1   6      
    mov qword[rbp-8] (symtab[1050]),1     ;#0043C83B: 48:307105 F8 01000000      uv 00 20  1   7      
    mov rax,[rbp-8] (symtab[1050])        ;#0043C843: 48:213105 F8               vu 01 20  1   7      
    jmp #0044298D (:%opRetf)              ;#0043C847: 351 41610000               v  00 00  1   8      
;  4621 end type
;  4622 
;  4623 --global 
;  4624 type byte_range(sequence r)
    mov rdi,[rbp] (r)                     ;#0043C750: 48:213175 00               uv 80 20  1   1      
    mov r15,h4                            ;#0043C754: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0043C75E: 4C:071377                  uv 00 8080  1   2      
    jl #0043C76A                          ;#0043C761: 174 07                     v  00 00  1   2      
    test byte[rbx+rdi*4-1],#80            ;#0043C763: 366104273 FF 80            u  00 88  2   3      
    jne #0043C776                         ;#0043C768: 165 0C                     v  00 00  1   4      
    mov rcx,1053                          ;#0043C76A: 48:307301 1D040000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0043C771: 350 E2620000               v  00 00  1   5      
;  4625     if length(r) = 0 then
    mov rsi,[rbx+rdi*4-24]                ;#0043C776: 48:48:213164273 E8         uv 40 88  1   6      
    cmp rsi,0                             ;#0043C77C: 48:203376 00               uv 00 40  1   7 40   
    jne #0043C790                         ;#0043C780: 165 0E                     v  00 00  1   7      
;  4626         return 1
    mov rax,1                             ;#0043C782: 48:307300 01000000         uv 01 00  1   8      
    jmp #0044298D (:%opRetf)              ;#0043C789: 351 FF610000               v  00 00  1   8      
    jmp #0043C805                         ;#0043C78E: 353 75                     v  00 00  1   9      
;  4627     elsif length(r) = 2 and r[1] <= r[2] then
    mov rcx,[rbx+rdi*4-24]                ;#0043C790: 48:48:213114273 E8         uv 02 88  1  10      
    cmp rcx,2                             ;#0043C796: 48:203371 02               uv 00 02  1  11 02   
    jne #0043C7FD                         ;#0043C79A: 165 61                     v  00 00  1  11      
    mov rdi,1                             ;#0043C79C: 48:307307 01000000         uv 80 00  1  12      
    lea rcx,[rbp-16] (symtab[1055])       ;#0043C7A3: 48:215115 F0               vu 02 20  1  12      
    mov rsi,[rbp] (r)                     ;#0043C7A7: 48:213165 00               uv 40 20  1  13      
    mov rdx,1053                          ;#0043C7AB: 48:307302 1D040000         vu 04 00  1  13      
    call #00441675 (:%pSubse1)            ;#0043C7B2: 350 BE4E0000               v  00 00  1  14      
    mov rdi,2                             ;#0043C7B7: 48:307307 02000000         uv 80 00  1  15      
    lea rcx,[rbp-24] (symtab[1056])       ;#0043C7BE: 48:215115 E8               vu 02 20  1  15      
    mov rsi,[rbp] (r)                     ;#0043C7C2: 48:213165 00               uv 40 20  1  16      
    mov rdx,1053                          ;#0043C7C6: 48:307302 1D040000         vu 04 00  1  16      
    call #00441675 (:%pSubse1)            ;#0043C7CD: 350 A34E0000               v  00 00  1  17      
    mov rdi,[rbp-24] (symtab[1056])       ;#0043C7D2: 48:213175 E8               uv 80 20  1  18      
    mov rax,[rbp-16] (symtab[1055])       ;#0043C7D6: 48:213105 F0               vu 01 20  1  18      
    mov rsi,1056                          ;#0043C7DA: 48:307306 20040000         uv 40 00  1  19      
    mov rdx,1055                          ;#0043C7E1: 48:307302 1F040000         vu 04 00  1  19      
    call #0043FA81 (:%opJcc)              ;#0043C7E8: 350 94320000               v  00 00  1  20      
    jg #0043C7FD                          ;#0043C7ED: 177 0E                     v  00 00  1  21      
;  4628         return 1
    mov rax,1                             ;#0043C7EF: 48:307300 01000000         uv 01 00  1  22      
    jmp #0044298D (:%opRetf)              ;#0043C7F6: 351 92610000               v  00 00  1  22      
    jmp #0043C805                         ;#0043C7FB: 353 08                     v  00 00  1  23      
;  4629     else
;  4630         return 0
    xor rax,rax                           ;#0043C7FD: 48:061300                  uv 01 01  1  24      
    jmp #0044298D (:%opRetf)              ;#0043C800: 351 88610000               v  00 00  1  24      
;  4631     end if
    call #00442D91 (:%pBadRetf)           ;#0043C805: 350 87650000               v  00 00  1  25      
;  4632 end type
;  4633 
;  4634 --/*
;  4635 function process_byterange(atom fhandle, sequence byterange)
;  4636 atom offsetLO,offsetHI,bytesLO,bytesHI
;  4637     if length(byterange)=0 then
;  4638         if c_func(xGetFileInformationByHandle, {fhandle,pBHFI})=0 then ?9/0 end if
;  4639         offsetLO = 0
;  4640         offsetHI = 0
;  4641         bytesLO = peek4u(pBHFI+BHFI_FSLO)
;  4642         bytesHI = peek4u(pBHFI+BHFI_FSHI)
;  4643     else
;  4644         offsetLO = byterange[1]
;  4645         bytesLO = byterange[2]-offsetLO
;  4646         offsetHI = floor(offsetLO/#100000000)
;  4647         offsetLO = and_bits(offsetLO,#FFFFFFFF)
;  4648         bytesHI = floor(bytesLO/#100000000)
;  4649         bytesLO = and_bits(bytesLO,#FFFFFFFF)
;  4650     end if
;  4651     return {fhandle,offsetLO,offsetHI,bytesLO,bytesHI}
;  4652 end function
;  4653 --*/
;  4654 
;  4655 constant UNLOCK = 0
;  4656 function flock(integer fn, integer locktype, byte_range byterange)
    mov rsi,[rbp] (fn)                    ;#0043C42D: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0043C431: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0043C43B: 4C:071376                  uv 00 8040  1   2      
    jl #0043C44C                          ;#0043C43E: 174 0C                     v  00 00  1   2      
    mov rcx,1060                          ;#0043C440: 48:307301 24040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043C447: 350 0C660000               v  00 00  1   3      
    mov rdi,[rbp-8] (locktype)            ;#0043C44C: 48:213175 F8               uv 80 20  1   4      
    mov r15,h4                            ;#0043C450: 49:277 0000000000000040    vu 8000 00  1   4      
    cmp rdi,r15                           ;#0043C45A: 4C:071377                  uv 00 8080  1   5      
    jl #0043C46B                          ;#0043C45D: 174 0C                     v  00 00  1   5      
    mov rcx,1061                          ;#0043C45F: 48:307301 25040000         uv 02 00  1   6      
    call #00442A58 (:%opTchkFail)         ;#0043C466: 350 ED650000               v  00 00  1   6      
    mov rcx,4                             ;#0043C46B: 48:307301 04000000         uv 02 00  1   7      
    mov rdx,1052                          ;#0043C472: 48:307302 1C040000         vu 04 00  1   7      
    push #0043C491                        ;#0043C479: 150 91C44300               uv 00 00  1   8      
    push 1062                             ;#0043C47E: 48:150 26040000            vu 00 00  1   8      
    push #0043C750                        ;#0043C484: 150 50C74300               uv 00 00  1   9      
    push qword[rbp-16] (byterange)        ;#0043C489: 377165 F0                  np 00 20  2  10      
    jmp #00442A1F (:%opTchk)              ;#0043C48C: 351 8E650000               v  00 00  1  12      
;  4657 --function flock(integer fn, lock_type locktype, byte_range byterange)
;  4658 -- locktype is UNLOCK/LOCK_SHARED/LOCK_EXCLUSIVE (0/1/2) (NB: not a lock_type)
;  4659 integer iThis
;  4660 atom offset, bytes
;  4661 integer res
;  4662 
;  4663     if not finit then initF() end if
    mov rcx,[#00403178] (finit)           ;#0043C491: 48:213015 E06CFCFF         uv 02 00  1  13      
    test rcx,rcx                          ;#0043C498: 48:205311                  uv 00 02  1  14 02   
    jne #0043C4B9                         ;#0043C49B: 165 1C                     v  00 00  1  14      
    xor rcx,rcx                           ;#0043C49D: 48:061311                  uv 02 02  1  15      
    mov rdx,967                           ;#0043C4A0: 48:307302 C7030000         vu 04 00  1  15      
    call #004428DB (:%opFrame) (initF)    ;#0043C4A7: 350 2F640000               v  00 00  1  16      
    mov qword[retaddr],#0043C4B9          ;#0043C4AC: 48:307105 20 B9C44300      uv 00 20  1  17      
    jmp #0043B5D9 (code:initF)            ;#0043C4B4: 351 20F1FFFF               v  00 00  1  17      
;  4664     iThis = get_this(fn)
    mov rcx,6                             ;#0043C4B9: 48:307301 06000000         uv 02 00  1  18      
    mov rdx,1010                          ;#0043C4C0: 48:307302 F2030000         vu 04 00  1  18      
    call :%opFrame (get_this)             ;#0043C4C7: 350 0F640000               v  00 00  1  19      
    mov rdi,[rbp+40] (prevebp)            ;#0043C4CC: 48:213175 28               uv 80 20  1  20      
    mov rax,[rdi]                         ;#0043C4D0: 48:213007                  uv 01 80  1  23 80 *80*
    mov [rbp] (fn),rax                    ;#0043C4D3: 48:211105 00               uv 00 21  1  24 01   
    mov qword[retaddr],#0043C4E4          ;#0043C4D7: 48:307105 20 E4C44300      vu 00 20  1  24      
    jmp #0043C667 (code:get_this)         ;#0043C4DF: 351 83010000               v  00 00  1  25      
    mov [rbp-24] (iThis),rax              ;#0043C4E4: 48:211105 E8               uv 00 21  1  26      
;  4665     if length(byterange)=0 then
    mov rsi,[rbp-16] (byterange)          ;#0043C4E8: 48:213165 F0               vu 40 20  1  26      
    mov rdi,[rbx+rsi*4-24]                ;#0043C4EC: 48:48:213174263 E8         uv 80 48  1  29    *40*
    cmp rdi,0                             ;#0043C4F2: 48:203377 00               uv 00 80  1  30 80   
    jne #0043C533                         ;#0043C4F6: 165 3B                     v  00 00  1  30      
;  4666         offset = 0
    mov [rbp-32] (offset),rbx             ;#0043C4F8: 48:211135 E0               uv 00 28  1  31      
;  4667         #ilASM{
;  4668             [PE32]
;  4669                 mov esi,[iThis]
;  4670                 sub esp,sizeof_BHFI
;  4671                 push esp                                    -- lpFileInformation
;  4672                 push dword[ebx+esi*4+HNDL]                  -- hFile
;  4673                 call "kernel32.dll","GetFileInformationByHandle"
;  4674 --              test eax,eax
;  4675 --              jz ??? [DEV]
;  4676 --              fld qword[esp+BHFI_FSHI]    --DEV are these the wrong way round?
;  4677                 mov edx,[esp+BHFI_FSHI]
;  4678                 lea edi,[bytes]
;  4679                 mov [esp+BHFI_NLINK],edx
;  4680                 fild qword[esp+BHFI_FSLO]
;  4681                 add esp,sizeof_BHFI
;  4682                 call :%pStoreFlt
;  4683             [ELF32]
;  4684                 pop al
;  4685             [PE64]
;  4686                 mov rsi,[iThis]
                        mov rsi,[rbp-24] (iThis)  ;#0043C4FC: 48:213165 E8               vu 40 20  1  31      
;  4687                 sub rsp,sizeof_BHFI64
                        sub rsp,56        ;#0043C500: 48:203354 38               uv 10 10  1  32      
;  4688                 mov rdx,rsp
                        mov rdx,rsp       ;#0043C504: 48:213324                  uv 04 10  1  33 10   
;  4689                 sub rsp,8*5
                        sub rsp,40        ;#0043C507: 48:203354 28               vu 10 10  1  33      
;  4690 --              (rdx already set)                               -- lpFileInformation
;  4691                 mov rcx,[rbx+rsi*4+HNDL64]                      -- hFile
                        mov rcx,[rbx+rsi*4]  ;#0043C50B: 48:213014263               uv 02 48  1  34      
;  4692                 call "kernel32.dll","GetFileInformationByHandle"
                        call [GetFileInformationByHandle]  ;#0043C50F: 377025 7B4BFCFF            np 00 00  2  35      
;  4693                 add rsp,8*5
                        add rsp,40        ;#0043C515: 48:203304 28               uv 10 10  1  37      
;  4694 --              test rax,rax
;  4695 --              jz ??? [DEV]
;  4696 --              fld qword[esp+BHFI_FSHI]    --DEV are these the wrong way round?
;  4697                 mov edx,[esp+BHFI_FSHI]
                        mov edx,[rsp+32]  ;#0043C519: 213124044 20               uv 04 10  1  40 10 *10*
;  4698                 lea rdi,[bytes]
                        lea rdi,[rbp-40] (bytes)  ;#0043C51D: 48:215175 D8               vu 80 20  1  40      
;  4699                 mov [esp+BHFI_NLINK],edx
                        mov [rsp+40],edx  ;#0043C521: 211124044 28               uv 00 14  1  41      
;  4700                 fild qword[esp+BHFI_FSLO]
                        fild qword[rsp+36]  ;#0043C525: 337154044 24               np 00 10  3  42      
;  4701                 add esp,sizeof_BHFI64
                        add esp,56        ;#0043C529: 203304 38                  uv 10 10  1  45      
;  4702                 call :%pStoreFlt
                        call #004421B0 (:%pStoreFlt)  ;#0043C52C: 350 7F5C0000               v  00 00  1  45      
;  4703             [ELF64]
;  4704                 pop al
;  4705             []
;  4706               }
    jmp #0043C59C                         ;#0043C531: 353 69                     v  00 00  1  46      
;  4707     else
;  4708         offset = byterange[1]
    mov rdi,1                             ;#0043C533: 48:307307 01000000         uv 80 00  1  47      
    lea rcx,[rbp-32] (offset)             ;#0043C53A: 48:215115 E0               vu 02 20  1  47      
    mov rdx,1062                          ;#0043C53E: 48:307302 26040000         uv 04 00  1  48      
    call #00441675 (:%pSubse1)            ;#0043C545: 350 2B510000               v  00 00  1  48      
    mov rcx,[rbp-32] (offset)             ;#0043C54A: 48:213115 E0               uv 02 20  1  49      
    mov r15,h4                            ;#0043C54E: 49:277 0000000000000040    vu 8000 00  1  49      
    cmp rcx,r15                           ;#0043C558: 4C:071371                  uv 00 8002  1  50      
    jl #0043C570                          ;#0043C55B: 174 13                     v  00 00  1  50      
    cmp byte[rbx+rcx*4-1],#12             ;#0043C55D: 200174213 FF 12            u  00 0A  2  51      
    je #0043C570                          ;#0043C562: 164 0C                     v  00 00  1  52      
    mov rcx,1064                          ;#0043C564: 48:307301 28040000         uv 02 00  1  53      
    call #00442A58 (:%opTchkFail)         ;#0043C56B: 350 E8640000               v  00 00  1  53      
;  4709         bytes = byterange[2]-offset
    mov rdi,2                             ;#0043C570: 48:307307 02000000         uv 80 00  1  54      
    lea rcx,[rbp-64] (symtab[1068])       ;#0043C577: 48:215115 C0               vu 02 20  1  54      
    mov rsi,[rbp-16] (byterange)          ;#0043C57B: 48:213165 F0               uv 40 20  1  55      
    mov rdx,1062                          ;#0043C57F: 48:307302 26040000         vu 04 00  1  55      
    call #00441675 (:%pSubse1)            ;#0043C586: 350 EA500000               v  00 00  1  56      
    lea rdi,[rbp-40] (bytes)              ;#0043C58B: 48:215175 D8               uv 80 20  1  57      
    mov rcx,[rbp-64] (symtab[1068])       ;#0043C58F: 48:213115 C0               vu 02 20  1  57      
    mov rax,[rbp-32] (offset)             ;#0043C593: 48:213105 E0               uv 01 20  1  58      
    call #0043F4D8 (:%opSub)              ;#0043C597: 350 3C2F0000               v  00 00  1  58      
;  4710     end if
;  4711     #ilASM{
;  4712         [PE32]
;  4713             sub esp,sizeof_OVERLAPPED
;  4714             mov edx,esp
;  4715             mov eax,[offset]
;  4716             mov ecx,[bytes]
;  4717             push ebx                        -- bytesHi
;  4718             push ecx                        -- bytesLo
;  4719             mov [edx+OV_OFFHI],ebx          -- OVERLAPPED.offsetHi
;  4720             mov [edx+OV_OFFSET],eax         -- OVERLAPPED.offsetLo
;  4721             cmp eax,h4
;  4722             jl @f
;  4723                 sub esp,8
;  4724                 fld qword[ebx+eax*4]
;  4725                 fistp qword[esp]
;  4726                 pop dword[edx+OV_OFFSET]    -- OVERLAPPED.offsetLo
;  4727                 pop dword[edx+OV_OFFHI]     -- OVERLAPPED.offsetHi
;  4728           @@:
;  4729             cmp ecx,h4
;  4730             jl @f
;  4731                 fld qword[ebx+ecx*4]
;  4732                 fistp qword[esp]
;  4733           @@:
;  4734             mov edi,[locktype]
;  4735             pop ecx                         -- nNumberOfBytesTo(Un)LockLow
;  4736             pop eax                         -- nNumberOfBytesTo(Un)LockHigh
;  4737             mov esi,[iThis]
;  4738             mov [edx+OV_EVENT],ebx          -- OVERLAPPED.hEvent:=0
;  4739             push edx                        -- lpOverlapped
;  4740             push eax                        -- nNumberOfBytesToLockHigh
;  4741             push ecx                        -- nNumberOfBytesToLockLow
;  4742             push ebx                        -- dwReserved
;  4743             cmp edi,UNLOCK
;  4744             je :unlock
;  4745             and edi,2                       -- LOCKFILE_EXCLUSIVE_LOCK (keep)
;  4746             or edi,1                        -- LOCKFILE_FAIL_IMMEDIATELY (add)
;  4747 
;  4748 --          push edx                        -- lpOverlapped
;  4749 --          push eax                        -- nNumberOfBytesToLockHigh
;  4750 --          push ecx                        -- nNumberOfBytesToLockLow
;  4751 --          push ebx                        -- dwReserved
;  4752             push edi                        -- dwFlags
;  4753             push dword[ebx+esi*4+HNDL]      -- hFile
;  4754             call "kernel32.dll","LockFileEx"
;  4755             jmp @f
;  4756           ::unlock
;  4757 --          push edx                        -- lpOverlapped
;  4758 --          push eax                        -- nNumberOfBytesToUnlockHigh
;  4759 --          push ecx                        -- nNumberOfBytesToUnlockLow
;  4760 --          push ebx                        -- dwReserved
;  4761             push dword[ebx+esi*4+HNDL]      -- hFile
;  4762             call "kernel32.dll","UnlockFileEx"
;  4763           @@:
;  4764             add esp,sizeof_OVERLAPPED
;  4765             mov [res],eax
;  4766         [ELF32]
;  4767             pop al
;  4768         [PE64]
;  4769             sub rsp,sizeof_OVERLAPPED64
                    sub rsp,24            ;#0043C59C: 48:203354 18               uv 10 10  1  59      
;  4770             mov r15,h4
                    mov r15,h4            ;#0043C5A0: 49:277 0000000000000040    vu 8000 00  1  59      
;  4771             mov rdx,rsp
                    mov rdx,rsp           ;#0043C5AA: 48:213324                  uv 04 10  1  60      
;  4772             mov rax,[offset]
                    mov rax,[rbp-32] (offset)  ;#0043C5AD: 48:213105 E0               vu 01 20  1  60      
;  4773             mov rcx,[bytes]
                    mov rcx,[rbp-40] (bytes)  ;#0043C5B1: 48:213115 D8               uv 02 20  1  61      
;  4774             mov qword[rdx+OV_OFFSET],rax    -- OVERLAPPED.offsetLo (and OV_OFFHI)
                    mov [rdx+8],rax       ;#0043C5B5: 48:211102 08               uv 00 05  1  63    *04*
;  4775             push rcx
                    push rcx              ;#0043C5B9: 48:121                     vu 00 02  1  63      
;  4776             cmp rax,r15
                    cmp rax,r15           ;#0043C5BB: 49:073307                  uv 00 8001  1  64      
;  4777             jl @f
                    jl #0043C5C6          ;#0043C5BE: 174 06                     v  00 00  1  64      
;  4778                 fld tbyte[rbx+rax*4]
                        fld tbyte[rbx+rax*4]  ;#0043C5C0: 333054203                  np 00 09  3  65      
;  4779                 fistp qword[rdx+OV_OFFSET]  -- OVERLAPPED.offsetLo (and OV_OFFHI)
                        fistp qword[rdx+8]  ;#0043C5C3: 337172 08                  np 00 04  6  68      
;  4780           @@:
;  4781             cmp rcx,r15
                    cmp rcx,r15           ;#0043C5C6: 49:073317                  uv 00 8002  1  74      
;  4782             jl @f
                    jl #0043C5D1          ;#0043C5C9: 174 06                     v  00 00  1  74      
;  4783                 fld tbyte[rbx+rcx*4]
                        fld tbyte[rbx+rcx*4]  ;#0043C5CB: 333054213                  np 00 0A  3  75      
;  4784                 fistp qword[rsp]
                        fistp qword[rsp]  ;#0043C5CE: 337074044                  np 00 10  6  78      
;  4785           @@:
;  4786             mov rdi,[locktype]
                    mov rdi,[rbp-8] (locktype)  ;#0043C5D1: 48:213175 F8               uv 80 20  1  84      
;  4787             mov r10,rbx
                    mov r10,rbx           ;#0043C5D5: 4C:213323                  vu 400 08  1  84      
;  4788             mov rax,rbx
                    mov rax,rbx           ;#0043C5D8: 48:213303                  uv 01 08  1  85      
;  4789             mov r10d,[rsp]                      -- (DWORD) nNumberOfBytesTo(Un)LockLow
                    mov r10d,[rsp]        ;#0043C5DB: 44:213024044               vu 400 10  1  85      
;  4790             mov eax,[rsp+4]                     -- (DWORD) nNumberOfBytesTo(Un)LockHigh
                    mov eax,[rsp+4]       ;#0043C5DF: 213104044 04               uv 01 10  1  86      
;  4791             sub rsp,8*6
                    sub rsp,48            ;#0043C5E3: 48:203354 30               vu 10 10  1  86      
;  4792             mov rcx,[rbx+rsi*4+HNDL64]
                    mov rcx,[rbx+rsi*4]   ;#0043C5E7: 48:213014263               uv 02 48  1  87      
;  4793             mov [rdx+OV_EVENT],rbx              -- OVERLAPPED.hEvent:=0
                    mov [rdx+16],rbx      ;#0043C5EB: 48:211132 10               vu 00 0C  1  87      
;  4794             mov rsi,[iThis]
                    mov rsi,[rbp-24] (iThis)  ;#0043C5EF: 48:213165 E8               uv 40 20  1  88      
;  4795             cmp rdi,0
                    cmp rdi,0             ;#0043C5F3: 48:203377 00               vu 00 80  1  88      
;  4796             je :unlock
                    je #0043C61C          ;#0043C5F7: 164 23                     v  00 00  1  89      
;  4797             and rdi,2                           -- LOCKFILE_EXCLUSIVE_LOCK (keep)
                    and rdi,2             ;#0043C5F9: 48:203347 02               uv 80 80  1  90      
;  4798             mov [rsp+40],rdx                    -- lpOverlapped
                    mov [rsp+40],rdx      ;#0043C5FD: 48:211124044 28            vu 00 14  1  90      
;  4799             or rdi,1                            -- LOCKFILE_FAIL_IMMEDIATELY (add)
                    or rdi,1              ;#0043C602: 48:203317 01               uv 80 80  1  91      
;  4800             mov [rsp+32],rax                    -- nNumberOfBytesToLockHigh
                    mov [rsp+32],rax      ;#0043C606: 48:211104044 20            vu 00 11  1  91      
;  4801             mov r9,r10                          -- nNumberOfBytesToLockLow
                    mov r9,r10            ;#0043C60B: 4D:213312                  uv 200 400  1  92      
;  4802             mov r8,rbx                          -- dwReserved
                    mov r8,rbx            ;#0043C60E: 4C:213303                  vu 100 08  1  92      
;  4803             mov rdx,rdi                         -- dwFlags
                    mov rdx,rdi           ;#0043C611: 48:213327                  uv 04 80  1  93      
;  4804 --          (rcx already set)                   -- hFile
;  4805             call "kernel32.dll","LockFileEx"
                    call [#004010E8] (LockFileEx)  ;#0043C614: 377025 CE4AFCFF            np 00 00  2  94      
;  4806             jmp @f
                    jmp #0043C630         ;#0043C61A: 353 14                     v  00 00  1  96      
;  4807           ::unlock
;  4808             mov [rsp+32],rdx                    -- lpOverlapped
                    mov [rsp+32],rdx      ;#0043C61C: 48:211124044 20            uv 00 14  1  97      
;  4809             mov r9,rax                          -- nNumberOfBytesToUnlockHigh
                    mov r9,rax            ;#0043C621: 4C:213310                  vu 200 01  1  97      
;  4810             mov r8,r10                          -- nNumberOfBytesToUnlockLow
                    mov r8,r10            ;#0043C624: 4D:213302                  uv 100 400  1  98      
;  4811             mov rdx,rbx                         -- dwReserved
                    mov rdx,rbx           ;#0043C627: 48:213323                  vu 04 08  1  98      
;  4812 --          (rcx already set)                   -- hFile
;  4813             call "kernel32.dll","UnlockFileEx"
                    call [#00401140] (UnlockFileEx)  ;#0043C62A: 377025 104BFCFF            np 00 00  2  99      
;  4814           @@:
;  4815             add rsp,8*7 -- (includes the push rcx from 41 lines ago)
                    add rsp,56            ;#0043C630: 48:203304 38               uv 10 10  1 101      
;  4816             add rsp,sizeof_OVERLAPPED64
                    add rsp,24            ;#0043C634: 48:203304 18               uv 10 10  1 102 10   
;  4817             mov [res],rax
                    mov [rbp-48] (res),rax  ;#0043C638: 48:211105 D0               vu 00 21  1 102      
;  4818         [ELF64]
;  4819             pop al
;  4820         []
;  4821           }
;  4822     return res
    mov rax,[rbp-48] (res)                ;#0043C63C: 48:213105 D0               uv 01 20  1 103      
    mov r15,h4                            ;#0043C640: 49:277 0000000000000040    vu 8000 00  1 103      
    cmp rax,r15                           ;#0043C64A: 4C:071370                  uv 00 8001  1 104      
    jl #0043C662                          ;#0043C64D: 174 13                     v  00 00  1 104      
    mov rsi,1066                          ;#0043C64F: 48:307306 2A040000         uv 40 00  1 105      
    mov rdi,1058                          ;#0043C656: 48:307307 22040000         vu 80 00  1 105      
    call #00442D75 (:%pUnassigned)        ;#0043C65D: 350 13670000               v  00 00  1 106      
    jmp #0044298D (:%opRetf)              ;#0043C662: 351 26630000               v  00 00  1 107      
;  4823 end function
;  4824 
;  4825 --global function lock_file(integer fn, lock_type locktype, byte_range byterange)
;  4826 function flock_file(integer fn, lock_type locktype, byte_range byterange)
    mov rcx,[rbp] (fn)                    ;#0043C35D: 48:213115 00               uv 02 20  1   1      
    mov r15,h4                            ;#0043C361: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rcx,r15                           ;#0043C36B: 4C:071371                  uv 00 8002  1   2      
    jl #0043C37C                          ;#0043C36E: 174 0C                     v  00 00  1   2      
    mov rcx,1071                          ;#0043C370: 48:307301 2F040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043C377: 350 DC660000               v  00 00  1   3      
    mov rcx,2                             ;#0043C37C: 48:307301 02000000         uv 02 00  1   4      
    mov rdx,1048                          ;#0043C383: 48:307302 18040000         vu 04 00  1   4      
    push #0043C3A2                        ;#0043C38A: 150 A2C34300               uv 00 00  1   5      
    push 1072                             ;#0043C38F: 48:150 30040000            vu 00 00  1   5      
    push #0043C80A                        ;#0043C395: 150 0AC84300               uv 00 00  1   6      
    push qword[rbp-8] (locktype)          ;#0043C39A: 377165 F8                  np 00 20  2   7      
    jmp #00442A1F (:%opTchk)              ;#0043C39D: 351 7D660000               v  00 00  1   9      
    mov rcx,4                             ;#0043C3A2: 48:307301 04000000         uv 02 00  1  10      
    mov rdx,1052                          ;#0043C3A9: 48:307302 1C040000         vu 04 00  1  10      
    push #0043C3C8                        ;#0043C3B0: 150 C8C34300               uv 00 00  1  11      
    push 1073                             ;#0043C3B5: 48:150 31040000            vu 00 00  1  11      
    push #0043C750                        ;#0043C3BB: 150 50C74300               uv 00 00  1  12      
    push qword[rbp-16] (byterange)        ;#0043C3C0: 377165 F0                  np 00 20  2  13      
    jmp #00442A1F (:%opTchk)              ;#0043C3C3: 351 57660000               v  00 00  1  15      
;  4827 -- note this has a typecheck on locktype whereas flock does (and should) not.
;  4828     return flock(fn,locktype,byterange)
    mov rcx,9                             ;#0043C3C8: 48:307301 09000000         uv 02 00  1  16      
    mov rdx,1059                          ;#0043C3CF: 48:307302 23040000         vu 04 00  1  16      
    call #004428DB (:%opFrame) (flock)    ;#0043C3D6: 350 00650000               v  00 00  1  17      
    mov rdi,[rbp+40] (prevebp)            ;#0043C3DB: 48:213175 28               uv 80 20  1  18      
    mov rax,[rdi]                         ;#0043C3DF: 48:213007                  uv 01 80  1  21 80 *80*
    mov [rbp] (fn),rax                    ;#0043C3E2: 48:211105 00               uv 00 21  1  22 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043C3E6: 48:213175 28               vu 80 20  1  22      
    mov rax,[rdi-8]                       ;#0043C3EA: 48:213107 F8               uv 01 80  1  25    *80*
    mov [rbp-8] (locktype),rax            ;#0043C3EE: 48:211105 F8               uv 00 21  1  26 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043C3F2: 48:213175 28               vu 80 20  1  26      
    mov rax,[rdi-16]                      ;#0043C3F6: 48:213107 F0               uv 01 80  1  29    *80*
    xor rbx,rbx                           ;#0043C3FA: 48:061333                  vu 08 08  1  29      
    mov r15,h4                            ;#0043C3FD: 49:277 0000000000000040    uv 8000 00  1  30      
    cmp rax,r15                           ;#0043C407: 4C:071370                  uv 00 8001  1  31 8000   
    jl #0043C417                          ;#0043C40A: 174 0B                     v  00 00  1  31      
    add qword[rbx+rax*4-16],1             ;#0043C40C: 48:203104203 F0 01         u  00 09  3  32      
    cmp eax,1073                          ;#0043C412: 075 31040000               vu 00 01  1  34      
    mov [rbp-16] (byterange),rax          ;#0043C417: 48:211105 F0               uv 00 21  1  35      
    mov qword[retaddr],#0043C428          ;#0043C41B: 48:307105 20 28C44300      vu 00 20  1  35      
    jmp #0043C42D (code:flock)            ;#0043C423: 351 05000000               v  00 00  1  36      
    jmp #0044298D (:%opRetf)              ;#0043C428: 351 60650000               v  00 00  1  37      
;  4829 end function
;  4830 
;  4831 --/*
;  4832 flock:
;  4833     mov eax,[edi]
;  4834     cmp eax,h4
;  4835     jge e60fninai8      -- file number is not an integer
;  4836     cmp eax,2
;  4837     jle e58bfneax8                  -- invalid file number (%d)
;  4838     mov edi,[ftend]
;  4839   @@:
;  4840     or edi,edi
;  4841     jz e58bfneax8                   -- invalid file number (%d)
;  4842     cmp [edi+f_no],eax
;  4843     je @f
;  4844     mov edi,[edi+f_prev]
;  4845     jmp @b
;  4846   @@:
;  4847     mov eax,[byterange]
;  4848     mov esi,edi
;  4849     cmp eax,h4
;  4850     jle e67bre
;  4851     shl eax,2
;  4852     test byte[eax-1],0x80
;  4853     jz e67bre
;  4854     mov edx,[eax-12]
;  4855     or edx,edx
;  4856     jne @f
;  4857 --   if equal(byterange,{}) then
;  4858     mov eax,[esi]   -- handle
;  4859     invoke GetFileInformationByHandle, eax, BHFI
;  4860     mov eax,[esi]   -- handle
;  4861     xor ecx,ecx     -- high-order word of lock region (0)
;  4862     mov edi,ecx     -- low-order word of lock region (0)
;  4863                     -- number of bytes to lock are in BHFIfileSize.
;  4864     ret
;  4865 
;  4866   @@:
;  4867     cmp edx,2
;  4868     jne e67bre                -- byterange error (length not 0 or 2)
;  4869     cmp byte[eax-1],0x80
;  4870     je @f
;  4871     cmp byte[eax-1],0x82
;  4872     jne e67bre
;  4873     xor ecx,ecx
;  4874     mov ax,[eax]
;  4875     mov cl,ah
;  4876     and eax,0xFF
;  4877     mov edi,eax
;  4878     jmp byterangeLoaded
;  4879   @@:
;  4880     lea edi,[eax+4]
;  4881     mov ecx,[edi]
;  4882     cmp ecx,h4
;  4883     jl @f
;  4884         shl ecx,2
;  4885         mov [emapTo],edi
;  4886         call emapecx8
;  4887         jne e67bre     -- ecx = byterange[2]
;  4888   @@:
;  4889     mov edi,[eax]
;  4890     cmp edi,h4
;  4891     jl @f
;  4892         shl edi,2
;  4893         mov [emapTo],eax
;  4894       flocke92b:    -- exception here mapped to e92vhnbaavEmapToEsp8feh
;  4895         cmp byte[edi-1],0x12
;  4896         jne e67bre     -- edi = byterange[1]
;  4897         fld qword[edi]
;  4898         mov edi,FltWrk
;  4899         fldcw [down53]
;  4900         fistp qword[edi]
;  4901         fldcw [near53]
;  4902         mov edi,[edi]
;  4903   @@:
;  4904   byterangeLoaded:
;  4905     sub ecx,edi        -- dev 32-bit maths!?
;  4906     mov [BHFInFileSizeLow],ecx -- number of bytes to lock (DEV max 4G only)
;  4907     xor ecx,ecx        -- high-order word of lock region [must be 0 on 95/98 anyway]
;  4908     mov [BHFInFileSizeHigh],ecx -- high-order word of number of bytes to lock=0 [DEV]
;  4909     mov eax,[esi]    -- handle
;  4910     ret
;  4911 
;  4912 opLock:                        -- [edx]=lock_file(edi,ecx,esi)
;  4913 --------
;  4914     trc Lock
;  4915 -- calling convention:
;  4916 --  mov esi,p4  -- addr byterange
;  4917 --  mov ecx,p3  -- addr locktype
;  4918 --  mov edi,p2  -- addr fileno
;  4919 --  mov edx,p1  -- result location
;  4920 --  call opLock
;  4921 
;  4922     mov ecx,[locktype]
;  4923     mov esi,[byterange]
;  4924 
;  4925     mov eax,ecx
;  4926     and eax,0x03
;  4927     cmp eax,ecx
;  4928     jne e66ilt                      -- invalid lock type
;  4929     mov [byterange],esi
;  4930     push edx
;  4931     call flock
;  4932 
;  4933     invoke LockFile, eax,edi,ecx,[BHFInFileSizeLow],[BHFInFileSizeHigh]
;  4934     mov [res],eax
;  4935     ret
;  4936 
;  4937 opUnLock:                      -- unlock(edi,esi)
;  4938 ----------
;  4939     trc UnLock
;  4940 -- calling convention:
;  4941 --  mov esi,p2  -- addr byterange
;  4942 --  mov edi,p1  -- addr fileno
;  4943 --  call opUnLockR
;  4944 
;  4945     mov esi,[esi]               -- byterange
;  4946 push edx    -- to match opLock, [era]-wise
;  4947     mov [byterange],esi
;  4948     call flock
;  4949 
;  4950     invoke UnlockFile, eax,edi,ecx,[BHFInFileSizeLow],[BHFInFileSizeHigh]
;  4951 pop edi     -- ditto
;  4952     ret
;  4953 --*/
;  4954 
;  4955 -- replaced by :%opUnLock
;  4956 --global procedure unlock_file(integer fn, byte_range byterange)
;  4957 --  {} = flock(fn,UNLOCK,byterange)
;  4958 ----integer iThis
;  4959 ----atom fhandle
;  4960 ----sequence params
;  4961 ----integer res
;  4962 ----    if not finit then initF() end if
;  4963 ----    iThis = get_this(fn)
;  4964 ----    fhandle = peek4u(iThis*4+HNDL)
;  4965 ----    params = process_byterange(fhandle,byterange)
;  4966 ----    res = c_func(xUnlockFile,params)
;  4967 --end procedure
;  4968 
;  4969 function addline(sequence res, integer i, integer start, integer option, integer filesize, string src)
    mov rcx,[rbp] (res)                   ;#0043C1B0: 48:213115 00               uv 02 20  1   1      
    mov r15,h4                            ;#0043C1B4: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rcx,r15                           ;#0043C1BE: 4C:071371                  uv 00 8002  1   2      
    jl #0043C1CA                          ;#0043C1C1: 174 07                     v  00 00  1   2      
    test byte[rbx+rcx*4-1],#80            ;#0043C1C3: 366104213 FF 80            u  00 0A  2   3      
    jne #0043C1D6                         ;#0043C1C8: 165 0C                     v  00 00  1   4      
    mov rcx,1076                          ;#0043C1CA: 48:307301 34040000         uv 02 00  1   5      
    call #00442A58 (:%opTchkFail)         ;#0043C1D1: 350 82680000               v  00 00  1   5      
;  4970 --
;  4971 -- Internal routine. Bolt another line onto res.
;  4972 -- All six of the variables i, start, option, src,
;  4973 -- filesize, and res must be set by the callee(!!)
;  4974 -- Factored out so we can call it both when we
;  4975 -- find a \r or \n, and also at end of file.
;  4976 -- The "(use a shared constant)" fairly obviously
;  4977 -- makes multiple references to one object rather
;  4978 -- than multiple such things with ref counts of 1.
;  4979 --
;  4980 sequence oneline
;  4981 integer lend
;  4982     lend = i-1
    mov rdi,[rbp-8] (i)                   ;#0043C1D6: 48:213175 F8               uv 80 20  1   6      
    sub rdi,1                             ;#0043C1DA: 48:203357 01               uv 80 80  1   7 80   
    mov rdx,rdi                           ;#0043C1DE: 48:213327                  uv 04 80  1   8 80   
    mov [rbp-56] (lend),rdi               ;#0043C1E1: 48:211175 C8               vu 00 A0  1   8      
    shl rdx,1                             ;#0043C1E5: 48:321342                  u  04 04  1   9      
    jno #0043C1F3                         ;#0043C1E8: 161 09                     v  00 00  1   9      
    lea rdi,[rbp-56] (lend)               ;#0043C1EA: 48:215175 C8               uv 80 20  1  10      
    call #00442DA9 (:%pAddiii)            ;#0043C1EE: 350 B66B0000               v  00 00  1  10      
;  4983     if option=-1 then   -- GT_LF_STRIPPED
    mov rsi,[rbp-24] (option)             ;#0043C1F3: 48:213165 E8               uv 40 20  1  11      
    cmp rsi,-1                            ;#0043C1F7: 48:203376 FF               uv 00 40  1  12 40   
    jne #0043C23D                         ;#0043C1FB: 165 40                     v  00 00  1  12      
;  4984         if start>lend then
    mov rax,[rbp-16] (start)              ;#0043C1FD: 48:213105 F0               uv 01 20  1  13      
    mov rcx,[rbp-56] (lend)               ;#0043C201: 48:213115 C8               vu 02 20  1  13      
    cmp rax,rcx                           ;#0043C205: 48:071310                  uv 00 03  1  14      
    jle #0043C220                         ;#0043C208: 176 16                     v  00 00  1  14      
;  4985             oneline = ""    -- (use a shared constant)
    mov rdi,qword[#00402240]              ;#0043C20A: 48:213075 2F60FCFF         uv 80 00  1  15      
    mov [rbp-48] (oneline),rdi            ;#0043C211: 48:211175 D0               uv 00 A0  1  16 80   
    add qword[rbx+rdi*4-16],1             ;#0043C215: 48:203104273 F0 01         u  00 88  3  18    *80*
    jmp #0043C2EA                         ;#0043C21B: 351 CA000000               v  00 00  1  20      
;  4986         else
;  4987             oneline = src[start..lend]
    lea rax,[rbp-48] (oneline)            ;#0043C220: 48:215105 D0               uv 01 20  1  21      
    mov rdi,[rbp-16] (start)              ;#0043C224: 48:213175 F0               vu 80 20  1  21      
    mov rsi,[rbp-40] (src)                ;#0043C228: 48:213165 D8               uv 40 20  1  22      
    mov rdx,1081                          ;#0043C22C: 48:307302 39040000         vu 04 00  1  22      
    call #00441212 (:%pSubsss)            ;#0043C233: 350 DA4F0000               v  00 00  1  23      
;  4988         end if
    jmp #0043C2EA                         ;#0043C238: 351 AD000000               v  00 00  1  24      
;  4989     else
;  4990         if start>lend then
    mov rax,[rbp-16] (start)              ;#0043C23D: 48:213105 F0               uv 01 20  1  25      
    mov rdi,[rbp-56] (lend)               ;#0043C241: 48:213175 C8               vu 80 20  1  25      
    cmp rax,rdi                           ;#0043C245: 48:071370                  uv 00 81  1  26      
    jle #0043C28C                         ;#0043C248: 176 42                     v  00 00  1  26      
;  4991             oneline = "\n"  -- (use a shared constant)
    mov rcx,qword[#00402600]              ;#0043C24A: 48:213015 AF63FCFF         uv 02 00  1  27      
    mov rdx,[rbp-48] (oneline)            ;#0043C251: 48:213125 D0               vu 04 20  1  27      
    mov r15,h4                            ;#0043C255: 49:277 0000000000000040    uv 8000 00  1  28      
    cmp rcx,r15                           ;#0043C25F: 4C:071371                  uv 00 8002  1  29 8000   
    jl #0043C26A                          ;#0043C262: 174 06                     v  00 00  1  29      
    add qword[rbx+rcx*4-16],1             ;#0043C264: 48:203104213 F0 01         u  00 0A  3  30      
    mov [rbp-48] (oneline),rcx            ;#0043C26A: 48:211115 D0               vu 00 22  1  32      
    mov r15,h4                            ;#0043C26E: 49:277 0000000000000040    uv 8000 00  1  33      
    cmp rdx,r15                           ;#0043C278: 4C:071372                  uv 00 8004  1  34 8000   
    jle #0043C2EA                         ;#0043C27B: 176 6D                     v  00 00  1  34      
    sub qword[rbx+rdx*4-16],1             ;#0043C27D: 48:203154223 F0 01         u  00 0C  3  35      
    jne #0043C2EA                         ;#0043C283: 165 65                     v  00 00  1  37      
    call #004422DA (:%pDealloc)           ;#0043C285: 350 50600000               v  00 00  1  38      
    jmp #0043C2EA                         ;#0043C28A: 353 5E                     v  00 00  1  39      
;  4992         elsif i<=filesize then
    mov rsi,[rbp-8] (i)                   ;#0043C28C: 48:213165 F8               uv 40 20  1  40      
    mov rax,[rbp-32] (filesize)           ;#0043C290: 48:213105 E0               vu 01 20  1  40      
    cmp rsi,rax                           ;#0043C294: 48:071306                  uv 00 41  1  41      
    jg #0043C2CE                          ;#0043C297: 177 35                     v  00 00  1  41      
;  4993             src[i] = '\n'   -- \r\n --> \n
    mov rdi,rsi                           ;#0043C299: 48:211367                  uv 80 40  1  42      
    mov rcx,10                            ;#0043C29C: 48:307301 0A000000         vu 02 00  1  42      
    mov rsi,[rbp-40] (src)                ;#0043C2A3: 48:213165 D8               uv 40 20  1  43      
    lea rax,[rbp-40] (src)                ;#0043C2A7: 48:215105 D8               vu 01 20  1  43      
    call #00440EB1 (:%pRepe1is)           ;#0043C2AB: 350 014C0000               v  00 00  1  44      
;  4994             oneline = src[start..i]
    lea rax,[rbp-48] (oneline)            ;#0043C2B0: 48:215105 D0               uv 01 20  1  45      
    mov rdi,[rbp-16] (start)              ;#0043C2B4: 48:213175 F0               vu 80 20  1  45      
    mov rcx,[rbp-8] (i)                   ;#0043C2B8: 48:213115 F8               uv 02 20  1  46      
    mov rsi,[rbp-40] (src)                ;#0043C2BC: 48:213165 D8               vu 40 20  1  46      
    mov rdx,1081                          ;#0043C2C0: 48:307302 39040000         uv 04 00  1  47      
    call #00441212 (:%pSubsss)            ;#0043C2C7: 350 464F0000               v  00 00  1  47      
    jmp #0043C2EA                         ;#0043C2CC: 353 1C                     v  00 00  1  48      
;  4995         else -- eof case
;  4996             oneline = src[start..filesize]
    lea rax,[rbp-48] (oneline)            ;#0043C2CE: 48:215105 D0               uv 01 20  1  49      
    mov rdi,[rbp-16] (start)              ;#0043C2D2: 48:213175 F0               vu 80 20  1  49      
    mov rcx,[rbp-32] (filesize)           ;#0043C2D6: 48:213115 E0               uv 02 20  1  50      
    mov rsi,[rbp-40] (src)                ;#0043C2DA: 48:213165 D8               vu 40 20  1  50      
    mov rdx,1081                          ;#0043C2DE: 48:307302 39040000         uv 04 00  1  51      
    call #00441212 (:%pSubsss)            ;#0043C2E5: 350 284F0000               v  00 00  1  51      
;  4997         end if
;  4998     end if
;  4999     res = append(res,oneline)
    mov rax,[rbp-48] (oneline)            ;#0043C2EA: 48:213105 D0               uv 01 20  1  52      
    mov r15,h4                            ;#0043C2EE: 49:277 0000000000000040    vu 8000 00  1  52      
    cmp rax,r15                           ;#0043C2F8: 4C:071370                  uv 00 8001  1  53      
    jne #0043C309                         ;#0043C2FB: 165 0C                     v  00 00  1  53      
    mov rsi,1082                          ;#0043C2FD: 48:307306 3A040000         uv 40 00  1  54      
    call #00442D75 (:%pUnassigned)        ;#0043C304: 350 6C6A0000               v  00 00  1  54      
    mov rdx,rbp                           ;#0043C309: 48:213325                  uv 04 20  1  55      
    mov rdi,rbp                           ;#0043C30C: 48:213375                  vu 80 20  1  55      
    lea rcx,[rbp-48] (oneline)            ;#0043C30F: 48:215115 D0               uv 02 20  1  56      
    xor rax,rax                           ;#0043C313: 48:061300                  vu 01 01  1  56      
    call #0043FC15 (:%opApnd)             ;#0043C316: 350 FA380000               v  00 00  1  57      
;  5000     return res
    mov rax,[rbp] (res)                   ;#0043C31B: 48:213105 00               uv 01 20  1  58      
    mov [rbp] (res),rbx                   ;#0043C31F: 48:211135 00               vu 00 28  1  58      
    jmp #0044298D (:%opRetf)              ;#0043C323: 351 65660000               v  00 00  1  59      
;  5001 end function
;  5002 
;  5003 --DEV e119 to go (has been replaced with 58/59/get_text)
;  5004 -- ( "file number is not an integer or {fn,c}\n",                   -- e119fninaiofnc)
;  5005 --DEV :%opGetText
;  5006 --global function get_text(integer fn, integer option=-2) -- = GT_WHOLE_FILE)
;  5007 function fget_text(integer fn, integer option) --(option gets a default of -2 in pmain.e)
    mov rcx,[rbp] (fn)                    ;#0043BA15: 48:213115 00               uv 02 20  1   1      
    mov r15,h4                            ;#0043BA19: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rcx,r15                           ;#0043BA23: 4C:071371                  uv 00 8002  1   2      
    jl #0043BA34                          ;#0043BA26: 174 0C                     v  00 00  1   2      
    mov rcx,1086                          ;#0043BA28: 48:307301 3E040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043BA2F: 350 24700000               v  00 00  1   3      
    mov rsi,[rbp-8] (option)              ;#0043BA34: 48:213165 F8               uv 40 20  1   4      
    mov r15,h4                            ;#0043BA38: 49:277 0000000000000040    vu 8000 00  1   4      
    cmp rsi,r15                           ;#0043BA42: 4C:071376                  uv 00 8040  1   5      
    jl #0043BA53                          ;#0043BA45: 174 0C                     v  00 00  1   5      
    mov rcx,1087                          ;#0043BA47: 48:307301 3F040000         uv 02 00  1   6      
    call #00442A58 (:%opTchkFail)         ;#0043BA4E: 350 05700000               v  00 00  1   6      
;  5008 --
;  5009 --  Read entire file into memory. Suitable for relatively small text files, for
;  5010 --  example configuration (ini) files, and most of the files used by editors and
;  5011 --  compilers, at least the text ones that is. It is absolutely NOT suitable for
;  5012 --  large files, over say 5MB, or any form of binary file (database, video, etc).
;  5013 --  (Technically GT_WHOLE_FILE might work on small binaries, but you are pushing 
;  5014 --   limits and bending the definition of a string, caveat emptor and all that.)
;  5015 --  This routine, unlike the others in this source file, is deliberately limited 
;  5016 --  to 1GB, producing the error e78atgtgt1gbf, "attempt to get_text() >1GB file", 
;  5017 --  if breached. Larger files should be processed [one char/byte/line at a time] 
;  5018 --  by getc/gets/seek/puts, which have a (predicted) limit of 8192 TB (thousands 
;  5019 --  of times larger than the biggest available hard drives).
;  5020 --
;  5021 --  fn should be an open file with read-only access (it does not matter whether
;  5022 --      it was opened in binary or text mode)
;  5023 --  option is one of:
;  5024 --  -2: (GT_WHOLE_FILE) get whole file as one long string, plus final '\n' if missing.
;  5025 --      GT_WHOLE_FILE (-2) leaves any embedded CR,LF,CRLF,LFCR as-is, whereas 
;  5026 --      no CR are returned from the other options. GT_WHOLE_FILE is however the
;  5027 --      fastest way to read a large file (GT_WHOLE_FILE is what p.exw uses). [DEV?]
;  5028 --       (tests: "a\nb\n" from both "a\nb" and "a\nb\n")
;  5029 --  -1: (GT_LF_STRIPPED) '\n'-stripped lines
;  5030 --       (eg: {"a","b"} from both "a\nb" and "a\nb\n")
;  5031 --       (tests: {"a","b"} from "a\nb", "a\nb\n", "a\r\nb", "a\r\nb\r\n", "a\n\rb\n\r", "a\rb", "a\rb\r")
;  5032 --   0: (GT_LF_LEFT) '\n' left on lines,
;  5033 --       (tests: {"a\n","b"} from "a\nb" but {"a\n","b\n"} from "a\nb\n")
;  5034 --  +1: (GT_LF_LAST) '\n' left on lines, and put on last line if missing.
;  5035 --       (tests: {"a\n","b\n"} from both "a\nb" and "a\nb\n")
;  5036 --
;  5037 --  The constants GT_WHOLE_FILE, GT_LF_STRIPPED, GT_LF_LEFT, and GT_LF_LAST are 
;  5038 --  automatically defined in psym.e/syminit().
;  5039 --
;  5040 --  It should make no difference if fn is open in binary or text mode.
;  5041 --
;  5042 integer fidx, ch
;  5043 integer fmode
;  5044 --atom fhandle
;  5045 integer i
;  5046 object res
;  5047 integer start
;  5048 integer filesize
;  5049 string src
;  5050 --atom frealposn
;  5051 --atom this
;  5052 integer iThis
;  5053 
;  5054     fidx = fn-2
    sub rcx,2                             ;#0043BA53: 48:203351 02               uv 02 02  1   7      
    mov rdx,rcx                           ;#0043BA57: 48:213321                  uv 04 02  1   8 02   
    mov [rbp-16] (fidx),rcx               ;#0043BA5A: 48:211115 F0               vu 00 22  1   8      
    shl rdx,1                             ;#0043BA5E: 48:321342                  u  04 04  1   9      
    jno #0043BA6C                         ;#0043BA61: 161 09                     v  00 00  1   9      
    lea rdi,[rbp-16] (fidx)               ;#0043BA63: 48:215175 F0               uv 80 20  1  10      
    call #00442DA9 (:%pAddiii)            ;#0043BA67: 350 3D730000               v  00 00  1  10      
;  5055     fmode = 0
    mov [rbp-32] (fmode),rbx              ;#0043BA6C: 48:211135 E0               uv 00 28  1  11      
;  5056     if finit and fidx>=1 and fidx<=fdmax then
    mov rdi,[#00403178] (finit)           ;#0043BA70: 48:213075 0177FCFF         vu 80 00  1  11      
    test rdi,rdi                          ;#0043BA77: 48:205377                  uv 00 80  1  12      
    je #0043BAD3                          ;#0043BA7A: 164 57                     v  00 00  1  12      
    cmp rcx,1                             ;#0043BA7C: 48:203371 01               uv 00 02  1  13      
    jl #0043BAD3                          ;#0043BA80: 174 51                     v  00 00  1  13      
    mov rax,[#004030D8] (fdmax)           ;#0043BA82: 48:213005 4F76FCFF         uv 01 00  1  14      
    cmp rcx,rax                           ;#0043BA89: 48:071301                  uv 00 03  1  15 01   
    jg #0043BAD3                          ;#0043BA8C: 177 45                     v  00 00  1  15      
;  5057 --DEV newsize [PE32], get_this()?
;  5058         fmode = 1   --DEV should really fix this... (compiler issue)
    mov qword[rbp-32] (fmode),1           ;#0043BA8E: 48:307105 E0 01000000      uv 00 20  1  16      
;  5059         #ilASM{
;  5060             [32]
;  5061                 mov edx,[fidx]
;  5062                 shl edx,2
;  5063               @@:
;  5064                 mov edi,[fdtbl]
;  5065                 mov esi,[edx+edi*4-4]   -- esi:=fdtbl[fidx]
;  5066                 cmp edi,[fdtbl]
;  5067                 jne @b
;  5068                 mov eax,[ebx+esi*4+MODE]
;  5069                 mov [iThis],esi
;  5070                 mov [fmode],eax
;  5071                 mov dword[ebx+esi*4+POSN],1
;  5072                 mov [ebx+esi*4+FEND],ebx
;  5073                 mov [ebx+esi*4+POSL],ebx
;  5074                 mov [ebx+esi*4+POSH],ebx
;  5075             [64]
;  5076                 mov rdx,[fidx]
                        mov rdx,[rbp-16] (fidx)  ;#0043BA96: 48:213125 F0               vu 04 20  1  16      
;  5077                 shl rdx,3
                        shl rdx,3         ;#0043BA9A: 48:301342 03               u  04 04  1  17      
;  5078               @@:
;  5079                 mov rdi,[fdtbl]
                        mov rdi,[#004030D0] (fdtbl)  ;#0043BA9E: 48:213075 2B76FCFF         vu 80 00  1  17      
;  5080                 mov rsi,[rdx+rdi*4-8]   -- esi:=fdtbl[fidx]
                        mov rsi,[rdx+rdi*4-8]  ;#0043BAA5: 48:213164272 F8            uv 40 84  1  20    *84*
;  5081                 cmp rdi,[fdtbl]
                        cmp rdi,[#004030D0] (fdtbl)  ;#0043BAAA: 48:073075 1F76FCFF         vu 00 80  2  20      
;  5082                 jne @b
                        jne #0043BA9E     ;#0043BAB1: 165 EB                     v  00 00  1  21      
;  5083                 mov rax,[rbx+rsi*4+MODE64]
                        mov rax,[rbx+rsi*4+8]  ;#0043BAB3: 48:213104263 08            uv 01 48  1  22      
;  5084                 mov [iThis],rsi
                        mov [rbp-80] (iThis),rsi  ;#0043BAB8: 48:211165 B0               vu 00 60  1  22      
;  5085                 mov [fmode],rax
                        mov [rbp-32] (fmode),rax  ;#0043BABC: 48:211105 E0               uv 00 21  1  23      
;  5086                 mov qword[rbx+rsi*4+POSN64],1
                        mov qword[rbx+rsi*4+16],1  ;#0043BAC0: 48:307104263 10 01000000   vu 00 48  1  23      
;  5087                 mov [rbx+rsi*4+FEND64],rbx
                        mov [rbx+rsi*4+24],rbx  ;#0043BAC9: 48:211134263 18            uv 00 48  1  24      
;  5088                 mov [rbx+rsi*4+RPOS64],rbx
                        mov [rbx+rsi*4+32],rbx  ;#0043BACE: 48:211134263 20            vu 00 48  1  24      
;  5089               }
;  5090 --      fmode = peek4u(this+MODE)
;  5091     end if
;  5092     if fmode=0 or fn<=2 then
    mov rsi,[rbp-32] (fmode)              ;#0043BAD3: 48:213165 E0               uv 40 20  1  25      
    cmp rsi,0                             ;#0043BAD7: 48:203376 00               uv 00 40  1  26 40   
    je #0043BAE7                          ;#0043BADB: 164 0A                     v  00 00  1  26      
    mov rdi,[rbp] (fn)                    ;#0043BADD: 48:213175 00               uv 80 20  1  27      
    cmp rdi,2                             ;#0043BAE1: 48:203377 02               uv 00 80  1  28 80   
    jg #0043BB1A                          ;#0043BAE5: 177 33                     v  00 00  1  28      
;  5093         iofatal(58,fn)  -- "invalid file number (%d)"
    mov rcx,2                             ;#0043BAE7: 48:307301 02000000         uv 02 00  1  29      
    mov rdx,968                           ;#0043BAEE: 48:307302 C8030000         vu 04 00  1  29      
    call #004428DB (:%opFrame) (iofatal)  ;#0043BAF5: 350 E16D0000               v  00 00  1  30      
    mov qword[rbp] (errcode),58           ;#0043BAFA: 48:307105 00 3A000000      uv 00 20  1  31      
    mov rdi,[rbp+40] (prevebp)            ;#0043BB02: 48:213175 28               vu 80 20  1  31      
    mov rax,[rdi]                         ;#0043BB06: 48:213007                  uv 01 80  1  34    *80*
    mov [rbp-8] (ep1),rax                 ;#0043BB09: 48:211105 F8               uv 00 21  1  35 01   
    mov qword[retaddr],#0043BB1A          ;#0043BB0D: 48:307105 20 1ABB4300      vu 00 20  1  35      
    jmp #0043C328 (code:iofatal)          ;#0043BB15: 351 0E080000               v  00 00  1  36      
;  5094     end if
;  5095     if and_bits(fmode,or_bits(F_READ,F_WRITE))!=F_READ then
    mov qword[rbp-88] (symtab[1097]),3    ;#0043BB1A: 48:307105 A8 03000000      uv 00 20  1  37      
    mov rcx,[rbp-32] (fmode)              ;#0043BB22: 48:213115 E0               vu 02 20  1  37      
    and rcx,3                             ;#0043BB26: 48:203341 03               uv 02 02  1  38      
    cmp rcx,1                             ;#0043BB2A: 48:203371 01               uv 00 02  1  39 02   
    je #0043BB58                          ;#0043BB2E: 164 28                     v  00 00  1  39      
;  5096         iofatal(59) -- "wrong file mode for attempted operation"
    mov rcx,2                             ;#0043BB30: 48:307301 02000000         uv 02 00  1  40      
    mov rdx,968                           ;#0043BB37: 48:307302 C8030000         vu 04 00  1  40      
    call #004428DB (:%opFrame) (iofatal)  ;#0043BB3E: 350 986D0000               v  00 00  1  41      
    mov qword[rbp] (errcode),59           ;#0043BB43: 48:307105 00 3B000000      uv 00 20  1  42      
    mov qword[retaddr],#0043BB58          ;#0043BB4B: 48:307105 20 58BB4300      vu 00 20  1  42      
    jmp #0043C328 (code:iofatal)          ;#0043BB53: 351 D0070000               v  00 00  1  43      
;  5097     end if
;  5098 
;  5099 --DEV e119?
;  5100 --  if option<-2 or option>1 then return -1 end if
;  5101     if option<-2 or option>1 then ?9/0 end if
    mov rsi,[rbp-8] (option)              ;#0043BB58: 48:213165 F8               uv 40 20  1  44      
    cmp rsi,-2                            ;#0043BB5C: 48:203376 FE               uv 00 40  1  45 40   
    jl #0043BB68                          ;#0043BB60: 174 06                     v  00 00  1  45      
    cmp rsi,1                             ;#0043BB62: 48:203376 01               uv 00 40  1  46      
    jle #0043BB6D                         ;#0043BB66: 176 05                     v  00 00  1  46      
    call #00442DD2 (:%pDiv0)              ;#0043BB68: 350 65720000               v  00 00  1  47      
;  5102 
;  5103 --DEV newsize [PE32] machine_bits()
;  5104 --  if machine_bits()=32 then
;  5105 --      poke4(iThis*4+POSN,1)   -- unnecessary?
;  5106 --      poke4(iThis*4+FEND,0)
;  5107 --      poke8(iThis*4+POSL,0)
;  5108 ----DEV we don't need this:
;  5109 --      fhandle = peek4u(iThis*4+HNDL)
;  5110 --  else
;  5111 --      poke8(iThis*4+POSN64,1) -- unnecessary?
;  5112 --      poke8(iThis*4+FEND64,0)
;  5113 --      poke8(iThis*4+RPOS64,0)
;  5114 ----DEV we don't need this:
;  5115 --      fhandle = peek8u(iThis*4+HNDL64)
;  5116 --  end if
;  5117 
;  5118 --DEV better?:
;  5119     if seek(fn,0)!=SEEK_OK then ?9/0 end if
    lea rdi,[rbp-96] (symtab[1098])       ;#0043BB6D: 48:215175 A0               uv 80 20  1  48      
    mov rax,[rbp] (fn)                    ;#0043BB71: 48:213105 00               vu 01 20  1  48      
    mov rcx,qword[#00402028]              ;#0043BB75: 48:213015 AC64FCFF         uv 02 00  1  49      
    call #0043E927 (:%opSeek)             ;#0043BB7C: 350 A62D0000               v  00 00  1  49      
    cmp rax,0                             ;#0043BB81: 48:203370 00               uv 00 01  1  50      
    je #0043BB8C                          ;#0043BB85: 164 05                     v  00 00  1  50      
    call #00442DD2 (:%pDiv0)              ;#0043BB87: 350 46720000               v  00 00  1  51      
;  5120 --  frealposn = 0
;  5121 --  frealposn = c_func(xSetFilePointer,{fhandle,0,NULL,FILE_BEGIN})
;  5122 
;  5123 --DEV newsize [PE32]
;  5124     #ilASM{
;  5125         [32]
;  5126             mov esi,[iThis]
;  5127         [PE32]
;  5128             push ebx                            -- reserve space for FileSizeHigh
;  5129             push esp                            -- lpFileSizeHigh
;  5130             push dword[ebx+esi*4+HNDL]          -- hFile
;  5131             call "kernel32.dll","GetFileSize"
;  5132             pop ecx
;  5133             test ecx,ecx
;  5134             jnz :highnotzero
;  5135             cmp eax,h4
;  5136             jb :lowOK
;  5137           ::highnotzero
;  5138             -- e78atgtgt1gbf: "attempt to get_text() >1GB file"
;  5139             mov al,78
;  5140             xor edi,edi     -- ep1 unused
;  5141             xor esi,esi     -- ep2 unused
;  5142 --DEV
;  5143             call :%pRTErn   -- fatal error
;  5144           ::lowOK
;  5145             mov [filesize],eax
;  5146         [ELF32]
;  5147             pop al
;  5148         [64]
;  5149             mov rsi,[iThis]
                    mov rsi,[rbp-80] (iThis)  ;#0043BB8C: 48:213165 B0               uv 40 20  1  52      
;  5150         [PE64]
;  5151             sub rsp,8*7
                    sub rsp,56            ;#0043BB90: 48:203354 38               vu 10 10  1  52      
;  5152             lea rdx,[rsp+32]                    -- lpFileSize
                    lea rdx,[rsp+32]      ;#0043BB94: 48:215124044 20            uv 04 10  1  55    *10*
;  5153             mov rcx,[rbx+rsi*4+HNDL64]          -- hFile
                    mov rcx,[rbx+rsi*4]   ;#0043BB99: 48:213014263               vu 02 48  1  55      
;  5154             call "kernel32.dll","GetFileSizeEx"
                    call [#00401098] (GetFileSizeEx)  ;#0043BB9D: 377025 F554FCFF            np 00 00  2  56      
;  5155             mov rcx,[rsp+32]
                    mov rcx,[rsp+32]      ;#0043BBA3: 48:213114044 20            uv 02 10  1  58      
;  5156             add rsp,8*7
                    add rsp,56            ;#0043BBA8: 48:203304 38               vu 10 10  1  58      
;  5157             mov [filesize],rcx
                    mov [rbp-64] (filesize),rcx  ;#0043BBAC: 48:211115 C0               uv 00 22  1  59      
;  5158         [ELF64]
;  5159             pop al
;  5160           }
;  5161     if filesize=0 then
    xor rdi,rdi                           ;#0043BBB0: 48:061377                  vu 80 80  1  59      
    mov rax,[rbp-64] (filesize)           ;#0043BBB3: 48:213105 C0               uv 01 20  1  60      
    mov rsi,25                            ;#0043BBB7: 48:307306 19000000         vu 40 00  1  60      
    mov rdx,1094                          ;#0043BBBE: 48:307302 46040000         uv 04 00  1  61      
    call #0043FAF6 (:%opJccE)             ;#0043BBC5: 350 2C3F0000               v  00 00  1  61      
    jne #0043BBFC                         ;#0043BBCA: 165 30                     v  00 00  1  62      
;  5162         if option=-2 then   -- GT_WHOLE_FILE
    mov rdi,[rbp-8] (option)              ;#0043BBCC: 48:213175 F8               uv 80 20  1  63      
    cmp rdi,-2                            ;#0043BBD0: 48:203377 FE               uv 00 80  1  64 80   
    jne #0043BBEA                         ;#0043BBD4: 165 14                     v  00 00  1  64      
;  5163             return "\n"
    mov rax,qword[#00402600]              ;#0043BBD6: 48:213005 236AFCFF         uv 01 00  1  65      
    add qword[rbx+rax*4-16],1             ;#0043BBDD: 48:203104203 F0 01         u  00 09  3  68    *01*
    jmp #0044298D (:%opRetf)              ;#0043BBE3: 351 A56D0000               v  00 00  1  70      
    jmp #0043BBFC                         ;#0043BBE8: 353 12                     v  00 00  1  71      
;  5164         else
;  5165             return {}
    mov rax,qword[#004022C8]              ;#0043BBEA: 48:213005 D766FCFF         uv 01 00  1  72      
    add qword[rbx+rax*4-16],1             ;#0043BBF1: 48:203104203 F0 01         u  00 09  3  75    *01*
    jmp #0044298D (:%opRetf)              ;#0043BBF7: 351 916D0000               v  00 00  1  77      
;  5166         end if
;  5167     end if
;  5168     if option=0 then    -- GT_LF_LEFT
    mov rsi,[rbp-8] (option)              ;#0043BBFC: 48:213165 F8               uv 40 20  1  78      
    cmp rsi,0                             ;#0043BC00: 48:203376 00               uv 00 40  1  79 40   
    jne #0043BC37                         ;#0043BC04: 165 31                     v  00 00  1  79      
;  5169         src = repeat('\n',filesize)
    mov rcx,[rbp-64] (filesize)           ;#0043BC06: 48:213115 C0               uv 02 20  1  80      
    mov r15,h4                            ;#0043BC0A: 49:277 0000000000000040    vu 8000 00  1  80      
    cmp rcx,r15                           ;#0043BC14: 4C:071371                  uv 00 8002  1  81      
    jne #0043BC25                         ;#0043BC17: 165 0C                     v  00 00  1  81      
    mov rsi,1094                          ;#0043BC19: 48:307306 46040000         uv 40 00  1  82      
    call #00442D75 (:%pUnassigned)        ;#0043BC20: 350 50710000               v  00 00  1  82      
    lea rdi,[rbp-72] (src)                ;#0043BC25: 48:215175 B8               uv 80 20  1  83      
    mov rax,10                            ;#0043BC29: 48:307300 0A000000         vu 01 00  1  83      
    call #0043B1E1 (:%opRepCh)            ;#0043BC30: 350 ACF5FFFF               v  00 00  1  84      
    jmp #0043BC7E                         ;#0043BC35: 353 47                     v  00 00  1  85      
;  5170     else
;  5171         src = repeat('\n',filesize+1)       -- add/plant "safety lf"
    mov rdi,[rbp-64] (filesize)           ;#0043BC37: 48:213175 C0               uv 80 20  1  86      
    mov r15,h4                            ;#0043BC3B: 49:277 0000000000000040    vu 8000 00  1  86      
    cmp rdi,r15                           ;#0043BC45: 4C:071377                  uv 00 8080  1  87      
    jne #0043BC56                         ;#0043BC48: 165 0C                     v  00 00  1  87      
    mov rsi,1094                          ;#0043BC4A: 48:307306 46040000         uv 40 00  1  88      
    call #00442D75 (:%pUnassigned)        ;#0043BC51: 350 1F710000               v  00 00  1  88      
    lea rdi,[rbp-104] (symtab[1100])      ;#0043BC56: 48:215175 98               uv 80 20  1  89      
    mov rcx,[rbp-64] (filesize)           ;#0043BC5A: 48:213115 C0               vu 02 20  1  89      
    mov rax,qword[#00402030]              ;#0043BC5E: 48:213005 CB63FCFF         uv 01 00  1  90      
    call #0043F4AF (:%opAdd)              ;#0043BC65: 350 45380000               v  00 00  1  90      
    lea rdi,[rbp-72] (src)                ;#0043BC6A: 48:215175 B8               uv 80 20  1  91      
    mov rax,10                            ;#0043BC6E: 48:307300 0A000000         vu 01 00  1  91      
    mov rcx,[rbp-104] (symtab[1100])      ;#0043BC75: 48:213115 98               uv 02 20  1  92      
    call #0043B1E1 (:%opRepCh)            ;#0043BC79: 350 63F5FFFF               v  00 00  1  92      
;  5172     end if
;  5173     res = -1
    mov qword[rbp-48] (res),-1            ;#0043BC7E: 48:307105 D0 FFFFFFFF      uv 00 20  1  93      
;  5174 --DEV newsize [PE32]
;  5175     #ilASM{
;  5176         [32]
;  5177             mov esi,[iThis]
;  5178             mov edi,[src]
;  5179             push ebx                    -- reserve space for NumberOfBytesRead
;  5180             mov edx,esp
;  5181             mov ecx,[filesize]
;  5182             shl edi,2
;  5183         [PE32]
;  5184             push ebx                                        -- lpOverlapped (NULL)
;  5185             push edx                                        -- lpNumberOfBytesRead
;  5186             push ecx                                        -- nNumberOfBytesToRead
;  5187             push edi                                        -- lpBuffer
;  5188             push dword[ebx+esi*4+HNDL]                      -- hFile
;  5189             call "kernel32.dll","ReadFile"
;  5190             pop ecx
;  5191             test eax,eax
;  5192             jz :retZ2
;  5193             test ecx,ecx
;  5194             jz :retZ2
;  5195         [ELF32]
;  5196             pop al
;  5197         [64]
;  5198             mov rdx,[src]
                    mov rdx,[rbp-72] (src)  ;#0043BC86: 48:213125 B8               vu 04 20  1  93      
;  5199             mov rsi,[iThis]
                    mov rsi,[rbp-80] (iThis)  ;#0043BC8A: 48:213165 B0               uv 40 20  1  94      
;  5200             shl rdx,2
                    shl rdx,2             ;#0043BC8E: 48:301342 02               u  04 04  1  95      
;  5201         [PE64]
;  5202             sub rsp,8*7
                    sub rsp,56            ;#0043BC92: 48:203354 38               vu 10 10  1  95      
;  5203             mov [rsp+40],rbx
                    mov [rsp+40],rbx      ;#0043BC96: 48:211134044 28            uv 00 18  1  98    *10*
;  5204             mov [rsp+32],rbx                                -- lpOverlapped (NULL)
                    mov [rsp+32],rbx      ;#0043BC9B: 48:211134044 20            vu 00 18  1  98      
;  5205             lea r9,[rsp+40]                                 -- lpNumberOfBytesRead
                    lea r9,[rsp+40]       ;#0043BCA0: 4C:215114044 28            uv 200 10  1  99      
;  5206             mov r8,[filesize]                               -- nNumberOfBytesToRead
                    mov r8,[rbp-64] (filesize)  ;#0043BCA5: 4C:213105 C0               vu 100 20  1  99      
;  5207 --          (rdx already set)                               -- lpBuffer
;  5208             mov rcx,[ebx+esi*4+HNDL]                        -- hFile
                    mov rcx,[rbx+rsi*4]   ;#0043BCA9: 48:213014263               uv 02 48  1 100      
;  5209             call "kernel32.dll","ReadFile"
                    call [#00401100] (ReadFile)  ;#0043BCAD: 377025 4D54FCFF            np 00 00  2 101      
;  5210             mov rcx,[rsp+40]
                    mov rcx,[rsp+40]      ;#0043BCB3: 48:213114044 28            uv 02 10  1 103      
;  5211             add rsp,8*7
                    add rsp,56            ;#0043BCB8: 48:203304 38               vu 10 10  1 103      
;  5212             test rax,rax
                    test rax,rax          ;#0043BCBC: 48:205300                  uv 00 01  1 104      
;  5213             jz :retZ2
                    jz #0043C1A3          ;#0043BCBF: 017204 DE040000            v  00 00  1 104      
;  5214             test rcx,rcx
                    test rcx,rcx          ;#0043BCC5: 48:205311                  uv 00 02  1 105      
;  5215             jz :retZ2
                    jz #0043C1A3          ;#0043BCC8: 017204 D5040000            v  00 00  1 105      
;  5216         [ELF64]
;  5217             pop al
;  5218           }
;  5219 
;  5220 --DEV as above.. (why bother?)
;  5221 --  frealposn = c_func(xSetFilePointer,{fhandle,0,NULL,FILE_BEGIN})
;  5222 
;  5223     if option!=0 then   -- not GT_LF_LEFT
    mov rsi,[rbp-8] (option)              ;#0043BCCE: 48:213165 F8               uv 40 20  1 106      
    cmp rsi,0                             ;#0043BCD2: 48:203376 00               uv 00 40  1 107 40   
    je #0043BE9B                          ;#0043BCD6: 017204 BF010000            v  00 00  1 107      
;  5224         ch = src[filesize]
    mov rdi,[rbp-72] (src)                ;#0043BCDC: 48:213175 B8               uv 80 20  1 108      
    mov r15,h4                            ;#0043BCE0: 49:277 0000000000000040    vu 8000 00  1 108      
    cmp rdi,r15                           ;#0043BCEA: 4C:071377                  uv 00 8080  1 109      
    jne #0043BCFB                         ;#0043BCED: 165 0C                     v  00 00  1 109      
    mov rsi,1095                          ;#0043BCEF: 48:307306 47040000         uv 40 00  1 110      
    call #00442D75 (:%pUnassigned)        ;#0043BCF6: 350 7A700000               v  00 00  1 110      
    mov rax,[rbp-64] (filesize)           ;#0043BCFB: 48:213105 C0               uv 01 20  1 111      
    mov r15,h4                            ;#0043BCFF: 49:277 0000000000000040    vu 8000 00  1 111      
    cmp rax,r15                           ;#0043BD09: 4C:071370                  uv 00 8001  1 112      
    jne #0043BD1A                         ;#0043BD0C: 165 0C                     v  00 00  1 112      
    mov rsi,1094                          ;#0043BD0E: 48:307306 46040000         uv 40 00  1 113      
    call #00442D75 (:%pUnassigned)        ;#0043BD15: 350 5B700000               v  00 00  1 113      
    mov rdi,rax                           ;#0043BD1A: 48:211307                  uv 80 01  1 114      
    mov rsi,[rbp-72] (src)                ;#0043BD1D: 48:213165 B8               vu 40 20  1 114      
    mov rdx,1095                          ;#0043BD21: 48:307302 47040000         uv 04 00  1 115      
    call #00441762 (:%pSubse1is)          ;#0043BD28: 350 355A0000               v  00 00  1 115      
    mov [rbp-24] (ch),rax                 ;#0043BD2D: 48:211105 E8               uv 00 21  1 116      
;  5225         if ch='\n' then
    cmp rax,10                            ;#0043BD31: 48:203370 0A               vu 00 01  1 116      
    jne #0043BD7D                         ;#0043BD35: 165 46                     v  00 00  1 117      
;  5226             -- "...\n<safety\n>" ==> "...\n"
;  5227             src = src[1..-2]                -- remove that "safety \n"
    mov rcx,[rbp-72] (src)                ;#0043BD37: 48:213115 B8               uv 02 20  1 118      
    mov r15,h4                            ;#0043BD3B: 49:277 0000000000000040    vu 8000 00  1 118      
    cmp rcx,r15                           ;#0043BD45: 4C:071371                  uv 00 8002  1 119      
    jne #0043BD56                         ;#0043BD48: 165 0C                     v  00 00  1 119      
    mov rsi,1095                          ;#0043BD4A: 48:307306 47040000         uv 40 00  1 120      
    call #00442D75 (:%pUnassigned)        ;#0043BD51: 350 1F700000               v  00 00  1 120      
    lea rax,[rbp-72] (src)                ;#0043BD56: 48:215105 B8               uv 01 20  1 121      
    mov rdi,1                             ;#0043BD5A: 48:307307 01000000         vu 80 00  1 121      
    mov rcx,-2                            ;#0043BD61: 48:307301 FEFFFFFF         uv 02 00  1 122      
    mov rsi,[rbp-72] (src)                ;#0043BD68: 48:213165 B8               vu 40 20  1 122      
    mov rdx,1095                          ;#0043BD6C: 48:307302 47040000         uv 04 00  1 123      
    call #00441212 (:%pSubsss)            ;#0043BD73: 350 9A540000               v  00 00  1 123      
    jmp #0043BE9B                         ;#0043BD78: 351 1E010000               v  00 00  1 124      
;  5228         elsif ch='\r' then
    cmp rax,13                            ;#0043BD7D: 48:203370 0D               uv 00 01  1 125      
    jne #0043BE9B                         ;#0043BD81: 017205 14010000            v  00 00  1 125      
;  5229             if filesize>1 and src[filesize-1]='\n' then
    mov rdi,1                             ;#0043BD87: 48:307307 01000000         uv 80 00  1 126      
    mov rax,[rbp-64] (filesize)           ;#0043BD8E: 48:213105 C0               vu 01 20  1 126      
    mov rsi,26                            ;#0043BD92: 48:307306 1A000000         uv 40 00  1 127      
    mov rdx,1094                          ;#0043BD99: 48:307302 46040000         vu 04 00  1 127      
    call #0043FA81 (:%opJcc)              ;#0043BDA0: 350 DC3C0000               v  00 00  1 128      
    jle #0043BE3F                         ;#0043BDA5: 017216 94000000            v  00 00  1 129      
    mov rdi,[rbp-64] (filesize)           ;#0043BDAB: 48:213175 C0               uv 80 20  1 130      
    sub rdi,1                             ;#0043BDAF: 48:203357 01               uv 80 80  1 131 80   
    mov rdx,rdi                           ;#0043BDB3: 48:213327                  uv 04 80  1 132 80   
    mov [rbp-96] (symtab[1098]),rdi       ;#0043BDB6: 48:211175 A0               vu 00 A0  1 132      
    shl rdx,1                             ;#0043BDBA: 48:321342                  u  04 04  1 133      
    jno #0043BDC8                         ;#0043BDBD: 161 09                     v  00 00  1 133      
    lea rdi,[rbp-96] (symtab[1098])       ;#0043BDBF: 48:215175 A0               uv 80 20  1 134      
    call #00442DA9 (:%pAddiii)            ;#0043BDC3: 350 E16F0000               v  00 00  1 134      
    mov rcx,[rbp-72] (src)                ;#0043BDC8: 48:213115 B8               uv 02 20  1 135      
    mov r15,h4                            ;#0043BDCC: 49:277 0000000000000040    vu 8000 00  1 135      
    cmp rcx,r15                           ;#0043BDD6: 4C:071371                  uv 00 8002  1 136      
    jne #0043BDE7                         ;#0043BDD9: 165 0C                     v  00 00  1 136      
    mov rsi,1095                          ;#0043BDDB: 48:307306 47040000         uv 40 00  1 137      
    call #00442D75 (:%pUnassigned)        ;#0043BDE2: 350 8E6F0000               v  00 00  1 137      
    mov rdi,[rbp-96] (symtab[1098])       ;#0043BDE7: 48:213175 A0               uv 80 20  1 138      
    mov rsi,rcx                           ;#0043BDEB: 48:211316                  vu 40 02  1 138      
    mov rdx,1095                          ;#0043BDEE: 48:307302 47040000         uv 04 00  1 139      
    call #00441762 (:%pSubse1is)          ;#0043BDF5: 350 68590000               v  00 00  1 139      
    cmp rax,10                            ;#0043BDFA: 48:203370 0A               uv 00 01  1 140      
    jne #0043BE3F                         ;#0043BDFE: 165 3F                     v  00 00  1 140      
;  5230                 -- "...\n\r<safety\n>" ==> "...\n"
;  5231                 src = src[1..-3]
    mov rsi,[rbp-72] (src)                ;#0043BE00: 48:213165 B8               uv 40 20  1 141      
    mov r15,h4                            ;#0043BE04: 49:277 0000000000000040    vu 8000 00  1 141      
    cmp rsi,r15                           ;#0043BE0E: 4C:071376                  uv 00 8040  1 142      
    jne #0043BE1F                         ;#0043BE11: 165 0C                     v  00 00  1 142      
    mov rsi,1095                          ;#0043BE13: 48:307306 47040000         uv 40 00  1 143      
    call #00442D75 (:%pUnassigned)        ;#0043BE1A: 350 566F0000               v  00 00  1 143      
    lea rax,[rbp-72] (src)                ;#0043BE1F: 48:215105 B8               uv 01 20  1 144      
    mov rdi,1                             ;#0043BE23: 48:307307 01000000         vu 80 00  1 144      
    mov rcx,-3                            ;#0043BE2A: 48:307301 FDFFFFFF         uv 02 00  1 145      
    mov rdx,1095                          ;#0043BE31: 48:307302 47040000         vu 04 00  1 145      
    call #00441212 (:%pSubsss)            ;#0043BE38: 350 D5530000               v  00 00  1 146      
    jmp #0043BE9B                         ;#0043BE3D: 353 5C                     v  00 00  1 147      
;  5232             else
;  5233                 -- "...X\r<safety\n>" ==> "...X\n" (where X!='\n')
;  5234                 src = src[1..-2]
    mov rdi,[rbp-72] (src)                ;#0043BE3F: 48:213175 B8               uv 80 20  1 148      
    mov r15,h4                            ;#0043BE43: 49:277 0000000000000040    vu 8000 00  1 148      
    cmp rdi,r15                           ;#0043BE4D: 4C:071377                  uv 00 8080  1 149      
    jne #0043BE5E                         ;#0043BE50: 165 0C                     v  00 00  1 149      
    mov rsi,1095                          ;#0043BE52: 48:307306 47040000         uv 40 00  1 150      
    call #00442D75 (:%pUnassigned)        ;#0043BE59: 350 176F0000               v  00 00  1 150      
    lea rax,[rbp-72] (src)                ;#0043BE5E: 48:215105 B8               uv 01 20  1 151      
    mov rdi,1                             ;#0043BE62: 48:307307 01000000         vu 80 00  1 151      
    mov rcx,-2                            ;#0043BE69: 48:307301 FEFFFFFF         uv 02 00  1 152      
    mov rsi,[rbp-72] (src)                ;#0043BE70: 48:213165 B8               vu 40 20  1 152      
    mov rdx,1095                          ;#0043BE74: 48:307302 47040000         uv 04 00  1 153      
    call #00441212 (:%pSubsss)            ;#0043BE7B: 350 92530000               v  00 00  1 153      
;  5235                 src[-1] = '\n'
    mov rdi,qword[#00402020]              ;#0043BE80: 48:213075 9961FCFF         uv 80 00  1 154      
    mov rcx,10                            ;#0043BE87: 48:307301 0A000000         vu 02 00  1 154      
    mov rsi,[rbp-72] (src)                ;#0043BE8E: 48:213165 B8               uv 40 20  1 155      
    lea rax,[rbp-72] (src)                ;#0043BE92: 48:215105 B8               vu 01 20  1 155      
    call #00440EB1 (:%pRepe1is)           ;#0043BE96: 350 16500000               v  00 00  1 156      
;  5236             end if
;  5237         end if
;  5238     end if
;  5239 
;  5240     if option=-2 then   -- GT_WHOLE_FILE
    mov rcx,[rbp-8] (option)              ;#0043BE9B: 48:213115 F8               uv 02 20  1 157      
    cmp rcx,-2                            ;#0043BE9F: 48:203371 FE               uv 00 02  1 158 02   
    jne #0043BEB2                         ;#0043BEA3: 165 0D                     v  00 00  1 158      
;  5241         return src
    mov rax,[rbp-72] (src)                ;#0043BEA5: 48:213105 B8               uv 01 20  1 159      
    mov [rbp-72] (src),rbx                ;#0043BEA9: 48:211135 B8               vu 00 28  1 159      
    jmp #0044298D (:%opRetf)              ;#0043BEAD: 351 DB6A0000               v  00 00  1 160      
;  5242     end if
;  5243 
;  5244     res = {}
    mov rdi,qword[#004022C8]              ;#0043BEB2: 48:213075 0F64FCFF         uv 80 00  1 161      
    mov rdx,[rbp-48] (res)                ;#0043BEB9: 48:213125 D0               vu 04 20  1 161      
    mov r15,h4                            ;#0043BEBD: 49:277 0000000000000040    uv 8000 00  1 162      
    cmp rdi,r15                           ;#0043BEC7: 4C:071377                  uv 00 8080  1 163 8000   
    jl #0043BED2                          ;#0043BECA: 174 06                     v  00 00  1 163      
    add qword[rbx+rdi*4-16],1             ;#0043BECC: 48:203104273 F0 01         u  00 88  3 164      
    mov [rbp-48] (res),rdi                ;#0043BED2: 48:211175 D0               vu 00 A0  1 166      
    mov r15,h4                            ;#0043BED6: 49:277 0000000000000040    uv 8000 00  1 167      
    cmp rdx,r15                           ;#0043BEE0: 4C:071372                  uv 00 8004  1 168 8000   
    jle #0043BEF2                         ;#0043BEE3: 176 0D                     v  00 00  1 168      
    sub qword[rbx+rdx*4-16],1             ;#0043BEE5: 48:203154223 F0 01         u  00 0C  3 169      
    jne #0043BEF2                         ;#0043BEEB: 165 05                     v  00 00  1 171      
    call #004422DA (:%pDealloc)           ;#0043BEED: 350 E8630000               v  00 00  1 172      
;  5245     i = 1
    mov qword[rbp-40] (i),1               ;#0043BEF2: 48:307105 D8 01000000      uv 00 20  1 173      
;  5246     start = 1
    mov qword[rbp-56] (start),1           ;#0043BEFA: 48:307105 C8 01000000      vu 00 20  1 173      
;  5247     while i<=filesize do
    mov rdi,[rbp-64] (filesize)           ;#0043BF02: 48:213175 C0               uv 80 20  1 174      
    mov rax,[rbp-40] (i)                  ;#0043BF06: 48:213105 D8               vu 01 20  1 174      
    mov rsi,1094                          ;#0043BF0A: 48:307306 46040000         uv 40 00  1 175      
    mov rdx,1091                          ;#0043BF11: 48:307302 43040000         vu 04 00  1 175      
    call #0043FA81 (:%opJcc)              ;#0043BF18: 350 643B0000               v  00 00  1 176      
    jg #0043C0D2                          ;#0043BF1D: 017217 AF010000            v  00 00  1 177      
;  5248         ch = src[i]
    mov rsi,[rbp-72] (src)                ;#0043BF23: 48:213165 B8               uv 40 20  1 178      
    mov r15,h4                            ;#0043BF27: 49:277 0000000000000040    vu 8000 00  1 178      
    cmp rsi,r15                           ;#0043BF31: 4C:071376                  uv 00 8040  1 179      
    jne #0043BF42                         ;#0043BF34: 165 0C                     v  00 00  1 179      
    mov rsi,1095                          ;#0043BF36: 48:307306 47040000         uv 40 00  1 180      
    call #00442D75 (:%pUnassigned)        ;#0043BF3D: 350 336E0000               v  00 00  1 180      
    mov rdi,[rbp-40] (i)                  ;#0043BF42: 48:213175 D8               uv 80 20  1 181      
    mov rdx,1095                          ;#0043BF46: 48:307302 47040000         vu 04 00  1 181      
    call #00441762 (:%pSubse1is)          ;#0043BF4D: 350 10580000               v  00 00  1 182      
    mov [rbp-24] (ch),rax                 ;#0043BF52: 48:211105 E8               uv 00 21  1 183      
;  5249         if ch='\r' or ch='\n' then
    cmp rax,13                            ;#0043BF56: 48:203370 0D               vu 00 01  1 183      
    je #0043BF66                          ;#0043BF5A: 164 0A                     v  00 00  1 184      
    cmp rax,10                            ;#0043BF5C: 48:203370 0A               uv 00 01  1 185      
    jne #0043C0AC                         ;#0043BF60: 017205 46010000            v  00 00  1 185      
;  5250             res = addline(res,i,start,option,filesize,src)
    mov rcx,8                             ;#0043BF66: 48:307301 08000000         uv 02 00  1 186      
    mov rdx,1075                          ;#0043BF6D: 48:307302 33040000         vu 04 00  1 186      
    call #004428DB (:%opFrame) (addline)  ;#0043BF74: 350 62690000               v  00 00  1 187      
    mov rdi,[rbp+40] (prevebp)            ;#0043BF79: 48:213175 28               uv 80 20  1 188      
    mov rax,[rdi-48]                      ;#0043BF7D: 48:213107 D0               uv 01 80  1 191 80 *80*
    mov [rdi-48],r15                      ;#0043BF81: 4C:211177 D0               vu 00 8080  1 191      
    mov [rbp] (res),rax                   ;#0043BF85: 48:211105 00               uv 00 21  1 192      
    mov rdi,[rbp+40] (prevebp)            ;#0043BF89: 48:213175 28               vu 80 20  1 192      
    mov rax,[rdi-40]                      ;#0043BF8D: 48:213107 D8               uv 01 80  1 195    *80*
    mov [rbp-8] (i),rax                   ;#0043BF91: 48:211105 F8               uv 00 21  1 196 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043BF95: 48:213175 28               vu 80 20  1 196      
    mov rax,[rdi-56]                      ;#0043BF99: 48:213107 C8               uv 01 80  1 199    *80*
    mov [rbp-16] (start),rax              ;#0043BF9D: 48:211105 F0               uv 00 21  1 200 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043BFA1: 48:213175 28               vu 80 20  1 200      
    mov rax,[rdi-8]                       ;#0043BFA5: 48:213107 F8               uv 01 80  1 203    *80*
    mov [rbp-24] (option),rax             ;#0043BFA9: 48:211105 E8               uv 00 21  1 204 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043BFAD: 48:213175 28               vu 80 20  1 204      
    mov rax,[rdi-64]                      ;#0043BFB1: 48:213107 C0               uv 01 80  1 207    *80*
    mov [rbp-32] (filesize),rax           ;#0043BFB5: 48:211105 E0               uv 00 21  1 208 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043BFB9: 48:213175 28               vu 80 20  1 208      
    mov rax,[rdi-72]                      ;#0043BFBD: 48:213107 B8               uv 01 80  1 211    *80*
    xor rbx,rbx                           ;#0043BFC1: 48:061333                  vu 08 08  1 211      
    mov r15,h4                            ;#0043BFC4: 49:277 0000000000000040    uv 8000 00  1 212      
    cmp rax,r15                           ;#0043BFCE: 4C:071370                  uv 00 8001  1 213 8000   
    jl #0043BFDE                          ;#0043BFD1: 174 0B                     v  00 00  1 213      
    add qword[rbx+rax*4-16],1             ;#0043BFD3: 48:203104203 F0 01         u  00 09  3 214      
    cmp eax,1095                          ;#0043BFD9: 075 47040000               vu 00 01  1 216      
    mov [rbp-40] (src),rax                ;#0043BFDE: 48:211105 D8               uv 00 21  1 217      
    mov qword[retaddr],#0043BFEF          ;#0043BFE2: 48:307105 20 EFBF4300      vu 00 20  1 217      
    jmp #0043C1B0 (code:addline)          ;#0043BFEA: 351 C1010000               v  00 00  1 218      
    push rax                              ;#0043BFEF: 120                        uv 00 01  1 219      
    mov rcx,[rbp-48] (res)                ;#0043BFF0: 48:213115 D0               vu 02 20  1 219      
    mov r15,h4                            ;#0043BFF4: 49:277 0000000000000040    uv 8000 00  1 220      
    cmp rcx,r15                           ;#0043BFFE: 4C:071371                  uv 00 8002  1 221 8000   
    jle #0043C013                         ;#0043C001: 176 10                     v  00 00  1 221      
    sub qword[rbx+rcx*4-16],1             ;#0043C003: 48:203154213 F0 01         u  00 0A  3 222      
    jne #0043C013                         ;#0043C009: 165 08                     v  00 00  1 224      
    mov rdx,rcx                           ;#0043C00B: 48:213321                  uv 04 02  1 225      
    call #004422DA (:%pDealloc)           ;#0043C00E: 350 C7620000               v  00 00  1 225      
    pop dword[rbp-48] (res)               ;#0043C013: 217105 D0                  np 00 20  3 226      
;  5251 --DEV tryme
;  5252 --          res = append(res,addline(i,start,option,filesize,src))
;  5253             ch = xor_bits(ch,0b0111)    -- '\n' <==> '\r'
    mov rdi,[rbp-24] (ch)                 ;#0043C016: 48:213175 E8               uv 80 20  1 229      
    xor rdi,7                             ;#0043C01A: 48:203367 07               uv 80 80  1 230 80   
    mov [rbp-24] (ch),rdi                 ;#0043C01E: 48:211175 E8               uv 00 A0  1 231 80   
;  5254             i += 1
    mov rsi,[rbp-40] (i)                  ;#0043C022: 48:213165 D8               vu 40 20  1 231      
    add rsi,1                             ;#0043C026: 48:203306 01               uv 40 40  1 232      
    mov rdx,rsi                           ;#0043C02A: 48:213326                  uv 04 40  1 233 40   
    mov [rbp-40] (i),rsi                  ;#0043C02D: 48:211165 D8               vu 00 60  1 233      
    shl rdx,1                             ;#0043C031: 48:321342                  u  04 04  1 234      
    jno #0043C03F                         ;#0043C034: 161 09                     v  00 00  1 234      
    lea rdi,[rbp-40] (i)                  ;#0043C036: 48:215175 D8               uv 80 20  1 235      
    call #00442DA9 (:%pAddiii)            ;#0043C03A: 350 6A6D0000               v  00 00  1 235      
;  5255             if i<=filesize and src[i]=ch then
    mov rax,[rbp-64] (filesize)           ;#0043C03F: 48:213105 C0               uv 01 20  1 236      
    cmp rsi,rax                           ;#0043C043: 48:071306                  uv 00 41  1 237 01   
    jg #0043C09F                          ;#0043C046: 177 57                     v  00 00  1 237      
    mov rcx,[rbp-72] (src)                ;#0043C048: 48:213115 B8               uv 02 20  1 238      
    mov r15,h4                            ;#0043C04C: 49:277 0000000000000040    vu 8000 00  1 238      
    cmp rcx,r15                           ;#0043C056: 4C:071371                  uv 00 8002  1 239      
    jne #0043C067                         ;#0043C059: 165 0C                     v  00 00  1 239      
    mov rsi,1095                          ;#0043C05B: 48:307306 47040000         uv 40 00  1 240      
    call #00442D75 (:%pUnassigned)        ;#0043C062: 350 0E6D0000               v  00 00  1 240      
    mov rdi,rsi                           ;#0043C067: 48:211367                  uv 80 40  1 241      
    mov rsi,rcx                           ;#0043C06A: 48:211316                  vu 40 02  1 241      
    mov rdx,1095                          ;#0043C06D: 48:307302 47040000         uv 04 00  1 242      
    call #00441762 (:%pSubse1is)          ;#0043C074: 350 E9560000               v  00 00  1 242      
    mov rdi,[rbp-24] (ch)                 ;#0043C079: 48:213175 E8               uv 80 20  1 243      
    cmp rax,rdi                           ;#0043C07D: 48:071370                  uv 00 81  1 244 80   
    jne #0043C09F                         ;#0043C080: 165 1D                     v  00 00  1 244      
;  5256                 i += 1
    mov rsi,[rbp-40] (i)                  ;#0043C082: 48:213165 D8               uv 40 20  1 245      
    add rsi,1                             ;#0043C086: 48:203306 01               uv 40 40  1 246 40   
    mov rdx,rsi                           ;#0043C08A: 48:213326                  uv 04 40  1 247 40   
    mov [rbp-40] (i),rsi                  ;#0043C08D: 48:211165 D8               vu 00 60  1 247      
    shl rdx,1                             ;#0043C091: 48:321342                  u  04 04  1 248      
    jno #0043C09F                         ;#0043C094: 161 09                     v  00 00  1 248      
    lea rdi,[rbp-40] (i)                  ;#0043C096: 48:215175 D8               uv 80 20  1 249      
    call #00442DA9 (:%pAddiii)            ;#0043C09A: 350 0A6D0000               v  00 00  1 249      
;  5257             end if
;  5258             start = i
    mov rcx,[rbp-40] (i)                  ;#0043C09F: 48:213115 D8               uv 02 20  1 250      
    mov [rbp-56] (start),rcx              ;#0043C0A3: 48:211115 C8               uv 00 22  1 251 02   
    jmp #0043BF02                         ;#0043C0A7: 351 56FEFFFF               v  00 00  1 251      
;  5259         else
;  5260             i += 1
    mov rax,[rbp-40] (i)                  ;#0043C0AC: 48:213105 D8               uv 01 20  1 252      
    add rax,1                             ;#0043C0B0: 48:203300 01               uv 01 01  1 253 01   
    mov rdx,rax                           ;#0043C0B4: 48:213320                  uv 04 01  1 254 01   
    mov [rbp-40] (i),rax                  ;#0043C0B7: 48:211105 D8               vu 00 21  1 254      
    shl rdx,1                             ;#0043C0BB: 48:321342                  u  04 04  1 255      
    jno #0043BF02                         ;#0043C0BE: 017201 3EFEFFFF            v  00 00  1 255      
    lea rdi,[rbp-40] (i)                  ;#0043C0C4: 48:215175 D8               uv 80 20  1 256      
    call #00442DA9 (:%pAddiii)            ;#0043C0C8: 350 DC6C0000               v  00 00  1 256      
;  5261         end if
;  5262     end while
    jmp #0043BF02                         ;#0043C0CD: 351 30FEFFFF               v  00 00  1 257      
;  5263     if start<=filesize then
    mov rdi,[rbp-64] (filesize)           ;#0043C0D2: 48:213175 C0               uv 80 20  1 258      
    mov rax,[rbp-56] (start)              ;#0043C0D6: 48:213105 C8               vu 01 20  1 258      
    mov rsi,1094                          ;#0043C0DA: 48:307306 46040000         uv 40 00  1 259      
    mov rdx,1093                          ;#0043C0E1: 48:307302 45040000         vu 04 00  1 259      
    call #0043FA81 (:%opJcc)              ;#0043C0E8: 350 94390000               v  00 00  1 260      
    jg #0043C1A3                          ;#0043C0ED: 017217 B0000000            v  00 00  1 261      
;  5264         res = addline(res,i,start,option,filesize,src)
    mov rcx,8                             ;#0043C0F3: 48:307301 08000000         uv 02 00  1 262      
    mov rdx,1075                          ;#0043C0FA: 48:307302 33040000         vu 04 00  1 262      
    call #004428DB (:%opFrame) (addline)  ;#0043C101: 350 D5670000               v  00 00  1 263      
    mov rdi,[rbp+40] (prevebp)            ;#0043C106: 48:213175 28               uv 80 20  1 264      
    mov rax,[rdi-48]                      ;#0043C10A: 48:213107 D0               uv 01 80  1 267 80 *80*
    mov [rdi-48],r15                      ;#0043C10E: 4C:211177 D0               vu 00 8080  1 267      
    mov [rbp] (res),rax                   ;#0043C112: 48:211105 00               uv 00 21  1 268      
    mov rdi,[rbp+40] (prevebp)            ;#0043C116: 48:213175 28               vu 80 20  1 268      
    mov rax,[rdi-40]                      ;#0043C11A: 48:213107 D8               uv 01 80  1 271    *80*
    mov [rbp-8] (i),rax                   ;#0043C11E: 48:211105 F8               uv 00 21  1 272 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043C122: 48:213175 28               vu 80 20  1 272      
    mov rax,[rdi-56]                      ;#0043C126: 48:213107 C8               uv 01 80  1 275    *80*
    mov [rbp-16] (start),rax              ;#0043C12A: 48:211105 F0               uv 00 21  1 276 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043C12E: 48:213175 28               vu 80 20  1 276      
    mov rax,[rdi-8]                       ;#0043C132: 48:213107 F8               uv 01 80  1 279    *80*
    mov [rbp-24] (option),rax             ;#0043C136: 48:211105 E8               uv 00 21  1 280 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043C13A: 48:213175 28               vu 80 20  1 280      
    mov rax,[rdi-64]                      ;#0043C13E: 48:213107 C0               uv 01 80  1 283    *80*
    mov [rbp-32] (filesize),rax           ;#0043C142: 48:211105 E0               uv 00 21  1 284 01   
    mov rdi,[rbp+40] (prevebp)            ;#0043C146: 48:213175 28               vu 80 20  1 284      
    mov rax,[rdi-72]                      ;#0043C14A: 48:213107 B8               uv 01 80  1 287    *80*
    xor rbx,rbx                           ;#0043C14E: 48:061333                  vu 08 08  1 287      
    mov r15,h4                            ;#0043C151: 49:277 0000000000000040    uv 8000 00  1 288      
    cmp rax,r15                           ;#0043C15B: 4C:071370                  uv 00 8001  1 289 8000   
    jl #0043C16B                          ;#0043C15E: 174 0B                     v  00 00  1 289      
    add qword[rbx+rax*4-16],1             ;#0043C160: 48:203104203 F0 01         u  00 09  3 290      
    cmp eax,1095                          ;#0043C166: 075 47040000               vu 00 01  1 292      
    mov [rbp-40] (src),rax                ;#0043C16B: 48:211105 D8               uv 00 21  1 293      
    mov qword[retaddr],#0043C17C          ;#0043C16F: 48:307105 20 7CC14300      vu 00 20  1 293      
    jmp #0043C1B0 (code:addline)          ;#0043C177: 351 34000000               v  00 00  1 294      
    push rax                              ;#0043C17C: 120                        uv 00 01  1 295      
    mov rsi,[rbp-48] (res)                ;#0043C17D: 48:213165 D0               vu 40 20  1 295      
    mov r15,h4                            ;#0043C181: 49:277 0000000000000040    uv 8000 00  1 296      
    cmp rsi,r15                           ;#0043C18B: 4C:071376                  uv 00 8040  1 297 8000   
    jle #0043C1A0                         ;#0043C18E: 176 10                     v  00 00  1 297      
    sub qword[rbx+rsi*4-16],1             ;#0043C190: 48:203154263 F0 01         u  00 48  3 298      
    jne #0043C1A0                         ;#0043C196: 165 08                     v  00 00  1 300      
    mov rdx,rsi                           ;#0043C198: 48:213326                  uv 04 40  1 301      
    call #004422DA (:%pDealloc)           ;#0043C19B: 350 3A610000               v  00 00  1 301      
    pop dword[rbp-48] (res)               ;#0043C1A0: 217105 D0                  np 00 20  3 302      
;  5265     end if
;  5266  #ilASM{ ::retZ2 }
;  5267     return res
    mov rax,[rbp-48] (res)                ;#0043C1A3: 48:213105 D0               uv 01 20  1 305      
    mov [rbp-48] (res),rbx                ;#0043C1A7: 48:211135 D0               vu 00 28  1 305      
    jmp #0044298D (:%opRetf)              ;#0043C1AB: 351 DD670000               v  00 00  1 306      
;  5268 end function
;  5269 
;  5270 
;  5271 --
;  5272 --integer flag
;  5273 --sequence expected
;  5274 --procedure test(sequence src)
;  5275 --sequence res
;  5276 --  res = get_text(src,flag)
;  5277 --  if res!=expected then ?9/0 end if
;  5278 --end procedure
;  5279 --if 01 then
;  5280 ----    -2: (GT_WHOLE_FILE) get whole file as one long string, plus final '\n' if missing.
;  5281 ----         (tests: "a\nb\n" from both "a\nb" and "a\nb\n")
;  5282 --  flag = -2
;  5283 --  expected = "a\nb\n"
;  5284 --  test("a\nb")
;  5285 --  test("a\nb\n")
;  5286 --
;  5287 ----    -1: (GT_LF_STRIPPED) cr-stripped lines
;  5288 ----         (eg: {"a","b"} from both "a\nb" and "a\nb\n")
;  5289 ----         (tests: {"a","b"} from "a\nb", "a\nb\n", "a\r\nb", "a\r\nb\r\n", "a\n\rb\n\r", "a\rb", "a\rb\r")
;  5290 --  flag = -1
;  5291 --  expected = {"a","b"}
;  5292 --  test("a\nb")
;  5293 --  test("a\nb\n")
;  5294 --  test("a\r\nb\n")
;  5295 --  test("a\r\nb\r")
;  5296 --  test("a\r\nb")
;  5297 --  test("a\r\nb\r\n")
;  5298 --  test("a\n\rb\n\r")
;  5299 --  test("a\rb")
;  5300 --  test("a\rb\r")
;  5301 --  expected = {"a",""}
;  5302 --  test("a\r\r")
;  5303 --  test("a\n\n")
;  5304 --  test("a\n\r\n\r")
;  5305 --  test("a\r\n\r\n")
;  5306 --
;  5307 ----     0: (GT_LF_LEFT) '\n' left on lines,
;  5308 ----         (tests: {"a\n","b"} from "a\nb" but {"a\n","b\n"} from "a\nb\n")
;  5309 ----        (it should be clear from these tests that being fussy about the
;  5310 ----         last line probably just complicates things unnecessarily.)
;  5311 --  flag = 0
;  5312 --  expected = {"a\n","b"}
;  5313 --  test("a\nb")
;  5314 --  test("a\r\nb")
;  5315 --  test("a\n\rb")
;  5316 --  expected = {"a\n","b\n"}
;  5317 --  test("a\nb\n")
;  5318 --  test("a\r\nb\n")
;  5319 --  test("a\r\nb\r")
;  5320 --  expected = {"a\n","b"}
;  5321 --  test("a\r\nb")
;  5322 --  expected = {"a\n","b\n"}
;  5323 --  test("a\r\nb\r\n")
;  5324 --  test("a\n\rb\n\r")
;  5325 --  expected = {"a\n","b"}
;  5326 --  test("a\rb")
;  5327 --  expected = {"a\n","b\n"}
;  5328 --  test("a\rb\r")
;  5329 --  expected = {"a\n","\n"}
;  5330 --  test("a\r\r")
;  5331 --  test("a\n\n")
;  5332 --  test("a\n\r\n\r")
;  5333 --  test("a\r\n\r\n")
;  5334 --
;  5335 ----    +1: (GT_LF_LAST) '\n' left on lines, and put on last line if missing.
;  5336 ----         (tests: {"a\n","b\n"} from both "a\nb" and "a\nb\n")
;  5337 --  flag = +1
;  5338 --  expected = {"a\n","b\n"}
;  5339 --  test("a\nb")
;  5340 --  test("a\nb\n")
;  5341 --  test("a\r\nb\n")
;  5342 --  test("a\r\nb\r")
;  5343 --  test("a\r\nb")
;  5344 --  test("a\r\nb\r\n")
;  5345 --  test("a\n\rb\n\r")
;  5346 --  test("a\rb")
;  5347 --  test("a\rb\r")
;  5348 --  expected = {"a\n","\n"}
;  5349 --  test("a\r\r")
;  5350 --  test("a\n\n")
;  5351 --  test("a\n\r\n\r")
;  5352 --  test("a\r\n\r\n")
;  5353 --end if
;  5354 
;  5355 --/*
;  5356 constant ModeFlagSet = {{0,         "closed"},
;  5357                         {F_READ,    "read"  },
;  5358                         {F_WRITE,   "write" },
;  5359                         {F_BINARY,  "binary"},
;  5360                         {F_DIRTY,   "dirty" }}
;  5361 
;  5362 --:%opIOdiag?? (I somehow think this as passed it's use by date)
;  5363 global procedure fiodiag(integer fn)
;  5364 integer fidx
;  5365 --atom this
;  5366 integer iThis
;  5367 atom fhandle
;  5368 integer fmode
;  5369 string smode
;  5370 integer fposn
;  5371 integer fend
;  5372 atom frealposn
;  5373     fidx = fn-2
;  5374 --DEV use get_this()?
;  5375     #ilASM{
;  5376         [32]
;  5377             mov edx,[fidx]
;  5378             shl edx,2
;  5379           @@:
;  5380             mov edi,[fdtbl]
;  5381             mov esi,[edx+edi*4-4]   -- esi:=fdtbl[fidx]
;  5382             cmp edi,[fdtbl]
;  5383             jne @b
;  5384             mov eax,[ebx+esi*4+MODE]
;  5385             mov [iThis],esi
;  5386             mov [fmode],eax
;  5387             lea edi,[fhandle]
;  5388             fild dword[ebx+esi*4+HNDL]
;  5389             call :%pStoreFlt
;  5390             lea edi,[fposn]
;  5391             fild dword[ebx+esi*4+POSN]
;  5392             call :%pStoreFlt
;  5393             lea edi,[fend]
;  5394             fild dword[ebx+esi*4+FEND]
;  5395             call :%pStoreFlt
;  5396             lea edi,[frealposn]
;  5397             fild qword[ebx+esi*4+POSL]
;  5398             call :%pStoreFlt
;  5399         [64]
;  5400             mov rdx,[fidx]
;  5401             shl rdx,3
;  5402           @@:
;  5403             mov rdi,[fdtbl]
;  5404             mov rsi,[rdx+rdi*4-8]   -- esi:=fdtbl[fidx]
;  5405             cmp rdi,[fdtbl]
;  5406             jne @b
;  5407             mov rax,[rbx+rsi*4+MODE64]
;  5408             mov [iThis],rsi
;  5409             mov [fmode],rax
;  5410             lea edi,[fhandle]
;  5411             fild qword[rbx+rsi*4+HNDL64]
;  5412             call :%pStoreFlt
;  5413             lea edi,[fposn]
;  5414             fild qword[rbx+rsi*4+POSN64]
;  5415             call :%pStoreFlt
;  5416             lea edi,[fend]
;  5417             fild qword[rbx+rsi*4+FEND64]
;  5418             call :%pStoreFlt
;  5419             lea edi,[frealposn]
;  5420             fild qword[rbx+rsi*4+RPOS64]
;  5421             call :%pStoreFlt
;  5422           }
;  5423 --  if machine_bits()=32 then
;  5424 --      fhandle = peek4u(iThis*4+HNDL)
;  5425 ----        fmode = peek4u(iThis*4+MODE)
;  5426 --      fposn = peek4u(iThis*4+POSN)
;  5427 --      fend = peek4u(iThis*4+FEND)
;  5428 --      frealposn = peek8u(iThis*4+POSL)
;  5429 --  else
;  5430 --      ?9/0
;  5431 --  end if
;  5432     smode = decode_flags(ModeFlagSet,fmode)
;  5433     printf(1,"Handle:#%08x, Mode:#%02x(%s), Posn:%d, Fend:%d, realposn:%d\n",{fhandle,fmode,smode,fposn,fend,frealposn})
;  5434     if machine_bits()=32 then
;  5435         ?peek({iThis*4+BUFF,10})
;  5436     else
;  5437         ?peek({iThis*4+BUFF64,10})
;  5438     end if
;  5439 end procedure
;  5440 --*/
;  5441 
;  5442 --global function get_position()
;  5443 --  :%opGetPos
;  5444 function fget_position()
;  5445 integer posX,posY
;  5446     if not cinit then initConsole() end if
    mov rdi,[#004031C0] (cinit)           ;#0043B950: 48:213075 6978FCFF         uv 80 00  1   1      
    test rdi,rdi                          ;#0043B957: 48:205377                  uv 00 80  1   2 80   
    jne #0043B978                         ;#0043B95A: 165 1C                     v  00 00  1   2      
    xor rcx,rcx                           ;#0043B95C: 48:061311                  uv 02 02  1   3      
    mov rdx,1008                          ;#0043B95F: 48:307302 F0030000         vu 04 00  1   3      
    call :%opFrame (initConsole)          ;#0043B966: 350 706F0000               v  00 00  1   4      
    mov qword[retaddr],#0043B978          ;#0043B96B: 48:307105 20 78B94300      uv 00 20  1   5      
    jmp #0043B59C (code:initConsole)      ;#0043B973: 351 24FCFFFF               v  00 00  1   5      
;  5447 --  #ilASM{ call :%pClearDbg }
;  5448     #ilASM{
;  5449         [PE32]
;  5450             sub esp,sizeof_CSBI
;  5451             mov eax,[stdout]
;  5452             mov edi,esp
;  5453             push edi                                        -- lpConsoleScreenBufferInfo
;  5454             push eax                                        -- hConsoleOutput
;  5455             call "kernel32.dll","GetConsoleScreenBufferInfo"
;  5456 --          test eax,eax
;  5457 --          jz ??? [DEV]
;  5458             xor eax,eax
;  5459             xor ecx,ecx
;  5460             mov ax,[edi+CSBI_CPOSX]
;  5461             mov cx,[edi+CSBI_CPOSY]
;  5462             mov [posX],eax
;  5463             mov [posY],ecx
;  5464             add esp,sizeof_CSBI
;  5465         [ELF32]
;  5466             pop al
;  5467         [PE64]
;  5468             sub rsp,sizeof_CSBI64
                    sub rsp,24            ;#0043B978: 48:203354 18               uv 10 10  1   6      
;  5469             mov rdx,rsp
                    mov rdx,rsp           ;#0043B97C: 48:213324                  uv 04 10  1   7 10   
;  5470             sub rsp,8*5
                    sub rsp,40            ;#0043B97F: 48:203354 28               vu 10 10  1   7      
;  5471 --          (rdx already set)                               -- lpConsoleScreenBufferInfo
;  5472             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B983: 48:213015 2678FCFF         uv 02 00  1   8      
;  5473             call "kernel32.dll","GetConsoleScreenBufferInfo"
                    call [GetConsoleScreenBufferInfo]  ;#0043B98A: 377025 F056FCFF            np 00 00  2   9      
;  5474             add rsp,8*5
                    add rsp,40            ;#0043B990: 48:203304 28               uv 10 10  1  11      
;  5475 --          test eax,eax
;  5476 --          jz ??? [DEV]
;  5477             xor rax,rax
                    xor rax,rax           ;#0043B994: 48:061300                  vu 01 01  1  11      
;  5478             xor rcx,rcx
                    xor rcx,rcx           ;#0043B997: 48:061311                  uv 02 02  1  12      
;  5479             mov ax,[edi+CSBI_CPOSX]
                    mov ax,word[edi+4]    ;#0043B99A: 146:213107 04              vu 01 80  1  12      
;  5480             mov cx,[edi+CSBI_CPOSY]
                    mov cx,word[edi+6]    ;#0043B99E: 146:213117 06              uv 02 80  1  13      
;  5481             mov [posX],eax
                    mov [ebp] (posX),eax  ;#0043B9A2: 211105 00                  vu 00 21  1  13      
;  5482             mov [posY],ecx
                    mov [ebp-8] (posY),ecx  ;#0043B9A5: 211115 F8                  uv 00 22  1  14      
;  5483             add rsp,sizeof_CSBI64
                    add rsp,24            ;#0043B9A8: 48:203304 18               vu 10 10  1  14      
;  5484         [ELF64]
;  5485             pop al
;  5486         []
;  5487           }
;  5488     return {posY,posX}
    mov rax,[rbp] (posX)                  ;#0043B9AC: 48:213105 00               uv 01 20  1  15      
    mov r15,h4                            ;#0043B9B0: 49:277 0000000000000040    vu 8000 00  1  15      
    cmp rax,r15                           ;#0043B9BA: 4C:071370                  uv 00 8001  1  16      
    jne #0043B9CB                         ;#0043B9BD: 165 0C                     v  00 00  1  16      
    mov rsi,1103                          ;#0043B9BF: 48:307306 4F040000         uv 40 00  1  17      
    call #00442D75 (:%pUnassigned)        ;#0043B9C6: 350 AA730000               v  00 00  1  17      
    mov rsi,[rbp-8] (posY)                ;#0043B9CB: 48:213165 F8               uv 40 20  1  18      
    mov r15,h4                            ;#0043B9CF: 49:277 0000000000000040    vu 8000 00  1  18      
    cmp rsi,r15                           ;#0043B9D9: 4C:071376                  uv 00 8040  1  19      
    jne #0043B9EA                         ;#0043B9DC: 165 0C                     v  00 00  1  19      
    mov rsi,1104                          ;#0043B9DE: 48:307306 50040000         uv 40 00  1  20      
    call #00442D75 (:%pUnassigned)        ;#0043B9E5: 350 8B730000               v  00 00  1  20      
    lea rax,[rbp-16] (symtab[1105])       ;#0043B9EA: 48:215105 F0               uv 01 20  1  21      
    mov rdx,2                             ;#0043B9EE: 48:307302 02000000         vu 04 00  1  21      
    push #0043BA08                        ;#0043B9F5: 150 08BA4300               uv 00 00  1  22      
    push rax                              ;#0043B9FA: 120                        vu 00 01  1  22      
    push qword[rbp] (posX)                ;#0043B9FB: 377165 00                  np 00 20  2  23      
    push rsi                              ;#0043B9FE: 126                        uv 00 40  1  25      
    mov rdi,[rbp-16] (symtab[1105])       ;#0043B9FF: 48:213175 F0               vu 80 20  1  25      
    jmp #004404BD (:%pMkSq)               ;#0043BA03: 351 B54A0000               v  00 00  1  26      
    mov rax,[rbp-16] (symtab[1105])       ;#0043BA08: 48:213105 F0               uv 01 20  1  27      
    mov [rbp-16] (symtab[1105]),rbx       ;#0043BA0C: 48:211135 F0               vu 00 28  1  27      
    jmp #0044298D (:%opRetf)              ;#0043BA10: 351 786F0000               v  00 00  1  28      
;  5489 end function
;  5490 
;  5491 --  :%opWrap
;  5492 --global procedure wrap(integer flag)
;  5493 procedure fwrap(integer flag)
    mov rsi,[rbp] (flag)                  ;#0043B8AD: 48:213165 00               uv 40 20  1   1      
    mov r15,h4                            ;#0043B8B1: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0043B8BB: 4C:071376                  uv 00 8040  1   2      
    jl #0043B8CC                          ;#0043B8BE: 174 0C                     v  00 00  1   2      
    mov rcx,1107                          ;#0043B8C0: 48:307301 53040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043B8C7: 350 8C710000               v  00 00  1   3      
;  5494 --atom pMode = allocate(4) [and I never free()'d that!]
;  5495 --integer Mode, blSet
;  5496 
;  5497     if not cinit then initConsole() end if
    mov rcx,[#004031C0] (cinit)           ;#0043B8CC: 48:213015 ED78FCFF         uv 02 00  1   4      
    test rcx,rcx                          ;#0043B8D3: 48:205311                  uv 00 02  1   5 02   
    jne #0043B8F4                         ;#0043B8D6: 165 1C                     v  00 00  1   5      
    xor rcx,rcx                           ;#0043B8D8: 48:061311                  uv 02 02  1   6      
    mov rdx,1008                          ;#0043B8DB: 48:307302 F0030000         vu 04 00  1   6      
    call :%opFrame (initConsole)          ;#0043B8E2: 350 F46F0000               v  00 00  1   7      
    mov qword[retaddr],#0043B8F4          ;#0043B8E7: 48:307105 20 F4B84300      uv 00 20  1   8      
    jmp #0043B59C (code:initConsole)      ;#0043B8EF: 351 A8FCFFFF               v  00 00  1   8      
;  5498 --> if not c_func(xGetConsoleMode,{stdout,pMode}) then ?9/0 end if
;  5499 --  Mode = peek4u(pMode)
;  5500 --  blSet = (and_bits(Mode,ENABLE_WRAP_AT_EOL_OUTPUT)!=0)
;  5501 ----    if blSet!=flag then
;  5502 --  if blSet=(not flag) then -- (as "", but treats all flag!=0 as true)
;  5503 --      if flag=0 then
;  5504 --          Mode -= ENABLE_WRAP_AT_EOL_OUTPUT
;  5505 --      else
;  5506 --          Mode += ENABLE_WRAP_AT_EOL_OUTPUT
;  5507 --      end if
;  5508 --      if not c_func(xSetConsoleMode,{stdout,Mode}) then ?9/0 end if
;  5509 --  end if
;  5510     #ilASM{
;  5511         [PE32]
;  5512             push ebx    -- pMode
;  5513             push esp                        -- lpMode
;  5514             push [stdout]                   -- hConsoleHandle
;  5515             call "kernel32.dll","GetConsoleMode"
;  5516             mov eax,[esp]
;  5517             xor edx,edx
;  5518             and eax,ENABLE_WRAP_AT_EOL_OUTPUT
;  5519             cmp [flag],0
;  5520             je @f
;  5521                 mov edx,ENABLE_WRAP_AT_EOL_OUTPUT
;  5522           @@:
;  5523             -- edx is now "desired", eax is "actual" (one bit only)
;  5524             cmp eax,edx
;  5525             pop eax
;  5526             je @f
;  5527                 xor eax,ENABLE_WRAP_AT_EOL_OUTPUT   -- toggle
;  5528                 push eax                            -- dwMode
;  5529                 push [stdout]                       -- hConsoleHandle
;  5530                 call "kernel32.dll","SetConsoleMode"
;  5531           @@:
;  5532         [PE64]
;  5533 --          push ebx    -- pMode
;  5534             sub rsp,8*5
                    sub rsp,40            ;#0043B8F4: 48:203354 28               uv 10 10  1   9      
;  5535             mov [rsp+32],rbx
                    mov [rsp+32],rbx      ;#0043B8F8: 48:211134044 20            uv 00 18  1  12 10 *10*
;  5536             lea rdx,[rsp+32]                    -- lpMode
                    lea rdx,[rsp+32]      ;#0043B8FD: 48:215124044 20            vu 04 10  1  12      
;  5537             mov rcx,[stdout]                    -- hConsoleHandle
                    mov rcx,[#004031B0] (stdout)  ;#0043B902: 48:213015 A778FCFF         uv 02 00  1  13      
;  5538             call "kernel32.dll","GetConsoleMode"
                    call [#00401078] (GetConsoleMode)  ;#0043B909: 377025 6957FCFF            np 00 00  2  14      
;  5539             mov rax,[rsp+32]
                    mov rax,[rsp+32]      ;#0043B90F: 48:213104044 20            uv 01 10  1  16      
;  5540             xor rdx,rdx
                    xor rdx,rdx           ;#0043B914: 48:061322                  vu 04 04  1  16      
;  5541             and rax,ENABLE_WRAP_AT_EOL_OUTPUT
                    and rax,2             ;#0043B917: 48:203340 02               uv 01 01  1  17      
;  5542             cmp [flag],0
                    cmp qword[rbp] (flag),0  ;#0043B91B: 48:203175 00 00            u  00 20  2  18      
;  5543             je @f
                    je #0043B929          ;#0043B920: 164 07                     v  00 00  1  19      
;  5544                 mov rdx,ENABLE_WRAP_AT_EOL_OUTPUT
                        mov rdx,2         ;#0043B922: 48:307302 02000000         uv 04 00  1  20      
;  5545           @@:
;  5546             -- edx is now "desired", eax is "actual" (one bit only)
;  5547             cmp rax,rdx
                    cmp rax,rdx           ;#0043B929: 48:071320                  uv 00 05  1  21 04   
;  5548             mov rax,[rsp+32]
                    mov rax,[rsp+32]      ;#0043B92C: 48:213104044 20            vu 01 10  1  21      
;  5549             je @f
                    je #0043B947          ;#0043B931: 164 14                     v  00 00  1  22      
;  5550                 xor rax,ENABLE_WRAP_AT_EOL_OUTPUT   -- toggle
                        xor rax,2         ;#0043B933: 48:203360 02               uv 01 01  1  23      
;  5551                 mov rdx,rax                         -- dwMode
                        mov rdx,rax       ;#0043B937: 48:213320                  uv 04 01  1  24 01   
;  5552                 mov rcx,[stdout]                    -- hConsoleHandle
                        mov rcx,[#004031B0] (stdout)  ;#0043B93A: 48:213015 6F78FCFF         vu 02 00  1  24      
;  5553                 call "kernel32.dll","SetConsoleMode"
                        call [#00401110] (SetConsoleMode)  ;#0043B941: 377025 C957FCFF            np 00 00  2  25      
;  5554           @@:
;  5555             add rsp,8*5
                    add rsp,40            ;#0043B947: 48:203304 28               uv 10 10  1  27      
;  5556         [ELF32]
;  5557             pop al
;  5558         [ELF64]
;  5559             pop al
;  5560         []
;  5561           }
    jmp #0044298D (:%opRetf)              ;#0043B94B: 351 3D700000               v  00 00  1  27      
;  5562 end procedure
;  5563 
;  5564 ----DEV not quite right... (now in builtins\pScrollN.e)
;  5565 ----    :%opScroll
;  5566 ----global procedure scroll(integer amount, integer top, integer bottom)
;  5567 --procedure fscroll(integer amount, integer top, integer bottom)
;  5568 --integer right
;  5569 --integer attributes
;  5570 --
;  5571 --  if not cinit then initConsole() end if
;  5572 --  #ilASM{
;  5573 --      [PE32]
;  5574 --          sub esp,sizeof_CSBI
;  5575 --          mov eax,[stdout]
;  5576 --          mov edi,esp
;  5577 --          push edi                                        -- lpConsoleScreenBufferInfo
;  5578 --          push eax                                        -- hConsoleOutput
;  5579 --          call "kernel32.dll","GetConsoleScreenBufferInfo"
;  5580 ----            test eax,eax
;  5581 ----            jz ??? [DEV]
;  5582 --          xor eax,eax
;  5583 --          xor ecx,ecx
;  5584 --          mov ax,[edi+CSBI_SIZEX]
;  5585 --          mov cx,[edi+CSBI_ATTR]
;  5586 --          sub eax,1
;  5587 --          mov [attributes],ecx
;  5588 --          mov [right],eax
;  5589 --          add esp,sizeof_CSBI
;  5590 --      [ELF32]
;  5591 --          pop al
;  5592 --      [PE64]
;  5593 --          sub rsp,sizeof_CSBI64
;  5594 --          mov rdi,rsp
;  5595 --          sub rsp,8*5
;  5596 --          mov rdx,rdi                                     -- lpConsoleScreenBufferInfo
;  5597 --          mov rcx,[stdout]                                -- hConsoleOutput
;  5598 --          call "kernel32.dll","GetConsoleScreenBufferInfo"
;  5599 --          add rsp,8*5         
;  5600 ----            test rax,rax
;  5601 ----            jz ??? [DEV]
;  5602 --          xor rax,rax
;  5603 --          xor rcx,rcx
;  5604 --          mov ax,[rdi+CSBI_SIZEX]
;  5605 --          mov cx,[rdi+CSBI_ATTR]
;  5606 --          sub rax,1
;  5607 --          mov [attributes],rcx
;  5608 --          mov [right],rax
;  5609 --          add rsp,sizeof_CSBI64
;  5610 --      [ELF64]
;  5611 --          pop al
;  5612 --      []
;  5613 --        }
;  5614 --  if abs(amount)>abs(bottom-top) then
;  5615 --      for i=top-1 to bottom-1 do
;  5616 --          #ilASM{
;  5617 --              [PE32]
;  5618 --                  push ebx    -- space for NumberOf(Attrs|Chars)Written
;  5619 --                  mov esi,esp
;  5620 --                  mov eax,[i]
;  5621 --                  -- push params for FillConsoleOutputAttribute first (before regs get damaged)
;  5622 --                  push esi                                    -- lpNumberOfAttrsWritten
;  5623 --                  shl eax,16                                  -- a COORD of {0,i}
;  5624 --                  mov ecx,[right]
;  5625 --                  mov edx,[attributes]
;  5626 --                  mov edi,[stdout]
;  5627 --                  push eax                                    -- dwWriteCoord
;  5628 --                  push ecx                                    -- nLength
;  5629 --                  push edx                                    -- wAttribute
;  5630 --                  push edi                                    -- hConsoleOutput
;  5631 --                  -- now params for FillConsoleOutputCharacter
;  5632 --                  push esi                                    -- lpNumberOfCharsWritten
;  5633 --                  push eax                                    -- dwWriteCoord
;  5634 --                  push ecx                                    -- nLength
;  5635 --                  push ' '                                    -- cCharacter
;  5636 --                  push edi                                    -- hConsoleOutput
;  5637 --                  call "kernel32.dll","FillConsoleOutputCharacterA"
;  5638 --                  call "kernel32.dll","FillConsoleOutputAttribute"
;  5639 --                  pop eax     -- discard NumberOf(Attrs|Chars)Written
;  5640 --              [ELF32]
;  5641 --                  pop al
;  5642 --              [PE64]
;  5643 --                  sub rsp,8*7
;  5644 --                  mov rsi,[i]
;  5645 --                  xor rdx,rdx
;  5646 --                  lea rdi,[rsp+40]                            -- (repeserved over api calls)
;  5647 --                  shl rsi,16                                  -- a COORD of {0,i} (preserved over api calls)
;  5648 --                  mov [rsp+32],rdi                                    -- lpNumberOfCharsWritten
;  5649 --                  mov r9,rsi                                          -- dwWriteCoord
;  5650 --                  mov r8,[right]                                      -- nLength
;  5651 ----DEV check this in list.asm:
;  5652 ----                    mov rdx,dword' '                                    -- cCharacter
;  5653 --                  mov dl,' '
;  5654 --                  mov rcx,[stdout]                                    -- hConsoleOutput
;  5655 --                  call "kernel32.dll","FillConsoleOutputCharacterA"
;  5656 --                  mov [rsp+32],rdi                                    -- lpNumberOfAttrsWritten
;  5657 --                  mov r9,rsi                                          -- dwWriteCoord
;  5658 --                  mov r8,[right]                                      -- nLength
;  5659 --                  mov edx,[attributes]                                -- wAttribute
;  5660 --                  mov rcx,[stdout]                                    -- hConsoleOutput
;  5661 --                  call "kernel32.dll","FillConsoleOutputAttribute"
;  5662 --                  add rsp,8*7
;  5663 --              [ELF64]
;  5664 --                  pop al
;  5665 --              []
;  5666 --                }
;  5667 --      end for
;  5668 --  else
;  5669 ----        poke2(pSMALLRECT,{0,top-1,right,bottom-1})
;  5670 ----        poke2(pCHARINFO,{' ',attributes})
;  5671 ----        dest = (top-1-amount)*#10000    -- a COORD of {0,top-1-amount}
;  5672 ---->   if not c_func(xScrollConsoleScreenBuffer,{stdout,pSMALLRECT,NULL,dest,pCHARINFO}) then ?9/0 end if
;  5673 --      #ilASM{
;  5674 --          [PE32]
;  5675 --              sub esp,sizeof_SMALL_RECT
;  5676 --              mov edi,esp
;  5677 --              sub esp,sizeof_CHAR_INFO
;  5678 --              mov esi,esp
;  5679 --              mov eax,[top]
;  5680 --              mov ecx,[right]
;  5681 --              sub eax,1
;  5682 --              mov edx,[attributes]
;  5683 --              mov [edi+SR_Left],bx    -- 0
;  5684 --              mov [edi+SR_Top],ax     -- top-1
;  5685 --              mov [edi+SR_Right],cx   -- right
;  5686 ----DEV not yet supported..
;  5687 ----                sub eax,[amount]
;  5688 --              mov ecx,[amount]
;  5689 --              sub eax,ecx
;  5690 --              mov ecx,[bottom]
;  5691 ----DEV... (same op)
;  5692 ----                sal eax,16              -- a COORD of {0,top-1-amount}
;  5693 --              shl eax,16              -- a COORD of {0,top-1-amount}
;  5694 --              mov [esi+CI_UnicodeChar],word' '
;  5695 --              sub ecx,1
;  5696 --              mov [esi+CI_Attributes],dx
;  5697 --              mov [edi+SR_Bottom],cx  -- bottom-1
;  5698 --              push esi                                    -- lpFill
;  5699 --              push eax                                    -- dwDestinationOrigin
;  5700 --              push ebx                                    -- lpClipRectangle(NULL)
;  5701 --              push edi                                    -- lpScrollRectangle
;  5702 --              push dword[stdout]                          -- hConsoleOutput
;  5703 --              call "kernel32.dll","ScrollConsoleScreenBufferA"
;  5704 --              add esp,sizeof_CHAR_INFO+sizeof_SMALL_RECT
;  5705 --          [ELF32]
;  5706 --              pop al
;  5707 --          [PE64]
;  5708 --              sub rsp,sizeof_SMALL_RECT64
;  5709 --              mov rdi,rsp
;  5710 --              sub rsp,sizeof_CHAR_INFO64
;  5711 --              mov rsi,rsp
;  5712 --              mov rax,[top]
;  5713 --              mov rcx,[right]
;  5714 --              sub rax,1
;  5715 --              mov rdx,[attributes]
;  5716 --              mov [rdi+SR_Left],bx    -- 0
;  5717 --              mov [rdi+SR_Top],ax     -- top-1
;  5718 --              mov [rdi+SR_Right],cx   -- right
;  5719 ----DEV not yet supported..
;  5720 ----                sub rax,[amount]
;  5721 --              mov rcx,[amount]
;  5722 --              sub rax,rcx
;  5723 --              mov rcx,[bottom]
;  5724 ----DEV... (same op)
;  5725 ----                sal rax,16              -- a COORD of {0,top-1-amount}
;  5726 --              shl rax,16              -- a COORD of {0,top-1-amount}
;  5727 --              mov [rsi+CI_UnicodeChar],word' '
;  5728 --              sub rcx,1
;  5729 --              mov [rsi+CI_Attributes],dx
;  5730 --              mov [rdi+SR_Bottom],cx  -- bottom-1
;  5731 --              sub rsp,8*5
;  5732 --              mov [rsp+32],rsi                            -- lpFill
;  5733 --              mov r9,rax                                  -- dwDestinationOrigin
;  5734 --              mov r8,rbx                                  -- lpClipRectangle(NULL)
;  5735 --              mov rdx,rdi                                 -- lpScrollRectangle
;  5736 --              mov rcx,[stdout]                            -- hConsoleOutput
;  5737 --              call "kernel32.dll","ScrollConsoleScreenBufferA"
;  5738 --              add rsp,8*5
;  5739 --              add rsp,sizeof_CHAR_INFO+sizeof_SMALL_RECT
;  5740 --          [ELF64]
;  5741 --              pop al
;  5742 --          []
;  5743 --            }
;  5744 --  end if
;  5745 --end procedure
;  5746 
;  5747 --  :%opTextRows
;  5748 --global function text_rows(integer newrows)
;  5749 function ftext_rows(integer newrows)
    mov rax,[rbp] (newrows)               ;#0043B7DC: 48:213105 00               uv 01 20  1   1      
    mov r15,h4                            ;#0043B7E0: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rax,r15                           ;#0043B7EA: 4C:071370                  uv 00 8001  1   2      
    jl #0043B7FB                          ;#0043B7ED: 174 0C                     v  00 00  1   2      
    mov rcx,1110                          ;#0043B7EF: 48:307301 56040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043B7F6: 350 5D720000               v  00 00  1   3      
;  5750 integer res
;  5751     if newrows<1 then ?9/0 end if
    cmp rax,1                             ;#0043B7FB: 48:203370 01               uv 00 01  1   4      
    jge #0043B806                         ;#0043B7FF: 175 05                     v  00 00  1   4      
    call #00442DD2 (:%pDiv0)              ;#0043B801: 350 CC750000               v  00 00  1   5      
;  5752     if not cinit then initConsole() end if
    mov rdi,[#004031C0] (cinit)           ;#0043B806: 48:213075 B379FCFF         uv 80 00  1   6      
    test rdi,rdi                          ;#0043B80D: 48:205377                  uv 00 80  1   7 80   
    jne #0043B82E                         ;#0043B810: 165 1C                     v  00 00  1   7      
    xor rcx,rcx                           ;#0043B812: 48:061311                  uv 02 02  1   8      
    mov rdx,1008                          ;#0043B815: 48:307302 F0030000         vu 04 00  1   8      
    call :%opFrame (initConsole)          ;#0043B81C: 350 BA700000               v  00 00  1   9      
    mov qword[retaddr],#0043B82E          ;#0043B821: 48:307105 20 2EB84300      uv 00 20  1  10      
    jmp #0043B59C (code:initConsole)      ;#0043B829: 351 6EFDFFFF               v  00 00  1  10      
;  5753     #ilASM{
;  5754         [PE32]
;  5755             sub esp,sizeof_CSBI
;  5756             mov esi,[stdout]
;  5757             mov edi,esp
;  5758             push edi                                            -- lpConsoleScreenBufferInfo
;  5759             push esi                                            -- hConsoleOutput
;  5760             call "kernel32.dll","GetConsoleScreenBufferInfo"
;  5761 --          test eax,eax
;  5762 --          jz ??? [DEV]
;  5763             mov edx,[newrows]
;  5764             shl edx,16
;  5765             mov dx,[edi+CSBI_SIZEX] -- a COORD of {X,newrows}
;  5766             push edx                                            -- dwSize
;  5767             push esi                                            -- hConsoleOutput
;  5768             call "kernel32.dll","SetConsoleScreenBufferSize"
;  5769             -- (ignore error, instead just return how things ended up)
;  5770             push edi                                            -- lpConsoleScreenBufferInfo
;  5771             push esi                                            -- hConsoleOutput
;  5772             call "kernel32.dll","GetConsoleScreenBufferInfo"
;  5773 --          test eax,eax
;  5774 --          jz ??? [DEV]
;  5775             xor eax,eax
;  5776             mov ax,[edi+CSBI_SIZEY]
;  5777             add esp,sizeof_CSBI
;  5778             mov [res],eax
;  5779         [ELF32]
;  5780             pop al
;  5781         [PE64]
;  5782             sub rsp,sizeof_CSBI64
                    sub rsp,24            ;#0043B82E: 48:203354 18               uv 10 10  1  11      
;  5783             mov rdi,rsp
                    mov rdi,rsp           ;#0043B832: 48:213374                  uv 80 10  1  12 10   
;  5784             sub rsp,8*5
                    sub rsp,40            ;#0043B835: 48:203354 28               vu 10 10  1  12      
;  5785             mov rdx,rdi                                     -- lpConsoleScreenBufferInfo
                    mov rdx,rdi           ;#0043B839: 48:213327                  uv 04 80  1  13      
;  5786             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B83C: 48:213015 6D79FCFF         vu 02 00  1  13      
;  5787             call "kernel32.dll","GetConsoleScreenBufferInfo"
                    call [GetConsoleScreenBufferInfo]  ;#0043B843: 377025 3758FCFF            np 00 00  2  14      
;  5788 --          test eax,eax
;  5789 --          jz ??? [DEV]
;  5790             mov edx,[newrows]
                    mov edx,[ebp] (newrows)  ;#0043B849: 213125 00                  uv 04 20  1  16      
;  5791             shl edx,16
                    shl edx,16            ;#0043B84C: 301342 10                  u  04 04  1  17      
;  5792             mov dx,[edi+CSBI_SIZEX]                         -- dwSize (a COORD of {X,newrows})
                    mov dx,word[edi]      ;#0043B84F: 146:213027                 uv 04 80  1  18 04   
;  5793             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B852: 48:213015 5779FCFF         vu 02 00  1  18      
;  5794             call "kernel32.dll","SetConsoleScreenBufferSize"
                    call [SetConsoleScreenBufferSize]  ;#0043B859: 377025 B958FCFF            np 00 00  2  19      
;  5795             -- (ignore error, instead just return how things ended up)
;  5796             mov rdx,rdi                                     -- lpConsoleScreenBufferInfo
                    mov rdx,rdi           ;#0043B85F: 48:213327                  uv 04 80  1  21      
;  5797             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B862: 48:213015 4779FCFF         vu 02 00  1  21      
;  5798             call "kernel32.dll","GetConsoleScreenBufferInfo"
                    call [GetConsoleScreenBufferInfo]  ;#0043B869: 377025 1158FCFF            np 00 00  2  22      
;  5799 --          test eax,eax
;  5800 --          jz ??? [DEV]
;  5801             xor rax,rax
                    xor rax,rax           ;#0043B86F: 48:061300                  uv 01 01  1  24      
;  5802             mov ax,[rdi+CSBI_SIZEY]
                    mov ax,word[edi+2]    ;#0043B872: 146:213107 02              uv 01 80  1  25 01   
;  5803             add rsp,8*5
                    add rsp,40            ;#0043B876: 48:203304 28               vu 10 10  1  25      
;  5804             mov [res],rax
                    mov [rbp-8] (res),rax  ;#0043B87A: 48:211105 F8               uv 00 21  1  26      
;  5805             add rsp,sizeof_CSBI64
                    add rsp,24            ;#0043B87E: 48:203304 18               vu 10 10  1  26      
;  5806         [ELF64]
;  5807             pop al
;  5808           }
;  5809     return res
    mov rax,[rbp-8] (res)                 ;#0043B882: 48:213105 F8               uv 01 20  1  27      
    mov r15,h4                            ;#0043B886: 49:277 0000000000000040    vu 8000 00  1  27      
    cmp rax,r15                           ;#0043B890: 4C:071370                  uv 00 8001  1  28      
    jl #0043B8A8                          ;#0043B893: 174 13                     v  00 00  1  28      
    mov rsi,1111                          ;#0043B895: 48:307306 57040000         uv 40 00  1  29      
    mov rdi,1108                          ;#0043B89C: 48:307307 54040000         vu 80 00  1  29      
    call #00442D75 (:%pUnassigned)        ;#0043B8A3: 350 CD740000               v  00 00  1  30      
    jmp #0044298D (:%opRetf)              ;#0043B8A8: 351 E0700000               v  00 00  1  31      
;  5810 end function
;  5811 
;  5812 
;  5813 constant BACKGROUNDCOLOR=0, TEXTCOLOR=1
;  5814 
;  5815 procedure set_console_color(integer color, integer cmode)
    mov rdi,[rbp] (color)                 ;#0043B72A: 48:213175 00               uv 80 20  1   1      
    mov r15,h4                            ;#0043B72E: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#0043B738: 4C:071377                  uv 00 8080  1   2      
    jl #0043B749                          ;#0043B73B: 174 0C                     v  00 00  1   2      
    mov rcx,1115                          ;#0043B73D: 48:307301 5B040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043B744: 350 0F730000               v  00 00  1   3      
    mov rsi,[rbp-8] (cmode)               ;#0043B749: 48:213165 F8               uv 40 20  1   4      
    mov r15,h4                            ;#0043B74D: 49:277 0000000000000040    vu 8000 00  1   4      
    cmp rsi,r15                           ;#0043B757: 4C:071376                  uv 00 8040  1   5      
    jl #0043B768                          ;#0043B75A: 174 0C                     v  00 00  1   5      
    mov rcx,1116                          ;#0043B75C: 48:307301 5C040000         uv 02 00  1   6      
    call #00442A58 (:%opTchkFail)         ;#0043B763: 350 F0720000               v  00 00  1   6      
;  5816     if not cinit then initConsole() end if
    mov rcx,[#004031C0] (cinit)           ;#0043B768: 48:213015 517AFCFF         uv 02 00  1   7      
    test rcx,rcx                          ;#0043B76F: 48:205311                  uv 00 02  1   8 02   
    jne #0043B790                         ;#0043B772: 165 1C                     v  00 00  1   8      
    xor rcx,rcx                           ;#0043B774: 48:061311                  uv 02 02  1   9      
    mov rdx,1008                          ;#0043B777: 48:307302 F0030000         vu 04 00  1   9      
    call :%opFrame (initConsole)          ;#0043B77E: 350 58710000               v  00 00  1  10      
    mov qword[retaddr],#0043B790          ;#0043B783: 48:307105 20 90B74300      uv 00 20  1  11      
    jmp #0043B59C (code:initConsole)      ;#0043B78B: 351 0CFEFFFF               v  00 00  1  11      
;  5817     #ilASM{
;  5818         [PE32]
;  5819             sub esp,sizeof_CSBI
;  5820             mov esi,[stdout]
;  5821             mov edi,esp
;  5822 --          push eax                                        -- lpConsoleScreenBufferInfo
;  5823             push edi                                        -- lpConsoleScreenBufferInfo
;  5824             push esi                                        -- hConsoleOutput
;  5825             call "kernel32.dll","GetConsoleScreenBufferInfo"
;  5826 --          test eax,eax
;  5827 --          jz ??? [DEV]
;  5828             xor eax,eax
;  5829             mov ecx,[color]
;  5830             mov ax,[edi+CSBI_ATTR]
;  5831             and cl,0x0F
;  5832 --          and ecx,0x0F
;  5833             cmp [cmode],0
;  5834             je :bk_clr
;  5835                 and ax,0xF0
;  5836 --              and eax,0xF0
;  5837 --              mov al,cl
;  5838                 jmp @f
;  5839           ::bk_clr
;  5840                 and ax,0x0F
;  5841 --              and eax,0x0F
;  5842                 shl cl,4
;  5843 --              mov ah,cl
;  5844           @@:
;  5845             or al,cl
;  5846             push eax                                        -- wAttributes
;  5847             push esi                                        -- hConsoleOutput
;  5848             call "kernel32.dll","SetConsoleTextAttribute"
;  5849 --          test eax,eax
;  5850 --          jz ??? [DEV]
;  5851             add esp,sizeof_CSBI
;  5852         [ELF32]
;  5853             pop al
;  5854         [PE64]
;  5855             sub rsp,sizeof_CSBI64
                    sub rsp,24            ;#0043B790: 48:203354 18               uv 10 10  1  12      
;  5856             mov rdi,rsp
                    mov rdi,rsp           ;#0043B794: 48:213374                  uv 80 10  1  13 10   
;  5857             sub rsp,8*5
                    sub rsp,40            ;#0043B797: 48:203354 28               vu 10 10  1  13      
;  5858             mov rdx,rdi                                     -- lpConsoleScreenBufferInfo
                    mov rdx,rdi           ;#0043B79B: 48:213327                  uv 04 80  1  14      
;  5859             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B79E: 48:213015 0B7AFCFF         vu 02 00  1  14      
;  5860             call "kernel32.dll","GetConsoleScreenBufferInfo"
                    call [GetConsoleScreenBufferInfo]  ;#0043B7A5: 377025 D558FCFF            np 00 00  2  15      
;  5861 --          test eax,eax
;  5862 --          jz ??? [DEV]
;  5863             xor rax,rax
                    xor rax,rax           ;#0043B7AB: 48:061300                  uv 01 01  1  17      
;  5864             mov rcx,[color]
                    mov rcx,[rbp] (color)  ;#0043B7AE: 48:213115 00               vu 02 20  1  17      
;  5865             mov ax,[rdi+CSBI_ATTR]
                    mov ax,word[edi+8]    ;#0043B7B2: 146:213107 08              uv 01 80  1  18      
;  5866             cmp [cmode],0
                    cmp qword[rbp-8] (cmode),0  ;#0043B7B6: 48:203175 F8 00            u  00 20  2  19      
;  5867             je :bk_clr
                    je #0043B7C1          ;#0043B7BB: 164 04                     v  00 00  1  20      
;  5868                 mov al,cl
                        mov al,cl         ;#0043B7BD: 212301                     uv 01 02  1  21      
;  5869                 jmp @f
                        jmp #0043B7C3     ;#0043B7BF: 353 02                     v  00 00  1  21      
;  5870           ::bk_clr
;  5871                 mov ah,cl
                        mov ah,cl         ;#0043B7C1: 212341                     uv 01 02  1  22      
;  5872           @@:
;  5873             mov rdx,rax                                     -- wAttributes
                    mov rdx,rax           ;#0043B7C3: 48:213320                  uv 04 01  1  23 01   
;  5874             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B7C6: 48:213015 E379FCFF         vu 02 00  1  23      
;  5875             call "kernel32.dll","SetConsoleTextAttribute"
                    call [SetConsoleTextAttribute]  ;#0043B7CD: 377025 4D59FCFF            np 00 00  2  24      
;  5876 --          test eax,eax
;  5877 --          jz ??? [DEV]
;  5878             add rsp,sizeof_CSBI64
                    add rsp,24            ;#0043B7D3: 48:203304 18               uv 10 10  1  26      
;  5879         [ELF64]
;  5880             pop al
;  5881         []
;  5882           }
    jmp #0044298D (:%opRetf)              ;#0043B7D7: 351 B1710000               v  00 00  1  26      
;  5883 end procedure
;  5884 
;  5885 --  opName("opBkClr",opBkClr,2)
;  5886 --global procedure bk_color(integer color)
;  5887 --  set_console_color(color, BACKGROUNDCOLOR)
;  5888 --end procedure
;  5889 
;  5890 --  opName("opTxtClr",opTxtClr,2)
;  5891 --global procedure text_color(integer color)
;  5892 --  set_console_color(color, TEXTCOLOR)
;  5893 --end procedure
;  5894 
;  5895 --  opName("opClrScrn",opClrScrn,1)
;  5896 --global procedure clear_screen()
;  5897 procedure fclear_screen()
;  5898     if not cinit then initConsole() end if
    mov rax,[#004031C0] (cinit)           ;#0043B676: 48:213005 437BFCFF         uv 01 00  1   1      
    test rax,rax                          ;#0043B67D: 48:205300                  uv 00 01  1   2 01   
    jne #0043B69E                         ;#0043B680: 165 1C                     v  00 00  1   2      
    xor rcx,rcx                           ;#0043B682: 48:061311                  uv 02 02  1   3      
    mov rdx,1008                          ;#0043B685: 48:307302 F0030000         vu 04 00  1   3      
    call :%opFrame (initConsole)          ;#0043B68C: 350 4A720000               v  00 00  1   4      
    mov qword[retaddr],#0043B69E          ;#0043B691: 48:307105 20 9EB64300      uv 00 20  1   5      
    jmp #0043B59C (code:initConsole)      ;#0043B699: 351 FEFEFFFF               v  00 00  1   5      
;  5899     #ilASM{
;  5900         [PE32]
;  5901             sub esp,sizeof_CSBI
;  5902             mov eax,[stdout]
;  5903             mov edi,esp
;  5904             push edi            -- lpConsoleScreenBufferInfo
;  5905             push eax            -- hConsoleOutput
;  5906             call "kernel32.dll","GetConsoleScreenBufferInfo"
;  5907 --          test eax,eax
;  5908 --          jz ??? [DEV]
;  5909             xor eax,eax
;  5910             xor ecx,ecx
;  5911             mov ax,[edi+CSBI_SIZEX]
;  5912             mov cx,[edi+CSBI_SIZEY]
;  5913             xor edx,edx
;  5914             imul ecx
;  5915             mov dx,[edi+CSBI_ATTR]
;  5916             add esp,sizeof_CSBI
;  5917             push ebx    -- space for NumberOf(Attrs|Chars)Written
;  5918             mov esi,esp
;  5919             -- push params for FillConsoleOutputAttribute first (before regs get damaged)
;  5920             push esi                                        -- lpNumberOfAttrsWritten
;  5921             mov edi,[stdout]
;  5922             push ebx                                        -- dwWriteCoord
;  5923             push eax                                        -- nLength
;  5924             push edx                                        -- wAttribute
;  5925             push edi                                        -- hConsoleOutput
;  5926             -- now params for FillConsoleOutputCharacter
;  5927             push esi                                        -- lpNumberOfCharsWritten
;  5928             push ebx                                        -- dwWriteCoord
;  5929             push eax                                        -- nLength
;  5930             push ' '                                        -- cCharacter
;  5931             push edi                                        -- hConsoleOutput
;  5932             call "kernel32.dll","FillConsoleOutputCharacterA"
;  5933             call "kernel32.dll","FillConsoleOutputAttribute"
;  5934 --          pop eax     -- discard NumberOf(Attrs|Chars)Written
;  5935 --          push ebx                                        -- dwCursorPosition
;  5936             mov [esp],ebx                                   -- dwCursorPosition
;  5937             push [stdout]                                   -- hConsoleOutput
;  5938             call "kernel32.dll","SetConsoleCursorPosition"
;  5939         [ELF32]
;  5940             pop al
;  5941         [PE64]
;  5942             sub rsp,sizeof_CSBI64
                    sub rsp,24            ;#0043B69E: 48:203354 18               uv 10 10  1   6      
;  5943             mov rdi,rsp
                    mov rdi,rsp           ;#0043B6A2: 48:213374                  uv 80 10  1   7 10   
;  5944             sub rsp,8*7
                    sub rsp,56            ;#0043B6A5: 48:203354 38               vu 10 10  1   7      
;  5945             mov rdx,rdi                                     -- lpConsoleScreenBufferInfo
                    mov rdx,rdi           ;#0043B6A9: 48:213327                  uv 04 80  1   8      
;  5946             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B6AC: 48:213015 FD7AFCFF         vu 02 00  1   8      
;  5947             call "kernel32.dll","GetConsoleScreenBufferInfo"
                    call [GetConsoleScreenBufferInfo]  ;#0043B6B3: 377025 C759FCFF            np 00 00  2   9      
;  5948 --          test eax,eax
;  5949 --          jz ??? [DEV]
;  5950             xor rax,rax
                    xor rax,rax           ;#0043B6B9: 48:061300                  uv 01 01  1  11      
;  5951             xor rcx,rcx
                    xor rcx,rcx           ;#0043B6BC: 48:061311                  vu 02 02  1  11      
;  5952             mov ax,[rdi+CSBI_SIZEX]
                    mov ax,word[edi]      ;#0043B6BF: 146:213007                 uv 01 80  1  12      
;  5953             mov cx,[rdi+CSBI_SIZEY]
                    mov cx,word[edi+2]    ;#0043B6C2: 146:213117 02              vu 02 80  1  12      
;  5954 --          xor edx,edx
;  5955             imul rcx
                    imul rcx              ;#0043B6C6: 48:367351                  np 05 03 10  13      
;  5956             lea r14,[rsp+40]    -- (as r14 is preserved over api calls)
                    lea r14,[rsp+40]      ;#0043B6C9: 4C:215164044 28            uv 4000 10  1  23      
;  5957             mov r12,rax         -- (as r12 is preserved over api calls)
                    mov r12,rax           ;#0043B6CE: 4C:213340                  vu 1000 01  1  23      
;  5958             xor rdx,rdx
                    xor rdx,rdx           ;#0043B6D1: 48:061322                  uv 04 04  1  24      
;  5959             mov [rsp+32],r14                                -- lpNumberOfCharsWritten
                    mov [rsp+32],r14      ;#0043B6D4: 4C:211164044 20            vu 00 4010  1  24      
;  5960             mov r9,rbx                                      -- dwWriteCoord ({0,0})
                    mov r9,rbx            ;#0043B6D9: 4C:213313                  uv 200 08  1  25      
;  5961             mov r8,r12                                      -- nLength
                    mov r8,r12            ;#0043B6DC: 4D:213304                  vu 100 1000  1  25      
;  5962 --          mov rdx,' '                                     -- cCharacter
;  5963             mov dl,' '                                      -- cCharacter
                    mov dl,32             ;#0043B6DF: 262 20                     uv 04 00  1  26      
;  5964             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B6E1: 48:213015 C87AFCFF         vu 02 00  1  26      
;  5965             call "kernel32.dll","FillConsoleOutputCharacterA"
                    call [FillConsoleOutputCharacterA]  ;#0043B6E8: 377025 7259FCFF            np 00 00  2  27      
;  5966             xor rdx,rdx
                    xor rdx,rdx           ;#0043B6EE: 48:061322                  uv 04 04  1  29      
;  5967             mov [rsp+32],r14                                -- lpNumberOfAttrsWritten
                    mov [rsp+32],r14      ;#0043B6F1: 4C:211164044 20            vu 00 4010  1  29      
;  5968             mov r9,rbx                                      -- dwWriteCoord ({0,0})
                    mov r9,rbx            ;#0043B6F6: 4C:213313                  uv 200 08  1  30      
;  5969             mov r8,r12                                      -- nLength
                    mov r8,r12            ;#0043B6F9: 4D:213304                  vu 100 1000  1  30      
;  5970             mov dx,[rdi+CSBI_ATTR]                          -- wAttribute
                    mov dx,word[edi+8]    ;#0043B6FC: 146:213127 08              uv 04 80  1  31      
;  5971             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B700: 48:213015 A97AFCFF         vu 02 00  1  31      
;  5972             call "kernel32.dll","FillConsoleOutputAttribute"
                    call [FillConsoleOutputAttribute]  ;#0043B707: 377025 4B59FCFF            np 00 00  2  32      
;  5973             mov rdx,rbx                                     -- dwCursorPosition ({0,0})
                    mov rdx,rbx           ;#0043B70D: 48:213323                  uv 04 08  1  34      
;  5974             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B710: 48:213015 997AFCFF         vu 02 00  1  34      
;  5975             call "kernel32.dll","SetConsoleCursorPosition"
                    call [SetConsoleCursorPosition]  ;#0043B717: 377025 EB59FCFF            np 00 00  2  35      
;  5976             add rsp,8*7
                    add rsp,56            ;#0043B71D: 48:203304 38               uv 10 10  1  37      
;  5977             add rsp,sizeof_CSBI64
                    add rsp,24            ;#0043B721: 48:203304 18               uv 10 10  1  38 10   
;  5978         [ELF64]
;  5979             pop al
;  5980           }
;  5981 --  free(pCharsWritten)
    jmp #0044298D (:%opRetf)              ;#0043B725: 351 63720000               v  00 00  1  38      
;  5982 end procedure
;  5983 
;  5984 --  opName("opFreeCons",opFreeCons,1)
;  5985 --global procedure free_console()
;  5986 procedure ffree_console()
;  5987     if cinit then
    mov rcx,[#004031C0] (cinit)           ;#0043B63B: 48:213015 7E7BFCFF         uv 02 00  1   1      
    test rcx,rcx                          ;#0043B642: 48:205311                  uv 00 02  1   2 02   
    je #0043B671                          ;#0043B645: 164 2A                     v  00 00  1   2      
;  5988 -->     {} = c_func(xFreeConsole,{})
;  5989         #ilASM{
;  5990             [PE32]
;  5991                 call "kernel32.dll","FreeConsole"
;  5992             [PE64]
;  5993                 sub rsp,8*5
                        sub rsp,40        ;#0043B647: 48:203354 28               uv 10 10  1   3      
;  5994                 call "kernel32.dll","FreeConsole"
                        call [#00401070] (FreeConsole)  ;#0043B64B: 377025 1F5AFCFF            np 00 00  2   4      
;  5995                 add rsp,8*5
                        add rsp,40        ;#0043B651: 48:203304 28               uv 10 10  1   6      
;  5996             [ELF32]
;  5997                 pop al
;  5998             [ELF64]
;  5999                 pop al
;  6000             []
;  6001               }
;  6002         stdin = 0
    mov [#004031A8] (stdin),rbx           ;#0043B655: 48:211035 4C7BFCFF         vu 00 08  1   6      
;  6003         stdout = 0
    mov [#004031B0] (stdout),rbx          ;#0043B65C: 48:211035 4D7BFCFF         uv 00 08  1   7      
;  6004         stderr = 0
    mov [#004031B8] (stderr),rbx          ;#0043B663: 48:211035 4E7BFCFF         vu 00 08  1   7      
;  6005 --      free(pBHFI)
;  6006 --      free(pSMALLRECT)
;  6007 --      free(pCHARINFO)
;  6008         cinit = 0
    mov [#004031C0] (cinit),rbx           ;#0043B66A: 48:211035 4F7BFCFF         uv 00 08  1   8      
;  6009     end if
    jmp #0044298D (:%opRetf)              ;#0043B671: 351 17730000               v  00 00  1   8      
;  6010 end procedure
;  6011 
;  6012 --  opName("opPosition",opPosition,3)
;  6013 --global procedure position(integer line, integer col)
;  6014 procedure fposition(integer line, integer col)
    mov rax,[rbp] (line)                  ;#0043B4A3: 48:213105 00               uv 01 20  1   1      
    mov r15,h4                            ;#0043B4A7: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rax,r15                           ;#0043B4B1: 4C:071370                  uv 00 8001  1   2      
    jl #0043B4C2                          ;#0043B4B4: 174 0C                     v  00 00  1   2      
    mov rcx,1120                          ;#0043B4B6: 48:307301 60040000         uv 02 00  1   3      
    call #00442A58 (:%opTchkFail)         ;#0043B4BD: 350 96750000               v  00 00  1   3      
    mov rdi,[rbp-8] (col)                 ;#0043B4C2: 48:213175 F8               uv 80 20  1   4      
    mov r15,h4                            ;#0043B4C6: 49:277 0000000000000040    vu 8000 00  1   4      
    cmp rdi,r15                           ;#0043B4D0: 4C:071377                  uv 00 8080  1   5      
    jl #0043B4E1                          ;#0043B4D3: 174 0C                     v  00 00  1   5      
    mov rcx,1121                          ;#0043B4D5: 48:307301 61040000         uv 02 00  1   6      
    call #00442A58 (:%opTchkFail)         ;#0043B4DC: 350 77750000               v  00 00  1   6      
;  6015 integer coord
;  6016     if not cinit then initConsole() end if
    mov rsi,[#004031C0] (cinit)           ;#0043B4E1: 48:213065 D87CFCFF         uv 40 00  1   7      
    test rsi,rsi                          ;#0043B4E8: 48:205366                  uv 00 40  1   8 40   
    jne #0043B509                         ;#0043B4EB: 165 1C                     v  00 00  1   8      
    xor rcx,rcx                           ;#0043B4ED: 48:061311                  uv 02 02  1   9      
    mov rdx,1008                          ;#0043B4F0: 48:307302 F0030000         vu 04 00  1   9      
    call :%opFrame (initConsole)          ;#0043B4F7: 350 DF730000               v  00 00  1  10      
    mov qword[retaddr],#0043B509          ;#0043B4FC: 48:307105 20 09B54300      uv 00 20  1  11      
    jmp #0043B59C (code:initConsole)      ;#0043B504: 351 93000000               v  00 00  1  11      
;  6017 --  #ilASM{ call :%pClearDbg }
;  6018 --  coord = and_bits(line-1,#FFFF)*#10000 + and_bits(col,#FFFF)
;  6019     coord = and_bits(line-1,#FFFF)*#10000 + and_bits(col-1,#FFFF)
    lea rdi,[rbp-24] (symtab[1123])       ;#0043B509: 48:215175 E8               uv 80 20  1  12      
    mov rcx,[rbp] (line)                  ;#0043B50D: 48:213115 00               vu 02 20  1  12      
    mov rax,qword[#00402030]              ;#0043B511: 48:213005 186BFCFF         uv 01 00  1  13      
    call #0043F4D8 (:%opSub)              ;#0043B518: 350 BB3F0000               v  00 00  1  13      
    lea rdi,[rbp-32] (symtab[1125])       ;#0043B51D: 48:215175 E0               uv 80 20  1  14      
    mov rcx,[rbp-24] (symtab[1123])       ;#0043B521: 48:213115 E8               vu 02 20  1  14      
    mov rax,qword[#004031F0]              ;#0043B525: 48:213005 C47CFCFF         uv 01 00  1  15      
    call #0043F6C1 (:%opAndBits)          ;#0043B52C: 350 90410000               v  00 00  1  15      
    lea rdi,[rbp-24] (symtab[1123])       ;#0043B531: 48:215175 E8               uv 80 20  1  16      
    mov rcx,[rbp-32] (symtab[1125])       ;#0043B535: 48:213115 E0               vu 02 20  1  16      
    mov rax,[MB_SETFOREGROUND]            ;#0043B539: 48:213005 486CFCFF         uv 01 00  1  17      
    call #0043F67C (:%opMul)              ;#0043B540: 350 37410000               v  00 00  1  17      
    lea rdi,[rbp-40] (symtab[1126])       ;#0043B545: 48:215175 D8               uv 80 20  1  18      
    mov rcx,[rbp-8] (col)                 ;#0043B549: 48:213115 F8               vu 02 20  1  18      
    mov rax,qword[#00402030]              ;#0043B54D: 48:213005 DC6AFCFF         uv 01 00  1  19      
    call #0043F4D8 (:%opSub)              ;#0043B554: 350 7F3F0000               v  00 00  1  19      
    lea rdi,[rbp-32] (symtab[1125])       ;#0043B559: 48:215175 E0               uv 80 20  1  20      
    mov rcx,[rbp-40] (symtab[1126])       ;#0043B55D: 48:213115 D8               vu 02 20  1  20      
    mov rax,qword[#004031F0]              ;#0043B561: 48:213005 887CFCFF         uv 01 00  1  21      
    call #0043F6C1 (:%opAndBits)          ;#0043B568: 350 54410000               v  00 00  1  21      
    lea rdi,[rbp-16] (coord)              ;#0043B56D: 48:215175 F0               uv 80 20  1  22      
    mov rcx,[rbp-24] (symtab[1123])       ;#0043B571: 48:213115 E8               vu 02 20  1  22      
    mov rax,[rbp-32] (symtab[1125])       ;#0043B575: 48:213105 E0               uv 01 20  1  23      
    call #0043F4BE (:%opAddi)             ;#0043B579: 350 403F0000               v  00 00  1  23      
;  6020     #ilASM{
;  6021         [PE32]
;  6022             push dword[coord]                           -- dwCursorPosition
;  6023             push [stdout]                               -- hConsoleOutput
;  6024             call "kernel32.dll","SetConsoleCursorPosition"
;  6025         [ELF32]
;  6026             pop al
;  6027         [PE64]
;  6028             sub rsp,8*5
                    sub rsp,40            ;#0043B57E: 48:203354 28               uv 10 10  1  24      
;  6029             mov rdx,[coord]                                 -- dwCursorPosition
                    mov rdx,[rbp-16] (coord)  ;#0043B582: 48:213125 F0               vu 04 20  1  24      
;  6030             mov rcx,[stdout]                                -- hConsoleOutput
                    mov rcx,[#004031B0] (stdout)  ;#0043B586: 48:213015 237CFCFF         uv 02 00  1  25      
;  6031             call "kernel32.dll","SetConsoleCursorPosition"
                    call [SetConsoleCursorPosition]  ;#0043B58D: 377025 755BFCFF            np 00 00  2  26      
;  6032             add rsp,8*5
                    add rsp,40            ;#0043B593: 48:203304 28               uv 10 10  1  28      
;  6033         [ELF64]
;  6034             pop al
;  6035           }
    jmp #0044298D (:%opRetf)              ;#0043B597: 351 F1730000               v  00 00  1  28      
;  6036 end procedure
;  6037 
;  6038 #ilASM{ jmp :fin
                jmp #0043ED26             ;#0043E840: 351 E1040000               v  00 00  1   1      
;  6039 --/*
;  6040 procedure :%opOpen(:%)
;  6041 end procedure -- (for Edita/CtrlQ)
;  6042 --*/
;  6043     :%opOpen
;  6044 ------------
;  6045         --
;  6046         --  This is the "glue" needed to allow open() to be put in the optable.
;  6047         --  Sure, I could rewrite it as pure #ilASM, but it was much easier to
;  6048         --  write (and test) as a (global) hll routine; plus writing something 
;  6049         --  like x=s[i] in assembler gets real tedious real fast, trust me.
;  6050         --
;  6051         [32]
;  6052             -- calling convention
;  6053             --  lea edi,[res]       -- result location
;  6054             --  mov eax,[filepath]  -- (opUnassigned)
;  6055             --  mov ecx,[openmode]  -- (opUnassigned)
;  6056             --  call :%opOpen       -- [edi]:=open(eax,ecx)
;  6057             cmp eax,h4
;  6058             jl @f
;  6059                 add dword[ebx+eax*4-8],1
;  6060           @@:
;  6061             cmp ecx,h4
;  6062             jl @f
;  6063                 add dword[ebx+ecx*4-8],1
;  6064           @@:
;  6065             push edi                            --[1] addr res
;  6066             push ecx                            --[2] openmode
;  6067             push eax                            --[3] filepath
;  6068             mov edx,routine_id(fopen)           -- mov edx,imm32 (sets K_ridt)
;  6069             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6070             call :%opFrame
;  6071             mov edx,[esp+12]
;  6072             pop dword[ebp]                      --[3] filepath
;  6073             pop dword[ebp-4]                    --[2] openmode
;  6074             mov dword[ebp+16],:openret          -- return address
;  6075             mov dword[ebp+12],edx               -- called from address
;  6076             jmp $_il                            -- jmp code:fopen
;  6077           ::openret     
;  6078             pop edi                             --[1] addr res
;  6079             mov edx,[edi]
;  6080             mov [edi],eax
;  6081             cmp edx,h4
;  6082             jle @f
;  6083                 sub dword[ebx+edx*4-8],1
;  6084                 jz :%pDealloc
;  6085         [64]
;  6086             -- calling convention
;  6087             --  lea rdi,[res]       -- result location
;  6088             --  mov rax,[filepath]  -- (opUnassigned)
;  6089             --  mov rcx,[openmode]  -- (opUnassigned)
;  6090             --  call :%opOpen       -- [rdi]:=open(rax,rcx)
;  6091             mov r15,h4
                    mov r15,h4            ;#0043E845: 49:277 0000000000000040    uv 8000 00  1   2      
;  6092             cmp rax,r15
                    cmp rax,r15           ;#0043E84F: 49:073307                  uv 00 8001  1   3 8000   
;  6093             jl @f
                    jl #0043E85A          ;#0043E852: 174 06                     v  00 00  1   3      
;  6094                 add qword[rbx+rax*4-16],1
                        add qword[rbx+rax*4-16],1  ;#0043E854: 48:203104203 F0 01         u  00 09  3   4      
;  6095           @@:
;  6096             cmp rcx,r15
                    cmp rcx,r15           ;#0043E85A: 49:073317                  vu 00 8002  1   6      
;  6097             jl @f
                    jl #0043E865          ;#0043E85D: 174 06                     v  00 00  1   7      
;  6098                 add qword[rbx+rcx*4-16],1
                        add qword[rbx+rcx*4-16],1  ;#0043E85F: 48:203104213 F0 01         u  00 0A  3   8      
;  6099           @@:
;  6100             push rdi                            --[1] addr res
                    push rdi              ;#0043E865: 48:127                     vu 00 80  1  10      
;  6101             push rcx                            --[2] openmode
                    push rcx              ;#0043E867: 48:121                     uv 00 02  1  11      
;  6102             push rax                            --[3] filepath
                    push rax              ;#0043E869: 48:120                     vu 00 01  1  11      
;  6103             mov rdx,routine_id(fopen)           -- mov rdx,imm32 (sets K_ridt)
                    mov edx,982           ;#0043E86B: 272 D6030000               uv 04 00  1  12      
;  6104             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,15            ;#0043E870: 48:307301 0F000000         vu 02 00  1  12      
;  6105             call :%opFrame
                    call #004428DB (:%opFrame) (fopen)  ;#0043E877: 350 5F400000               v  00 00  1  13      
;  6106             mov rdx,[rsp+24]
                    mov rdx,[rsp+24]      ;#0043E87C: 48:213124044 18            uv 04 10  1  14      
;  6107             pop qword[rbp]                      --[3] filepath
                    pop qword[rbp] (filepath)  ;#0043E881: 147:217105 00              np 00 20  3  15      
;  6108             pop qword[rbp-8]                    --[2] openmode
                    pop qword[rbp-8] (openmode)  ;#0043E885: 147:217105 F8              np 00 20  3  18      
;  6109             mov qword[rbp+32],:openret          -- return address
                    mov qword[retaddr],#0043E89A  ;#0043E889: 48:307105 20 9AE84300      uv 00 20  1  21      
;  6110             mov qword[rbp+24],rdx               -- called from address
                    mov [rbp+24],rdx      ;#0043E891: 48:211125 18               vu 00 24  1  21      
;  6111             jmp $_il                            -- jmp code:fopen
                    jmp #0043D2D5 (code:fopen)  ;#0043E895: 351 3BEAFFFF               v  00 00  1  22      
;  6112           ::openret     
;  6113             pop rdi                             --[1] addr res
                    pop rdi               ;#0043E89A: 48:137                     uv 80 00  1  23      
;  6114             mov rdx,[rdi]
                    mov rdx,[rdi]         ;#0043E89C: 48:213027                  uv 04 80  1  26 80 *80*
;  6115             mov [rdi],rax
                    mov [rdi],rax         ;#0043E89F: 48:211007                  vu 00 81  1  26      
;  6116             cmp rdx,r15
                    cmp rdx,r15           ;#0043E8A2: 49:073327                  uv 00 8004  1  27      
;  6117             jle @f
                    jle #0043E8B3         ;#0043E8A5: 176 0C                     v  00 00  1  27      
;  6118                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043E8A7: 48:203154223 F0 01         u  00 0C  3  28      
;  6119                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043E8AD: 017204 273A0000            v  00 00  1  30      
;  6120         []
;  6121           @@:
;  6122             ret
                    ret                   ;#0043E8B3: 303                        np 00 00  2  31      
;  6123 
;  6124 --/*
;  6125 procedure :%opFlush(:%)
;  6126 end procedure -- (for Edita/CtrlQ)
;  6127 --*/
;  6128     :%opFlush
;  6129 -------------
;  6130         --  The "glue" needed to allow flush() to be put in the optable.
;  6131         [32]
;  6132             -- calling convention
;  6133             --  mov eax,[fn]        -- (opUnassigned, should be integer)
;  6134             --  call :%opFlush      -- flush(eax)
;  6135             cmp eax,h4
;  6136             jl @f
;  6137                 int3    --DEV (better error msg)
;  6138           @@:
;  6139             push eax                            --[1] fn
;  6140             mov edx,routine_id(fflush)          -- mov edx,imm32 (sets K_ridt)
;  6141             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6142             call :%opFrame
;  6143             mov edx,[esp+4]
;  6144             pop dword[ebp]                      --[1] fn
;  6145             mov dword[ebp+16],:flushret         -- return address
;  6146             mov dword[ebp+12],edx               -- called from address
;  6147             jmp $_il                            -- jmp code:fflush
;  6148         [64]
;  6149             -- calling convention
;  6150             --  mov rax,[fn]        -- (opUnassigned)
;  6151             --  call :%opFlush      -- flush(rax)
;  6152             mov r15,h4
                    mov r15,h4            ;#0043E8B4: 49:277 0000000000000040    uv 8000 00  1  33      
;  6153             cmp rax,r15
                    cmp rax,r15           ;#0043E8BE: 49:073307                  uv 00 8001  1  34 8000   
;  6154             jl @f
                    jl #0043E8C4          ;#0043E8C1: 174 01                     v  00 00  1  34      
;  6155                 int3
                        int3              ;#0043E8C3: 314                        np 00 00 13  35      
;  6156           @@:
;  6157             push rax                            --[1] fn
                    push rax              ;#0043E8C4: 48:120                     uv 00 01  1  48      
;  6158             mov rdx,routine_id(fflush)          -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1017          ;#0043E8C6: 272 F9030000               vu 04 00  1  48      
;  6159             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,5             ;#0043E8CB: 48:307301 05000000         uv 02 00  1  49      
;  6160             call :%opFrame
                    call #004428DB (:%opFrame) (fflush)  ;#0043E8D2: 350 04400000               v  00 00  1  49      
;  6161             mov rdx,[rsp+8]
                    mov rdx,[rsp+8]       ;#0043E8D7: 48:213124044 08            uv 04 10  1  50      
;  6162             pop qword[rbp]                      --[1] fn
                    pop qword[rbp] (fn)   ;#0043E8DC: 147:217105 00              np 00 20  3  51      
;  6163             mov qword[rbp+32],:flushret         -- return address
                    mov qword[retaddr],#0043E8F1  ;#0043E8E0: 48:307105 20 F1E84300      uv 00 20  1  54      
;  6164             mov qword[rbp+24],rdx               -- called from address
                    mov [rbp+24],rdx      ;#0043E8E8: 48:211125 18               vu 00 24  1  54      
;  6165             jmp $_il                            -- jmp code:fflush
                    jmp #0043D19B (code:fflush)  ;#0043E8EC: 351 AAE8FFFF               v  00 00  1  55      
;  6166         []
;  6167           ::flushret    
;  6168             ret
                    ret                   ;#0043E8F1: 303                        np 00 00  2  56      
;  6169 
;  6170 --/*
;  6171 procedure :%opClose(:%)
;  6172 end procedure -- (for Edita/CtrlQ)
;  6173 --*/
;  6174     :%opClose
;  6175 -------------
;  6176         --  The "glue" needed to allow close() to be put in the optable.
;  6177         [32]
;  6178             -- calling convention
;  6179             --  mov eax,[fn]        -- (opUnassigned, integer)
;  6180             --  call :%opClose      -- close(eax)
;  6181             cmp eax,h4
;  6182             jl @f
;  6183                 int3    --DEV
;  6184           @@:
;  6185             push eax                            --[1] fn
;  6186             mov edx,routine_id(fclose)          -- mov edx,imm32 (sets K_ridt)
;  6187             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6188             call :%opFrame
;  6189             pop dword[ebp]                      --[1] fn
;  6190             mov dword[ebp+16],:closeret
;  6191             jmp $_il                            -- jmp code:fclose
;  6192         [64]
;  6193             -- calling convention
;  6194             --  mov rax,[fn]        -- (opUnassigned, integer)
;  6195             --  call :%opClose      -- close(rax)
;  6196             mov r15,h4
                    mov r15,h4            ;#0043E8F2: 49:277 0000000000000040    uv 8000 00  1  58      
;  6197             cmp rax,r15
                    cmp rax,r15           ;#0043E8FC: 49:073307                  uv 00 8001  1  59 8000   
;  6198             jl @f
                    jl #0043E902          ;#0043E8FF: 174 01                     v  00 00  1  59      
;  6199                 int3
                        int3              ;#0043E901: 314                        np 00 00 13  60      
;  6200           @@:
;  6201             push rax                            --[1] fn
                    push rax              ;#0043E902: 48:120                     uv 00 01  1  73      
;  6202             mov rdx,routine_id(fclose)      -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1023          ;#0043E904: 272 FF030000               vu 04 00  1  73      
;  6203             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,6             ;#0043E909: 48:307301 06000000         uv 02 00  1  74      
;  6204             call :%opFrame
                    call #004428DB (:%opFrame) (fclose)  ;#0043E910: 350 C63F0000               v  00 00  1  74      
;  6205             pop qword[rbp]                      --[1] fn
                    pop qword[rbp] (fn)   ;#0043E915: 147:217105 00              np 00 20  3  75      
;  6206             mov qword[rbp+32],:closeret
                    mov qword[retaddr],#0043E926  ;#0043E919: 48:307105 20 26E94300      uv 00 20  1  78      
;  6207             jmp $_il                            -- jmp code:fclose
                    jmp #0043CF81 (code:fclose)  ;#0043E921: 351 5BE6FFFF               v  00 00  1  78      
;  6208         []
;  6209           ::closeret    
;  6210             ret
                    ret                   ;#0043E926: 303                        np 00 00  2  79      
;  6211 
;  6212 --/*
;  6213 procedure :%opSeek(:%)
;  6214 end procedure -- (for Edita/CtrlQ)
;  6215 --*/
;  6216     :%opSeek
;  6217 ------------
;  6218         --  The "glue" needed to allow seek() to be put in the optable.
;  6219         [32]
;  6220             -- calling convention
;  6221             --  lea edi,[res]       -- result location
;  6222             --  mov eax,[fn]        -- file number (opUnassigned, integer)
;  6223             --  mov ecx,[pos]       -- position (opUnassigned)
;  6224             --  call :%opSeek       -- [edi]:=seek(eax,ecx)
;  6225 
;  6226 --          (don't bother, will crash soon enough if needed)
;  6227             cmp eax,h4
;  6228             jl @f
;  6229 --              add dword[ebx+eax*4-8],1
;  6230                 int3    --DEV
;  6231           @@:
;  6232             cmp ecx,h4
;  6233             jl @f
;  6234                 add dword[ebx+ecx*4-8],1
;  6235           @@:
;  6236             push dword[edi]                     --[1] prev res (popped into edx)
;  6237             push edi                            --[2] addr res
;  6238             push ecx                            --[3] position
;  6239             push eax                            --[4] file number
;  6240             mov edx,routine_id(fseek)           -- mov edx,imm32 (sets K_ridt)
;  6241             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6242             call :%opFrame
;  6243 --          mov edx,[esp+24]
;  6244             mov edx,[esp+16]                    -- return address (of the call :%opSeek)
;  6245             pop dword[ebp]                      --[4] file number
;  6246             pop dword[ebp-4]                    --[3] position
;  6247             mov dword[ebp+16],:seekret          -- return address
;  6248             mov dword[ebp+12],edx               -- called from address (for errors)
;  6249             jmp $_il                            -- jmp code:fseek
;  6250           ::seekret     
;  6251             pop edi                             --[2] addr res
;  6252             pop edx                             --[1] prev (equiv to mov edx,[edi])
;  6253             mov [edi],eax
;  6254             cmp edx,h4
;  6255             jle @f
;  6256                 sub dword[ebx+edx*4-8],1
;  6257                 jz :%pDealloc
;  6258         [64]
;  6259             -- calling convention
;  6260             --  lea rdi,[res]       -- result location
;  6261             --  mov rax,[fn]        -- file number (opUnassigned, integer)
;  6262             --  mov rcx,[pos]       -- position (opUnassigned)
;  6263             --  call :%opSeek       -- [rdi]:=seek(rax,rcx)
;  6264 
;  6265             mov r15,h4
                    mov r15,h4            ;#0043E927: 49:277 0000000000000040    uv 8000 00  1  81      
;  6266 --          (don't bother, will crash soon enough if needed)
;  6267             cmp rax,r15
                    cmp rax,r15           ;#0043E931: 49:073307                  uv 00 8001  1  82 8000   
;  6268             jl @f
                    jl #0043E937          ;#0043E934: 174 01                     v  00 00  1  82      
;  6269 --              add qword[rbx+rax*4-16],1
;  6270                 int3
                        int3              ;#0043E936: 314                        np 00 00 13  83      
;  6271           @@:
;  6272             cmp rcx,r15
                    cmp rcx,r15           ;#0043E937: 49:073317                  uv 00 8002  1  96      
;  6273             jl @f
                    jl #0043E942          ;#0043E93A: 174 06                     v  00 00  1  96      
;  6274                 add qword[rbx+rcx*4-16],1
                        add qword[rbx+rcx*4-16],1  ;#0043E93C: 48:203104213 F0 01         u  00 0A  3  97      
;  6275           @@:
;  6276             push qword[rdi]                     --[1] prev res (popped into rdx)
                    push qword[rdi]       ;#0043E942: 48:377067                  np 00 80  2 100      
;  6277             push rdi                            --[2] addr res
                    push rdi              ;#0043E945: 48:127                     uv 00 80  1 102      
;  6278             push rcx                            --[3] position
                    push rcx              ;#0043E947: 48:121                     vu 00 02  1 102      
;  6279             push rax                            --[4] file number
                    push rax              ;#0043E949: 48:120                     uv 00 01  1 103      
;  6280             mov rdx,routine_id(fseek)           -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1031          ;#0043E94B: 272 07040000               vu 04 00  1 103      
;  6281             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,10            ;#0043E950: 48:307301 0A000000         uv 02 00  1 104      
;  6282             call :%opFrame
                    call #004428DB (:%opFrame) (fseek)  ;#0043E957: 350 7F3F0000               v  00 00  1 104      
;  6283             mov rdx,[rsp+32]                    -- return address (of the call :%opSeek)
                    mov rdx,[rsp+32]      ;#0043E95C: 48:213124044 20            uv 04 10  1 105      
;  6284             pop qword[rbp]                      --[4] file number
                    pop qword[rbp] (fn)   ;#0043E961: 147:217105 00              np 00 20  3 106      
;  6285             pop qword[rbp-8]                    --[3] position
                    pop qword[rbp-8] (pos)  ;#0043E965: 147:217105 F8              np 00 20  3 109      
;  6286             mov qword[ebp+32],:seekret          -- return address
                    mov qword[retaddr],#0043E97A  ;#0043E969: 48:307105 20 7AE94300      uv 00 20  1 112      
;  6287             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043E971: 48:211125 18               vu 00 24  1 112      
;  6288             jmp $_il                            -- jmp code:fseek
                    jmp #0043C978 (code:fseek)  ;#0043E975: 351 FEDFFFFF               v  00 00  1 113      
;  6289           ::seekret     
;  6290             pop rdi                             --[2] addr res
                    pop rdi               ;#0043E97A: 48:137                     uv 80 00  1 114      
;  6291             pop rdx                             --[1] prev (equiv to mov edx,[edi])
                    pop rdx               ;#0043E97C: 48:132                     vu 04 00  1 114      
;  6292             mov [rdi],rax
                    mov [rdi],rax         ;#0043E97E: 48:211007                  uv 00 81  1 117    *80*
;  6293             cmp rdx,r15
                    cmp rdx,r15           ;#0043E981: 49:073327                  vu 00 8004  1 117      
;  6294             jle @f
                    jle #0043E992         ;#0043E984: 176 0C                     v  00 00  1 118      
;  6295                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043E986: 48:203154223 F0 01         u  00 0C  3 119      
;  6296                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043E98C: 017204 48390000            v  00 00  1 121      
;  6297         []
;  6298           @@:
;  6299             ret
                    ret                   ;#0043E992: 303                        np 00 00  2 122      
;  6300 
;  6301 --/*
;  6302 procedure :%opWhere(:%)
;  6303 end procedure -- (for Edita/CtrlQ)
;  6304 --*/
;  6305     :%opWhere
;  6306 ------------
;  6307         --  The "glue" needed to allow where() to be put in the optable.
;  6308         [32]
;  6309             -- calling convention
;  6310             --  lea edi,[res]       -- result location
;  6311             --  mov eax,[fn]        -- file number (opUnassigned, integer)
;  6312             --  call :%opWhere      -- [edi]:=where(eax)
;  6313 
;  6314 --          (don't bother, will crash soon enough if needed)
;  6315             cmp eax,h4
;  6316             jl @f
;  6317 --              add dword[ebx+eax*4-8],1
;  6318                 int3
;  6319           @@:
;  6320             push dword[edi]                     --[1] prev res (popped into edx)
;  6321             push edi                            --[2] addr res
;  6322             push eax                            --[3] file number
;  6323             mov edx,routine_id(fwhere)          -- mov edx,imm32 (sets K_ridt)
;  6324             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6325             call :%opFrame
;  6326             mov edx,[esp+12]                    -- return address (of the call :%opWhere)
;  6327             pop dword[ebp]                      --[3] file number
;  6328             mov dword[ebp+16],:whereret         -- return address
;  6329             mov dword[ebp+12],edx               -- called from address (for errors)
;  6330             jmp $_il                            -- jmp code:fwhere
;  6331           ::whereret    
;  6332             pop edi                             --[2] addr res
;  6333             pop edx                             --[1] prev (equiv to mov edx,[edi])
;  6334             mov [edi],eax
;  6335             cmp edx,h4
;  6336             jle @f
;  6337                 sub dword[ebx+edx*4-8],1
;  6338                 jz :%pDealloc
;  6339         [64]
;  6340             -- calling convention
;  6341             --  lea rdi,[res]       -- result location
;  6342             --  mov rax,[fn]        -- file number (opUnassigned, integer)
;  6343             --  call :%opWhere      -- [rdi]:=where(rax)
;  6344 
;  6345             mov r15,h4
                    mov r15,h4            ;#0043E993: 49:277 0000000000000040    uv 8000 00  1 124      
;  6346 --          (don't bother, will crash soon enough if needed)
;  6347             cmp rax,r15
                    cmp rax,r15           ;#0043E99D: 49:073307                  uv 00 8001  1 125 8000   
;  6348             jl @f
                    jl #0043E9A3          ;#0043E9A0: 174 01                     v  00 00  1 125      
;  6349 --              add qword[rbx+rax*4-16],1
;  6350                 int3
                        int3              ;#0043E9A2: 314                        np 00 00 13 126      
;  6351           @@:
;  6352             push qword[rdi]                     --[1] prev res (popped into rdx)
                    push qword[rdi]       ;#0043E9A3: 48:377067                  np 00 80  2 139      
;  6353             push rdi                            --[2] addr res
                    push rdi              ;#0043E9A6: 48:127                     uv 00 80  1 141      
;  6354             push rax                            --[3] file number
                    push rax              ;#0043E9A8: 48:120                     vu 00 01  1 141      
;  6355             mov rdx,routine_id(fwhere)          -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1043          ;#0043E9AA: 272 13040000               uv 04 00  1 142      
;  6356             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,3             ;#0043E9AF: 48:307301 03000000         vu 02 00  1 142      
;  6357             call :%opFrame
                    call #004428DB (:%opFrame) (fwhere)  ;#0043E9B6: 350 203F0000               v  00 00  1 143      
;  6358             mov rdx,[rsp+24]                    -- return address (of the call :%opSeek)
                    mov rdx,[rsp+24]      ;#0043E9BB: 48:213124044 18            uv 04 10  1 144      
;  6359             pop qword[rbp]                      --[3] file number
                    pop qword[rbp] (fn)   ;#0043E9C0: 147:217105 00              np 00 20  3 145      
;  6360             mov qword[ebp+32],:whereret         -- return address
                    mov qword[retaddr],#0043E9D5  ;#0043E9C4: 48:307105 20 D5E94300      uv 00 20  1 148      
;  6361             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043E9CC: 48:211125 18               vu 00 24  1 148      
;  6362             jmp $_il                            -- jmp code:fwhere
                    jmp #0043C84C (code:fwhere)  ;#0043E9D0: 351 77DEFFFF               v  00 00  1 149      
;  6363           ::whereret    
;  6364             pop rdi                             --[2] addr res
                    pop rdi               ;#0043E9D5: 48:137                     uv 80 00  1 150      
;  6365             pop rdx                             --[1] prev (equiv to mov edx,[edi])
                    pop rdx               ;#0043E9D7: 48:132                     vu 04 00  1 150      
;  6366             mov [rdi],rax
                    mov [rdi],rax         ;#0043E9D9: 48:211007                  uv 00 81  1 153    *80*
;  6367             cmp rdx,r15
                    cmp rdx,r15           ;#0043E9DC: 49:073327                  vu 00 8004  1 153      
;  6368             jle @f
                    jle #0043E9ED         ;#0043E9DF: 176 0C                     v  00 00  1 154      
;  6369                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043E9E1: 48:203154223 F0 01         u  00 0C  3 155      
;  6370                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043E9E7: 017204 ED380000            v  00 00  1 157      
;  6371         []
;  6372           @@:
;  6373             ret
                    ret                   ;#0043E9ED: 303                        np 00 00  2 158      
;  6374 
;  6375 --DEV replaced with :%opLock
;  6376 --global function lock_file(integer fn, lock_type locktype, byte_range byterange)
;  6377 --  return flock(fn,locktype,byterange)
;  6378 --end function
;  6379 
;  6380 --/*
;  6381 procedure :%opLock(:%)
;  6382 end procedure -- (for Edita/CtrlQ)
;  6383 --*/
;  6384     :%opLock
;  6385 ------------
;  6386         --  The "glue" needed to allow lock_file() to be put in the optable.
;  6387         [32]
;  6388             -- calling convention
;  6389             --  lea edi,[res]       -- result location
;  6390             --  mov eax,[fn]        -- file number (opUnassigned, integer)
;  6391             --  mov ecx,[locktype]  -- lock type (opUnassigned, integer)
;  6392             --  mov esi,[byterange] -- byte range (opUnassigned, sequence)
;  6393             --  call :%opLock       -- [edi]:=lock_file(eax,ecx,esi)
;  6394             cmp eax,h4
;  6395             jl @f
;  6396 --              add dword[ebx+eax*4-8],1
;  6397                 int3
;  6398           @@:
;  6399             cmp ecx,h4
;  6400             jl @f
;  6401 --              add dword[ebx+ecx*4-8],1
;  6402                 int3
;  6403           @@:
;  6404             cmp esi,h4
;  6405             jl @f
;  6406                 add dword[ebx+esi*4-8],1
;  6407           @@:
;  6408             push dword[edi]                     --[1] prev res (popped into edx)
;  6409             push edi                            --[2] addr res
;  6410             push eax                            --[3] file number
;  6411             push ecx                            --[4] lock type
;  6412             push esi                            --[5] byte range
;  6413             mov edx,routine_id(flock_file)      -- mov edx,imm32 (sets K_ridt)
;  6414             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6415             call :%opFrame
;  6416             mov edx,[esp+20]                    -- return address (of the call :%opLock)
;  6417             pop dword[ebp-8]                    --[5] byte range
;  6418             pop dword[ebp-4]                    --[4] lock type
;  6419             pop dword[ebp]                      --[3] file number
;  6420             mov dword[ebp+16],:lockret          -- return address
;  6421             mov dword[ebp+12],edx               -- called from address (for errors)
;  6422             jmp $_il                            -- jmp code:flock_file
;  6423           ::lockret
;  6424             pop edi                             --[2] addr res
;  6425             pop edx                             --[1] prev (equiv to mov edx,[edi])
;  6426             mov [edi],eax
;  6427             cmp edx,h4
;  6428             jle @f
;  6429                 sub dword[ebx+edx*4-8],1
;  6430                 jz :%pDealloc
;  6431         [64]
;  6432             -- calling convention
;  6433             --  lea rdi,[res]       -- result location
;  6434             --  mov rax,[fn]        -- file number (opUnassigned, integer)
;  6435             --  mov rcx,[locktype]  -- lock type (opUnassigned, integer)
;  6436             --  mov rsi,[byterange] -- byte range (opUnassigned, sequence)
;  6437             --  call :%opLock       -- [rdi]:=lock_file(rax,rcx,rsi)
;  6438             mov r15,h4
                    mov r15,h4            ;#0043E9EE: 49:277 0000000000000040    uv 8000 00  1 160      
;  6439             cmp rax,r15
                    cmp rax,r15           ;#0043E9F8: 49:073307                  uv 00 8001  1 161 8000   
;  6440             jl @f
                    jl #0043E9FE          ;#0043E9FB: 174 01                     v  00 00  1 161      
;  6441 --              add qword[rbx+rax*4-16],1
;  6442                 int3
                        int3              ;#0043E9FD: 314                        np 00 00 13 162      
;  6443           @@:
;  6444             cmp rcx,r15
                    cmp rcx,r15           ;#0043E9FE: 49:073317                  uv 00 8002  1 175      
;  6445             jl @f
                    jl #0043EA04          ;#0043EA01: 174 01                     v  00 00  1 175      
;  6446 --              add qword[ebx+rcx*4-16],1
;  6447                 int3
                        int3              ;#0043EA03: 314                        np 00 00 13 176      
;  6448           @@:
;  6449             cmp rsi,r15
                    cmp rsi,r15           ;#0043EA04: 49:073367                  uv 00 8040  1 189      
;  6450             jl @f
                    jl #0043EA0F          ;#0043EA07: 174 06                     v  00 00  1 189      
;  6451                 add qword[rbx+rsi*4-16],1
                        add qword[rbx+rsi*4-16],1  ;#0043EA09: 48:203104263 F0 01         u  00 48  3 190      
;  6452           @@:
;  6453             push qword[rdi]                     --[1] prev res (popped into rdx)
                    push qword[rdi]       ;#0043EA0F: 48:377067                  np 00 80  2 193      
;  6454             push rdi                            --[2] addr res
                    push rdi              ;#0043EA12: 48:127                     uv 00 80  1 195      
;  6455             push rax                            --[3] file number
                    push rax              ;#0043EA14: 48:120                     vu 00 01  1 195      
;  6456             push rcx                            --[4] lock type
                    push rcx              ;#0043EA16: 48:121                     uv 00 02  1 196      
;  6457             push rsi                            --[5] byte range
                    push rsi              ;#0043EA18: 48:126                     vu 00 40  1 196      
;  6458             mov rdx,routine_id(flock_file)      -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1070          ;#0043EA1A: 272 2E040000               uv 04 00  1 197      
;  6459             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,3             ;#0043EA1F: 48:307301 03000000         vu 02 00  1 197      
;  6460             call :%opFrame
                    call :%opFrame (flock_file)  ;#0043EA26: 350 B03E0000               v  00 00  1 198      
;  6461             mov rdx,[rsp+40]                    -- return address (of the call :%opLock)
                    mov rdx,[rsp+40]      ;#0043EA2B: 48:213124044 28            uv 04 10  1 199      
;  6462             pop qword[rbp-16]                   --[5] byte range
                    pop qword[rbp-16] (byterange)  ;#0043EA30: 147:217105 F0              np 00 20  3 200      
;  6463             pop qword[rbp-8]                    --[4] lock type
                    pop qword[rbp-8] (locktype)  ;#0043EA34: 147:217105 F8              np 00 20  3 203      
;  6464             pop qword[rbp]                      --[3] file number
                    pop qword[rbp] (fn)   ;#0043EA38: 147:217105 00              np 00 20  3 206      
;  6465             mov qword[rbp+32],:lockret          -- return address
                    mov qword[retaddr],#0043EA4D  ;#0043EA3C: 48:307105 20 4DEA4300      uv 00 20  1 209      
;  6466             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EA44: 48:211125 18               vu 00 24  1 209      
;  6467             jmp $_il                            -- jmp code:flock_file
                    jmp #0043C35D (code:flock_file)  ;#0043EA48: 351 10D9FFFF               v  00 00  1 210      
;  6468           ::lockret
;  6469             pop rdi                             --[2] addr res
                    pop rdi               ;#0043EA4D: 48:137                     uv 80 00  1 211      
;  6470             pop rdx                             --[1] prev (equiv to mov edx,[edi])
                    pop rdx               ;#0043EA4F: 48:132                     vu 04 00  1 211      
;  6471             mov [rdi],rax
                    mov [rdi],rax         ;#0043EA51: 48:211007                  uv 00 81  1 214    *80*
;  6472             cmp rdx,r15
                    cmp rdx,r15           ;#0043EA54: 49:073327                  vu 00 8004  1 214      
;  6473             jle @f
                    jle #0043EA65         ;#0043EA57: 176 0C                     v  00 00  1 215      
;  6474                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043EA59: 48:203154223 F0 01         u  00 0C  3 216      
;  6475                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043EA5F: 017204 75380000            v  00 00  1 218      
;  6476         []
;  6477           @@:
;  6478             ret
                    ret                   ;#0043EA65: 303                        np 00 00  2 219      
;  6479 
;  6480 --/*
;  6481 procedure :%opUnLock(:%)
;  6482 end procedure -- (for Edita/CtrlQ)
;  6483 --*/
;  6484     :%opUnLock
;  6485 --------------
;  6486         --  The "glue" needed to allow unlock_file() to be put in the optable.
;  6487         [32]
;  6488             -- calling convention
;  6489             --  mov eax,[fn]        -- file number (opUnassigned, integer)
;  6490             --  mov esi,[byterange] -- byte range (opUnassigned, sequence)
;  6491             --  call :%opUnLock     -- unlock_file(eax,esi)
;  6492             cmp eax,h4
;  6493             jl @f
;  6494 --              add dword[ebx+eax*4-8],1
;  6495                 int3
;  6496           @@:
;  6497             cmp esi,h4
;  6498             jl @f
;  6499                 add dword[ebx+esi*4-8],1
;  6500           @@:
;  6501             push eax                            --[1] file number
;  6502             push esi                            --[2] byte range
;  6503             mov edx,routine_id(flock)           -- mov edx,imm32 (sets K_ridt)
;  6504             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6505             call :%opFrame
;  6506             mov edx,[esp+8]                     -- return address (of the call :%opUnLock)
;  6507             pop dword[ebp-8]                    --[2] byte range
;  6508             mov dword[ebp-4],UNLOCK             --    lock type
;  6509             pop dword[ebp]                      --[1] file number
;  6510             mov dword[ebp+16],:unlockret        -- return address
;  6511             mov dword[ebp+12],edx               -- called from address (for errors)
;  6512             jmp $_il                            -- jmp code:flock
;  6513           ::unlockret
;  6514         [64]
;  6515             -- calling convention
;  6516             --  mov rax,[fn]        -- file number (opUnassigned, integer)
;  6517             --  mov rsi,[byterange] -- byte range (opUnassigned, sequence)
;  6518             --  call :%opUnLock     -- [rdi]:=unlock_file(rax,rsi)
;  6519             mov r15,h4
                    mov r15,h4            ;#0043EA66: 49:277 0000000000000040    uv 8000 00  1 221      
;  6520             cmp rax,r15
                    cmp rax,r15           ;#0043EA70: 49:073307                  uv 00 8001  1 222 8000   
;  6521             jl @f
                    jl #0043EA76          ;#0043EA73: 174 01                     v  00 00  1 222      
;  6522 --              add qword[rbx+rax*4-16],1
;  6523                 int3
                        int3              ;#0043EA75: 314                        np 00 00 13 223      
;  6524           @@:
;  6525             cmp rsi,r15
                    cmp rsi,r15           ;#0043EA76: 49:073367                  uv 00 8040  1 236      
;  6526             jl @f
                    jl #0043EA81          ;#0043EA79: 174 06                     v  00 00  1 236      
;  6527                 add qword[rbx+rsi*4-16],1
                        add qword[rbx+rsi*4-16],1  ;#0043EA7B: 48:203104263 F0 01         u  00 48  3 237      
;  6528           @@:
;  6529             push rax                            --[1] file number
                    push rax              ;#0043EA81: 48:120                     vu 00 01  1 239      
;  6530             push rsi                            --[2] byte range
                    push rsi              ;#0043EA83: 48:126                     uv 00 40  1 240      
;  6531             mov rdx,routine_id(flock)           -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1059          ;#0043EA85: 272 23040000               vu 04 00  1 240      
;  6532             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,9             ;#0043EA8A: 48:307301 09000000         uv 02 00  1 241      
;  6533             call :%opFrame
                    call #004428DB (:%opFrame) (flock)  ;#0043EA91: 350 453E0000               v  00 00  1 241      
;  6534             mov rdx,[rsp+16]                    -- return address (of the call :%opLock)
                    mov rdx,[rsp+16]      ;#0043EA96: 48:213124044 10            uv 04 10  1 242      
;  6535             pop qword[rbp-16]                   --[2] byte range
                    pop qword[rbp-16] (byterange)  ;#0043EA9B: 147:217105 F0              np 00 20  3 243      
;  6536             mov qword[rbp-8],UNLOCK             --    lock type
                    mov qword[rbp-8] (locktype),0  ;#0043EA9F: 48:307105 F8 00000000      uv 00 20  1 246      
;  6537             pop qword[rbp]                      --[1] file number
                    pop qword[rbp] (fn)   ;#0043EAA7: 147:217105 00              np 00 20  3 247      
;  6538             mov qword[rbp+32],:unlockret        -- return address
                    mov qword[retaddr],#0043EABC  ;#0043EAAB: 48:307105 20 BCEA4300      uv 00 20  1 250      
;  6539             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EAB3: 48:211125 18               vu 00 24  1 250      
;  6540             jmp $_il                            -- jmp code:flock
                    jmp #0043C42D (code:flock)  ;#0043EAB7: 351 71D9FFFF               v  00 00  1 251      
;  6541           ::unlockret
;  6542         []
;  6543             ret
                    ret                   ;#0043EABC: 303                        np 00 00  2 252      
;  6544 
;  6545 --global function get_text(integer fn, integer option=-2) -- = GT_WHOLE_FILE)
;  6546 --function fget_text(integer fn, integer option) (option gets a default of -2 in pmain.e)
;  6547 --/*
;  6548 procedure :%opGetText(:%)
;  6549 end procedure -- (for Edita/CtrlQ)
;  6550 --*/
;  6551     :%opGetText
;  6552 --------------
;  6553         --  The "glue" needed to allow get_text() to be put in the optable.
;  6554         [32]
;  6555             -- calling convention
;  6556             --  lea edi,[res]       -- result location
;  6557             --  mov eax,[fn]        -- file number (opUnassigned, integer)
;  6558             --  mov ecx,[option]    -- option (opUnassigned, integer, =-2 in pmain.e)
;  6559             --  call :%opGetText    -- [edi]:=get_text(eax,ecx)
;  6560             cmp eax,h4
;  6561             jl @f
;  6562 --              add dword[ebx+eax*4-8],1
;  6563                 int3
;  6564           @@:
;  6565             cmp ecx,h4
;  6566             jl @f
;  6567 --              add dword[ebx+ecx*4-8],1
;  6568                 int3
;  6569           @@:
;  6570             push dword[edi]                     --[1] prev res (popped into edx)
;  6571             push edi                            --[2] addr res
;  6572             push eax                            --[3] fn
;  6573             push ecx                            --[4] option
;  6574             mov edx,routine_id(fget_text)       -- mov edx,imm32 (sets K_ridt)
;  6575             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6576             call :%opFrame
;  6577             mov edx,[esp+16]                    -- return address (of the call :%opGetText)
;  6578             pop dword[ebp-4]                    --[4] option
;  6579             pop dword[ebp]                      --[3] fn
;  6580             mov dword[ebp+16],:gtret            -- return address
;  6581             mov dword[ebp+12],edx               -- called from address (for errors)
;  6582             jmp $_il                            -- jmp code:fget_text
;  6583           ::gtret
;  6584             pop edi                             --[2] addr res
;  6585             pop edx                             --[1] prev (equiv to mov edx,[edi])
;  6586             mov [edi],eax
;  6587             cmp edx,h4
;  6588             jle @f
;  6589                 sub dword[ebx+edx*4-8],1
;  6590                 jz :%pDealloc
;  6591         [64]
;  6592             -- calling convention
;  6593             --  lea rdi,[res]       -- result location
;  6594             --  mov rax,[fn]        -- file number (opUnassigned, integer)
;  6595             --  mov rcx,[option]    -- option (opUnassigned, integer, =-2 in pmain.e)
;  6596             --  call :%opGetText    -- [rdi]:=get_text(rax,rcx)
;  6597             mov r15,h4
                    mov r15,h4            ;#0043EABD: 49:277 0000000000000040    uv 8000 00  1 254      
;  6598             cmp rax,r15
                    cmp rax,r15           ;#0043EAC7: 49:073307                  uv 00 8001  1 255 8000   
;  6599             jl @f
                    jl #0043EACD          ;#0043EACA: 174 01                     v  00 00  1 255      
;  6600 --              add qword[rbx+rax*4-16],1
;  6601                 int3
                        int3              ;#0043EACC: 314                        np 00 00 13 256      
;  6602           @@:
;  6603             cmp rcx,r15
                    cmp rcx,r15           ;#0043EACD: 49:073317                  uv 00 8002  1 269      
;  6604             jl @f
                    jl #0043EAD3          ;#0043EAD0: 174 01                     v  00 00  1 269      
;  6605 --              add qword[rbx+rcx*4-16],1
;  6606                 int3
                        int3              ;#0043EAD2: 314                        np 00 00 13 270      
;  6607           @@:
;  6608 
;  6609             push qword[rdi]                     --[1] prev res (popped into rdx)
                    push qword[rdi]       ;#0043EAD3: 48:377067                  np 00 80  2 283      
;  6610             push rdi                            --[2] addr res
                    push rdi              ;#0043EAD6: 48:127                     uv 00 80  1 285      
;  6611             push rax                            --[3] fn
                    push rax              ;#0043EAD8: 48:120                     vu 00 01  1 285      
;  6612             push rcx                            --[4] option
                    push rcx              ;#0043EADA: 48:121                     uv 00 02  1 286      
;  6613             mov rdx,routine_id(fget_text)       -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1085          ;#0043EADC: 272 3D040000               vu 04 00  1 286      
;  6614             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,14            ;#0043EAE1: 48:307301 0E000000         uv 02 00  1 287      
;  6615             call :%opFrame
                    call :%opFrame (fget_text)  ;#0043EAE8: 350 EE3D0000               v  00 00  1 287      
;  6616             mov rdx,[rsp+32]                    -- return address (of the call :%opGetText)
                    mov rdx,[rsp+32]      ;#0043EAED: 48:213124044 20            uv 04 10  1 288      
;  6617             pop qword[rbp-8]                    --[4] option
                    pop qword[rbp-8] (option)  ;#0043EAF2: 147:217105 F8              np 00 20  3 289      
;  6618             pop qword[rbp]                      --[3] fn
                    pop qword[rbp] (fn)   ;#0043EAF6: 147:217105 00              np 00 20  3 292      
;  6619             mov qword[rbp+32],:gtret            -- return address
                    mov qword[retaddr],#0043EB0B  ;#0043EAFA: 48:307105 20 0BEB4300      uv 00 20  1 295      
;  6620             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EB02: 48:211125 18               vu 00 24  1 295      
;  6621             jmp $_il                            -- jmp code:fget_text
                    jmp #0043BA15 (code:fget_text)  ;#0043EB06: 351 0ACFFFFF               v  00 00  1 296      
;  6622           ::gtret
;  6623             pop rdi                             --[2] addr res
                    pop rdi               ;#0043EB0B: 48:137                     uv 80 00  1 297      
;  6624             pop rdx                             --[1] prev (equiv to mov edx,[edi])
                    pop rdx               ;#0043EB0D: 48:132                     vu 04 00  1 297      
;  6625             mov [rdi],rax
                    mov [rdi],rax         ;#0043EB0F: 48:211007                  uv 00 81  1 300    *80*
;  6626             cmp rdx,r15
                    cmp rdx,r15           ;#0043EB12: 49:073327                  vu 00 8004  1 300      
;  6627             jle @f
                    jle #0043EB23         ;#0043EB15: 176 0C                     v  00 00  1 301      
;  6628                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043EB17: 48:203154223 F0 01         u  00 0C  3 302      
;  6629                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043EB1D: 017204 B7370000            v  00 00  1 304      
;  6630         []
;  6631           @@:
;  6632             ret
                    ret                   ;#0043EB23: 303                        np 00 00  2 305      
;  6633 
;  6634 --/*
;  6635 procedure :%opGetPos(:%)
;  6636 end procedure -- (for Edita/CtrlQ)
;  6637 --*/
;  6638     :%opGetPos
;  6639 --------------
;  6640         --  The "glue" needed to allow get_text() to be put in the optable.
;  6641         [32]
;  6642             -- calling convention
;  6643             --  lea edi,[res]       -- result location
;  6644             --  call :%opGetPos -- [edi]:=get_position()
;  6645             push dword[edi]                     --[1] prev res (popped into edx)
;  6646             push edi                            --[2] addr res
;  6647             mov edx,routine_id(fget_position)   -- mov edx,imm32 (sets K_ridt)
;  6648             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6649             call :%opFrame
;  6650             mov edx,[esp+8]                     -- return address (of the call :%opGetPos)
;  6651             mov dword[ebp+16],:getposret        -- return address
;  6652             mov dword[ebp+12],edx               -- called from address (for errors)
;  6653             jmp $_il                            -- jmp code:fget_position
;  6654           ::getposret
;  6655             pop edi                             --[2] addr res
;  6656             pop edx                             --[1] prev (equiv to mov edx,[edi])
;  6657             mov [edi],eax
;  6658             cmp edx,h4
;  6659             jle @f
;  6660                 sub dword[ebx+edx*4-8],1
;  6661                 jz :%pDealloc
;  6662         [64]
;  6663             -- calling convention
;  6664             --  lea rdi,[res]       -- result location
;  6665             --  call :%opGetPos     -- [rdi]:=get_position()
;  6666             push qword[rdi]                     --[1] prev res (popped into rdx)
                    push qword[rdi]       ;#0043EB24: 48:377067                  np 00 80  2 307      
;  6667             push rdi                            --[2] addr res
                    push rdi              ;#0043EB27: 48:127                     uv 00 80  1 309      
;  6668             mov rdx,routine_id(fget_position)   -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1102          ;#0043EB29: 272 4E040000               vu 04 00  1 309      
;  6669             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,3             ;#0043EB2E: 48:307301 03000000         uv 02 00  1 310      
;  6670             call :%opFrame
                    call :%opFrame (fget_position)  ;#0043EB35: 350 A13D0000               v  00 00  1 310      
;  6671             mov rdx,[rsp+16]                    -- return address (of the call :%opGetPos)
                    mov rdx,[rsp+16]      ;#0043EB3A: 48:213124044 10            uv 04 10  1 311      
;  6672             mov qword[rbp+32],:getposret        -- return address
                    mov qword[retaddr],#0043EB50  ;#0043EB3F: 48:307105 20 50EB4300      vu 00 20  1 311      
;  6673             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EB47: 48:211125 18               uv 00 24  1 312      
;  6674             jmp $_il                            -- jmp code:fget_position
                    jmp #0043B950 (code:fget_position)  ;#0043EB4B: 351 00CEFFFF               v  00 00  1 312      
;  6675           ::getposret
;  6676             pop rdi                             --[2] addr res
                    pop rdi               ;#0043EB50: 48:137                     uv 80 00  1 313      
;  6677             pop rdx                             --[1] prev (equiv to mov edx,[edi])
                    pop rdx               ;#0043EB52: 48:132                     vu 04 00  1 313      
;  6678             mov [rdi],rax
                    mov [rdi],rax         ;#0043EB54: 48:211007                  uv 00 81  1 316    *80*
;  6679             cmp rdx,r15
                    cmp rdx,r15           ;#0043EB57: 49:073327                  vu 00 8004  1 316      
;  6680             jle @f
                    jle #0043EB68         ;#0043EB5A: 176 0C                     v  00 00  1 317      
;  6681                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043EB5C: 48:203154223 F0 01         u  00 0C  3 318      
;  6682                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043EB62: 017204 72370000            v  00 00  1 320      
;  6683         []
;  6684           @@:
;  6685             ret
                    ret                   ;#0043EB68: 303                        np 00 00  2 321      
;  6686 
;  6687 --/*
;  6688 procedure :%opWrap(:%)
;  6689 end procedure -- (for Edita/CtrlQ)
;  6690 --*/
;  6691     :%opWrap
;  6692 ------------
;  6693         --  The "glue" needed to allow get_text() to be put in the optable.
;  6694         [32]
;  6695             -- calling convention
;  6696             --  mov eax,[flag]      -- flag (opUnassigned, integer 0|1)
;  6697             --  call :%opWrap       -- wrap(eax)
;  6698             cmp eax,h4
;  6699             jl @f
;  6700 --              add dword[ebx+eax*4-8],1
;  6701                 int3
;  6702           @@:
;  6703             push eax                            --[1] flag
;  6704             mov edx,routine_id(fwrap)           -- mov edx,imm32 (sets K_ridt)
;  6705             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6706             call :%opFrame
;  6707             mov edx,[esp+4]                     -- return address (of the call :%opWrap)
;  6708             pop dword[ebp]                      --[1] flag
;  6709             mov dword[ebp+16],:wrapret          -- return address
;  6710             mov dword[ebp+12],edx               -- called from address (for errors)
;  6711             jmp $_il                            -- jmp code:fwrap
;  6712           ::wrapret
;  6713         [64]
;  6714             -- calling convention
;  6715             --  mov rax,[flag]      -- flag (opUnassigned, integer 0|1)
;  6716             --  call :%opWrap       -- wrap(rax)
;  6717             mov r15,h4
                    mov r15,h4            ;#0043EB69: 49:277 0000000000000040    uv 8000 00  1 323      
;  6718             cmp rax,r15
                    cmp rax,r15           ;#0043EB73: 49:073307                  uv 00 8001  1 324 8000   
;  6719             jl @f
                    jl #0043EB79          ;#0043EB76: 174 01                     v  00 00  1 324      
;  6720 --              add qword[rbx+rax*4-16],1
;  6721                 int3
                        int3              ;#0043EB78: 314                        np 00 00 13 325      
;  6722           @@:
;  6723             push rax                            --[1] flag
                    push rax              ;#0043EB79: 48:120                     uv 00 01  1 338      
;  6724             mov rdx,routine_id(fwrap)           -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1106          ;#0043EB7B: 272 52040000               vu 04 00  1 338      
;  6725             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,1             ;#0043EB80: 48:307301 01000000         uv 02 00  1 339      
;  6726             call :%opFrame
                    call #004428DB (:%opFrame) (fwrap)  ;#0043EB87: 350 4F3D0000               v  00 00  1 339      
;  6727             mov rdx,[rsp+8]                     -- return address (of the call :%opWrap)
                    mov rdx,[rsp+8]       ;#0043EB8C: 48:213124044 08            uv 04 10  1 340      
;  6728             pop qword[rbp]                      --[1] flag
                    pop qword[rbp] (flag)  ;#0043EB91: 147:217105 00              np 00 20  3 341      
;  6729             mov qword[rbp+32],:wrapret          -- return address
                    mov qword[retaddr],#0043EBA6  ;#0043EB95: 48:307105 20 A6EB4300      uv 00 20  1 344      
;  6730             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EB9D: 48:211125 18               vu 00 24  1 344      
;  6731             jmp $_il                            -- jmp code:fwrap
                    jmp #0043B8AD (code:fwrap)  ;#0043EBA1: 351 07CDFFFF               v  00 00  1 345      
;  6732           ::wrapret
;  6733         []
;  6734           @@:
;  6735             ret
                    ret                   ;#0043EBA6: 303                        np 00 00  2 346      
;  6736 
;  6737 --DEV now builtins/pScrollN.e (not part of the VM)
;  6738 ----/*
;  6739 --procedure :%opScroll(:%)
;  6740 --end procedure -- (for Edita/CtrlQ)
;  6741 ----*/
;  6742 --  :%opScroll
;  6743 ----------------
;  6744 --      --  The "glue" needed to allow get_text() to be put in the optable.
;  6745 --      [32]
;  6746 --          -- calling convention
;  6747 --          --  mov eax,[amount]    -- +/-lines (opUnassigned, integer)
;  6748 --          --  mov ecx,[top]       -- topline (opUnassigned, integer)
;  6749 --          --  mov esi,[bottom]    -- btmline (opUnassigned, integer)
;  6750 --          --  call :%opScroll     -- scroll(eax,ecx,esi)
;  6751 --          cmp eax,h4
;  6752 --          jl @f
;  6753 ----                add dword[ebx+eax*4-8],1
;  6754 --              int3
;  6755 --        @@:
;  6756 --          cmp ecx,h4
;  6757 --          jl @f
;  6758 ----                add dword[ebx+ecx*4-8],1
;  6759 --              int3
;  6760 --        @@:
;  6761 --          cmp esi,h4
;  6762 --          jl @f
;  6763 ----                add dword[ebx+esi*4-8],1
;  6764 --              int3
;  6765 --        @@:
;  6766 --          push eax                            --[1] amt
;  6767 --          push ecx                            --[2] top
;  6768 --          push esi                            --[3] btm
;  6769 --          mov edx,routine_id(fscroll)         -- mov edx,imm32 (sets K_ridt)
;  6770 --          mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6771 --          call :%opFrame
;  6772 --          mov edx,[esp+12]                    -- return address (of the call :%opGetText)
;  6773 --          pop dword[ebp-8]                    --[3] btm
;  6774 --          pop dword[ebp-4]                    --[2] top
;  6775 --          pop dword[ebp]                      --[1] amt
;  6776 --          mov dword[ebp+16],:scrollret        -- return address
;  6777 --          mov dword[ebp+12],edx               -- called from address (for errors)
;  6778 --          jmp $_il                            -- jmp code:fscroll
;  6779 --        ::scrollret
;  6780 --      [64]
;  6781 --          -- calling convention
;  6782 --          --  mov rax,[amt]       -- +/- lines (opUnassigned, integer)
;  6783 --          --  mov rcx,[top]       -- top line (opUnassigned, integer)
;  6784 --          --  mov rsi,[btm]       -- bottom line (opUnassigned, integer)
;  6785 --          --  call :%opScroll     -- scroll(rax,rcx,rsi)
;  6786 --          mov r15,h4
;  6787 --          cmp rax,r15
;  6788 --          jl @f
;  6789 ----                add qword[rbx+rax*4-16],1
;  6790 --              int3
;  6791 --        @@:
;  6792 --          cmp rcx,r15
;  6793 --          jl @f
;  6794 ----                add qword[rbx+rcx*4-16],1
;  6795 --              int3
;  6796 --        @@:
;  6797 --          cmp rsi,r15
;  6798 --          jl @f
;  6799 ----                add qword[rbx+rsi*4-16],1
;  6800 --              int3
;  6801 --        @@:
;  6802 --
;  6803 --          push rax                            --[1] amt
;  6804 --          push rcx                            --[2] top
;  6805 --          push rsi                            --[3] btm
;  6806 --          mov rdx,routine_id(fscroll)         -- mov rdx,imm32 (sets K_ridt)
;  6807 --          mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
;  6808 --          call :%opFrame
;  6809 --          mov rdx,[rsp+24]                    -- return address (of the call :%opGetText)
;  6810 --          pop qword[rbp-16]                   --[3] btm
;  6811 --          pop qword[rbp-8]                    --[2] top
;  6812 --          pop qword[rbp]                      --[1] amt
;  6813 --          mov qword[rbp+32],:scrollret        -- return address
;  6814 --          mov qword[rbp+24],rdx               -- called from address (for errors)
;  6815 --          jmp $_il                            -- jmp code:fscroll
;  6816 --        ::scrollret
;  6817 --      []
;  6818 --        @@:
;  6819 --          ret
;  6820 
;  6821 --/*
;  6822 procedure :%opTextRows(:%)
;  6823 end procedure -- (for Edita/CtrlQ)
;  6824 --*/
;  6825     :%opTextRows
;  6826 --------------
;  6827         --  The "glue" needed to allow text_rows() to be put in the optable.
;  6828         [32]
;  6829             -- calling convention
;  6830             --  lea edi,[res]       -- result location
;  6831             --  mov eax,[lines]     -- lines (opUnassigned, integer)
;  6832             --  call :%opTextRows   -- [edi]:=text_rows(eax)
;  6833             cmp eax,h4
;  6834             jl @f
;  6835 --              add dword[ebx+eax*4-8],1
;  6836                 int3
;  6837           @@:
;  6838             push dword[edi]                     --[1] prev res (popped into edx)
;  6839             push edi                            --[2] addr res
;  6840             push eax                            --[3] lines
;  6841             mov edx,routine_id(ftext_rows)      -- mov edx,imm32 (sets K_ridt)
;  6842             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6843             call :%opFrame
;  6844             mov edx,[esp+12]                    -- return address (of the call :%opTextRows)
;  6845             pop dword[ebp]                      --[3] lines
;  6846             mov dword[ebp+16],:textrowsret      -- return address
;  6847             mov dword[ebp+12],edx               -- called from address (for errors)
;  6848             jmp $_il                            -- jmp code:ftext_rows
;  6849           ::textrowsret
;  6850             pop edi                             --[2] addr res
;  6851             pop edx                             --[1] prev (equiv to mov edx,[edi])
;  6852             mov [edi],eax
;  6853             cmp edx,h4
;  6854             jle @f
;  6855                 sub dword[ebx+edx*4-8],1
;  6856                 jz :%pDealloc
;  6857         [64]
;  6858             -- calling convention
;  6859             --  lea rdi,[res]       -- result location
;  6860             --  mov rax,[lines]     -- lines (opUnassigned, integer)
;  6861             --  call :%opTextRows   -- [rdi]:=text_rows(rax)
;  6862             mov r15,h4
                    mov r15,h4            ;#0043EBA7: 49:277 0000000000000040    uv 8000 00  1 348      
;  6863             cmp rax,r15
                    cmp rax,r15           ;#0043EBB1: 49:073307                  uv 00 8001  1 349 8000   
;  6864             jl @f
                    jl #0043EBB7          ;#0043EBB4: 174 01                     v  00 00  1 349      
;  6865 --              add qword[rbx+rax*4-16],1
;  6866                 int3
                        int3              ;#0043EBB6: 314                        np 00 00 13 350      
;  6867           @@:
;  6868             push qword[rdi]                     --[1] prev res (popped into rdx)
                    push qword[rdi]       ;#0043EBB7: 48:377067                  np 00 80  2 363      
;  6869             push rdi                            --[2] addr res
                    push rdi              ;#0043EBBA: 48:127                     uv 00 80  1 365      
;  6870             push rax                            --[3] lines
                    push rax              ;#0043EBBC: 48:120                     vu 00 01  1 365      
;  6871             mov rdx,routine_id(ftext_rows)      -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1109          ;#0043EBBE: 272 55040000               uv 04 00  1 366      
;  6872             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,2             ;#0043EBC3: 48:307301 02000000         vu 02 00  1 366      
;  6873             call :%opFrame
                    call :%opFrame (ftext_rows)  ;#0043EBCA: 350 0C3D0000               v  00 00  1 367      
;  6874             mov rdx,[rsp+24]                    -- return address (of the call :%opTextRows)
                    mov rdx,[rsp+24]      ;#0043EBCF: 48:213124044 18            uv 04 10  1 368      
;  6875             pop qword[rbp]                      --[3] lines
                    pop qword[rbp] (newrows)  ;#0043EBD4: 147:217105 00              np 00 20  3 369      
;  6876             mov qword[rbp+32],:textrowsret      -- return address
                    mov qword[retaddr],#0043EBE9  ;#0043EBD8: 48:307105 20 E9EB4300      uv 00 20  1 372      
;  6877             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EBE0: 48:211125 18               vu 00 24  1 372      
;  6878             jmp $_il                            -- jmp code:ftext_rows
                    jmp #0043B7DC (code:ftext_rows)  ;#0043EBE4: 351 F3CBFFFF               v  00 00  1 373      
;  6879           ::textrowsret
;  6880             pop rdi                             --[2] addr res
                    pop rdi               ;#0043EBE9: 48:137                     uv 80 00  1 374      
;  6881             pop rdx                             --[1] prev (equiv to mov edx,[edi])
                    pop rdx               ;#0043EBEB: 48:132                     vu 04 00  1 374      
;  6882             mov [rdi],rax
                    mov [rdi],rax         ;#0043EBED: 48:211007                  uv 00 81  1 377    *80*
;  6883             cmp rdx,r15
                    cmp rdx,r15           ;#0043EBF0: 49:073327                  vu 00 8004  1 377      
;  6884             jle @f
                    jle #0043EC01         ;#0043EBF3: 176 0C                     v  00 00  1 378      
;  6885                 sub qword[rbx+rdx*4-16],1
                        sub qword[rbx+rdx*4-16],1  ;#0043EBF5: 48:203154223 F0 01         u  00 0C  3 379      
;  6886                 jz :%pDealloc
                        jz #004422DA (:%pDealloc)  ;#0043EBFB: 017204 D9360000            v  00 00  1 381      
;  6887         []
;  6888           @@:
;  6889             ret
                    ret                   ;#0043EC01: 303                        np 00 00  2 382      
;  6890 
;  6891 --/*
;  6892 procedure :%opBkClr(:%)
;  6893 end procedure -- (for Edita/CtrlQ)
;  6894 --*/
;  6895     :%opBkClr
;  6896 ------------
;  6897         --  The "glue" needed to allow bk_color() to be put in the optable.
;  6898         [32]
;  6899             -- calling convention
;  6900             --  mov eax,[color]     -- color (opUnassigned, integer)
;  6901             --  call :%opBkClr      -- bk_color(eax)
;  6902             cmp eax,h4
;  6903             jl @f
;  6904 --              add dword[ebx+eax*4-8],1
;  6905                 int3
;  6906           @@:
;  6907             push eax                                --[1] color
;  6908             mov edx,routine_id(set_console_color)   -- mov edx,imm32 (sets K_ridt)
;  6909             mov ecx,$_Ltot                          -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6910             call :%opFrame
;  6911             mov edx,[esp+4]                         -- return address (of the call :%opBkClr)
;  6912             mov dword[ebp-4],BACKGROUNDCOLOR
;  6913             pop dword[ebp]                          --[1] color
;  6914             mov dword[ebp+16],:bkclrret             -- return address
;  6915             mov dword[ebp+12],edx                   -- called from address (for errors)
;  6916             jmp $_il                                -- jmp code:set_console_color
;  6917           ::bkclrret
;  6918         [64]
;  6919             -- calling convention
;  6920             --  mov rax,[color]     -- color (opUnassigned, integer)
;  6921             --  call :%opBkClr      -- wrap(rax)
;  6922             mov r15,h4
                    mov r15,h4            ;#0043EC02: 49:277 0000000000000040    uv 8000 00  1 384      
;  6923             cmp rax,r15
                    cmp rax,r15           ;#0043EC0C: 49:073307                  uv 00 8001  1 385 8000   
;  6924             jl @f
                    jl #0043EC12          ;#0043EC0F: 174 01                     v  00 00  1 385      
;  6925 --              add qword[rbx+rax*4-16],1
;  6926                 int3
                        int3              ;#0043EC11: 314                        np 00 00 13 386      
;  6927           @@:
;  6928             push rax                                --[1] color
                    push rax              ;#0043EC12: 48:120                     uv 00 01  1 399      
;  6929             mov rdx,routine_id(set_console_color)   -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1114          ;#0043EC14: 272 5A040000               vu 04 00  1 399      
;  6930             mov rcx,$_Ltot                          -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,2             ;#0043EC19: 48:307301 02000000         uv 02 00  1 400      
;  6931             call :%opFrame
                    call :%opFrame (set_console_color)  ;#0043EC20: 350 B63C0000               v  00 00  1 400      
;  6932             mov rdx,[rsp+8]                         -- return address (of the call :%opBkClr)
                    mov rdx,[rsp+8]       ;#0043EC25: 48:213124044 08            uv 04 10  1 401      
;  6933             mov qword[rbp-8],BACKGROUNDCOLOR
                    mov qword[rbp-8] (cmode),0  ;#0043EC2A: 48:307105 F8 00000000      vu 00 20  1 401      
;  6934             pop qword[rbp]                          --[1] color
                    pop qword[rbp] (color)  ;#0043EC32: 147:217105 00              np 00 20  3 402      
;  6935             mov qword[rbp+32],:bkclrret             -- return address
                    mov qword[retaddr],#0043EC47  ;#0043EC36: 48:307105 20 47EC4300      uv 00 20  1 405      
;  6936             mov qword[rbp+24],rdx                   -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EC3E: 48:211125 18               vu 00 24  1 405      
;  6937             jmp $_il                                -- jmp code:set_console_color
                    jmp code:set_console_color  ;#0043EC42: 351 E3CAFFFF               v  00 00  1 406      
;  6938           ::bkclrret
;  6939         []
;  6940           @@:
;  6941             ret
                    ret                   ;#0043EC47: 303                        np 00 00  2 407      
;  6942 
;  6943 --/*
;  6944 procedure :%opTxtClr(:%)
;  6945 end procedure -- (for Edita/CtrlQ)
;  6946 --*/
;  6947     :%opTxtClr
;  6948 ------------
;  6949         --  The "glue" needed to allow text_color() to be put in the optable.
;  6950         [32]
;  6951             -- calling convention
;  6952             --  mov eax,[color]     -- color (opUnassigned, integer)
;  6953             --  call :%opTxtClr     -- text_color(eax)
;  6954             cmp eax,h4
;  6955             jl @f
;  6956 --              add dword[ebx+eax*4-8],1
;  6957                 int3
;  6958           @@:
;  6959             push eax                                --[1] color
;  6960             mov edx,routine_id(set_console_color)   -- mov edx,imm32 (sets K_ridt)
;  6961             mov ecx,$_Ltot                          -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  6962             call :%opFrame
;  6963             mov edx,[esp+4]                         -- return address (of the call :%opTxtClr)
;  6964             mov dword[ebp-4],TEXTCOLOR
;  6965             pop dword[ebp]                          --[1] color
;  6966             mov dword[ebp+16],:txclrret             -- return address
;  6967             mov dword[ebp+12],edx                   -- called from address (for errors)
;  6968             jmp $_il                                -- jmp code:set_console_color
;  6969           ::txclrret
;  6970         [64]
;  6971             -- calling convention
;  6972             --  mov rax,[color]     -- color (opUnassigned, integer)
;  6973             --  call :%opTxtClr     -- text_color(rax)
;  6974             mov r15,h4
                    mov r15,h4            ;#0043EC48: 49:277 0000000000000040    uv 8000 00  1 409      
;  6975             cmp rax,r15
                    cmp rax,r15           ;#0043EC52: 49:073307                  uv 00 8001  1 410 8000   
;  6976             jl @f
                    jl #0043EC58          ;#0043EC55: 174 01                     v  00 00  1 410      
;  6977 --              add qword[rbx+rax*4-16],1
;  6978                 int3
                        int3              ;#0043EC57: 314                        np 00 00 13 411      
;  6979           @@:
;  6980             push rax                                --[1] color
                    push rax              ;#0043EC58: 48:120                     uv 00 01  1 424      
;  6981             mov rdx,routine_id(set_console_color)   -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1114          ;#0043EC5A: 272 5A040000               vu 04 00  1 424      
;  6982             mov rcx,$_Ltot                          -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,2             ;#0043EC5F: 48:307301 02000000         uv 02 00  1 425      
;  6983             call :%opFrame
                    call :%opFrame (set_console_color)  ;#0043EC66: 350 703C0000               v  00 00  1 425      
;  6984             mov rdx,[rsp+8]                         -- return address (of the call :%opTxtClr)
                    mov rdx,[rsp+8]       ;#0043EC6B: 48:213124044 08            uv 04 10  1 426      
;  6985             mov qword[rbp-8],TEXTCOLOR
                    mov qword[rbp-8] (cmode),1  ;#0043EC70: 48:307105 F8 01000000      vu 00 20  1 426      
;  6986             pop qword[rbp]                          --[1] color
                    pop qword[rbp] (color)  ;#0043EC78: 147:217105 00              np 00 20  3 427      
;  6987             mov qword[rbp+32],:txclrret             -- return address
                    mov qword[retaddr],#0043EC8D  ;#0043EC7C: 48:307105 20 8DEC4300      uv 00 20  1 430      
;  6988             mov qword[rbp+24],rdx                   -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043EC84: 48:211125 18               vu 00 24  1 430      
;  6989             jmp $_il                                -- jmp code:set_console_color
                    jmp code:set_console_color  ;#0043EC88: 351 9DCAFFFF               v  00 00  1 431      
;  6990           ::txclrret
;  6991         []
;  6992           @@:
;  6993             ret
                    ret                   ;#0043EC8D: 303                        np 00 00  2 432      
;  6994 
;  6995 --/*
;  6996 procedure :%opClrScrn(:%)
;  6997 end procedure -- (for Edita/CtrlQ)
;  6998 --*/
;  6999     :%opClrScrn
;  7000 ---------------
;  7001         --  The "glue" needed to allow clear_screen() to be put in the optable.
;  7002         [32]
;  7003             -- calling convention
;  7004             --  call :%opClrScrn -- clear_screen()
;  7005             mov edx,routine_id(fclear_screen)   -- mov edx,imm32 (sets K_ridt)
;  7006             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  7007             call :%opFrame
;  7008             mov edx,[esp]                       -- return address (of the call :%opClrScrn)
;  7009             mov dword[ebp+16],:clsret           -- return address
;  7010             mov dword[ebp+12],edx               -- called from address (for errors)
;  7011             jmp $_il                            -- jmp code:fclear_screen
;  7012           ::clsret
;  7013         [64]
;  7014             -- calling convention
;  7015             --  call :%opClrScrn -- clear_screen()
;  7016             mov rdx,routine_id(fclear_screen)   -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1117          ;#0043EC8E: 272 5D040000               uv 04 00  1 434      
;  7017             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,0             ;#0043EC93: 48:307301 00000000         vu 02 00  1 434      
;  7018             call :%opFrame
                    call :%opFrame (fclear_screen)  ;#0043EC9A: 350 3C3C0000               v  00 00  1 435      
;  7019             mov rdx,[rsp]                       -- return address (of the call :%opClrScrn)
                    mov rdx,[rsp]         ;#0043EC9F: 48:213024044               uv 04 10  1 436      
;  7020             mov qword[rbp+32],:clsret           -- return address
                    mov qword[retaddr],#0043ECB4  ;#0043ECA3: 48:307105 20 B4EC4300      vu 00 20  1 436      
;  7021             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043ECAB: 48:211125 18               uv 00 24  1 437      
;  7022             jmp $_il                            -- jmp code:fclear_screen
                    jmp #0043B676 (code:fclear_screen)  ;#0043ECAF: 351 C2C9FFFF               v  00 00  1 437      
;  7023           ::clsret
;  7024         []
;  7025           @@:
;  7026             ret
                    ret                   ;#0043ECB4: 303                        np 00 00  2 438      
;  7027 
;  7028 --/*
;  7029 procedure :%opFreeCons(:%)
;  7030 end procedure -- (for Edita/CtrlQ)
;  7031 --*/
;  7032     :%opFreeCons
;  7033 ----------------
;  7034         --  The "glue" needed to allow get_text() to be put in the optable.
;  7035         [32]
;  7036             -- calling convention
;  7037             --  call :%opFreeCons -- free_console()
;  7038             mov edx,routine_id(ffree_console)   -- mov edx,imm32 (sets K_ridt)
;  7039             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  7040             call :%opFrame
;  7041             mov edx,[esp]                       -- return address (of the call :%opFreeCons)
;  7042             mov dword[ebp+16],:fcret            -- return address
;  7043             mov dword[ebp+12],edx               -- called from address (for errors)
;  7044             jmp $_il                            -- jmp code:ffree_console
;  7045           ::fcret
;  7046         [64]
;  7047             -- calling convention
;  7048             --  call :%opFreeCons -- free_console()
;  7049             mov rdx,routine_id(ffree_console)   -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1118          ;#0043ECB5: 272 5E040000               uv 04 00  1 440      
;  7050             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,0             ;#0043ECBA: 48:307301 00000000         vu 02 00  1 440      
;  7051             call :%opFrame
                    call :%opFrame (ffree_console)  ;#0043ECC1: 350 153C0000               v  00 00  1 441      
;  7052             mov rdx,[rsp]                       -- return address (of the call :%opFreeCons)
                    mov rdx,[rsp]         ;#0043ECC6: 48:213024044               uv 04 10  1 442      
;  7053             mov qword[rbp+32],:fcret            -- return address
                    mov qword[retaddr],#0043ECDB  ;#0043ECCA: 48:307105 20 DBEC4300      vu 00 20  1 442      
;  7054             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043ECD2: 48:211125 18               uv 00 24  1 443      
;  7055             jmp $_il                            -- jmp code:ffree_console
                    jmp #0043B63B (code:ffree_console)  ;#0043ECD6: 351 60C9FFFF               v  00 00  1 443      
;  7056           ::fcret
;  7057         []
;  7058           @@:
;  7059             ret
                    ret                   ;#0043ECDB: 303                        np 00 00  2 444      
;  7060 
;  7061 --/*
;  7062 procedure :%opPosition(:%)
;  7063 end procedure -- (for Edita/CtrlQ)
;  7064 --*/
;  7065     :%opPosition
;  7066 ------------
;  7067         --  The "glue" needed to allow position() to be put in the optable.
;  7068         [32]
;  7069             -- calling convention
;  7070             --  mov eax,[line]      -- line (opUnassigned, integer)
;  7071             --  mov ecx,[col]       -- col (opUnassigned, integer)
;  7072             --  call :%opPosition   -- position(eax,ecx)
;  7073             cmp eax,h4
;  7074             jl @f
;  7075 --              add dword[ebx+eax*4-8],1
;  7076                 int3
;  7077           @@:
;  7078             cmp ecx,h4
;  7079             jl @f
;  7080 --              add dword[ebx+ecx*4-8],1
;  7081                 int3
;  7082           @@:
;  7083             push eax                            --[1] line
;  7084             push ecx                            --[2] col
;  7085             mov edx,routine_id(fposition)       -- mov edx,imm32 (sets K_ridt)
;  7086             mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[open][S_Ltot])
;  7087             call :%opFrame
;  7088             mov edx,[esp+8]                     -- return address (of the call :%opPosition)
;  7089             pop dword[ebp-4]                    --[2] col
;  7090             pop dword[ebp]                      --[1] line
;  7091             mov dword[ebp+16],:posnret          -- return address
;  7092             mov dword[ebp+12],edx               -- called from address (for errors)
;  7093             jmp $_il                            -- jmp code:fposition
;  7094           ::posnret
;  7095         [64]
;  7096             -- calling convention
;  7097             --  mov rax,[line]      -- line (opUnassigned, integer)
;  7098             --  mov rcx,[col]       -- col (opUnassigned, integer)
;  7099             --  call :%opPosition   -- position(rax,rcx)
;  7100             mov r15,h4
                    mov r15,h4            ;#0043ECDC: 49:277 0000000000000040    uv 8000 00  1 446      
;  7101             cmp rax,r15
                    cmp rax,r15           ;#0043ECE6: 49:073307                  uv 00 8001  1 447 8000   
;  7102             jl @f
                    jl #0043ECEC          ;#0043ECE9: 174 01                     v  00 00  1 447      
;  7103 --              add qword[rbx+rax*4-16],1
;  7104                 int3
                        int3              ;#0043ECEB: 314                        np 00 00 13 448      
;  7105           @@:
;  7106             cmp rcx,r15
                    cmp rcx,r15           ;#0043ECEC: 49:073317                  uv 00 8002  1 461      
;  7107             jl @f
                    jl #0043ECF2          ;#0043ECEF: 174 01                     v  00 00  1 461      
;  7108 --              add dword[rbx+rcx*4-16],1
;  7109                 int3
                        int3              ;#0043ECF1: 314                        np 00 00 13 462      
;  7110           @@:
;  7111             push rax                            --[1] line
                    push rax              ;#0043ECF2: 48:120                     uv 00 01  1 475      
;  7112             push rcx                            --[2] col
                    push rcx              ;#0043ECF4: 48:121                     vu 00 02  1 475      
;  7113             mov rdx,routine_id(fposition)       -- mov rdx,imm32 (sets K_ridt)
                    mov edx,1119          ;#0043ECF6: 272 5F040000               uv 04 00  1 476      
;  7114             mov rcx,$_Ltot                      -- mov rcx,imm32 (=symtab[open][S_Ltot])
                    mov rcx,6             ;#0043ECFB: 48:307301 06000000         vu 02 00  1 476      
;  7115             call :%opFrame
                    call :%opFrame (fposition)  ;#0043ED02: 350 D43B0000               v  00 00  1 477      
;  7116             mov rdx,[rsp+16]                    -- return address (of the call :%opPosition)
                    mov rdx,[rsp+16]      ;#0043ED07: 48:213124044 10            uv 04 10  1 478      
;  7117             pop qword[rbp-8]                    --[2] col
                    pop qword[rbp-8] (col)  ;#0043ED0C: 147:217105 F8              np 00 20  3 479      
;  7118             pop qword[rbp]                      --[1] line
                    pop qword[rbp] (line)  ;#0043ED10: 147:217105 00              np 00 20  3 482      
;  7119             mov qword[rbp+32],:posnret          -- return address
                    mov qword[retaddr],#0043ED25  ;#0043ED14: 48:307105 20 25ED4300      uv 00 20  1 485      
;  7120             mov qword[rbp+24],rdx               -- called from address (for errors)
                    mov [rbp+24],rdx      ;#0043ED1C: 48:211125 18               vu 00 24  1 485      
;  7121             jmp $_il                            -- jmp code:fposition
                    jmp #0043B4A3 (code:fposition)  ;#0043ED20: 351 7EC7FFFF               v  00 00  1 486      
;  7122           ::posnret
;  7123         []
;  7124           @@:
;  7125             ret
                    ret                   ;#0043ED25: 303                        np 00 00  2 487      
;  7126 
;  7127           ::fin
;  7128       }
;  7129 
    jmp #0044298D (:%opRetf)              ;#0043ED26: 351 623C0000               v  00 00  1 489      
;C:\Program Files (x86)\Phix\builtins\VM\pPower.e:
;=================================================
;     1 --
;     2 -- pPower.e
;     3 -- ========
;     4 --
;     5 --  Implements :%opPow
;     6 --
;     7 
;     8 include VM\pHeap.e  -- :%pDealloc/:%pStoreFlt
;     9 include VM\pFPU.e   -- :%down53 etc
;    10 
;    11 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043B31A: 351 6E760000               v  00 00  1   1      
;    12 
;    13 --DEV
;    14         ::e102cr0tple0   -- cannot raise 0 to power<=0
;    15             int3
                    int3                  ;#0043B31F: 314                        np 00 00 13   2      
;    16         ::e1413sopa
;    17             int3
                    int3                  ;#0043B320: 314                        np 00 00 13  15      
;    18         ::e34pfu
;    19             int3
                    int3                  ;#0043B321: 314                        np 00 00 13  28      
;    20         ::e35pfo
;    21             int3
                    int3                  ;#0043B322: 314                        np 00 00 13  41      
;    22         ::e54atrnntnip
;    23             int3
                    int3                  ;#0043B323: 314                        np 00 00 13  54      
;    24 
;    25 --/*
;    26 procedure :%opPow(:%)
;    27 end procedure -- (for Edita/CtrlQ)
;    28 --*/
;    29   :%opPow
;    30 ---------
;    31     [32]
;    32         --calling convention:
;    33         --  lea edi,[p1]        -- target
;    34         --  mov ecx,[p3]        -- ref p3 (opUnassigned)
;    35         --  mov eax,[p2]        -- ref p2 (opUnassigned)
;    36         --  call :%opPow        -- [edi] := power(eax,ecx)
;    37         --    all registers trashed unless result is integer, left in eax
;    38 
;    39         -- handle power(2,0..29) as 1 shl cl.
;    40         cmp eax,2
;    41         jne :notPow2
;    42         cmp ecx,29
;    43         ja :notPow2
;    44         mov eax,1
;    45         mov edx,[edi]
;    46         shl eax,cl
;    47       ::opPowRet
;    48         cmp edx,h4
;    49         mov [edi],eax
;    50         jle @f
;    51             sub dword[ebx+edx*4-8],1
;    52             jz :%pDealloc
;    53       @@:
;    54         ret
;    55 
;    56       ::notPow2
;    57 
;    58         -- handle power(x,0) as 1, except for power(0,0) and power(<seq>,0) which are errors
;    59         test ecx,ecx
;    60         jnz :notPow0
;    61         test eax,eax
;    62         jz :e102cr0tple0
;    63         cmp eax,h4
;    64         jl @f
;    65             cmp byte[ebx+eax*4-1],0x12
;    66             jne :e1413sopa
;    67       @@:
;    68         mov edx,[edi]
;    69         mov eax,1
;    70         jmp :opPowRet
;    71     
;    72       ::notPow0
;    73 
;    74         -- power(-177..177,1..4) can be done using mul to give an integer result...
;    75         cmp ecx,4
;    76         ja :notIntRes
;    77         cmp eax,-177
;    78         jl :notIntRes
;    79         cmp eax,177
;    80         jg :notIntRes
;    81         mov esi,eax
;    82         mov edx,[edi]
;    83         sub ecx,1
;    84         jz :opPowRet
;    85       ::IntPowMulLoop
;    86         imul esi
;    87         sub ecx,1
;    88         jnz IntPowMulLoop
;    89         mov edx,[edi]
;    90         jmp :opPowRet
;    91 
;    92       ::notIntRes
;    93         cmp ecx,h4
;    94         jge :opPowp3Flt
;    95             push ecx
;    96             fild dword[esp]
;    97             add esp,4
;    98             jmp @f
;    99       ::opPowp3Flt
;   100             cmp byte[ebx+ecx*4-1],0x12
;   101             jne :e1413sopa
;   102             fld qword[ebx+ecx*4]
;   103       @@:
;   104         cmp eax,h4
;   105         jge :opPowp2Flt
;   106             push eax
;   107             fild dword[esp]
;   108             add esp,4
;   109             jmp @f
;   110       ::opPowp2Flt
;   111             cmp byte[ebx+eax*4-1],0x12
;   112             jne :e1413sopa
;   113             fld qword[ebx+eax*4]
;   114       @@:
;   115 
;   116 --    ::opPowNN
;   117         fldz
;   118         fcomp
;   119         fnstsw ax
;   120 --DEV  test ah,0x41 jz (C=0 and Z=0 for ja), not sure any help since wd need test ah,0x40 next...
;   121         sahf
;   122         ja :opPowP2neg      -- jump if 0 > (above) p2
;   123         fxch
;   124         jne @f              -- if p2=0 then:
;   125             fldz
;   126             fcompp
;   127             fnstsw ax
;   128 --DEV test ah,0x01/jnz (C=1 for jb)
;   129             sahf
;   130             jb :%pStoreFlt
;   131             jmp :e102cr0tple0   -- cannot raise 0 to power<=0
;   132       @@:
;   133         fxch
;   134       ::opPowP3even
;   135         fyl2x               -- st1*=log2(st0); pop st0. st0 must be >0 ; ie log2(p2)*p3
;   136         fld st0             -- duplicate st0
;   137         frndint             -- round it to an integer   ;DEV SLOW!
;   138         fsub st1,st0        -- leave only fractional portion in st1
;   139         fxch st1            -- st1=int(p2*log2(p3)); st0=p2*log2(p3)-st1
;   140         f2xm1               -- get the fractional power of 2 (minus 1). st0 = 2^^st0-1 st0 must be in the range -1.0 to +1.0
;   141         fld1
;   142         faddp               -- get rid of that minus 1
;   143         fscale              -- multiply by 2^int(p2*log2(p3)) ; similar to shl 2 being same as mul 4
;   144 
;   145       ::opPowCont
;   146         fxch
;   147         fstp st0            -- discard junk
;   148 --  mov edx,edi
;   149 -- 30/1:
;   150     -- check for under/overflow:
;   151 --  cmp [sferr],0
;   152 --  je @f
;   153 --  mov [sferr],0
;   154 --minatm        dq 0xFFEFFFFFFFFFFFFF   ; -1.7976931348623146e308
;   155 --maxatm        dq 0x7FEFFFFFFFFFFFFF   ; +1.7976931348623146e308
;   156 --DEV test this!
;   157         push 0xFFEFFFFF
;   158         push -1
;   159 --  fld qword[minatm]
;   160         fld qword[esp]  -- minatm 
;   161         fcomp
;   162         fnstsw ax
;   163 --DEV Agner sez (look this up!) test ax,0x40 jz StoreFlt64 (nb test inverted)
;   164 --  sahf
;   165 --  ja e34pfu           -- power function underflow
;   166         test ah,0x41
;   167         jz :e34pfu          -- power function underflow
;   168         mov dword[esp+4],0x7FEFFFFF
;   169 --  fld qword[maxatm]
;   170         fld qword[esp]  -- maxatm
;   171         add esp,8
;   172         fcomp
;   173         fnstsw ax
;   174 --DEV Agner sez (look this up!) test ax,0x40 jz StoreFlt64 (nb test inverted)
;   175 --  sahf
;   176 --  jae StoreFlt
;   177         test ah,0x01
;   178         jz :%pStoreFlt
;   179         jmp :e35pfo         -- power function overflow
;   180 --  mov [sferr],1
;   181 -- @@:
;   182 
;   183 --  jmp StoreFlt
;   184 
;   185       ::opPowP2neg
;   186         fabs                -- p2 = |p2|, in this case same as *-1
;   187         fld st1             -- duplicate p3
;   188         frndint             -- DEV SLOW!
;   189         fcom st2
;   190         fnstsw ax
;   191         sahf
;   192         jne :e54atrnntnip   -- attempt to raise negative number to non-integer power
;   193         sub esp,4
;   194         fistp dword[esp]
;   195         pop eax
;   196         shr eax,1
;   197         jnc :opPowP3even
;   198         fyl2x               -- st1*=log2(st0); pop st0. st0 must be >0 ; ie log2(p2)*p3
;   199         fld st0             -- duplicate st0
;   200         frndint             -- round it to an integer   ; DEV SLOW!
;   201         fsub st1,st0        -- leave only fractional portion in st1
;   202         fxch st1            -- st1=int(p2*log2(p3)); st0=p2*log2(p3)-st1
;   203         f2xm1               -- get the fractional power of 2 (minus 1). st0 = 2^^st0-1 st0 must be in the range -1.0 to +1.0
;   204         fld1
;   205         faddp               -- get rid of that minus 1
;   206         fscale              -- multiply by 2^int(p2*log2(p3)) ; similar to shl 2 being same as mul 4
;   207         fchs                -- change sign!
;   208         jmp :opPowCont       
;   209     [64]
;   210         --calling convention:
;   211         --  lea rdi,[p1]        -- target
;   212         --  mov rcx,[p3]        -- ref p3 (opUnassigned)
;   213         --  mov rax,[p2]        -- ref p2 (opUnassigned)
;   214         --  call :%opPow        -- [rdi] := power(rax,rcx)
;   215         --    all registers trashed unless result is integer, left in rax
;   216 
;   217         mov r15,h4
                mov r15,h4                ;#0043B324: 49:277 0000000000000040    uv 8000 00  1  67      
;   218         -- handle power(2,0..61) as 1 shl cl. (29..61 untested!)
;   219         cmp rax,2
                cmp rax,2                 ;#0043B32E: 48:203370 02               vu 00 01  1  67      
;   220         jne :notPow2
                jne #0043B35B             ;#0043B332: 165 27                     v  00 00  1  68      
;   221         cmp rcx,61
                cmp rcx,61                ;#0043B334: 48:203371 3D               uv 00 02  1  69      
;   222         ja :notPow2
                ja #0043B35B              ;#0043B338: 167 21                     v  00 00  1  69      
;   223         mov rax,1
                mov rax,1                 ;#0043B33A: 48:307300 01000000         uv 01 00  1  70      
;   224         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043B341: 48:213027                  vu 04 80  1  70      
;   225         shl rax,cl
                shl eax,cl                ;#0043B344: 323340                     np 01 03  4  71      
;   226       ::opPowRet
;   227         cmp rdx,r15
                cmp rdx,r15               ;#0043B346: 49:073327                  uv 00 8004  1  75      
;   228         mov [rdi],rax
                mov [rdi],rax             ;#0043B349: 48:211007                  vu 00 81  1  75      
;   229         jle @f
                jle #0043B35A             ;#0043B34C: 176 0C                     v  00 00  1  76      
;   230             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043B34E: 48:203154223 F0 01         u  00 0C  3  77      
;   231             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043B354: 017204 806F0000            v  00 00  1  79      
;   232       @@:
;   233         ret
                ret                       ;#0043B35A: 303                        np 00 00  2  80      
;   234 
;   235       ::notPow2
;   236 
;   237         -- handle power(x,0) as 1, except for power(0,0) and power(<seq>,0) which are errors
;   238         test rcx,rcx
                test rcx,rcx              ;#0043B35B: 48:205311                  uv 00 02  1  82      
;   239         jnz :notPow0
                jnz #0043B37D             ;#0043B35E: 165 1D                     v  00 00  1  82      
;   240         test rax,rax
                test rax,rax              ;#0043B360: 48:205300                  uv 00 01  1  83      
;   241         jz :e102cr0tple0
                jz #0043B31F              ;#0043B363: 164 BA                     v  00 00  1  83      
;   242         cmp rax,r15
                cmp rax,r15               ;#0043B365: 49:073307                  uv 00 8001  1  84      
;   243         jl @f
                jl #0043B371              ;#0043B368: 174 07                     v  00 00  1  84      
;   244             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043B36A: 200174203 FF 12            u  00 09  2  85      
;   245             jne :e1413sopa
                    jne #0043B320         ;#0043B36F: 165 AF                     v  00 00  1  86      
;   246       @@:
;   247         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043B371: 48:213027                  uv 04 80  1  87      
;   248         mov rax,1
                mov rax,1                 ;#0043B374: 48:307300 01000000         vu 01 00  1  87      
;   249         jmp :opPowRet
                jmp #0043B346             ;#0043B37B: 353 C9                     v  00 00  1  88      
;   250     
;   251       ::notPow0
;   252 
;   253 --DEV new valid int range not yet done...
;   254         -- power(-177..177,1..4) can be done using mul to give an integer result...
;   255         cmp rcx,4
                cmp rcx,4                 ;#0043B37D: 48:203371 04               uv 00 02  1  89      
;   256         ja :notIntRes
                ja #0043B3AF              ;#0043B381: 167 2C                     v  00 00  1  89      
;   257         cmp rax,-177
                cmp rax,-177              ;#0043B383: 48:201370 4FFFFFFF         uv 00 01  1  90      
;   258         jl :notIntRes
                jl #0043B3AF              ;#0043B38A: 174 23                     v  00 00  1  90      
;   259         cmp rax,177
                cmp rax,177               ;#0043B38C: 48:201370 B1000000         uv 00 01  1  91      
;   260         jg :notIntRes
                jg #0043B3AF              ;#0043B393: 177 1A                     v  00 00  1  91      
;   261         mov rsi,rax
                mov rsi,rax               ;#0043B395: 48:213360                  uv 40 01  1  92      
;   262         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043B398: 48:213027                  vu 04 80  1  92      
;   263         sub rcx,1
                sub rcx,1                 ;#0043B39B: 48:203351 01               uv 02 02  1  93      
;   264         jz :opPowRet
                jz #0043B346              ;#0043B39F: 164 A5                     v  00 00  1  93      
;   265       ::IntPowMulLoop
;   266         imul rsi
                imul rsi                  ;#0043B3A1: 48:367356                  np 05 41 10  94      
;   267         sub rcx,1
                sub rcx,1                 ;#0043B3A4: 48:203351 01               uv 02 02  1 104      
;   268         jnz IntPowMulLoop
                jnz #0043B3A1             ;#0043B3A8: 165 F7                     v  00 00  1 104      
;   269         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043B3AA: 48:213027                  uv 04 80  1 105      
;   270         jmp :opPowRet
                jmp #0043B346             ;#0043B3AD: 353 97                     v  00 00  1 105      
;   271 
;   272       ::notIntRes
;   273         cmp rcx,r15
                cmp rcx,r15               ;#0043B3AF: 49:073317                  uv 00 8002  1 106      
;   274         jge :opPowp3Flt
                jge #0043B3BF             ;#0043B3B2: 175 0B                     v  00 00  1 106      
;   275             push rcx
                    push rcx              ;#0043B3B4: 48:121                     uv 00 02  1 107      
;   276             fild qword[rsp]
                    fild qword[rsp]       ;#0043B3B6: 337054044                  np 00 10  3 108      
;   277             add rsp,8
                    add rsp,8             ;#0043B3B9: 48:203304 08               uv 10 10  1 111      
;   278             jmp @f
                    jmp #0043B3CD         ;#0043B3BD: 353 0E                     v  00 00  1 111      
;   279       ::opPowp3Flt
;   280             cmp byte[rbx+rcx*4-1],0x12
                    cmp byte[rbx+rcx*4-1],#12  ;#0043B3BF: 200174213 FF 12            u  00 0A  2 112      
;   281             jne :e1413sopa
                    jne #0043B320         ;#0043B3C4: 017205 56FFFFFF            v  00 00  1 113      
;   282             fld tbyte[rbx+rcx*4]
                    fld tbyte[rbx+rcx*4]  ;#0043B3CA: 333054213                  np 00 0A  3 114      
;   283       @@:
;   284         cmp rax,r15
                cmp rax,r15               ;#0043B3CD: 49:073307                  uv 00 8001  1 117      
;   285         jge :opPowp2Flt
                jge #0043B3DD             ;#0043B3D0: 175 0B                     v  00 00  1 117      
;   286             push rax
                    push rax              ;#0043B3D2: 48:120                     uv 00 01  1 118      
;   287             fild qword[rsp]
                    fild qword[rsp]       ;#0043B3D4: 337054044                  np 00 10  3 119      
;   288             add rsp,8
                    add rsp,8             ;#0043B3D7: 48:203304 08               uv 10 10  1 122      
;   289             jmp @f
                    jmp #0043B3EB         ;#0043B3DB: 353 0E                     v  00 00  1 122      
;   290       ::opPowp2Flt
;   291             cmp byte[rbx+rax*4-1],0x12
                    cmp byte[rbx+rax*4-1],#12  ;#0043B3DD: 200174203 FF 12            u  00 09  2 123      
;   292             jne :e1413sopa
                    jne #0043B320         ;#0043B3E2: 017205 38FFFFFF            v  00 00  1 124      
;   293             fld tbyte[rbx+rax*4]
                    fld tbyte[rbx+rax*4]  ;#0043B3E8: 333054203                  np 00 09  3 125      
;   294       @@:
;   295 
;   296 --    ::opPowNN
;   297         fldz
                fldz                      ;#0043B3EB: 331356                     np 00 00  2 128      
;   298         fcomp
                fcomp                     ;#0043B3ED: 330331                     np 00 00  1 130      
;   299         fnstsw ax
                fnstsw ax                 ;#0043B3EF: 337340                     np 01 00  6 131      
;   300 --DEV  test ah,0x41 jz (C=0 and Z=0 for ja), not sure any help since wd need test ah,0x40 next...
;   301         sahf
                sahf                      ;#0043B3F1: 236                        np 00 01  2 137      
;   302         ja :opPowP2neg      -- jump if 0 > (above) p2
                ja #0043B469              ;#0043B3F2: 167 75                     v  00 00  1 139      
;   303         fxch
                fxch                      ;#0043B3F4: 331311                     np 00 00  1 140      
;   304         jne @f              -- if p2=0 then:
                jne #0043B40A             ;#0043B3F6: 165 12                     v  00 00  1 141      
;   305             fldz
                    fldz                  ;#0043B3F8: 331356                     np 00 00  2 142      
;   306             fcompp
                    fcompp                ;#0043B3FA: 336331                     np 00 00  1 144      
;   307             fnstsw ax
                    fnstsw ax             ;#0043B3FC: 337340                     np 01 00  6 145      
;   308 --DEV test ah,0x01/jnz (C=1 for jb)
;   309             sahf
                    sahf                  ;#0043B3FE: 236                        np 00 01  2 151      
;   310             jb :%pStoreFlt
                    jb #004421B0 (:%pStoreFlt)  ;#0043B3FF: 017202 AB6D0000            v  00 00  1 153      
;   311             jmp :e102cr0tple0   -- cannot raise 0 to power<=0
                    jmp #0043B31F         ;#0043B405: 351 15FFFFFF               v  00 00  1 154      
;   312       @@:
;   313         fxch
                fxch                      ;#0043B40A: 331311                     np 00 00  1 155      
;   314       ::opPowP3even
;   315         fyl2x               -- st1*=log2(st0); pop st0. st0 must be >0 ; ie log2(p2)*p3
                fyl2x                     ;#0043B40C: 331361                     np 00 00 103 156      
;   316         fld st0             -- duplicate st0
                fld st0                   ;#0043B40E: 331300                     np 00 00  1 259      
;   317         frndint             -- round it to an integer   ;DEV SLOW!
                frndint                   ;#0043B410: 331374                     np 00 00 20 260      
;   318         fsub st1,st0        -- leave only fractional portion in st1
                fsub st1,st0              ;#0043B412: 334351                     np 00 00  3 280      
;   319         fxch st1            -- st1=int(p2*log2(p3)); st0=p2*log2(p3)-st1
                fxch                      ;#0043B414: 331311                     np 00 00  1 283      
;   320         f2xm1               -- get the fractional power of 2 (minus 1). st0 = 2^^st0-1 st0 must be in the range -1.0 to +1.0
                f2xm1                     ;#0043B416: 331360                     np 00 00 57 284      
;   321         fld1
                fld1                      ;#0043B418: 331350                     np 00 00  2 341      
;   322         faddp               -- get rid of that minus 1
                faddp st1,st0             ;#0043B41A: 336301                     np 00 00  3 343      
;   323         fscale              -- multiply by 2^int(p2*log2(p3)) ; similar to shl 2 being same as mul 4
                fscale                    ;#0043B41C: 331375                     np 00 00 32 346      
;   324 
;   325       ::opPowCont
;   326         fxch
                fxch                      ;#0043B41E: 331311                     np 00 00  1 378      
;   327         fstp st0            -- discard junk
                fstp st0                  ;#0043B420: 335330                     np 00 00  1 379      
;   328         -- check for under/overflow:
;   329 --DEV test this!
;   330         mov rax,0x0000FFFE
                mov rax,65534             ;#0043B422: 48:307300 FEFF0000         uv 01 00  1 380      
;   331         mov rcx,-1
                mov rcx,-1                ;#0043B429: 48:307301 FFFFFFFF         vu 02 00  1 380      
;   332         push rax
                push rax                  ;#0043B430: 48:120                     uv 00 01  1 381      
;   333         push rcx
                push rcx                  ;#0043B432: 48:121                     vu 00 02  1 381      
;   334         fld tbyte[rsp]  -- minatm 
                fld tbyte[rsp]            ;#0043B434: 333054044                  np 00 10  3 382      
;   335         fcomp
                fcomp                     ;#0043B437: 330331                     np 00 00  1 385      
;   336         fnstsw ax
                fnstsw ax                 ;#0043B439: 337340                     np 01 00  6 386      
;   337 --DEV Agner sez (look this up!) test ax,0x40 jz StoreFlt64 (nb test inverted)
;   338 --  sahf
;   339 --  ja e34pfu           -- power function underflow
;   340         test ah,0x41
                test ah,65                ;#0043B43B: 366304 41                  uv 00 01  1 392      
;   341         jz :e34pfu          -- power function underflow
                jz #0043B321              ;#0043B43E: 017204 DDFEFFFF            v  00 00  1 392      
;   342         mov rax,0x00007FFE
                mov rax,32766             ;#0043B444: 48:307300 FE7F0000         uv 01 00  1 393      
;   343         mov [rsp+8],rax
                mov [rsp+8],rax           ;#0043B44B: 48:211104044 08            uv 00 11  1 394 01   
;   344         fld tbyte[rsp]  -- maxatm
                fld tbyte[rsp]            ;#0043B450: 333054044                  np 00 10  3 395      
;   345         add rsp,16
                add rsp,16                ;#0043B453: 48:203304 10               uv 10 10  1 398      
;   346         fcomp
                fcomp                     ;#0043B457: 330331                     np 00 00  1 399      
;   347         fnstsw ax
                fnstsw ax                 ;#0043B459: 337340                     np 01 00  6 400      
;   348 --DEV Agner sez (look this up!) test ax,0x40 jz StoreFlt64 (nb test inverted)
;   349 --  sahf
;   350 --  jae StoreFlt
;   351         test ah,0x01
                test ah,1                 ;#0043B45B: 366304 01                  uv 00 01  1 406      
;   352         jz :%pStoreFlt
                jz #004421B0 (:%pStoreFlt)  ;#0043B45E: 017204 4C6D0000            v  00 00  1 406      
;   353         jmp :e35pfo         -- power function overflow
                jmp #0043B322             ;#0043B464: 351 B9FEFFFF               v  00 00  1 407      
;   354 --  mov [sferr],1
;   355 -- @@:
;   356 
;   357 --  jmp StoreFlt
;   358 
;   359       ::opPowP2neg
;   360         fabs                -- p2 = |p2|, in this case same as *-1
                fabs                      ;#0043B469: 331341                     np 00 00  1 408      
;   361         fld st1             -- duplicate p3
                fld st1                   ;#0043B46B: 331301                     np 00 00  1 409      
;   362         frndint             -- DEV SLOW!
                frndint                   ;#0043B46D: 331374                     np 00 00 20 410      
;   363         fcom st2
                fcom st2                  ;#0043B46F: 330322                     np 00 00  1 430      
;   364         fnstsw ax
                fnstsw ax                 ;#0043B471: 337340                     np 01 00  6 431      
;   365         sahf
                sahf                      ;#0043B473: 236                        np 00 01  2 437      
;   366         jne :e54atrnntnip   -- attempt to raise negative number to non-integer power
                jne #0043B323             ;#0043B474: 017205 A9FEFFFF            v  00 00  1 439      
;   367         sub rsp,8
                sub rsp,8                 ;#0043B47A: 48:203354 08               uv 10 10  1 440      
;   368         fistp qword[rsp]
                fistp qword[rsp]          ;#0043B47E: 337074044                  np 00 10  6 443    *10*
;   369         pop rax
                pop rax                   ;#0043B481: 48:130                     uv 01 00  1 449      
;   370         shr rax,1
                shr rax,1                 ;#0043B483: 48:321350                  u  01 01  1 450      
;   371         jnc :opPowP3even
                jnc #0043B40C             ;#0043B486: 163 84                     v  00 00  1 450      
;   372         fyl2x               -- st1*=log2(st0); pop st0. st0 must be >0 ; ie log2(p2)*p3
                fyl2x                     ;#0043B488: 331361                     np 00 00 103 451      
;   373         fld st0             -- duplicate st0
                fld st0                   ;#0043B48A: 331300                     np 00 00  1 554      
;   374         frndint             -- round it to an integer   ; DEV SLOW!
                frndint                   ;#0043B48C: 331374                     np 00 00 20 555      
;   375         fsub st1,st0        -- leave only fractional portion in st1
                fsub st1,st0              ;#0043B48E: 334351                     np 00 00  3 575      
;   376         fxch st1            -- st1=int(p2*log2(p3)); st0=p2*log2(p3)-st1
                fxch                      ;#0043B490: 331311                     np 00 00  1 578      
;   377         f2xm1               -- get the fractional power of 2 (minus 1). st0 = 2^^st0-1 st0 must be in the range -1.0 to +1.0
                f2xm1                     ;#0043B492: 331360                     np 00 00 57 579      
;   378         fld1
                fld1                      ;#0043B494: 331350                     np 00 00  2 636      
;   379         faddp               -- get rid of that minus 1
                faddp st1,st0             ;#0043B496: 336301                     np 00 00  3 638      
;   380         fscale              -- multiply by 2^int(p2*log2(p3)) ; similar to shl 2 being same as mul 4
                fscale                    ;#0043B498: 331375                     np 00 00 32 641      
;   381         fchs                -- change sign!
                fchs                      ;#0043B49A: 331340                     np 00 00  1 673      
;   382         jmp :opPowCont       
                jmp #0043B41E             ;#0043B49C: 353 80                     v  00 00  1 674      
;   383     []
;   384       }
;   385 
    jmp #0044298D (:%opRetf)              ;#0043B49E: 351 EA740000               v  00 00  1 675      
;C:\Program Files (x86)\Phix\builtins\VM\pJnotx.e:
;=================================================
;     1 --
;     2 -- pJnotx.e
;     3 -- ========
;     4 --
;     5 --  implements :%opJnotx (if [not] s[idx] then)
;     6 --
;     7 
;     8 include builtins\VM\pFPU.e  -- :%down53 etc
;     9 
;    10 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043B265: 351 23770000               v  00 00  1   1      
;    11 
;    12 --DEV FIXME: (and the :!bang labels below)
;    13 --  ::e94vhnbaavecx
;    14 --      int3
;    15     ::e04atssaa -- attempt to subscript an atom
;    16 --DEV [64]
;    17         pop edx
                pop rdx                   ;#0043B26A: 132                        uv 04 00  1   2      
;    18         mov al,4
                mov al,4                  ;#0043B26B: 260 04                     vu 01 00  1   2      
;    19         sub edx,1
                sub edx,1                 ;#0043B26D: 203352 01                  uv 04 04  1   3      
;    20         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#0043B270: 351 F17B0000               v  00 00  1   3      
;    21         int3
                int3                      ;#0043B275: 314                        np 00 00 13   4      
;    22     :!e106ioobr
;    23         int3
                int3                      ;#0043B276: 314                        np 00 00 13  17      
;    24     ::e05sinaa0e10
;    25         pop edx
                pop rdx                   ;#0043B277: 132                        uv 04 00  1  30      
;    26         mov al,5
                mov al,5                  ;#0043B278: 260 05                     vu 01 00  1  30      
;    27         sub edx,1
                sub edx,1                 ;#0043B27A: 203352 01                  uv 04 04  1  31      
;    28         jmp :!iDiag
                jmp #00442E66 (:!iDiag)   ;#0043B27D: 351 E47B0000               v  00 00  1  31      
;    29         int3
                int3                      ;#0043B282: 314                        np 00 00 13  32      
;    30     ::e106ioobrp1
;    31         int3
                int3                      ;#0043B283: 314                        np 00 00 13  45      
;    32     ::e03tfcmbaa
;    33         int3
                int3                      ;#0043B284: 314                        np 00 00 13  58      
;    34 
;    35 --/*
;    36 procedure :%opJnotx(:%)
;    37 end procedure -- (for Edita/CtrlQ)
;    38 --*/
;    39     :%opJnotx       -- <flags> = test p2[p3]
;    40 -------------
;    41     [32]
;    42         --calling convention:
;    43         --  mov edi,[p3]        -- idx
;    44         --  mov esi,[p2]        -- s
;    45         --  mov ecx,p3          -- var no of idx
;    46         --  mov edx,p2          -- var no of s
;    47         --  call opJnotx
;    48         --eax=p2[p3], ebx=0, edx=length(p2), edi=normalised idx, esi=raw(p2)
;    49         --  jz xxx              -- jnz for opJifx
;    50         add edi,-1
;    51         xor eax,eax
;    52       :!opJnotxe92a             -- exception here mapped to e94vhnbaavedx
;    53         mov al,[ebx+esi*4-1]    -- type byte
;    54         mov edx,[ebx+esi*4-12]  -- length
;    55         test al,0x80
;    56         jz :e04atssaa
;    57         cmp edi,edx
;    58         jb @f                   -- unsigned jump, lets 0..len-1 through
;    59 --DEV use pFixup.e... (it was like this in p.asm too)
;    60             add edi,1           -- (there was an add edi,-1 above)
;    61             jl :opJnotxNegativeIdx
;    62             -- but it might be a float:
;    63 --          cmp edi,h4
;    64 --          jl :e106ioobr           -- index out of bounds
;    65 ----        opJnotxe92b:                    -- exception here mapped to e94vhnbaavecxfeh
;    66 --          cmp edi,h4
;    67 --          je :e94vhnbaavecx
;    68 --DEV :%pLoadMint
;    69         :!opJnotxe92b                   -- exception here mapped to e94vhnbaavecxfeh
;    70             cmp byte[ebx+edi*4-1],0x12
;    71             jne :e05sinaa0e10           -- subscript is not an atom [era @ [esp]]
;    72             fld qword[ebx+edi*4]
;    73             call :%down53
;    74             sub esp,8
;    75             fistp qword[esp]
;    76             call :%near53
;    77             mov edi,[esp]
;    78             add esp,8
;    79             cmp edi,0
;    80             jge :opJnotxNotNegative
;    81           ::opJnotxNegativeIdx
;    82                 add edi,edx
;    83                 cmp edi,edx
;    84                 jb @f
;    85                     sub edi,edx
;    86                     jmp :!e106ioobr
;    87           ::opJnotxNotNegative
;    88             sub edi,1
;    89             cmp edi,edx
;    90             jae :e106ioobrp1      -- > length or still <=0
;    91       @@:
;    92         shl esi,2
;    93         cmp al,0x82
;    94         je :jnotxStr
;    95             mov eax,[esi+edi*4]
;    96             cmp eax,h4
;    97             jl :jnotxend
;    98             cmp byte[ebx+eax*4-1],0x12  -- (assumes floats are never 0.0)
;    99             je :jnotxend
;   100             jmp :e03tfcmbaa         -- true/false condition must be an ATOM [DEV untested]
;   101 
;   102       ::jnotxStr
;   103             mov al,[esi+edi]
;   104       ::jnotxend
;   105         test eax,eax
;   106         ret
;   107     [64]
;   108         --calling convention:
;   109         --  mov rdi,[p3]        -- idx
;   110         --  mov rsi,[p2]        -- s
;   111         --  mov rcx,p3          -- var no of idx
;   112         --  mov rdx,p2          -- var no of s
;   113         --  call opJnotx
;   114         --rax=p2[p3], rbx=0, rdx=length(p2), rdi=normalised idx, rsi=raw(p2)
;   115         --  jz xxx              -- jnz for opJifx
;   116         add rdi,-1
                add rdi,-1                ;#0043B285: 48:203307 FF               uv 80 80  1  71      
;   117         mov r15,h4
                mov r15,h4                ;#0043B289: 49:277 0000000000000040    vu 8000 00  1  71      
;   118         xor rax,rax
                xor rax,rax               ;#0043B293: 48:061300                  uv 01 01  1  72      
;   119       :!opJnotxe92a             -- exception here mapped to e94vhnbaavedx
;   120         mov al,[rbx+rsi*4-1]    -- type byte
                mov al,[rbx+rsi*4-1]      ;#0043B296: 212104263 FF               uv 01 48  1  73 01   
;   121         mov rdx,[rbx+rsi*4-24]  -- length
                mov rdx,[rbx+rsi*4-24]    ;#0043B29A: 48:213124263 E8            vu 04 48  1  73      
;   122         test al,0x80
                test al,#80               ;#0043B29F: 250 80                     uv 00 01  1  74      
;   123         jz :e04atssaa
                jz #0043B26A              ;#0043B2A1: 164 C7                     v  00 00  1  74      
;   124         cmp rdi,rdx
                cmp rdi,rdx               ;#0043B2A3: 48:071327                  uv 00 84  1  75      
;   125         jb @f                   -- unsigned jump, lets 0..len-1 through
                jb #0043B2F0              ;#0043B2A6: 162 48                     v  00 00  1  75      
;   126             add rdi,1           -- (there was an add rdi,-1 above)
                    add rdi,1             ;#0043B2A8: 48:203307 01               uv 80 80  1  76      
;   127             jl :opJnotxNegativeIdx
                    jl #0043B2D7          ;#0043B2AC: 174 29                     v  00 00  1  76      
;   128             -- but it might be a float:
;   129 --          cmp rdi,r15
;   130 --          jl :e106ioobr           -- index out of bounds
;   131 ----        opJnotxe92b:                    -- exception here mapped to e94vhnbaavecxfeh [DEV merge these!]
;   132 --          cmp rdi,r15
;   133 --          je :e94vhnbaavecx
;   134         :!opJnotxe92b                   -- exception here mapped to e94vhnbaavecxfeh
;   135             cmp byte[rbx+rdi*4-1],0x12
                    cmp byte[rbx+rdi*4-1],#12  ;#0043B2AE: 200174273 FF 12            u  00 88  2  79    *80*
;   136             jne :e05sinaa0e10           -- subscript is not an atom [era @ [esp]]
                    jne #0043B277         ;#0043B2B3: 165 C2                     v  00 00  1  80      
;   137             fld tbyte[rbx+rdi*4]
                    fld tbyte[rbx+rdi*4]  ;#0043B2B5: 333054273                  np 00 88  3  81      
;   138 --DEV down64? (spotted in passing)
;   139             call :%down53
                    call #00441389 (:%down53)  ;#0043B2B8: 350 CC600000               v  00 00  1  84      
;   140             sub rsp,8
                    sub rsp,8             ;#0043B2BD: 48:203354 08               uv 10 10  1  85      
;   141             fistp qword[rsp]
                    fistp qword[rsp]      ;#0043B2C1: 337074044                  np 00 10  6  88    *10*
;   142             call :%near64
                    call #004413A5 (:%near64)  ;#0043B2C4: 350 DC600000               v  00 00  1  94      
;   143             mov rdi,[rsp]
                    mov rdi,[rsp]         ;#0043B2C9: 48:213074044               uv 80 10  1  95      
;   144             add rsp,8
                    add rsp,8             ;#0043B2CD: 48:203304 08               vu 10 10  1  95      
;   145             cmp rdi,0
                    cmp rdi,0             ;#0043B2D1: 48:203377 00               uv 00 80  1  96      
;   146             jge :opJnotxNotNegative
                    jge #0043B2E7         ;#0043B2D5: 175 10                     v  00 00  1  96      
;   147           ::opJnotxNegativeIdx
;   148                 add rdi,rdx
                        add rdi,rdx       ;#0043B2D7: 48:001327                  uv 80 84  1  97      
;   149                 cmp rdi,rdx
                        cmp rdi,rdx       ;#0043B2DA: 48:071327                  uv 00 84  1  98 80   
;   150                 jb @f
                        jb #0043B2F0      ;#0043B2DD: 162 11                     v  00 00  1  98      
;   151                     sub rdi,rdx
                            sub rdi,rdx   ;#0043B2DF: 48:051327                  uv 80 84  1  99      
;   152                     jmp :!e106ioobr
                            jmp #0043B276 (:!e106ioobr)  ;#0043B2E2: 351 8FFFFFFF               v  00 00  1  99      
;   153           ::opJnotxNotNegative
;   154             sub rdi,1
                    sub rdi,1             ;#0043B2E7: 48:203357 01               uv 80 80  1 100      
;   155             cmp rdi,rdx
                    cmp rdi,rdx           ;#0043B2EB: 48:071327                  uv 00 84  1 101 80   
;   156             jae :e106ioobrp1      -- > length or still <=0
                    jae #0043B283         ;#0043B2EE: 163 93                     v  00 00  1 101      
;   157       @@:
;   158         shl rsi,2
                shl rsi,2                 ;#0043B2F0: 48:301346 02               u  40 40  1 102      
;   159         cmp al,0x82
                cmp al,#82                ;#0043B2F4: 200370 82                  vu 00 01  1 102      
;   160         je :jnotxStr
                je #0043B30E              ;#0043B2F7: 164 15                     v  00 00  1 103      
;   161 --          mov rax,[rsi+rdi*4]
;   162             mov rax,[rsi+rdi*8]
                    mov rax,[rsi+rdi*8]   ;#0043B2F9: 48:213004376               uv 01 C0  1 104      
;   163             cmp rax,r15
                    cmp rax,r15           ;#0043B2FD: 49:073307                  uv 00 8001  1 105 01   
;   164             jl :jnotxend
                    jl #0043B311          ;#0043B300: 174 0F                     v  00 00  1 105      
;   165             cmp byte[rbx+rax*4-1],0x12  -- (assumes floats are never 0.0)
                    cmp byte[rbx+rax*4-1],#12  ;#0043B302: 200174203 FF 12            u  00 09  2 106      
;   166             je :jnotxend
                    je #0043B311          ;#0043B307: 164 08                     v  00 00  1 107      
;   167             jmp :e03tfcmbaa         -- true/false condition must be an ATOM [DEV untested]
                    jmp #0043B284         ;#0043B309: 351 76FFFFFF               v  00 00  1 108      
;   168 
;   169       ::jnotxStr
;   170             mov al,[rsi+rdi]
                    mov al,[rsi+rdi]      ;#0043B30E: 212004076                  uv 01 C0  1 109      
;   171       ::jnotxend
;   172         test rax,rax
                test rax,rax              ;#0043B311: 48:205300                  uv 00 01  1 110 01   
;   173         ret
                ret                       ;#0043B314: 303                        np 00 00  2 111      
;   174     []
;   175       }
    jmp #0044298D (:%opRetf)              ;#0043B315: 351 73760000               v  00 00  1 113      
;C:\Program Files (x86)\Phix\builtins\VM\pRepeatN.e:
;===================================================
;     1 --
;     2 -- pRepeatN.e
;     3 -- ==========
;     4 --
;     5 --without debug
;     6 include builtins\VM\pHeap.e     -- :%pAllocStr, :%pAllocSeq
;     7 -- include VM\pDiag.e   -- :%e52rcmbnni
;     8 
;     9 --global function repeat(object o, integer count, integer type=0)
;    10 --  type=0: decide based on (integer(o) && 7<=o<=255)
;    11 --  type=8/string: error if o is not integer or <0 or >255; create a string
;    12 --  type=12/sequence: create a dword-sequence (do not test the value of o)
;    13 --  Note that the standard builtin type names of string and sequence can 
;    14 --       (specially) be used for p3 of repeat(), eg:
;    15 --          s = repeat(ch,len,string)
;    16 --          q = repeat(x,len,sequence)
;    17 --       but if you want a variable/parameter to call repeat with, you will 
;    18 --       have to define your own constants (with the values 0, 8, and/or 12).
;    19 --
;    20 --  if type=0 then
;    21 --      type = (integer(o) and o>=7 and o<=255) -- 1:create string, 0:create dword-sequence
;    22 --  elsif type=8 then -- string
;    23 --      if not integer(o) or o<0 or o>255 then fatal("repeat element not character")
;    24 --      type = 1
;    25 --  else
;    26 --      if type!=12 then fatal("repeat type must be any/string/sequence(0/8/12)")
;    27 --      type = 0
;    28 --  end if
;    29 --  if type then
;    30 
;    31 --OR
;    32 
;    33 --  global function repeatch(integer ch, integer type)
;    34 --  -- returns a string. Note the compiler automatically maps eg repeat('=',80) to
;    35 --  --  repeatch('=',80), and consequently improves type inference. It will also
;    36 --  --  map repeat('\0',80) to repeatch (ie using toktype=SQUOTE). Obviously
;    37 --  --  without appropriate clues, the dseq/str decision is made at run-time.
;    38 
;    39 
;    40 --/*
;    41 global function repeat(object o, integer count)
;    42 sequence res
;    43     if count<0 then ?9/0 end if --DEV runtime error
;    44 --  if count<0 then fatal("repeat count must not be negative") end if
;    45 --  if count<0 then #ilASM{ jmp :%e52rcmbnni } end if
;    46 --  #ilASM{ cmp [count],0
;    47 --          jl :!e52rcmbnni }   -- (if -nodiag, jl 0 == next instruction, which is obviously
;    48 --                              --  going to crash and burn on error, but you did say -nodiag)
;    49     if integer(o) and o>=7 and o<=255 then
;    50 --res = ""
;    51         -- create a string (one byte per character/raw binary)
;    52         #ilASM {
;    53             [32]
;    54                 mov ecx,[count]
;    55                 call :%pAllocStr
;    56                 mov [res],eax
;    57                 lea edi,[ebx+eax*4]
;    58                 mov ecx,[count]
;    59                 mov eax,[o]
;    60                 rep stosb
;    61             [64]
;    62                 mov rcx,[count]
;    63                 call :%pAllocStr
;    64                 mov [res],rax
;    65                 lea rdi,[rbx+rax*4]
;    66                 mov rcx,[count]
;    67                 mov rax,[o]
;    68                 rep stosb
;    69             []
;    70               }
;    71     else
;    72 --res = {}
;    73         -- create a d/qword-sequence
;    74         #ilASM {
;    75             [32]
;    76                 mov ecx,[count]
;    77                 call :%pAllocSeq
;    78                 mov [res],eax
;    79                 lea edi,[ebx+eax*4]
;    80                 mov eax,[o]
;    81                 mov ecx,[count]
;    82                 cmp eax,h4
;    83                 jl @f
;    84                     add dword[ebx+eax*4-8],ecx
;    85               @@:
;    86                 rep stosd
;    87             [64]
;    88                 mov rcx,[count]
;    89                 call :%pAllocSeq
;    90                 mov [res],rax
;    91                 lea rdi,[rbx+rax*4]
;    92                 mov rax,[o]
;    93                 mov rcx,[count]
;    94 --              cmp rax,h4
;    95                 mov r15,h4
;    96                 cmp rax,r15
;    97                 jl @f
;    98                     add qword[rbx+rax*4-16],rcx
;    99               @@:
;   100                 rep stosq
;   101             []
;   102               }
;   103     end if
;   104     return res
;   105 end function
;   106 --*/
;   107 
;   108 #ilASM{ jmp :%opRetf
                jmp #0044298D (:%opRetf)  ;#0043B1DC: 351 AC770000               v  00 00  1   1      
;   109 
;   110 --/*
;   111 procedure :%opRepeatCh(:%)
;   112 end procedure -- (for Edita/CtrlQ)
;   113 --*/
;   114     :%opRepCh
;   115 -------------
;   116         -- convention as below
;   117         -- only called when the compiler knows eax is a character, eg repeat('\0',n)
;   118         -- (maybe there could be a repeatch() builtin, but it would not check ch...)
;   119     [32]
;   120         cmp ecx,h4
;   121     [64]
;   122         mov r15,h4
                mov r15,h4                ;#0043B1E1: 49:277 0000000000000040    uv 8000 00  1   2      
;   123         cmp rcx,r15
                cmp rcx,r15               ;#0043B1EB: 49:073317                  uv 00 8002  1   3 8000   
;   124     []
;   125         jb :repeatCh
                jb #0043B216              ;#0043B1EE: 162 26                     v  00 00  1   3      
;   126 --DEV:
;   127      ::e52rcmbnni  -- repeat count must be non negative integer
;   128         mov al,52
                mov al,52                 ;#0043B1F0: 260 34                     uv 01 00  1   4      
;   129         int3
                int3                      ;#0043B1F2: 314                        np 00 00 13   5      
;   130 
;   131 --/*
;   132 procedure :%opRepeat(:%)
;   133 end procedure -- (for Edita/CtrlQ)
;   134 --*/
;   135     :%opRepeat
;   136 --------------
;   137     [32]
;   138         --calling convention:
;   139         --  lea edi,[p1]    -- dest
;   140         --  mov eax,[p2]    -- item to be repeated (opUnassigned)
;   141         --  mov ecx,[p3]    -- count (opUnassigned)
;   142         --  call :%opRepeat -- [edi]:=repeat(eax,ecx)
;   143         cmp ecx,h4
;   144         jae e52rcmbnni  -- repeat count must be non negative integer
;   145         cmp eax,h4
;   146         jg :repeatRef
;   147         cmp eax,255
;   148         ja :repeatSeq   -- (-ve and >255)
;   149         -- DEV: Ideally, repeat(0,count) should return a dword-sequence,
;   150         --      whereas repeat('\0',count) should return a string of nulls.
;   151         --      maybe we sould have :%pRepeatCh which rejoins here
;   152         cmp eax,7
;   153         jl :repeatSeq   -- (0..6)
;   154       ::repeatCh
;   155         push eax
;   156         call :%pAllocStr
;   157         mov edx,[edi]
;   158         mov [edi],eax
;   159         lea edi,[ebx+eax*4]
;   160         pop eax
;   161         rep stosb
;   162         mov [edi],bl
;   163 --29/7/15:
;   164 --      ret
;   165         jmp :repdealloc
;   166 
;   167       ::repeatRef
;   168         add dword[ebx+eax*4-8],ecx
;   169       ::repeatSeq
;   170         mov edx,[esp]       -- era
;   171         push eax
;   172         call :%pAllocSeq
;   173         mov edx,[edi]
;   174         mov [edi],eax
;   175         lea edi,[ebx+eax*4]
;   176         pop eax
;   177         rep stosd
;   178       ::repdealloc
;   179         cmp edx,h4
;   180         jle @f
;   181             sub dword[ebx+edx*4-8],1
;   182             jz :%pDealloc
;   183       @@:
;   184         ret
;   185     [64]
;   186         --calling convention:
;   187         --  lea rdi,[p1]    -- dest
;   188         --  mov rax,[p2]    -- item to be repeated (opUnassigned)
;   189         --  mov rcx,[p3]    -- count (opUnassigned)
;   190         --  call :%opRepeat -- [edi]:=repeat(eax,ecx)
;   191         mov r15,h4
                mov r15,h4                ;#0043B1F3: 49:277 0000000000000040    uv 8000 00  1  18      
;   192         cmp rcx,r15
                cmp rcx,r15               ;#0043B1FD: 49:073317                  uv 00 8002  1  19 8000   
;   193         jae e52rcmbnni  -- repeat count must be non negative integer
                jae #0043B1F0             ;#0043B200: 163 EE                     v  00 00  1  19      
;   194         cmp rax,r15
                cmp rax,r15               ;#0043B202: 49:073307                  uv 00 8001  1  20      
;   195         jg :repeatRef
                jg #0043B22F              ;#0043B205: 177 28                     v  00 00  1  20      
;   196         cmp rax,255
                cmp rax,255               ;#0043B207: 48:201370 FF000000         uv 00 01  1  21      
;   197         ja :repeatSeq   -- (-ve and >255)
                ja #0043B234              ;#0043B20E: 167 24                     v  00 00  1  21      
;   198         cmp rax,7
                cmp rax,7                 ;#0043B210: 48:203370 07               uv 00 01  1  22      
;   199         jl :repeatSeq   -- (0..6)
                jl #0043B234              ;#0043B214: 174 1E                     v  00 00  1  22      
;   200       ::repeatCh
;   201         push rax
                push rax                  ;#0043B216: 48:120                     uv 00 01  1  23      
;   202         call :%pAllocStr
                call #004420E3 (:%pAllocStr)  ;#0043B218: 350 C66E0000               v  00 00  1  23      
;   203         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043B21D: 48:213027                  uv 04 80  1  24      
;   204         mov [rdi],rax
                mov [rdi],rax             ;#0043B220: 48:211007                  vu 00 81  1  24      
;   205         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#0043B223: 48:215074203               uv 80 09  1  25      
;   206         pop rax
                pop rax                   ;#0043B227: 48:130                     vu 01 00  1  25      
;   207         rep stosb
                rep stosb                 ;#0043B229: 363:252                    np 82 83  3  28    *80*
;   208         mov [rdi],bl
                mov [edi],bl              ;#0043B22B: 210037                     uv 00 88  1  32    *80*
;   209 --29/7/15:
;   210 --      ret
;   211         jmp :repdealloc
                jmp #0043B24E             ;#0043B22D: 353 1F                     v  00 00  1  32      
;   212 
;   213       ::repeatRef
;   214         add qword[rbx+rax*4-16],rcx
                add [rbx+rax*4-16],rcx    ;#0043B22F: 48:001114203 F0            uv 00 0B  3  33      
;   215       ::repeatSeq
;   216         mov rdx,[rsp]       -- era
                mov rdx,[rsp]             ;#0043B234: 48:213024044               vu 04 10  1  35      
;   217         push rax
                push rax                  ;#0043B238: 48:120                     uv 00 01  1  36      
;   218         call :%pAllocSeq
                call #00442148 (:%pAllocSeq)  ;#0043B23A: 350 096F0000               v  00 00  1  36      
;   219         mov rdx,[rdi]
                mov rdx,[rdi]             ;#0043B23F: 48:213027                  uv 04 80  1  37      
;   220         mov [rdi],rax
                mov [rdi],rax             ;#0043B242: 48:211007                  vu 00 81  1  37      
;   221         lea rdi,[rbx+rax*4]
                lea rdi,[rbx+rax*4]       ;#0043B245: 48:215074203               uv 80 09  1  38      
;   222         pop rax
                pop rax                   ;#0043B249: 48:130                     vu 01 00  1  38      
;   223         rep stosq
                rep stosq                 ;#0043B24B: 363:48:253                 np 82 83  3  41    *80*
;   224 --29/7/15:
;   225       ::repdealloc
;   226         cmp rdx,r15
                cmp rdx,r15               ;#0043B24E: 49:073327                  uv 00 8004  1  44      
;   227         jle @f
                jle #0043B25F             ;#0043B251: 176 0C                     v  00 00  1  44      
;   228             sub qword[rbx+rdx*4-16],1
                    sub qword[rbx+rdx*4-16],1  ;#0043B253: 48:203154223 F0 01         u  00 0C  3  45      
;   229             jz :%pDealloc
                    jz #004422DA (:%pDealloc)  ;#0043B259: 017204 7B700000            v  00 00  1  47      
;   230       @@:
;   231         ret
                ret                       ;#0043B25F: 303                        np 00 00  2  48      
;   232     []
;   233       }
    jmp #0044298D (:%opRetf)              ;#0043B260: 351 28770000               v  00 00  1  50      
;C:\Program Files (x86)\Phix\builtins\VM\pcfuncN.e:
;==================================================
;     1 --
;     2 -- pcfuncN.e (Phix compatible 0.6.3)
;     3 --
;     4 --  Phix implementations of define_c_func, define_c_proc, define_c_var,
;     5 --                          call_back, c_func, and c_proc.
;     6 --
;     7 --  WARNING: Fragile code ahead! Mistakes in this code may completely
;     8 --           spanner diagnostics and tracing. You have been warned.
;     9 --           (If p -test, p edita, p test\terror, and p test\trace
;    10 --            all seem fine, then you can breathe easy once again.)
;    11 --
;    12 --/*
;    13     ?9/0    This file is incompatible with RDS/OpenEu.
;    14 --*/
;    15 --
;    16 --  In Phix, you need not "include dll.e" before using define_c_func, 
;    17 --  etc, nor do you actually need to "include pcfunc.e"; the compiler
;    18 --  is smart enough to find and load this file for you automagically.
;    19 --
;    20 --  Moved from dll.e for the benefit of pmach.e
;    21 --
;    22 --  In Phix and RDS Eu you can (if you want) still code eg:
;    23 --      include dll.e as dll
;    24 --      i1 = dll:define_c_func(a,s1,s2,i2)
;    25 --  (obviously you need an explicit include if you want a namespace)
;    26 --    (and "include dll.e" is recommended over "include pcfunc.e")
;    27 --
;    28 --  a) The Phix version of dll.e contains the line
;    29 --      "--/**/ include pcfunc.e	-- (Phix compatible)"
;    30 --      Obviously, RDS Eu ignores that line/treats it as a comment,
;    31 --      whereas Phix includes this file. Also, unlike RDS Eu, in
;    32 --      Phix namespaces apply equally to sub-includes.
;    33 --
;    34 --  b) RDS Eu will of course run the versions of the routines in
;    35 --      dll.e (inside "--/*" "--*/" pairs), whereas Phix will of 
;    36 --      course execute the ones below.
;    37 --
;    38 --  c) In Phix, calls to machine_func(M_DEFINE_C) are not supposed to
;    39 --      occur, however if an application includes an old version (say 
;    40 --      RDS Eu 2.4) of dll.e, then pmach.e maps it here. Now, if we
;    41 --      left this in dll.e, and pmach.e (naievely) mapped M_DEFINE_C
;    42 --      to dll:define_c_func(), it would result in an infinite loop. 
;    43 --      Hence I moved them, but kept it as compatible as possible.
;    44 --
;    45 --  d) The fixed constants from dll.e have been "moved" to psym.e, to
;    46 --      allow them to be used before dll.e has been "auto-included".
;    47 --
;    48 --
;    49 -- NOTE:
;    50 -- =====
;    51 --  This has been carefully engineered to match RDS Eu, whether that 
;    52 --  is for the best or not. For example:
;    53 --
;    54 --          function f(atom a)
;    55 --              ?a
;    56 --              return 1
;    57 --          end function
;    58 --          constant cb_f = call_back(routine_id("f")),
;    59 --                   cp_f = define_c_proc({},cb_f,{C_INT})
;    60 --          c_proc(cp_f,{-1})
;    61 --
;    62 --  Displays 4294967295 (=#FFFFFFFF), not -1. Commented out code 
;    63 --   exists below to change this behaviour, if needed.              [DEV did I change that?]
;    64 --  See also test/t42cback.exw for further notes.
;    65 --
;    66 --
;    67 -- WARNING: [DEV add this to the docs]
;    68 -- =======
;    69 --  Phix allows eg c_func(WriteConsole,{stdout,"hello\n",6,pBytes,0}) 
;    70 --  whereas in RDS/OpenEu you must allocate_string/free. However, a  
;    71 --  few C functions modify such strings/data directly, eg
;    72 --              c_func(ReadFile,{handle,strbuf,...})
;    73 --  and in that case */THE REFCOUNT OF STRBUF IS COMPLETELY IGNORED/*.
;    74 --
;    75 --  Obviously (legacy) code which performs allocate/c_func/peek/free 
;    76 --  does exactly what you might expect, but in eg:
;    77 --
;    78 --      sequence table, a, strbuf
;    79 --          table = {0}
;    80 --          a = repeat(' ',8192)
;    81 --          table[1] = a
;    82 --          ...
;    83 --          strbuf = table[1]
;    84 --          c_func(ReadFile,{handle,strbuf,...})
;    85 --
;    86 --  then strbuf, a, and table[1] are */ALL/* modified in the one hit.
;    87 --    (pfileio.e does that sort of thing quite deliberately, btw)
;    88 --
;    89 --  There is, in fact, no (sensible) way to change this behaviour, 
;    90 --  aside from forcing the use of allocate/free.
;    91 --
;    92 --  Also, wherever you can pass a string you can pass a dword-sequence
;    93 --  equivalent ("fred" vs {'f','r','e','d'}). Should you pass such a
;    94 --  buffer to ReadFile, then (see argstring below) c_func will quietly 
;    95 --  convert it to an 8-bit string, then (let the C code) modify that, 
;    96 --  before just completely discarding the modified 8-bit version.
;    97 --
;    98 --  Naturally this is all a warning for "new style" code and even then 
;    99 --  only for a very select few external C functions; to avoid any such
;   100 --  effects simply allocate and peek/free after the call, in the same 
;   101 --  way that legacy code would/had to.
;   102 --
;   103 
;   104 --!/**/without debug
;   105 --!/**/with debug
;   106 
;   107 include builtins\VM\pHeap.e     -- :%pStoreFlt etc
;   108 include builtins\VM\pStack.e    -- :%opFrame etc
;   109 --include builtins\VM\pDiagN.e  -- e02atdb0 (DEV/now in pUnassigned)
;   110 --include builtins\VM\pprntfN.e
;   111 --include platform.e
;   112 include builtins\VM\pUnassigned.e   -- :%pRTErn (DEV/temp)
;   113 
;   114 constant ASALPHANUM = 1,    --(specifically the chars we expect in a dll entry point; 1-9/A-Z/a-z/_)
;   115          ASANY = 0      --(ie assume any and all atoms are ok)
;   116                         --(all atoms are and'ed with #FF, in both cases, btw) 
;   117 
;   118 constant e16cbchop      = 16    -- call_backs cannot have optional parameters
;   119 constant e72iri         = 72    -- invalid routine_id
;   120 constant e73atodmbs     = 73    -- argument to open_dll must be string
;   121 constant e74dcfpe       = 74    -- define_c_func/proc parameter error
;   122 constant e75cbrpmaba    = 75    -- call back routine parameters must all be atoms
;   123 constant e81ipicfp      = 81    -- insufficient parameters in call_func/proc()
;   124 constant e84cbpmbropr   = 84    -- call_back parameter must be routine_id or {'+',routine_id}
;   125 constant e88atcfpmbaos  = 88    -- arguments to c_func/proc must be atoms or strings
;   126 constant e89tmpicfp     = 89    -- too many parameters in call_func/proc()
;   127 constant e117rdnrav     = 117   -- routine does not return a value
;   128 constant e118rrav       = 118   -- routine returns a value
;   129 
;   130 --DEV remove, as per pfileioN.e
;   131 --/*
;   132 procedure fatal(integer errcode, integer ep1=0)
;   133     #ilASM{
;   134         [32]
;   135             mov eax,[errcode]
;   136             mov edi,[ep1]
;   137             xor esi,esi     -- ep2 unused
;   138             call :%pRTErn   -- fatal error (see pdiagN.e)
;   139         [64]
;   140             mov rax,[errcode]
;   141             mov rdi,[ep1]
;   142             xor rsi,rsi     -- ep2 unused
;   143             call :%pRTErn   -- fatal error (see pdiagN.e)
;   144         []
;   145           }
;   146     ?9/0
;   147 end procedure
;   148 --*/
;   149 
;   150 -- new version, to replace the above...
;   151 procedure fatalN(integer level, integer errcode, integer ep1=0)
    mov rsi,[rbp-16] (ep1)                ;#0044A360: 48:213165 F0               uv 40 20  1   1      
    mov r15,h4                            ;#0044A364: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0044A36E: 4C:071376                  uv 00 8040  1   2      
    jne #0044A377                         ;#0044A371: 165 04                     v  00 00  1   2      
    mov [rbp-16] (ep1),rbx                ;#0044A373: 48:211135 F0               uv 00 28  1   3      
;   152 -- level is the number of frames to pop to obtain an era (must be >1).
;   153 -- we report errors on (eg) the c_func call, not in c_func below, so
;   154 -- obviously c_func itself calls fatalN(2..), whereas if c_func calls
;   155 -- toString, that must then call fatalN(3..), and when open_dll calls
;   156 -- OpenOneDLL, which calls toString which finally calls this, it must 
;   157 -- do so with call fatalN(4..). There are no fatalN(1..) calls since
;   158 -- this is local and that would report an error in pcfuncN.e itself,
;   159 -- which is the very thing the level parameter is supposed to avoid!
;   160     #ilASM{
;   161         [32]
;   162             mov ecx,[level]
;   163             mov eax,[errcode]
;   164             mov edi,[ep1]
;   165           @@:
;   166             mov edx,[ebp+16]    -- era
;   167             mov ebp,[ebp+20]    -- (nb no local vars after this!)
;   168             sub ecx,1
;   169             jg @b
;   170             xor esi,esi         -- ep2 unused
;   171             sub edx,1
;   172             jmp :!iDiag         -- fatal error (see pdiagN.e)
;   173             int3
;   174         [64]
;   175             mov rcx,[level]
                    mov rcx,[rbp] (level)  ;#0044A377: 48:213115 00               vu 02 20  1   3      
;   176             mov rax,[errcode]
                    mov rax,[rbp-8] (errcode)  ;#0044A37B: 48:213105 F8               uv 01 20  1   4      
;   177             mov rdi,[ep1]
                    mov rdi,[rbp-16] (ep1)  ;#0044A37F: 48:213175 F0               vu 80 20  1   4      
;   178           @@:
;   179             mov rdx,[rbp+32]    -- era
                    mov rdx,[rbp+32] (retaddr)  ;#0044A383: 48:213125 20               uv 04 20  1   5      
;   180             mov rbp,[rbp+40]    -- (nb no local vars after this!)
                    mov rbp,[rbp+40] (prevebp)  ;#0044A387: 48:213155 28               vu 20 20  1   5      
;   181             sub rcx,1
                    sub rcx,1             ;#0044A38B: 48:203351 01               uv 02 02  1   6      
;   182             jg @b
                    jg #0044A383          ;#0044A38F: 177 F2                     v  00 00  1   6      
;   183             xor rsi,rsi         -- ep2 unused
                    xor rsi,rsi           ;#0044A391: 48:061366                  uv 40 40  1   7      
;   184             sub rdx,1
                    sub rdx,1             ;#0044A394: 48:203352 01               vu 04 04  1   7      
;   185             jmp :!iDiag         -- fatal error (see pdiagN.e)
                    jmp #00442E66 (:!iDiag)  ;#0044A398: 351 C98AFFFF               v  00 00  1   8      
;   186             int3
                    int3                  ;#0044A39D: 314                        np 00 00 13   9      
;   187         []
;   188           }
;   189     ?9/0
    call #00442DD2 (:%pDiv0)              ;#0044A39E: 350 2F8AFFFF               v  00 00  1  22      
    jmp #0044298D (:%opRetf)              ;#0044A3A3: 351 E585FFFF               v  00 00  1  23      
;   190 end procedure
;   191 
;   192 function toString(sequence name, integer asAlphanum, integer errcode, integer level)
;   193 -- Explicitly convert a dword-sequence to an 8-bit string
;   194 -- asAlphanum is ASALPHANUM or ASANY
;   195 -- errcode is one of the constants defined above (e73..e88)
;   196 string res
;   197 integer nlen
;   198 object ch
;   199     nlen = length(name)
    mov rsi,[rbp] (name)                  ;#0044A1D9: 48:213165 00               uv 40 20  1   1      
    mov rcx,[rbx+rsi*4-24]                ;#0044A1DD: 48:48:213114263 E8         uv 02 48  1   4 40 *40*
    mov [rbp-40] (nlen),rcx               ;#0044A1E3: 48:211115 D8               uv 00 22  1   5 02   
;   200     res = repeat(' ',nlen)
    lea rdi,[rbp-32] (res)                ;#0044A1E7: 48:215175 E0               vu 80 20  1   5      
    mov rax,32                            ;#0044A1EB: 48:307300 20000000         uv 01 00  1   6      
    call #0043B1E1 (:%opRepCh)            ;#0044A1F2: 350 EA0FFFFF               v  00 00  1   6      
;   201     for i=1 to nlen do
    mov rdi,[rbp-40] (nlen)               ;#0044A1F7: 48:213175 D8               uv 80 20  1   7      
    mov [rbp-56] (symtab[1160]),rdi       ;#0044A1FB: 48:211175 C8               uv 00 A0  1   8 80   
    mov qword[rbp-64] (i),1               ;#0044A1FF: 48:307105 C0 01000000      vu 00 20  1   8      
    cmp rdi,1                             ;#0044A207: 48:201377 01000000         uv 00 80  1   9      
    jl #0044A353                          ;#0044A20E: 017214 3F010000            v  00 00  1   9      
;   202         ch = name[i]
    mov rdi,[rbp-64] (i)                  ;#0044A214: 48:213175 C0               uv 80 20  1  10      
    lea rcx,[rbp-48] (ch)                 ;#0044A218: 48:215115 D0               vu 02 20  1  10      
    mov rsi,[rbp] (name)                  ;#0044A21C: 48:213165 00               uv 40 20  1  11      
    mov rdx,1153                          ;#0044A220: 48:307302 81040000         vu 04 00  1  11      
    call #00441675 (:%pSubse1)            ;#0044A227: 350 4974FFFF               v  00 00  1  12      
;   203         if atom(ch) then
    mov rax,[rbp-48] (ch)                 ;#0044A22C: 48:213105 D0               uv 01 20  1  13      
    mov r15,h4                            ;#0044A230: 49:277 0000000000000040    vu 8000 00  1  13      
    cmp rax,r15                           ;#0044A23A: 4C:071370                  uv 00 8001  1  14      
    jl #0044A24A                          ;#0044A23D: 174 0B                     v  00 00  1  14      
    cmp byte[rbx+rax*4-1],#12             ;#0044A23F: 200174203 FF 12            u  00 09  2  15      
    jne #0044A2E8                         ;#0044A244: 017205 9E000000            v  00 00  1  16      
;   204             ch = and_bits(ch,#FF)
    lea rdi,[rbp-48] (ch)                 ;#0044A24A: 48:215175 D0               uv 80 20  1  17      
    mov rcx,rax                           ;#0044A24E: 48:211301                  vu 02 01  1  17      
    mov rax,qword[#00402268]              ;#0044A251: 48:213005 1080FBFF         uv 01 00  1  18      
    call #0043F6C1 (:%opAndBits)          ;#0044A258: 350 6454FFFF               v  00 00  1  18      
;   205             res[i] = ch
    mov rdi,[rbp-64] (i)                  ;#0044A25D: 48:213175 C0               uv 80 20  1  19      
    mov rcx,[rbp-48] (ch)                 ;#0044A261: 48:213115 D0               vu 02 20  1  19      
    mov rsi,[rbp-32] (res)                ;#0044A265: 48:213165 E0               uv 40 20  1  20      
    lea rax,[rbp-32] (res)                ;#0044A269: 48:215105 E0               vu 01 20  1  20      
    call #00440EB1 (:%pRepe1is)           ;#0044A26D: 350 3F6CFFFF               v  00 00  1  21      
;   206             if asAlphanum=ASALPHANUM then
    mov rax,[rbp-8] (asAlphanum)          ;#0044A272: 48:213105 F8               uv 01 20  1  22      
    cmp rax,1                             ;#0044A276: 48:203370 01               uv 00 01  1  23 01   
    jne #0044A2E8                         ;#0044A27A: 165 6C                     v  00 00  1  23      
;   207                 if ch<'1'
    mov rdi,[rbp-48] (ch)                 ;#0044A27C: 48:213175 D0               uv 80 20  1  24      
    cmp rdi,49                            ;#0044A280: 48:203377 31               uv 00 80  1  25 80   
    jl #0044A2AA                          ;#0044A284: 174 24                     v  00 00  1  25      
;   208                 or (ch>'9' and ch<'A')
    cmp rdi,57                            ;#0044A286: 48:203377 39               uv 00 80  1  26      
    jle #0044A292                         ;#0044A28A: 176 06                     v  00 00  1  26      
    cmp rdi,65                            ;#0044A28C: 48:203377 41               uv 00 80  1  27      
    jl #0044A2AA                          ;#0044A290: 174 18                     v  00 00  1  27      
;   209                 or (ch>'Z' and ch<'a' and ch!='_')
    cmp rdi,90                            ;#0044A292: 48:203377 5A               uv 00 80  1  28      
    jle #0044A2A4                         ;#0044A296: 176 0C                     v  00 00  1  28      
    cmp rdi,97                            ;#0044A298: 48:203377 61               uv 00 80  1  29      
    jge #0044A2A4                         ;#0044A29C: 175 06                     v  00 00  1  29      
    cmp rdi,95                            ;#0044A29E: 48:203377 5F               uv 00 80  1  30      
    jne #0044A2AA                         ;#0044A2A2: 165 06                     v  00 00  1  30      
;   210                 or ch>'z' then
    cmp rdi,122                           ;#0044A2A4: 48:203377 7A               uv 00 80  1  31      
    jle #0044A2E8                         ;#0044A2A8: 176 3E                     v  00 00  1  31      
;   211                     -- add any special foreign chars ( etc) 
;   212                     --  here as and when needed (if ever).
;   213 --                  if not find(ch,"") then
;   214                     ch = {}
    mov rcx,qword[#004022C8]              ;#0044A2AA: 48:213015 1780FBFF         uv 02 00  1  32      
    mov r15,h4                            ;#0044A2B1: 49:277 0000000000000040    vu 8000 00  1  32      
    cmp rcx,r15                           ;#0044A2BB: 4C:071371                  uv 00 8002  1  33      
    jl #0044A2C6                          ;#0044A2BE: 174 06                     v  00 00  1  33      
    add qword[rbx+rcx*4-16],1             ;#0044A2C0: 48:203104213 F0 01         u  00 0A  3  34      
    mov [rbp-48] (ch),rcx                 ;#0044A2C6: 48:211115 D0               vu 00 22  1  36      
    mov r15,h4                            ;#0044A2CA: 49:277 0000000000000040    uv 8000 00  1  37      
    cmp rdi,r15                           ;#0044A2D4: 4C:071377                  uv 00 8080  1  38 8000   
    jle #0044A2E8                         ;#0044A2D7: 176 0F                     v  00 00  1  38      
    sub qword[rbx+rdi*4-16],1             ;#0044A2D9: 48:203154273 F0 01         u  00 88  3  39      
    jne #0044A2E8                         ;#0044A2DF: 165 07                     v  00 00  1  41      
    mov edx,edi                           ;#0044A2E1: 211372                     uv 04 80  1  42      
    call #004422DA (:%pDealloc)           ;#0044A2E3: 350 F27FFFFF               v  00 00  1  42      
;   215 --                  end if
;   216                 end if
;   217             end if
;   218         end if
;   219         if not atom(ch) then
    mov rsi,[rbp-48] (ch)                 ;#0044A2E8: 48:213165 D0               uv 40 20  1  43      
    mov r15,h4                            ;#0044A2EC: 49:277 0000000000000040    vu 8000 00  1  43      
    cmp rsi,r15                           ;#0044A2F6: 4C:071376                  uv 00 8040  1  44      
    jl #0044A33A                          ;#0044A2F9: 174 3F                     v  00 00  1  44      
    cmp byte[rbx+rsi*4-1],#12             ;#0044A2FB: 200174263 FF 12            u  00 48  2  45      
    je #0044A33A                          ;#0044A300: 164 38                     v  00 00  1  46      
;   220 --          fatal(errcode)
;   221             fatalN(level,errcode)
    mov rcx,3                             ;#0044A302: 48:307301 03000000         uv 02 00  1  47      
    mov rdx,1147                          ;#0044A309: 48:307302 7B040000         vu 04 00  1  47      
    call #004428DB (:%opFrame) (fatalN)   ;#0044A310: 350 C685FFFF               v  00 00  1  48      
    mov rdi,[rbp+40] (prevebp)            ;#0044A315: 48:213175 28               uv 80 20  1  49      
    mov rax,[rdi-24]                      ;#0044A319: 48:213107 E8               uv 01 80  1  52 80 *80*
    mov [rbp] (level),rax                 ;#0044A31D: 48:211105 00               uv 00 21  1  53 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044A321: 48:213175 28               vu 80 20  1  53      
    mov rax,[rdi-16]                      ;#0044A325: 48:213107 F0               uv 01 80  1  56    *80*
    mov [rbp-8] (errcode),rax             ;#0044A329: 48:211105 F8               uv 00 21  1  57 01   
    mov qword[retaddr],#0044A33A          ;#0044A32D: 48:307105 20 3AA34400      vu 00 20  1  57      
    jmp #0044A360 (code:fatalN)           ;#0044A335: 351 26000000               v  00 00  1  58      
;   222         end if
;   223     end for
    mov rdi,[rbp-64] (i)                  ;#0044A33A: 48:213175 C0               uv 80 20  1  59      
    mov rcx,[rbp-56] (symtab[1160])       ;#0044A33E: 48:213115 C8               vu 02 20  1  59      
    add rdi,1                             ;#0044A342: 48:203307 01               uv 80 80  1  60      
    cmp rdi,rcx                           ;#0044A346: 48:073371                  uv 00 82  1  61 80   
    mov [rbp-64] (i),rdi                  ;#0044A349: 48:211175 C0               vu 00 A0  1  61      
    jle #0044A214                         ;#0044A34D: 017216 C1FEFFFF            v  00 00  1  62      
;   224     return res
    mov rax,[rbp-32] (res)                ;#0044A353: 48:213105 E0               uv 01 20  1  63      
    mov [rbp-32] (res),rbx                ;#0044A357: 48:211135 E0               vu 00 28  1  63      
    jmp #0044298D (:%opRetf)              ;#0044A35B: 351 2D86FFFF               v  00 00  1  64      
;   225 end function
;   226 
;   227 function OpenOneDLL(sequence filename)
;   228 atom res
;   229     if not string(filename) then
    mov rcx,[rbp] (filename)              ;#0044AA22: 48:213115 00               uv 02 20  1   1      
    cmp byte[rbx+rcx*4-1],#82             ;#0044AA26: 200174213 FF 82            u  00 0A  2   4    *02*
    je #0044AA9A                          ;#0044AA2B: 164 6D                     v  00 00  1   5      
;   230         filename = toString(filename,ASALPHANUM,e73atodmbs,4)
    mov rcx,9                             ;#0044AA2D: 48:307301 09000000         uv 02 00  1   6      
    mov rdx,1152                          ;#0044AA34: 48:307302 80040000         vu 04 00  1   6      
    call :%opFrame (toString)             ;#0044AA3B: 350 9B7EFFFF               v  00 00  1   7      
    mov rdi,[rbp+40] (prevebp)            ;#0044AA40: 48:213175 28               uv 80 20  1   8      
    mov rax,[rdi]                         ;#0044AA44: 48:213007                  uv 01 80  1  11 80 *80*
    mov [rdi],r15                         ;#0044AA47: 4C:211077                  vu 00 8080  1  11      
    mov [rbp] (name),rax                  ;#0044AA4A: 48:211105 00               uv 00 21  1  12      
    mov qword[rbp-8] (asAlphanum),1       ;#0044AA4E: 48:307105 F8 01000000      vu 00 20  1  12      
    mov qword[rbp-16] (errcode),73        ;#0044AA56: 48:307105 F0 49000000      uv 00 20  1  13      
    mov qword[rbp-24] (level),4           ;#0044AA5E: 48:307105 E8 04000000      vu 00 20  1  13      
    mov qword[retaddr],#0044AA73          ;#0044AA66: 48:307105 20 73AA4400      uv 00 20  1  14      
    jmp #0044A1D9 (code:toString)         ;#0044AA6E: 351 66F7FFFF               v  00 00  1  14      
    push rax                              ;#0044AA73: 120                        uv 00 01  1  15      
    mov rdi,[rbp] (filename)              ;#0044AA74: 48:213175 00               vu 80 20  1  15      
    mov r15,h4                            ;#0044AA78: 49:277 0000000000000040    uv 8000 00  1  16      
    cmp rdi,r15                           ;#0044AA82: 4C:071377                  uv 00 8080  1  17 8000   
    jle #0044AA97                         ;#0044AA85: 176 10                     v  00 00  1  17      
    sub qword[rbx+rdi*4-16],1             ;#0044AA87: 48:203154273 F0 01         u  00 88  3  18      
    jne #0044AA97                         ;#0044AA8D: 165 08                     v  00 00  1  20      
    mov rdx,rdi                           ;#0044AA8F: 48:213327                  uv 04 80  1  21      
    call #004422DA (:%pDealloc)           ;#0044AA92: 350 4378FFFF               v  00 00  1  21      
    pop dword[rbp] (filename)             ;#0044AA97: 217105 00                  np 00 20  3  22      
;   231     end if
;   232     #ilASM{
;   233         [PE32]
;   234             mov eax,[filename]
;   235             push ebx    --(=0) (for fild qword)
;   236             shl eax,2
;   237             push eax                            -- lpLibFileName
;   238             call "kernel32.dll","LoadLibraryA"
;   239             push eax
;   240             lea edi,[res]
;   241             fild qword[esp]
;   242             add esp,8
;   243             call :%pStoreFlt                    -- ([edi]:=ST0)
;   244         [PE64]
;   245             mov rcx,rsp -- put 2 copies of rsp onto the stack...
                    mov rcx,rsp           ;#0044AA9A: 48:213314                  uv 02 10  1  25      
;   246             push rsp
                    push rsp              ;#0044AA9D: 48:124                     vu 00 10  1  25      
;   247             push rcx
                    push rcx              ;#0044AA9F: 48:121                     uv 00 02  1  26      
;   248             or rsp,8    -- [rsp] is now 1st or 2nd copy:
                    or rsp,8              ;#0044AAA1: 48:203314 08               vu 10 10  1  26      
;   249                         -- if on entry rsp was xxx8: both copies remain on the stack
;   250                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;   251                         -- obviously rsp is now xxx8, whatever alignment we started with
;   252             mov rcx,[filename]
                    mov rcx,[rbp] (filename)  ;#0044AAA5: 48:213115 00               uv 02 20  1  27      
;   253             sub rsp,8*5         -- minimum 4 param shadow space, and align
                    sub rsp,40            ;#0044AAA9: 48:203354 28               vu 10 10  1  27      
;   254             shl rcx,2                           -- lpLibFileName
                    shl rcx,2             ;#0044AAAD: 48:301341 02               u  02 02  1  28      
;   255             call "kernel32.dll","LoadLibraryA"
                    call [#004010E0] (LoadLibraryA)  ;#0044AAB1: 377025 2966FBFF            np 00 00  2  29      
;   256             mov [rsp],rax
                    mov [rsp],rax         ;#0044AAB7: 48:211004044               uv 00 11  1  31      
;   257             lea rdi,[res]
                    lea rdi,[rbp-8] (res)  ;#0044AABB: 48:215175 F8               vu 80 20  1  31      
;   258             fild qword[rsp]
                    fild qword[rsp]       ;#0044AABF: 337054044                  np 00 10  3  32      
;   259 --          add rsp,8*5
;   260 --          pop rsp
;   261             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                    mov rsp,[rsp+40]      ;#0044AAC2: 48:213144044 28            uv 10 10  1  35      
;   262             call :%pStoreFlt    -- ([rdi]:=ST0)
                    call #004421B0 (:%pStoreFlt)  ;#0044AAC7: 350 E476FFFF               v  00 00  1  35      
;   263         [ELF32]
;   264             pop al
;   265         [ELF64]
;   266             pop al
;   267         []
;   268           }
;   269     return res
    mov rax,[rbp-8] (res)                 ;#0044AACC: 48:213105 F8               uv 01 20  1  36      
    mov [rbp-8] (res),rbx                 ;#0044AAD0: 48:211135 F8               vu 00 28  1  36      
    jmp #0044298D (:%opRetf)              ;#0044AAD4: 351 B47EFFFF               v  00 00  1  37      
;   270 end function
;   271 
;   272 global function open_dll(sequence filename)
;   273 atom res = 0
    mov [rbp-8] (res),rbx                 ;#0044A882: 48:211135 F8               uv 00 28  1   1      
;   274 sequence fi
;   275     if length(filename)>0 and atom(filename[1]) then
    mov rsi,[rbp] (filename)              ;#0044A886: 48:213165 00               vu 40 20  1   1      
    mov rcx,[rbx+rsi*4-24]                ;#0044A88A: 48:48:213114263 E8         uv 02 48  1   4    *40*
    cmp rcx,0                             ;#0044A890: 48:203371 00               uv 00 02  1   5 02   
    jle #0044A925                         ;#0044A894: 017216 8B000000            v  00 00  1   5      
    mov rdi,1                             ;#0044A89A: 48:307307 01000000         uv 80 00  1   6      
    mov rdx,1169                          ;#0044A8A1: 48:307302 91040000         vu 04 00  1   6      
    call #00441762 (:%pSubse1is)          ;#0044A8A8: 350 B56EFFFF               v  00 00  1   7      
    mov [rbp-32] (symtab[1173]),rax       ;#0044A8AD: 48:211105 E0               uv 00 21  1   8      
;   276         res = OpenOneDLL(filename)
    mov rcx,2                             ;#0044A8B1: 48:307301 02000000         vu 02 00  1   8      
    mov rdx,1166                          ;#0044A8B8: 48:307302 8E040000         uv 04 00  1   9      
    call :%opFrame (OpenOneDLL)           ;#0044A8BF: 350 1780FFFF               v  00 00  1   9      
    mov rdi,[rbp+40] (prevebp)            ;#0044A8C4: 48:213175 28               uv 80 20  1  10      
    mov rax,[rdi]                         ;#0044A8C8: 48:213007                  uv 01 80  1  13 80 *80*
    xor rbx,rbx                           ;#0044A8CB: 48:061333                  vu 08 08  1  13      
    mov r15,h4                            ;#0044A8CE: 49:277 0000000000000040    uv 8000 00  1  14      
    cmp rax,r15                           ;#0044A8D8: 4C:071370                  uv 00 8001  1  15 8000   
    jl #0044A8E8                          ;#0044A8DB: 174 0B                     v  00 00  1  15      
    add qword[rbx+rax*4-16],1             ;#0044A8DD: 48:203104203 F0 01         u  00 09  3  16      
    cmp eax,1169                          ;#0044A8E3: 075 91040000               vu 00 01  1  18      
    mov [rbp] (filename),rax              ;#0044A8E8: 48:211105 00               uv 00 21  1  19      
    mov qword[retaddr],#0044A8F9          ;#0044A8EC: 48:307105 20 F9A84400      vu 00 20  1  19      
    jmp #0044AA22 (code:OpenOneDLL)       ;#0044A8F4: 351 29010000               v  00 00  1  20      
    push rax                              ;#0044A8F9: 120                        uv 00 01  1  21      
    mov rdi,[rbp-8] (res)                 ;#0044A8FA: 48:213175 F8               vu 80 20  1  21      
    mov r15,h4                            ;#0044A8FE: 49:277 0000000000000040    uv 8000 00  1  22      
    cmp rdi,r15                           ;#0044A908: 4C:071377                  uv 00 8080  1  23 8000   
    jle #0044A91D                         ;#0044A90B: 176 10                     v  00 00  1  23      
    sub qword[rbx+rdi*4-16],1             ;#0044A90D: 48:203154273 F0 01         u  00 88  3  24      
    jne #0044A91D                         ;#0044A913: 165 08                     v  00 00  1  26      
    mov rdx,rdi                           ;#0044A915: 48:213327                  uv 04 80  1  27      
    call #004422DA (:%pDealloc)           ;#0044A918: 350 BD79FFFF               v  00 00  1  27      
    pop dword[rbp-8] (res)                ;#0044A91D: 217105 F8                  np 00 20  3  28      
    jmp #0044AA15                         ;#0044A920: 351 F0000000               v  00 00  1  31      
;   277     else
;   278         -- A list of filenames: try each one in turn
;   279         for idx=1 to length(filename) do
    mov rcx,[rbx+rsi*4-24]                ;#0044A925: 48:48:213114263 E8         uv 02 48  1  32      
    mov [rbp-24] (symtab[1172]),rcx       ;#0044A92B: 48:211115 E8               uv 00 22  1  33 02   
    mov qword[rbp-40] (idx),1             ;#0044A92F: 48:307105 D8 01000000      vu 00 20  1  33      
    cmp rcx,1                             ;#0044A937: 48:201371 01000000         uv 00 02  1  34      
    jl #0044AA15                          ;#0044A93E: 017214 D1000000            v  00 00  1  34      
;   280             fi = filename[idx]
    mov rdi,[rbp-40] (idx)                ;#0044A944: 48:213175 D8               uv 80 20  1  35      
    lea rcx,[rbp-16] (fi)                 ;#0044A948: 48:215115 F0               vu 02 20  1  35      
    mov rsi,[rbp] (filename)              ;#0044A94C: 48:213165 00               uv 40 20  1  36      
    mov rdx,1169                          ;#0044A950: 48:307302 91040000         vu 04 00  1  36      
    call #00441675 (:%pSubse1)            ;#0044A957: 350 196DFFFF               v  00 00  1  37      
    mov rax,[rbp-16] (fi)                 ;#0044A95C: 48:213105 F0               uv 01 20  1  38      
    mov r15,h4                            ;#0044A960: 49:277 0000000000000040    vu 8000 00  1  38      
    cmp rax,r15                           ;#0044A96A: 4C:071370                  uv 00 8001  1  39      
    jl #0044A976                          ;#0044A96D: 174 07                     v  00 00  1  39      
    test byte[rbx+rax*4-1],#80            ;#0044A96F: 366104203 FF 80            u  00 09  2  40      
    jne #0044A982                         ;#0044A974: 165 0C                     v  00 00  1  41      
    mov rcx,1171                          ;#0044A976: 48:307301 93040000         uv 02 00  1  42      
    call #00442A58 (:%opTchkFail)         ;#0044A97D: 350 D680FFFF               v  00 00  1  42      
;   281             res = OpenOneDLL(fi)
    mov rcx,2                             ;#0044A982: 48:307301 02000000         uv 02 00  1  43      
    mov rdx,1166                          ;#0044A989: 48:307302 8E040000         vu 04 00  1  43      
    call :%opFrame (OpenOneDLL)           ;#0044A990: 350 467FFFFF               v  00 00  1  44      
    mov rdi,[rbp+40] (prevebp)            ;#0044A995: 48:213175 28               uv 80 20  1  45      
    mov rax,[rdi-16]                      ;#0044A999: 48:213107 F0               uv 01 80  1  48 80 *80*
    xor rbx,rbx                           ;#0044A99D: 48:061333                  vu 08 08  1  48      
    mov r15,h4                            ;#0044A9A0: 49:277 0000000000000040    uv 8000 00  1  49      
    cmp rax,r15                           ;#0044A9AA: 4C:071370                  uv 00 8001  1  50 8000   
    jl #0044A9BA                          ;#0044A9AD: 174 0B                     v  00 00  1  50      
    add qword[rbx+rax*4-16],1             ;#0044A9AF: 48:203104203 F0 01         u  00 09  3  51      
    cmp eax,1171                          ;#0044A9B5: 075 93040000               vu 00 01  1  53      
    mov [rbp] (filename),rax              ;#0044A9BA: 48:211105 00               uv 00 21  1  54      
    mov qword[retaddr],#0044A9CB          ;#0044A9BE: 48:307105 20 CBA94400      vu 00 20  1  54      
    jmp #0044AA22 (code:OpenOneDLL)       ;#0044A9C6: 351 57000000               v  00 00  1  55      
    push rax                              ;#0044A9CB: 120                        uv 00 01  1  56      
    mov rcx,[rbp-8] (res)                 ;#0044A9CC: 48:213115 F8               vu 02 20  1  56      
    mov r15,h4                            ;#0044A9D0: 49:277 0000000000000040    uv 8000 00  1  57      
    cmp rcx,r15                           ;#0044A9DA: 4C:071371                  uv 00 8002  1  58 8000   
    jle #0044A9EF                         ;#0044A9DD: 176 10                     v  00 00  1  58      
    sub qword[rbx+rcx*4-16],1             ;#0044A9DF: 48:203154213 F0 01         u  00 0A  3  59      
    jne #0044A9EF                         ;#0044A9E5: 165 08                     v  00 00  1  61      
    mov rdx,rcx                           ;#0044A9E7: 48:213321                  uv 04 02  1  62      
    call #004422DA (:%pDealloc)           ;#0044A9EA: 350 EB78FFFF               v  00 00  1  62      
    pop dword[rbp-8] (res)                ;#0044A9EF: 217105 F8                  np 00 20  3  63      
;   282             if res!=0 then exit end if
    mov rdi,[rbp-8] (res)                 ;#0044A9F2: 48:213175 F8               uv 80 20  1  66      
    cmp rdi,0                             ;#0044A9F6: 48:203377 00               uv 00 80  1  67 80   
    jne #0044AA15                         ;#0044A9FA: 165 19                     v  00 00  1  67      
;   283         end for
    mov rsi,[rbp-40] (idx)                ;#0044A9FC: 48:213165 D8               uv 40 20  1  68      
    mov rax,[rbp-24] (symtab[1172])       ;#0044AA00: 48:213105 E8               vu 01 20  1  68      
    add rsi,1                             ;#0044AA04: 48:203306 01               uv 40 40  1  69      
    cmp rsi,rax                           ;#0044AA08: 48:073360                  uv 00 41  1  70 40   
    mov [rbp-40] (idx),rsi                ;#0044AA0B: 48:211165 D8               vu 00 60  1  70      
    jle #0044A944                         ;#0044AA0F: 017216 2FFFFFFF            v  00 00  1  71      
;   284     end if
;   285     return res
    mov rax,[rbp-8] (res)                 ;#0044AA15: 48:213105 F8               uv 01 20  1  72      
    mov [rbp-8] (res),rbx                 ;#0044AA19: 48:211135 F8               vu 00 28  1  72      
    jmp #0044298D (:%opRetf)              ;#0044AA1D: 351 6B7FFFFF               v  00 00  1  73      
;   286 end function
;   287 
;   288 procedure check(object o, integer level)
;   289 -- (if any more types are added here, ensure c_func copes with the new return type,
;   290 --  also see that routine for some possible future types we might one day need.)
;   291     if not find(o, {C_CHAR,C_UCHAR,
;   292                     C_SHORT,C_USHORT,
;   293                     C_INT,C_UINT,
;   294                 -- (C_LONG    = C_INT,
;   295                 --  C_ULONG   = C_UINT,
;   296                 --  C_POINTER = C_ULONG,)
;   297 --                  C_FLOAT,C_DOUBLE,
;   298                     C_FLOAT,C_DOUBLE}) then
    mov rcx,7                             ;#0044A808: 48:307301 07000000         uv 02 00  1   1      
    mov rdx,75                            ;#0044A80F: 48:307302 4B000000         vu 04 00  1   1      
    call #004428DB (:%opFrame) (find)     ;#0044A816: 350 C080FFFF               v  00 00  1   2      
    mov rdi,[rbp+40] (prevebp)            ;#0044A81B: 48:213175 28               uv 80 20  1   3      
    mov rax,[rdi]                         ;#0044A81F: 48:213007                  uv 01 80  1   6 80 *80*
    mov [rbp] (x),rax                     ;#0044A822: 48:211105 00               uv 00 21  1   7 01   
    mov rdi,qword[#00403290]              ;#0044A826: 48:213075 638AFBFF         vu 80 00  1   7      
    mov [rbp-8] (s),rdi                   ;#0044A82D: 48:211175 F8               uv 00 A0  1   8      
    add qword[rbx+rdi*4-16],1             ;#0044A831: 48:203104273 F0 01         u  00 88  3  10    *80*
    mov qword[retaddr],#0044A844          ;#0044A837: 48:307105 20 44A84400      vu 00 20  1  12      
    jmp #0043DAD6 (code:find)             ;#0044A83F: 351 9232FFFF               v  00 00  1  13      
    test rax,rax                          ;#0044A844: 48:205300                  uv 00 01  1  14      
    jne #0044A87D                         ;#0044A847: 165 34                     v  00 00  1  14      
;   299 --                  E_INTEGER,E_ATOM,
;   300 --                  E_SEQUENCE,E_OBJECT}) then
;   301 --      fatal(e74dcfpe)
;   302         fatalN(level,e74dcfpe)
    mov rcx,3                             ;#0044A849: 48:307301 03000000         uv 02 00  1  15      
    mov rdx,1147                          ;#0044A850: 48:307302 7B040000         vu 04 00  1  15      
    call #004428DB (:%opFrame) (fatalN)   ;#0044A857: 350 7F80FFFF               v  00 00  1  16      
    mov rdi,[rbp+40] (prevebp)            ;#0044A85C: 48:213175 28               uv 80 20  1  17      
    mov rax,[rdi-8]                       ;#0044A860: 48:213107 F8               uv 01 80  1  20 80 *80*
    mov [rbp] (level),rax                 ;#0044A864: 48:211105 00               uv 00 21  1  21 01   
    mov qword[rbp-8] (errcode),74         ;#0044A868: 48:307105 F8 4A000000      vu 00 20  1  21      
    mov qword[retaddr],#0044A87D          ;#0044A870: 48:307105 20 7DA84400      uv 00 20  1  22      
    jmp #0044A360 (code:fatalN)           ;#0044A878: 351 E3FAFFFF               v  00 00  1  22      
;   303     end if
    jmp #0044298D (:%opRetf)              ;#0044A87D: 351 0B81FFFF               v  00 00  1  23      
;   304 end procedure
;   305 
;   306 --  table = append(table,{name,addr,args,return_type,convention})
;   307 constant T_name         = 1,  -- (kept for ref/debugging purposes only)
;   308          T_address      = 2,
;   309          T_args         = 3,
;   310          T_return_type  = 4,
;   311          T_convention   = 5
;   312 
;   313 --DEV (posted as a challenge)
;   314 --if T_name!=1 then ?9/0 end if -- suppress warning (no code is generated)
;   315 --if T_name then end if -- same problem
;   316 
;   317 constant STDCALL = 1,
;   318          CDECL   = 2 -- T_convention values
;   319 
;   320 --DEV not thread safe! (critical section should be fine)
;   321 sequence table
;   322 
;   323 integer tinit
;   324         tinit = 0
;   325 
;   326 global function define_c_func(object lib, object fname, sequence args, atom return_type)
;   327 --
;   328 -- Define the characteristics of either:
;   329 --  * a C function in a dll or .so file, or
;   330 --  * a machine-code routine at a given address.
;   331 --
;   332 --  lib may be an atom, the address of the library containing the function, normally
;   333 --      from open_dll(), in which case fname must be a sequence, eg:
;   334 --
;   335 --          constant kernel32 = open_dll("kernel32"),
;   336 --                   xBeep = define_c_func(kernel32,"Beep",{C_INT,C_INT},C_INT)
;   337 --          ...
;   338 --              if c_func(xBeep,{250,500}) then end if  -- 250Hz for 500ms
;   339 --
;   340 --  lib may instead be {} or "", in which case fname must be an atom, ie a machine 
;   341 --      code routine, either from inline assembly (recommended), or memory from 
;   342 --      allocate() that has had x86 binary poked into it (the legacy way), eg:
;   343 --
;   344 --          -- The recommended way:
;   345 --          integer jraddr
;   346 --          #ilASM {jmp :fin
;   347 --                  ::justret
;   348 --                      -- (params at eg [esp+4]/[rsp+8])
;   349 --                      ret -- (or ret nn)
;   350 --                  ::fin
;   351 --                      mov [jraddr],:justret   -- (assumes justret<1GB)
;   352 --                 }
;   353 --          constant ret1 = define_c_proc({},jraddr,{})
;   354 --          ...
;   355 --          -- The legacy way:
;   356 --          constant mem1 = allocate(1)
;   357 --              poke(mem1,#C3)  -- ret
;   358 --          constant ret2 = define_c_proc({},mem1,{})
;   359 --          ...
;   360 --              c_proc(ret1,{})
;   361 --              c_proc(ret2,{})
;   362 --
;   363 --      (of course c_proc/func can be used on both library and machine routines)
;   364 --
;   365 --  name may be prefixed by '+' to use the CDECL calling convention:
;   366 --      CDECL is the default/only calling convention on a Linux system.
;   367 --      STDCALL is the default in a Windows system.
;   368 --          c_func({},{'+',<atom memory_address>},...)
;   369 --      defines a machine code routine to be called using CDECL,
;   370 --          c_func(<atom lib>,"+FunctionName",...)
;   371 --      or
;   372 --          c_func(<atom lib>,{'+',"FunctionName"},...) [NOT RDS Eu compatible]
;   373 --      define a dll/.so routine to be called using CDECL.
;   374 --
;   375 --      The CDECL convention requires the callee to clean up the stack, and is 
;   376 --      therefore more suited to variable numbers of arguments, whereas with 
;   377 --      STDCALL the routine cleans up the stack before returning.
;   378 --
;   379 --  args should be a sequence of C_CHAR..E_OBJECT (as per check() above),
;   380 --
;   381 --  return_type should be one of C_CHAR..E_OBJECT, or 0 for define_c_proc.
;   382 --
;   383 --  The file test\t42cback.exw is (or should be) the most comprehensive set
;   384 --  or examples, but there are many others, such as demo/winwire, or even 
;   385 --  just the Beep/DeleteFile in p.exw which may be easier to start with.
;   386 --
;   387 --  Returns a positive integer (aka routine_id, an index into the tables
;   388 --  above), which should be used as the first argument to c_func (or c_proc),
;   389 --  or -1 is returned if the routine could not be located.
;   390 --
;   391 integer nlen
;   392 object name
;   393 integer convention
;   394 atom addr
;   395 integer res
;   396 integer level = 2+(return_type=0)
    mov rcx,[rbp-24] (return_type)        ;#0044A3A8: 48:213115 E8               uv 02 20  1   1      
    xor eax,eax                           ;#0044A3AC: 061300                     vu 01 01  1   1      
    cmp rcx,0                             ;#0044A3AE: 48:203371 00               uv 00 02  1   2      
    sete al                               ;#0044A3B2: 017224300                  np 01 00  2   3      
    mov [rbp-80] (symtab[1198]),rax       ;#0044A3B5: 48:211105 B0               uv 00 21  1   5      
    mov qword[rbp-72] (level),2           ;#0044A3B9: 48:307105 B8 02000000      vu 00 20  1   5      
;   397 
;   398     convention = STDCALL
    mov qword[rbp-48] (convention),1      ;#0044A3C1: 48:307105 D0 01000000      uv 00 20  1   6      
;   399     if platform()!=WIN32 then
;   400         convention = CDECL
;   401     end if
;   402     name = fname
    mov rdi,[rbp-8] (fname)               ;#0044A3C9: 48:213175 F8               vu 80 20  1   6      
    mov [rbp-40] (name),rdi               ;#0044A3CD: 48:211175 D8               uv 00 A0  1   7      
    add qword[rbx+rdi*4-16],1             ;#0044A3D1: 48:203104273 F0 01         u  00 88  3   9    *80*
;   403     if sequence(fname) then
;   404         -- check for a '+' prefix:
;   405         nlen = length(fname)
    mov rsi,[rbx+rdi*4-24]                ;#0044A3D7: 48:48:213164273 E8         vu 40 88  1  11      
    mov [rbp-32] (nlen),rsi               ;#0044A3DD: 48:211165 E0               uv 00 60  1  12      
;   406 --      if nlen=0 then fatal(e74dcfpe) end if
;   407         if nlen=0 then fatalN(level,e74dcfpe) end if
    cmp rsi,0                             ;#0044A3E1: 48:203376 00               vu 00 40  1  12      
    jne #0044A41B                         ;#0044A3E5: 165 34                     v  00 00  1  13      
    mov rcx,3                             ;#0044A3E7: 48:307301 03000000         uv 02 00  1  14      
    mov rdx,1147                          ;#0044A3EE: 48:307302 7B040000         vu 04 00  1  14      
    call #004428DB (:%opFrame) (fatalN)   ;#0044A3F5: 350 E184FFFF               v  00 00  1  15      
    mov rdi,[rbp+40] (prevebp)            ;#0044A3FA: 48:213175 28               uv 80 20  1  16      
    mov rax,[rdi-72]                      ;#0044A3FE: 48:213107 B8               uv 01 80  1  19 80 *80*
    mov [rbp] (level),rax                 ;#0044A402: 48:211105 00               uv 00 21  1  20 01   
    mov qword[rbp-8] (errcode),74         ;#0044A406: 48:307105 F8 4A000000      vu 00 20  1  20      
    mov qword[retaddr],#0044A41B          ;#0044A40E: 48:307105 20 1BA44400      uv 00 20  1  21      
    jmp #0044A360 (code:fatalN)           ;#0044A416: 351 45FFFFFF               v  00 00  1  21      
;   408         if fname[1]='+' then
    mov rdi,1                             ;#0044A41B: 48:307307 01000000         uv 80 00  1  22      
    mov rsi,[rbp-8] (fname)               ;#0044A422: 48:213165 F8               vu 40 20  1  22      
    mov rdx,1189                          ;#0044A426: 48:307302 A5040000         uv 04 00  1  23      
    call #00441762 (:%pSubse1is)          ;#0044A42D: 350 3073FFFF               v  00 00  1  23      
    cmp rax,43                            ;#0044A432: 48:203370 2B               uv 00 01  1  24      
    jne #0044A4C9                         ;#0044A436: 017205 8D000000            v  00 00  1  24      
;   409             convention = CDECL
    mov qword[rbp-48] (convention),2      ;#0044A43C: 48:307105 D0 02000000      uv 00 20  1  25      
;   410 --          if nlen<=1 then fatal(e74dcfpe) end if
;   411             if nlen<=1 then fatalN(level,e74dcfpe) end if
    mov rcx,[rbp-32] (nlen)               ;#0044A444: 48:213115 E0               vu 02 20  1  25      
    cmp rcx,1                             ;#0044A448: 48:203371 01               uv 00 02  1  26      
    jg #0044A482                          ;#0044A44C: 177 34                     v  00 00  1  26      
    mov rcx,3                             ;#0044A44E: 48:307301 03000000         uv 02 00  1  27      
    mov rdx,1147                          ;#0044A455: 48:307302 7B040000         vu 04 00  1  27      
    call #004428DB (:%opFrame) (fatalN)   ;#0044A45C: 350 7A84FFFF               v  00 00  1  28      
    mov rdi,[rbp+40] (prevebp)            ;#0044A461: 48:213175 28               uv 80 20  1  29      
    mov rax,[rdi-72]                      ;#0044A465: 48:213107 B8               uv 01 80  1  32 80 *80*
    mov [rbp] (level),rax                 ;#0044A469: 48:211105 00               uv 00 21  1  33 01   
    mov qword[rbp-8] (errcode),74         ;#0044A46D: 48:307105 F8 4A000000      vu 00 20  1  33      
    mov qword[retaddr],#0044A482          ;#0044A475: 48:307105 20 82A44400      uv 00 20  1  34      
    jmp #0044A360 (code:fatalN)           ;#0044A47D: 351 DEFEFFFF               v  00 00  1  34      
;   412             if atom(lib) then
;   413                 if nlen=2 and sequence(name[2]) then
    mov rdi,[rbp-32] (nlen)               ;#0044A482: 48:213175 E0               uv 80 20  1  35      
    cmp rdi,2                             ;#0044A486: 48:203377 02               uv 00 80  1  36 80   
    jne #0044A4A7                         ;#0044A48A: 165 1B                     v  00 00  1  36      
    mov rdi,2                             ;#0044A48C: 48:307307 02000000         uv 80 00  1  37      
    lea rcx,[rbp-88] (symtab[1199])       ;#0044A493: 48:215115 A8               vu 02 20  1  37      
    mov rsi,[rbp-40] (name)               ;#0044A497: 48:213165 D8               uv 40 20  1  38      
    mov rdx,1193                          ;#0044A49B: 48:307302 A9040000         vu 04 00  1  38      
    call #00441675 (:%pSubse1)            ;#0044A4A2: 350 CE71FFFF               v  00 00  1  39      
;   414                     -- eg {'+',"fred"} (RDS Eu incompatible)
;   415                     name = name[2]
;   416                 else
;   417                     -- "+fred" format                   
;   418                     name = name[2..-1]
    lea rax,[rbp-40] (name)               ;#0044A4A7: 48:215105 D8               uv 01 20  1  40      
    mov rdi,2                             ;#0044A4AB: 48:307307 02000000         vu 80 00  1  40      
    mov rcx,-1                            ;#0044A4B2: 48:307301 FFFFFFFF         uv 02 00  1  41      
    mov rsi,[rbp-40] (name)               ;#0044A4B9: 48:213165 D8               vu 40 20  1  41      
    mov rdx,1193                          ;#0044A4BD: 48:307302 A9040000         uv 04 00  1  42      
    call #00441212 (:%pSubsss)            ;#0044A4C4: 350 496DFFFF               v  00 00  1  42      
;   419                 end if
;   420             else
;   421                 -- CDECL m/c must always be {'+',<atom addr>}
;   422 --              if nlen!=2 then fatal(e74dcfpe) end if
;   423                 if nlen!=2 then fatalN(level,e74dcfpe) end if
;   424                 name = name[2]
;   425 --              if not atom(name) then fatal(e74dcfpe) end if
;   426                 if not atom(name) then fatalN(level,e74dcfpe) end if
;   427             end if
;   428         end if
;   429     end if
;   430 --  addr = 0
;   431     if sequence(lib) then
;   432         if length(lib)
;   433         or not atom(name) then
;   434 --          fatal(e74dcfpe)
;   435             fatalN(level,e74dcfpe)
;   436         end if
;   437         addr = name
;   438     else -- atom(lib)
;   439         if not sequence(name) then
    mov rcx,[rbp-40] (name)               ;#0044A4C9: 48:213115 D8               uv 02 20  1  43      
    mov r15,h4                            ;#0044A4CD: 49:277 0000000000000040    vu 8000 00  1  43      
    cmp rcx,r15                           ;#0044A4D7: 4C:071371                  uv 00 8002  1  44      
    jl #0044A4E3                          ;#0044A4DA: 174 07                     v  00 00  1  44      
    test byte[rbx+rcx*4-1],#80            ;#0044A4DC: 366104213 FF 80            u  00 0A  2  45      
    jne #0044A519                         ;#0044A4E1: 165 36                     v  00 00  1  46      
;   440 --          fatal(e74dcfpe)
;   441             fatalN(level,e74dcfpe)
    mov rcx,3                             ;#0044A4E3: 48:307301 03000000         uv 02 00  1  47      
    mov rdx,1147                          ;#0044A4EA: 48:307302 7B040000         vu 04 00  1  47      
    call #004428DB (:%opFrame) (fatalN)   ;#0044A4F1: 350 E583FFFF               v  00 00  1  48      
    mov rdi,[rbp+40] (prevebp)            ;#0044A4F6: 48:213175 28               uv 80 20  1  49      
    mov rax,[rdi-72]                      ;#0044A4FA: 48:213107 B8               uv 01 80  1  52 80 *80*
    mov [rbp] (level),rax                 ;#0044A4FE: 48:211105 00               uv 00 21  1  53 01   
    mov qword[rbp-8] (errcode),74         ;#0044A502: 48:307105 F8 4A000000      vu 00 20  1  53      
    mov qword[retaddr],#0044A517          ;#0044A50A: 48:307105 20 17A54400      uv 00 20  1  54      
    jmp #0044A360 (code:fatalN)           ;#0044A512: 351 49FEFFFF               v  00 00  1  54      
    jmp #0044A58F                         ;#0044A517: 353 76                     v  00 00  1  55      
;   442         elsif not string(name) then
    cmp byte[rbx+rcx*4-1],#82             ;#0044A519: 200174213 FF 82            u  00 0A  2  56      
    je #0044A58F                          ;#0044A51E: 164 6F                     v  00 00  1  57      
;   443             name = toString(name,ASALPHANUM,e74dcfpe,3) --DEV better messsage
    mov rcx,9                             ;#0044A520: 48:307301 09000000         uv 02 00  1  58      
    mov rdx,1152                          ;#0044A527: 48:307302 80040000         vu 04 00  1  58      
    call :%opFrame (toString)             ;#0044A52E: 350 A883FFFF               v  00 00  1  59      
    mov rdi,[rbp+40] (prevebp)            ;#0044A533: 48:213175 28               uv 80 20  1  60      
    mov rax,[rdi-40]                      ;#0044A537: 48:213107 D8               uv 01 80  1  63 80 *80*
    mov [rdi-40],r15                      ;#0044A53B: 4C:211177 D8               vu 00 8080  1  63      
    mov [rbp] (name),rax                  ;#0044A53F: 48:211105 00               uv 00 21  1  64      
    mov qword[rbp-8] (asAlphanum),1       ;#0044A543: 48:307105 F8 01000000      vu 00 20  1  64      
    mov qword[rbp-16] (errcode),74        ;#0044A54B: 48:307105 F0 4A000000      uv 00 20  1  65      
    mov qword[rbp-24] (level),3           ;#0044A553: 48:307105 E8 03000000      vu 00 20  1  65      
    mov qword[retaddr],#0044A568          ;#0044A55B: 48:307105 20 68A54400      uv 00 20  1  66      
    jmp #0044A1D9 (code:toString)         ;#0044A563: 351 71FCFFFF               v  00 00  1  66      
    push rax                              ;#0044A568: 120                        uv 00 01  1  67      
    mov rdi,[rbp-40] (name)               ;#0044A569: 48:213175 D8               vu 80 20  1  67      
    mov r15,h4                            ;#0044A56D: 49:277 0000000000000040    uv 8000 00  1  68      
    cmp rdi,r15                           ;#0044A577: 4C:071377                  uv 00 8080  1  69 8000   
    jle #0044A58C                         ;#0044A57A: 176 10                     v  00 00  1  69      
    sub qword[rbx+rdi*4-16],1             ;#0044A57C: 48:203154273 F0 01         u  00 88  3  70      
    jne #0044A58C                         ;#0044A582: 165 08                     v  00 00  1  72      
    mov rdx,rdi                           ;#0044A584: 48:213327                  uv 04 80  1  73      
    call #004422DA (:%pDealloc)           ;#0044A587: 350 4E7DFFFF               v  00 00  1  73      
    pop dword[rbp-40] (name)              ;#0044A58C: 217105 D8                  np 00 20  3  74      
;   444         end if
;   445         #ilASM{
;   446             [32]
;   447 --              lea edi,[addr]
;   448                 mov eax,[lib]
;   449                 mov edx,[name]
;   450                 --
;   451                 --  If lib is stored as an atom (presumably because it is > 31 bits),
;   452                 --  convert it to 32bits in eax. Likewise convert the string ref to
;   453                 --  a raw address of the string, by shifting it left two bits.
;   454                 --
;   455                 cmp eax,h4  --DEV :%pLoadMint
;   456                 jl @f
;   457                     sub esp,8
;   458                     fld qword[ebx+eax*4]
;   459                     fistp qword[esp]
;   460                     pop eax
;   461                     add esp,4
;   462               @@:
;   463                 shl edx,2
;   464             [PE32]
;   465                 push edx                            -- lpProcName
;   466                 push eax                            -- hModule
;   467                 call "kernel32.dll","GetProcAddress"
;   468             [ELF32]
;   469                 pop al
;   470             [32]
;   471                 push ebx    --(=0, for fild qword)
;   472                 push eax
;   473                 lea edi,[addr]
;   474                 fild qword[esp]
;   475                 add esp,8
;   476                 call :%pStoreFlt                    -- ([edi]:=ST0)
;   477             [PE64]
;   478                 mov rcx,rsp -- put 2 copies of rsp onto the stack...
                        mov rcx,rsp       ;#0044A58F: 48:213314                  uv 02 10  1  77      
;   479                 push rsp
                        push rsp          ;#0044A592: 48:124                     vu 00 10  1  77      
;   480                 push rcx
                        push rcx          ;#0044A594: 48:121                     uv 00 02  1  78      
;   481                 or rsp,8    -- [rsp] is now 1st or 2nd copy:
                        or rsp,8          ;#0044A596: 48:203314 08               vu 10 10  1  78      
;   482                             -- if on entry rsp was xxx8: both copies remain on the stack
;   483                             -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;   484                             -- obviously rsp is now xxx8, whatever alignment we started with
;   485 
;   486                 mov rcx,[lib]
                        mov rcx,[rbp] (lib)  ;#0044A59A: 48:213115 00               uv 02 20  1  79      
;   487                 mov r15,h4
                        mov r15,h4        ;#0044A59E: 49:277 0000000000000040    vu 8000 00  1  79      
;   488                 sub rsp,8*5                         -- minimum 4 param shadow space, and align
                        sub rsp,40        ;#0044A5A8: 48:203354 28               uv 10 10  1  80      
;   489                 mov rdx,[name]
                        mov rdx,[rbp-40] (name)  ;#0044A5AC: 48:213125 D8               vu 04 20  1  80      
;   490                 --
;   491                 --  If lib is stored as an atom (presumably because it is > 63 bits),
;   492                 --  convert it to 64bits in rax. Likewise convert the string ref to
;   493                 --  a raw address of the string, by shifting it left two bits.
;   494                 --
;   495                 cmp rcx,r15
                        cmp rcx,r15       ;#0044A5B0: 49:073317                  uv 00 8002  1  81      
;   496                 jl @f
                        jl #0044A5BF      ;#0044A5B3: 174 0A                     v  00 00  1  81      
;   497                     fld tbyte[rbx+rcx*4]
                            fld tbyte[rbx+rcx*4]  ;#0044A5B5: 333054213                  np 00 0A  3  82      
;   498                     fistp qword[rsp]
                            fistp qword[rsp]  ;#0044A5B8: 337074044                  np 00 10  6  85      
;   499                     mov rcx,[rsp]
                            mov rcx,[rsp]  ;#0044A5BB: 48:213014044               uv 02 10  1  91      
;   500               @@:
;   501                 shl rdx,2                           -- lpProcName
                        shl rdx,2         ;#0044A5BF: 48:301342 02               u  04 04  1  92      
;   502                 -- (rcx already set)                -- hModule
;   503                 call "kernel32.dll","GetProcAddress"
                        call [#004010A8] (GetProcAddress)  ;#0044A5C3: 377025 DF6AFBFF            np 00 00  2  93      
;   504                 mov [rsp],rax
                        mov [rsp],rax     ;#0044A5C9: 48:211004044               uv 00 11  1  95      
;   505                 lea rdi,[addr]
                        lea rdi,[rbp-56] (addr)  ;#0044A5CD: 48:215175 C8               vu 80 20  1  95      
;   506                 fild qword[rsp]
                        fild qword[rsp]   ;#0044A5D1: 337054044                  np 00 10  3  96      
;   507 --              add rsp,8*5
;   508 --              pop rsp
;   509                 mov rsp,[rsp+8*5]   -- equivalent to the add/pop
                        mov rsp,[rsp+40]  ;#0044A5D4: 48:213144044 28            uv 10 10  1  99      
;   510                 call :%pStoreFlt                    -- ([edi]:=ST0)
                        call #004421B0 (:%pStoreFlt)  ;#0044A5D9: 350 D27BFFFF               v  00 00  1  99      
;   511             [ELF32]
;   512                 pop al
;   513             []
;   514               }
;   515         if addr=NULL then return -1 end if
    xor rdi,rdi                           ;#0044A5DE: 48:061377                  uv 80 80  1 100      
    mov rax,[rbp-56] (addr)               ;#0044A5E1: 48:213105 C8               vu 01 20  1 100      
    mov rsi,38                            ;#0044A5E5: 48:307306 26000000         uv 40 00  1 101      
    mov rdx,1195                          ;#0044A5EC: 48:307302 AB040000         vu 04 00  1 101      
    call #0043FAF6 (:%opJccE)             ;#0044A5F3: 350 FE54FFFF               v  00 00  1 102      
    jne #0044A606                         ;#0044A5F8: 165 0C                     v  00 00  1 103      
    mov rax,-1                            ;#0044A5FA: 48:307300 FFFFFFFF         uv 01 00  1 104      
    jmp #0044298D (:%opRetf)              ;#0044A601: 351 8783FFFF               v  00 00  1 104      
;   516     end if
;   517 
;   518     --
;   519     -- Validate the args and return type
;   520     --
;   521     for i=1 to length(args) do
    mov rsi,[rbp-16] (args)               ;#0044A606: 48:213165 F0               uv 40 20  1 105      
    mov rcx,[rbx+rsi*4-24]                ;#0044A60A: 48:48:213114263 E8         uv 02 48  1 108 40 *40*
    mov [rbp-80] (symtab[1198]),rcx       ;#0044A610: 48:211115 B0               uv 00 22  1 109 02   
    mov qword[rbp-96] (i),1               ;#0044A614: 48:307105 A0 01000000      vu 00 20  1 109      
    cmp rcx,1                             ;#0044A61C: 48:201371 01000000         uv 00 02  1 110      
    jl #0044A6A3                          ;#0044A623: 174 7E                     v  00 00  1 110      
;   522         check(args[i],2+(return_type=0))
    mov rdi,[rbp-96] (i)                  ;#0044A625: 48:213175 A0               uv 80 20  1 111      
    mov rsi,[rbp-16] (args)               ;#0044A629: 48:213165 F0               vu 40 20  1 111      
    mov rdx,1190                          ;#0044A62D: 48:307302 A6040000         uv 04 00  1 112      
    call #00441744 (:%pSubse1ip)          ;#0044A634: 350 0B71FFFF               v  00 00  1 112      
    mov [rbp-88] (symtab[1199]),rax       ;#0044A639: 48:211105 A8               uv 00 21  1 113      
    mov rcx,[rbp-24] (return_type)        ;#0044A63D: 48:213115 E8               vu 02 20  1 113      
    xor eax,eax                           ;#0044A641: 061300                     uv 01 01  1 114      
    cmp rcx,0                             ;#0044A643: 48:203371 00               vu 00 02  1 114      
    sete al                               ;#0044A647: 017224300                  np 01 00  2 115      
    mov [rbp-104] (symtab[1201]),rax      ;#0044A64A: 48:211105 98               uv 00 21  1 117      
    mov qword[rbp-112] (symtab[1202]),2   ;#0044A64E: 48:307105 90 02000000      vu 00 20  1 117      
    mov rcx,2                             ;#0044A656: 48:307301 02000000         uv 02 00  1 118      
    mov rdx,1175                          ;#0044A65D: 48:307302 97040000         vu 04 00  1 118      
    call #004428DB (:%opFrame) (check)    ;#0044A664: 350 7282FFFF               v  00 00  1 119      
    mov rdi,[rbp+40] (prevebp)            ;#0044A669: 48:213175 28               uv 80 20  1 120      
    mov rax,[rdi-88]                      ;#0044A66D: 48:213107 A8               uv 01 80  1 123 80 *80*
    mov [rbp] (o),rax                     ;#0044A671: 48:211105 00               uv 00 21  1 124 01   
    mov rdi,[rbp+40] (prevebp)            ;#0044A675: 48:213175 28               vu 80 20  1 124      
    mov rax,[rdi-112]                     ;#0044A679: 48:213107 90               uv 01 80  1 127    *80*
    mov [rbp-8] (level),rax               ;#0044A67D: 48:211105 F8               uv 00 21  1 128 01   
    mov qword[retaddr],#0044A68E          ;#0044A681: 48:307105 20 8EA64400      vu 00 20  1 128      
    jmp #0044A808 (code:check)            ;#0044A689: 351 7A010000               v  00 00  1 129      
;   523     end for
    mov rdi,[rbp-96] (i)                  ;#0044A68E: 48:213175 A0               uv 80 20  1 130      
    mov rsi,[rbp-80] (symtab[1198])       ;#0044A692: 48:213165 B0               vu 40 20  1 130      
    add rdi,1                             ;#0044A696: 48:203307 01               uv 80 80  1 131      
    cmp rdi,rsi                           ;#0044A69A: 48:073376                  uv 00 C0  1 132 80   
    mov [rbp-96] (i),rdi                  ;#0044A69D: 48:211175 A0               vu 00 A0  1 132      
    jle #0044A625                         ;#0044A6A1: 176 82                     v  00 00  1 133      
;   524     if return_type then
;   525         check(return_type,2)
    mov rcx,2                             ;#0044A6A3: 48:307301 02000000         uv 02 00  1 134      
    mov rdx,1175                          ;#0044A6AA: 48:307302 97040000         vu 04 00  1 134      
    call #004428DB (:%opFrame) (check)    ;#0044A6B1: 350 2582FFFF               v  00 00  1 135      
    mov rdi,[rbp+40] (prevebp)            ;#0044A6B6: 48:213175 28               uv 80 20  1 136      
    mov rax,[rdi-24]                      ;#0044A6BA: 48:213107 E8               uv 01 80  1 139 80 *80*
    mov [rbp] (o),rax                     ;#0044A6BE: 48:211105 00               uv 00 21  1 140 01   
    mov qword[rbp-8] (level),2            ;#0044A6C2: 48:307105 F8 02000000      vu 00 20  1 140      
    mov qword[retaddr],#0044A6D7          ;#0044A6CA: 48:307105 20 D7A64400      uv 00 20  1 141      
    jmp #0044A808 (code:check)            ;#0044A6D2: 351 31010000               v  00 00  1 141      
;   526     end if
;   527 
;   528 --DEV locking...
;   529 --  enter_cs()
;   530     if not tinit then
    mov rcx,[#004032D8] (tinit)           ;#0044A6D7: 48:213015 FA8BFBFF         uv 02 00  1 142      
    test rcx,rcx                          ;#0044A6DE: 48:205311                  uv 00 02  1 143 02   
    jne #0044A734                         ;#0044A6E1: 165 51                     v  00 00  1 143      
;   531         table = {}
    mov rsi,qword[#004022C8]              ;#0044A6E3: 48:213065 DE7BFBFF         uv 40 00  1 144      
    mov rdx,[#004032D0] (table)           ;#0044A6EA: 48:213025 DF8BFBFF         vu 04 00  1 144      
    mov r15,h4                            ;#0044A6F1: 49:277 0000000000000040    uv 8000 00  1 145      
    cmp rsi,r15                           ;#0044A6FB: 4C:071376                  uv 00 8040  1 146 8000   
    jl #0044A706                          ;#0044A6FE: 174 06                     v  00 00  1 146      
    add qword[rbx+rsi*4-16],1             ;#0044A700: 48:203104263 F0 01         u  00 48  3 147      
    mov [#004032D0] (table),rsi           ;#0044A706: 48:211065 C38BFBFF         vu 00 40  1 149      
    mov r15,h4                            ;#0044A70D: 49:277 0000000000000040    uv 8000 00  1 150      
    cmp rdx,r15                           ;#0044A717: 4C:071372                  uv 00 8004  1 151 8000   
    jle #0044A729                         ;#0044A71A: 176 0D                     v  00 00  1 151      
    sub qword[rbx+rdx*4-16],1             ;#0044A71C: 48:203154223 F0 01         u  00 0C  3 152      
    jne #0044A729                         ;#0044A722: 165 05                     v  00 00  1 154      
    call #004422DA (:%pDealloc)           ;#0044A724: 350 B17BFFFF               v  00 00  1 155      
;   532         tinit = 1
    mov qword[#004032D8] (tinit),1        ;#0044A729: 48:307005 A48BFBFF 01000000 uv 00 00  1 156      
;   533     end if
;   534 --DEV delete_routine? [probably not rqd]
;   535     table = append(table,{name,addr,args,return_type,convention})
    lea rax,[rbp-120] (symtab[1203])      ;#0044A734: 48:215105 88               vu 01 20  1 156      
    mov rdx,5                             ;#0044A738: 48:307302 05000000         uv 04 00  1 157      
    push #0044A7B3                        ;#0044A73F: 150 B3A74400               vu 00 00  1 157      
    push rax                              ;#0044A744: 120                        uv 00 01  1 158      
    push qword[rbp-48] (convention)       ;#0044A745: 377165 D0                  np 00 20  2 159      
    push 16777220                         ;#0044A748: 150 04000001               uv 00 00  1 161      
    mov rdi,[rbp-16] (args)               ;#0044A74D: 48:213175 F0               vu 80 20  1 161      
    mov r15,h4                            ;#0044A751: 49:277 0000000000000040    uv 8000 00  1 162      
    cmp rdi,r15                           ;#0044A75B: 4C:071377                  uv 00 8080  1 163 8000   
    jl #0044A76B                          ;#0044A75E: 174 0B                     v  00 00  1 163      
    add qword[rbx+rdi*4-16],1             ;#0044A760: 48:203104273 F0 01         u  00 88  3 164      
    cmp eax,1190                          ;#0044A766: 075 A6040000               vu 00 01  1 166      
    push rdi                              ;#0044A76B: 127                        uv 00 80  1 167      
    mov rax,[rbp-56] (addr)               ;#0044A76C: 48:213105 C8               vu 01 20  1 167      
    mov r15,h4                            ;#0044A770: 49:277 0000000000000040    uv 8000 00  1 168      
    cmp rax,r15                           ;#0044A77A: 4C:071370                  uv 00 8001  1 169 8000   
    jl #0044A78A                          ;#0044A77D: 174 0B                     v  00 00  1 169      
    add qword[rbx+rax*4-16],1             ;#0044A77F: 48:203104203 F0 01         u  00 09  3 170      
    cmp eax,1195                          ;#0044A785: 075 AB040000               vu 00 01  1 172      
    push rax                              ;#0044A78A: 120                        uv 00 01  1 173      
    mov rcx,[rbp-40] (name)               ;#0044A78B: 48:213115 D8               vu 02 20  1 173      
    mov r15,h4                            ;#0044A78F: 49:277 0000000000000040    uv 8000 00  1 174      
    cmp rcx,r15                           ;#0044A799: 4C:071371                  uv 00 8002  1 175 8000   
    jl #0044A7A9                          ;#0044A79C: 174 0B                     v  00 00  1 175      
    add qword[rbx+rcx*4-16],1             ;#0044A79E: 48:203104213 F0 01         u  00 0A  3 176      
    cmp eax,1193                          ;#0044A7A4: 075 A9040000               vu 00 01  1 178      
    push rcx                              ;#0044A7A9: 121                        uv 00 02  1 179      
    mov rdi,[rbp-120] (symtab[1203])      ;#0044A7AA: 48:213175 88               vu 80 20  1 179      
    jmp #004404BD (:%pMkSq)               ;#0044A7AE: 351 0A5DFFFF               v  00 00  1 180      
    mov rsi,[#004032D0] (table)           ;#0044A7B3: 48:213065 168BFBFF         uv 40 00  1 181      
    mov r15,h4                            ;#0044A7BA: 49:277 0000000000000040    vu 8000 00  1 181      
    cmp rsi,r15                           ;#0044A7C4: 4C:071376                  uv 00 8040  1 182      
    jne #0044A7D5                         ;#0044A7C7: 165 0C                     v  00 00  1 182      
    mov rsi,1186                          ;#0044A7C9: 48:307306 A2040000         uv 40 00  1 183      
    call #00442D75 (:%pUnassigned)        ;#0044A7D0: 350 A085FFFF               v  00 00  1 183      
    lea rdx,[#004032D0] (table)           ;#0044A7D5: 48:215025 F48AFBFF         uv 04 00  1 184      
    lea rdi,[#004032D0] (table)           ;#0044A7DC: 48:215075 ED8AFBFF         vu 80 00  1 184      
    lea rcx,[rbp-120] (symtab[1203])      ;#0044A7E3: 48:215115 88               uv 02 20  1 185      
    xor rax,rax                           ;#0044A7E7: 48:061300                  vu 01 01  1 185      
    call #0043FC15 (:%opApnd)             ;#0044A7EA: 350 2654FFFF               v  00 00  1 186      
;   536     res = length(table)
    mov rax,[#004032D0] (table)           ;#0044A7EF: 48:213005 DA8AFBFF         uv 01 00  1 187      
    mov rcx,[rbx+rax*4-24]                ;#0044A7F6: 48:48:213114203 E8         uv 02 09  1 190 01 *01*
    mov [rbp-64] (res),rcx                ;#0044A7FC: 48:211115 C0               uv 00 22  1 191 02   
;   537 --  leave_cs()
;   538     return res
    mov rax,rcx                           ;#0044A800: 48:211310                  vu 01 02  1 191      
    jmp #0044298D (:%opRetf)              ;#0044A803: 351 8581FFFF               v  00 00  1 192      
;   539 end function
;   540 
;   541 global function define_c_proc(object lib, object name, sequence args)
;   542 --
;   543 -- Define the characteristics of either:
;   544 --  * a C function with a VOID return type / ignored return value, or
;   545 --  * a machine-code routine at a given address.
;   546 --
;   547     return define_c_func(lib, name, args, 0)
;   548 end function
;   549 
;   550 global function define_c_var(atom lib, sequence name)
;   551 --
;   552 -- Get the address of a public C variable defined in a dll or .so file.
;   553 --
;   554 atom addr
;   555 --DEV factor this out of define_c_func?
;   556     if not string(name) then
;   557         name = toString(name,ASALPHANUM,e74dcfpe,3)
;   558     end if
;   559     #ilASM{
;   560         [32]
;   561 --          lea edi,[addr]
;   562             mov eax,[lib]
;   563             mov edx,[name]
;   564             cmp eax,h4 --DEV :%pLoadMint
;   565             jl @f
;   566                 sub esp,8
;   567                 fld qword[ebx+eax*4]
;   568                 fistp qword[esp]
;   569                 pop eax
;   570                 add esp,4
;   571           @@:
;   572             shl edx,2
;   573         [PE32]
;   574             push edx
;   575             push eax
;   576             call "kernel32.dll","GetProcAddress"
;   577         [ELF32]
;   578             pop al
;   579         [32]
;   580             push ebx    --(=0, for fild qword)
;   581             push eax
;   582             lea edi,[addr]
;   583             fild qword[esp]
;   584             add esp,8
;   585             call :%pStoreFlt                    -- ([edi]:=ST0)
;   586         [PE64]
;   587             mov rcx,rsp -- put 2 copies of rsp onto the stack...
;   588             push rsp
;   589             push rcx
;   590             or rsp,8    -- [rsp] is now 1st or 2nd copy:
;   591                         -- if on entry rsp was xxx8: both copies remain on the stack
;   592                         -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;   593                         -- obviously rsp is now xxx8, whatever alignment we started with
;   594             mov rcx,[lib]
;   595             mov r15,h4
;   596             sub rsp,8*5                         -- minimum 4 param shadow space, and align
;   597             mov rdx,[name]
;   598             cmp rcx,r15
;   599             jl @f
;   600                 fld tbyte[rbx+rcx*4]
;   601                 fistp qword[rsp]
;   602                 mov rcx,[rsp]
;   603           @@:
;   604             shl rdx,2                           -- lpProcName
;   605             -- (rcx already set)                -- hModule
;   606             call "kernel32.dll","GetProcAddress"
;   607             mov [rsp],rax
;   608             lea rdi,[addr]
;   609             fild qword[rsp]
;   610 --          add rsp,8*5
;   611 --          pop rsp
;   612             mov rsp,[rsp+8*5]   -- equivalent to the add/pop
;   613             call :%pStoreFlt                    -- ([edi]:=ST0)
;   614         [ELF64]
;   615             pop al
;   616         []
;   617           }
;   618 -- we may want this?:
;   619 --  if addr=0 then return -1 end if
;   620     return addr
;   621 end function
;   622 
;   623 --  ;DEV better:
;   624 --  ;   save symtab[i][S_il],
;   625 --  ;   addr threadstack[-symtab[i-1][S_Tidx]]
;   626 --  ;   [ebpidx] (as current)
;   627 --  ;   save/set opFrame stuff: addr first(eax), N(ecx), edi (routineNo)
;   628 --  ;   
;   629 
;   630 -- keep these matching pglobals.e!
;   631 constant S_NTyp     = 2,
;   632          S_sig      = 7,    -- routine signature, eg {'F',T_integer} (nb S_sig must be = S_vtype)
;   633 --       S_Parm1    = 8,    -- first parameter. (idx to symtab, then follow S_Slink)
;   634          S_ParmN    = 9,    -- min no of parameters. (max is length(S_sig)-1))
;   635          S_Ltot     = 10,   -- total no of parameters + locals (for stack frame allocation)
;   636          S_il       = 11,   -- intermediate code (also backpatch list)
;   637 --       S_Tidx     = 9,
;   638          S_Type     = 6,
;   639          S_Func     = 7,
;   640          S_Proc     = 8,
;   641          T_atom     = 3,
;   642          T_object   = 15,
;   643          T_const1   = 26,
;   644          DEBUG      = 0
;   645 
;   646 
;   647 --DEV not thread safe (locking rqd). Also, a cleanup (or delete) routine might be nice...
;   648 sequence previd,    -- table of all previous call_backs created (id)
;   649          prevcb     -- result for each ""
;   650 integer pinit
;   651         pinit = 0
;   652 
;   653 procedure Pinit()
;   654     previd = {}
    mov rdi,qword[#004022C8]              ;#0043B0B6: 48:213075 0B72FCFF         uv 80 00  1   1      
    mov rdx,[#00403340] (previd)          ;#0043B0BD: 48:213025 7C82FCFF         vu 04 00  1   1      
    mov r15,h4                            ;#0043B0C4: 49:277 0000000000000040    uv 8000 00  1   2      
    cmp rdi,r15                           ;#0043B0CE: 4C:071377                  uv 00 8080  1   3 8000   
    jl #0043B0D9                          ;#0043B0D1: 174 06                     v  00 00  1   3      
    add qword[rbx+rdi*4-16],1             ;#0043B0D3: 48:203104273 F0 01         u  00 88  3   4      
    mov [#00403340] (previd),rdi          ;#0043B0D9: 48:211075 6082FCFF         vu 00 80  1   6      
    mov r15,h4                            ;#0043B0E0: 49:277 0000000000000040    uv 8000 00  1   7      
    cmp rdx,r15                           ;#0043B0EA: 4C:071372                  uv 00 8004  1   8 8000   
    jle #0043B0FC                         ;#0043B0ED: 176 0D                     v  00 00  1   8      
    sub qword[rbx+rdx*4-16],1             ;#0043B0EF: 48:203154223 F0 01         u  00 0C  3   9      
    jne #0043B0FC                         ;#0043B0F5: 165 05                     v  00 00  1  11      
    call #004422DA (:%pDealloc)           ;#0043B0F7: 350 DE710000               v  00 00  1  12      
;   655     prevcb = {}
    mov rsi,qword[#004022C8]              ;#0043B0FC: 48:213065 C571FCFF         uv 40 00  1  13      
    mov rdx,[#00403348] (prevcb)          ;#0043B103: 48:213025 3E82FCFF         vu 04 00  1  13      
    mov r15,h4                            ;#0043B10A: 49:277 0000000000000040    uv 8000 00  1  14      
    cmp rsi,r15                           ;#0043B114: 4C:071376                  uv 00 8040  1  15 8000   
    jl #0043B11F                          ;#0043B117: 174 06                     v  00 00  1  15      
    add qword[rbx+rsi*4-16],1             ;#0043B119: 48:203104263 F0 01         u  00 48  3  16      
    mov [#00403348] (prevcb),rsi          ;#0043B11F: 48:211065 2282FCFF         vu 00 40  1  18      
    mov r15,h4                            ;#0043B126: 49:277 0000000000000040    uv 8000 00  1  19      
    cmp rdx,r15                           ;#0043B130: 4C:071372                  uv 00 8004  1  20 8000   
    jle #0043B142                         ;#0043B133: 176 0D                     v  00 00  1  20      
    sub qword[rbx+rdx*4-16],1             ;#0043B135: 48:203154223 F0 01         u  00 0C  3  21      
    jne #0043B142                         ;#0043B13B: 165 05                     v  00 00  1  23      
    call #004422DA (:%pDealloc)           ;#0043B13D: 350 98710000               v  00 00  1  24      
;   656     pinit = 1
    mov qword[#00403350] (pinit),1        ;#0043B142: 48:307005 0382FCFF 01000000 uv 00 00  1  25      
    jmp #0044298D (:%opRetf)              ;#0043B14D: 351 3B780000               v  00 00  1  25      
;   657 end procedure
;   658 if not pinit then Pinit() end if
    mov rcx,[#00403350] (pinit)           ;#0043B152: 48:213015 F781FCFF         uv 02 00  1   1      
    test rcx,rcx                          ;#0043B159: 48:205311                  uv 00 02  1   2 02   
    jne #0043B1B6                         ;#0043B15C: 165 58                     v  00 00  1   2      
    xor rcx,rcx                           ;#0043B15E: 48:061311                  uv 02 02  1   3      
    mov rdx,1219                          ;#0043B161: 48:307302 C3040000         vu 04 00  1   3      
    call #004428DB (:%opFrame) (Pinit)    ;#0043B168: 350 6E770000               v  00 00  1   4      
    mov qword[retaddr],#0043B17A          ;#0043B16D: 48:307105 20 7AB14300      uv 00 20  1   5      
    jmp #0043B0B6 (code:Pinit)            ;#0043B175: 351 3CFFFFFF               v  00 00  1   5      
;   659 
;   660     --DEV not thread safe!!
;   661     -- save ebp (/4 to avoid any 31-bit integer issues).
;   662     -- set by every call()/c_func()/c_proc(), which each have was_ebp_xx,
;   663     --  and used in cbhandler (below) /reset to 0 before resuming Phix code.
;   664     -- (ebp is the current frame/callstack, in case you didn't know.)
;   665     ----DEV use TLS:
;   666 integer ebp_save = 0    -- stored /4 to avoid any 31-bit integer issues
;   667     --
;   668     #ilASM{ jmp :fin
                    jmp #0043B1B6         ;#0043B17A: 353 3A                     v  00 00  1   6      
;   669     [32]
;   670       :%save_ebp
;   671         mov edx,ebp
;   672         mov eax,[ebp_save]
;   673         shr edx,2
;   674       :%restore_ebp
;   675         mov [ebp_save],edx
;   676     [64]
;   677       :%save_rbp
;   678         mov rdx,rbp
                mov rdx,rbp               ;#0043B17C: 48:213325                  uv 04 20  1   7      
;   679         mov rax,[ebp_save]
                mov rax,[#00403358] (ebp_save)  ;#0043B17F: 48:213005 D281FCFF         vu 01 00  1   7      
;   680         shr rdx,2
                shr rdx,2                 ;#0043B186: 48:301352 02               u  04 04  1   8      
;   681       :%restore_rbp
;   682         mov [ebp_save],rdx
                mov [#00403358] (ebp_save),rdx  ;#0043B18A: 48:211025 C781FCFF         uv 00 04  1   9 04   
;   683     []
;   684         ret
                ret                       ;#0043B191: 303                        np 00 00  2  10      
;   685       ::fin
;   686 }
;   687 -- calling convention:
;   688 -- integer local_ebp
;   689 --  #ilASM{ call :%save_ebp
;   690 --          mov [local_ebp],eax
;   691 --  ... <some ilASM which might invoke a callback>
;   692 --          mov edx,[local_ebp]
;   693 --          call :%restore_ebp
;   694 --  }
;   695 -- These "guards" are used in c_func/c_proc/call, and therefore you need
;   696 --  the same if any ilASM is attempting anything similar.
;   697 -- You can put hll code between the save and restore, though it is
;   698 --  probably best to have such guards cover smallish blocks of code.
;   699 -- Note that while you /could/ just inline this where it is called from
;   700 --  in this source (pcfunc.e), the whole point is to have just the one 
;   701 --  place that needs modifying (eg to use TlsSetValue & TlsGetValue),
;   702 --  that is, on top of whatever mods cbhandler needs.
;   703 --
;   704 
;   705 global function call_back(object id)
;   706 --
;   707 -- Get a (32-bit) machine address for calling a routine
;   708 --
;   709 -- id should be a result from routine_id, or on Windows the same as part
;   710 --  of a {'+',id} pair, if the routine uses CDECL calling convention.
;   711 --
;   712 -- Note that all parameters must be declared as atoms, and will receive an      --DEV check/test this...
;   713 --  unsigned 32-bit value. Use "integer" instead of "atom" at your own risk;
;   714 --  eg -1, might, at best, appear as 4,294,967,295 (#FFFFFFFF), at worst it 
;   715 --  could be (especially if type checking/debug is turned off) a raw address
;   716 --  or bit-shifted Phix reference, which will undoubtedly trigger a machine
;   717 --  exception. If you find any kind of bug when using integer parameters on 
;   718 --  a call_back, the "fix" will be "use atom".
;   719 --
;   720 -- Repeated invocations of this routine do not "leak" memory
;   721 --  (unlike the RDS Eu version of this routine).
;   722 --
;   723 -- Technical point:
;   724 --  You should always "call" a call_back, rather than "jmp" to one, since
;   725 --  the code below expects a return address at the top of the stack, before 
;   726 --  any parameters. That may sound obvious, and is mentioned only in order
;   727 --  to specifically say that you cannot optimise "push push call ret" to
;   728 --  to "push push jmp", although "pop push push push jmp" might be ok.
;   729 --
;   730 integer k, siNTyp, sigi, noofparams
;   731 --integer d1234
;   732 sequence symtab, sig
;   733 object si
;   734 atom r
;   735 integer convention
;   736 
;   737     k = 0
;   738     if not pinit then
;   739         Pinit()
;   740     else
;   741         k = find(id,previd)
;   742     end if
;   743     if k=0 then
;   744 --DEV locking
;   745         previd = append(previd,id)
;   746         convention = STDCALL
;   747         if platform()!=WIN32 then
;   748             convention = CDECL
;   749         end if
;   750         if sequence(id) then
;   751             if length(id)!=2
;   752             or id[1]!='+'
;   753             or sequence(id[2]) then
;   754 --              fatal(e84cbpmbropr) -- call_back parameter must be routine_id or {'+',routine_id}
;   755                 fatalN(2,e84cbpmbropr) -- call_back parameter must be routine_id or {'+',routine_id}
;   756             end if
;   757             convention = CDECL
;   758             id = id[2]
;   759         end if
;   760 --      si = 1  -- callstack not rqd
;   761         #ilASM{
;   762             [32]
;   763                 lea edi,[symtab]
;   764                 call :%opGetST  -- [edi]:=symtab (see pStack.e)
;   765             [64]
;   766                 lea rdi,[symtab]
;   767                 call :%opGetST  -- [rdi]:=symtab (see pStack.e)
;   768             []
;   769               }
;   770         if not integer(id)
;   771         or id<=T_const1             -- (no real routines that far down there mate)
;   772         or id>length(symtab) then   -- (nor any "" "" after the end of the symtab!)
;   773 --          fatal(e72iri,id)
;   774             fatalN(2,e72iri,id)
;   775         end if
;   776         si = symtab[id]
;   777         if atom(si) then
;   778 --          fatal(e72iri,id)
;   779             fatalN(2,e72iri,id)
;   780         end if
;   781         siNTyp = si[S_NTyp]
;   782         if siNTyp!=S_Func
;   783         and siNTyp!=S_Type then
;   784 --          fatal(e72iri,id)
;   785             fatalN(2,e72iri,id)
;   786         end if
;   787         sig = si[S_sig]
;   788         for i=2 to length(sig) do
;   789             sigi = sig[i]
;   790             if sigi>T_atom then
;   791                 while sigi>T_object do
;   792                     -- follow the type chain to get the builtin type, eg
;   793                     --  type hour(integer h) return h>=0 and h<=23 end type
;   794                     --  type evening(hour h) return h>=18 and h<=23 end type
;   795                     -- then this loop does evening->hour->integer.
;   796                     if DEBUG then
;   797                         if symtab[sigi][S_NTyp]!=S_Type then ?9/0 end if
;   798                     end if
;   799                     sigi = symtab[sigi][S_sig][2]
;   800                 end while
;   801 --30/04/2011 (for iup)
;   802 --              if sigi>T_atom then
;   803                 if and_bits(sigi,T_atom)=0 then
;   804 --                  fatal(e75cbrpmaba) -- call back routine parameters must all be atoms
;   805                     fatalN(2,e75cbrpmaba) -- call back routine parameters must all be atoms
;   806                 end if
;   807             end if
;   808         end for
;   809         -- length(sig)-1 is the max, ParmN the min. Verify max==min.
;   810         -- In theory this could be a warning, with call_back assuming 
;   811         --  the max, but safer as an error. Besides, it is not exactly 
;   812         --  difficult to make fixed-var thin wrapper(s), ie/eg:
;   813         --      function varfunc(a=1,b=2)... end function
;   814         --      --constant cb = call_back(routine_id("varfunc")) -- error!
;   815         --      function fixed0() return varfunc() end function
;   816         --      function fixed1(a) return varfunc(a) end function
;   817         --      function fixed2(a,b) return varfunc(a,b) end function
;   818         --      constant cb0 = call_back(routine_id("fixed0"))
;   819         --      constant cb1 = call_back(routine_id("fixed1"))
;   820         --      constant cb2 = call_back(routine_id("fixed2"))
;   821         -- (Though normally there would be only one callback required.)
;   822         noofparams = si[S_ParmN]
;   823         if noofparams!=length(sig)-1 then
;   824 --          fatal(e16cbchop) -- call_backs cannot have optional parameters
;   825             fatalN(2,e16cbchop) -- call_backs cannot have optional parameters
;   826         end if
;   827 --SUG: should we check the return type for non-atom as well? (warning)
;   828 
;   829 
;   830 --DEV Needs DEP handling.
;   831 --DEV also, we could try the floor(adr/4) trick
;   832 
;   833 --      r = allocate(20)    -- STDCALL needs 18 bytes, CDECL 16 (round up to 5 dwords):
;   834         r = allocate(16)    -- STDCALL needs 13 bytes, CDECL 11 (round up to 4 dwords):
;   835 --                          --  push 0x01020304     ; 68 04030201 [DEV no longer rqd]   -- DEV symtab pointer
;   836                             --  push 0x05060708     ; 68 08070605 (routine number)
;   837                             --  call #030000000     ; E8 03000000
;   838                             --  ret 0x9090          ; C2 9090   (or C3 nop nop for CDECL)
;   839 --                          --                      (total of 18 (or 16) bytes)
;   840                             --                      (total of 13 (or 11) bytes)
;   841 
;   842         #ilASM{
;   843             [32]
;   844                 mov edi,[r]
;   845                 call :tpop              -- (===push :template; jmp tpop)
;   846 --      ::template  -- template code, copied to [r] and then patched.
;   847 --DEV ebp save no longer rqd. (see save_ebp etc, quite a pain to remove this, though)
;   848 --              push #01020304      -- (saved ebp)  [erm, saved symtab ptr]
;   849                 push #05060708      -- (routine number)
;   850                 call :tpop          -- patched to call cbhandler (relative jump)
;   851                 ret 1234            -- ret imm16      (patched to C3 (&nop,nop) for CDECL,
;   852                                     --                  and the imm16 patched for STDCALL.)
;   853 
;   854 --          ::cbhandler
;   855             -----------
;   856                 pushad
;   857 
;   858                 -- [esp] is saved edi (from the pushad)
;   859                 -- [esp+4] is saved esi
;   860                 -- [esp+8] is saved ebp
;   861                 -- [esp+12] is saved esp
;   862                 -- [esp+16] is saved ebx
;   863                 -- [esp+20] is saved edx
;   864                 -- [esp+24] is saved ecx
;   865                 -- [esp+28] is saved eax    -- (save of symtab[routineno], then result)
;   866                 -- [esp+32] is return address into stdcb clone (ret nnn instruction)
;   867                 -- [esp+36] is routine no   -- (also used to save result addr)
;   868 --              -- [esp+40] is saved ebp [DEV no longer rqd/used]
;   869 --              -- [esp+44] another return address [into C code, probably]
;   870 --              -- [esp+48] params
;   871                 -- [esp+40] another return address [into C code, probably]
;   872                 -- [esp+44] params
;   873 
;   874                 -- (same for both STDCALL and CDECL, cmiiw)
;   875 
;   876                 mov edx,[esp+36]        -- rtnid
;   877                 xor ebx,ebx
;   878                 -- restore ebp (from last call()/c_func()/c_proc())
;   879                 --  DEV this is not thread safe! (tls rqd?) (reserve say gvar[1]?)
;   880                 mov ecx,[ebp_save]
;   881                 shl ecx,2
;   882                 jz @f
;   883                     mov ebp,ecx
;   884               @@:
;   885 --              mov esi,[ebp+24]        -- symtab
;   886 --14/8/15
;   887 --              mov esi,[ds+8]          -- symtab
;   888                 call :%pGetSymPtr
;   889 --27/2/15:
;   890 --^             mov esi,[ebp+24]        -- vsb_root
;   891 --^             mov esi,[esi+8]         -- symtabptr
;   892                 mov esi,[esi+edx*4-4]   -- esi:=symtab[rtnid]
;   893                 mov [esp+28],esi        -- save symtab[rtnid] (in eax after popad)
;   894                 mov edi,[ebx+esi*4+32]  -- edi:=esi[S_ParmN=9]
;   895                 push edi                -- [1] push edi (no of params [min==max])
;   896                 mov ecx,[ebx+esi*4+36]  -- ecx:=esi[S_Ltot=10]
;   897                 --
;   898                 -- Create a frame:
;   899                 --
;   900                 --  ecx ==> number of params+locals
;   901 --              --  esi ==> "called from" addr -- opFrame sets this from [esp]
;   902                 --  edx ==> routineNo to call
;   903                 --
;   904                 call :%opFrame
;   905                 --
;   906                 -- Set params, converting any big 32-bit values to floats
;   907                 --
;   908                 mov edi,ebp             -- (addr first param)
;   909                 pop ecx                 -- [1] pop ecx (no of params)
;   910                 test ecx,ecx
;   911                 jz :zeroparams
;   912 --                  lea esi,[esp+48]    -- params (on stack)
;   913                     lea esi,[esp+44]    -- params (on stack)
;   914                 ::paramloop
;   915                     lodsd               --  eax:=[esi], esi+=4
;   916                     cmp eax,h4
;   917                     jb :paramstosd      -- (0..#3FFFFFFF)
;   918 --DEV this is viable, treating #FFFFFFFF as -1, but disagrees with RDS Eu...
;   919                     cmp eax,#C0000000
;   920                     jae :paramstosd     -- (#C0000000..#FFFFFFFF)
;   921 --DEV this loads it unsigned (agreeing with RDS Eu)....
;   922 --                  push ebx            -- (=0)
;   923 --                  push eax
;   924 --                  fild qword[esp]
;   925 --                  add esp,8
;   926 --DEV ... whereas this loads it signed (disagreeing with RDS Eu).
;   927                     fild dword[esi-4]
;   928 
;   929 --                  push edx
;   930 --DEV (to go) [temporary compatibility kludge, while pwy.exe is 26/08/2012]
;   931 --                  mov edx,edi
;   932 --                  call %opMovbi       --  call StoreFlt ([edi]:=ST0)
;   933                     call :%pStoreFlt                    -- ([edi]:=ST0)
;   934 --                  pop edx
;   935                     jmp :nextparam
;   936                 ::paramstosd
;   937                     mov [edi],eax
;   938                 ::nextparam
;   939                     sub edi,4
;   940                     sub ecx,1
;   941                     jnz :paramloop
;   942             ::zeroparams
;   943                 mov eax,[ebp_save]
;   944                 mov esi,[esp+28]        -- restore symtab[rtnid]
;   945                 mov [ebp_save],ebx      -- (0)  ; important!
;   946                 mov [esp+28],eax        -- was_ebp_save
;   947                 mov dword[ebp+16],:retaddr
;   948                 jmp dword[ebx+esi*4+40] -- execute first opcode (S_il=11)
;   949             ::retaddr
;   950                 -- result is in eax, but >31bit stored as a float
;   951                 cmp eax,h4 --DEV :%pLoadMint
;   952                 jl :retint
;   953                     sub esp,8
;   954                     cmp byte[ebx+eax*4-1],0x12          -- (ebx==0)
;   955                     je @f
;   956                         call :%e02atdb0                 -- (DEV better: call back returned non-atom?)
;   957                   @@:
;   958                     fld qword[ebx+eax*4]
;   959                     fistp qword[esp]
;   960                     dec dword[ebx+eax*4-8]
;   961                     jnz @f
;   962                         mov edx,eax
;   963                         push dword[esp+40]
;   964                         call :%pDealloc0
;   965                   @@:
;   966                     pop eax
;   967                     add esp,4
;   968             ::retint
;   969                 mov edx,[esp+28]        -- was_ebp_save
;   970                 mov [esp+28],eax        -- keep eax, but
;   971                 mov [ebp_save],edx      -- restore (important!)
;   972                 popad                   -- restore all other registers
;   973 --              ret 8                   -- (the two dwords pushed by template code)
;   974                 ret 4                   -- (the dword pushed by template code)
;   975 
;   976             -- end of cbhandler
;   977 
;   978             ::tpop
;   979                 pop esi                 -- (start of template code)
;   980                 cmp edi,h4              -- (allocated memory) --DEV :%pLoadMint
;   981                 jl @f
;   982                     -- allocated addrs > #3FFFFFFF get stored as 64-bit float:
;   983                     sub esp,8
;   984                     fld qword[ebx+edi*4]
;   985                     fistp qword[esp]
;   986                     pop edi
;   987                     add esp,4
;   988             @@:
;   989 --              lea edx,[edi+1]         -- (addr of that #01020304)
;   990                 mov edx,edi             -- (save)
;   991 --              lea edx,[edi+11]        -- (addr of offset)
;   992                 mov ecx,5               -- (5 dwords=20 bytes)
;   993                 rep movsd
;   994 --              mov ecx,[edx]           -- (to check #01020304)
;   995 --DEV should no longer be necessary...
;   996 --              mov [edx],ebp
;   997 --              mov [d1234],ecx
;   998 --              mov eax,[edx+10]        -- (original jump offset)
;   999                 mov eax,3               -- (original jump offset)
;  1000                 sub esi,edi
;  1001                 mov ecx,[id]
;  1002                 add eax,esi
;  1003 --              mov [edx+6],ecx
;  1004                 mov [edx+1],ecx
;  1005 --              mov [edx+11],eax        -- (updated jump offset)
;  1006                 mov [edx+6],eax         -- (updated jump offset)
;  1007 --              mov [edx],eax           -- (updated jump offset)
;  1008                 mov ecx,[noofparams]
;  1009                 cmp [convention],STDCALL
;  1010                 jne :cdecl
;  1011                     shl ecx,2
;  1012 --                  mov word[edx+16],cx
;  1013                     mov word[edx+11],cx
;  1014                     jmp @f
;  1015               ::cdecl
;  1016 --                  mov byte[edx+15],#C3
;  1017                     mov byte[edx+10],#C3
;  1018               @@:
;  1019             [64]
;  1020                 mov rdi,[r]
;  1021                 call :tpop              -- (===push :template; jmp tpop)
;  1022 --      ::template  -- template code, copied to [r] and then patched.
;  1023 --DEV ebp save no longer rqd. (see save_ebp etc, quite a pain to remove this, though)
;  1024 --              push #01020304          -- (saved ebp)  [erm, saved symtab ptr]
;  1025 --              push #05060708          -- (routine number)
;  1026 --              mov edx,#05060708       -- (routine number) [yes, use a 32-bit instruction]     (#BA imm32)
;  1027                 mov eax,#05060708       -- (routine number) [yes, 32-bit ins, 0-fills rax]      (#B8 imm32)
;  1028                 call :cbhandler64       -- patched to call cbhandler (relative jump)            (#E8 rel32)
;  1029 --              ret 1234                -- ret imm16      (patched to C3 (&nop,nop) for CDECL,  (#C2 #04D2)
;  1030 --                                      --                  and the imm16 patched for STDCALL.) (=13bytes=)
;  1031                 ret                     -- ret                                                  (#C3)
;  1032 --                                      --                                                      (=11bytes=)
;  1033 --              nop
;  1034 --              nop
;  1035 --              nop                     -- round it up to 16 bytes
;  1036 
;  1037             ::cbhandler64
;  1038             -----------
;  1039                 -- rax is routine number
;  1040                 -- [rsp] is return address into stdcb clone (ret nnn instruction)
;  1041                 -- [rsp+8] another return address [into C code, probably]
;  1042                 -- [rsp+16] params: shadow space: rcx/[rsp+16]
;  1043                 --                                rdx/[rsp+24]
;  1044                 --                                r8 /[rsp+32]
;  1045                 --                                r9 /[rsp+40]
;  1046                 -- (same for both STDCALL and CDECL, cmiiw)
;  1047 
;  1048 --[PE64]
;  1049                 xor rbx,rbx
;  1050                 mov [rsp+16],rcx
;  1051                 mov [rsp+24],rdx
;  1052                 mov [rsp+32],r8
;  1053                 mov [rsp+40],r9
;  1054 --14/8/15:
;  1055 --              mov rsi,[ds+8]          -- symtab (raw)
;  1056                 call :%pGetSymPtr
;  1057 --27/2/15:
;  1058 --^             mov rsi,[rbp+48]        -- vsb_root
;  1059 --^             mov rsi,[rsi+16]        -- symtabptr
;  1060 -- DEV this is not thread safe! (tls rqd?)
;  1061                 mov rcx,[ebp_save]
;  1062                 mov rdx,rax
;  1063                 shl rcx,2
;  1064                 jz @f
;  1065                     mov rbp,rcx
;  1066               @@:
;  1067                 mov rsi,[rsi+rdx*8-8]   -- rsi:=symtab[rtnid]
;  1068 --[ELF64]
;  1069                 push rsi                --[1] save symtab[rtnid]
;  1070 --              mov rdi,[rbx+rsi*8+64]  -- rdi:=rsi[S_ParmN=9]
;  1071                 mov rdi,[rbx+rsi*4+64]  -- rdi:=rsi[S_ParmN=9]
;  1072                 mov rcx,[rbx+rsi*4+72]  -- rcx:=rsi[S_Ltot=10]
;  1073                 push rdi                --[2] push edi (no of params [min==max])
;  1074 
;  1075                 call :%opFrame          -- (with rcx==number of params+locals, rdx==routine no)
;  1076 
;  1077                 --
;  1078                 -- Set params, converting any big 32-bit values to floats
;  1079                 --
;  1080                 mov rdi,rbp             -- (addr first param)
;  1081                 pop rcx                 --[2] pop ecx (no of params)
;  1082                 mov r15,h4
;  1083                 test rcx,rcx
;  1084                 jz :zeroparams
;  1085 --31/12/14:
;  1086 --                  lea rsi,[rsp+16]    -- params (on stack)
;  1087                     lea rsi,[rsp+24]    -- params (on stack)
;  1088                 ::paramloop
;  1089                     lodsq               --  rax:=[rsi], rsi+=8
;  1090                     cmp rax,r15
;  1091                     jb :paramstosd      -- (0..#3FFFFFFF)
;  1092 --DEV this is viable, treating #FFFFFFFF as -1, but disagrees with RDS Eu...
;  1093 --                  cmp eax,#C0000000
;  1094 --                  jae :paramstosd     -- (#C0000000..#FFFFFFFF)
;  1095 --DEV this loads it unsigned (agreeing with RDS Eu)....
;  1096 --pop al    -- DEV done to here...
;  1097 ----                push ebx            -- (=0)
;  1098 --                  push rax
;  1099 --                  fild qword[rsp]
;  1100 --                  add rsp,8
;  1101 --DEV ... whereas this loads it signed (disagreeing with RDS Eu).       [DEV seems like I'm going this route...]
;  1102                     fild qword[rsi-8]
;  1103 
;  1104 --                  push edx
;  1105 --DEV (to go) [temporary compatibility kludge, while pwy.exe is 26/08/2012]
;  1106 --                  mov edx,edi
;  1107 --                  call %opMovbi       --  call StoreFlt ([edi]:=ST0)
;  1108                     call :%pStoreFlt                    -- ([edi]:=ST0)
;  1109 --                  pop edx
;  1110                     jmp :nextparam
;  1111                 ::paramstosd
;  1112                     mov [rdi],rax
;  1113                 ::nextparam
;  1114                     sub rdi,8
;  1115                     sub rcx,1
;  1116                     jnz :paramloop
;  1117             ::zeroparams
;  1118                 mov rax,[ebp_save]
;  1119 --              mov rsi,[rsp+?28]       -- restore symtab[rtnid]
;  1120                 pop rsi                 --[1]
;  1121                 mov [ebp_save],rbx      -- (0)  ; important!
;  1122                 push rax
;  1123                 mov qword[rbp+32],:retaddr64
;  1124                 jmp dword[rbx+rsi*4+80] -- execute first opcode (S_il=11)
;  1125             ::retaddr64
;  1126                 -- result is in rax, but >63bit stored as a float
;  1127 --              cmp rax,h4
;  1128                 mov r15,h4
;  1129                 cmp rax,r15
;  1130                 jl :retint
;  1131                     sub rsp,8
;  1132                     cmp byte[rbx+rax*4-1],0x12          -- (ebx==0)
;  1133                     je @f
;  1134                         call :%e02atdb0                 -- (DEV better: call back returned non-atom?)
;  1135                   @@:
;  1136                     fld tbyte[rbx+rax*4]
;  1137                     fistp qword[rsp]
;  1138                     sub qword[rbx+rax*4-16],1
;  1139                     jnz @f
;  1140                         mov rdx,rax
;  1141                         push qword[rsp+24]
;  1142                         call :%pDealloc0
;  1143                   @@:
;  1144                     pop rax
;  1145 --                  add esp,4
;  1146             ::retint
;  1147 --              mov edx,[esp+28]        -- was_ebp_save
;  1148                 pop rdx
;  1149 --              mov [esp+28],eax        -- keep eax, but
;  1150                 mov [ebp_save],rdx      -- restore (important!)
;  1151 --              popad                   -- restore all other registers
;  1152 --              ret 8                   -- (the two dwords pushed by template code)
;  1153                 ret
;  1154 
;  1155             -- end of cbhandler
;  1156 
;  1157             ::tpop
;  1158                 pop rsi                 -- (start of template code)
;  1159 --              cmp rdi,h4              -- (allocated memory)
;  1160                 mov r15,h4
;  1161                 cmp rdi,r15             -- (allocated memory) --DEV :%pLoadMint
;  1162                 jl @f
;  1163                     -- allocated addrs > #3FFFFFFF_FFFFFFFF get stored as 64-bit float:
;  1164                     sub rsp,8
;  1165                     fld tbyte[rbx+rdi*4]
;  1166                     fistp qword[esp]
;  1167                     pop rdi
;  1168             @@:
;  1169             [PE64]
;  1170                 -- Grant execute access (DEV would be better to allocate a single large block)
;  1171                 --                       (perhaps something like arwen/Quick_Allocations.ew)
;  1172                 mov rcx,rsp -- put 2 copies of rsp onto the stack...
;  1173                 push rsp
;  1174                 push rcx
;  1175                 or rsp,8    -- [rsp] is now 1st or 2nd copy:
;  1176                             -- if on entry rsp was xxx8: both copies remain on the stack
;  1177                             -- if on entry rsp was xxx0: or rsp,8 effectively pops one of them (+8)
;  1178                             -- obviously rsp is now xxx8, whatever alignment we started with
;  1179                 sub rsp,8*5         -- minimum 4 param shadow space, flOldProtect, and align
;  1180                 lea r9,[rsp+32]                     -- lpflOldProtect
;  1181                 mov r8,#40                          -- flNewProtect (PAGE_EXECUTE_READWRITE)
;  1182                 mov rdx,16                          -- dwSize
;  1183                 mov rcx,rdi                         -- lpAddress
;  1184                 call "kernel32.dll","VirtualProtect"    -- (preserves rdi,rsi)
;  1185 --              add rsp,8*5
;  1186 --              pop rsp
;  1187                 mov rsp,[rsp+8*5]   -- equivalent to the add/pop
;  1188             [64]
;  1189                 mov rdx,rdi             -- (save)
;  1190 --              lea edx,[edi+11]        -- (addr of offset)
;  1191 --              mov ecx,5               -- (5 dwords=20 bytes)
;  1192                 mov rcx,2               -- (2 qwords=16 bytes)
;  1193                 rep movsq
;  1194 --              mov ecx,[edx]           -- (to check #01020304)
;  1195 --DEV should no longer be necessary...
;  1196 --              mov [edx],ebp
;  1197 --              mov [d1234],ecx
;  1198 --              mov eax,[edx+10]        -- (original jump offset)
;  1199 --              mov rax,3               -- (original jump offset)
;  1200                 mov rax,1               -- (original jump offset)
;  1201                 sub rsi,rdi
;  1202                 mov rcx,[id]
;  1203                 add rax,rsi
;  1204                 mov dword[rdx+1],ecx    -- id (as a 32-bit value)
;  1205 --              mov [edx+11],eax        -- (updated jump offset)
;  1206 --              mov [edx],eax           -- (updated jump offset)
;  1207 --              mov dword[rdx+11],eax   -- (updated jump offset,"")
;  1208                 mov dword[rdx+6],eax    -- (updated jump offset,"")
;  1209                 mov rcx,[noofparams]
;  1210 --removed 19/8/15:
;  1211 --              cmp [convention],STDCALL
;  1212 --              jne :cdecl
;  1213 --                  --DEV may need +1 for even no of params/min of 5...
;  1214 --                  -- (also not sure about STDCALL/CDECL vs 64-bit)
;  1215 ----                    shl ecx,2
;  1216 --                  shl rcx,3
;  1217 ----                    mov word[rdx+16],cx
;  1218 --                  mov word[rdx+11],cx
;  1219 ----DEV 19/8/15:
;  1220 ----                    jmp @f
;  1221 --            ::cdecl
;  1222 --                  mov byte[rdx+10],#C3
;  1223 --            @@:
;  1224             [ELF64]
;  1225                 pop al  -- for certain, the above "mov [rsp+16],rcx" etc is wrong...
;  1226             []
;  1227         }
;  1228 --      previd = append(previd,id)  -- done above
;  1229 --DEV delete_routine?
;  1230         prevcb = append(prevcb,r)
;  1231     else
;  1232         r = prevcb[k]
;  1233     end if
;  1234     return r
;  1235 end function
;  1236 
;  1237 global procedure call(atom addr)
;  1238 integer local_ebp -- (stored /4)
;  1239     #ilASM{
;  1240             [32]
;  1241                 e_all                                       -- set "all side-effects"
;  1242                 -- first, save ebp in case of a callback:
;  1243                 call :%save_ebp
;  1244                 mov [local_ebp],eax
;  1245 --DEV (pTrace.e)
;  1246 --              call %opClrDbg                              -- clear debug screen if needed
;  1247 --              int3
;  1248                 mov eax,[addr]
;  1249                 xor ebx,ebx
;  1250                 cmp eax,h4  --DEV :%pLoadMint
;  1251                 jl @f
;  1252                     sub esp,8
;  1253                     fld qword[ebx+eax*4]
;  1254                     fistp qword[esp]
;  1255                     pop eax
;  1256                     add esp,4
;  1257             @@:
;  1258                 call eax
;  1259                 xor ebx,ebx
;  1260                 mov edx,[local_ebp]
;  1261                 call :%restore_ebp
;  1262             [64]
;  1263                 e_all                                       -- set "all side-effects"
;  1264                 call :%save_rbp
;  1265                 mov [local_ebp],rax
;  1266 --DEV (pTrace.e)
;  1267 --              call :%opClrDbg                             -- clear debug screen if needed
;  1268 --              int3
;  1269                 mov rax,[addr]
;  1270 --              xor rbx,rbx
;  1271 --              cmp rax,h4
;  1272                 mov r15,h4
;  1273                 cmp rax,r15
;  1274                 jl @f
;  1275                     sub rsp,8
;  1276                     fld tbyte[rbx+rax*4]
;  1277                     fistp qword[rsp]
;  1278                     pop rax
;  1279             @@:
;  1280 --DEV is this just PE64? (it may not really matter)
;  1281                 sub rsp,8*5
;  1282                 call rax
;  1283                 xor rbx,rbx
;  1284                 add rsp,8*5
;  1285                 mov rdx,[local_ebp]
;  1286                 call :%restore_rbp
;  1287             []
;  1288         }
;  1289 end procedure
;  1290 
;  1291 
;  1292 constant FUNC = 1, PROC = 0
;  1293 
;  1294 function c_common(integer rid, sequence args, integer flag)
;  1295 -- common code for c_func and c_proc (validate and process args)
;  1296 --  flag is FUNC or PROC accordingly.
;  1297 sequence argdefs
;  1298 integer argdefi
;  1299 integer convention
;  1300 integer la, lad, ch
;  1301 object argi
;  1302 string argstring
;  1303 integer return_type
;  1304 object name -- for debugging only
;  1305 sequence tr -- table[rid], ie {name,addr,args,return_type,convention}
;  1306 atom addr
;  1307 sequence cstrings -- keeps refcounst>0, of any temps we have to make
;  1308 
;  1309     if tinit=0 or rid<1 or rid>length(table) then
    mov rdi,[#004032D8] (tinit)           ;#00449C31: 48:213075 A096FBFF         uv 80 00  1   1      
    cmp rdi,0                             ;#00449C38: 48:203377 00               uv 00 80  1   2 80   
    je #00449C68                          ;#00449C3C: 164 2A                     v  00 00  1   2      
    mov rsi,[rbp] (rid)                   ;#00449C3E: 48:213165 00               uv 40 20  1   3      
    cmp rsi,1                             ;#00449C42: 48:203376 01               uv 00 40  1   4 40   
    jl #00449C68                          ;#00449C46: 174 20                     v  00 00  1   4      
    lea rdi,[rbp-128] (symtab[1241])      ;#00449C48: 48:215175 80               uv 80 20  1   5      
    mov rsi,[#004032D0] (table)           ;#00449C4C: 48:213065 7D96FBFF         vu 40 00  1   5      
    mov rdx,1186                          ;#00449C53: 48:307302 A2040000         uv 04 00  1   6      
    call #0043F28D (:%opLen)              ;#00449C5A: 350 2E56FFFF               v  00 00  1   6      
    mov rax,[rbp] (rid)                   ;#00449C5F: 48:213105 00               uv 01 20  1   7      
    cmp rax,rcx                           ;#00449C63: 48:071310                  uv 00 03  1   8 01   
    jle #00449CA3                         ;#00449C66: 176 3B                     v  00 00  1   8      
;  1310 --      fatal(e72iri,rid)
;  1311         fatalN(3,e72iri,rid)
    mov rcx,3                             ;#00449C68: 48:307301 03000000         uv 02 00  1   9      
    mov rdx,1147                          ;#00449C6F: 48:307302 7B040000         vu 04 00  1   9      
    call #004428DB (:%opFrame) (fatalN)   ;#00449C76: 350 608CFFFF               v  00 00  1  10      
    mov qword[rbp] (level),3              ;#00449C7B: 48:307105 00 03000000      uv 00 20  1  11      
    mov qword[rbp-8] (errcode),72         ;#00449C83: 48:307105 F8 48000000      vu 00 20  1  11      
    mov rdi,[rbp+40] (prevebp)            ;#00449C8B: 48:213175 28               uv 80 20  1  12      
    mov rax,[rdi]                         ;#00449C8F: 48:213007                  uv 01 80  1  15 80 *80*
    mov [rbp-16] (ep1),rax                ;#00449C92: 48:211105 F0               uv 00 21  1  16 01   
    mov qword[retaddr],#00449CA3          ;#00449C96: 48:307105 20 A39C4400      vu 00 20  1  16      
    jmp #0044A360 (code:fatalN)           ;#00449C9E: 351 BD060000               v  00 00  1  17      
;  1312     end if
;  1313     tr = table[rid]
    mov rdi,[#004032D0] (table)           ;#00449CA3: 48:213075 2696FBFF         uv 80 00  1  18      
    mov r15,h4                            ;#00449CAA: 49:277 0000000000000040    vu 8000 00  1  18      
    cmp rdi,r15                           ;#00449CB4: 4C:071377                  uv 00 8080  1  19      
    jne #00449CC5                         ;#00449CB7: 165 0C                     v  00 00  1  19      
    mov rsi,1186                          ;#00449CB9: 48:307306 A2040000         uv 40 00  1  20      
    call #00442D75 (:%pUnassigned)        ;#00449CC0: 350 B090FFFF               v  00 00  1  20      
    mov rdi,[rbp] (rid)                   ;#00449CC5: 48:213175 00               uv 80 20  1  21      
    lea rcx,[rbp-104] (tr)                ;#00449CC9: 48:215115 98               vu 02 20  1  21      
    mov rsi,[#004032D0] (table)           ;#00449CCD: 48:213065 FC95FBFF         uv 40 00  1  22      
    mov rdx,1186                          ;#00449CD4: 48:307302 A2040000         vu 04 00  1  22      
    call #00441675 (:%pSubse1)            ;#00449CDB: 350 9579FFFF               v  00 00  1  23      
;  1314     name = tr[T_name]
    mov rdi,1                             ;#00449CE0: 48:307307 01000000         uv 80 00  1  24      
    lea rcx,[rbp-96] (name)               ;#00449CE7: 48:215115 A0               vu 02 20  1  24      
    mov rsi,[rbp-104] (tr)                ;#00449CEB: 48:213165 98               uv 40 20  1  25      
    mov rdx,1238                          ;#00449CEF: 48:307302 D6040000         vu 04 00  1  25      
    call #00441675 (:%pSubse1)            ;#00449CF6: 350 7A79FFFF               v  00 00  1  26      
;  1315     addr = tr[T_address]
    mov rdi,2                             ;#00449CFB: 48:307307 02000000         uv 80 00  1  27      
    lea rcx,[rbp-112] (addr)              ;#00449D02: 48:215115 90               vu 02 20  1  27      
    mov rsi,[rbp-104] (tr)                ;#00449D06: 48:213165 98               uv 40 20  1  28      
    mov rdx,1238                          ;#00449D0A: 48:307302 D6040000         vu 04 00  1  28      
    call #00441675 (:%pSubse1)            ;#00449D11: 350 5F79FFFF               v  00 00  1  29      
    mov rcx,[rbp-112] (addr)              ;#00449D16: 48:213115 90               uv 02 20  1  30      
    mov r15,h4                            ;#00449D1A: 49:277 0000000000000040    vu 8000 00  1  30      
    cmp rcx,r15                           ;#00449D24: 4C:071371                  uv 00 8002  1  31      
    jl #00449D3C                          ;#00449D27: 174 13                     v  00 00  1  31      
    cmp byte[rbx+rcx*4-1],#12             ;#00449D29: 200174213 FF 12            u  00 0A  2  32      
    je #00449D3C                          ;#00449D2E: 164 0C                     v  00 00  1  33      
    mov rcx,1239                          ;#00449D30: 48:307301 D7040000         uv 02 00  1  34      
    call #00442A58 (:%opTchkFail)         ;#00449D37: 350 1C8DFFFF               v  00 00  1  34      
;  1316     argdefs = tr[T_args]
    mov rdi,3                             ;#00449D3C: 48:307307 03000000         uv 80 00  1  35      
    lea rcx,[rbp-24] (argdefs)            ;#00449D43: 48:215115 E8               vu 02 20  1  35      
    mov rsi,[rbp-104] (tr)                ;#00449D47: 48:213165 98               uv 40 20  1  36      
    mov rdx,1238                          ;#00449D4B: 48:307302 D6040000         vu 04 00  1  36      
    call #00441675 (:%pSubse1)            ;#00449D52: 350 1E79FFFF               v  00 00  1  37      
    mov rax,[rbp-24] (argdefs)            ;#00449D57: 48:213105 E8               uv 01 20  1  38      
    mov r15,h4                            ;#00449D5B: 49:277 0000000000000040    vu 8000 00  1  38      
    cmp rax,r15                           ;#00449D65: 4C:071370                  uv 00 8001  1  39      
    jl #00449D71                          ;#00449D68: 174 07                     v  00 00  1  39      
    test byte[rbx+rax*4-1],#80            ;#00449D6A: 366104203 FF 80            u  00 09  2  40      
    jne #00449D7D                         ;#00449D6F: 165 0C                     v  00 00  1  41      
    mov rcx,1228                          ;#00449D71: 48:307301 CC040000         uv 02 00  1  42      
    call #00442A58 (:%opTchkFail)         ;#00449D78: 350 DB8CFFFF               v  00 00  1  42      
;  1317     return_type = tr[T_return_type]
    mov rdi,4                             ;#00449D7D: 48:307307 04000000         uv 80 00  1  43      
    lea rcx,[rbp-88] (return_type)        ;#00449D84: 48:215115 A8               vu 02 20  1  43      
    mov rsi,[rbp-104] (tr)                ;#00449D88: 48:213165 98               uv 40 20  1  44      
    mov rdx,1238                          ;#00449D8C: 48:307302 D6040000         vu 04 00  1  44      
    call #004416F2 (:%pSubse1i)           ;#00449D93: 350 5A79FFFF               v  00 00  1  45      
;  1318     convention = tr[T_convention]
    mov rdi,5                             ;#00449D98: 48:307307 05000000         uv 80 00  1  46      
    lea rcx,[rbp-40] (convention)         ;#00449D9F: 48:215115 D8               vu 02 20  1  46      
    mov rsi,[rbp-104] (tr)                ;#00449DA3: 48:213165 98               uv 40 20  1  47      
    mov rdx,1238                          ;#00449DA7: 48:307302 D6040000         vu 04 00  1  47      
    call #004416F2 (:%pSubse1i)           ;#00449DAE: 350 3F79FFFF               v  00 00  1  48      
;  1319 
;  1320     --20/8/15: (ensure shadow space and align)
;  1321     if machine_bits()=64 then
;  1322         la = length(args)
    mov rdi,[rbp-8] (args)                ;#00449DB3: 48:213175 F8               uv 80 20  1  49      
    mov rcx,[rbx+rdi*4-24]                ;#00449DB7: 48:48:213114273 E8         uv 02 88  1  52 80 *80*
    mov [rbp-48] (la),rcx                 ;#00449DBD: 48:211115 D0               uv 00 22  1  53 02   
;  1323         if la<5 then
    cmp rcx,5                             ;#00449DC1: 48:203371 05               vu 00 02  1  53      
    jge #00449E4F                         ;#00449DC5: 017215 84000000            v  00 00  1  54      
;  1324             args &= repeat(0,5-la)
    mov rdx,5                             ;#00449DCB: 48:307302 05000000         uv 04 00  1  55      
    sub rdx,rcx                           ;#00449DD2: 48:051312                  uv 04 06  1  56 04   
    mov [rbp-136] (symtab[1242]),rdx      ;#00449DD5: 48:211225 78FFFFFF         uv 00 24  1  57 04   
    lea rdi,[rbp-144] (symtab[1243])      ;#00449DDC: 48:215275 70FFFFFF         vu 80 20  1  57      
    mov rax,0                             ;#00449DE3: 48:307300 00000000         uv 01 00  1  58      
    mov rcx,[rbp-136] (symtab[1242])      ;#00449DEA: 48:213215 78FFFFFF         vu 02 20  1  58      
    call #0043B1F3 (:%opRepeat)           ;#00449DF1: 350 FD13FFFF               v  00 00  1  59      
    lea rdx,[rbp-8] (args)                ;#00449DF6: 48:215125 F8               uv 04 20  1  60      
    lea rdi,[rbp-8] (args)                ;#00449DFA: 48:215175 F8               vu 80 20  1  60      
    lea rcx,[rbp-144] (symtab[1243])      ;#00449DFE: 48:215215 70FFFFFF         uv 02 20  1  61      
    call #00440021 (:%opConcat)           ;#00449E05: 350 1762FFFF               v  00 00  1  61      
;  1325             argdefs &= repeat(#01000004,5-la)
    mov rsi,[rbp-48] (la)                 ;#00449E0A: 48:213165 D0               uv 40 20  1  62      
    mov rdx,5                             ;#00449E0E: 48:307302 05000000         vu 04 00  1  62      
    sub rdx,rsi                           ;#00449E15: 48:051362                  uv 04 44  1  63      
    mov [rbp-136] (symtab[1242]),rdx      ;#00449E18: 48:211225 78FFFFFF         uv 00 24  1  64 04   
    lea rdi,[rbp-144] (symtab[1243])      ;#00449E1F: 48:215275 70FFFFFF         vu 80 20  1  64      
    mov rax,16777220                      ;#00449E26: 48:307300 04000001         uv 01 00  1  65      
    mov rcx,[rbp-136] (symtab[1242])      ;#00449E2D: 48:213215 78FFFFFF         vu 02 20  1  65      
    call #0043B1F3 (:%opRepeat)           ;#00449E34: 350 BA13FFFF               v  00 00  1  66      
    lea rdx,[rbp-24] (argdefs)            ;#00449E39: 48:215125 E8               uv 04 20  1  67      
    lea rdi,[rbp-24] (argdefs)            ;#00449E3D: 48:215175 E8               vu 80 20  1  67      
    lea rcx,[rbp-144] (symtab[1243])      ;#00449E41: 48:215215 70FFFFFF         uv 02 20  1  68      
    call #00440021 (:%opConcat)           ;#00449E48: 350 D461FFFF               v  00 00  1  68      
    jmp #00449E8C                         ;#00449E4D: 353 3D                     v  00 00  1  69      
;  1326         elsif remainder(la,2)!=1 then
    mov rax,rcx                           ;#00449E4F: 48:211310                  uv 01 02  1  70      
    and rax,1                             ;#00449E52: 48:045 01000000            uv 01 01  1  71 01   
    cmp rax,1                             ;#00449E58: 48:203370 01               uv 00 01  1  72 01   
    je #00449E8C                          ;#00449E5C: 164 2E                     v  00 00  1  72      
;  1327             args &= 0
    lea rdx,[rbp-8] (args)                ;#00449E5E: 48:215125 F8               uv 04 20  1  73      
    lea rdi,[rbp-8] (args)                ;#00449E62: 48:215175 F8               vu 80 20  1  73      
    lea rcx,qword[#00402028]              ;#00449E66: 48:215015 BB81FBFF         uv 02 00  1  74      
    xor rax,rax                           ;#00449E6D: 48:061300                  vu 01 01  1  74      
    call #0043FC15 (:%opApnd)             ;#00449E70: 350 A05DFFFF               v  00 00  1  75      
;  1328             argdefs &= #01000004    -- (C_INT)
    lea rdx,[rbp-24] (argdefs)            ;#00449E75: 48:215125 E8               uv 04 20  1  76      
    lea rdi,[rbp-24] (argdefs)            ;#00449E79: 48:215175 E8               vu 80 20  1  76      
    lea rcx,[#00402058] (C_INT)           ;#00449E7D: 48:215015 D481FBFF         uv 02 00  1  77      
    xor rax,rax                           ;#00449E84: 48:061300                  vu 01 01  1  77      
    call #0043FC15 (:%opApnd)             ;#00449E87: 350 895DFFFF               v  00 00  1  78      
;  1329         end if
;  1330     end if
;  1331 
;  1332     la = length(args)
    mov rdi,[rbp-8] (args)                ;#00449E8C: 48:213175 F8               uv 80 20  1  79      
    mov rsi,[rbx+rdi*4-24]                ;#00449E90: 48:48:213164273 E8         uv 40 88  1  82 80 *80*
    mov [rbp-48] (la),rsi                 ;#00449E96: 48:211165 D0               uv 00 60  1  83 40   
;  1333     lad = length(argdefs)
    mov rcx,[rbp-24] (argdefs)            ;#00449E9A: 48:213115 E8               vu 02 20  1  83      
    mov rax,[rbx+rcx*4-24]                ;#00449E9E: 48:48:213104213 E8         uv 01 0A  1  86    *02*
    mov [rbp-56] (lad),rax                ;#00449EA4: 48:211105 C8               uv 00 21  1  87 01   
;  1334     if la!=lad then
    cmp rsi,rax                           ;#00449EA8: 48:071306                  vu 00 41  1  87      
    je #00449EBC                          ;#00449EAB: 164 0F                     v  00 00  1  88      
;  1335         -- e116rrnp4: routine [%s] requires %d parameters, not %d
;  1336         #ilASM{
;  1337                 [32]
;  1338                     mov al,116
;  1339                     mov edi,[lad]   -- ep1
;  1340                     mov esi,[la]    -- ep2
;  1341 --                  mov edx,[name]  -- ep3  --DEV (we haven't got an ep3, yet)
;  1342                     call :%pRTErn   -- fatal error
;  1343 --DEV (this is :%pRTErn:, see also pfileioN.e for ebp/calledfrom etc)
;  1344 --      pop edx -- era
;  1345 --      sub edx,1
;  1346 --      jmp :!iDiag
;  1347 --      int3
;  1348                 [64]
;  1349                     mov al,116
                            mov al,116    ;#00449EAD: 260 74                     uv 01 00  1  89      
;  1350                     mov rdi,[lad]   -- ep1
                            mov rdi,[rbp-56] (lad)  ;#00449EAF: 48:213175 C8               vu 80 20  1  89      
;  1351                     mov rsi,[la]    -- ep2
                            mov rsi,[rbp-48] (la)  ;#00449EB3: 48:213165 D0               uv 40 20  1  90      
;  1352 --                  mov rdx,[name]  -- ep3  --DEV (we haven't got an ep3, yet)
;  1353                     call :%pRTErn   -- fatal error
                            call #00442DC8 (:%pRTErn)  ;#00449EB7: 350 0C8FFFFF               v  00 00  1  90      
;  1354                 []
;  1355             }
;  1356     end if
;  1357     if flag=FUNC then
;  1358 --      if return_type=0 then fatal(e117rdnrav) end if
;  1359         if return_type=0 then fatalN(3,e117rdnrav) end if
    mov rdi,[rbp-88] (return_type)        ;#00449EBC: 48:213175 A8               uv 80 20  1  91      
    cmp rdi,0                             ;#00449EC0: 48:203377 00               uv 00 80  1  92 80   
    jne #00449EF6                         ;#00449EC4: 165 30                     v  00 00  1  92      
    mov rcx,3                             ;#00449EC6: 48:307301 03000000         uv 02 00  1  93      
    mov rdx,1147                          ;#00449ECD: 48:307302 7B040000         vu 04 00  1  93      
    call #004428DB (:%opFrame) (fatalN)   ;#00449ED4: 350 028AFFFF               v  00 00  1  94      
    mov qword[rbp] (level),3              ;#00449ED9: 48:307105 00 03000000      uv 00 20  1  95      
    mov qword[rbp-8] (errcode),117        ;#00449EE1: 48:307105 F8 75000000      vu 00 20  1  95      
    mov qword[retaddr],#00449EF6          ;#00449EE9: 48:307105 20 F69E4400      uv 00 20  1  96      
    jmp #0044A360 (code:fatalN)           ;#00449EF1: 351 6A040000               v  00 00  1  96      
;  1360     else -- flag=PROC
;  1361 --      if return_type!=0 then fatal(e118rrav) end if
;  1362         if return_type!=0 then fatalN(3,e118rrav) end if
;  1363     end if
;  1364     #ilASM{ e_all               -- set "all side-effects"
;  1365 --DEV
;  1366 --              call %opClrDbg      -- clear debug screen if needed
;  1367 --              int3
;  1368         }
;  1369     cstrings = {}
    mov rcx,qword[#004022C8]              ;#00449EF6: 48:213015 CB83FBFF         uv 02 00  1  97      
    mov [rbp-120] (cstrings),rcx          ;#00449EFD: 48:211115 88               uv 00 22  1  98 02   
    add qword[rbx+rcx*4-16],1             ;#00449F01: 48:203104213 F0 01         u  00 0A  3 100    *02*
;  1370 --DEV 64bit: do we want an initial push rbx for the even no of params case?
;  1371     if string(args) then
;  1372         -- hmmm, well just push the string chars then...
;  1373         for i=la to 1 by -1 do
;  1374             ch = args[i]
;  1375             argdefi = argdefs[i]
;  1376             if DEBUG then
;  1377                 if not find(argdefi,{
;  1378                       -- (These should be fine, but not much point adding them when
;  1379                       --    we've nothing to say whether they work or not...)
;  1380 --                                       #01000001,     -- C_CHAR
;  1381 --                                       #01000004,     -- C_INT
;  1382 --                                       #02000004      -- C_UINT == C_ULONG, C_POINTER, C_PTR
;  1383                                     }) then ?9/0 end if
;  1384             end if
;  1385             #ilASM{
;  1386                     [32]
;  1387                         mov edx,[ch]
;  1388                         push edx
;  1389                     [64]
;  1390                         mov rdx,[ch]
;  1391                         push rdx
;  1392                     []
;  1393                 }
;  1394         end for
;  1395     else
;  1396         for i=la to 1 by -1 do
    mov rax,[rbp-48] (la)                 ;#00449F07: 48:213105 D0               vu 01 20  1 102      
    mov [rbp-168] (symtab[1246]),rax      ;#00449F0B: 48:211205 58FFFFFF         uv 00 21  1 103      
    mov [rbp-176] (i),rax                 ;#00449F12: 48:211205 50FFFFFF         vu 00 21  1 103      
    cmp rax,1                             ;#00449F19: 48:075 01000000            uv 00 01  1 104      
    jl #0044A165                          ;#00449F1F: 017214 40020000            v  00 00  1 104      
;  1397             argi = args[i]
    mov rdi,[rbp-176] (i)                 ;#00449F25: 48:213275 50FFFFFF         uv 80 20  1 105      
    lea rcx,[rbp-72] (argi)               ;#00449F2C: 48:215115 B8               vu 02 20  1 105      
    mov rsi,[rbp-8] (args)                ;#00449F30: 48:213165 F8               uv 40 20  1 106      
    mov rdx,1226                          ;#00449F34: 48:307302 CA040000         vu 04 00  1 106      
    call #00441675 (:%pSubse1)            ;#00449F3B: 350 3577FFFF               v  00 00  1 107      
;  1398             argdefi = argdefs[i]
    mov rdi,[rbp-176] (i)                 ;#00449F40: 48:213275 50FFFFFF         uv 80 20  1 108      
    lea rcx,[rbp-32] (argdefi)            ;#00449F47: 48:215115 E0               vu 02 20  1 108      
    mov rsi,[rbp-24] (argdefs)            ;#00449F4B: 48:213165 E8               uv 40 20  1 109      
    mov rdx,1228                          ;#00449F4F: 48:307302 CC040000         vu 04 00  1 109      
    call #004416F2 (:%pSubse1i)           ;#00449F56: 350 9777FFFF               v  00 00  1 110      
;  1399             if integer(argi) then
    mov rcx,[rbp-72] (argi)               ;#00449F5B: 48:213115 B8               uv 02 20  1 111      
    mov r15,h4                            ;#00449F5F: 49:277 0000000000000040    vu 8000 00  1 111      
    cmp rcx,r15                           ;#00449F69: 4C:071371                  uv 00 8002  1 112      
    jg #00449F77                          ;#00449F6C: 177 09                     v  00 00  1 112      
;  1400                 if DEBUG then
;  1401                     if not find(argdefi,{
;  1402                                          #01000001,     -- C_CHAR
;  1403                                          #01000004,     -- C_INT
;  1404                                          #02000004      -- C_UINT == C_ULONG, C_POINTER, C_PTR
;  1405                                         }) then ?9/0 end if
;  1406                 end if
;  1407                 #ilASM{
;  1408                         [32]
;  1409                             mov edx,[argi]
;  1410                             push edx
;  1411                         [64]
;  1412 --                          mov rdx,[argi]  --DEV everywhere
;  1413 --                          push rdx
;  1414                             push [argi]
                                    push qword[rbp-72] (argi)  ;#00449F6E: 48:377165 B8               np 00 20  2 113      
;  1415                         []
;  1416                     }
    jmp #0044A143                         ;#00449F72: 351 CC010000               v  00 00  1 115      
;  1417             elsif atom(argi) then
    cmp byte[rbx+rcx*4-1],#12             ;#00449F77: 200174213 FF 12            u  00 0A  2 116      
    jne #0044A08B                         ;#00449F7C: 017205 09010000            v  00 00  1 117      
;  1418 --DEV switch would be better?
;  1419                 if find(argdefi,{
;  1420                                  #01000004,     -- C_INT
;  1421                                  #02000004      -- C_UINT == C_ULONG, C_POINTER, C_PTR
    mov rcx,7                             ;#00449F82: 48:307301 07000000         uv 02 00  1 118      
    mov rdx,75                            ;#00449F89: 48:307302 4B000000         vu 04 00  1 118      
    call #004428DB (:%opFrame) (find)     ;#00449F90: 350 4689FFFF               v  00 00  1 119      
    mov rdi,[rbp+40] (prevebp)            ;#00449F95: 48:213175 28               uv 80 20  1 120      
    mov rax,[rdi-32]                      ;#00449F99: 48:213107 E0               uv 01 80  1 123 80 *80*
    mov [rbp] (x),rax                     ;#00449F9D: 48:211105 00               uv 00 21  1 124 01   
    mov rdi,qword[#004023D0]              ;#00449FA1: 48:213075 2884FBFF         vu 80 00  1 124      
    mov [rbp-8] (s),rdi                   ;#00449FA8: 48:211175 F8               uv 00 A0  1 125      
    add qword[rbx+rdi*4-16],1             ;#00449FAC: 48:203104273 F0 01         u  00 88  3 127    *80*
    mov qword[retaddr],#00449FBF          ;#00449FB2: 48:307105 20 BF9F4400      vu 00 20  1 129      
    jmp #0043DAD6 (code:find)             ;#00449FBA: 351 173BFFFF               v  00 00  1 130      
    test rax,rax                          ;#00449FBF: 48:205300                  uv 00 01  1 131      
    je #00449FD7                          ;#00449FC2: 164 13                     v  00 00  1 131      
;  1422                                 }) then
;  1423                     #ilASM{
;  1424                             [32]
;  1425                                 mov edx,[argi]      --DEV :%pLoadMint
;  1426                                 sub esp,8
;  1427                                 fld qword[ebx+edx*4]
;  1428                                 fistp qword[esp]
;  1429                                 pop edx
;  1430                                 add esp,4
;  1431                                 push edx
;  1432                             [64]
;  1433                                 mov rdx,[argi]
                                        mov rdx,[rbp-72] (argi)  ;#00449FC4: 48:213125 B8               uv 04 20  1 132      
;  1434                                 sub rsp,8
                                        sub rsp,8  ;#00449FC8: 48:203354 08               vu 10 10  1 132      
;  1435                                 fld tbyte[rbx+rdx*4]
                                        fld tbyte[rbx+rdx*4]  ;#00449FCC: 333054223                  np 00 0C  3 135    *04*
;  1436                                 fistp qword[rsp]
                                        fistp qword[rsp]  ;#00449FCF: 337074044                  np 00 10  6 140    *10*
;  1437                             []
;  1438                         }
    jmp #0044A143                         ;#00449FD2: 351 6C010000               v  00 00  1 146      
;  1439                 elsif find(argdefi,{
;  1440                                     #03000004       -- C_FLOAT
    mov rcx,7                             ;#00449FD7: 48:307301 07000000         uv 02 00  1 147      
    mov rdx,75                            ;#00449FDE: 48:307302 4B000000         vu 04 00  1 147      
    call #004428DB (:%opFrame) (find)     ;#00449FE5: 350 F188FFFF               v  00 00  1 148      
    mov rdi,[rbp+40] (prevebp)            ;#00449FEA: 48:213175 28               uv 80 20  1 149      
    mov rax,[rdi-32]                      ;#00449FEE: 48:213107 E0               uv 01 80  1 152 80 *80*
    mov [rbp] (x),rax                     ;#00449FF2: 48:211105 00               uv 00 21  1 153 01   
    mov rsi,qword[#00403370]              ;#00449FF6: 48:213065 7393FBFF         vu 40 00  1 153      
    mov [rbp-8] (s),rsi                   ;#00449FFD: 48:211165 F8               uv 00 60  1 154      
    add qword[rbx+rsi*4-16],1             ;#0044A001: 48:203104263 F0 01         u  00 48  3 156    *40*
    mov qword[retaddr],#0044A014          ;#0044A007: 48:307105 20 14A04400      vu 00 20  1 158      
    jmp #0043DAD6 (code:find)             ;#0044A00F: 351 C23AFFFF               v  00 00  1 159      
    test rax,rax                          ;#0044A014: 48:205300                  uv 00 01  1 160      
    je #0044A02C                          ;#0044A017: 164 13                     v  00 00  1 160      
;  1441                                    }) then
;  1442                     #ilASM{
;  1443                             [32]
;  1444                                 mov edx,[argi]
;  1445                                 sub esp,4
;  1446                                 fld qword[ebx+edx*4]
;  1447                                 fstp dword[esp]
;  1448                             [64]
;  1449 --erm... (no self-respecting 64-bit code should be using 32-bit float params...)
;  1450                                 mov rdx,[argi]
                                        mov rdx,[rbp-72] (argi)  ;#0044A019: 48:213125 B8               uv 04 20  1 161      
;  1451                                 sub rsp,8
                                        sub rsp,8  ;#0044A01D: 48:203354 08               vu 10 10  1 161      
;  1452                                 fld tbyte[rbx+rdx*4]
                                        fld tbyte[rbx+rdx*4]  ;#0044A021: 333054223                  np 00 0C  3 164    *04*
;  1453                                 fstp qword[rsp]
                                        fstp qword[rsp]  ;#0044A024: 335034044                  np 00 10  2 169    *10*
;  1454                             []
;  1455                         }
    jmp #0044A143                         ;#0044A027: 351 17010000               v  00 00  1 171      
;  1456                 elsif find(argdefi,{
;  1457                                     #03000008       -- C_DOUBLE
    mov rcx,7                             ;#0044A02C: 48:307301 07000000         uv 02 00  1 172      
    mov rdx,75                            ;#0044A033: 48:307302 4B000000         vu 04 00  1 172      
    call #004428DB (:%opFrame) (find)     ;#0044A03A: 350 9C88FFFF               v  00 00  1 173      
    mov rdi,[rbp+40] (prevebp)            ;#0044A03F: 48:213175 28               uv 80 20  1 174      
    mov rax,[rdi-32]                      ;#0044A043: 48:213107 E0               uv 01 80  1 177 80 *80*
    mov [rbp] (x),rax                     ;#0044A047: 48:211105 00               uv 00 21  1 178 01   
    mov rcx,qword[#00403378]              ;#0044A04B: 48:213015 2693FBFF         vu 02 00  1 178      
    mov [rbp-8] (s),rcx                   ;#0044A052: 48:211115 F8               uv 00 22  1 179      
    add qword[rbx+rcx*4-16],1             ;#0044A056: 48:203104213 F0 01         u  00 0A  3 181    *02*
    mov qword[retaddr],#0044A069          ;#0044A05C: 48:307105 20 69A04400      vu 00 20  1 183      
    jmp #0043DAD6 (code:find)             ;#0044A064: 351 6D3AFFFF               v  00 00  1 184      
    test rax,rax                          ;#0044A069: 48:205300                  uv 00 01  1 185      
    je #0044A081                          ;#0044A06C: 164 13                     v  00 00  1 185      
;  1458                                    }) then
;  1459                     #ilASM{
;  1460                             [32]
;  1461                                 mov edx,[argi]
;  1462                                 sub esp,8
;  1463                                 fld qword[ebx+edx*4]
;  1464                                 fstp qword[esp]
;  1465                             [64]
;  1466                                 mov rdx,[argi]
                                        mov rdx,[rbp-72] (argi)  ;#0044A06E: 48:213125 B8               uv 04 20  1 186      
;  1467                                 sub rsp,8
                                        sub rsp,8  ;#0044A072: 48:203354 08               vu 10 10  1 186      
;  1468                                 fld tbyte[rbx+rdx*4]
                                        fld tbyte[rbx+rdx*4]  ;#0044A076: 333054223                  np 00 0C  3 189    *04*
;  1469                                 fstp qword[rsp]
                                        fstp qword[rsp]  ;#0044A079: 335034044                  np 00 10  2 194    *10*
;  1470                             []
;  1471                         }
    jmp #0044A143                         ;#0044A07C: 351 C2000000               v  00 00  1 196      
;  1472                 else
;  1473                     ?9/0
    call #00442DD2 (:%pDiv0)              ;#0044A081: 350 4C8DFFFF               v  00 00  1 197      
;  1474                 end if
    jmp #0044A143                         ;#0044A086: 351 B8000000               v  00 00  1 198      
;  1475             elsif string(argi) then
    cmp byte[rbx+rcx*4-1],#82             ;#0044A08B: 200174213 FF 82            u  00 0A  2 199      
    jne #0044A0A1                         ;#0044A090: 165 0F                     v  00 00  1 200      
;  1476 --              elsif string(argi) and argdefi!=C_WIDEPTR then
;  1477                 if DEBUG then
;  1478                     if not find(argdefi,{
;  1479                                          #02000004      -- C_UINT == C_ULONG, C_POINTER, C_PTR
;  1480                                         }) then ?9/0 end if
;  1481                 end if
;  1482                 -- NB recount-agnostic; see WARNING above.
;  1483                 #ilASM{
;  1484                         [32]
;  1485                             mov edx,[argi]
;  1486                             shl edx,2       -- (convert to raw address)
;  1487                             push edx
;  1488                         [64]
;  1489                             mov rdx,[argi]
                                    mov rdx,[rbp-72] (argi)  ;#0044A092: 48:213125 B8               uv 04 20  1 201      
;  1490                             shl rdx,2       -- (convert to raw address)
                                    shl rdx,2  ;#0044A096: 48:301342 02               u  04 04  1 202      
;  1491                             push rdx
                                    push rdx  ;#0044A09A: 48:122                     uv 00 04  1 203 04   
;  1492                         []
;  1493                     }
    jmp #0044A143                         ;#0044A09C: 351 A2000000               v  00 00  1 203      
;  1494             else
;  1495                 if DEBUG then
;  1496                     if not find(argdefi,{
;  1497                                          #02000004      -- C_UINT == C_ULONG, C_POINTER, C_PTR
;  1498 --                                           #12000004      -- C_WIDEPTR [DEV]
;  1499                                         }) then ?9/0 end if
;  1500                 end if
;  1501                 -- convert to a string and push that (cstrings ensures these temporaries are
;  1502                 --  /not/ freed, and the memory reused, until /after/ c_func|c_proc return)
;  1503                 argstring = toString(argi,ASANY,e88atcfpmbaos,4)
    mov rcx,9                             ;#0044A0A1: 48:307301 09000000         uv 02 00  1 204      
    mov rdx,1152                          ;#0044A0A8: 48:307302 80040000         vu 04 00  1 204      
    call :%opFrame (toString)             ;#0044A0AF: 350 2788FFFF               v  00 00  1 205      
    mov rdi,[rbp+40] (prevebp)            ;#0044A0B4: 48:213175 28               uv 80 20  1 206      
    mov rax,[rdi-72]                      ;#0044A0B8: 48:213107 B8               uv 01 80  1 209 80 *80*
    xor rbx,rbx                           ;#0044A0BC: 48:061333                  vu 08 08  1 209      
    mov r15,h4                            ;#0044A0BF: 49:277 0000000000000040    uv 8000 00  1 210      
    cmp rax,r15                           ;#0044A0C9: 4C:071370                  uv 00 8001  1 211 8000   
    jl #0044A0D9                          ;#0044A0CC: 174 0B                     v  00 00  1 211      
    add qword[rbx+rax*4-16],1             ;#0044A0CE: 48:203104203 F0 01         u  00 09  3 212      
    cmp eax,1234                          ;#0044A0D4: 075 D2040000               vu 00 01  1 214      
    mov [rbp] (name),rax                  ;#0044A0D9: 48:211105 00               uv 00 21  1 215      
    mov [rbp-8] (asAlphanum),rbx          ;#0044A0DD: 48:211135 F8               vu 00 28  1 215      
    mov qword[rbp-16] (errcode),88        ;#0044A0E1: 48:307105 F0 58000000      uv 00 20  1 216      
    mov qword[rbp-24] (level),4           ;#0044A0E9: 48:307105 E8 04000000      vu 00 20  1 216      
    mov qword[retaddr],#0044A0FE          ;#0044A0F1: 48:307105 20 FEA04400      uv 00 20  1 217      
    jmp #0044A1D9 (code:toString)         ;#0044A0F9: 351 DB000000               v  00 00  1 217      
    push rax                              ;#0044A0FE: 120                        uv 00 01  1 218      
    mov rdi,[rbp-80] (argstring)          ;#0044A0FF: 48:213175 B0               vu 80 20  1 218      
    mov r15,h4                            ;#0044A103: 49:277 0000000000000040    uv 8000 00  1 219      
    cmp rdi,r15                           ;#0044A10D: 4C:071377                  uv 00 8080  1 220 8000   
    jle #0044A122                         ;#0044A110: 176 10                     v  00 00  1 220      
    sub qword[rbx+rdi*4-16],1             ;#0044A112: 48:203154273 F0 01         u  00 88  3 221      
    jne #0044A122                         ;#0044A118: 165 08                     v  00 00  1 223      
    mov rdx,rdi                           ;#0044A11A: 48:213327                  uv 04 80  1 224      
    call #004422DA (:%pDealloc)           ;#0044A11D: 350 B881FFFF               v  00 00  1 224      
    pop dword[rbp-80] (argstring)         ;#0044A122: 217105 B0                  np 00 20  3 225      
;  1504                 #ilASM{
;  1505                         [32]
;  1506                             mov edx,[argstring]
;  1507                             shl edx,2   -- (convert to raw address)
;  1508                             push edx
;  1509                         [64]
;  1510                             mov rdx,[argstring]
                                    mov rdx,[rbp-80] (argstring)  ;#0044A125: 48:213125 B0               uv 04 20  1 228      
;  1511                             shl rdx,2   -- (convert to raw address)
                                    shl rdx,2  ;#0044A129: 48:301342 02               u  04 04  1 229      
;  1512                             push rdx
                                    push rdx  ;#0044A12D: 48:122                     uv 00 04  1 230 04   
;  1513                         []
;  1514                     }
;  1515                 cstrings = append(cstrings,argstring)   -- (keep refcounts>0, for a while)
    lea rdx,[rbp-120] (cstrings)          ;#0044A12F: 48:215125 88               vu 04 20  1 230      
    lea rdi,[rbp-120] (cstrings)          ;#0044A133: 48:215175 88               uv 80 20  1 231      
    lea rcx,[rbp-80] (argstring)          ;#0044A137: 48:215115 B0               vu 02 20  1 231      
    xor rax,rax                           ;#0044A13B: 48:061300                  uv 01 01  1 232      
    call #0043FC15 (:%opApnd)             ;#0044A13E: 350 D25AFFFF               v  00 00  1 232      
;  1516             end if
;  1517         end for
    mov rsi,[rbp-176] (i)                 ;#0044A143: 48:213265 50FFFFFF         uv 40 20  1 233      
    mov rdx,1                             ;#0044A14A: 48:307302 01000000         vu 04 00  1 233      
    add rsi,-1                            ;#0044A151: 48:203306 FF               uv 40 40  1 234      
    cmp rsi,rdx                           ;#0044A155: 48:073362                  uv 00 44  1 235 40   
    mov [rbp-176] (i),rsi                 ;#0044A158: 48:211265 50FFFFFF         vu 00 60  1 235      
    jge #00449F25                         ;#0044A15F: 017215 C0FDFFFF            v  00 00  1 236      
;  1518     end if
;  1519     return {return_type,addr,cstrings}
    lea rax,[rbp-184] (symtab[1250])      ;#0044A165: 48:215205 48FFFFFF         uv 01 20  1 237      
    mov rdx,3                             ;#0044A16C: 48:307302 03000000         vu 04 00  1 237      
    push #0044A1C6                        ;#0044A173: 150 C6A14400               uv 00 00  1 238      
    push rax                              ;#0044A178: 120                        vu 00 01  1 238      
    mov rcx,[rbp-120] (cstrings)          ;#0044A179: 48:213115 88               uv 02 20  1 239      
    mov r15,h4                            ;#0044A17D: 49:277 0000000000000040    vu 8000 00  1 239      
    cmp rcx,r15                           ;#0044A187: 4C:071371                  uv 00 8002  1 240      
    jl #0044A197                          ;#0044A18A: 174 0B                     v  00 00  1 240      
    add qword[rbx+rcx*4-16],1             ;#0044A18C: 48:203104213 F0 01         u  00 0A  3 241      
    cmp eax,1240                          ;#0044A192: 075 D8040000               vu 00 01  1 243      
    push rcx                              ;#0044A197: 121                        uv 00 02  1 244      
    mov rax,[rbp-112] (addr)              ;#0044A198: 48:213105 90               vu 01 20  1 244      
    mov r15,h4                            ;#0044A19C: 49:277 0000000000000040    uv 8000 00  1 245      
    cmp rax,r15                           ;#0044A1A6: 4C:071370                  uv 00 8001  1 246 8000   
    jl #0044A1B6                          ;#0044A1A9: 174 0B                     v  00 00  1 246      
    add qword[rbx+rax*4-16],1             ;#0044A1AB: 48:203104203 F0 01         u  00 09  3 247      
    cmp eax,1239                          ;#0044A1B1: 075 D7040000               vu 00 01  1 249      
    push rax                              ;#0044A1B6: 120                        uv 00 01  1 250      
    push qword[rbp-88] (return_type)      ;#0044A1B7: 377165 A8                  np 00 20  2 251      
    mov rdi,[rbp-184] (symtab[1250])      ;#0044A1BA: 48:213275 48FFFFFF         uv 80 20  1 253      
    jmp #004404BD (:%pMkSq)               ;#0044A1C1: 351 F762FFFF               v  00 00  1 253      
    mov rax,[rbp-184] (symtab[1250])      ;#0044A1C6: 48:213205 48FFFFFF         uv 01 20  1 254      
    mov [rbp-184] (symtab[1250]),rbx      ;#0044A1CD: 48:211235 48FFFFFF         vu 00 28  1 254      
    jmp #0044298D (:%opRetf)              ;#0044A1D4: 351 B487FFFF               v  00 00  1 255      
;  1520 end function
;  1521 
;  1522 
;  1523 global function c_func(integer rid, sequence args={})
    mov rdi,[rbp-8] (args)                ;#00449946: 48:213175 F8               uv 80 20  1   1      
    mov r15,h4                            ;#0044994A: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rdi,r15                           ;#00449954: 4C:071377                  uv 00 8080  1   2      
    jne #0044996F                         ;#00449957: 165 16                     v  00 00  1   2      
    mov rdi,qword[#004022C8]              ;#00449959: 48:213075 6889FBFF         uv 80 00  1   3      
    mov [rbp-8] (args),rdi                ;#00449960: 48:211175 F8               uv 00 A0  1   4 80   
    add qword[rbx+rdi*4-16],1             ;#00449964: 48:203104273 F0 01         u  00 88  3   6    *80*
    cmp eax,233                           ;#0044996A: 075 E9000000               vu 00 01  1   8      
;  1524 integer return_type
;  1525 object r
;  1526 --DEV /4 trick:
;  1527 integer c_esp_lo = 0    -- save/restore esp (just in case)  [dev it is dword-aligned!]
    mov [rbp-32] (c_esp_lo),rbx           ;#0044996F: 48:211135 E0               uv 00 28  1   9      
;  1528 integer c_esp_hi = 0
    mov [rbp-40] (c_esp_hi),rbx           ;#00449973: 48:211135 D8               vu 00 28  1   9      
;  1529 integer local_ebp
;  1530 atom addr
;  1531 sequence cstrings -- Keeps refcounts>0, of any temps we had to make, over the call.
;  1532                   -- Freed automatically, after we get back from the call_eax, /not/
;  1533                   -- on exit from, or mid-way through, calling the c_common routine.
;  1534 
;  1535     #ilASM{
;  1536             [32]
;  1537                 mov eax,esp
;  1538                 mov ecx,esp
;  1539                 shr eax,16
;  1540                 and ecx,#0000FFFF
;  1541                 mov [c_esp_hi],eax
;  1542                 mov [c_esp_lo],ecx
;  1543             [64]
;  1544 --DEV better yet: use the push rsp twice, or rsp,8 trick... (nah...)
;  1545                 mov rax,rsp
                        mov rax,rsp       ;#00449977: 48:213304                  uv 01 10  1  10      
;  1546                 mov rcx,rsp
                        mov rcx,rsp       ;#0044997A: 48:213314                  vu 02 10  1  10      
;  1547                 shr rax,32
                        shr rax,32        ;#0044997D: 48:301350 20               u  01 01  1  11      
;  1548                 and rcx,#FFFFFFFF
                        and rcx,-1        ;#00449981: 48:201341 FFFFFFFF         vu 02 02  1  11      
;  1549                 mov [c_esp_hi],rax
                        mov [rbp-40] (c_esp_hi),rax  ;#00449988: 48:211105 D8               uv 00 21  1  12      
;  1550                 mov [c_esp_lo],rcx
                        mov [rbp-32] (c_esp_lo),rcx  ;#0044998C: 48:211115 E0               vu 00 22  1  12      
;  1551             []
;  1552         }
;  1553     {return_type,addr,cstrings} = c_common(rid,args,FUNC)
    mov rcx,24                            ;#00449990: 48:307301 18000000         uv 02 00  1  13      
    mov rdx,1224                          ;#00449997: 48:307302 C8040000         vu 04 00  1  13      
    call :%opFrame (c_common)             ;#0044999E: 350 388FFFFF               v  00 00  1  14      
    mov rdi,[rbp+40] (prevebp)            ;#004499A3: 48:213175 28               uv 80 20  1  15      
    mov rax,[rdi]                         ;#004499A7: 48:213007                  uv 01 80  1  18 80 *80*
    mov [rbp] (rid),rax                   ;#004499AA: 48:211105 00               uv 00 21  1  19 01   
    mov rdi,[rbp+40] (prevebp)            ;#004499AE: 48:213175 28               vu 80 20  1  19      
    mov rax,[rdi-8]                       ;#004499B2: 48:213107 F8               uv 01 80  1  22    *80*
    xor rbx,rbx                           ;#004499B6: 48:061333                  vu 08 08  1  22      
    mov r15,h4                            ;#004499B9: 49:277 0000000000000040    uv 8000 00  1  23      
    cmp rax,r15                           ;#004499C3: 4C:071370                  uv 00 8001  1  24 8000   
    jl #004499D3                          ;#004499C6: 174 0B                     v  00 00  1  24      
    add qword[rbx+rax*4-16],1             ;#004499C8: 48:203104203 F0 01         u  00 09  3  25      
    cmp eax,1252                          ;#004499CE: 075 E4040000               vu 00 01  1  27      
    mov [rbp-8] (args),rax                ;#004499D3: 48:211105 F8               uv 00 21  1  28      
    mov qword[rbp-16] (flag),1            ;#004499D7: 48:307105 F0 01000000      vu 00 20  1  28      
    mov qword[retaddr],#004499EC          ;#004499DF: 48:307105 20 EC994400      uv 00 20  1  29      
    jmp #00449C31 (code:c_common)         ;#004499E7: 351 45020000               v  00 00  1  29      
    push rax                              ;#004499EC: 120                        uv 00 01  1  30      
    mov rsi,[rbp-72] (symtab[1260])       ;#004499ED: 48:213165 B8               vu 40 20  1  30      
    mov r15,h4                            ;#004499F1: 49:277 0000000000000040    uv 8000 00  1  31      
    cmp rsi,r15                           ;#004499FB: 4C:071376                  uv 00 8040  1  32 8000   
    jle #00449A10                         ;#004499FE: 176 10                     v  00 00  1  32      
    sub qword[rbx+rsi*4-16],1             ;#00449A00: 48:203154263 F0 01         u  00 48  3  33      
    jne #00449A10                         ;#00449A06: 165 08                     v  00 00  1  35      
    mov rdx,rsi                           ;#00449A08: 48:213326                  uv 04 40  1  36      
    call #004422DA (:%pDealloc)           ;#00449A0B: 350 CA88FFFF               v  00 00  1  36      
    pop dword[rbp-72] (symtab[1260])      ;#00449A10: 217105 B8                  np 00 20  3  37      
    mov rdi,3                             ;#00449A13: 48:307307 03000000         uv 80 00  1  40      
    lea rcx,[rbp-64] (cstrings)           ;#00449A1A: 48:215115 C0               vu 02 20  1  40      
    mov rsi,[rbp-72] (symtab[1260])       ;#00449A1E: 48:213165 B8               uv 40 20  1  41      
    mov rdx,1260                          ;#00449A22: 48:307302 EC040000         vu 04 00  1  41      
    call #00441675 (:%pSubse1)            ;#00449A29: 350 477CFFFF               v  00 00  1  42      
    mov rcx,[rbp-64] (cstrings)           ;#00449A2E: 48:213115 C0               uv 02 20  1  43      
    mov r15,h4                            ;#00449A32: 49:277 0000000000000040    vu 8000 00  1  43      
    cmp rcx,r15                           ;#00449A3C: 4C:071371                  uv 00 8002  1  44      
    jl #00449A48                          ;#00449A3F: 174 07                     v  00 00  1  44      
    test byte[rbx+rcx*4-1],#80            ;#00449A41: 366104213 FF 80            u  00 0A  2  45      
    jne #00449A54                         ;#00449A46: 165 0C                     v  00 00  1  46      
    mov rcx,1259                          ;#00449A48: 48:307301 EB040000         uv 02 00  1  47      
    call #00442A58 (:%opTchkFail)         ;#00449A4F: 350 0490FFFF               v  00 00  1  47      
    mov rdi,2                             ;#00449A54: 48:307307 02000000         uv 80 00  1  48      
    lea rcx,[rbp-56] (addr)               ;#00449A5B: 48:215115 C8               vu 02 20  1  48      
    mov rsi,[rbp-72] (symtab[1260])       ;#00449A5F: 48:213165 B8               uv 40 20  1  49      
    mov rdx,1260                          ;#00449A63: 48:307302 EC040000         vu 04 00  1  49      
    call #00441675 (:%pSubse1)            ;#00449A6A: 350 067CFFFF               v  00 00  1  50      
    mov rdi,[rbp-56] (addr)               ;#00449A6F: 48:213175 C8               uv 80 20  1  51      
    mov r15,h4                            ;#00449A73: 49:277 0000000000000040    vu 8000 00  1  51      
    cmp rdi,r15                           ;#00449A7D: 4C:071377                  uv 00 8080  1  52      
    jl #00449A95                          ;#00449A80: 174 13                     v  00 00  1  52      
    cmp byte[rbx+rdi*4-1],#12             ;#00449A82: 200174273 FF 12            u  00 88  2  53      
    je #00449A95                          ;#00449A87: 164 0C                     v  00 00  1  54      
    mov rcx,1258                          ;#00449A89: 48:307301 EA040000         uv 02 00  1  55      
    call #00442A58 (:%opTchkFail)         ;#00449A90: 350 C38FFFFF               v  00 00  1  55      
    mov rdi,1                             ;#00449A95: 48:307307 01000000         uv 80 00  1  56      
    lea rcx,[rbp-16] (return_type)        ;#00449A9C: 48:215115 F0               vu 02 20  1  56      
    mov rsi,[rbp-72] (symtab[1260])       ;#00449AA0: 48:213165 B8               uv 40 20  1  57      
    mov rdx,1260                          ;#00449AA4: 48:307302 EC040000         vu 04 00  1  57      
    call #004416F2 (:%pSubse1i)           ;#00449AAB: 350 427CFFFF               v  00 00  1  58      
    mov r15,h4                            ;#00449AB0: 49:277 0000000000000040    uv 8000 00  1  59      
    cmp rax,r15                           ;#00449ABA: 4C:071370                  uv 00 8001  1  60 8000   
    jl #00449ACB                          ;#00449ABD: 174 0C                     v  00 00  1  60      
    mov rcx,1253                          ;#00449ABF: 48:307301 E5040000         uv 02 00  1  61      
    call #00442A58 (:%opTchkFail)         ;#00449AC6: 350 8D8FFFFF               v  00 00  1  61      
;  1554 
;  1555 --(DEV: delete once all types are handled)
;  1556     if not find(return_type,{
;  1557 --                               C_CHAR,        -- #01000001
;  1558                              C_UCHAR,       -- #02000001
;  1559                              C_SHORT,       -- #01000002
;  1560                              C_USHORT,      -- #02000002
;  1561                              C_INT,         -- #01000004    -- == C_LONG
;  1562                              C_UINT,        -- #02000004    -- == C_ULONG, C_POINTER, C_PTR
;  1563                              C_FLOAT,       -- #03000004
;  1564                              C_DOUBLE,      -- #03000008
    mov rcx,7                             ;#00449ACB: 48:307301 07000000         uv 02 00  1  62      
    mov rdx,75                            ;#00449AD2: 48:307302 4B000000         vu 04 00  1  62      
    call #004428DB (:%opFrame) (find)     ;#00449AD9: 350 FD8DFFFF               v  00 00  1  63      
    mov rdi,[rbp+40] (prevebp)            ;#00449ADE: 48:213175 28               uv 80 20  1  64      
    mov rax,[rdi-16]                      ;#00449AE2: 48:213107 F0               uv 01 80  1  67 80 *80*
    mov [rbp] (x),rax                     ;#00449AE6: 48:211105 00               uv 00 21  1  68 01   
    mov rcx,qword[#00403380]              ;#00449AEA: 48:213015 8F98FBFF         vu 02 00  1  68      
    mov [rbp-8] (s),rcx                   ;#00449AF1: 48:211115 F8               uv 00 22  1  69      
    add qword[rbx+rcx*4-16],1             ;#00449AF5: 48:203104213 F0 01         u  00 0A  3  71    *02*
    mov qword[retaddr],#00449B08          ;#00449AFB: 48:307105 20 089B4400      vu 00 20  1  73      
    jmp #0043DAD6 (code:find)             ;#00449B03: 351 CE3FFFFF               v  00 00  1  74      
    test rax,rax                          ;#00449B08: 48:205300                  uv 00 01  1  75      
    jne #00449B12                         ;#00449B0B: 165 05                     v  00 00  1  75      
;  1565 --                               E_INTEGER,     -- #06000004    \
;  1566 --                               E_ATOM,        -- #07000004     \ (Should probably be reserved
;  1567 --                               E_SEQUENCE,    -- #08000004     /  for RDS Eu-built dlls)
;  1568 --                               E_OBJECT,      -- #09000004    /
;  1569 -- possibly:
;  1570 --C:\Program Files\Phix\psym.e:1304 --  initialConstant("P_REF",          #04000004)??
;  1571 --                               P_INTEGER,     -- #04010004    \
;  1572 --                               P_ATOM,        -- #04030004     \ (ie reserved for Phix-built
;  1573 --                               P_STRING,      -- #04040004      > dlls, if we ever get round
;  1574 --                               P_SEQUENCE,    -- #040C0004     /  to creating them that is!)
;  1575 --                               P_OBJECT,      -- #040F0004    /
;  1576 --                               ""}) then      -- (dummy entry)
;  1577                                  $}) then       -- (dummy entry)
;  1578 --          printf(1,"c_func: return type %08x not yet coded/tested\n",return_type)
;  1579         ?9/0    -- return type not yet coded/tested!
    call #00442DD2 (:%pDiv0)              ;#00449B0D: 350 C092FFFF               v  00 00  1  76      
;  1580 --DEV e15?
;  1581 
;  1582     end if
;  1583 
;  1584     --
;  1585     -- Call the routine and convert result (in eax/ST0) to a Phix ref:
;  1586     --
;  1587     #ilASM{
;  1588             [32]
;  1589                 call :%save_ebp
;  1590                 mov [local_ebp],eax
;  1591                 mov eax,[addr]
;  1592                 cmp eax,h4  --DEV :%pLoadMint
;  1593                 jl @f
;  1594                     -- addr>#3FFFFFFF stored as float:
;  1595                     sub esp,8
;  1596                     fld qword[ebx+eax*4]
;  1597                     fistp qword[esp]
;  1598                     pop eax
;  1599                     add esp,4
;  1600             @@:
;  1601 
;  1602                 call eax
;  1603 
;  1604                 mov edx,[c_esp_hi]
;  1605                 mov ecx,[c_esp_lo]
;  1606                 shl edx,16
;  1607                 xor ebx,ebx         -- (Phix likes it zero!)
;  1608                 add ecx,edx
;  1609                 mov edx,[return_type]
;  1610                 mov esp,ecx
;  1611 
;  1612                 cmp edx,0x01000004  -- (C_INT [== C_LONG])
;  1613                 jne @f
;  1614                     cmp eax,h4
;  1615                     jb :intres          -- (0..#3FFFFFFF)
;  1616                     cmp eax,#C0000000
;  1617                     jae :intres         -- (#C0000000..#FFFFFFFF)
;  1618                         push eax
;  1619                         fild dword[esp]
;  1620                         pop eax -- (discard)
;  1621                         jmp :cstore
;  1622             @@:
;  1623                 cmp edx,0x02000004  -- (C_UINT [== C_ULONG, C_POINTER, C_PTR])
;  1624                 jne @f
;  1625                     cmp eax,h4
;  1626                     jb :intres          -- (0..#3FFFFFFF)
;  1627 --                  cmp eax,#C0000000
;  1628 --                  jae :intres         -- (#C0000000..#FFFFFFFF)
;  1629                     push ebx            -- (0)
;  1630                     push eax
;  1631                     fild qword[esp]
;  1632                     add esp,8
;  1633                     jmp :cstore
;  1634             @@:
;  1635                 cmp edx,0x03000004  -- (C_FLOAT)
;  1636                 je :cstore
;  1637                 cmp edx,0x03000008  -- (C_DOUBLE)
;  1638                 jne @f
;  1639             ::cstore                                        --    cstore:
;  1640 --DEV (to go) [temporary compatibility kludge, while pwy.exe is 26/08/2012]
;  1641 --                  lea edx,[r]
;  1642                     lea edi,[r]
;  1643 --                  call %opMovbi       -- call StoreFlt
;  1644                     call :%pStoreFlt                    -- ([edi]:=ST0)
;  1645                     jmp :done
;  1646             @@:
;  1647                 cmp edx,0x01000002  -- (C_SHORT)
;  1648                 jne @f
;  1649                     cwde                                    -- (ax->eax) [in range -32768..32767]
;  1650                     jmp :intres
;  1651             @@:
;  1652                 cmp edx,0x02000001  -- (C_UCHAR)
;  1653                 jne @f
;  1654                     and eax,0xFF
;  1655                     jmp :intres
;  1656             @@:
;  1657                 cmp edx,0x02000002  -- (C_USHORT)
;  1658                 jne @f
;  1659                     and eax,0x0000FFFF
;  1660                     jmp :intres
;  1661             @@:
;  1662 --              cmp edx,0x01000001  -- (C_CHAR)
;  1663 --              jne @f
;  1664 --                  cbw                                     -- (al->ax)
;  1665 --                  cwde                                    -- (ax->eax) [in range -128..127]
;  1666 --                  jmp :intres
;  1667 --          @@:
;  1668 --              cmp edx,0x02000001  -- (C_UCHAR)
;  1669 --              jne @f
;  1670 --                  and eax,0xFF
;  1671 --                  jmp :intres
;  1672 --          @@:
;  1673                 call :%e02atdb0
;  1674 --DEV e15 instead
;  1675 
;  1676             ::intres                                        -- intres:
;  1677                 mov [r],eax
;  1678             ::done                                          -- done:
;  1679                 mov edx,[local_ebp]
;  1680                 call :%restore_ebp
;  1681             [64]
;  1682                 call :%save_rbp
                        call #0043B17C (:%save_rbp)  ;#00449B12: 350 6516FFFF               v  00 00  1  77      
;  1683                 mov [local_ebp],rax
                        mov [rbp-48] (local_ebp),rax  ;#00449B17: 48:211105 D0               uv 00 21  1  78      
;  1684                 mov rax,[addr]
                        mov rax,[rbp-56] (addr)  ;#00449B1B: 48:213105 C8               vu 01 20  1  78      
;  1685 --              cmp rax,h4
;  1686                 mov r15,h4
                        mov r15,h4        ;#00449B1F: 49:277 0000000000000040    uv 8000 00  1  79      
;  1687                 cmp rax,r15
                        cmp rax,r15       ;#00449B29: 49:073307                  uv 00 8001  1  80 8000   
;  1688                 jl @f
                        jl #00449B3A      ;#00449B2C: 174 0C                     v  00 00  1  80      
;  1689                     -- addr>#3FFFFFFFFFFFFFFF stored as float:
;  1690                     sub rsp,8
                            sub rsp,8     ;#00449B2E: 48:203354 08               uv 10 10  1  81      
;  1691                     fld tbyte[rbx+rax*4]
                            fld tbyte[rbx+rax*4]  ;#00449B32: 333054203                  np 00 09  3  82      
;  1692                     fistp qword[rsp]
                            fistp qword[rsp]  ;#00449B35: 337074044                  np 00 10  6  85      
;  1693                     pop rax
                            pop rax       ;#00449B38: 48:130                     uv 01 00  1  91      
;  1694             @@:
;  1695 --[PE64]    
;  1696                 mov rcx,[rsp]
                        mov rcx,[rsp]     ;#00449B3A: 48:213014044               vu 02 10  1  91      
;  1697                 mov rdx,[rsp+8]
                        mov rdx,[rsp+8]   ;#00449B3E: 48:213124044 08            uv 04 10  1  92      
;  1698                 mov r8,[rsp+16]
                        mov r8,[rsp+16]   ;#00449B43: 4C:213104044 10            vu 100 10  1  92      
;  1699                 mov r9,[rsp+24]
                        mov r9,[rsp+24]   ;#00449B48: 4C:213114044 18            uv 200 10  1  93      
;  1700 --[ELF64]?
;  1701                 call rax
                        call rax          ;#00449B4D: 377320                     np 00 01  2  94      
;  1702 
;  1703                 mov rdx,[c_esp_hi]
                        mov rdx,[rbp-40] (c_esp_hi)  ;#00449B4F: 48:213125 D8               uv 04 20  1  96      
;  1704                 mov rcx,[c_esp_lo]
                        mov rcx,[rbp-32] (c_esp_lo)  ;#00449B53: 48:213115 E0               vu 02 20  1  96      
;  1705                 shl rdx,32
                        shl rdx,32        ;#00449B57: 48:301342 20               u  04 04  1  97      
;  1706                 xor rbx,rbx         -- (Phix likes it zero!)
                        xor rbx,rbx       ;#00449B5B: 48:061333                  vu 08 08  1  97      
;  1707                 add rcx,rdx
                        add rcx,rdx       ;#00449B5E: 48:001321                  uv 02 06  1  98      
;  1708                 mov rdx,[return_type]
                        mov rdx,[rbp-16] (return_type)  ;#00449B61: 48:213125 F0               vu 04 20  1  98      
;  1709                 mov rsp,rcx
                        mov rsp,rcx       ;#00449B65: 48:213341                  uv 10 02  1  99      
;  1710 
;  1711                 cmp rdx,0x01000004  -- (C_INT [== C_LONG])
                        cmp rdx,16777220  ;#00449B68: 48:201372 04000001         vu 00 04  1  99      
;  1712                 jne @f
                        jne #00449B97     ;#00449B6F: 165 26                     v  00 00  1 100      
;  1713 --                  cmp rax,h4
;  1714 --                  mov r15,h4
;  1715                     cmp rax,r15
                            cmp rax,r15   ;#00449B71: 49:073307                  uv 00 8001  1 101      
;  1716                     jb :intres          -- (0..#3FFFFFFFFFFFFFFF)
                            jb #00449C17  ;#00449B74: 017202 9D000000            v  00 00  1 101      
;  1717 --                  mov r14,#C000000000000000
;  1718                     mov r14,#C0000000 --0000 0000
                            mov r14,-1073741824  ;#00449B7A: 49:307306 000000C0         uv 4000 00  1 102      
;  1719                     shl r14,32
                            shl r14,32    ;#00449B81: 49:301346 20               u  4000 4000  1 103      
;  1720                     cmp rax,r14
                            cmp rax,r14   ;#00449B85: 49:073306                  uv 00 4001  1 104 4000   
;  1721                     jae :intres         -- (#C0000000..#FFFFFFFF)
                            jae #00449C17  ;#00449B88: 017203 89000000            v  00 00  1 104      
;  1722                         push rax
                                push rax  ;#00449B8E: 48:120                     uv 00 01  1 105      
;  1723                         fild qword[esp]
                                fild qword[rsp]  ;#00449B90: 337054044                  np 00 10  3 106      
;  1724                         pop rax -- (discard)
                                pop rax   ;#00449B93: 48:130                     uv 01 00  1 109      
;  1725                         jmp :cstore
                                jmp #00449BD5  ;#00449B95: 353 3E                     v  00 00  1 109      
;  1726             @@:
;  1727                 cmp rdx,0x02000004  -- (C_UINT [== C_ULONG, C_POINTER, C_PTR])
                        cmp rdx,33554436  ;#00449B97: 48:201372 04000002         uv 00 04  1 110      
;  1728                 jne @f
                        jne #00449BC3     ;#00449B9E: 165 23                     v  00 00  1 110      
;  1729 --                  cmp rax,h4
;  1730 --                  mov r15,h4
;  1731                     cmp rax,r15
                            cmp rax,r15   ;#00449BA0: 49:073307                  uv 00 8001  1 111      
;  1732                     jb :intres          -- (0..#3FFFFFFFFFFFFFFF)
                            jb #00449C17  ;#00449BA3: 162 72                     v  00 00  1 111      
;  1733 --                  cmp eax,#C000000000000000
;  1734 --                  jae :intres         -- (#C0000000..#FFFFFFFF)
;  1735 --                  push rax
;  1736 --                  fild qword[rsp]
;  1737 --                  add rsp,8
;  1738                     -- to load unsigned, right shift rax by 1, save odd bit in rcx, then *2+[0|1]
;  1739                     mov rcx,rbx
                            mov rcx,rbx   ;#00449BA5: 48:213313                  uv 02 08  1 112      
;  1740                     shr rax,1
                            shr rax,1     ;#00449BA8: 48:321350                  u  01 01  1 113      
;  1741                     rcl rcx,1
                            rcl rcx,1     ;#00449BAB: 48:321321                  u  02 02  1 114      
;  1742                     push rax
                            push rax      ;#00449BAE: 48:120                     vu 00 01  1 114      
;  1743                     push rcx
                            push rcx      ;#00449BB0: 48:121                     uv 00 02  1 115      
;  1744                     fild qword[rsp]
                            fild qword[rsp]  ;#00449BB2: 337054044                  np 00 10  3 116      
;  1745                     fild qword[rsp+8]
                            fild qword[rsp+8]  ;#00449BB5: 337154044 08               np 00 10  3 119      
;  1746                     add rsp,16
                            add rsp,16    ;#00449BB9: 48:203304 10               uv 10 10  1 122      
;  1747                     fadd st0,st0
                            fadd st0,st0  ;#00449BBD: 330300                     np 00 00  3 123      
;  1748                     faddp
                            faddp st1,st0  ;#00449BBF: 336301                     np 00 00  3 126      
;  1749                     jmp :cstore
                            jmp #00449BD5  ;#00449BC1: 353 12                     v  00 00  1 129      
;  1750             @@:
;  1751                 cmp rdx,0x03000004  -- (C_FLOAT)
                        cmp rdx,50331652  ;#00449BC3: 48:201372 04000003         uv 00 04  1 130      
;  1752                 je :cstore
                        je #00449BD5      ;#00449BCA: 164 09                     v  00 00  1 130      
;  1753                 cmp rdx,0x03000008  -- (C_DOUBLE)
                        cmp rdx,50331656  ;#00449BCC: 48:201372 08000003         uv 00 04  1 131      
;  1754                 jne @f
                        jne #00449BE0     ;#00449BD3: 165 0B                     v  00 00  1 131      
;  1755             ::cstore                                        --    cstore:
;  1756                     lea rdi,[r]
                            lea rdi,[rbp-24] (r)  ;#00449BD5: 48:215175 E8               uv 80 20  1 132      
;  1757                     call :%pStoreFlt                    -- ([rdi]:=ST0)
                            call #004421B0 (:%pStoreFlt)  ;#00449BD9: 350 D285FFFF               v  00 00  1 132      
;  1758                     jmp :done
                            jmp #00449C1B  ;#00449BDE: 353 3B                     v  00 00  1 133      
;  1759             @@:
;  1760                 cmp rdx,0x01000002  -- (C_SHORT)
                        cmp rdx,16777218  ;#00449BE0: 48:201372 02000001         uv 00 04  1 134      
;  1761                 jne @f
                        jne #00449BEE     ;#00449BE7: 165 05                     v  00 00  1 134      
;  1762                     cwde                                    -- (ax->eax) [in range -32768..32767]
                            cwde          ;#00449BE9: 230                        np 01 01  3 135      
;  1763 --                  and rax,0xFFFF
;  1764                     cdqe                                    -- (nb does not list right in FDBG)
                            cdqe          ;#00449BEA: 48:230                     np 01 01  3 138      
;  1765                     jmp :intres
                            jmp #00449C17  ;#00449BEC: 353 29                     v  00 00  1 141      
;  1766             @@:
;  1767                 cmp rdx,0x02000001  -- (C_UCHAR)
                        cmp rdx,33554433  ;#00449BEE: 48:201372 01000002         uv 00 04  1 142      
;  1768                 jne @f
                        jne #00449C00     ;#00449BF5: 165 09                     v  00 00  1 142      
;  1769                     and rax,0x00FF
                            and rax,255   ;#00449BF7: 48:201340 FF000000         uv 01 01  1 143      
;  1770                     jmp :intres
                            jmp #00449C17  ;#00449BFE: 353 17                     v  00 00  1 143      
;  1771             @@:
;  1772                 cmp rdx,0x02000002  -- (C_USHORT)
                        cmp rdx,33554434  ;#00449C00: 48:201372 02000002         uv 00 04  1 144      
;  1773                 jne @f
                        jne #00449C12     ;#00449C07: 165 09                     v  00 00  1 144      
;  1774                     and rax,0x0000FFFF
                            and rax,65535  ;#00449C09: 48:201340 FFFF0000         uv 01 01  1 145      
;  1775                     jmp :intres
                            jmp #00449C17  ;#00449C10: 353 05                     v  00 00  1 145      
;  1776             @@:
;  1777 --              cmp rdx,0x01000001  -- (C_CHAR)
;  1778 --              jne @f
;  1779 --                  cbw                                     -- (al->ax)
;  1780 --                  cwde                                    -- (ax->eax) [in range -128..127]
;  1781 --                  cdqe
;  1782 --                  jmp :intres
;  1783 --          @@:
;  1784 --              cmp rdx,0x02000001  -- (C_UCHAR)
;  1785 --              jne @f
;  1786 --                  and rax,0xFF
;  1787 --                  jmp :intres
;  1788 --          @@:
;  1789                 call :%e02atdb0
                        call #00442DD2 (:%pDiv0)  ;#00449C12: 350 BB91FFFF               v  00 00  1 146      
;  1790 --DEV e15 instead
;  1791 
;  1792             ::intres                                        -- intres:
;  1793                 mov [r],rax
                        mov [rbp-24] (r),rax  ;#00449C17: 48:211105 E8               uv 00 21  1 147      
;  1794             ::done                                          -- done:
;  1795 --DEV beginning to think this is drivel... (as per c_proc)
;  1796 -- (erm, just badly named??)
;  1797                 mov rdx,[local_ebp]
                        mov rdx,[rbp-48] (local_ebp)  ;#00449C1B: 48:213125 D0               vu 04 20  1 147      
;  1798                 call :%restore_rbp
                        call #0043B18A (:%restore_rbp)  ;#00449C1F: 350 6615FFFF               v  00 00  1 148      
;  1799             []
;  1800         }
;  1801     return r
    mov rax,[rbp-24] (r)                  ;#00449C24: 48:213105 E8               uv 01 20  1 149      
    mov [rbp-24] (r),rbx                  ;#00449C28: 48:211135 E8               vu 00 28  1 149      
    jmp #0044298D (:%opRetf)              ;#00449C2C: 351 5C8DFFFF               v  00 00  1 150      
;  1802 end function
;  1803 
;  1804 --    opCFuncZeroParams:
;  1805 --
;  1806 --  mov ecx,[ebpidx]
;  1807 --  mov [ebpsave+ecx],ebp   ; in case of callback
;  1808 --      call eax
;  1809 --      mov edi,FltWrk
;  1810 --      xor ebx,ebx
;  1811 --      pop esi                 ;[2] dcftbl entry addr
;  1812 --   ;  [esi] contains a 32-bit function address
;  1813 --   ;  [esi+4] contains the number of parameters
;  1814 --   ;  [esi+8] contains the return type
;  1815 --   ;  [esi+12] contains the calling convention
;  1816 --
;  1817 --  ;;DEV::
;  1818 --  ;   cmp dword[esi+8],0x03000008     ; C_DOUBLE?
;  1819 --  ;   mov cl,[esi+11]     0x01 signed, 0x02 unsigned, 0x03 float  
;  1820 --  ;;DEV???
;  1821 --  ;   cmp [ecode],0
;  1822 --  ;   je @f
;  1823 --  ;       pop eax
;  1824 --  ;       ret
;  1825 --  ;  @@:
;  1826 --      mov ecx,[esi+8]
;  1827 --      cmp cl,4
;  1828 --      je opCFuncDword
;  1829 --  ;   cmp cl,8
;  1830 --      cmp ecx,0x03000008
;  1831 --      je opCFuncDouble
;  1832 --      cmp cl,2
;  1833 --      je opCFuncWord
;  1834 --      cmp cl,1
;  1835 --      jne e15ucfrt            ; unknown cfunc return type
;  1836 --      and eax,0xFF
;  1837 --    opCFuncWord:  
;  1838 --      and eax,0x0000FFFF
;  1839 --    opCFuncDword: 
;  1840 --      rol ecx,8
;  1841 --      mov dword[edi],eax
;  1842 --  ;   cmp byte[esi+11],0x02
;  1843 --      cmp cl,1
;  1844 --      jne opCFunsigned
;  1845 --  ;   initialConstant("C_CHAR",       #01000001)
;  1846 --  ;   initialConstant("C_UCHAR",      #02000001)
;  1847 --  ;   initialConstant("C_SHORT",      #01000002)
;  1848 --  ;   initialConstant("C_USHORT",     #02000002)
;  1849 --  ;   initialConstant("C_INT",        #01000004)
;  1850 --  ;   initialConstant("C_UINT",       #02000004)
;  1851 --  ;   initialConstant("C_FLOAT",      #03000004)
;  1852 --  ;   initialConstant("C_DOUBLE",     #03000008)  -- result in st0
;  1853 --  ;   initialConstant("E_INTEGER",    #06000004)
;  1854 --  ;   initialConstant("E_ATOM",       #07000004)
;  1855 --  ;   initialConstant("E_SEQUENCE",   #08000004)
;  1856 --  ;   initialConstant("E_OBJECT",     #09000004)
;  1857 --
;  1858 --  ;   jge opCFunsigned
;  1859 --      fild dword[edi] ;;DEV was qword...
;  1860 --  ;   mov [FltWrk64],0
;  1861 --  ;   fild qword[FltWrk]
;  1862 --  ;  @@:
;  1863 --    opCFuncDouble:
;  1864 --      pop edx
;  1865 --      push freeStrings
;  1866 --      jmp StoreFlt
;  1867 --
;  1868 --    opCFunsigned:
;  1869 --  ;   jg opCFloat
;  1870 --  ;   jg @b
;  1871 --      cmp cl,2    
;  1872 --      jne opCFuncElse
;  1873 --      mov dword[edi+4],ebx
;  1874 --      fild qword[edi]
;  1875 --      jmp opCFuncDouble
;  1876 --
;  1877 --    opCFuncElse:
;  1878 --      cmp cl,4
;  1879 --      jne @f
;  1880 --      ; P_REF handling
;  1881 --  ;   mov edi,edx
;  1882 --      mov eax,edx
;  1883 --      pop edi
;  1884 --      cmp eax,h4
;  1885 --      jl opCFuncStore
;  1886 --      inc dword[ebx+eax*4-8]
;  1887 --      jmp opCFuncStore
;  1888 --      
;  1889 --    @@:
;  1890 --      cmp cl,8
;  1891 --      jne e15ucfrtR8          ; unknown c_func return type
;  1892 --      ; E_SEQUENCE handling
;  1893 --  ;   shl eax,3
;  1894 --  ;               NO VALUE: 10111111 11111111 11111111 11111111   (undefined object)
;  1895 --  ;               ATOM-DBL: 101ppppp pppppppp pppppppp pppppppp   (29-bit pointer)
;  1896 --  ;               SEQUENCE: 100ppppp pppppppp pppppppp pppppppp   (29-bit pointer)
;  1897 --  ;struct s1 {                       /* a sequence header block */
;  1898 --  ;       object_ptr base;               /* pointer to (non-existent) 0th element */
;  1899 --  ;       long length;                   /* number of elements */
;  1900 --  ;       long ref;                      /* reference count */
;  1901 --  ;       long postfill;                 /* number of post-fill objects */
;  1902 --  ;}; /* total 16 bytes */
;  1903 --  ;struct d {                        /* a double precision number */
;  1904 --  ;       double dbl;                    /* double precision value */
;  1905 --  ;       long ref;                      /* reference count */
;  1906 --  ;}; /* total 12 bytes */
;  1907 --    opCFuncEseq:
;  1908 --  ;   push edx                ; result addr
;  1909 --      mov edx,[ebx+eax*8+4]   ; length (RDS Eu style)
;  1910 --      mov esi,[ebx+eax*8]     ; base (RDS Eu style)
;  1911 --      <mov edx,era>
;  1912 --      call AllocSeq           ; damages eax only
;  1913 --      test edx,edx
;  1914 --      jz opCFuncEseqZL
;  1915 --      mov ecx,edx
;  1916 --      lea edi,[ebx+eax*4]
;  1917 --    opCFuncEseqLoop:
;  1918 --      mov edx,[esi+4]
;  1919 --      add esi,4 
;  1920 --      cmp edx,0x80000000
;  1921 --      jb opCFuncEseqInt
;  1922 --      cmp edx,0xA0000000
;  1923 --      jb opCFuncEseqSubseq
;  1924 --      ; this is a float then:
;  1925 --      fld qword[ebx+edx*8]
;  1926 --      pushad
;  1927 --      call AllocFlt
;  1928 --      mov [esp+20],eax    ; (edx:=eax, the newly allocated ref)
;  1929 --      popad
;  1930 --      jmp opCFuncEseqInt
;  1931 --    opCFuncEseqSubseq:
;  1932 --      pushad
;  1933 --      mov eax,edx
;  1934 --      mov edx,edi         ; actually gets stored twice, not a problem,
;  1935 --      mov [edi],ebx       ; clear, just in case
;  1936 --      call opCFuncEseq
;  1937 --      mov [esp+20],eax    ; (edx:=eax, the newly allocated ref)
;  1938 --      popad
;  1939 --    opCFuncEseqInt:
;  1940 --      mov [edi],edx
;  1941 --      add edi,4
;  1942 --      dec ecx
;  1943 --      jnz opCFuncEseqLoop
;  1944 --   opCFuncEseqZL:
;  1945 --      pop edi
;  1946 --   opCFuncStore:
;  1947 --      mov edx,[edi]
;  1948 --      mov [edi],eax
;  1949 --      cmp edx,h4
;  1950 --      jle @f
;  1951 --          dec dword[ebx+edx*4-8]
;  1952 --          jz deallocX
;  1953 --    @@:
;  1954 --      ret
;  1955 --
;  1956 
;  1957 global procedure c_proc(integer rid, sequence args={})
;  1958 integer return_type
;  1959 integer c_esp_lo = 0    --DEV esp is dword-aligned!
;  1960 integer c_esp_hi = 0
;  1961 integer local_ebp
;  1962 atom addr
;  1963 sequence cstrings -- Keeps refcounts>0, of any temps we had to make, over the call.
;  1964                   -- Freed automatically, after we get back from the call_eax, /not/
;  1965                   -- on exit from, or mid-way through, calling the c_common routine.
;  1966 
;  1967     #ilASM{
;  1968             [32]
;  1969                 mov eax,esp
;  1970                 mov ecx,esp
;  1971                 shr eax,16
;  1972                 and ecx,#0000FFFF
;  1973                 mov [c_esp_hi],eax
;  1974                 mov [c_esp_lo],ecx
;  1975             [64]
;  1976                 mov rax,rsp
;  1977                 mov rcx,rsp
;  1978                 shr rax,32
;  1979 --              and ecx,#0000FFFF
;  1980                 and rcx,#FFFFFFFF
;  1981                 mov [c_esp_hi],rax
;  1982                 mov [c_esp_lo],rcx
;  1983 --push rbp
;  1984             []
;  1985         }
;  1986     {return_type,addr,cstrings} = c_common(rid,args,PROC)
;  1987     -- (return_type has already been tested for 0 in c_common)
;  1988     #ilASM{
;  1989             [32]
;  1990                 call :%save_ebp         --DEV this is stupid!!
;  1991                 mov [local_ebp],eax
;  1992                 mov eax,[addr]
;  1993                 cmp eax,h4  --DEV :%pLoadMint
;  1994                 jl @f
;  1995                     -- addr>#3FFFFFFF get stored as float:
;  1996                     sub esp,8
;  1997                     fld qword[ebx+eax*4]
;  1998                     fistp qword[esp]
;  1999                     pop eax
;  2000                     add esp,4
;  2001             @@:
;  2002                 call eax
;  2003                 mov edx,[c_esp_hi]
;  2004                 mov ecx,[c_esp_lo]
;  2005                 shl edx,16
;  2006                 xor ebx,ebx     -- (Phix likes it zero!)
;  2007                 add ecx,edx
;  2008                 mov esp,ecx
;  2009                 mov edx,[local_ebp]
;  2010                 call :%restore_ebp
;  2011             [64]
;  2012                 call :%save_rbp
;  2013                 mov [local_ebp],rax
;  2014                 mov rax,[addr]
;  2015 --              cmp rax,h4
;  2016                 mov r15,h4
;  2017                 cmp rax,r15
;  2018                 jl @f
;  2019                     -- addr>#3FFFFFFFFFFFFFFF get stored as float:
;  2020                     sub rsp,8
;  2021                     fld tbyte[rbx+rax*4]
;  2022                     fistp qword[rsp]
;  2023                     pop rax
;  2024             @@:
;  2025 --push rbp
;  2026 --[PE64]
;  2027                 mov rcx,[rsp]
;  2028                 mov rdx,[rsp+8]
;  2029                 mov r8,[rsp+16]
;  2030                 mov r9,[rsp+24]
;  2031 --[ELF64]
;  2032                 call rax
;  2033 --pop rbp
;  2034 --DEV... we cannot restore rsp or rbp from a corrupt rbp!!! (that's not what it is!)
;  2035 --!/*
;  2036                 mov rdx,[c_esp_hi]
;  2037                 mov rcx,[c_esp_lo]
;  2038                 shl rdx,32
;  2039                 xor rbx,rbx     -- (Phix likes it zero!)
;  2040                 add rcx,rdx
;  2041                 mov rsp,rcx
;  2042                 mov rdx,[local_ebp]
;  2043                 call :%restore_rbp
;  2044 --!*/
;  2045 --pop al
;  2046             []
;  2047         }
;  2048 end procedure
;  2049 
;  2050 
;  2051 --Searching for: p_ref
;  2052 -- Files scanned 4751, Directories scanned 365, Lines 2444672
;  2053 --C:\Program Files\Phix\e0.exw:338 o=c_func(define_c_func({},call_back(routine_id("h0")),{},P_REF),{}) -- -77
;  2054 --C:\Program Files\Phix\psym.e:1304 --  initialConstant("P_REF",          #04000004)
;  2055 --C:\Program Files\Phix\psym.e:1310 --   P_REF, when Phix gets a -dll command line option that is..)
;  2056 --C:\Program Files\Phix\tmp.txt:62 C\Program Files\Phix\e0.exw338 o=c_func(define_c_func({},call_back(routine_id("h0")),{},P_REF),{}) -- -77
;  2057 --C:\Program Files\Phix\tmp.txt:77 C\Program Files\Phix\test\t42cback.exw55 o=c_func(define_c_func({},call_back(routine_id("h0")),{},P_REF),{}) -- -77
;  2058 --C:\Program Files\Phix\test\t42cback.exw:11 --  the new P_REF setting
;  2059 --C:\Program Files\Phix\test\t42cback.exw:59 --o=c_func(define_c_func({},call_back(routine_id("h0")),{},P_REF),{}) -- -77
;  2060 --C:\Program Files\Phix\builtins\dll.e:39 --     P_REF      = #04000004,    -- NB: Phix uses this instead of above four.
;  2061 --C:\Program Files\Phix\bench\dll.e:39 --   P_REF    = #04000004,    -- NB: Phix uses this instead of above four.
;  2062 --C:\Program Files\Phix\asm\p.asm:13358   mov [esp+20],eax    ; preserve (in edx) for P_REF handling
;  2063 --C:\Program Files\Phix\asm\p.asm:13961   ; P_REF handling
;  2064 --
;  2065 
;  2066 function call_common(integer rid, sequence params, integer isProc)
;  2067 -- common code for call_proc/call_func (validate and process args)
;  2068 -- isProc is 0 from call_func, 1 from call_proc.
;  2069 sequence symtab
;  2070 object si               -- copy of symtab[i], speedwise
;  2071 integer sNtyp,
;  2072         minparams,
;  2073         maxparams,
;  2074         noofparams,
;  2075         nooflocals,     -- (ie params+localvars)
;  2076         si_il
;  2077 
;  2078 --integer tidx
;  2079 object res
;  2080 
;  2081     -- get copy of symtab. NB read only! may contain nuts! (unassigned vars)
;  2082 --  si = 1  -- callstack not rqd
;  2083     #ilASM{
;  2084         [32]
;  2085             lea edi,[symtab]
;  2086             call :%opGetST                      -- [edi]:=symtab (see pStack.e)
;  2087         [64]
;  2088             lea rdi,[symtab]
;  2089             call :%opGetST                      -- [rdi]:=symtab (see pStack.e)
;  2090         []
;  2091           }
;  2092     if rid<T_const1
;  2093     or rid>length(symtab) then
;  2094 --      fatal(e72iri,rid)
;  2095         fatalN(3,e72iri,rid)
;  2096     end if
;  2097 
;  2098     si = symtab[rid]
;  2099 
;  2100     sNtyp = si[S_NTyp]
;  2101     if sNtyp<S_Type
;  2102     or sNtyp>S_Proc
;  2103     or (sNtyp=S_Proc)!=isProc then
;  2104 --      fatal(e72iri,rid)
;  2105         fatalN(3,e72iri,rid)
;  2106     end if
;  2107 
;  2108     minparams = si[S_ParmN]
;  2109     maxparams = length(si[S_sig])-1
;  2110     noofparams = length(params)
;  2111     if noofparams<minparams then fatalN(3,e81ipicfp) end if -- insufficient parameters in call_func/proc()
;  2112     if noofparams>maxparams then fatalN(3,e89tmpicfp) end if -- too many parameters in call_func/proc()
;  2113     nooflocals = si[S_Ltot]         -- (total no of params + local vars + temps)
;  2114     if string(params) then
;  2115         params &= -1    -- (force conversion to dword-sequence)
;  2116         --  Of course call_proc(N,"fred") is probably an error,
;  2117         --  where the programmer actually meant to use {"fred"},
;  2118         --  ((assuming enough optional params to get this far))
;  2119         --  but call_proc(N,repeat(65,5)) must work the same as
;  2120         --  call_proc(N,{65,65,65,65,65}) even though it is in
;  2121         --  fact effectively the same as call_proc(N,"AAAAA"),
;  2122         --  since repeat(ch,N) creates a string, as it should.
;  2123     end if
;  2124 --DEV 26/02/2012 (we want something similar on si, maybe object sicopy?)
;  2125 --put back, 21/9/14 (keep ex.err simpler):
;  2126 --  symtab = {} -- 1/10/14: spannered self-host on newEmit=0, so I made the same un-change here for now [DEV, re-test when newEmit=1 self host works!]
;  2127 -- added 21/9/14:
;  2128     si_il = si[S_il]
;  2129     si = 0
;  2130     #ilASM{ e_all                                   -- set "all side_effects"
;  2131         [32]
;  2132             mov ecx,[nooflocals]                    -- (si[S_Ltot])
;  2133             mov edx,[rid]
;  2134             -- 04/12/2011: load before the opFrame (as that modifies ebp) and push*3
;  2135 --          mov eax,[si]
;  2136             mov eax,[si_il]                         -- (si[S_il])
;  2137             mov edi,[noofparams]
;  2138             mov esi,[params]
;  2139             push eax                                -- [1] (popped into esi)
;  2140             push edi                                -- [2] (popped into ecx)
;  2141             push esi                                -- [3] 
;  2142             call :%opFrame
;  2143             pop esi                                 -- [3] (params)
;  2144             mov edi,ebp                             -- address of first parameter
;  2145             pop ecx                                 -- [2] (noofparams)
;  2146             shl esi,2                               -- params(raw)
;  2147             test ecx,ecx
;  2148             jz :zeroparams
;  2149 
;  2150          ::paramloop
;  2151                 lodsd                               -- mov eax,[esi]; esi+=4
;  2152                 mov [edi],eax
;  2153                 sub edi,4
;  2154                 cmp eax,h4
;  2155                 jl @f
;  2156                     add dword[ebx+eax*4-8],1        -- increment refcount.
;  2157               @@:
;  2158                 dec ecx
;  2159                 jnz :paramloop
;  2160 
;  2161          ::zeroparams
;  2162 
;  2163 --          pop esi                                 -- [1] ([si, ie symtab[rid]])
;  2164 --          pop esi                                 -- [1] ([si_il, ie symtab[rid][S_il]])
;  2165             mov dword[ebp+16],:retaddr
;  2166 --          jmp dword[ebx+esi*4+40]                 -- execute first opcode (S_il=11)
;  2167 --          jmp esi                                 -- execute first opcode
;  2168             ret                                     -- [1] (== jmp symtab[rid][S_il])
;  2169          ::retaddr
;  2170             cmp [isProc],0
;  2171             jz :isFunc
;  2172                 xor eax,eax
;  2173          ::isFunc
;  2174             mov [res],eax                           -- (assumes [res] is still h4 here)
;  2175         [64]
;  2176             mov rcx,[nooflocals]
;  2177             mov rdx,[rid]
;  2178             -- 04/12/2011: load before the opFrame (as that modifies ebp) and push*3
;  2179 --          mov rax,[si]
;  2180             mov rax,[si_il]
;  2181             mov rdi,[noofparams]
;  2182             mov rsi,[params]
;  2183             push rax                                -- [1] (popped into rsi)
;  2184             push rdi                                -- [2] (popped into rcx)
;  2185             push rsi                                -- [3] 
;  2186             call :%opFrame
;  2187             pop rsi                                 -- [3] (params)
;  2188             mov rdi,rbp                             -- address of first parameter
;  2189             pop rcx                                 -- [2] (noofparams)
;  2190             shl rsi,2                               -- params(raw)
;  2191             test rcx,rcx
;  2192             jz :zeroparams
;  2193             mov r15,h4
;  2194 
;  2195          ::paramloop
;  2196                 lodsq                               -- mov rax,[rsi]; rsi+=8
;  2197                 mov [rdi],rax
;  2198 --              sub rdi,4
;  2199                 sub rdi,8
;  2200 --              cmp rax,h4
;  2201                 cmp rax,r15
;  2202                 jl @f
;  2203                     add qword[rbx+rax*4-16],1       -- increment refcount.
;  2204               @@:
;  2205                 sub ecx,1
;  2206                 jnz :paramloop
;  2207 
;  2208          ::zeroparams
;  2209 
;  2210 --          pop esi                                 -- [1] ([si, ie symtab[rid]])
;  2211 --          pop esi                                 -- [1] ([si_il, ie symtab[rid][S_il]])
;  2212             mov qword[rbp+32],:retaddr
;  2213 --          jmp dword[ebx+esi*4+40]                 -- execute first opcode (S_il=11)
;  2214 --          jmp esi                                 -- execute first opcode
;  2215             ret                                     -- [1] (== jmp symtab[rid][S_il])
;  2216          ::retaddr
;  2217             cmp [isProc],0
;  2218             jz :isFunc
;  2219                 xor rax,rax
;  2220          ::isFunc
;  2221             mov [res],rax                           -- (assumes [res] is still h4 here)
;  2222         []
;  2223     }
;  2224     return res
;  2225 end function
;  2226 
;  2227 global function call_func(integer rid, sequence params)
;  2228     return call_common(rid,params,0)
;  2229 end function
;  2230 
;  2231 global procedure call_proc(integer rid, sequence params)
;  2232     if call_common(rid,params,1)!=0 then ?9/0 end if
;  2233 end procedure
;  2234 
;  2235 global procedure c_cleanup()
;  2236     if pinit then
    mov rsi,[#00403350] (pinit)           ;#0043B025: 48:213065 2483FCFF         uv 40 00  1   1      
    test rsi,rsi                          ;#0043B02C: 48:205366                  uv 00 40  1   2 40   
    je #0043B06B                          ;#0043B02F: 164 3A                     v  00 00  1   2      
;  2237         for i=1 to length(prevcb) do
    mov rdi,rbp                           ;#0043B031: 48:213375                  uv 80 20  1   3      
    mov rsi,[#00403348] (prevcb)          ;#0043B034: 48:213065 0D83FCFF         vu 40 00  1   3      
    mov rdx,1217                          ;#0043B03B: 48:307302 C1040000         uv 04 00  1   4      
    call #0043F28D (:%opLen)              ;#0043B042: 350 46420000               v  00 00  1   4      
    mov qword[rbp-8] (i),1                ;#0043B047: 48:307105 F8 01000000      uv 00 20  1   5      
;  2238             free(prevcb[i])
;  2239         end for
;  2240         Pinit() -- (may not be necessary)
    xor rcx,rcx                           ;#0043B04F: 48:061311                  vu 02 02  1   5      
    mov rdx,1219                          ;#0043B052: 48:307302 C3040000         uv 04 00  1   6      
    call #004428DB (:%opFrame) (Pinit)    ;#0043B059: 350 7D780000               v  00 00  1   6      
    mov qword[retaddr],#0043B06B          ;#0043B05E: 48:307105 20 6BB04300      uv 00 20  1   7      
    jmp #0043B0B6 (code:Pinit)            ;#0043B066: 351 4B000000               v  00 00  1   7      
;  2241     end if
;  2242     table = {}
    mov rax,qword[#004022C8]              ;#0043B06B: 48:213005 5672FCFF         uv 01 00  1   8      
    mov rdx,[#004032D0] (table)           ;#0043B072: 48:213025 5782FCFF         vu 04 00  1   8      
    mov r15,h4                            ;#0043B079: 49:277 0000000000000040    uv 8000 00  1   9      
    cmp rax,r15                           ;#0043B083: 4C:071370                  uv 00 8001  1  10 8000   
    jl #0043B08E                          ;#0043B086: 174 06                     v  00 00  1  10      
    add qword[rbx+rax*4-16],1             ;#0043B088: 48:203104203 F0 01         u  00 09  3  11      
    mov [#004032D0] (table),rax           ;#0043B08E: 48:211005 3B82FCFF         vu 00 01  1  13      
    mov r15,h4                            ;#0043B095: 49:277 0000000000000040    uv 8000 00  1  14      
    cmp rdx,r15                           ;#0043B09F: 4C:071372                  uv 00 8004  1  15 8000   
    jle #0043B0B1                         ;#0043B0A2: 176 0D                     v  00 00  1  15      
    sub qword[rbx+rdx*4-16],1             ;#0043B0A4: 48:203154223 F0 01         u  00 0C  3  16      
    jne #0043B0B1                         ;#0043B0AA: 165 05                     v  00 00  1  18      
    call #004422DA (:%pDealloc)           ;#0043B0AC: 350 29720000               v  00 00  1  19      
    jmp #0044298D (:%opRetf)              ;#0043B0B1: 351 D7780000               v  00 00  1  20      
;  2243 end procedure
;  2244 
;  2245 #ilASM{ jmp :fin
                jmp #0043B1B6             ;#0043B192: 353 22                     v  00 00  1   1      
;  2246         --
;  2247         -- These nops are here because we are storing ::Cleanup/4,
;  2248         -- so a "shr 2; call" may land up to 3 bytes early(!!)
;  2249         --  (and no, an align feature is not in the plan)
;  2250         --
;  2251         nop
                nop                       ;#0043B194: 220                        uv 00 00  1   2      
;  2252         nop
                nop                       ;#0043B195: 220                        vu 00 00  1   2      
;  2253         nop
                nop                       ;#0043B196: 220                        uv 00 00  1   3      
;  2254     ::CCleanup
;  2255       [32]
;  2256         mov edx,routine_id(c_cleanup)       -- mov edx,imm32 (sets K_ridt)
;  2257         mov ecx,$_Ltot                      -- mov ecx,imm32 (=symtab[c_cleanup][S_Ltot])
;  2258         call :%opFrame
;  2259         mov dword[ebp+16],:cleanupret       -- return address
;  2260         jmp $_il                            -- jmp code:c_cleanup
;  2261       [64]
;  2262         mov rdx,routine_id(c_cleanup)       -- mov edx,imm32 (sets K_ridt)
                mov edx,1262              ;#0043B197: 272 EE040000               vu 04 00  1   3      
;  2263         mov rcx,$_Ltot                      -- mov ecx,imm32 (=symtab[c_cleanup][S_Ltot])
                mov rcx,3                 ;#0043B19C: 48:307301 03000000         uv 02 00  1   4      
;  2264         call :%opFrame
                call :%opFrame (c_cleanup)  ;#0043B1A3: 350 33770000               v  00 00  1   4      
;  2265         mov qword[rbp+32],:cleanupret       -- return address
                mov qword[retaddr],#0043B1B5  ;#0043B1A8: 48:307105 20 B5B14300      uv 00 20  1   5      
;  2266         jmp $_il                            -- jmp code:c_cleanup
                jmp #0043B025 (code:c_cleanup)  ;#0043B1B0: 351 70FEFFFF               v  00 00  1   5      
;  2267       []
;  2268       ::cleanupret
;  2269         ret
                ret                       ;#0043B1B5: 303                        np 00 00  2   6      
;  2270         
;  2271     ::fin
;  2272 --14/8/15:
;  2273 --      mov esi,[ds+8]              -- esi:=raw addr of symtab[1]
;  2274         call :%pGetSymPtr
                call #004427EF (:%pGetSymPtr)  ;#0043B1B6: 350 34760000               v  00 00  1   8      
;  2275     [32]
;  2276         mov edx,[esi+84]            -- edx:=symtab[T_EBP=22]
;  2277         test edx,edx
;  2278         jz @f
;  2279             -- interpreted
;  2280             mov eax,:CCleanup
;  2281             shl eax,2
;  2282     [64]
;  2283         mov rdx,[rsi+21*8]          -- rdx:=symtab[T_EBP=22]
                mov rdx,[rsi+168]         ;#0043B1BB: 48:213226 A8000000         uv 04 40  1   9      
;  2284         test rdx,rdx
                test rdx,rdx              ;#0043B1C2: 48:205322                  uv 00 04  1  10 04   
;  2285         jz @f
                jz #0043B1D7              ;#0043B1C5: 164 10                     v  00 00  1  10      
;  2286             -- interpreted
;  2287             mov rax,:CCleanup
                    mov rax,#0043B197     ;#0043B1C7: 48:307300 97B14300         uv 01 00  1  11      
;  2288             shl rax,2
                    shl rax,2             ;#0043B1CE: 48:301340 02               u  01 01  1  12      
;  2289     []
;  2290             call :%SetCCleanup
                    call #00442A5C (:%SetCCleanup)  ;#0043B1D2: 350 85780000               v  00 00  1  12      
;  2291       @@:
;  2292       }
;  2293 
    jmp #0044298D (:%opRetf)              ;#0043B1D7: 351 B1770000               v  00 00  1  13      
;C:\Program Files (x86)\Phix\builtins\VM\pFind.e: - skipped (without debug)
;===========================================================================
;C:\Program Files (x86)\Phix\builtins\VM\pMatch.e:
;=================================================
;     1 --
;     2 -- pMatch.e
;     3 -- ========
;     4 --
;     5 --  (Temporary) hll implementation of match()
;     6 --  There is an equivalent commented-out backend/asm version in pJcc.e, conversion of which is yet to be completed.
;     7 --
;     8 
;     9 global function match(object s1, sequence s2, integer start=1)
    mov rsi,[rbp-16] (start)              ;#00449700: 48:213165 F0               uv 40 20  1   1      
    mov r15,h4                            ;#00449704: 49:277 0000000000000040    vu 8000 00  1   1      
    cmp rsi,r15                           ;#0044970E: 4C:071376                  uv 00 8040  1   2      
    jne #0044971B                         ;#00449711: 165 08                     v  00 00  1   2      
    mov qword[rbp-16] (start),1           ;#00449713: 48:307105 F0 01000000      uv 00 20  1   3      
;    10 --
;    11 -- Try to match s1 against some slice of s2.
;    12 -- If successful, return the element number of s2 where the (first) matching slice begins,
;    13 -- else return 0.  
;    14 
;    15 -- This is the closest way to express the back-end algorithm in hll.
;    16 -- Phix ensures that eg 6.5+6.5 is stored as a short int 13, not
;    17 -- a floating point 13.0. Finding a short int is faster than anything
;    18 -- else, because there is no dereference, hence when we hit a mismatch
;    19 -- and one of the disagreeing values is a shortint, use that to look
;    20 -- for a better place to restart the top-level scan.
;    21 -- In the asm backend, we actually apply the integer() checks before
;    22 -- the deep-equal(), and use quick_equal() in the inner loops.
;    23 -- The asm backend also uses slightly different code for the four
;    24 -- cases match(string,string), match(string,sequence), match(seq,str)
;    25 -- and match(seq,seq) for the obvious reasons of bit size, and not
;    26 -- bothering to check for string[i] as integer, and that the first
;    27 -- three cases do not ever need to invoke deep_equal().
;    28 --
;    29 -- Changes to the functionality of match() noted below arose from a 
;    30 -- protracted discussion on EuForum in 2002.
;    31 --
;    32 integer res, s2idx, ls1, ls2
;    33 object s1i, s2i
;    34     -- This line, and first parameter being object not sequence, is not RDS compliant.
;    35     --  (RDS gives error "first argument of match() must be a sequence")
;    36     if atom(s1) then return find(s1,s2,start) end if
;    37     res = start
    mov qword[rbp-24] (res),1             ;#0044971B: 48:307105 E8 01000000      vu 00 20  1   3      
;    38     ls1 = length(s1)
    lea rdi,[rbp-40] (ls1)                ;#00449723: 48:215175 D8               uv 80 20  1   4      
    mov rsi,[rbp] (s1)                    ;#00449727: 48:213165 00               vu 40 20  1   4      
    mov rdx,1273                          ;#0044972B: 48:307302 F9040000         uv 04 00  1   5      
    call #0043F28D (:%opLen)              ;#00449732: 350 565BFFFF               v  00 00  1   5      
;    39     -- This line is also not RDS compliant
;    40     --  (RDS gives error "first argument of match() must be a non-empty sequence")
;    41     if ls1=0 then return 0 end if
    cmp rcx,0                             ;#00449737: 48:203371 00               uv 00 02  1   6      
    jne #00449745                         ;#0044973B: 165 08                     v  00 00  1   6      
    xor rax,rax                           ;#0044973D: 48:061300                  uv 01 01  1   7      
    jmp #0044298D (:%opRetf)              ;#00449740: 351 4892FFFF               v  00 00  1   7      
;    42     ls2 = length(s2)
    mov rdi,[rbp-8] (s2)                  ;#00449745: 48:213175 F8               uv 80 20  1   8      
    mov rax,[rbx+rdi*4-24]                ;#00449749: 48:48:213104273 E8         uv 01 88  1  11 80 *80*
    mov [rbp-48] (ls2),rax                ;#0044974F: 48:211105 D0               uv 00 21  1  12 01   
;    43 --  if ls1 > ls2 then return 0 end if -- see below
;    44     while 1 do
;    45         if res+ls1-1>ls2 then return 0 end if
    lea rdi,[rbp-72] (symtab[1282])       ;#00449753: 48:215175 B8               vu 80 20  1  12      
    mov rcx,[rbp-24] (res)                ;#00449757: 48:213115 E8               uv 02 20  1  13      
    mov rax,[rbp-40] (ls1)                ;#0044975B: 48:213105 D8               vu 01 20  1  13      
    call #0043F4AF (:%opAdd)              ;#0044975F: 350 4B5DFFFF               v  00 00  1  14      
    lea rdi,[rbp-80] (symtab[1283])       ;#00449764: 48:215175 B0               uv 80 20  1  15      
    mov rcx,[rbp-72] (symtab[1282])       ;#00449768: 48:213115 B8               vu 02 20  1  15      
    mov rax,qword[#00402030]              ;#0044976C: 48:213005 BD88FBFF         uv 01 00  1  16      
    call #0043F4D8 (:%opSub)              ;#00449773: 350 605DFFFF               v  00 00  1  16      
    mov rdi,[rbp-48] (ls2)                ;#00449778: 48:213175 D0               uv 80 20  1  17      
    mov rax,[rbp-80] (symtab[1283])       ;#0044977C: 48:213105 B0               vu 01 20  1  17      
    mov rsi,1279                          ;#00449780: 48:307306 FF040000         uv 40 00  1  18      
    mov rdx,1283                          ;#00449787: 48:307302 03050000         vu 04 00  1  18      
    call #0043FA81 (:%opJcc)              ;#0044978E: 350 EE62FFFF               v  00 00  1  19      
    jle #0044979D                         ;#00449793: 176 08                     v  00 00  1  20      
    xor rax,rax                           ;#00449795: 48:061300                  uv 01 01  1  21      
    jmp #0044298D (:%opRetf)              ;#00449798: 351 F091FFFF               v  00 00  1  21      
;    46         for i=1 to ls1 do
    mov rsi,[rbp-40] (ls1)                ;#0044979D: 48:213165 D8               uv 40 20  1  22      
    mov [rbp-88] (symtab[1284]),rsi       ;#004497A1: 48:211165 A8               uv 00 60  1  23 40   
    mov qword[rbp-96] (i),1               ;#004497A5: 48:307105 A0 01000000      vu 00 20  1  23      
    cmp rsi,1                             ;#004497AD: 48:201376 01000000         uv 00 40  1  24      
    jl #00449753                          ;#004497B4: 174 9D                     v  00 00  1  24      
;    47             s1i = s1[i]
    mov rdi,[rbp-96] (i)                  ;#004497B6: 48:213175 A0               uv 80 20  1  25      
    mov rsi,[rbp] (s1)                    ;#004497BA: 48:213165 00               vu 40 20  1  25      
    mov rdx,1273                          ;#004497BE: 48:307302 F9040000         uv 04 00  1  26      
    call #00441762 (:%pSubse1is)          ;#004497C5: 350 987FFFFF               v  00 00  1  26      
    mov [rbp-56] (s1i),rax                ;#004497CA: 48:211105 C8               uv 00 21  1  27      
;    48             s2idx = i+res-1
    lea rdi,[rbp-80] (symtab[1283])       ;#004497CE: 48:215175 B0               vu 80 20  1  27      
    mov rcx,[rbp-96] (i)                  ;#004497D2: 48:213115 A0               uv 02 20  1  28      
    mov rax,[rbp-24] (res)                ;#004497D6: 48:213105 E8               vu 01 20  1  28      
    call #0043F4AF (:%opAdd)              ;#004497DA: 350 D05CFFFF               v  00 00  1  29      
    lea rdi,[rbp-32] (s2idx)              ;#004497DF: 48:215175 E0               uv 80 20  1  30      
    mov rcx,[rbp-80] (symtab[1283])       ;#004497E3: 48:213115 B0               vu 02 20  1  30      
    mov rax,qword[#00402030]              ;#004497E7: 48:213005 4288FBFF         uv 01 00  1  31      
    call #0043F4EB (:%opSubi)             ;#004497EE: 350 F85CFFFF               v  00 00  1  31      
;    49 --          if s2idx>ls2 then return 0 end if -- see above
;    50             s2i = s2[s2idx]
    mov rdi,[rbp-32] (s2idx)              ;#004497F3: 48:213175 E0               uv 80 20  1  32      
    lea rcx,[rbp-64] (s2i)                ;#004497F7: 48:215115 C0               vu 02 20  1  32      
    mov rsi,[rbp-8] (s2)                  ;#004497FB: 48:213165 F8               uv 40 20  1  33      
    mov rdx,1274                          ;#004497FF: 48:307302 FA040000         vu 04 00  1  33      
    call #00441675 (:%pSubse1)            ;#00449806: 350 6A7EFFFF               v  00 00  1  34      
;    51 --          if not quick_equal(sli,s2i) then    -- asm variant
;    52             if not equal(s1i,s2i) then
    mov rcx,[rbp-56] (s1i)                ;#0044980B: 48:213115 C8               uv 02 20  1  35      
    mov rax,[rbp-64] (s2i)                ;#0044980F: 48:213105 C0               vu 01 20  1  35      
    cmp rcx,rax                           ;#00449813: 48:071301                  uv 00 03  1  36      
    je #00449911                          ;#00449816: 017204 F5000000            v  00 00  1  36      
;    53 --              if integer(sli) and not integer(s2i) then -- maybe?
;    54 --              if integer(sli) and not equal(s1i,s2i) then -- maybe?
;    55                 if integer(s1i) then
;    56                     -- scan for sli later on in s2
;    57                     -- eg s1=13131...,
;    58                     --    s2=1313x31...
;    59                     -- with s1[5]=1, scanning fwd two places to s2[7]=1
;    60                     -- gives the earliest point worth re-starting from.
;    61                     -- if s1i does not occur anywhere later in s2, then
;    62                     -- clearly there will be no match anywhere.
;    63                     for j=s2idx+1 to ls2+1 do
    lea rdi,[rbp-80] (symtab[1283])       ;#0044981C: 48:215175 B0               uv 80 20  1  37      
    mov rcx,[rbp-32] (s2idx)              ;#00449820: 48:213115 E0               vu 02 20  1  37      
    mov rax,qword[#00402030]              ;#00449824: 48:213005 0588FBFF         uv 01 00  1  38      
    call #0043F4AF (:%opAdd)              ;#0044982B: 350 7F5CFFFF               v  00 00  1  38      
    lea rdi,[rbp-72] (symtab[1282])       ;#00449830: 48:215175 B8               uv 80 20  1  39      
    mov rcx,[rbp-48] (ls2)                ;#00449834: 48:213115 D0               vu 02 20  1  39      
    mov rax,qword[#00402030]              ;#00449838: 48:213005 F187FBFF         uv 01 00  1  40      
    call #0043F4AF (:%opAdd)              ;#0044983F: 350 6B5CFFFF               v  00 00  1  40      
    mov rdx,[rbp-104] (j)                 ;#00449844: 48:213125 98               uv 04 20  1  41      
    mov r15,h4                            ;#00449848: 49:277 0000000000000040    vu 8000 00  1  41      
    cmp rdx,r15                           ;#00449852: 4C:071372                  uv 00 8004  1  42      
    jle #00449864                         ;#00449855: 176 0D                     v  00 00  1  42      
    sub qword[rbx+rdx*4-16],1             ;#00449857: 48:203154223 F0 01         u  00 0C  3  43      
    jne #00449864                         ;#0044985D: 165 05                     v  00 00  1  45      
    call #004422DA (:%pDealloc)           ;#0044985F: 350 768AFFFF               v  00 00  1  46      
    mov rdi,[rbp-80] (symtab[1283])       ;#00449864: 48:213175 B0               uv 80 20  1  47      
    mov r15,h4                            ;#00449868: 49:277 0000000000000040    vu 8000 00  1  47      
    cmp rdi,r15                           ;#00449872: 4C:071377                  uv 00 8080  1  48      
    jl #0044988C                          ;#00449875: 174 15                     v  00 00  1  48      
    mov al,120                            ;#00449877: 260 78                     uv 01 00  1  49      
    mov rdi,1283                          ;#00449879: 48:307307 03050000         vu 80 00  1  49      
    mov rsi,1                             ;#00449880: 48:307306 01000000         uv 40 00  1  50      
    call #00442DC8 (:%pRTErn)             ;#00449887: 350 3C95FFFF               v  00 00  1  50      
    mov [rbp-104] (j),rdi                 ;#0044988C: 48:211175 98               uv 00 A0  1  51      
    mov rsi,[rbp-72] (symtab[1282])       ;#00449890: 48:213165 B8               vu 40 20  1  51      
    cmp rdi,rsi                           ;#00449894: 48:073376                  uv 00 C0  1  52      
    jg #00449753                          ;#00449897: 017217 B6FEFFFF            v  00 00  1  52      
;    64                         res += 1
    mov rcx,[rbp-24] (res)                ;#0044989D: 48:213115 E8               uv 02 20  1  53      
    add rcx,1                             ;#004498A1: 48:203301 01               uv 02 02  1  54 02   
    mov rdx,rcx                           ;#004498A5: 48:213321                  uv 04 02  1  55 02   
    mov [rbp-24] (res),rcx                ;#004498A8: 48:211115 E8               vu 00 22  1  55      
    shl rdx,1                             ;#004498AC: 48:321342                  u  04 04  1  56      
    jno #004498BA                         ;#004498AF: 161 09                     v  00 00  1  56      
    lea rdi,[rbp-24] (res)                ;#004498B1: 48:215175 E8               uv 80 20  1  57      
    call #00442DA9 (:%pAddiii)            ;#004498B5: 350 EF94FFFF               v  00 00  1  57      
;    65 --                      s2idx = i+res-1
;    66 --                      s2idx += 1
;    67 --                      if s2idx>ls2 then return 0 end if
;    68                         if j>ls2 then return 0 end if
    mov rax,[rbp-104] (j)                 ;#004498BA: 48:213105 98               uv 01 20  1  58      
    mov rdi,[rbp-48] (ls2)                ;#004498BE: 48:213175 D0               vu 80 20  1  58      
    cmp rax,rdi                           ;#004498C2: 48:071370                  uv 00 81  1  59      
    jle #004498CF                         ;#004498C5: 176 08                     v  00 00  1  59      
    xor rax,rax                           ;#004498C7: 48:061300                  uv 01 01  1  60      
    jmp #0044298D (:%opRetf)              ;#004498CA: 351 BE90FFFF               v  00 00  1  60      
;    69                         if equal(s1i,s2[j]) then exit end if
    mov rdi,rax                           ;#004498CF: 48:211307                  uv 80 01  1  61      
    lea rcx,[rbp-112] (symtab[1287])      ;#004498D2: 48:215115 90               vu 02 20  1  61      
    mov rsi,[rbp-8] (s2)                  ;#004498D6: 48:213165 F8               uv 40 20  1  62      
    mov rdx,1274                          ;#004498DA: 48:307302 FA040000         vu 04 00  1  62      
    call #00441675 (:%pSubse1)            ;#004498E1: 350 8F7DFFFF               v  00 00  1  63      
    mov rcx,[rbp-56] (s1i)                ;#004498E6: 48:213115 C8               uv 02 20  1  64      
    mov rdi,[rbp-112] (symtab[1287])      ;#004498EA: 48:213175 90               vu 80 20  1  64      
    cmp rcx,rdi                           ;#004498EE: 48:071371                  uv 00 82  1  65      
    je #00449753                          ;#004498F1: 017204 5CFEFFFF            v  00 00  1  65      
;    70                     end for
    mov rax,[rbp-104] (j)                 ;#004498F7: 48:213105 98               uv 01 20  1  66      
    mov rsi,[rbp-72] (symtab[1282])       ;#004498FB: 48:213165 B8               vu 40 20  1  66      
    add rax,1                             ;#004498FF: 48:203300 01               uv 01 01  1  67      
    cmp rax,rsi                           ;#00449903: 48:073306                  uv 00 41  1  68 01   
    mov [rbp-104] (j),rax                 ;#00449906: 48:211105 98               vu 00 21  1  68      
    jle #0044989D                         ;#0044990A: 176 91                     v  00 00  1  69      
;    71                     exit
    jmp #00449753                         ;#0044990C: 351 42FEFFFF               v  00 00  1  70      
;    72                 elsif integer(s2i) then
;    73                     -- scan for s2i earlier on in s1
;    74                     -- eg s1=131313x...,
;    75                     --    s2=1313131...
;    76                     -- with s2[7]=1, scanning back two places to s1[5]=1
;    77                     -- gives the earliest point worth re-starting from.
;    78                     -- if s2[7] does not occur anywhere earlier in s1,
;    79                     -- then clearly we should restart from s2[8].
;    80                     for j=i-1 to 0 by -1 do
;    81                         res += 1
;    82                         if j=0 then exit end if
;    83                         if equal(s2i,s1[j]) then exit end if
;    84                     end for
;    85                     exit
;    86 --              elsif not equal(s1i,s2i) then   -- deep_equal() here in asm
;    87                 else
;    88                     res += 1
;    89                     exit
;    90                 end if
;    91             end if
;    92             if i=ls1 then return res end if
    mov rcx,[rbp-96] (i)                  ;#00449911: 48:213115 A0               uv 02 20  1  71      
    mov rdi,[rbp-40] (ls1)                ;#00449915: 48:213175 D8               vu 80 20  1  71      
    cmp rcx,rdi                           ;#00449919: 48:071371                  uv 00 82  1  72      
    jne #00449927                         ;#0044991C: 165 09                     v  00 00  1  72      
    mov rax,[rbp-24] (res)                ;#0044991E: 48:213105 E8               uv 01 20  1  73      
    jmp #0044298D (:%opRetf)              ;#00449922: 351 6690FFFF               v  00 00  1  73      
;    93         end for
    mov rsi,[rbp-88] (symtab[1284])       ;#00449927: 48:213165 A8               uv 40 20  1  74      
    add rcx,1                             ;#0044992B: 48:203301 01               vu 02 02  1  74      
    cmp rcx,rsi                           ;#0044992F: 48:073316                  uv 00 42  1  75      
    mov [rbp-96] (i),rcx                  ;#00449932: 48:211115 A0               vu 00 22  1  75      
    jle #004497B6                         ;#00449936: 017216 7AFEFFFF            v  00 00  1  76      
;    94     end while
    jmp #00449753                         ;#0044993C: 351 12FEFFFF               v  00 00  1  77      
    call #00442D91 (:%pBadRetf)           ;#00449941: 350 4B94FFFF               v  00 00  1  78      
;    95 end function
;    96 
;C:\Program Files (x86)\Phix\builtins\sort.e:
;============================================
;     1 -- Euphoria 2.4
;     2 -- Sorting
;     3 
;     4 -- Sort the elements of a sequence into ascending order, using "Shell" sort.
;     5 
;     6 --DEV wrong one for newEmit
;     7 --!/**/include builtins\pcfunc.e
;     8 
;     9 global function sort(sequence x)
;    10 -- Sort a sequence into ascending order. The elements can be atoms or 
;    11 -- sequences. The standard compare() routine is used to compare elements.
;    12 integer gap, j, first, last
;    13 object tempi, tempj
;    14 
;    15     last = length(x)
    mov rdi,[rbp] (x)                     ;#0044AEAD: 48:213175 00               uv 80 20  1   1      
    mov rax,[rbx+rdi*4-24]                ;#0044AEB1: 48:48:213104273 E8         uv 01 88  1   4 80 *80*
    mov [rbp-32] (last),rax               ;#0044AEB7: 48:211105 E0               uv 00 21  1   5 01   
;    16     gap = floor(last/10)+1
    lea rdi,[rbp-56] (symtab[1298])       ;#0044AEBB: 48:215175 C8               vu 80 20  1   5      
    mov rcx,rax                           ;#0044AEBF: 48:211301                  uv 02 01  1   6      
    mov rax,[#004020E8] (BRIGHT_GREEN)    ;#0044AEC2: 48:213005 1F72FBFF         vu 01 00  1   6      
    call #0043F5E4 (:%opDivf)             ;#0044AEC9: 350 1647FFFF               v  00 00  1   7      
    mov rcx,[rbp-56] (symtab[1298])       ;#0044AECE: 48:213115 C8               uv 02 20  1   8      
    add rcx,1                             ;#0044AED2: 48:203301 01               uv 02 02  1   9 02   
    mov rdx,rcx                           ;#0044AED6: 48:213321                  uv 04 02  1  10 02   
    mov [rbp-8] (gap),rcx                 ;#0044AED9: 48:211115 F8               vu 00 22  1  10      
    shl rdx,1                             ;#0044AEDD: 48:321342                  u  04 04  1  11      
    jno #0044AEEB                         ;#0044AEE0: 161 09                     v  00 00  1  11      
    lea rdi,[rbp-8] (gap)                 ;#0044AEE2: 48:215175 F8               uv 80 20  1  12      
    call #00442DA9 (:%pAddiii)            ;#0044AEE6: 350 BE7EFFFF               v  00 00  1  12      
;    17     while 1 do
;    18         first = gap+1
    mov rsi,[rbp-8] (gap)                 ;#0044AEEB: 48:213165 F8               uv 40 20  1  13      
    add rsi,1                             ;#0044AEEF: 48:203306 01               uv 40 40  1  14 40   
    mov rdx,rsi                           ;#0044AEF3: 48:213326                  uv 04 40  1  15 40   
    mov [rbp-24] (first),rsi              ;#0044AEF6: 48:211165 E8               vu 00 60  1  15      
    shl rdx,1                             ;#0044AEFA: 48:321342                  u  04 04  1  16      
    jno #0044AF08                         ;#0044AEFD: 161 09                     v  00 00  1  16      
    lea rdi,[rbp-24] (first)              ;#0044AEFF: 48:215175 E8               uv 80 20  1  17      
    call #00442DA9 (:%pAddiii)            ;#0044AF03: 350 A17EFFFF               v  00 00  1  17      
;    19         for i=first to last do
    mov [rbp-64] (symtab[1299]),rsi       ;#0044AF08: 48:211165 C0               uv 00 60  1  18      
    mov rdi,[rbp-32] (last)               ;#0044AF0C: 48:213175 E0               vu 80 20  1  18      
    mov [rbp-72] (symtab[1300]),rdi       ;#0044AF10: 48:211175 B8               uv 00 A0  1  19      
    mov [rbp-80] (i),rsi                  ;#0044AF14: 48:211165 B0               vu 00 60  1  19      
    cmp rsi,rdi                           ;#0044AF18: 48:073367                  uv 00 C0  1  20      
    jg #0044B03F                          ;#0044AF1B: 017217 1E010000            v  00 00  1  20      
;    20             tempi = x[i]
    mov rdi,[rbp-80] (i)                  ;#0044AF21: 48:213175 B0               uv 80 20  1  21      
    lea rcx,[rbp-40] (tempi)              ;#0044AF25: 48:215115 D8               vu 02 20  1  21      
    mov rsi,[rbp] (x)                     ;#0044AF29: 48:213165 00               uv 40 20  1  22      
    mov rdx,1291                          ;#0044AF2D: 48:307302 0B050000         vu 04 00  1  22      
    call #00441675 (:%pSubse1)            ;#0044AF34: 350 3C67FFFF               v  00 00  1  23      
;    21             j = i-gap
    mov rax,[rbp-80] (i)                  ;#0044AF39: 48:213105 B0               uv 01 20  1  24      
    mov rcx,[rbp-8] (gap)                 ;#0044AF3D: 48:213115 F8               vu 02 20  1  24      
    sub rax,rcx                           ;#0044AF41: 48:051310                  uv 01 03  1  25      
    mov rdx,rax                           ;#0044AF44: 48:213320                  uv 04 01  1  26 01   
    mov [rbp-16] (j),rax                  ;#0044AF47: 48:211105 F0               vu 00 21  1  26      
    shl rdx,1                             ;#0044AF4B: 48:321342                  u  04 04  1  27      
    jno #0044AF59                         ;#0044AF4E: 161 09                     v  00 00  1  27      
    lea rdi,[rbp-16] (j)                  ;#0044AF50: 48:215175 F0               uv 80 20  1  28      
    call #00442DA9 (:%pAddiii)            ;#0044AF54: 350 507EFFFF               v  00 00  1  28      
;    22             while 1 do
;    23                 tempj = x[j]
    mov rdi,[rbp-16] (j)                  ;#0044AF59: 48:213175 F0               uv 80 20  1  29      
    lea rcx,[rbp-48] (tempj)              ;#0044AF5D: 48:215115 D0               vu 02 20  1  29      
    mov rsi,[rbp] (x)                     ;#0044AF61: 48:213165 00               uv 40 20  1  30      
    mov rdx,1291                          ;#0044AF65: 48:307302 0B050000         vu 04 00  1  30      
    call #00441675 (:%pSubse1)            ;#0044AF6C: 350 0467FFFF               v  00 00  1  31      
;    24 --              if tempi >= tempj then
;    25                 if compare(tempi, tempj)>=0 then
    mov rdi,[rbp-48] (tempj)              ;#0044AF71: 48:213175 D0               uv 80 20  1  32      
    mov rax,[rbp-40] (tempi)              ;#0044AF75: 48:213105 D8               vu 01 20  1  32      
    mov rsi,1297                          ;#0044AF79: 48:307306 11050000         uv 40 00  1  33      
    mov rdx,1296                          ;#0044AF80: 48:307302 10050000         vu 04 00  1  33      
    call #0043FA81 (:%opJcc)              ;#0044AF87: 350 F54AFFFF               v  00 00  1  34      
    jl #0044AFB0                          ;#0044AF8C: 174 22                     v  00 00  1  35      
;    26                     j += gap
    mov rcx,[rbp-16] (j)                  ;#0044AF8E: 48:213115 F0               uv 02 20  1  36      
    mov rsi,[rbp-8] (gap)                 ;#0044AF92: 48:213165 F8               vu 40 20  1  36      
    add rcx,rsi                           ;#0044AF96: 48:001361                  uv 02 42  1  37      
    mov rdx,rcx                           ;#0044AF99: 48:213321                  uv 04 02  1  38 02   
    mov [rbp-16] (j),rcx                  ;#0044AF9C: 48:211115 F0               vu 00 22  1  38      
    shl rdx,1                             ;#0044AFA0: 48:321342                  u  04 04  1  39      
    jno #0044B012                         ;#0044AFA3: 161 6D                     v  00 00  1  39      
    lea rdi,[rbp-16] (j)                  ;#0044AFA5: 48:215175 F0               uv 80 20  1  40      
    call #00442DA9 (:%pAddiii)            ;#0044AFA9: 350 FB7DFFFF               v  00 00  1  40      
;    27                     exit
    jmp #0044B012                         ;#0044AFAE: 353 62                     v  00 00  1  41      
;    28                 end if
;    29                 x[j+gap] = tempj
    mov rdi,[rbp-16] (j)                  ;#0044AFB0: 48:213175 F0               uv 80 20  1  42      
    mov rax,[rbp-8] (gap)                 ;#0044AFB4: 48:213105 F8               vu 01 20  1  42      
    add rdi,rax                           ;#0044AFB8: 48:001307                  uv 80 81  1  43      
    mov rdx,rdi                           ;#0044AFBB: 48:213327                  uv 04 80  1  44 80   
    mov [rbp-56] (symtab[1298]),rdi       ;#0044AFBE: 48:211175 C8               vu 00 A0  1  44      
    shl rdx,1                             ;#0044AFC2: 48:321342                  u  04 04  1  45      
    jno #0044AFD0                         ;#0044AFC5: 161 09                     v  00 00  1  45      
    lea rdi,[rbp-56] (symtab[1298])       ;#0044AFC7: 48:215175 C8               uv 80 20  1  46      
    call #00442DA9 (:%pAddiii)            ;#0044AFCB: 350 D97DFFFF               v  00 00  1  46      
    mov rdi,[rbp-56] (symtab[1298])       ;#0044AFD0: 48:213175 C8               uv 80 20  1  47      
    mov rcx,[rbp-48] (tempj)              ;#0044AFD4: 48:213115 D0               vu 02 20  1  47      
    mov rsi,[rbp] (x)                     ;#0044AFD8: 48:213165 00               uv 40 20  1  48      
    mov rax,rbp                           ;#0044AFDC: 48:213305                  vu 01 20  1  48      
    call #00440C54 (:%pRepe1)             ;#0044AFDF: 350 705CFFFF               v  00 00  1  49      
;    30                 if j<=gap then
    mov rax,[rbp-16] (j)                  ;#0044AFE4: 48:213105 F0               uv 01 20  1  50      
    mov rdi,[rbp-8] (gap)                 ;#0044AFE8: 48:213175 F8               vu 80 20  1  50      
    cmp rax,rdi                           ;#0044AFEC: 48:071370                  uv 00 81  1  51      
    jle #0044B012                         ;#0044AFEF: 176 21                     v  00 00  1  51      
;    31                     exit
;    32                 end if
;    33                 j -= gap
    sub rax,rdi                           ;#0044AFF1: 48:051370                  uv 01 81  1  52      
    mov rdx,rax                           ;#0044AFF4: 48:213320                  uv 04 01  1  53 01   
    mov [rbp-16] (j),rax                  ;#0044AFF7: 48:211105 F0               vu 00 21  1  53      
    shl rdx,1                             ;#0044AFFB: 48:321342                  u  04 04  1  54      
    jno #0044AF59                         ;#0044AFFE: 017201 55FFFFFF            v  00 00  1  54      
    lea rdi,[rbp-16] (j)                  ;#0044B004: 48:215175 F0               uv 80 20  1  55      
    call #00442DA9 (:%pAddiii)            ;#0044B008: 350 9C7DFFFF               v  00 00  1  55      
;    34             end while
    jmp #0044AF59                         ;#0044B00D: 351 47FFFFFF               v  00 00  1  56      
;    35             x[j] = tempi
    mov rdi,[rbp-16] (j)                  ;#0044B012: 48:213175 F0               uv 80 20  1  57      
    mov rcx,[rbp-40] (tempi)              ;#0044B016: 48:213115 D8               vu 02 20  1  57      
    mov rsi,[rbp] (x)                     ;#0044B01A: 48:213165 00               uv 40 20  1  58      
    mov rax,rbp                           ;#0044B01E: 48:213305                  vu 01 20  1  58      
    call #00440C54 (:%pRepe1)             ;#0044B021: 350 2E5CFFFF               v  00 00  1  59      
;    36         end for
    mov rax,[rbp-80] (i)                  ;#0044B026: 48:213105 B0               uv 01 20  1  60      
    mov rdi,[rbp-72] (symtab[1300])       ;#0044B02A: 48:213175 B8               vu 80 20  1  60      
    add rax,1                             ;#0044B02E: 48:203300 01               uv 01 01  1  61      
    cmp rax,rdi                           ;#0044B032: 48:073307                  uv 00 81  1  62 01   
    mov [rbp-80] (i),rax                  ;#0044B035: 48:211105 B0               vu 00 21  1  62      
    jle #0044AF21                         ;#0044B039: 017216 E2FEFFFF            v  00 00  1  63      
;    37         if gap=1 then
    mov rcx,[rbp-8] (gap)                 ;#0044B03F: 48:213115 F8               uv 02 20  1  64      
    cmp rcx,1                             ;#0044B043: 48:203371 01               uv 00 02  1  65 02   
    jne #0044B05B                         ;#0044B047: 165 12                     v  00 00  1  65      
;    38             return x
    mov rax,[rbp] (x)                     ;#0044B049: 48:213105 00               uv 01 20  1  66      
    mov [rbp] (x),rbx                     ;#0044B04D: 48:211135 00               vu 00 28  1  66      
    jmp #0044298D (:%opRetf)              ;#0044B051: 351 3779FFFF               v  00 00  1  67      
    jmp #0044AEEB                         ;#0044B056: 351 90FEFFFF               v  00 00  1  68      
;    39         else
;    40             gap = floor(gap/3.5)+1
    lea rdi,[rbp-88] (symtab[1303])       ;#0044B05B: 48:215175 A8               uv 80 20  1  69      
    mov rax,qword[#00403390]              ;#0044B05F: 48:213005 2A83FBFF         vu 01 00  1  69      
    call #0043F5E4 (:%opDivf)             ;#0044B066: 350 7945FFFF               v  00 00  1  70      
    lea rdi,[rbp-8] (gap)                 ;#0044B06B: 48:215175 F8               uv 80 20  1  71      
    mov rcx,[rbp-88] (symtab[1303])       ;#0044B06F: 48:213115 A8               vu 02 20  1  71      
    mov rax,qword[#00402030]              ;#0044B073: 48:213005 B66FFBFF         uv 01 00  1  72      
    call #0043F4BE (:%opAddi)             ;#0044B07A: 350 3F44FFFF               v  00 00  1  72      
;    41         end if
;    42     end while
    jmp #0044AEEB                         ;#0044B07F: 351 67FEFFFF               v  00 00  1  73      
    call #00442D91 (:%pBadRetf)           ;#0044B084: 350 087DFFFF               v  00 00  1  74      
;    43 end function
;    44 
;    45 global function custom_sort(integer custom_compare, sequence x)
;    46 -- Sort a sequence. A user-supplied comparison function is used 
;    47 -- to compare elements. Note that this sort is not "stable", i.e.
;    48 -- elements that are considered equal might change position relative
;    49 -- to each other.
;    50 integer gap, j, first, last
;    51 object tempi, tempj
;    52 
;    53     last = length(x)
;    54     gap = floor(last/10)+1
;    55     while 1 do
;    56         first = gap+1
;    57         for i=first to last do
;    58             tempi = x[i]
;    59             j = i-gap
;    60             while 1 do
;    61                 tempj = x[j]
;    62                 if call_func(custom_compare, {tempi, tempj})>=0 then
;    63                     j += gap
;    64                     exit
;    65                 end if
;    66                 x[j+gap] = tempj
;    67                 if j<=gap then
;    68                     exit
;    69                 end if
;    70                 j -= gap
;    71             end while
;    72             x[j] = tempi
;    73         end for
;    74         if gap=1 then
;    75             return x
;    76         else
;    77             gap = floor(gap/3.5)+1
;    78         end if
;    79     end while
;    80 end function
;    81 


; Symtab Dump.
; ============

;global constant S_Name  = 1,  -- const/var/rtn name
;                S_NTyp  = 2,  -- Const/GVar/TVar/Nspc/Type/Func/Proc
;                S_FPno  = 3,  -- File and Path number
;                S_State = 4,  -- state flag. S_fwd/S_used/S_set
;                S_Nlink = 5,  -- name chain
;                S_Slink = 6,  -- scope/secondary chain
;                -- constants and variables [S_NTyp<=S_TVar]
;                S_vtype = 7,  -- variable type or namespace fileno
;                 (plus gInfo,varno/addr/thread idx/value)
;                -- routines [S_NTyp>=S_Type]
;                S_sig   = 7,  -- routine signature
;                S_Parm1 = 8,  -- first parameter. (idx to symtab, follow S_Slink)
;                S_ParmN = 9,  -- minimum no of parameters (max is length(S_sig)-1)
;                S_Ltot  = 10, -- total no of parameters, locals, and temporary vars
;                S_il    = 11, -- intermediate code
;
symtab[1]:{integer,S_Type,0,(S_used+K_used+K_gbl),0,0,{84'T',1},0,1,0,#0043A03A}
symtab[2]:{T_N,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[3]:{atom,S_Type,0,(S_used+K_used+K_gbl),0,0,{84'T',3},0,1,0,#0043A03B}
symtab[4]:{T_Dsq,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[5]:{0b0101,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[6]:{0b0110,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[7]:{0b0111,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[8]:{string,S_Type,0,(S_used+K_used+K_gbl),0,0,{84'T',8},0,1,0,#0043A03D}
symtab[9]:{0b1001,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[10]:{0b1010,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[11]:{0b1011,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[12]:{sequence,S_Type,0,(S_used+K_used+K_gbl),0,0,{84'T',12},0,1,0,#0043A03C}
symtab[13]:{0b1101,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[14]:{0b1110,S_Type,0,(K_used+K_gbl),0,0,T,0,0,0,#00439FFF}
symtab[15]:{object,S_Type,0,(S_used+K_used+K_gbl),0,0,{84'T',15},0,1,0,#0043A03E}
symtab[16=filepaths][1]:"C:\\Program Files (x86)\\Phix\\builtins\\"
                    [2]:"C:\\Program Files (x86)\\Phix\\builtins\\VM\\"
                    [3]:"C:\\Program Files (x86)\\Phix\\"
                    [4]:"C:\\Program Files (x86)\\Phix\\test\\FP\\"
symtab[17=filenames][1]:{4, "t02.exw"}
                    [2]:{2, "pDiagN.e"}
                    [3]:{2, "pprntfN.e"}
                    [4]:{2, "pUnassigned.e"}
                    [5]:{2, "puts1.e"}
                    [6]:{2, "psprintN.e"}
                    [7]:{1, "pcurrdir.e"}
                    [8]:{1, "pgetpath.e"}
                    [9]:{1, "peekstr.e"}
                    [10]:{1, "pcase.e"}
                    [11]:{1, "ppp.e"}
                    [12]:{2, "pStack.e"}
                    [13]:{2, "pFEH.e"}
                    [14]:{2, "pHeap.e"}
                    [15]:{2, "pSubseN.e"}
                    [16]:{2, "pFixup.e"}
                    [17]:{2, "pFPU.e"}
                    [18]:{2, "pSubssN.e"}
                    [19]:{2, "pRepeN.e"}
                    [20]:{2, "pRepsN.e"}
                    [21]:{2, "pMkSqN.e"}
                    [22]:{2, "pApnd.e"}
                    [23]:{2, "pJcc.e"}
                    [24]:{2, "pUnary.e"}
                    [25]:{2, "pMath.e"}
                    [26]:{2, "pXor.e"}
                    [27]:{2, "pLen.e"}
                    [28]:{2, "pRmdr.e"}
                    [29]:{2, "pMem.e"}
                    [30]:{2, "pfileioN.e"}
                    [31]:{2, "pPower.e"}
                    [32]:{2, "pJnotx.e"}
                    [33]:{2, "pRepeatN.e"}
                    [34]:{2, "pcfuncN.e"}
                    [35]:{2, "pFind.e"}
                    [36]:{2, "pMatch.e"}
                    [37]:{1, "sort.e"}
symtab[18]:0 (T_nslink)
symtab[19]:1 (T_cmdlnflg)
symtab[20=optable][1]:#00442B92 (:%puts1)
                  [2]:#00442B9E (:%puts1rdirsi)
                  [3]:#00442BD7 (:%puthex32a)
                  [4]:#00442BFC (:%puthex32)
                  [5]:#00442C4C (:%puthex64)
                  [6]:#00442CA2 (:%putsint)
                  [7]:#00442D0D (:%getc0)
                  [8]:#00442E19 (:%pCrashMsg)
                  [9]:#00442E53 (:%pCrashFile)
                  [10]:#00442E55 (:!SetBatchMode)
                  [11]:#00442E66 (:!iDiag)
                  [12]:#00442F64 (:!fehDiag)
                  [13]:#00000000 (:%opTrace)
                  [14]:#00000000 (:%opLnt)
                  [15]:#00000000 (:%opClrDbg)
                  [16]:#00000000 (:%opProfout)
                  [17]:#00000000 (:%opProfile)
                  [18]:#00000000 (:%opLnp)
                  [19]:#00000000 (:%opLnpt)
                  [20]:#0044178C (:%pGetpGtcb)
                  [21]:#00441794 (:%pNewGtcbChain)
                  [22]:#004417A3 (:%pRestoreGtcbChain)
                  [23]:#004420E3 (:%pAllocStr)
                  [24]:#00442148 (:%pAllocSeq)
                  [25]:#004421B0 (:%pStoreFlt)
                  [26]:#0044228A (:%pStoreMint)
                  [27]:#004422DA (:%pDealloc)
                  [28]:#004422DE (:%pDealloc0)
                  [29]:#00441B4D (:%pGetPool)
                  [30]:#00441FFA (:%pFreePool)
                  [31]:#00442460 (:%pAlloc)
                  [32]:#004424C8 (:%pFree)
                  [33]:#0044250E (:%pInitCS)
                  [34]:#00442557 (:%pDeleteCS)
                  [35]:#0044258C (:%pEnterCS)
                  [36]:#004425D1 (:%pTryCS)
                  [37]:#004425E9 (:%pLeaveCS)
symtab[21]:{T_maintls,S_Proc,1,(K_wdb+K_ran),0,73,P,0,0,0,#0043A000}
symtab[22..23]:0
symtab[24]:{T_constm1,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,1/#00402020,integer,-1}
symtab[25]:{T_const0,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,2/#00402028,integer,0}
symtab[26]:{T_const1,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,3/#00402030,integer,1}
symtab[27]:{C_CHAR,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,4/#00402038,integer,16777217}
symtab[28]:{C_UCHAR,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,5/#00402040,integer,33554433}
symtab[29]:{C_SHORT,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,6/#00402048,integer,16777218}
symtab[30]:{C_USHORT,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,7/#00402050,integer,33554434}
symtab[31]:{C_INT,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,8/#00402058,integer,16777220}
symtab[32]:{C_LONG,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,9/#00402060,integer,16777220}
symtab[33]:{C_UINT,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,10/#00402068,integer,33554436}
symtab[34]:{C_POINTER,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,11/#00402070,integer,33554436}
symtab[35]:{C_PTR,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,12/#00402078,integer,33554436}
symtab[36]:{C_FLOAT,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,13/#00402080,integer,50331652}
symtab[37]:{C_DOUBLE,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,14/#00402088,integer,50331656}
symtab[38]:{NULL,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,15/#00402090,integer,0}
symtab[39]:{WIN32,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,16/#00402098,integer,2}
symtab[40]:{LINUX,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,17/#004020A0,integer,3}
symtab[41]:{D_YEAR,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,18/#004020A8,integer,4}
symtab[42]:{D_MONTH,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,19/#004020B0,integer,5}
symtab[43]:{D_DAY,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,20/#004020B8,integer,6}
symtab[44]:{D_HOUR,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,21/#004020C0,integer,7}
symtab[45]:{D_MINUTE,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,22/#004020C8,integer,8}
symtab[46]:{D_SECOND,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,23/#004020D0,integer,9}
symtab[47]:{LOCK_SHARED,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,24/#004020D8,integer,1}
symtab[48]:{LOCK_EXCLUSIVE,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,25/#004020E0,integer,2}
symtab[49]:{BRIGHT_GREEN,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,26/#004020E8,integer,10}
symtab[50]:{BRIGHT_MAGENTA,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,27/#004020F0,integer,13}
symtab[51]:{YELLOW,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,28/#004020F8,integer,14}
symtab[52]:{BLINKING,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,29/#00402100,integer,16}
symtab[53]:{DB_EXISTS_ALREADY,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,30/#00402108,integer,-2}
symtab[54]:{pp_File,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,31/#00402110,integer,1}
symtab[55]:{pp_Maxlen,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,32/#00402118,integer,2}
symtab[56]:{pp_Pause,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,33/#00402120,integer,3}
symtab[57]:{pp_StrFmt,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,34/#00402128,integer,4}
symtab[58]:{pp_IntFmt,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,35/#00402130,integer,5}
symtab[59]:{pp_FltFmt,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,36/#00402138,integer,6}
symtab[60]:{pp_Nest,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,37/#00402140,integer,7}
symtab[61]:{pp_Ascii,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,38/#00402148,integer,8}
symtab[62]:{pp_Date,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,39/#00402150,integer,9}
symtab[63]:{pp_Brkt,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,40/#00402158,integer,10}
symtab[64]:{pp_Indent,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,41/#00402160,integer,11}
symtab[65]:{pp_Q22,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,42/#00402168,integer,12}
symtab[66]:{MB_ICONQUESTION,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,43/#00402170,integer,32' '}
symtab[67]:{MB_ICONEXCLAMATION,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,44/#00402178,integer,48'0'}
symtab[68]:{MB_DEFBUTTON2,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,45/#00402180,integer,256}
symtab[69]:{MB_SETFOREGROUND,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,46/#00402188,integer,65536}
symtab[70]:{SEEK_OK,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,47/#00402190,integer,0}
symtab[71]:{INFINITE,S_Const,0,(S_used+K_noclr+K_gbl+K_lit),0,48/#00402198,atom,4294967295}
symtab[72]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,-1,MAXLEN,object,-1},(rax)}
symtab[73]:{define_c_func,S_Func,34,(S_used+K_used+K_wdb+K_gbl),0,75,{70'F',15,15,12,3},1188,4,16,#0044A3A8}
symtab[74]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,0,MAXLEN,object,-1},(rax)}
symtab[75]:{find,S_Func,35,(S_used+K_used+K_gbl),0,77,{70'F',15,12,1},1266,2,7,#0043DAD6}
symtab[76]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,MININT,MAXINT,object,-1},(rax)}
symtab[77]:{match,S_Func,36,(S_used+K_used+K_wdb+K_gbl),0,79,{70'F',15,12,1},1273,2,17,#00449700}
symtab[78]:{-1,S_TVar,0,(S_set+K_Fres),0,0,object,{object,MININT,MAXINT,object,-1},(rax)}
symtab[79]:{c_func,S_Func,34,(S_used+K_used+K_wdb+K_gbl),0,81,{70'F',1,12},1251,1,10,#00449946}
symtab[80]:{-1,S_TVar,0,(S_set+K_Fres),0,0,atom,{atom,MININT,MAXINT,object,-1},(rax)}
symtab[81]:{open_dll,S_Func,34,(S_used+K_used+K_wdb+K_gbl),0,83,{70'F',12},1169,1,6,#0044A882}
symtab[82]:{-1,S_TVar,0,(S_set+K_Fres),0,0,sequence,{sequence,MININT,MAXINT,object,-2},(rax)}
symtab[83]:{current_dir,S_Func,7,(S_used+K_used+K_wdb+K_gbl),0,85,F,308,0,4,#00448C57}
symtab[84]:{-1,S_TVar,0,(S_set+K_Fres),0,0,sequence,{sequence,MININT,MAXINT,object,-2},(rax)}
symtab[85]:{get_proper_path,S_Func,8,(S_used+K_used+K_wdb+K_gbl),0,87,{70'F',12,15},297,1,5,#00448F1E}
symtab[86]:{-1,S_TVar,0,(S_set+K_Fres),0,0,sequence,{string,MININT,MAXINT,integer,-2},(rax)}
symtab[87]:{peek_string,S_Func,9,(S_used+K_used+K_wdb+K_gbl),0,89,{70'F',3},273,1,3,#00449225}
symtab[88]:{-1,S_TVar,0,(S_set+K_Fres),0,0,string,{string,MININT,MAXINT,integer,-2},(rax)}
symtab[89]:{sprintf,S_Func,3,(S_used+K_used+K_wdb+K_gbl),0,91,{70'F',12,15},193,2,33,#0044E450}
symtab[90]:{-1,S_TVar,0,(S_set+K_Fres),0,0,object,{0b1101,0,0,object,-2},(rax)}
symtab[91]:{sprint,S_Func,6,(S_used+K_used+K_wdb+K_gbl),0,93,{70'F',15,1,1},257,1,11,#0044D2DF}
symtab[92]:{-1,S_TVar,0,(S_set+K_Fres),0,0,sequence,{sequence,MININT,MAXINT,object,-2},(rax)}
symtab[93]:{sort,S_Func,37,(S_used+K_used+K_wdb+K_gbl),0,94,{70'F',12},1291,1,12,#0044AEAD}
symtab[94]:{printf,S_Proc,3,(S_used+K_used+K_wdb+K_gbl),0,95,{80'P',1,12,15},238,2,4,#00451A31}
symtab[95]:{<tls>,S_Proc,2,(S_used+K_used+K_wdb),0,98,P,0,0,0,#00442DE8}
symtab[96]:{diagdiag,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,49/#004021A0,integer,1}
symtab[97]:{show_bad_era,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,50/#004021A8,integer,1}
symtab[98]:{<tls>,S_Proc,4,(S_used+K_used+K_wdb),0,99,P,0,0,0,#00442D70}
symtab[99]:{<tls>,S_Proc,5,(S_used+K_used+K_wdb),0,102,P,0,0,0,#00442B8D}
symtab[100]:{eBadRetf,S_Const,4,(S_used+S_set+K_noclr+K_lit),0,51/#004021B0,string,"eBadRetf called, return address is #\n"}
symtab[101]:{-1,S_TVar,0,(S_set+K_Fres),0,0,string,{string,MININT,MAXINT,integer,-2},(rax)}
symtab[102]:{round,S_Func,3,(S_used+K_used+K_wdb),0,125,{70'F',8,3,1,1,1},103,5,12,#00451360}
symtab[103]:{result,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,104,string,{sequence,MININT,MAXINT,integer,-2},[rsp]}
symtab[104]:{f,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,105,atom,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[105]:{exp,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,106,integer,{integer,MININT,MAXINT,object,-1},[rsp-16]}
symtab[106]:{charflag,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,107,integer,{integer,MININT,MAXINT,object,-1},[rsp-24]}
symtab[107]:{digit,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,108,integer,{integer,MININT,MAXINT,object,-1},[rsp-32]}
symtab[108]:{tmp,S_TVar,3,(S_used+S_set+K_wdb),0,109,integer,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[109]:{dot,S_TVar,3,(S_used+S_set+K_wdb),0,110,integer,{integer,0,MAXLEN,object,-1},[rsp-48]}
symtab[110]:{dotm1,S_TVar,3,(S_used+S_set+K_wdb),0,111,integer,{integer,-1,805306367,object,-1},[rsp-56]}
symtab[111]:{-1,S_TVar,0,(S_set),0,112,atom,{atom,MININT,MAXINT,object,-1},[rsp-64]}
symtab[112]:{-1,S_TVar,0,(S_set),0,113,integer,{integer,0,MAXLEN,object,-1},[rsp-72]}
symtab[113]:{i,S_TVar,3,(S_used+S_set+S_for+K_wdb),0,118,integer,{integer,0,MAXLEN,object,-1},[rsp-80]}
symtab[114]:{-1,S_Const,3,(S_set+K_noclr+K_lit),0,52/#004021B8,integer,57'9'}
symtab[115]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,53/#004021C0,integer,46'.'}
symtab[116]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,54/#004021C8,string,"1"}
symtab[117]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,55/#004021D0,integer,102'f'}
symtab[118]:{-1,S_TVar,0,(S_set),0,0,integer,{integer,0,255,object,-1},[rsp-88]}
symtab[119]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,56/#004021D8,integer,33'!'}
symtab[120]:{-1,S_Const,3,(S_set+K_noclr+K_lit),0,57/#004021E0,integer,103'g'}
symtab[121]:{init2,S_GVar,3,(S_used+S_set+K_wdb+K_noclr),0,58/#004021E8,integer,{integer,0,1,object,-1},0}
symtab[122]:{inf,S_GVar,3,(S_used+S_set+K_wdb),0,59/#004021F0,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[123]:{nan,S_GVar,3,(S_used+S_set+K_wdb),0,60/#004021F8,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[124]:{-1,S_TVar,0,(S_set+K_Fres),0,0,string,{string,MININT,MAXINT,integer,3},(rax)}
symtab[125]:{Nan,S_Func,3,(S_used+K_used+K_wdb),0,130,F,126,0,1,#0045196E}
symtab[126]:{res,S_TVar,3,(S_used+S_set+K_wdb),0,0,string,{string,MININT,MAXINT,integer,3},[rsp]}
symtab[127]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,61/#00402200,integer,110'n'}
symtab[128]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,62/#00402208,integer,97'a'}
symtab[129]:{-1,S_TVar,0,(S_set+K_Fres),0,0,string,{string,MININT,MAXINT,integer,3},(rax)}
symtab[130]:{Inf,S_Func,3,(S_used+K_used+K_wdb),0,134,F,131,0,1,#00451917}
symtab[131]:{res,S_TVar,3,(S_used+S_set+K_wdb),126,0,string,{string,MININT,MAXINT,integer,3},[rsp]}
symtab[132]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,63/#00402210,integer,105'i'}
symtab[133]:{-1,S_TVar,0,(S_set+K_Fres),0,0,string,{string,MININT,MAXINT,integer,-2},(rax)}
symtab[134]:{sprintf2,S_Func,3,(S_used+K_used+K_wdb),0,175,{70'F',3,1,1,1,1},135,5,31,#0044FD4F}
symtab[135]:{pf,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,136,atom,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[136]:{charflag,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),106,137,integer,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[137]:{showplus,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,138,integer,{integer,0,1,object,-1},[rsp-16]}
symtab[138]:{minfieldwidth,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,139,integer,{integer,MININT,MAXINT,object,-1},[rsp-24]}
symtab[139]:{precision,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,140,integer,{atom,MININT,MAXINT,object,-1},[rsp-32]}
symtab[140]:{dotdone,S_TVar,3,(S_used+S_set+K_wdb),0,141,integer,{integer,0,1,object,-1},[rsp-40]}
symtab[141]:{nzdigitprinted,S_TVar,3,(S_used+S_set+K_wdb),0,142,integer,{integer,0,1,object,-1},[rsp-48]}
symtab[142]:{reve,S_TVar,3,(S_used+S_set+K_wdb),0,143,string,{sequence,MININT,MAXINT,atom,-2},[rsp-56]}
symtab[143]:{revelen,S_TVar,3,(S_used+S_set+K_wdb),0,144,integer,{atom,MININT,MAXINT,object,-1},[rsp-64]}
symtab[144]:{expadj,S_TVar,3,(S_used+S_set+K_wdb),0,145,integer,{atom,MININT,MAXINT,object,-1},[rsp-72]}
symtab[145]:{capE,S_TVar,3,(S_used+S_set+K_wdb),0,146,integer,{integer,69,101,object,-1},[rsp-80]}
symtab[146]:{ewk,S_TVar,3,(S_used+S_set+K_wdb),0,147,integer,{atom,MININT,MAXINT,object,-1},[rsp-88]}
symtab[147]:{tmp,S_TVar,3,(S_used+S_set+K_wdb),108,148,integer,{integer,0,255,object,-1},[rsp-96]}
symtab[148]:{digit,S_TVar,3,(S_used+S_set+K_wdb),107,149,integer,{atom,MININT,MAXINT,object,-1},[rsp-104]}
symtab[149]:{f,S_TVar,3,(S_used+S_set+K_wdb),104,150,atom,{atom,MININT,MAXINT,object,-1},[rsp-112]}
symtab[150]:{fwk,S_TVar,3,(S_used+S_set+K_wdb),0,151,atom,{atom,MININT,MAXINT,object,-1},[rsp-120]}
symtab[151]:{epwr,S_TVar,3,(S_used+S_set+K_wdb),0,152,atom,{atom,MININT,MAXINT,object,-1},[rsp-128]}
symtab[152]:{result,S_TVar,3,(S_used+S_set+K_wdb),103,153,string,{sequence,MININT,MAXINT,atom,-2},[rsp-136]}
symtab[153]:{exp,S_TVar,3,(S_used+S_set+K_wdb),105,154,integer,{atom,MININT,MAXINT,object,-1},[rsp-144]}
symtab[154]:{k,S_TVar,3,(S_used+S_set+K_wdb),0,157,integer,{integer,0,MAXLEN,object,-1},[rsp-152]}
symtab[155]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,64/#00402218,integer,45'-'}
symtab[156]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,65/#00402220,integer,43'+'}
symtab[157]:{-1,S_TVar,0,(S_set),158,158,string,{string,MININT,MAXINT,integer,-2},[rsp-160]}
symtab[158]:{-1,S_TVar,0,(S_set),0,161,string,{string,MININT,MAXINT,integer,-2},[rsp-168]}
symtab[159]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,66/#00402228,integer,101'e'}
symtab[160]:{-1,S_Const,3,(S_set+K_noclr+K_lit),0,67/#00402230,integer,69'E'}
symtab[161]:{-1,S_TVar,0,(S_set),166,162,atom,{atom,MININT,MAXINT,object,-1},[rsp-176]}
symtab[162]:{-1,S_TVar,0,(S_set),0,163,integer,{integer,MININT,MAXINT,object,-1},[rsp-184]}
symtab[163]:{i,S_TVar,3,(S_used+S_set+S_for+K_wdb),113,164,integer,{integer,MININT,MAXINT,object,-1},[rsp-192]}
symtab[164]:{-1,S_TVar,0,(S_set),0,166,integer,{integer,0,MAXLEN,object,-1},[rsp-200]}
symtab[165]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,68/#00402238,string,"0"}
symtab[166]:{-1,S_TVar,0,(S_set),0,167,atom,{atom,MININT,MAXINT,object,-1},[rsp-208]}
symtab[167]:{-1,S_TVar,0,(S_set),0,168,integer,{integer,0,MAXLEN,object,-1},[rsp-216]}
symtab[168]:{j,S_TVar,3,(S_used+S_set+S_for+K_wdb),0,173,integer,{integer,0,MAXLEN,object,-1},[rsp-224]}
symtab[169]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,69/#00402240,string,{}}
symtab[170]:{-1,S_Const,3,(S_set+K_noclr+K_lit),0,70/#00402248,string,"-"}
symtab[171]:{-1,S_Const,3,(S_set+K_noclr+K_lit),0,71/#00402250,string,"+"}
symtab[172]:{-1,S_Const,3,(S_used+S_set+K_sqr+K_noclr+K_lit),0,72/#00402258,T_Dsq,{{}, "-", "+"}}
symtab[173]:{-1,S_TVar,0,(S_set),0,174,integer,{integer,MININT,MAXINT,object,-1},[rsp-232]}
symtab[174]:{j,S_TVar,3,(S_used+S_set+S_for+K_wdb),168,0,integer,{integer,MININT,MAXINT,object,-1},[rsp-240]}
symtab[175]:{badfmt,S_Proc,3,(S_used+K_used+K_wdb),0,177,P,0,0,0,#004519AB}
symtab[176]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,0,1,object,-1},(rax)}
symtab[177]:{useFlatString,S_Func,3,(S_used+K_used+K_wdb),0,244,{70'F',12,1,12,1},178,4,11,#0045174E}
symtab[178]:{args,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,179,sequence,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[179]:{nxt,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,180,integer,{integer,MININT,MAXINT,object,-1},[rsp-8]}
symtab[180]:{format,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,181,sequence,{string,MININT,MAXINT,integer,-2},[rsp-16]}
symtab[181]:{i,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),163,182,integer,{integer,MININT,MAXINT,object,-1},[rsp-24]}
symtab[182]:{o,S_TVar,3,(S_used+S_set+K_wdb),0,183,object,{object,MININT,MAXINT,object,-2},[rsp-32]}
symtab[183]:{-1,S_TVar,0,(S_set),0,184,atom,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[184]:{-1,S_TVar,0,(S_set),0,185,integer,{integer,0,MAXLEN,object,-1},[rsp-48]}
symtab[185]:{j,S_TVar,3,(S_used+S_set+S_for+K_wdb),174,187,integer,{atom,MININT,MAXINT,object,-1},[rsp-56]}
symtab[186]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,73/#00402260,integer,37'%'}
symtab[187]:{-1,S_TVar,0,(S_set),0,188,object,{integer,0,255,object,-1},[rsp-64]}
symtab[188]:{-1,S_TVar,0,(S_set),0,189,integer,{atom,MININT,MAXINT,object,-1},[rsp-72]}
symtab[189]:{j,S_TVar,3,(S_used+S_set+S_for+K_wdb),185,0,integer,{integer,0,MAXLEN,object,-1},[rsp-80]}
symtab[190]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,74/#00402268,integer,255''}
symtab[191]:{hexchar,S_GVar,3,(S_used+S_set+K_wdb),0,75/#00402270,string,{string,MININT,MAXINT,integer,22},0}
symtab[192]:{bases,S_GVar,3,(S_used+S_set+K_wdb),0,76/#00402278,sequence,{T_Dsq,MININT,MAXINT,integer,4},0}
symtab[193]:{format,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),180,194,sequence,{string,MININT,MAXINT,integer,-2},[rsp]}
symtab[194]:{args,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),178,195,object,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[195]:{i,S_TVar,3,(S_used+S_set+K_wdb),181,196,integer,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[196]:{fi,S_TVar,3,(S_used+S_set+K_wdb),0,197,integer,{integer,0,255,object,-1},[rsp-24]}
symtab[197]:{fidx,S_TVar,3,(S_used+S_set+K_wdb),0,198,integer,{integer,0,MAXLEN,object,-1},[rsp-32]}
symtab[198]:{nxt,S_TVar,3,(S_used+S_set+K_wdb),179,199,integer,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[199]:{result,S_TVar,3,(S_used+S_set+K_wdb),152,200,string,{sequence,MININT,MAXINT,integer,-2},[rsp-48]}
symtab[200]:{r1,S_TVar,3,(S_used+S_set+K_wdb),0,201,string,{sequence,MININT,MAXINT,integer,-2},[rsp-56]}
symtab[201]:{o,S_TVar,3,(S_used+S_set+K_wdb),182,202,object,{object,MININT,MAXINT,object,-2},[rsp-64]}
symtab[202]:{oj,S_TVar,3,(S_used+S_set+K_wdb),0,203,object,{object,MININT,MAXINT,object,-2},[rsp-72]}
symtab[203]:{work,S_TVar,3,(S_used+S_set+K_wdb),0,204,atom,{atom,MININT,MAXINT,object,-1},[rsp-80]}
symtab[204]:{base,S_TVar,3,(S_used+S_set+K_wdb),0,205,integer,{integer,MININT,MAXINT,object,-1},[rsp-88]}
symtab[205]:{sign,S_TVar,3,(S_used+S_set+K_wdb),0,206,integer,{integer,0,1,object,-1},[rsp-96]}
symtab[206]:{r1len,S_TVar,3,(S_used+S_set+K_wdb),0,207,integer,{atom,MININT,MAXINT,object,-1},[rsp-104]}
symtab[207]:{hc,S_TVar,3,(S_used+S_set+K_wdb),0,208,integer,{atom,MININT,MAXINT,object,-1},[rsp-112]}
symtab[208]:{lowerHex,S_TVar,3,(S_used+S_set+K_wdb),0,209,integer,{integer,0,1,object,-1},[rsp-120]}
symtab[209]:{zerofill,S_TVar,3,(S_used+S_set+K_wdb),0,210,integer,{integer,0,1,object,-1},[rsp-128]}
symtab[210]:{leftjustify,S_TVar,3,(S_used+S_set+K_wdb),0,211,integer,{integer,0,1,object,-1},[rsp-136]}
symtab[211]:{showplus,S_TVar,3,(S_used+S_set+K_wdb),137,212,integer,{integer,0,1,object,-1},[rsp-144]}
symtab[212]:{showcommas,S_TVar,3,(S_used+S_set+K_wdb),0,213,integer,{atom,MININT,MAXINT,object,-1},[rsp-152]}
symtab[213]:{minfieldwidth,S_TVar,3,(S_used+S_set+K_wdb),138,214,integer,{atom,MININT,MAXINT,object,-1},[rsp-160]}
symtab[214]:{precision,S_TVar,3,(S_used+S_set+K_wdb),139,215,integer,{atom,MININT,MAXINT,object,-1},[rsp-168]}
symtab[215]:{tmp,S_TVar,3,(S_used+S_set+K_wdb),147,218,integer,{integer,0,255,object,-1},[rsp-176]}
symtab[216]:{-1,S_Const,3,(S_set+K_noclr+K_lit),0,77/#00402280,T_N,1e+300}
symtab[217]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,78/#00402288,atom,inf}
symtab[218]:{-1,S_TVar,0,(S_set),0,221,atom,{atom,MININT,MAXINT,object,-1},[rsp-184]}
symtab[219]:{-1,S_Const,3,(S_used+S_set+K_sqr+K_noclr+K_lit),0,79/#00402290,T_Dsq,{10,16,8,2}}
symtab[220]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,80/#00402298,string,"0123456789ABCDEFabcdef"}
symtab[221]:{-1,S_TVar,0,(S_set),228,223,integer,{integer,0,MAXLEN,object,-1},[rsp-192]}
symtab[222]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,81/#004022A0,integer,44','}
symtab[223]:{-1,S_TVar,0,(S_set),218,228,atom,{atom,MININT,MAXINT,object,-1},[rsp-200]}
symtab[224]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,82/#004022A8,string,"dxobscefgEXG"}
symtab[225]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,83/#004022B0,string,"df"}
symtab[226]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,84/#004022B8,T_N,2147483647}
symtab[227]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,85/#004022C0,T_N,2147483648}
symtab[228]:{-1,S_TVar,0,(S_set),0,229,integer,{integer,0,MAXLEN,object,-1},[rsp-208]}
symtab[229]:{-1,S_TVar,0,(S_set),0,230,sequence,{sequence,MININT,MAXINT,integer,-2},[rsp-216]}
symtab[230]:{-1,S_TVar,0,(S_set),0,231,integer,{integer,0,MAXLEN,object,-1},[rsp-224]}
symtab[231]:{j,S_TVar,3,(S_used+S_set+S_for+K_wdb),189,232,integer,{integer,0,MAXLEN,object,-1},[rsp-232]}
symtab[232]:{-1,S_TVar,0,(S_set),237,235,string,{string,MININT,MAXINT,integer,-2},[rsp-240]}
symtab[233]:{-1,S_Const,3,(S_used+S_set+K_sqr+K_noclr+K_lit),0,86/#004022C8,T_Dsq,{}}
symtab[234]:{-1,S_Const,3,(S_used+S_set+K_noclr+K_lit),0,87/#004022D0,string," "}
symtab[235]:{j,S_TVar,3,(S_used+S_set+S_for+K_wdb),231,237,integer,{integer,0,MAXLEN,object,-1},[rsp-248]}
symtab[236]:{sizeof_OVERLAPPED,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,88/#004022D8,integer,20}
symtab[237]:{-1,S_TVar,0,(S_set),0,0,string,{string,MININT,MAXINT,integer,-2},[rsp-256]}
symtab[238]:{fn,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),0,239,integer,{integer,-1,10000,object,-1},[rsp]}
symtab[239]:{format,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr),193,240,sequence,{string,MININT,MAXINT,integer,-2},[rsp-8]}
symtab[240]:{args,S_TVar,3,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),194,241,object,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[241]:{-1,S_TVar,0,(S_set),0,0,string,{string,MININT,MAXINT,integer,-2},[rsp-24]}
symtab[242]:{tnr,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,89/#004022E0,string,"tnr\\"&#22&"\'0"}
symtab[243]:{-1,S_TVar,0,(S_set+K_Fres),0,0,0b1001,{0b1001,0,0,integer,-2},(rax)}
symtab[244]:{allascii,S_Func,6,(S_used+K_used+K_wdb),0,277,{70'F',8},245,1,7,#0044DA46}
symtab[245]:{x,S_TVar,6,(S_used+S_set+K_used+K_wdb+K_othr),0,246,string,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[246]:{c,S_TVar,6,(S_used+S_set+K_wdb),0,247,integer,{integer,0,MAXLEN,object,-1},[rsp-8]}
symtab[247]:{-1,S_TVar,0,(S_set),0,248,integer,{integer,0,MAXLEN,object,-1},[rsp-16]}
symtab[248]:{i,S_TVar,6,(S_used+S_set+S_for+K_wdb),195,253,integer,{integer,0,MAXLEN,object,-1},[rsp-24]}
symtab[249]:{-1,S_Const,6,(S_set+K_noclr+K_lit),0,90/#004022E8,integer,126'~'}
symtab[250]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,91/#004022F0,string,"\\"&#22&"\'"}
symtab[251]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,92/#004022F8,string,{9,10,13,92'\',34'"',39''',0}}
symtab[252]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,93/#00402300,integer,92'\'}
symtab[253]:{-1,S_TVar,0,(S_set),0,254,integer,{integer,0,255,object,-1},[rsp-32]}
symtab[254]:{-1,S_TVar,0,(S_set),0,256,sequence,{T_Dsq,MININT,MAXINT,object,-2},[rsp-40]}
symtab[255]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,94/#00402308,integer,34'"'}
symtab[256]:{-1,S_TVar,0,(S_set),0,0,string,{string,MININT,MAXINT,integer,-2},[rsp-48]}
symtab[257]:{x,S_TVar,6,(S_used+S_set+K_used+K_wdb+K_othr),245,258,object,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[258]:{l,S_TVar,6,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),0,259,integer,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[259]:{nest,S_TVar,6,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),0,260,integer,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[260]:{s,S_TVar,6,(S_used+S_set+K_wdb),0,261,object,{0b1101,0,0,object,-2},[rsp-24]}
symtab[261]:{xi,S_TVar,6,(S_used+S_set+K_wdb),0,263,object,{object,MININT,MAXINT,object,-2},[rsp-32]}
symtab[262]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,95/#00402310,string,"%.10g"}
symtab[263]:{-1,S_TVar,0,(S_set),271,265,atom,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[264]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,96/#00402318,string,".0"}
symtab[265]:{-1,S_TVar,0,(S_set),0,266,integer,{integer,0,MAXLEN,object,-1},[rsp-48]}
symtab[266]:{-1,S_TVar,0,(S_set),0,269,string,{0b1101,0,0,object,-2},[rsp-56]}
symtab[267]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,97/#00402320,string,".."}
symtab[268]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,98/#00402328,string,"{"}
symtab[269]:{i,S_TVar,6,(S_used+S_set+S_for+K_wdb),248,270,integer,{integer,0,MAXLEN,object,-1},[rsp-64]}
symtab[270]:{-1,S_TVar,0,(S_set),0,271,integer,{integer,0,MAXLEN,object,-1},[rsp-72]}
symtab[271]:{-1,S_TVar,0,(S_set),0,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-80]}
symtab[272]:{-1,S_Const,6,(S_used+S_set+K_noclr+K_lit),0,99/#00402330,string,"}"}
symtab[273]:{addr,S_TVar,9,(S_used+S_set+K_used+K_wdb+K_othr),0,274,atom,{atom,MININT,MAXINT,object,-1},[rsp]}
symtab[274]:{ch,S_TVar,9,(S_used+S_set+K_wdb),0,275,integer,{integer,0,255,object,-1},[rsp-8]}
symtab[275]:{res,S_TVar,9,(S_used+S_set+K_wdb),131,0,sequence,{string,MININT,MAXINT,integer,-2},[rsp-16]}
symtab[276]:{-1,S_TVar,0,(S_set+K_Fres),0,0,sequence,{sequence,MININT,MAXINT,object,-2},(rax)}
symtab[277]:{cleanUpPath,S_Func,8,(S_used+K_used+K_wdb),0,392,{70'F',12,15},278,2,8,#0044928D}
symtab[278]:{filepath,S_TVar,8,(S_used+S_set+K_used+K_wdb+K_othr),0,279,sequence,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[279]:{rootdir,S_TVar,8,(S_used+S_set+K_used+K_wdb+K_othr),0,280,object,{0b1101,0,0,object,-2},[rsp-8]}
symtab[280]:{k,S_TVar,8,(S_used+S_set+K_wdb),154,281,integer,{integer,MININT,MAXINT,object,-1},[rsp-16]}
symtab[281]:{-1,S_TVar,0,(S_set),0,283,integer,{atom,MININT,MAXINT,object,-1},[rsp-24]}
symtab[282]:{-1,S_Const,8,(S_set+K_noclr+K_lit),0,100/#00402338,integer,58':'}
symtab[283]:{-1,S_TVar,0,(S_set),0,286,object,{object,MININT,MAXINT,object,-2},[rsp-32]}
symtab[284]:{-1,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,101/#00402340,integer,47'/'}
symtab[285]:{-1,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,102/#00402348,string,"\\..\\"}
symtab[286]:{-1,S_TVar,0,(S_set),0,287,atom,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[287]:{j,S_TVar,8,(S_used+S_set+S_for+K_wdb),235,289,integer,{atom,MININT,MAXINT,object,-1},[rsp-48]}
symtab[288]:{-1,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,103/#00402350,string,"Warning, cannot cleanup "}
symtab[289]:{-1,S_TVar,0,(S_set),0,0,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-56]}
symtab[290]:{-1,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,104/#00402358,string,"\\.\\"}
symtab[291]:{-1,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,105/#00402360,string,"\\\\"}
symtab[292]:{kernel32,S_GVar,8,(S_used+S_set+K_wdb),0,106/#00402368,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[293]:{buffer,S_GVar,8,(S_used+S_set+K_wdb),0,107/#00402370,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[294]:{xGetLongPathName,S_GVar,8,(S_used+S_set+K_wdb),0,108/#00402378,integer,{integer,-1,MAXLEN,object,-1},0}
symtab[295]:{MAX_PATH,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,109/#00402380,integer,260}
symtab[296]:{gppinit,S_GVar,8,(S_used+S_set+K_wdb+K_noclr),0,110/#00402388,integer,{integer,0,1,object,-1},0}
symtab[297]:{filepath,S_TVar,8,(S_used+S_set+K_used+K_wdb+K_othr),278,298,sequence,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[298]:{rootdir,S_TVar,8,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),279,299,object,{integer,0,0,object,-1},[rsp-8]}
symtab[299]:{l,S_TVar,8,(S_used+S_set+K_wdb),258,300,integer,{object,MININT,MAXINT,object,-1},[rsp-16]}
symtab[300]:{res,S_TVar,8,(S_used+S_set+K_wdb),275,304,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-24]}
symtab[301]:{-1,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,111/#00402390,string,"kernel32"}
symtab[302]:{-1,S_Const,8,(S_used+S_set+K_noclr+K_lit),0,112/#00402398,string,"GetLongPathNameA"}
symtab[303]:{-1,S_Const,8,(S_used+S_set+K_sqr+K_noclr+K_lit),0,113/#004023A0,T_Dsq,{33554436,33554436,16777220}}
symtab[304]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,3},[rsp-32]}
symtab[305]:{init,S_GVar,7,(S_used+S_set+K_wdb+K_noclr),0,114/#004023A8,integer,{integer,0,1,object,-1},0}
symtab[306]:{kernel32,S_GVar,7,(S_used+S_set+K_wdb),855,115/#004023B0,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[307]:{xGetCurrentDirectory,S_GVar,7,(S_used+S_set+K_wdb),0,116/#004023B8,atom,{integer,-1,MAXLEN,object,-1},0}
symtab[308]:{l,S_TVar,7,(S_used+S_set+K_wdb),299,309,integer,{object,MININT,MAXINT,object,-1},[rsp]}
symtab[309]:{res,S_TVar,7,(S_used+S_set+K_wdb),300,314,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-8]}
symtab[310]:{-1,S_Const,7,(S_used+S_set+K_noclr+K_lit),0,117/#004023C0,string,"kernel32.dll"}
symtab[311]:{-1,S_Const,7,(S_used+S_set+K_noclr+K_lit),0,118/#004023C8,string,"GetCurrentDirectoryA"}
symtab[312]:{-1,S_Const,7,(S_used+S_set+K_sqr+K_noclr+K_lit),0,119/#004023D0,T_Dsq,{16777220,33554436}}
symtab[313]:{-1,S_Const,7,(S_used+S_set+K_sqr+K_noclr+K_lit),0,120/#004023D8,T_Dsq,{0,0}}
symtab[314]:{-1,S_TVar,0,(S_set),0,315,atom,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[315]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,0b1001,2},[rsp-24]}
symtab[316]:{cinit,S_GVar,10,(S_used+S_set+K_wdb+K_noclr),0,121/#004023E0,integer,0}
symtab[317]:{toUpper,S_GVar,10,(S_used+S_set+K_wdb),0,122/#004023E8,string,?,0}
symtab[318]:{toLower,S_GVar,10,(S_used+S_set+K_wdb),0,123/#004023F0,string,?,0}
symtab[319]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,124/#004023F8,integer,254''}
symtab[320]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,125/#00402400,integer,65'A'}
symtab[321]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,126/#00402408,integer,90'Z'}
symtab[322]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,127/#00402410,integer,192''}
symtab[323]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,128/#00402418,integer,214''}
symtab[324]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,129/#00402420,integer,216''}
symtab[325]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,130/#00402428,integer,222''}
symtab[326]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,131/#00402430,integer,138''}
symtab[327]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,132/#00402438,integer,154''}
symtab[328]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,133/#00402440,integer,140''}
symtab[329]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,134/#00402448,integer,156''}
symtab[330]:{-1,S_Const,10,(S_set+K_noclr+K_lit),0,135/#00402450,integer,159''}
symtab[331]:{ppp_Maxlen,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,136/#00402458,integer,78'N'}
symtab[332]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,137/#00402460,integer,78'N'}
symtab[333]:{ppp_Indent,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,138/#00402468,integer,0}
symtab[334]:{ppp_Nest,S_GVar,11,(S_used+S_set+K_wdb),0,139/#00402470,object,?,0}
symtab[335]:{ppp_Pause,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,140/#00402478,integer,23}
symtab[336]:{T_ds4,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,141/#00402480,integer,23}
symtab[337]:{ppp_StrFmt,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,142/#00402488,integer,0}
symtab[338]:{ppp_Init,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,143/#00402490,integer,0}
symtab[339]:{ppp_Ascii,S_GVar,11,(S_used+S_set+K_wdb),0,144/#00402498,object,?,0}
symtab[340]:{ppp_IntFmt,S_GVar,11,(S_used+S_set+K_wdb),0,145/#004024A0,sequence,?,0}
symtab[341]:{ppp_FltFmt,S_GVar,11,(S_used+S_set+K_wdb),0,146/#004024A8,sequence,?,0}
symtab[342]:{ppp_Date,S_GVar,11,(S_used+S_set+K_wdb),0,147/#004024B0,sequence,?,0}
symtab[343]:{ppp_Br,S_GVar,11,(S_used+S_set+K_wdb),0,148/#004024B8,sequence,?,0}
symtab[344]:{ppp_Q22,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,149/#004024C0,integer,0}
symtab[345]:{ascii,S_GVar,11,(S_used+S_set+K_wdb),0,150/#004024C8,sequence,?,0}
symtab[346]:{ppp_File,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,151/#004024D0,integer,1}
symtab[347]:{ppp_result,S_GVar,11,(S_used+S_set+K_wdb),0,152/#004024D8,sequence,?,0}
symtab[348]:{pline,S_GVar,11,(S_used+S_set+K_wdb),0,153/#004024E0,sequence,?,0}
symtab[349]:{plen,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,154/#004024E8,integer,0}
symtab[350]:{sline,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,155/#004024F0,integer,0}
symtab[351]:{nindent,S_GVar,11,(S_used+S_set+K_wdb),0,156/#004024F8,integer,?,0}
symtab[352]:{escBytes,S_GVar,11,(S_used+S_set+K_wdb),0,157/#00402500,sequence,?,0}
symtab[353]:{escChars,S_GVar,11,(S_used+S_set+K_wdb),0,158/#00402508,sequence,?,0}
symtab[354]:{constants,S_GVar,11,(S_used+S_set+K_wdb),0,159/#00402510,sequence,?,0}
symtab[355]:{cl1q,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,160/#00402518,integer,0}
symtab[356]:{cllq,S_GVar,11,(S_used+S_set+K_wdb+K_noclr),0,161/#00402520,integer,0}
symtab[357]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,162/#00402528,string,"#22&"&#22}
symtab[358]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,163/#00402530,string,#22&"&#22"}
symtab[359]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,164/#00402538,string,#22&"&#22&"&#22}
symtab[360]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,165/#00402540,integer,31}
symtab[361]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,166/#00402548,integer,1900}
symtab[362]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,167/#00402550,integer,3000}
symtab[363]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,168/#00402558,string,",\n"}
symtab[364]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,169/#00402560,string,","}
symtab[365]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,170/#00402568,string,", "}
symtab[366]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,171/#00402570,atom,-4294967295}
symtab[367]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,172/#00402578,string,"%d\'%s\'"}
symtab[368]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,173/#00402580,string,"ppp.e: fatal: "}
symtab[369]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,174/#00402588,string,"\nPress d for diagnostics..."}
symtab[370]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,175/#00402590,string,"dD"}
symtab[371]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,176/#00402598,string,"length(ascii) must be 2"}
symtab[372]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,177/#004025A0,string,"length(minasc)!=length(maxasc)"}
symtab[373]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,178/#004025A8,string,"find(0,minasc) or find(0,maxasc)"}
symtab[374]:{-1,S_Const,11,(S_set+K_sqr+K_noclr+K_lit),0,179/#004025B0,T_Dsq," "}
symtab[375]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,180/#004025B8,string,"%d"}
symtab[376]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,181/#004025C0,string,"{}"}
symtab[377]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,182/#004025C8,string,"\t\n\r\\"&#22&"\'"}
symtab[378]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,183/#004025D0,string,"tnr\\"&#22&"\'"}
symtab[379]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,184/#004025D8,T_N,1.2958371959e+307}
symtab[380]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,185/#004025E0,atom,NOVALUE}
symtab[381]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,186/#004025E8,string,"NOVALUE"}
symtab[382]:{-1,S_Const,11,(S_set+K_sqr+K_noclr+K_lit),0,187/#004025F0,T_Dsq,{NOVALUE, "NOVALUE"}}
symtab[383]:{-1,S_Const,11,(S_set+K_noclr+K_lit),0,188/#004025F8,string,"length(options) not even"}
symtab[384]:{-1,S_Const,11,(S_used+S_set+K_noclr+K_lit),0,189/#00402600,string,"\n"}
symtab[385]:{-1,S_Const,11,(S_set+K_sqr+K_noclr+K_lit),0,190/#00402608,T_Dsq,{1,0,7,-1}}
symtab[386]:{-1,S_Const,11,(S_set+K_sqr+K_noclr+K_lit),0,191/#00402610,T_Dsq,{1,0}}
symtab[387]:{fn,S_GVar,2,(S_used+S_set+K_wdb),793,192/#00402618,integer,{integer,-1,10000,object,-1},0}
symtab[388]:{MAXLINELEN,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,193/#00402620,integer,77'M'}
symtab[389]:{MAXLENN,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,194/#00402628,integer,500}
symtab[390]:{OLDSTYLE,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,195/#00402630,integer,0}
symtab[391]:{printstack,S_GVar,2,(S_used+S_set+K_wdb),0,196/#00402638,sequence,{sequence,MININT,MAXINT,object,-2},0}
symtab[392]:{addtostack,S_Proc,2,(S_used+K_used+K_wdb),0,399,{80'P',12,1,8,8},393,4,5,#0044B089}
symtab[393]:{idii,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,394,sequence,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[394]:{idxr,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,395,integer,{integer,MININT,MAXINT,object,-1},[rsp-8]}
symtab[395]:{name,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,396,string,{string,MININT,MAXINT,integer,-2},[rsp-16]}
symtab[396]:{text,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,397,string,{object,MININT,MAXINT,object,-2},[rsp-24]}
symtab[397]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,sequence,3},[rsp-32]}
symtab[398]:{-1,S_TVar,0,(S_set+K_Fres),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,string,2},(rax)}
symtab[399]:{subscr,S_Func,2,(S_used+K_used+K_wdb),0,409,{70'F',8,8,1,1},400,4,5,#0044C8E1}
symtab[400]:{prev,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,401,string,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[401]:{name,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),395,402,string,{string,MININT,MAXINT,integer,-2},[rsp-8]}
symtab[402]:{prst,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,403,integer,{integer,MININT,MAXINT,object,-1},[rsp-16]}
symtab[403]:{prdx,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,405,integer,{integer,-2,MAXLEN,object,-1},[rsp-24]}
symtab[404]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,197/#00402640,string,"%s[%d]"}
symtab[405]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,0b1001,-2},[rsp-32]}
symtab[406]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,198/#00402648,string,"%s[%d..%d]"}
symtab[407]:{tnr,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),798,199/#00402650,string,"tnr\\"&#22&"\'0"}
symtab[408]:{-1,S_TVar,0,(S_set+K_Fres),0,0,0b1001,{0b1001,0,0,integer,-2},(rax)}
symtab[409]:{allascii,S_Func,2,(S_used+K_used+K_wdb),244,418,{70'F',8},410,1,7,#0044CB1C}
symtab[410]:{x,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),257,411,string,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[411]:{c,S_TVar,2,(S_used+S_set+K_wdb),246,412,integer,{integer,0,MAXLEN,object,-1},[rsp-8]}
symtab[412]:{-1,S_TVar,0,(S_set),0,413,integer,{integer,0,MAXLEN,object,-1},[rsp-16]}
symtab[413]:{i,S_TVar,2,(S_used+S_set+S_for+K_wdb),269,414,integer,{integer,0,MAXLEN,object,-1},[rsp-24]}
symtab[414]:{-1,S_TVar,0,(S_set),0,415,integer,{integer,0,255,object,-1},[rsp-32]}
symtab[415]:{-1,S_TVar,0,(S_set),0,416,sequence,{T_Dsq,MININT,MAXINT,object,-2},[rsp-40]}
symtab[416]:{-1,S_TVar,0,(S_set),0,0,string,{string,MININT,MAXINT,integer,-2},[rsp-48]}
symtab[417]:{-1,S_TVar,0,(S_set+K_Fres),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},(rax)}
symtab[418]:{cdi,S_Func,2,(S_used+K_used+K_wdb),0,447,{70'F',8,8,1,1,15,12},419,6,27,#0044B17E}
symtab[419]:{name,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),401,420,string,{string,MININT,MAXINT,integer,-2},[rsp]}
symtab[420]:{prev,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),400,421,string,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[421]:{prst,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),402,422,integer,{integer,MININT,MAXINT,object,-1},[rsp-16]}
symtab[422]:{prdx,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),403,423,integer,{integer,-1,MAXLEN,object,-1},[rsp-24]}
symtab[423]:{o,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),201,424,object,{object,MININT,MAXINT,object,-2},[rsp-32]}
symtab[424]:{idii,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),393,425,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-40]}
symtab[425]:{this,S_TVar,2,(S_used+S_set+K_wdb),0,426,object,{object,MININT,MAXINT,object,-2},[rsp-48]}
symtab[426]:{namedx,S_TVar,2,(S_used+S_set+K_wdb),0,427,string,{string,MININT,MAXINT,integer,-2},[rsp-56]}
symtab[427]:{newprst,S_TVar,2,(S_used+S_set+K_wdb),0,428,integer,{object,MININT,MAXINT,object,-2},[rsp-64]}
symtab[428]:{lo,S_TVar,2,(S_used+S_set+K_wdb),0,429,integer,{integer,0,MAXLEN,object,-1},[rsp-72]}
symtab[429]:{lp,S_TVar,2,(S_used+S_set+K_wdb),0,430,integer,{atom,MININT,MAXINT,object,-1},[rsp-80]}
symtab[430]:{lt,S_TVar,2,(S_used+S_set+K_wdb),0,431,integer,{atom,MININT,MAXINT,object,-1},[rsp-88]}
symtab[431]:{dotdot,S_TVar,2,(S_used+S_set+K_used+K_aod+K_wdb),0,432,integer,{integer,0,1,object,-1},[rsp-96]}
symtab[432]:{stringo,S_TVar,2,(S_used+S_set+K_used+K_aod+K_wdb),0,433,integer,{integer,0,1,object,-1},[rsp-104]}
symtab[433]:{wasstacklen,S_TVar,2,(S_used+S_set+K_wdb),0,434,integer,{integer,0,MAXLEN,object,-1},[rsp-112]}
symtab[434]:{-1,S_TVar,0,(S_set),0,436,integer,{integer,0,MAXLEN,object,-1},[rsp-120]}
symtab[435]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,200/#00402658,string,"\'%s\'"}
symtab[436]:{-1,S_TVar,0,(S_set),0,437,string,{string,MININT,MAXINT,integer,-2},[rsp-128]}
symtab[437]:{-1,S_TVar,0,(S_set),0,438,T_Dsq,{T_Dsq,MININT,MAXINT,0b1001,2},[rsp-136]}
symtab[438]:{i,S_TVar,2,(S_used+S_set+S_for+K_wdb),413,439,integer,{integer,0,MAXLEN,object,-1},[rsp-144]}
symtab[439]:{-1,S_TVar,0,(S_set),0,440,object,{object,MININT,MAXINT,object,-2},[rsp-152]}
symtab[440]:{-1,S_TVar,0,(S_set),0,441,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-160]}
symtab[441]:{-1,S_TVar,0,(S_set),0,442,integer,{integer,0,MAXLEN,object,-1},[rsp-168]}
symtab[442]:{-1,S_TVar,0,(S_set),0,443,atom,{atom,MININT,MAXINT,object,-1},[rsp-176]}
symtab[443]:{-1,S_TVar,0,(S_set),0,444,T_Dsq,{T_Dsq,MININT,MAXINT,0b1001,2},[rsp-184]}
symtab[444]:{-1,S_TVar,0,(S_set),0,445,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-192]}
symtab[445]:{-1,S_TVar,0,(S_set),0,446,T_Dsq,{T_Dsq,MININT,MAXINT,object,-2},[rsp-200]}
symtab[446]:{-1,S_TVar,0,(S_set),442,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-208]}
symtab[447]:{clever_dump,S_Proc,2,(S_used+K_used+K_wdb),0,461,{80'P',8,15},448,2,9,#0044AAD9}
symtab[448]:{name,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),419,449,string,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[449]:{o,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),423,450,object,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[450]:{prst,S_TVar,2,(S_used+S_set+K_wdb),421,451,integer,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[451]:{s,S_TVar,2,(S_used+S_set+K_wdb),260,452,string,{object,MININT,MAXINT,object,-2},[rsp-24]}
symtab[452]:{-1,S_TVar,0,(S_set),0,453,sequence,{sequence,MININT,MAXINT,object,2},[rsp-32]}
symtab[453]:{-1,S_TVar,0,(S_set),0,454,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-40]}
symtab[454]:{-1,S_TVar,0,(S_set),0,455,T_Dsq,{T_Dsq,MININT,MAXINT,integer,1},[rsp-48]}
symtab[455]:{-1,S_TVar,0,(S_set),0,456,integer,{integer,0,MAXLEN,object,-1},[rsp-56]}
symtab[456]:{i,S_TVar,2,(S_used+S_set+S_for+K_wdb),438,0,integer,{integer,0,MAXLEN,object,-1},[rsp-64]}
symtab[457]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,201/#00402660,string,"    %s = %s\n"}
symtab[458]:{lines,S_GVar,2,(S_used+S_set+K_wdb),0,202/#00402668,integer,{atom,MININT,MAXINT,object,-1},0}
symtab[459]:{crash_msg,S_GVar,2,(S_used+S_set+K_wdb+K_noclr),0,203/#00402670,object,{0b1101,0,0,object,-2},0}
symtab[460]:{batchmode,S_GVar,2,(S_used+S_set+K_wdb+K_noclr),0,204/#00402678,integer,{integer,0,1,object,-1},0}
symtab[461]:{putz,S_Proc,2,(S_used+K_used+K_wdb),0,474,{80'P',8,15,1},462,3,7,#0044CCDB}
symtab[462]:{name,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),448,463,string,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[463]:{o,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),449,464,object,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[464]:{novalue,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,465,integer,{integer,MININT,MAXINT,object,-1},[rsp-16]}
symtab[465]:{s,S_TVar,2,(S_used+S_set+K_wdb),451,471,string,{0b1101,0,0,object,-2},[rsp-24]}
symtab[466]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,205/#00402680,string,"<novalue>"}
symtab[467]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,206/#00402688,string,"*** INVALID REF ***"}
symtab[468]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,207/#00402690,string,"*** CORRUPT TYPE BYTE ***"}
symtab[469]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,208/#00402698,string,"*** INVALID ??? ***"}
symtab[470]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,209/#004026A0,integer,70'F'}
symtab[471]:{-1,S_TVar,0,(S_set),0,472,integer,{integer,0,MAXLEN,object,-1},[rsp-32]}
symtab[472]:{-1,S_TVar,0,(S_set),0,473,atom,{integer,-805306298,70,object,-1},[rsp-40]}
symtab[473]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,string,2},[rsp-48]}
symtab[474]:{put2,S_Proc,2,(S_used+K_used+K_wdb),0,625,{80'P',8},475,1,3,#0044D150}
symtab[475]:{emsg,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,476,string,{sequence,MININT,MAXINT,integer,-2},[rsp]}
symtab[476]:{-1,S_TVar,0,(S_set),0,478,integer,{integer,0,MAXLEN,object,-1},[rsp-8]}
symtab[477]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,210/#004026A8,string,"?? length 0 crash_msg ??\n"}
symtab[478]:{-1,S_TVar,0,(S_set),0,0,object,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[479]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,211/#004026B0,integer,999}
symtab[480]:{swod,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,212/#004026B8,integer,0}
symtab[481]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,213/#004026C0,string,"type check failure, %s is %s\n"}
symtab[482]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,214/#004026C8,string,"attempt to divide by 0\n"}
symtab[483]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,215/#004026D0,string,"true/false condition must be an ATOM\n"}
symtab[484]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,216/#004026D8,string,"attempt to subscript an atom\n"}
symtab[485]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,217/#004026E0,string,"subscript is not an atom\n"}
symtab[486]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,218/#004026E8,string,"index %d out of bounds, assigning to sequence length %d\n"}
symtab[487]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,219/#004026F0,string,"slice start is less than 1 (%d)\n"}
symtab[488]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,220/#004026F8,string,"slice end is not an integer\n"}
symtab[489]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,221/#00402700,string,"slice length is negative [%d..%d]\n"}
symtab[490]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,222/#00402708,string,"slice starts past end of sequence (%d > %d)\n"}
symtab[491]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,223/#00402710,string,"slice ends past end of sequence (%d > %d)\n"}
symtab[492]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,224/#00402718,string,"program aborted\n"}
symtab[493]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,225/#00402720,string,"attempt to exit a function without returning a value\n"}
symtab[494]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,226/#00402728,string,"sequence op (%s) attempted (use sq_%s?)\n"}
symtab[495]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,227/#00402730,string,"unrecognised c_func return type\n"}
symtab[496]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,228/#00402738,string,"call_backs cannot have optional parameters\n"}
symtab[497]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,229/#00402740,string,"sequence op (mul) attempted (use sq_mul?)\n"}
symtab[498]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,230/#00402748,string,"sequence op (remainder) attempted (use sq_remainder?)\n"}
symtab[499]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,231/#00402750,string,"sequence op (floor) attempted (use sq_floor?)\n"}
symtab[500]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,232/#00402758,string,"invalid match start index\n"}
symtab[501]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,233/#00402760,string,"invalid find start index\n"}
symtab[502]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,234/#00402768,string,"invalid mem_copy length\n"}
symtab[503]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,235/#00402770,string,"invalid mem_set length\n"}
symtab[504]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,236/#00402778,string,"invalid mem_copy memory address\n"}
symtab[505]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,237/#00402780,string,"invalid mem_set memory address\n"}
symtab[506]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,238/#00402788,string,"invalid argument type for integer := peek()\n"}
symtab[507]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,239/#00402790,string,"argument to rand() must be >= 1\n"}
symtab[508]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,240/#00402798,string,"argument to %s() must be an atom (use sq_%s?)\n"}
symtab[509]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,241/#004027A0,string,"argument to set_rand() must be an atom\n"}
symtab[510]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,242/#004027A8,string,"fatal exception %s at #%08x\n"}
symtab[511]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,243/#004027B0,string,"memory corruption: eax is #%08x, edx is #%08x\n"}
symtab[512]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,244/#004027B8,string,"heap corruption [era=%08x, edi=%08x]\n"}
symtab[513]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,245/#004027C0,string,"argument to arctan() must be atom (use sq_arctan?)\n"}
symtab[514]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,246/#004027C8,string,"power() function underflow\n"}
symtab[515]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,247/#004027D0,string,"power() function overflow\n"}
symtab[516]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,248/#004027D8,string,"length of an atom is not defined\n"}
symtab[517]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,249/#004027E0,string,"argument to allocate() must be positive integer\n"}
symtab[518]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,250/#004027E8,string,"argument to free() must be an atom\n"}
symtab[519]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,251/#004027F0,string,"arguments to mem_copy() must be atoms\n"}
symtab[520]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,252/#004027F8,string,"arguments to mem_set() must be atoms\n"}
symtab[521]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,253/#00402800,string,"first argument to poke() must be atom\n"}
symtab[522]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,254/#00402808,string,"first argument to poke4() must be atom\n"}
symtab[523]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,255/#00402810,string,"argument to peek() must be atom or sequence of two atoms\n"}
symtab[524]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,256/#00402818,string,"argument to peek4s() must be atom or sequence of two atoms\n"}
symtab[525]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,257/#00402820,string,"argument to peek4u() must be atom or sequence of two atoms\n"}
symtab[526]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,258/#00402828,string,"argument to float32_to_atom() must be sequence of length 4\n"}
symtab[527]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,259/#00402830,string,"argument to float64_to_atom() must be sequence of length 8\n"}
symtab[528]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,260/#00402838,string,"argument to atom_to_float32() must be atom\n"}
symtab[529]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,261/#00402840,string,"argument to atom_to_float64() must be atom\n"}
symtab[530]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,262/#00402848,string,"HeapFree error code [%08x]\n"}
symtab[531]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,263/#00402850,string,"repeat count must be non negative integer\n"}
symtab[532]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,264/#00402858,string,"attempt to raise negative number to non-integer power\n"}
symtab[533]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,265/#00402860,string,"invalid file name\n"}
symtab[534]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,266/#00402868,string,"invalid file number (%d)\n"}
symtab[535]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,267/#00402870,string,"wrong file mode for attempted operation\n"}
symtab[536]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,268/#00402878,string,"file number is not an integer\n"}
symtab[537]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,269/#00402880,string,"invalid open mode\n"}
symtab[538]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,270/#00402888,string,"file number %d is not open\n"}
symtab[539]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,271/#00402890,string,"second parameter of seek() must be an atom\n"}
symtab[540]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,272/#00402898,string,"seek fail on open append\n"}
symtab[541]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,273/#004028A0,string,"sequence found in character string\n"}
symtab[542]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,274/#004028A8,string,"invalid lock type\n"}
symtab[543]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,275/#004028B0,string,"byterange must be {} or pair of atoms\n"}
symtab[544]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,276/#004028B8,string,"error in format string\n"}
symtab[545]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,277/#004028C0,string,"insufficient values for (s)printf()\n"}
symtab[546]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,278/#004028C8,string,"invalid routine_id(%d)\n"}
symtab[547]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,279/#004028D0,string,"argument to open_dll() must be string\n"}
symtab[548]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,280/#004028D8,string,"define_c_func/proc parameter error\n"}
symtab[549]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,281/#004028E0,string,"call back routine parameters must all be atoms\n"}
symtab[550]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,282/#004028E8,string,"%c requires an atom value\n"}
symtab[551]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,283/#004028F0,string,"program has run out of memory\n"}
symtab[552]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,284/#004028F8,string,"attempt to get_text() >1GB file\n"}
symtab[553]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,285/#00402900,string,"argument to rand() must be an atom\n"}
symtab[554]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,286/#00402908,string,"insufficient parameters in call_func/proc()\n"}
symtab[555]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,287/#00402910,string,"argument to call() must be atom\n"}
symtab[556]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,288/#00402918,string,"arguments to position() must be integer\n"}
symtab[557]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,289/#00402920,string,"call_back parameter must be routine_id or {\'+\',routine_id}\n"}
symtab[558]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,290/#00402928,string,"argument to trace() must be integer 0..3\n"}
symtab[559]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,291/#00402930,string,"abort() code must be integer\n"}
symtab[560]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,292/#00402938,string,"arguments to c_func() must be atoms or strings\n"}
symtab[561]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,293/#00402940,string,"too many parameters in call_func/proc()\n"}
symtab[562]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,294/#00402948,string,"argument to profile() must be 0 or 1\n"}
symtab[563]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,295/#00402950,string,"variable %s has not been assigned a value\n"}
symtab[564]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,296/#00402958,string,"text_color error [%08x]\n"}
symtab[565]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,297/#00402960,string,"bk_color error [%08x]\n"}
symtab[566]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,298/#00402968,string,"heap error [%s]\n"}
symtab[567]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,299/#00402970,string,"flush error [%s]\n"}
symtab[568]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,300/#00402978,string,"invalid peek memory address\n"}
symtab[569]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,301/#00402980,string,"invalid poke memory address\n"}
symtab[570]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,302/#00402988,string,"attempt to allocate string of negative length\n"}
symtab[571]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,303/#00402990,string,"attempt to raise 0 to power <= 0\n"}
symtab[572]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,304/#00402998,string,"attempt to get remainder of a number divided by 0\n"}
symtab[573]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,305/#004029A0,string,"call back error?\n"}
symtab[574]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,306/#004029A8,string,"not enough format strings to print data\n"}
symtab[575]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,307/#004029B0,string,"index %d out of bounds, reading sequence length %d\n"}
symtab[576]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,308/#004029B8,string,"position error [%s]\n"}
symtab[577]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,309/#004029C0,string,"clear_screen error\n"}
symtab[578]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,310/#004029C8,string,"bitwise operations are limited to 32-bit numbers\n"}
symtab[579]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,311/#004029D0,string,"second argument of find() must be a sequence\n"}
symtab[580]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,312/#004029D8,string,"second argument of match() must be a sequence\n"}
symtab[581]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,313/#004029E0,string,"sequence to be poked must only contain atoms\n"}
symtab[582]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,314/#004029E8,string,"argument to sleep() must be atom\n"}
symtab[583]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,315/#004029F0,string,"routine requires %d parameters, not %d\n"}
symtab[584]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,316/#004029F8,string,"routine does not return a value\n"}
symtab[585]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,317/#00402A00,string,"routine returns a value\n"}
symtab[586]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,318/#00402A08,string,"file number is not an integer or {fn,c}\n"}
symtab[587]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,319/#00402A10,string,"for loop error, %s is %s\n"}
symtab[588]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,320/#00402A18,string,"for loop error, limit is %s, step is %s\n"}
symtab[589]:{msgs,S_Const,2,(S_used+S_set+K_sqr+K_noclr+K_lit),0,321/#00402A20,T_Dsq,{"type check failure, %s is %s\n", "attempt to divide by 0\n",
 "true/false condition must be an ATOM\n", "attempt to subscript an atom\n",
 "subscript is not an atom\n",
 "index %d out of bounds, assigning to sequence length %d\n",
 "slice start is less than 1 (%d)\n", "slice end is not an integer\n",
 "slice length is negative [%d..%d]\n",
 "slice starts past end of sequence (%d > %d)\n",
 "slice ends past end of sequence (%d > %d)\n", "program aborted\n",
 "attempt to exit a function without returning a value\n",
 "sequence op (%s) attempted (use sq_%s?)\n",
 "unrecognised c_func return type\n",
 "call_backs cannot have optional parameters\n",
 "sequence op (mul) attempted (use sq_mul?)\n",
 "sequence op (remainder) attempted (use sq_remainder?)\n",
 "sequence op (floor) attempted (use sq_floor?)\n",
 "invalid match start index\n", "invalid find start index\n",
 "invalid mem_copy length\n", "invalid mem_set length\n",
 "invalid mem_copy memory address\n", "invalid mem_set memory address\n",
 "invalid argument type for integer := peek()\n",
 "argument to rand() must be >= 1\n",
 "argument to %s() must be an atom (use sq_%s?)\n",
 "argument to set_rand() must be an atom\n",
 "fatal exception %s at #%08x\n",
 "memory corruption: eax is #%08x, edx is #%08x\n",
 "heap corruption [era=%08x, edi=%08x]\n",
 "argument to arctan() must be atom (use sq_arctan?)\n",
 "power() function underflow\n", "power() function overflow\n",
 "length of an atom is not defined\n",
 "argument to allocate() must be positive integer\n",
 "argument to free() must be an atom\n",
 "arguments to mem_copy() must be atoms\n",
 "arguments to mem_set() must be atoms\n",
 "first argument to poke() must be atom\n",
 "first argument to poke4() must be atom\n",
 "argument to peek() must be atom or sequence of two atoms\n",
 "argument to peek4s() must be atom or sequence of two atoms\n",
 "argument to peek4u() must be atom or sequence of two atoms\n",
 "argument to float32_to_atom() must be sequence of length 4\n",
 "argument to float64_to_atom() must be sequence of length 8\n", -1,
 "argument to atom_to_float32() must be atom\n",
 "argument to atom_to_float64() must be atom\n",
 "HeapFree error code [%08x]\n",
 "repeat count must be non negative integer\n", -1,
 "attempt to raise negative number to non-integer power\n", -1,-1,
 "invalid file name\n", "invalid file number (%d)\n",
 "wrong file mode for attempted operation\n",
 "file number is not an integer\n", "invalid open mode\n",
 "file number %d is not open\n",
 "second parameter of seek() must be an atom\n",
 "seek fail on open append\n", "sequence found in character string\n",
 "invalid lock type\n", "byterange must be {} or pair of atoms\n", -1,
 "error in format string\n", "insufficient values for (s)printf()\n", -1,
 "invalid routine_id(%d)\n", "argument to open_dll() must be string\n",
 "define_c_func/proc parameter error\n",
 "call back routine parameters must all be atoms\n",
 "%c requires an atom value\n", "program has run out of memory\n",
 "attempt to get_text() >1GB file\n",
 "argument to rand() must be an atom\n", -1,
 "insufficient parameters in call_func/proc()\n",
 "argument to call() must be atom\n",
 "arguments to position() must be integer\n",
 "call_back parameter must be routine_id or {\'+\',routine_id}\n", -1,
 "argument to trace() must be integer 0..3\n",
 "abort() code must be integer\n",
 "arguments to c_func() must be atoms or strings\n",
 "too many parameters in call_func/proc()\n",
 "argument to profile() must be 0 or 1\n",
 "variable %s has not been assigned a value\n",
 "variable %s has not been assigned a value\n",
 "variable %s has not been assigned a value\n",
 "variable %s has not been assigned a value\n", "text_color error [%08x]\n",
 "bk_color error [%08x]\n", "heap error [%s]\n", "flush error [%s]\n",
 "invalid peek memory address\n", "invalid poke memory address\n",
 "attempt to allocate string of negative length\n",
 "attempt to raise 0 to power <= 0\n",
 "attempt to get remainder of a number divided by 0\n",
 "call back error?\n", "not enough format strings to print data\n",
 "index %d out of bounds, reading sequence length %d\n", -1,
 "position error [%s]\n", "clear_screen error\n",
 "type check failure, %s is %s\n",
 "bitwise operations are limited to 32-bit numbers\n",
 "second argument of find() must be a sequence\n",
 "second argument of match() must be a sequence\n",
 "sequence to be poked must only contain atoms\n",
 "argument to sleep() must be atom\n",
 "routine requires %d parameters, not %d\n",
 "routine does not return a value\n", "routine returns a value\n",
 "file number is not an integer or {fn,c}\n", "for loop error, %s is %s\n",
 "for loop error, limit is %s, step is %s\n", -1}}
symtab[590]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,322/#00402A28,string,"type"}
symtab[591]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,323/#00402A30,string,"function"}
symtab[592]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,324/#00402A38,string,"procedure"}
symtab[593]:{rtndescs,S_Const,2,(S_used+S_set+K_sqr+K_noclr+K_lit),0,325/#00402A40,T_Dsq,{"type", "function", "procedure"}}
symtab[594]:{S_Name,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,326/#00402A48,integer,1}
symtab[595]:{S_NTyp,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,327/#00402A50,integer,2}
symtab[596]:{S_FPno,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,328/#00402A58,integer,3}
symtab[597]:{S_State,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,329/#00402A60,integer,4}
symtab[598]:{S_Slink,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,330/#00402A68,integer,6}
symtab[599]:{S_Tidx,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,331/#00402A70,integer,9}
symtab[600]:{S_Parm1,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,332/#00402A78,integer,8}
symtab[601]:{S_il,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,333/#00402A80,integer,11}
symtab[602]:{S_ltab,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,334/#00402A88,integer,12}
symtab[603]:{S_1stl,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,335/#00402A90,integer,13}
symtab[604]:{S_GVar2,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,336/#00402A98,integer,2}
symtab[605]:{S_TVar3,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,337/#00402AA0,integer,3}
symtab[606]:{S_Type,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,338/#00402AA8,integer,6}
symtab[607]:{K_wdb,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,339/#00402AB0,integer,256}
symtab[608]:{T_pathset,S_Const,2,(S_used+S_set+K_wdb+K_noclr+K_lit),0,340/#00402AB8,integer,16}
symtab[609]:{T_fileset,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,341/#00402AC0,integer,17}
symtab[610]:{T_cmdlnflg,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,342/#00402AC8,integer,19}
symtab[611]:{T_maintls,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,343/#00402AD0,integer,21}
symtab[612]:{T_EBP,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,344/#00402AD8,integer,22}
symtab[613]:{T_const1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,345/#00402AE0,integer,26}
symtab[614]:{or_ebp,S_GVar,2,(S_used+S_set+K_wdb),0,346/#00402AE8,integer,{atom,MININT,MAXINT,object,-1},0}
symtab[615]:{or_esp,S_GVar,2,(S_used+S_set+K_wdb),0,347/#00402AF0,atom,?,0}
symtab[616]:{xceptn,S_GVar,2,(S_used+S_set+K_wdb),0,348/#00402AF8,atom,?,0}
symtab[617]:{xcepta,S_GVar,2,(S_used+S_set+K_wdb),0,349/#00402B00,atom,?,0}
symtab[618]:{or_ecx,S_GVar,2,(S_used+S_set+K_wdb),0,350/#00402B08,atom,?,0}
symtab[619]:{or_era,S_GVar,2,(S_used+S_set+K_wdb),0,351/#00402B10,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[620]:{or_edx,S_GVar,2,(S_used+S_set+K_wdb),0,352/#00402B18,atom,?,0}
symtab[621]:{or_esi,S_GVar,2,(S_used+S_set+K_wdb),0,353/#00402B20,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[622]:{or_edi,S_GVar,2,(S_used+S_set+K_wdb),0,354/#00402B28,atom,?,0}
symtab[623]:{ds4,S_GVar,2,(S_used+S_set+K_wdb),0,355/#00402B30,integer,{object,MININT,MAXINT,object,-2},0}
symtab[624]:{-1,S_TVar,0,(S_set+K_Fres),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},(rax)}
symtab[625]:{getGvarValue,S_Func,2,(S_used+K_used+K_wdb),0,631,{70'F',1},626,1,4,#0044DD19}
symtab[626]:{gidx,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,627,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[627]:{novalue,S_TVar,2,(S_used+S_set+K_wdb),464,628,integer,?,[rsp-8]}
symtab[628]:{res,S_TVar,2,(S_used+S_set+K_wdb),309,629,object,?,[rsp-16]}
symtab[629]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-24]}
symtab[630]:{-1,S_TVar,0,(S_set+K_Fres),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},(rax)}
symtab[631]:{getTvarValue,S_Func,2,(S_used+K_used+K_wdb),0,639,{70'F',1},632,1,4,#0044DC08}
symtab[632]:{tidx,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,633,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[633]:{novalue,S_TVar,2,(S_used+S_set+K_wdb),627,634,integer,?,[rsp-8]}
symtab[634]:{res,S_TVar,2,(S_used+S_set+K_wdb),628,635,object,?,[rsp-16]}
symtab[635]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-24]}
symtab[636]:{vmax,S_GVar,2,(S_used+S_set+K_wdb+K_noclr),0,356/#00402B38,integer,{integer,MININT,MAXINT,object,-1},0}
symtab[637]:{vmap,S_GVar,2,(S_used+S_set+K_wdb),0,357/#00402B40,sequence,{T_Dsq,MININT,MAXINT,integer,-2},0}
symtab[638]:{-1,S_TVar,0,(S_set+K_Fres),0,0,object,{integer,MININT,MAXINT,object,-1},(rax)}
symtab[639]:{varIdx,S_Func,2,(S_used+K_used+K_wdb),0,668,{70'F',3,1,12},640,3,14,#0044DE2B}
symtab[640]:{addr,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),273,641,atom,{atom,MININT,MAXINT,object,-1},[rsp]}
symtab[641]:{rtn,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,642,integer,{integer,MININT,MAXINT,object,-1},[rsp-8]}
symtab[642]:{symtab,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,643,sequence,{object,MININT,MAXINT,object,-1},[rsp-16]}
symtab[643]:{gvar0,S_TVar,2,(S_used+S_set+K_wdb),0,644,integer,?,[rsp-24]}
symtab[644]:{maxgvar,S_TVar,2,(S_used+S_set+K_wdb),0,645,integer,?,[rsp-32]}
symtab[645]:{varno,S_TVar,2,(S_used+S_set+K_wdb),0,646,integer,{object,MININT,MAXINT,object,-2},[rsp-40]}
symtab[646]:{tidx,S_TVar,2,(S_used+S_set+K_wdb),632,647,integer,{atom,MININT,MAXINT,object,-1},[rsp-48]}
symtab[647]:{sr,S_TVar,2,(S_used+S_set+K_wdb),0,648,object,{object,MININT,MAXINT,object,-2},[rsp-56]}
symtab[648]:{nTyp,S_TVar,2,(S_used+S_set+K_wdb),0,649,integer,{object,MININT,MAXINT,object,-2},[rsp-64]}
symtab[649]:{-1,S_TVar,0,(S_set),0,650,atom,{atom,MININT,MAXINT,object,-1},[rsp-72]}
symtab[650]:{-1,S_TVar,0,(S_set),0,652,object,{integer,MININT,MAXINT,object,-1},[rsp-80]}
symtab[651]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,358/#00402B48,string,"bad varno(%d)\n"}
symtab[652]:{-1,S_TVar,0,(S_set),0,653,T_Dsq,{T_Dsq,MININT,MAXINT,integer,-2},[rsp-88]}
symtab[653]:{-1,S_TVar,0,(S_set),0,657,integer,{integer,0,MAXLEN,object,-1},[rsp-96]}
symtab[654]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,359/#00402B50,string,"pdiag.e/VarIdx: bad rtn(%d)\n"}
symtab[655]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,360/#00402B58,string,"pdiag.e/VarIdx:atom(symtab[%d])!\n"}
symtab[656]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,361/#00402B60,string,"pdiag.e/VarIdx:bad type(symtab[%d][S_NTyp]=%d)!\n"}
symtab[657]:{-1,S_TVar,0,(S_set),649,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-104]}
symtab[658]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,362/#00402B68,string,"pdiag.e/VarIdx:bad S_Parm1/S_link chain (varno=%d)\n"}
symtab[659]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,363/#00402B70,string,"pdiag.e:atom(symtab[%d])!\n"}
symtab[660]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,364/#00402B78,string,"pdiag.e/VarIdx:bad type(symtab[%d][S_NTyp](%d)!=S_TVar3)\n"}
symtab[661]:{cmp_eax_imm32,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,365/#00402B80,integer,61'='}
symtab[662]:{crashfile,S_GVar,2,(S_used+K_wdb+K_noclr),0,366/#00402B88,object,?,0}
symtab[663]:{diaglooping,S_GVar,2,(S_used+S_set+K_wdb+K_noclr),0,367/#00402B90,integer,{atom,MININT,MAXINT,object,-1},0}
symtab[664]:{ecode,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,368/#00402B98,string,"diag looping, error code is "}
symtab[665]:{erais,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,369/#00402BA0,string,", era is #"}
symtab[666]:{msg_id,S_GVar,2,(S_used+S_set+K_wdb+K_noclr),0,370/#00402BA8,integer,{atom,MININT,MAXINT,object,-1},0}
symtab[667]:{-1,S_TVar,0,(S_set+K_Fres),0,0,string,{string,MININT,MAXINT,integer,-2},(rax)}
symtab[668]:{addrS,S_Func,2,(S_used+K_used+K_wdb),0,672,{70'F',3},669,1,1,#004519B7}
symtab[669]:{a,S_TVar,2,(S_used+S_set+K_used+K_wdb+K_othr),0,0,atom,{atom,MININT,MAXINT,object,-1},[rsp]}
symtab[670]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,371/#00402BB0,string,"%08x"}
symtab[671]:{rbldrqd,S_GVar,2,(S_used+S_set+K_wdb+K_noclr),0,372/#00402BB8,integer,{integer,0,1,object,-1},1}
symtab[672]:{diag,S_Proc,2,(S_used+K_used+K_wdb),0,845,P,673,0,76,#004439B9}
symtab[673]:{symtab,S_TVar,2,(S_used+S_set+K_wdb),642,674,object,?,[rsp]}
symtab[674]:{si,S_TVar,2,(S_used+S_set+K_wdb),0,675,object,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[675]:{sp,S_TVar,2,(S_used+S_set+K_wdb),0,676,object,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[676]:{name,S_TVar,2,(S_used+S_set+K_wdb),462,677,object,{object,MININT,MAXINT,object,-2},[rsp-24]}
symtab[677]:{o,S_TVar,2,(S_used+S_set+K_wdb),463,678,object,{object,MININT,MAXINT,object,-2},[rsp-32]}
symtab[678]:{lineno,S_TVar,2,(S_used+S_set+K_wdb),0,679,integer,{integer,MININT,MAXINT,object,-1},[rsp-40]}
symtab[679]:{linenxt,S_TVar,2,(S_used+S_set+K_wdb),0,680,integer,{atom,MININT,MAXINT,object,-1},[rsp-48]}
symtab[680]:{lti,S_TVar,2,(S_used+S_set+K_wdb),0,681,integer,{atom,MININT,MAXINT,object,-1},[rsp-56]}
symtab[681]:{thisline,S_TVar,2,(S_used+S_set+K_wdb),0,682,integer,{integer,MININT,MAXINT,object,-1},[rsp-64]}
symtab[682]:{skip,S_TVar,2,(S_used+S_set+K_wdb),0,683,integer,{atom,MININT,MAXINT,object,-1},[rsp-72]}
symtab[683]:{fileno,S_TVar,2,(S_used+S_set+K_wdb),0,684,integer,{integer,MININT,MAXINT,object,-1},[rsp-80]}
symtab[684]:{fpno,S_TVar,2,(S_used+S_set+K_wdb),0,685,integer,{integer,MININT,MAXINT,object,-1},[rsp-88]}
symtab[685]:{sNTyp,S_TVar,2,(S_used+S_set+K_wdb),0,686,integer,{integer,MININT,MAXINT,object,-1},[rsp-96]}
symtab[686]:{c,S_TVar,2,(S_used+S_set+K_wdb),411,687,integer,{integer,MININT,MAXINT,object,-1},[rsp-104]}
symtab[687]:{returnoffset,S_TVar,2,(S_used+S_set+K_wdb),0,688,atom,{atom,MININT,MAXINT,object,-1},[rsp-112]}
symtab[688]:{msg,S_TVar,2,(S_used+S_set+K_wdb),0,689,sequence,{0b1001,MININT,MAXINT,integer,-2},[rsp-120]}
symtab[689]:{wmsg,S_TVar,2,(S_used+S_set+K_wdb),0,690,sequence,{string,MININT,MAXINT,integer,-2},[rsp-128]}
symtab[690]:{sr,S_TVar,2,(S_used+S_set+K_wdb),647,691,sequence,{object,MININT,MAXINT,object,-2},[rsp-136]}
symtab[691]:{linetab,S_TVar,2,(S_used+S_set+K_wdb),0,692,sequence,{object,MININT,MAXINT,object,-2},[rsp-144]}
symtab[692]:{filename,S_TVar,2,(S_used+S_set+K_wdb),0,693,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-152]}
symtab[693]:{pathset,S_TVar,2,(S_used+S_set+K_wdb),0,694,sequence,{object,MININT,MAXINT,object,-2},[rsp-160]}
symtab[694]:{x6,S_TVar,2,(S_used+S_set+K_wdb),0,695,sequence,{string,MININT,MAXINT,integer,-2},[rsp-168]}
symtab[695]:{lastline,S_TVar,2,(S_used+S_set+K_wdb),0,696,integer,{integer,MININT,MAXINT,object,-1},[rsp-176]}
symtab[696]:{base,S_TVar,2,(S_used+S_set+K_used+K_aod+K_wdb),204,697,integer,{atom,MININT,MAXINT,object,-1},[rsp-184]}
symtab[697]:{tmp,S_TVar,2,(S_used+S_set+K_wdb),215,698,integer,{integer,MININT,MAXINT,object,-1},[rsp-192]}
symtab[698]:{p,S_TVar,2,(S_used+S_set+K_wdb),0,699,integer,{object,MININT,MAXINT,object,-2},[rsp-200]}
symtab[699]:{N,S_TVar,2,(S_used+S_set+K_wdb),0,700,integer,{atom,MININT,MAXINT,object,-1},[rsp-208]}
symtab[700]:{rtn,S_TVar,2,(S_used+S_set+K_wdb),641,701,integer,{atom,MININT,MAXINT,object,-1},[rsp-216]}
symtab[701]:{from_addr,S_TVar,2,(S_used+S_set+K_wdb),0,702,atom,{atom,MININT,MAXINT,object,-1},[rsp-224]}
symtab[702]:{ret_addr,S_TVar,2,(S_used+S_set+K_wdb),0,703,atom,{atom,MININT,MAXINT,object,-1},[rsp-232]}
symtab[703]:{prev_ebp,S_TVar,2,(S_used+S_set+K_wdb),0,704,atom,{atom,MININT,MAXINT,object,-1},[rsp-240]}
symtab[704]:{ebp_root,S_TVar,2,(S_used+S_set+K_wdb),0,705,atom,{atom,MININT,MAXINT,object,-1},[rsp-248]}
symtab[705]:{vsb_prev,S_TVar,2,(S_used+S_set+K_wdb),0,706,atom,{atom,MININT,MAXINT,object,-1},[rsp-256]}
symtab[706]:{vsb_next,S_TVar,2,(S_used+S_set+K_wdb),0,707,atom,{atom,MININT,MAXINT,object,-1},[rsp-264]}
symtab[707]:{vsb_magic,S_TVar,2,(S_used+S_set+K_wdb),0,708,atom,{atom,MININT,MAXINT,object,-1},[rsp-272]}
symtab[708]:{magicok,S_TVar,2,(S_used+S_set+K_wdb),0,709,string,{string,MININT,MAXINT,integer,-2},[rsp-280]}
symtab[709]:{abortcode,S_TVar,2,(S_used+S_set+K_wdb),0,710,integer,{integer,MININT,MAXINT,object,-1},[rsp-288]}
symtab[710]:{rtype,S_TVar,2,(S_used+S_set+K_wdb),0,711,integer,{integer,1,3,object,-1},[rsp-296]}
symtab[711]:{tidx,S_TVar,2,(S_used+S_set+K_wdb),646,712,integer,{atom,MININT,MAXINT,object,-1},[rsp-304]}
symtab[712]:{varno,S_TVar,2,(S_used+S_set+K_wdb),645,713,integer,{atom,MININT,MAXINT,object,-1},[rsp-312]}
symtab[713]:{novalue,S_TVar,2,(S_used+S_set+K_wdb),633,714,integer,{object,MININT,MAXINT,object,-2},[rsp-320]}
symtab[714]:{msg2,S_TVar,2,(S_used+S_set+K_wdb),0,715,string,{string,MININT,MAXINT,integer,-2},[rsp-328]}
symtab[715]:{symtabptr,S_TVar,2,(S_used+S_set+K_wdb),0,716,atom,{atom,MININT,MAXINT,object,-1},[rsp-336]}
symtab[716]:{gvarptr,S_TVar,2,(S_used+S_set+K_wdb),0,717,atom,{atom,MININT,MAXINT,object,-1},[rsp-344]}
symtab[717]:{-1,S_TVar,0,(S_set),0,718,object,{object,MININT,MAXINT,object,-2},[rsp-352]}
symtab[718]:{-1,S_TVar,0,(S_set),0,719,integer,{integer,0,MAXLEN,object,-1},[rsp-360]}
symtab[719]:{-1,S_TVar,0,(S_set),782,720,atom,{atom,MININT,MAXINT,object,-1},[rsp-368]}
symtab[720]:{-1,S_TVar,0,(S_set),0,721,atom,{atom,MININT,MAXINT,object,-1},[rsp-376]}
symtab[721]:{-1,S_TVar,0,(S_set),0,722,T_Dsq,{T_Dsq,MININT,MAXINT,object,-2},[rsp-384]}
symtab[722]:{-1,S_TVar,0,(S_set),0,725,object,{T_Dsq,MININT,MAXINT,atom,-2},[rsp-392]}
symtab[723]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,373/#00402BC0,T_N,1079399234}
symtab[724]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,374/#00402BC8,string,"N=%d, rtn=%d, from=#%s, ret=#%s, prevebp=#%s, ebproot=#%s\n"}
symtab[725]:{-1,S_TVar,0,(S_set),726,726,string,{string,MININT,MAXINT,integer,-2},[rsp-400]}
symtab[726]:{-1,S_TVar,0,(S_set),727,727,string,{string,MININT,MAXINT,integer,-2},[rsp-408]}
symtab[727]:{-1,S_TVar,0,(S_set),728,728,string,{string,MININT,MAXINT,integer,-2},[rsp-416]}
symtab[728]:{-1,S_TVar,0,(S_set),0,734,string,{string,MININT,MAXINT,integer,-2},[rsp-424]}
symtab[729]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,375/#00402BD0,string,"or_ecx=#%08x, or_edx=#%08x, or_esi=#%08x, or_edi=#%08x\n"}
symtab[730]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,376/#00402BD8,string,#22&"@VSB"&#22}
symtab[731]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,377/#00402BE0,string,"**BAD MAGIC**"}
symtab[732]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,378/#00402BE8,string,"vsb_prev=#%s, vsb_next=#%s, vsb_magic=%s (%s)\n"}
symtab[733]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,379/#00402BF0,string,"diag(%d) [**BAD MESSAGE ID**] called\n"}
symtab[734]:{i,S_TVar,2,(S_used+S_set+S_for+K_wdb),456,735,integer,{integer,0,MAXLEN,object,-1},[rsp-432]}
symtab[735]:{-1,S_TVar,0,(S_set),0,736,object,{object,MININT,MAXINT,object,-2},[rsp-440]}
symtab[736]:{-1,S_TVar,0,(S_set),0,746,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-448]}
symtab[737]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,380/#00402BF8,integer,106'j'}
symtab[738]:{a32h4,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,381/#00402C00,T_N,1073741824}
symtab[739]:{a64h4,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,382/#00402C08,T_N,4.6116860185e+18}
symtab[740]:{-1,S_Const,2,(S_used+S_set+K_sqr+K_noclr+K_lit),0,383/#00402C10,T_Dsq,{1073741824,4.6116860185e+18}}
symtab[741]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,384/#00402C18,integer,30}
symtab[742]:{e72iri,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,385/#00402C20,integer,72'H'}
symtab[743]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,386/#00402C28,integer,131''}
symtab[744]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,387/#00402C30,integer,68'D'}
symtab[745]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,388/#00402C38,integer,199''}
symtab[746]:{-1,S_TVar,0,(S_set),0,754,integer,{integer,0,MAXLEN,object,-1},[rsp-456]}
symtab[747]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,389/#00402C40,integer,240''}
symtab[748]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,390/#00402C48,string,"#%08x"}
symtab[749]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,391/#00402C50,string,"???"}
symtab[750]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,392/#00402C58,string,"???(varno=%d[or_ecx=#%08x])"}
symtab[751]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,393/#00402C60,string,"???(atom(symtab[%d]))"}
symtab[752]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,394/#00402C68,string,"???(symtab[%d][S_name]=%d)"}
symtab[753]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,395/#00402C70,string,"???(symtab[%d] wrong type)"}
symtab[754]:{-1,S_TVar,0,(S_set),0,756,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-464]}
symtab[755]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,396/#00402C78,integer,50'2'}
symtab[756]:{-1,S_TVar,0,(S_set),0,765,T_Dsq,{T_Dsq,MININT,MAXINT,object,-2},[rsp-472]}
symtab[757]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,397/#00402C80,integer,91'['}
symtab[758]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,398/#00402C88,integer,93']'}
symtab[759]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,399/#00402C90,integer,94'^'}
symtab[760]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,400/#00402C98,string,"???(varno=%d)"}
symtab[761]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,401/#00402CA0,integer,120'x'}
symtab[762]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,402/#00402CA8,string,"init"}
symtab[763]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,403/#00402CB0,string,"limit"}
symtab[764]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,404/#00402CB8,string,"step"}
symtab[765]:{-1,S_TVar,0,(S_set),0,767,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-480]}
symtab[766]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,405/#00402CC0,integer,55'7'}
symtab[767]:{-1,S_TVar,0,(S_set),0,776,T_Dsq,{T_Dsq,MININT,MAXINT,object,-2},[rsp-488]}
symtab[768]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,406/#00402CC8,string,"slice end(%d) less than negative length(%d)\n"}
symtab[769]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,407/#00402CD0,string,"NUL"}
symtab[770]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,408/#00402CD8,string,"NULL"}
symtab[771]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,409/#00402CE0,string,"/dev/null"}
symtab[772]:{-1,S_Const,2,(S_used+S_set+K_sqr+K_noclr+K_lit),0,410/#00402CE8,T_Dsq,{"NUL", "NULL", "/dev/null"}}
symtab[773]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,411/#00402CF0,string,"w"}
symtab[774]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,412/#00402CF8,string,"ex.err"}
symtab[775]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,413/#00402D00,string,"diag.e: oops, rtn[=%d] out of range[1..%d]\n"}
symtab[776]:{i,S_TVar,2,(S_used+S_set+S_for+K_wdb),734,779,integer,{integer,0,MAXLEN,object,-1},[rsp-496]}
symtab[777]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,414/#00402D08,integer,127''}
symtab[778]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,415/#00402D10,integer,129''}
symtab[779]:{-1,S_TVar,0,(S_set),0,782,integer,{integer,0,805306372,object,-1},[rsp-504]}
symtab[780]:{-1,S_Const,2,(S_set+K_noclr+K_lit),0,416/#00402D18,integer,32767}
symtab[781]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,417/#00402D20,integer,16777216}
symtab[782]:{-1,S_TVar,0,(S_set),720,784,atom,{atom,MININT,MAXINT,object,-1},[rsp-512]}
symtab[783]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,418/#00402D28,T_N,4294967296}
symtab[784]:{i,S_TVar,2,(S_used+S_set+S_for+K_wdb),776,787,integer,{integer,0,MAXLEN,object,-1},[rsp-520]}
symtab[785]:{-1,S_Const,2,(S_used+S_set+K_sqr+K_noclr+K_lit),0,419/#00402D30,T_Dsq,{92'\',30}}
symtab[786]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,420/#00402D38,string,"  (warning: lineno of -1 for era of #%08x)\n"}
symtab[787]:{-1,S_TVar,0,(S_set),735,790,object,{object,MININT,MAXINT,object,-2},[rsp-528]}
symtab[788]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,421/#00402D40,string,"%s%s:%d"}
symtab[789]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,422/#00402D48,string," in %s %s()\n"}
symtab[790]:{-1,S_TVar,0,(S_set),0,791,integer,?,[rsp-536]}
symtab[791]:{-1,S_TVar,0,(S_set),0,795,integer,{integer,0,MAXLEN,object,-1},[rsp-544]}
symtab[792]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,423/#00402D50,string,"oops, p(%d) out of bounds(1..%d), pdiagN.e line 2049\n"}
symtab[793]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,424/#00402D58,string,"oops, atom(symtab[%d]), pdiagN.e line 2056\n"}
symtab[794]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,425/#00402D60,string,"%d[!!]"}
symtab[795]:{-1,S_TVar,0,(S_set),0,797,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-552]}
symtab[796]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,426/#00402D68,string,"diag.e: symtab[%d] bad S_NTyp[%d]\n"}
symtab[797]:{-1,S_TVar,0,(S_set),0,803,T_Dsq,{T_Dsq,MININT,MAXINT,object,2},[rsp-560]}
symtab[798]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,427/#00402D70,string,"(^^^) call_back from Windows/dll/asm\n"}
symtab[799]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,428/#00402D78,string,"diag.e: oops, lineno=-1/e92/not retD(), era=#%08x\n"}
symtab[800]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,429/#00402D80,string,"... called from "}
symtab[801]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,430/#00402D88,string,"\nGlobal & Local Variables\n"}
symtab[802]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,431/#00402D90,integer,27}
symtab[803]:{i,S_TVar,2,(S_used+S_set+S_for+K_wdb),784,804,integer,{integer,0,MAXLEN,object,-1},[rsp-568]}
symtab[804]:{-1,S_TVar,0,(S_set),0,805,integer,{integer,0,65791,object,-1},[rsp-576]}
symtab[805]:{-1,S_TVar,0,(S_set),735,808,object,{object,MININT,MAXINT,object,-2},[rsp-584]}
symtab[806]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,432/#00402D98,string,"\n %s%s:\n"}
symtab[807]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,433/#00402DA0,string,"    %s = <novalue>\n"}
symtab[808]:{-1,S_TVar,0,(S_set),0,811,T_Dsq,{T_Dsq,MININT,MAXINT,sequence,1},[rsp-592]}
symtab[809]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,434/#00402DA8,string,"--> see "}
symtab[810]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,435/#00402DB0,string,"\\ex.err\n"}
symtab[811]:{-1,S_TVar,0,(S_set),736,0,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-600]}
symtab[812]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,436/#00402DB8,integer,-9}
symtab[813]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,437/#00402DC0,string,"Press Enter..."}
symtab[814]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,438/#00402DC8,string,"error code %d, or_era=#%08x, or_ebp=#%08x, or_esp=#%08x\n"}
symtab[815]:{-1,S_GVar,0,(S_set),0,439/#00402DD0,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[816]:{-1,S_GVar,0,(S_set),0,440/#00402DD8,T_Dsq,{T_Dsq,MININT,MAXINT,atom,4},0}
symtab[817]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,441/#00402DE0,string,"exception #%08x at #%08x, or_era=#%08x, or_ebp=#%08x, or_esp=#%08x\n"}
symtab[818]:{-1,S_GVar,0,(S_set),0,442/#00402DE8,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[819]:{-1,S_GVar,0,(S_set),0,443/#00402DF0,T_Dsq,{T_Dsq,MININT,MAXINT,atom,5},0}
symtab[820]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,444/#00402DF8,string,"stack(#%08x): %08x, %08x, %08x, %08x\n"}
symtab[821]:{-1,S_GVar,0,(S_set),0,445/#00402E00,T_Dsq,{T_Dsq,MININT,MAXINT,atom,2},0}
symtab[822]:{-1,S_GVar,0,(S_set),0,446/#00402E08,object,{T_Dsq,MININT,MAXINT,atom,-2},0}
symtab[823]:{-1,S_GVar,0,(S_set),0,447/#00402E10,sequence,{T_Dsq,MININT,MAXINT,object,-2},0}
symtab[824]:{-1,S_GVar,0,(S_set),0,448/#00402E18,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[825]:{-1,S_GVar,0,(S_set),0,449/#00402E20,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[826]:{-1,S_GVar,0,(S_set),0,450/#00402E28,T_Dsq,{T_Dsq,MININT,MAXINT,atom,2},0}
symtab[827]:{-1,S_GVar,0,(S_set),0,451/#00402E30,object,{T_Dsq,MININT,MAXINT,atom,-2},0}
symtab[828]:{-1,S_GVar,0,(S_set),0,452/#00402E38,sequence,{T_Dsq,MININT,MAXINT,object,-2},0}
symtab[829]:{-1,S_GVar,0,(S_set),0,453/#00402E40,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[830]:{-1,S_GVar,0,(S_set),0,454/#00402E48,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[831]:{-1,S_GVar,0,(S_set),0,455/#00402E50,T_Dsq,{T_Dsq,MININT,MAXINT,atom,2},0}
symtab[832]:{-1,S_GVar,0,(S_set),0,456/#00402E58,object,{T_Dsq,MININT,MAXINT,atom,-2},0}
symtab[833]:{-1,S_GVar,0,(S_set),0,457/#00402E60,sequence,{T_Dsq,MININT,MAXINT,object,-2},0}
symtab[834]:{-1,S_GVar,0,(S_set),0,458/#00402E68,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[835]:{-1,S_GVar,0,(S_set),0,459/#00402E70,atom,{atom,MININT,MAXINT,object,-1},0}
symtab[836]:{-1,S_GVar,0,(S_set),0,460/#00402E78,T_Dsq,{T_Dsq,MININT,MAXINT,atom,2},0}
symtab[837]:{-1,S_GVar,0,(S_set),0,461/#00402E80,object,{T_Dsq,MININT,MAXINT,atom,-2},0}
symtab[838]:{-1,S_GVar,0,(S_set),0,462/#00402E88,sequence,{T_Dsq,MININT,MAXINT,object,-2},0}
symtab[839]:{-1,S_Const,2,(S_used+S_set+K_noclr+K_lit),0,463/#00402E90,string,"uh? (pdiagN.e line 3496)\n"}
symtab[840]:{i1,S_GVar,1,(S_used+S_set+K_wdb),0,464/#00402E98,integer,{integer,1,1,object,-1},0}
symtab[841]:{j2,S_GVar,1,(S_used+S_set+K_wdb),0,465/#00402EA0,integer,{integer,2,2,object,-1},0}
symtab[842]:{k3,S_GVar,1,(S_used+S_set+K_wdb),0,466/#00402EA8,integer,{integer,3,3,object,-1},0}
symtab[843]:{l4,S_GVar,1,(S_used+S_set+K_wdb),0,467/#00402EB0,integer,{integer,4,4,object,-1},0}
symtab[844]:{m5,S_GVar,1,(S_used+S_set+K_wdb),0,468/#00402EB8,integer,{integer,5,5,object,-1},0}
symtab[845]:{<tls>,S_Proc,12,(S_used+K_used+K_wdb),0,846,P,0,0,0,#004427EA}
symtab[846]:{<tls>,S_Proc,13,(S_used+K_used+K_wdb),0,856,P,0,0,0,#00442613}
symtab[847]:{ecode,S_Const,13,(S_used+S_set+K_noclr+K_lit),1333,469/#00402EC0,string,"exception code #"}
symtab[848]:{eat,S_Const,13,(S_used+S_set+K_noclr+K_lit),0,470/#00402EC8,string," at #"}
symtab[849]:{eaxis,S_Const,13,(S_used+S_set+K_noclr+K_lit),0,471/#00402ED0,string,"eax: "}
symtab[850]:{ebxis,S_Const,13,(S_used+S_set+K_noclr+K_lit),0,472/#00402ED8,string,"ebx: "}
symtab[851]:{ecxis,S_Const,13,(S_used+S_set+K_noclr+K_lit),0,473/#00402EE0,string,"ecx: "}
symtab[852]:{edxis,S_Const,13,(S_used+S_set+K_noclr+K_lit),0,474/#00402EE8,string,"edx: "}
symtab[853]:{esiis,S_Const,13,(S_used+S_set+K_noclr+K_lit),0,475/#00402EF0,string,"esi: "}
symtab[854]:{ediis,S_Const,13,(S_used+S_set+K_noclr+K_lit),0,476/#00402EF8,string,"edi: "}
symtab[855]:{finit,S_GVar,13,(S_used+S_set+K_wdb+K_noclr),0,477/#00402F00,integer,0}
symtab[856]:{<tls>,S_Proc,14,(S_used+K_used+K_wdb),0,862,P,0,0,0,#00441787}
symtab[857]:{pGtcb,S_GVar,14,(S_used+S_set+K_wdb+K_noclr),0,478/#00402F08,integer,0}
symtab[858]:{stdcs,S_GVar,14,(S_used+S_set+K_wdb+K_noclr),0,479/#00402F10,integer,0}
symtab[859]:{pArg,S_GVar,12,(S_used+S_set+K_wdb+K_noclr),0,480/#00402F18,integer,0}
symtab[860]:{nocleanup,S_GVar,12,(S_used+S_set+K_wdb+K_noclr),0,481/#00402F20,integer,0}
symtab[861]:{CClean,S_GVar,12,(S_used+S_set+K_wdb+K_noclr),0,482/#00402F28,integer,0}
symtab[862]:{<tls>,S_Proc,15,(S_used+K_used+K_wdb),0,863,P,0,0,0,#00441581}
symtab[863]:{<tls>,S_Proc,16,(S_used+K_used+K_wdb),0,864,P,0,0,0,#004413B8}
symtab[864]:{<tls>,S_Proc,17,(S_used+K_used+K_wdb),0,871,P,0,0,0,#00441319}
symtab[865]:{near53,S_GVar,17,(S_used+S_set+K_wdb+K_noclr),0,483/#00402F30,integer,0}
symtab[866]:{down53,S_GVar,17,(S_used+S_set+K_wdb+K_noclr),0,484/#00402F38,integer,0}
symtab[867]:{trunc53,S_GVar,17,(S_used+S_set+K_wdb+K_noclr),0,485/#00402F40,integer,0}
symtab[868]:{near64,S_GVar,17,(S_used+S_set+K_wdb+K_noclr),0,486/#00402F48,integer,0}
symtab[869]:{down64,S_GVar,17,(S_used+S_set+K_wdb+K_noclr),0,487/#00402F50,integer,0}
symtab[870]:{trunc64,S_GVar,17,(S_used+S_set+K_wdb+K_noclr),0,488/#00402F58,integer,0}
symtab[871]:{<tls>,S_Proc,18,(S_used+K_used+K_wdb),0,872,P,0,0,0,#00440F15}
symtab[872]:{<tls>,S_Proc,19,(S_used+K_used+K_wdb),0,874,P,0,0,0,#00440ABD}
symtab[873]:{-1,S_TVar,0,(S_set+K_noclr+K_Fres),0,0,integer,{integer,3,3,object,-1},(rax)}
symtab[874]:{f3,S_Func,1,(S_used+K_used+K_wdb),0,875,F,0,0,0,#0043AFCF}
symtab[875]:{<tls>,S_Proc,20,(S_used+K_used+K_wdb),0,877,P,0,0,0,#0044050D}
symtab[876]:{-1,S_TVar,0,(S_set+K_noclr+K_Fres),0,0,integer,{integer,4,4,object,-1},(rax)}
symtab[877]:{f4,S_Func,1,(S_used+K_used+K_wdb),0,878,F,0,0,0,#0043AFDB}
symtab[878]:{<tls>,S_Proc,21,(S_used+K_used+K_wdb),0,880,P,0,0,0,#004404B8}
symtab[879]:{-1,S_TVar,0,(S_set+K_noclr+K_Fres),0,0,integer,{integer,5,5,object,-1},(rax)}
symtab[880]:{f5,S_Func,1,(S_used+K_used+K_wdb),0,881,F,0,0,0,#0043AFE7}
symtab[881]:{<tls>,S_Proc,22,(S_used+K_used+K_wdb),0,882,P,0,0,0,#0043FC0F}
symtab[882]:{Abort,S_Proc,1,(S_used+K_used+K_wdb),0,885,{80'P',12},883,1,2,#0043AFF8}
symtab[883]:{msg,S_TVar,1,(S_used+S_set+K_used+K_wdb+K_othr),688,884,sequence,{string,MININT,MAXINT,integer,6},[rsp]}
symtab[884]:{-1,S_TVar,0,(S_set),0,0,integer,{integer,-1,255,object,-1},[rsp-8]}
symtab[885]:{<tls>,S_Proc,23,(S_used+K_used+K_wdb),0,886,P,0,0,0,#0043F88F}
symtab[886]:{check5,S_Proc,1,(S_used+K_used+K_wdb),0,897,{80'P',1,1,1,1,1},887,5,5,#0043AFF3}
symtab[887]:{a1,S_TVar,1,(S_used+S_set+K_used+K_wdb+K_othr),0,888,integer,{integer,1,1,object,-1},[rsp]}
symtab[888]:{b2,S_TVar,1,(S_used+S_set+K_used+K_wdb+K_othr),0,889,integer,{integer,2,2,object,-1},[rsp-8]}
symtab[889]:{c3,S_TVar,1,(S_used+S_set+K_used+K_wdb+K_othr),0,890,integer,{integer,3,3,object,-1},[rsp-16]}
symtab[890]:{d4,S_TVar,1,(S_used+S_set+K_used+K_wdb+K_othr),0,891,integer,{integer,4,4,object,-1},[rsp-24]}
symtab[891]:{e5,S_TVar,1,(S_used+S_set+K_used+K_wdb+K_othr),0,0,integer,{integer,5,5,object,-1},[rsp-32]}
symtab[892]:{-1,S_Const,1,(S_set+K_noclr+K_lit),0,489/#00402F60,string,"a1!=1\n"}
symtab[893]:{-1,S_Const,1,(S_set+K_noclr+K_lit),0,490/#00402F68,string,"b2!=2\n"}
symtab[894]:{-1,S_Const,1,(S_set+K_noclr+K_lit),0,491/#00402F70,string,"c3!=3\n"}
symtab[895]:{-1,S_Const,1,(S_set+K_noclr+K_lit),0,492/#00402F78,string,"d4!=4\n"}
symtab[896]:{-1,S_Const,1,(S_set+K_noclr+K_lit),0,493/#00402F80,string,"e5!=5\n"}
symtab[897]:{<tls>,S_Proc,24,(S_used+K_used+K_wdb),0,898,P,0,0,0,#0043F73D}
symtab[898]:{<tls>,S_Proc,25,(S_used+K_used+K_wdb),0,899,P,0,0,0,#0043F35A}
symtab[899]:{<tls>,S_Proc,26,(S_used+K_used+K_wdb),0,901,P,0,0,0,#0043F2CE}
symtab[900]:{half,S_Const,25,(S_used+S_set+K_noclr+K_lit),0,494/#00402F88,T_N,0.5}
symtab[901]:{<tls>,S_Proc,27,(S_used+K_used+K_wdb),0,903,P,0,0,0,#0043F288}
symtab[902]:{-1,S_GVar,0,(S_set),0,495/#00402F90,integer,{integer,5,5,object,-1},0}
symtab[903]:{<tls>,S_Proc,28,(S_used+K_used+K_wdb),0,904,P,0,0,0,#0043F1EE}
symtab[904]:{<tls>,S_Proc,29,(S_used+K_used+K_wdb),0,905,P,0,0,0,#0043ED2B}
symtab[905]:{<tls>,S_Proc,30,(S_used+K_used+K_wdb),0,967,P,0,0,0,#0043DB73}
symtab[906]:{INVALID_HANDLE_VALUE,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,496/#00402F98,integer,-1}
symtab[907]:{STD_INPUT_HANDLE,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,497/#00402FA0,integer,-10}
symtab[908]:{STD_OUTPUT_HANDLE,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,498/#00402FA8,integer,-11}
symtab[909]:{STD_ERROR_HANDLE,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,499/#00402FB0,integer,-12}
symtab[910]:{FDSIZE32,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,500/#00402FB8,integer,8192}
symtab[911]:{sizeof_CSBI,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,501/#00402FC0,integer,24}
symtab[912]:{BUFFERSIZE32,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,502/#00402FC8,integer,8168}
symtab[913]:{FDSIZE64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,503/#00402FD0,integer,8192}
symtab[914]:{BHFI_NLINK,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,504/#00402FD8,integer,40'('}
symtab[915]:{BUFFERSIZE64,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,505/#00402FE0,integer,8152}
symtab[916]:{CSBI_SIZEX,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,506/#00402FE8,integer,0}
symtab[917]:{CSBI_SIZEY,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,507/#00402FF0,integer,2}
symtab[918]:{CSBI_CPOSX,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,508/#00402FF8,integer,4}
symtab[919]:{CSBI_CPOSY,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,509/#00403000,integer,6}
symtab[920]:{CSBI_ATTR,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,510/#00403008,integer,8}
symtab[921]:{sizeof_CSBI64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,511/#00403010,integer,24}
symtab[922]:{BHFI_FSHI,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,512/#00403018,integer,32' '}
symtab[923]:{BHFI_FSLO,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,513/#00403020,integer,36'$'}
symtab[924]:{sizeof_BHFI,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,514/#00403028,integer,52'4'}
symtab[925]:{sizeof_BHFI64,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,515/#00403030,integer,56'8'}
symtab[926]:{OV_OFFSET,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,516/#00403038,integer,8}
symtab[927]:{OV_OFFHI,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,517/#00403040,integer,12}
symtab[928]:{OV_EVENT,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,518/#00403048,integer,16}
symtab[929]:{sizeof_OVERLAPPED64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,519/#00403050,integer,24}
symtab[930]:{CREATE_NEW,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,520/#00403058,integer,1}
symtab[931]:{OPEN_EXISTING,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,521/#00403060,integer,3}
symtab[932]:{OPEN_ALWAYS,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,522/#00403068,integer,4}
symtab[933]:{TRUNCATE_EXISTING,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,523/#00403070,integer,5}
symtab[934]:{GENERIC_READo4,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,524/#00403078,integer,536870912}
symtab[935]:{GENERIC_WRITEo4,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,525/#00403080,integer,268435456}
symtab[936]:{FILE_SHARE_READ,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,526/#00403088,integer,1}
symtab[937]:{FILE_SHARE_WRITE,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,527/#00403090,integer,2}
symtab[938]:{FILE_ATTRIBUTE_NORMAL,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,528/#00403098,integer,128''}
symtab[939]:{FILE_BEGIN,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,529/#004030A0,integer,0}
symtab[940]:{FILE_END,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,530/#004030A8,integer,2}
symtab[941]:{NO_ERROR,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,531/#004030B0,integer,0}
symtab[942]:{ENABLE_PROCESSED_INPUT,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,532/#004030B8,integer,1}
symtab[943]:{ENABLE_WRAP_AT_EOL_OUTPUT,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,533/#004030C0,integer,2}
symtab[944]:{fdcs,S_GVar,30,(S_used+S_set+K_wdb),0,534/#004030C8,atom,{integer,0,MAXINT,object,-1},0}
symtab[945]:{fdtbl,S_GVar,30,(S_used+S_set+K_wdb),0,535/#004030D0,sequence,{T_Dsq,MININT,MAXINT,integer,-2},0}
symtab[946]:{fdmax,S_GVar,30,(S_used+S_set+K_wdb+K_noclr),0,536/#004030D8,integer,{integer,0,MAXLEN,object,-1},0}
symtab[947]:{freelist,S_GVar,30,(S_used+S_set+K_wdb+K_noclr),0,537/#004030E0,integer,{atom,MININT,MAXINT,object,-1},0}
symtab[948]:{HNDL,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,538/#004030E8,integer,0}
symtab[949]:{MODE,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,539/#004030F0,integer,4}
symtab[950]:{POSN,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,540/#004030F8,integer,8}
symtab[951]:{FEND,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,541/#00403100,integer,12}
symtab[952]:{POSL,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,542/#00403108,integer,16}
symtab[953]:{POSH,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,543/#00403110,integer,20}
symtab[954]:{BUFF,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,544/#00403118,integer,24}
symtab[955]:{HNDL64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,545/#00403120,integer,0}
symtab[956]:{MODE64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,546/#00403128,integer,8}
symtab[957]:{POSN64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,547/#00403130,integer,16}
symtab[958]:{FEND64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,548/#00403138,integer,24}
symtab[959]:{RPOS64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,549/#00403140,integer,32' '}
symtab[960]:{BUFF64,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,550/#00403148,integer,40'('}
symtab[961]:{F_CLOSED,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,551/#00403150,integer,0}
symtab[962]:{F_READ,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,552/#00403158,integer,1}
symtab[963]:{F_WRITE,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,553/#00403160,integer,2}
symtab[964]:{F_BINARY,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,554/#00403168,integer,4}
symtab[965]:{F_DIRTY,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,555/#00403170,integer,8}
symtab[966]:{finit,S_GVar,30,(S_used+S_set+K_wdb+K_noclr),1524,556/#00403178,integer,{integer,0,1,object,-1},0}
symtab[967]:{initF,S_Proc,30,(S_used+K_used+K_wdb),0,968,P,0,0,0,#0043B5D9}
symtab[968]:{iofatal,S_Proc,30,(S_used+K_used+K_wdb),0,972,{80'P',1,1},969,1,2,#0043C328}
symtab[969]:{errcode,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,970,integer,{integer,58,59,object,-1},[rsp]}
symtab[970]:{ep1,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),0,0,integer,{integer,MININT,MAXINT,object,-1},[rsp-8]}
symtab[971]:{-1,S_TVar,0,(S_set+K_Fres),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,0b1001,2},(rax)}
symtab[972]:{toStringN,S_Func,30,(S_used+K_used+K_wdb),0,982,{70'F',12},973,1,8,#0043D9D9}
symtab[973]:{name,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),676,974,sequence,{T_Dsq,MININT,MAXINT,object,-2},[rsp]}
symtab[974]:{nlen,S_TVar,30,(S_used+S_set+K_wdb),0,975,integer,{integer,0,MAXLEN,object,-1},[rsp-8]}
symtab[975]:{ch,S_TVar,30,(S_used+S_set+K_wdb),274,976,object,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[976]:{res,S_TVar,30,(S_used+S_set+K_wdb),634,977,string,{string,MININT,MAXINT,integer,-2},[rsp-24]}
symtab[977]:{flag,S_TVar,30,(S_used+S_set+K_used+K_aod+K_wdb),0,978,integer,{integer,0,1,object,-1},[rsp-32]}
symtab[978]:{-1,S_TVar,0,(S_set),0,979,integer,{integer,0,MAXLEN,object,-1},[rsp-40]}
symtab[979]:{i,S_TVar,30,(S_used+S_set+S_for+K_wdb),803,980,integer,{integer,0,MAXLEN,object,-1},[rsp-48]}
symtab[980]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,0b1001,2},[rsp-56]}
symtab[981]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,MININT,MAXINT,object,-1},(rax)}
symtab[982]:{fopen,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1008,{70'F',12,15},983,2,15,#0043D2D5}
symtab[983]:{filepath,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),297,984,sequence,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[984]:{openmode,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,985,object,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[985]:{res,S_TVar,30,(S_used+S_set+K_wdb),976,986,integer,{0b1001,MININT,MAXINT,integer,-2},[rsp-16]}
symtab[986]:{imode,S_TVar,30,(S_used+S_set+K_wdb),0,987,integer,{integer,1,3,object,-1},[rsp-24]}
symtab[987]:{fmode,S_TVar,30,(S_used+S_set+K_wdb),0,988,integer,{integer,MININT,MAXINT,object,-1},[rsp-32]}
symtab[988]:{accessmode,S_TVar,30,(S_used+S_set+K_wdb),0,989,integer,{integer,268435456,MAXLEN,object,-1},[rsp-40]}
symtab[989]:{createmode,S_TVar,30,(S_used+S_set+K_wdb),0,990,integer,{integer,1,5,object,-1},[rsp-48]}
symtab[990]:{sharemode,S_TVar,30,(S_used+S_set+K_wdb),0,991,integer,{integer,1,3,object,-1},[rsp-56]}
symtab[991]:{fhandle,S_TVar,30,(S_used+S_set+K_wdb),0,992,atom,?,[rsp-64]}
symtab[992]:{iThis,S_TVar,30,(S_used+S_set+K_wdb),0,993,integer,{atom,MININT,MAXINT,object,-1},[rsp-72]}
symtab[993]:{-1,S_TVar,0,(S_set),0,994,integer,{integer,0,MAXLEN,object,-1},[rsp-80]}
symtab[994]:{-1,S_TVar,0,(S_set),0,996,object,{object,MININT,MAXINT,object,-2},[rsp-88]}
symtab[995]:{-1,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,557/#00403180,string,"bB"}
symtab[996]:{-1,S_TVar,0,(S_set),0,1001,T_Dsq,{T_Dsq,MININT,MAXINT,0b1001,2},[rsp-96]}
symtab[997]:{-1,S_Const,30,(S_set+K_noclr+K_lit),0,558/#00403188,integer,114'r'}
symtab[998]:{-1,S_Const,30,(S_set+K_noclr+K_lit),0,559/#00403190,integer,119'w'}
symtab[999]:{e117rdnrav,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,560/#00403198,integer,117'u'}
symtab[1000]:{-1,S_Const,30,(S_set+K_noclr+K_lit),0,561/#004031A0,integer,805306368}
symtab[1001]:{-1,S_TVar,0,(S_set),0,1002,atom,{atom,MININT,MAXINT,object,-1},[rsp-104]}
symtab[1002]:{-1,S_TVar,0,(S_set),1001,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-112]}
symtab[1003]:{stdin,S_GVar,30,(S_used+S_set+K_wdb+K_noclr),0,562/#004031A8,integer,{integer,0,0,object,-1},0}
symtab[1004]:{stdout,S_GVar,30,(S_used+S_set+K_wdb+K_noclr),0,563/#004031B0,integer,{integer,0,0,object,-1},0}
symtab[1005]:{stderr,S_GVar,30,(S_used+S_set+K_wdb),0,564/#004031B8,integer,{integer,0,0,object,-1},0}
symtab[1006]:{cinit,S_GVar,30,(S_used+S_set+K_wdb+K_noclr),881,565/#004031C0,integer,{integer,0,1,object,-1},0}
symtab[1007]:{stdin_redirected,S_GVar,30,(S_used+S_set+K_wdb+K_noclr),0,566/#004031C8,integer,0}
symtab[1008]:{initConsole,S_Proc,30,(S_used+K_used+K_wdb),0,1010,P,0,0,0,#0043B59C}
symtab[1009]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,0,1,object,-1},(rax)}
symtab[1010]:{get_this,S_Func,30,(S_used+K_used+K_wdb),0,1017,{70'F',1},1011,1,6,#0043C667}
symtab[1011]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),387,1012,integer,{integer,MININT,MAXINT,object,-1},[rsp]}
symtab[1012]:{iThis,S_TVar,30,(S_used+S_set+K_used+K_aod+K_wdb),992,1013,integer,{integer,0,1,object,-1},[rsp-8]}
symtab[1013]:{fidx,S_TVar,30,(S_used+S_set+K_wdb),197,1014,integer,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[1014]:{fmode,S_TVar,30,(S_used+S_set+K_used+K_aod+K_wdb),987,1015,integer,{atom,MININT,MAXINT,object,-1},[rsp-24]}
symtab[1015]:{-1,S_TVar,0,(S_set),0,1016,atom,{integer,0,4,object,-1},[rsp-32]}
symtab[1016]:{-1,S_TVar,0,(S_set),1015,0,atom,{integer,8,12,object,-1},[rsp-40]}
symtab[1017]:{fflush,S_Proc,30,(S_used+K_used+K_wdb+K_ridt),0,1023,{80'P',1},1018,1,5,#0043D19B}
symtab[1018]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1011,1019,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1019]:{fidx,S_TVar,30,(S_used+S_set+K_wdb),1013,1020,integer,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[1020]:{-1,S_TVar,0,(S_set),0,1021,integer,{integer,0,MAXLEN,object,-1},[rsp-16]}
symtab[1021]:{i,S_TVar,30,(S_used+S_set+S_for+K_wdb),979,1022,integer,{integer,0,MAXLEN,object,-1},[rsp-24]}
symtab[1022]:{-1,S_TVar,0,(S_set),0,0,atom,{integer,2,805306370,object,-1},[rsp-32]}
symtab[1023]:{fclose,S_Proc,30,(S_used+K_used+K_wdb+K_ridt),0,1031,{80'P',1},1024,1,6,#0043CF81}
symtab[1024]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1018,1025,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1025]:{fidx,S_TVar,30,(S_used+S_set+K_wdb),1019,1026,integer,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[1026]:{iThis,S_TVar,30,(S_used+S_set+K_wdb),1012,1027,integer,?,[rsp-16]}
symtab[1027]:{-1,S_TVar,0,(S_set),0,1028,integer,{integer,0,MAXLEN,object,-1},[rsp-24]}
symtab[1028]:{i,S_TVar,30,(S_used+S_set+S_for+K_wdb),1021,1029,integer,{integer,0,MAXLEN,object,-1},[rsp-32]}
symtab[1029]:{-1,S_TVar,0,(S_set),0,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[1030]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,0,0,object,-1},(rax)}
symtab[1031]:{fseek,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1043,{70'F',1,3},1032,2,10,#0043C978}
symtab[1032]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1024,1033,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1033]:{pos,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1034,atom,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1034]:{fidx,S_TVar,30,(S_used+S_set+K_wdb),1025,1035,integer,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[1035]:{fmode,S_TVar,30,(S_used+S_set+K_wdb),1014,1036,integer,{integer,0,1,object,-1},[rsp-24]}
symtab[1036]:{fend,S_TVar,30,(S_used+S_set+K_wdb),0,1037,integer,{atom,MININT,MAXINT,object,-1},[rsp-32]}
symtab[1037]:{workpos,S_TVar,30,(S_used+S_set+K_wdb),0,1038,atom,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[1038]:{frealposn,S_TVar,30,(S_used+S_set+K_wdb),0,1039,atom,{atom,MININT,MAXINT,object,-1},[rsp-48]}
symtab[1039]:{iThis,S_TVar,30,(S_used+S_set+K_wdb),1026,1040,integer,?,[rsp-56]}
symtab[1040]:{-1,S_TVar,0,(S_set),0,1041,atom,{atom,MININT,MAXINT,object,-1},[rsp-64]}
symtab[1041]:{-1,S_TVar,0,(S_set),1040,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-72]}
symtab[1042]:{-1,S_TVar,0,(S_set+K_Fres),0,0,atom,{atom,MININT,MAXINT,object,-1},(rax)}
symtab[1043]:{fwhere,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1048,{70'F',1},1044,1,3,#0043C84C}
symtab[1044]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1032,1045,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1045]:{fidx,S_TVar,30,(S_used+S_set+K_wdb),1034,1046,integer,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[1046]:{frealposn,S_TVar,30,(S_used+S_set+K_wdb),1038,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[1047]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,0,1,object,-1},(rax)}
symtab[1048]:{lock_type,S_Type,30,(S_used+K_wdb),0,1052,{84'T',1},1049,1,2,#0043C80A}
symtab[1049]:{t,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_type),0,1050,integer,{integer,MININT,MAXINT,object,-1},[rsp]}
symtab[1050]:{-1,S_TVar,0,(S_set),0,0,integer,{integer,0,1,object,-1},[rsp-8]}
symtab[1051]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,0,1,object,-1},(rax)}
symtab[1052]:{byte_range,S_Type,30,(S_used+K_wdb),0,1059,{84'T',12},1053,1,4,#0043C750}
symtab[1053]:{r,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_type),0,1054,sequence,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[1054]:{-1,S_TVar,0,(S_set),0,1055,integer,{integer,0,MAXLEN,object,-1},[rsp-8]}
symtab[1055]:{-1,S_TVar,0,(S_set),1056,1056,object,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[1056]:{-1,S_TVar,0,(S_set),0,0,object,{object,MININT,MAXINT,object,-2},[rsp-24]}
symtab[1057]:{UNLOCK,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,567/#004031D0,integer,0}
symtab[1058]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,MININT,MAXINT,object,-1},(rax)}
symtab[1059]:{flock,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1070,{70'F',1,1,1725},1060,3,9,#0043C42D}
symtab[1060]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1044,1061,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1061]:{locktype,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1062,integer,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1062]:{byterange,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1063,byte_range,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[1063]:{iThis,S_TVar,30,(S_used+S_set+K_wdb),1039,1064,integer,{integer,0,1,object,-1},[rsp-24]}
symtab[1064]:{offset,S_TVar,30,(S_used+S_set+K_wdb),0,1065,atom,{object,MININT,MAXINT,object,-2},[rsp-32]}
symtab[1065]:{bytes,S_TVar,30,(S_used+S_set+K_wdb),0,1066,atom,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[1066]:{res,S_TVar,30,(S_used+S_set+K_wdb),985,1067,integer,?,[rsp-48]}
symtab[1067]:{-1,S_TVar,0,(S_set),0,1068,integer,{integer,0,MAXLEN,object,-1},[rsp-56]}
symtab[1068]:{-1,S_TVar,0,(S_set),0,0,object,{object,MININT,MAXINT,object,-2},[rsp-64]}
symtab[1069]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,MININT,MAXINT,object,-1},(rax)}
symtab[1070]:{flock_file,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1075,{70'F',1,1721,1725},1071,3,3,#0043C35D}
symtab[1071]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1060,1072,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1072]:{locktype,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1061,1073,lock_type,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1073]:{byterange,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1062,0,byte_range,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[1074]:{-1,S_TVar,0,(S_set+K_Fres),0,0,sequence,{sequence,MININT,MAXINT,object,-2},(rax)}
symtab[1075]:{addline,S_Func,30,(S_used+K_used+K_wdb),0,1085,{70'F',12,1,1,1,1,8},1076,6,8,#0043C1B0}
symtab[1076]:{res,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1066,1077,sequence,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1077]:{i,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1028,1078,integer,{integer,MININT,MAXINT,object,-1},[rsp-8]}
symtab[1078]:{start,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1079,integer,{integer,MININT,MAXINT,object,-1},[rsp-16]}
symtab[1079]:{option,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1080,integer,{integer,MININT,MAXINT,object,-1},[rsp-24]}
symtab[1080]:{filesize,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1081,integer,{integer,MININT,MAXINT,object,-1},[rsp-32]}
symtab[1081]:{src,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1082,string,{string,MININT,MAXINT,integer,-2},[rsp-40]}
symtab[1082]:{oneline,S_TVar,30,(S_used+S_set+K_wdb),0,1083,sequence,{string,MININT,MAXINT,integer,-2},[rsp-48]}
symtab[1083]:{lend,S_TVar,30,(S_used+S_set+K_wdb),0,0,integer,{atom,MININT,MAXINT,object,-1},[rsp-56]}
symtab[1084]:{-1,S_TVar,0,(S_set+K_Fres),0,0,object,{object,MININT,MAXINT,object,-2},(rax)}
symtab[1085]:{fget_text,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1102,{70'F',1,1},1086,2,14,#0043BA15}
symtab[1086]:{fn,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1071,1087,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1087]:{option,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),1079,1088,integer,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1088]:{fidx,S_TVar,30,(S_used+S_set+K_wdb),1045,1089,integer,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[1089]:{ch,S_TVar,30,(S_used+S_set+K_wdb),975,1090,integer,{integer,MININT,MAXINT,object,-1},[rsp-24]}
symtab[1090]:{fmode,S_TVar,30,(S_used+S_set+K_wdb),1035,1091,integer,{integer,0,1,object,-1},[rsp-32]}
symtab[1091]:{i,S_TVar,30,(S_used+S_set+K_wdb),1077,1092,integer,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[1092]:{res,S_TVar,30,(S_used+S_set+K_wdb),1076,1093,object,{0b1101,-1,-1,object,-2},[rsp-48]}
symtab[1093]:{start,S_TVar,30,(S_used+S_set+K_wdb),1078,1094,integer,{integer,MININT,MAXINT,object,-1},[rsp-56]}
symtab[1094]:{filesize,S_TVar,30,(S_used+S_set+K_wdb),1080,1095,integer,?,[rsp-64]}
symtab[1095]:{src,S_TVar,30,(S_used+S_set+K_wdb),1081,1096,string,{string,MININT,MAXINT,integer,-2},[rsp-72]}
symtab[1096]:{iThis,S_TVar,30,(S_used+S_set+K_wdb),1063,1097,integer,?,[rsp-80]}
symtab[1097]:{-1,S_TVar,0,(S_set),1098,1098,integer,{integer,0,255,object,-1},[rsp-88]}
symtab[1098]:{-1,S_TVar,0,(S_set),0,1100,integer,{atom,MININT,MAXINT,object,-1},[rsp-96]}
symtab[1099]:{-1,S_Const,30,(S_set+K_noclr+K_lit),0,568/#004031D8,integer,59';'}
symtab[1100]:{-1,S_TVar,0,(S_set),0,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-104]}
symtab[1101]:{-1,S_TVar,0,(S_set+K_Fres),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,integer,2},(rax)}
symtab[1102]:{fget_position,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1106,F,1103,0,3,#0043B950}
symtab[1103]:{posX,S_TVar,30,(S_used+S_set+K_wdb),0,1104,integer,?,[rsp]}
symtab[1104]:{posY,S_TVar,30,(S_used+S_set+K_wdb),0,1105,integer,?,[rsp-8]}
symtab[1105]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,integer,2},[rsp-16]}
symtab[1106]:{fwrap,S_Proc,30,(S_used+K_used+K_wdb+K_ridt),0,1109,{80'P',1},1107,1,1,#0043B8AD}
symtab[1107]:{flag,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),977,0,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1108]:{-1,S_TVar,0,(S_set+K_Fres),0,0,integer,{integer,MININT,MAXINT,object,-1},(rax)}
symtab[1109]:{ftext_rows,S_Func,30,(S_used+K_used+K_wdb+K_ridt),0,1114,{70'F',1},1110,1,2,#0043B7DC}
symtab[1110]:{newrows,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1111,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1111]:{res,S_TVar,30,(S_used+S_set+K_wdb),1092,0,integer,?,[rsp-8]}
symtab[1112]:{BACKGROUNDCOLOR,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,569/#004031E0,integer,0}
symtab[1113]:{TEXTCOLOR,S_Const,30,(S_used+S_set+K_wdb+K_noclr+K_lit),0,570/#004031E8,integer,1}
symtab[1114]:{set_console_color,S_Proc,30,(S_used+K_used+K_wdb+K_ridt),0,1117,{80'P',1,1},1115,2,2,#0043B72A}
symtab[1115]:{color,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1116,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1116]:{cmode,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,0,integer,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1117]:{fclear_screen,S_Proc,30,(S_used+K_used+K_wdb+K_ridt),0,1118,P,0,0,0,#0043B676}
symtab[1118]:{ffree_console,S_Proc,30,(S_used+K_used+K_wdb+K_ridt),0,1119,P,0,0,0,#0043B63B}
symtab[1119]:{fposition,S_Proc,30,(S_used+K_used+K_wdb+K_ridt),0,1128,{80'P',1,1},1120,2,6,#0043B4A3}
symtab[1120]:{line,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1121,integer,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1121]:{col,S_TVar,30,(S_used+S_set+K_used+K_wdb+K_othr),0,1122,integer,{object,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1122]:{coord,S_TVar,30,(S_used+S_set+K_wdb),0,1123,integer,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[1123]:{-1,S_TVar,0,(S_set),1126,1125,atom,{atom,MININT,MAXINT,object,-1},[rsp-24]}
symtab[1124]:{-1,S_Const,30,(S_used+S_set+K_noclr+K_lit),0,571/#004031F0,integer,65535}
symtab[1125]:{-1,S_TVar,0,(S_set),0,1126,integer,{integer,0,65535,object,-1},[rsp-32]}
symtab[1126]:{-1,S_TVar,0,(S_set),0,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-40]}
symtab[1127]:{-1,S_GVar,0,(S_set),0,572/#004031F8,integer,{integer,5,5,object,-1},0}
symtab[1128]:{<tls>,S_Proc,31,(S_used+K_used+K_wdb),0,1130,P,0,0,0,#0043B31A}
symtab[1129]:{-1,S_GVar,0,(S_set),0,573/#00403200,integer,{integer,4,4,object,-1},0}
symtab[1130]:{<tls>,S_Proc,32,(S_used+K_used+K_wdb),0,1132,P,0,0,0,#0043B265}
symtab[1131]:{-1,S_GVar,0,(S_set),0,574/#00403208,integer,{integer,4,4,object,-1},0}
symtab[1132]:{<tls>,S_Proc,33,(S_used+K_used+K_wdb),0,1135,P,0,0,0,#0043B1DC}
symtab[1133]:{-1,S_GVar,0,(S_set),0,575/#00403210,integer,{integer,4,4,object,-1},0}
symtab[1134]:{-1,S_GVar,0,(S_set),0,576/#00403218,integer,{integer,5,5,object,-1},0}
symtab[1135]:{<tls>,S_Proc,34,(S_used+K_used+K_wdb),0,1147,P,0,0,0,#0043B152}
symtab[1136]:{ASALPHANUM,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,577/#00403220,integer,1}
symtab[1137]:{ASANY,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,578/#00403228,integer,0}
symtab[1138]:{e16cbchop,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,579/#00403230,integer,16}
symtab[1139]:{e73atodmbs,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,580/#00403238,integer,73'I'}
symtab[1140]:{e74dcfpe,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,581/#00403240,integer,74'J'}
symtab[1141]:{e75cbrpmaba,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,582/#00403248,integer,75'K'}
symtab[1142]:{e81ipicfp,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,583/#00403250,integer,81'Q'}
symtab[1143]:{e84cbpmbropr,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,584/#00403258,integer,84'T'}
symtab[1144]:{e88atcfpmbaos,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,585/#00403260,integer,88'X'}
symtab[1145]:{e89tmpicfp,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,586/#00403268,integer,89'Y'}
symtab[1146]:{e118rrav,S_Const,34,(S_used+S_set+K_noclr+K_lit),0,587/#00403270,integer,118'v'}
symtab[1147]:{fatalN,S_Proc,34,(S_used+K_used+K_wdb),0,1152,{80'P',1,1,1},1148,2,3,#0044A360}
symtab[1148]:{level,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),0,1149,integer,{integer,2,4,object,-1},[rsp]}
symtab[1149]:{errcode,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),969,1150,integer,{integer,72,118,object,-1},[rsp-8]}
symtab[1150]:{ep1,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),970,0,integer,{integer,-1,MAXLEN,object,-1},[rsp-16]}
symtab[1151]:{-1,S_TVar,0,(S_set+K_Fres),0,0,string,{string,MININT,MAXINT,integer,-2},(rax)}
symtab[1152]:{toString,S_Func,34,(S_used+K_used+K_wdb),0,1166,{70'F',12,1,1,1},1153,4,9,#0044A1D9}
symtab[1153]:{name,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),973,1154,sequence,{T_Dsq,MININT,MAXINT,object,-2},[rsp]}
symtab[1154]:{asAlphanum,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),0,1155,integer,{integer,0,1,object,-1},[rsp-8]}
symtab[1155]:{errcode,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),1149,1156,integer,{integer,73,88,object,-1},[rsp-16]}
symtab[1156]:{level,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),1148,1157,integer,{integer,3,4,object,-1},[rsp-24]}
symtab[1157]:{res,S_TVar,34,(S_used+S_set+K_wdb),1111,1158,string,{string,MININT,MAXINT,integer,-2},[rsp-32]}
symtab[1158]:{nlen,S_TVar,34,(S_used+S_set+K_wdb),974,1159,integer,{integer,0,MAXLEN,object,-1},[rsp-40]}
symtab[1159]:{ch,S_TVar,34,(S_used+S_set+K_wdb),1089,1160,object,{object,MININT,MAXINT,object,-2},[rsp-48]}
symtab[1160]:{-1,S_TVar,0,(S_set),0,1161,integer,{integer,0,MAXLEN,object,-1},[rsp-56]}
symtab[1161]:{i,S_TVar,34,(S_used+S_set+S_for+K_wdb),1091,0,integer,{integer,0,MAXLEN,object,-1},[rsp-64]}
symtab[1162]:{-1,S_Const,34,(S_set+K_noclr+K_lit),0,588/#00403278,integer,49'1'}
symtab[1163]:{-1,S_Const,34,(S_set+K_noclr+K_lit),0,589/#00403280,integer,95'_'}
symtab[1164]:{-1,S_Const,34,(S_set+K_noclr+K_lit),0,590/#00403288,integer,122'z'}
symtab[1165]:{-1,S_TVar,0,(S_set+K_Fres),0,0,atom,{atom,MININT,MAXINT,object,-1},(rax)}
symtab[1166]:{OpenOneDLL,S_Func,34,(S_used+K_used+K_wdb),0,1175,{70'F',12},1167,1,2,#0044AA22}
symtab[1167]:{filename,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),692,1168,sequence,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[1168]:{res,S_TVar,34,(S_used+S_set+K_wdb),1157,0,atom,?,[rsp-8]}
symtab[1169]:{filename,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),1167,1170,sequence,{string,MININT,MAXINT,integer,-2},[rsp]}
symtab[1170]:{res,S_TVar,34,(S_used+S_set+K_used+K_aod+K_wdb),1168,1171,atom,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[1171]:{fi,S_TVar,34,(S_used+S_set+K_wdb),196,1172,sequence,{integer,0,255,object,-1},[rsp-16]}
symtab[1172]:{-1,S_TVar,0,(S_set),0,1173,integer,{integer,0,MAXLEN,object,-1},[rsp-24]}
symtab[1173]:{-1,S_TVar,0,(S_set),0,1174,object,{integer,0,255,object,-1},[rsp-32]}
symtab[1174]:{idx,S_TVar,34,(S_used+S_set+S_for+K_wdb),0,0,integer,{integer,0,MAXLEN,object,-1},[rsp-40]}
symtab[1175]:{check,S_Proc,34,(S_used+K_used+K_wdb),0,1219,{80'P',15,1},1176,2,2,#0044A808}
symtab[1176]:{o,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),677,1177,object,{integer,MININT,MAXINT,object,-1},[rsp]}
symtab[1177]:{level,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),1156,0,integer,{integer,2,2,object,-1},[rsp-8]}
symtab[1178]:{-1,S_Const,34,(S_used+S_set+K_sqr+K_noclr+K_lit),0,591/#00403290,T_Dsq,{16777217,33554433,16777218,33554434,16777220,33554436,50331652,50331656}}
symtab[1179]:{T_name,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,592/#00403298,integer,1}
symtab[1180]:{T_address,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,593/#004032A0,integer,2}
symtab[1181]:{T_args,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,594/#004032A8,integer,3}
symtab[1182]:{T_return_type,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,595/#004032B0,integer,4}
symtab[1183]:{T_convention,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,596/#004032B8,integer,5}
symtab[1184]:{STDCALL,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,597/#004032C0,integer,1}
symtab[1185]:{CDECL,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,598/#004032C8,integer,2}
symtab[1186]:{table,S_GVar,34,(S_used+S_set+K_wdb),0,599/#004032D0,sequence,{T_Dsq,MININT,MAXINT,T_Dsq,-2},0}
symtab[1187]:{tinit,S_GVar,34,(S_used+S_set+K_wdb+K_noclr),0,600/#004032D8,integer,{integer,0,1,object,-1},0}
symtab[1188]:{lib,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),0,1189,object,{atom,MININT,MAXINT,object,-1},[rsp]}
symtab[1189]:{fname,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),0,1190,object,{string,MININT,MAXINT,integer,-2},[rsp-8]}
symtab[1190]:{args,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),240,1191,sequence,{T_Dsq,MININT,MAXINT,integer,-2},[rsp-16]}
symtab[1191]:{return_type,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),0,1192,atom,{integer,16777220,16777220,object,-1},[rsp-24]}
symtab[1192]:{nlen,S_TVar,34,(S_used+S_set+K_wdb),1158,1193,integer,{integer,0,MAXLEN,object,-1},[rsp-32]}
symtab[1193]:{name,S_TVar,34,(S_used+S_set+K_wdb),1153,1194,object,{object,MININT,MAXINT,object,-2},[rsp-40]}
symtab[1194]:{convention,S_TVar,34,(S_used+S_set+K_wdb),0,1195,integer,{integer,1,2,object,-1},[rsp-48]}
symtab[1195]:{addr,S_TVar,34,(S_used+S_set+K_wdb),640,1196,atom,{object,MININT,MAXINT,object,-2},[rsp-56]}
symtab[1196]:{res,S_TVar,34,(S_used+S_set+K_wdb),1170,1197,integer,{integer,0,MAXLEN,object,-1},[rsp-64]}
symtab[1197]:{level,S_TVar,34,(S_used+S_set+K_wdb),1177,1198,integer,{integer,2,2,object,-1},[rsp-72]}
symtab[1198]:{-1,S_TVar,0,(S_set),0,1199,integer,{integer,0,MAXLEN,object,-1},[rsp-80]}
symtab[1199]:{-1,S_TVar,0,(S_set),0,1200,object,{integer,MININT,MAXINT,object,-1},[rsp-88]}
symtab[1200]:{i,S_TVar,34,(S_used+S_set+S_for+K_wdb),1161,1201,integer,{integer,0,MAXLEN,object,-1},[rsp-96]}
symtab[1201]:{-1,S_TVar,0,(S_set),0,1202,integer,{integer,0,0,object,-1},[rsp-104]}
symtab[1202]:{-1,S_TVar,0,(S_set),0,1203,atom,{integer,2,2,object,-1},[rsp-112]}
symtab[1203]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,5},[rsp-120]}
symtab[1204]:{S_NTyp,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),1264,601/#004032E0,integer,2}
symtab[1205]:{S_sig,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,602/#004032E8,integer,7}
symtab[1206]:{S_ParmN,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,603/#004032F0,integer,9}
symtab[1207]:{S_Ltot,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,604/#004032F8,integer,10}
symtab[1208]:{S_il,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),1270,605/#00403300,integer,11}
symtab[1209]:{S_Type,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),1275,606/#00403308,integer,6}
symtab[1210]:{S_Func,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,607/#00403310,integer,7}
symtab[1211]:{S_Proc,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,608/#00403318,integer,8}
symtab[1212]:{T_atom,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,609/#00403320,integer,3}
symtab[1213]:{T_object,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,610/#00403328,integer,15}
symtab[1214]:{T_const1,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),1282,611/#00403330,integer,26}
symtab[1215]:{DEBUG,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,612/#00403338,integer,0}
symtab[1216]:{previd,S_GVar,34,(S_used+S_set+K_wdb),0,613/#00403340,sequence,{T_Dsq,MININT,MAXINT,object,0},0}
symtab[1217]:{prevcb,S_GVar,34,(S_used+S_set+K_wdb),0,614/#00403348,sequence,{T_Dsq,MININT,MAXINT,object,0},0}
symtab[1218]:{pinit,S_GVar,34,(S_used+S_set+K_wdb+K_noclr),0,615/#00403350,integer,{integer,0,1,object,-1},0}
symtab[1219]:{Pinit,S_Proc,34,(S_used+K_used+K_wdb),0,1224,P,0,0,0,#0043B0B6}
symtab[1220]:{ebp_save,S_GVar,34,(S_used+S_set+K_wdb+K_noclr),0,616/#00403358,integer,0}
symtab[1221]:{FUNC,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,617/#00403360,integer,1}
symtab[1222]:{PROC,S_Const,34,(S_used+S_set+K_wdb+K_noclr+K_lit),0,618/#00403368,integer,0}
symtab[1223]:{-1,S_TVar,0,(S_set+K_Fres),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,3},(rax)}
symtab[1224]:{c_common,S_Func,34,(S_used+K_used+K_wdb),0,1262,{70'F',1,12,1},1225,3,24,#00449C31}
symtab[1225]:{rid,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),0,1226,integer,{integer,-1,MAXLEN,object,-1},[rsp]}
symtab[1226]:{args,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),1190,1227,sequence,{T_Dsq,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1227]:{flag,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),1107,1228,integer,{integer,1,1,object,-1},[rsp-16]}
symtab[1228]:{argdefs,S_TVar,34,(S_used+S_set+K_wdb),0,1229,sequence,{object,MININT,MAXINT,object,-2},[rsp-24]}
symtab[1229]:{argdefi,S_TVar,34,(S_used+S_set+K_wdb),0,1230,integer,{integer,MININT,MAXINT,object,-1},[rsp-32]}
symtab[1230]:{convention,S_TVar,34,(S_used+S_set+K_wdb),1194,1231,integer,{integer,MININT,MAXINT,object,-1},[rsp-40]}
symtab[1231]:{la,S_TVar,34,(S_used+S_set+K_wdb),0,1232,integer,{integer,0,MAXLEN,object,-1},[rsp-48]}
symtab[1232]:{lad,S_TVar,34,(S_used+S_set+K_wdb),0,1233,integer,{integer,0,MAXLEN,object,-1},[rsp-56]}
symtab[1233]:{ch,S_TVar,34,(S_used+S_set+K_wdb),1159,1234,integer,{integer,MININT,MAXINT,object,-1},[rsp-64]}
symtab[1234]:{argi,S_TVar,34,(S_used+S_set+K_wdb),0,1235,object,{object,MININT,MAXINT,object,-2},[rsp-72]}
symtab[1235]:{argstring,S_TVar,34,(S_used+S_set+K_wdb),0,1236,string,{string,MININT,MAXINT,integer,-2},[rsp-80]}
symtab[1236]:{return_type,S_TVar,34,(S_used+S_set+K_wdb),1191,1237,integer,{integer,MININT,MAXINT,object,-1},[rsp-88]}
symtab[1237]:{name,S_TVar,34,(S_used+S_set+K_wdb),1193,1238,object,{object,MININT,MAXINT,object,-2},[rsp-96]}
symtab[1238]:{tr,S_TVar,34,(S_used+S_set+K_wdb),0,1239,sequence,{T_Dsq,MININT,MAXINT,object,-2},[rsp-104]}
symtab[1239]:{addr,S_TVar,34,(S_used+S_set+K_wdb),1195,1240,atom,{object,MININT,MAXINT,object,-2},[rsp-112]}
symtab[1240]:{cstrings,S_TVar,34,(S_used+S_set+K_wdb),0,1241,sequence,{T_Dsq,MININT,MAXINT,string,-2},[rsp-120]}
symtab[1241]:{-1,S_TVar,0,(S_set),0,1242,integer,{integer,0,MAXLEN,object,-1},[rsp-128]}
symtab[1242]:{-1,S_TVar,0,(S_set),0,1243,atom,{integer,-805306363,5,object,-1},[rsp-136]}
symtab[1243]:{-1,S_TVar,0,(S_set),0,1244,sequence,{T_Dsq,MININT,MAXINT,integer,-2},[rsp-144]}
symtab[1244]:{-1,S_TVar,0,(S_set),0,1245,integer,{integer,0,MAXLEN,object,-1},[rsp-152]}
symtab[1245]:{i,S_TVar,34,(S_used+S_set+S_for+K_wdb),1200,1246,integer,{integer,0,MAXLEN,object,-1},[rsp-160]}
symtab[1246]:{-1,S_TVar,0,(S_set),0,1247,integer,{integer,0,MAXLEN,object,-1},[rsp-168]}
symtab[1247]:{i,S_TVar,34,(S_used+S_set+S_for+K_wdb),1245,1250,integer,{integer,0,MAXLEN,object,-1},[rsp-176]}
symtab[1248]:{-1,S_Const,34,(S_used+S_set+K_sqr+K_noclr+K_lit),0,619/#00403370,T_Dsq,{50331652}}
symtab[1249]:{-1,S_Const,34,(S_used+S_set+K_sqr+K_noclr+K_lit),0,620/#00403378,T_Dsq,{50331656}}
symtab[1250]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,3},[rsp-184]}
symtab[1251]:{rid,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr),1225,1252,integer,{integer,-1,MAXLEN,object,-1},[rsp]}
symtab[1252]:{args,S_TVar,34,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),1226,1253,sequence,{T_Dsq,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1253]:{return_type,S_TVar,34,(S_used+S_set+K_wdb),1236,1254,integer,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[1254]:{r,S_TVar,34,(S_used+S_set+K_wdb),1053,1255,object,?,[rsp-24]}
symtab[1255]:{c_esp_lo,S_TVar,34,(S_used+S_set+K_used+K_aod+K_wdb),0,1256,integer,{integer,0,0,object,-1},[rsp-32]}
symtab[1256]:{c_esp_hi,S_TVar,34,(S_used+S_set+K_used+K_aod+K_wdb),0,1257,integer,{integer,0,0,object,-1},[rsp-40]}
symtab[1257]:{local_ebp,S_TVar,34,(S_used+S_set+K_wdb),0,1258,integer,?,[rsp-48]}
symtab[1258]:{addr,S_TVar,34,(S_used+S_set+K_wdb),1239,1259,atom,{object,MININT,MAXINT,object,-2},[rsp-56]}
symtab[1259]:{cstrings,S_TVar,34,(S_used+S_set+K_wdb),1240,1260,sequence,{object,MININT,MAXINT,object,-2},[rsp-64]}
symtab[1260]:{-1,S_TVar,0,(S_set),0,0,T_Dsq,{T_Dsq,MININT,MAXINT,object,3},[rsp-72]}
symtab[1261]:{-1,S_Const,34,(S_used+S_set+K_sqr+K_noclr+K_lit),0,621/#00403380,T_Dsq,{33554433,16777218,33554434,16777220,33554436,50331652,50331656}}
symtab[1262]:{c_cleanup,S_Proc,34,(S_used+S_set+K_used+K_wdb+K_gbl+K_ridt),0,0,P,1263,0,3,#0043B025}
symtab[1263]:{-1,S_TVar,0,(S_set),0,1264,integer,{integer,0,0,object,-1},[rsp]}
symtab[1264]:{i,S_TVar,34,(S_used+S_set+S_for+K_wdb),1247,1265,integer,{integer,0,1,object,-1},[rsp-8]}
symtab[1265]:{-1,S_TVar,0,(S_set),0,0,object,{object,MININT,MAXINT,object,-2},[rsp-16]}
symtab[1266]:{x,S_TVar,35,(S_used+S_set+K_used+K_othr),410,1267,object,{object,MININT,MAXINT,object,-2},[rsp]}
symtab[1267]:{s,S_TVar,35,(S_used+S_set+K_used+K_othr),465,1268,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1268]:{start,S_TVar,35,(S_used+S_set+K_used+K_othr+K_dlft),1093,1269,integer,{integer,1,1,object,-1},[rsp-16]}
symtab[1269]:{-1,S_TVar,0,(S_set),0,1270,integer,{integer,1,1,object,-1},[rsp-24]}
symtab[1270]:{-1,S_TVar,0,(S_set),0,1271,integer,{integer,0,MAXLEN,object,-1},[rsp-32]}
symtab[1271]:{i,S_TVar,35,(S_used+S_set+S_for),1264,1272,integer,{integer,0,MAXLEN,object,-1},[rsp-40]}
symtab[1272]:{-1,S_TVar,0,(S_set),0,0,object,{object,MININT,MAXINT,object,-2},[rsp-48]}
symtab[1273]:{s1,S_TVar,36,(S_used+S_set+K_used+K_wdb+K_othr),0,1274,object,{string,MININT,MAXINT,integer,-2},[rsp]}
symtab[1274]:{s2,S_TVar,36,(S_used+S_set+K_used+K_wdb+K_othr),0,1275,sequence,{sequence,MININT,MAXINT,object,-2},[rsp-8]}
symtab[1275]:{start,S_TVar,36,(S_used+S_set+K_used+K_wdb+K_othr+K_dlft),1268,1276,integer,{integer,1,1,object,-1},[rsp-16]}
symtab[1276]:{res,S_TVar,36,(S_used+S_set+K_wdb),1196,1277,integer,{atom,MININT,MAXINT,object,-1},[rsp-24]}
symtab[1277]:{s2idx,S_TVar,36,(S_used+S_set+K_wdb),0,1278,integer,{atom,MININT,MAXINT,object,-1},[rsp-32]}
symtab[1278]:{ls1,S_TVar,36,(S_used+S_set+K_wdb),0,1279,integer,{integer,0,MAXLEN,object,-1},[rsp-40]}
symtab[1279]:{ls2,S_TVar,36,(S_used+S_set+K_wdb),0,1280,integer,{integer,0,MAXLEN,object,-1},[rsp-48]}
symtab[1280]:{s1i,S_TVar,36,(S_used+S_set+K_wdb),0,1281,object,{integer,0,255,object,-1},[rsp-56]}
symtab[1281]:{s2i,S_TVar,36,(S_used+S_set+K_wdb),0,1282,object,{object,MININT,MAXINT,object,-2},[rsp-64]}
symtab[1282]:{-1,S_TVar,0,(S_set),0,1283,atom,{atom,MININT,MAXINT,object,-1},[rsp-72]}
symtab[1283]:{-1,S_TVar,0,(S_set),1282,1284,atom,{atom,MININT,MAXINT,object,-1},[rsp-80]}
symtab[1284]:{-1,S_TVar,0,(S_set),0,1285,integer,{integer,0,MAXLEN,object,-1},[rsp-88]}
symtab[1285]:{i,S_TVar,36,(S_used+S_set+S_for+K_wdb),1271,1286,integer,{integer,0,MAXLEN,object,-1},[rsp-96]}
symtab[1286]:{j,S_TVar,36,(S_used+S_set+S_for+K_wdb),287,1287,integer,{atom,MININT,MAXINT,object,-1},[rsp-104]}
symtab[1287]:{-1,S_TVar,0,(S_set),0,1288,object,{object,MININT,MAXINT,object,-2},[rsp-112]}
symtab[1288]:{-1,S_TVar,0,(S_set),0,1289,atom,{integer,-1,805306367,object,-1},[rsp-120]}
symtab[1289]:{j,S_TVar,36,(S_used+S_set+S_for+K_wdb),1286,0,integer,{integer,-1,805306367,object,-1},[rsp-128]}
symtab[1290]:{-1,S_GVar,0,(S_set),0,622/#00403388,integer,{integer,5,5,object,-1},0}
symtab[1291]:{x,S_TVar,37,(S_used+S_set+K_used+K_wdb+K_othr),1266,1292,sequence,{sequence,MININT,MAXINT,object,-2},[rsp]}
symtab[1292]:{gap,S_TVar,37,(S_used+S_set+K_wdb),0,1293,integer,{atom,MININT,MAXINT,object,-1},[rsp-8]}
symtab[1293]:{j,S_TVar,37,(S_used+S_set+K_wdb),1289,1294,integer,{atom,MININT,MAXINT,object,-1},[rsp-16]}
symtab[1294]:{first,S_TVar,37,(S_used+S_set+K_wdb),0,1295,integer,{atom,MININT,MAXINT,object,-1},[rsp-24]}
symtab[1295]:{last,S_TVar,37,(S_used+S_set+K_wdb),0,1296,integer,{integer,0,MAXLEN,object,-1},[rsp-32]}
symtab[1296]:{tempi,S_TVar,37,(S_used+S_set+K_wdb),0,1297,object,{object,MININT,MAXINT,object,-2},[rsp-40]}
symtab[1297]:{tempj,S_TVar,37,(S_used+S_set+K_wdb),0,1298,object,{object,MININT,MAXINT,object,-2},[rsp-48]}
symtab[1298]:{-1,S_TVar,0,(S_set),0,1299,integer,{atom,MININT,MAXINT,object,-1},[rsp-56]}
symtab[1299]:{-1,S_TVar,0,(S_set),0,1300,integer,{integer,MININT,MAXINT,object,-1},[rsp-64]}
symtab[1300]:{-1,S_TVar,0,(S_set),0,1301,integer,{integer,0,MAXLEN,object,-1},[rsp-72]}
symtab[1301]:{i,S_TVar,37,(S_used+S_set+S_for+K_wdb),1285,1303,integer,{integer,MININT,MAXINT,object,-1},[rsp-80]}
symtab[1302]:{-1,S_Const,37,(S_used+S_set+K_noclr+K_lit),0,623/#00403390,T_N,3.5}
symtab[1303]:{-1,S_TVar,0,(S_set),0,0,atom,{atom,MININT,MAXINT,object,-1},[rsp-88]}
symtab[1304]:{-1,S_GVar,0,(S_set),0,624/#00403398,integer,{integer,5,5,object,-1},0}
symtab[1305]:{-1,S_GVar,0,(S_set),0,625/#004033A0,integer,{integer,4,4,object,-1},0}
symtab[1306]:{-1,S_GVar,0,(S_set),0,626/#004033A8,integer,{integer,4,4,object,-1},0}
symtab[1307]:{-1,S_GVar,0,(S_set),0,627/#004033B0,integer,{integer,4,4,object,-1},0}
symtab[1308]:{-1,S_GVar,0,(S_set),0,628/#004033B8,integer,{integer,5,5,object,-1},0}
symtab[1309]:{-1,S_GVar,0,(S_set),0,629/#004033C0,integer,{integer,3,3,object,-1},0}
symtab[1310]:{-1,S_GVar,0,(S_set),0,630/#004033C8,integer,{integer,3,3,object,-1},0}
symtab[1311]:{-1,S_GVar,0,(S_set),0,631/#004033D0,integer,{integer,3,3,object,-1},0}
symtab[1312]:{-1,S_GVar,0,(S_set),0,632/#004033D8,integer,{integer,5,5,object,-1},0}
symtab[1313]:{-1,S_GVar,0,(S_set),0,633/#004033E0,integer,{integer,3,3,object,-1},0}
symtab[1314]:{-1,S_GVar,0,(S_set),0,634/#004033E8,integer,{integer,3,3,object,-1},0}
symtab[1315]:{-1,S_GVar,0,(S_set),0,635/#004033F0,integer,{integer,3,3,object,-1},0}
symtab[1316]:{-1,S_GVar,0,(S_set),0,636/#004033F8,integer,{integer,5,5,object,-1},0}
symtab[1317]:{-1,S_GVar,0,(S_set),0,637/#00403400,integer,{integer,3,3,object,-1},0}
symtab[1318]:{-1,S_GVar,0,(S_set),0,638/#00403408,integer,{integer,4,4,object,-1},0}
symtab[1319]:{-1,S_GVar,0,(S_set),0,639/#00403410,integer,{integer,3,3,object,-1},0}
symtab[1320]:{-1,S_GVar,0,(S_set),0,640/#00403418,integer,{integer,4,4,object,-1},0}
symtab[1321]:{-1,S_GVar,0,(S_set),0,641/#00403420,integer,{integer,3,3,object,-1},0}
symtab[1322]:{-1,S_GVar,0,(S_set),0,642/#00403428,integer,{integer,4,4,object,-1},0}
symtab[1323]:{-1,S_GVar,0,(S_set),0,643/#00403430,integer,{integer,5,5,object,-1},0}
symtab[1324]:{-1,S_Const,1,(S_used+S_set+K_noclr+K_lit),0,644/#00403438,string,"."}
symtab[1325]:{-1,S_GVar,0,(S_set),0,645/#00403440,integer,{integer,5,5,object,-1},0}
symtab[1326]:{-1,S_GVar,0,(S_set),0,646/#00403448,integer,{integer,5,5,object,-1},0}
symtab[1327]:{-1,S_GVar,0,(S_set),0,647/#00403450,integer,{integer,4,4,object,-1},0}
symtab[1328]:{-1,S_GVar,0,(S_set),0,648/#00403458,integer,{integer,4,4,object,-1},0}
symtab[1329]:{-1,S_GVar,0,(S_set),0,649/#00403460,integer,{integer,4,4,object,-1},0}
symtab[1330]:{-1,S_GVar,0,(S_set),0,650/#00403468,integer,{integer,5,5,object,-1},0}
symtab[1331]:{-1,S_GVar,0,(S_set),0,651/#00403470,integer,{integer,5,5,object,-1},0}
symtab[1332]:{-1,S_GVar,0,(S_set),0,652/#00403478,integer,{integer,5,5,object,-1},0}
symtab[1333]:{-1,S_GVar,0,(S_set),0,653/#00403480,integer,{integer,4,4,object,-1},0}
symtab[1334]:{-1,S_GVar,0,(S_set),0,654/#00403488,integer,{integer,4,4,object,-1},0}
symtab[1335]:{-1,S_GVar,0,(S_set),0,655/#00403490,integer,{integer,4,4,object,-1},0}
symtab[1336]:{-1,S_GVar,0,(S_set),0,656/#00403498,integer,{integer,5,5,object,-1},0}
symtab[1337]:{-1,S_GVar,0,(S_set),0,657/#004034A0,integer,{integer,3,3,object,-1},0}
symtab[1338]:{-1,S_GVar,0,(S_set),0,658/#004034A8,integer,{integer,3,3,object,-1},0}
symtab[1339]:{-1,S_GVar,0,(S_set),0,659/#004034B0,integer,{integer,3,3,object,-1},0}
symtab[1340]:{-1,S_GVar,0,(S_set),0,660/#004034B8,integer,{integer,5,5,object,-1},0}
