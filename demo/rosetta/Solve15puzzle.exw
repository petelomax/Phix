--
-- demo\rosetta\Solve15puzzle.exw
-- ==============================
--
constant STM = 01   -- single-tile metrics.
constant MTM = 0    -- multi-tile metrics.
if STM and MTM then ?9/0 end if -- both prohibited
--  0       0   -- fastest, but non-optimal
--  1       0   -- optimal in STM
--  0       1   -- optimal in MTM (slowest by far)

--Note: The fast method uses an inadmissible heuristic - see "not STM" in iddfs().
--      It explores mtm-style using the higher stm heuristic and may therefore 
--      fail badly in some cases.

constant SIZE = 4

constant goal = { 1, 2, 3, 4,
                  5, 6, 7, 8,
                  9,10,11,12,
                 13,14,15, 0}

--
-- multi-tile-metric walking distance heuristic lookup (mmwd).
-- ==========================================================
-- Uses patterns of counts of tiles in/from row/col, eg the solved state 
--  (ie goal above) could be represented by the following:
--      {{4,0,0,0},
--       {0,4,0,0},
--       {0,0,4,0},
--       {0,0,0,3}}
--  ie row/col 1 contains 4 tiles from col/row 1, etc. In this case
--  both are identical, but you can count row/col or col/row, and then
--  add them together. There are up to 24964 possible patterns. The
--  blank space is not counted. Note that a vertical move cannot change
--  a vertical pattern, ditto horizontal, and basic symmetry means that
--  row/col and col/row patterns will match (at least, that is, if they 
--  are calculated sympathetically), halving the setup cost.
-- The data is just the number of moves made before this pattern was
--  first encountered, in a breadth-first search, backwards from the
--  goal state, until all patterns have been enumerated.
-- (The same ideas/vars are now also used for stm metrics when MTM=0)
--
sequence wdkey              -- one such 4x4 pattern
constant mmwd = new_dict()  -- lookup table, data is walking distance.


--
-- We use two to-do lists: todo is the current list, and everything
-- of walkingdistance+1 ends up on tdnx. Once todo is exhausted, we
-- swap the dictionary-ids, so tdnx automatically becomes empty.
-- Key is an mmwd pattern as above, and data is {distance,space_idx}.
--
integer todo = new_dict()
integer tdnx = new_dict()

--

enum UP = 1, DOWN = -1

procedure explore(integer space_idx, walking_distance, direction)
--
--  Given a space index, explore all the possible moves in direction,
--  setting the distance and extending the tdnx table.
--
integer tile_idx = space_idx+direction
    for group=1 to SIZE do
        if wdkey[tile_idx][group] then
            -- ie: check row tile_idx for tiles belonging to rows 1..4
            -- Swap one of those tiles with the space
            wdkey[tile_idx][group] -= 1
            wdkey[space_idx][group] += 1

            if getd_index(wdkey,mmwd)=0 then
                -- save the walking distance value
                setd(wdkey,walking_distance+1,mmwd)
                -- and add to the todo next list:
                if getd_index(wdkey,tdnx)!=0 then ?9/0 end if
                setd(wdkey,{walking_distance+1,tile_idx},tdnx)
            end if

if MTM then
            if tile_idx>1 and tile_idx<SIZE then
                -- mtm: same direction means same distance:
                explore(tile_idx, walking_distance, direction)
            end if
end if

            -- Revert the swap so we can look at the next candidate.
            wdkey[tile_idx][group] += 1
            wdkey[space_idx][group] -= 1
        end if
    end for
end procedure

procedure generate_mmwd()
-- Perform a breadth-first search begining with the solved puzzle state 
--  and exploring from there until no more new patterns emerge.
integer walking_distance = 0, space = 4

    wdkey = {{4,0,0,0}, -- \
             {0,4,0,0}, --  } 4 tiles in correct row positions
             {0,0,4,0}, -- /
             {0,0,0,3}} --    3 tiles in correct row position
    setd(wdkey,walking_distance,mmwd)
    while 1 do
        if space<4 then explore(space, walking_distance, UP)    end if
        if space>1 then explore(space, walking_distance, DOWN) end if
        if dict_size(todo)=0 then
            if dict_size(tdnx)=0 then exit end if
            {todo,tdnx} = {tdnx,todo}
        end if
        wdkey = getd_partial_key(0,todo)
        {walking_distance,space} = getd(wdkey,todo)
        deld(wdkey,todo)
    end while
end procedure

function walking_distance(sequence puzzle)
sequence rkey = repeat(repeat(0,SIZE),SIZE),
         ckey = repeat(repeat(0,SIZE),SIZE)
    integer k = 1
    for i=1 to SIZE do  -- rows
        for j=1 to SIZE do  -- columns
            integer tile = puzzle[k]
            if tile!=0 then
                integer row = floor((tile-1)/4)+1,
                        col = mod(tile-1,4)+1
                rkey[i][row] += 1
                ckey[j][col] += 1
            end if
            k += 1
        end for
    end for
    if getd_index(rkey,mmwd)=0
    or getd_index(ckey,mmwd)=0 then
        ?9/0 -- sanity check
    end if
    integer rwd = getd(rkey,mmwd),
            cwd = getd(ckey,mmwd)
    return rwd+cwd
end function

sequence puzzle
string res = ""
atom t0 = time(),
     t1 = time()+1
atom tries = 0

constant ok = {{0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1},   -- left
               {0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1},   -- up
               {1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0},   -- down
               {1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0}}   -- right

function iddfs(integer step, lim, space, prevmv)
    if time()>t1 then
        printf(1,"working... (depth=%d, tries=%d, time=%3ds)\r",{lim,tries,time()-t0})
        t1 = time()+1
    end if
    tries += 1
    integer d = iff(step==lim?0:walking_distance(puzzle))
    if d=0 then

        return (puzzle==goal)

    elsif step+d<=lim then

        for mv=1 to 4 do -- l/u/d/r
            if prevmv!=(5-mv) -- not l after r or vice versa, ditto u/d
            and ok[mv][space] then
                integer nspace = space+{-1,-4,+4,+1}[mv]
                integer tile = puzzle[nspace]
                if puzzle[space]!=0 then ?9/0 end if    -- sanity check     
                puzzle[space] = tile
                puzzle[nspace] = 0
--              if iddfs(step+(prevmv!=mv),lim,nspace,mv) then
                if iddfs(step+iff(MTM or not STM?(prevmv!=mv):1),lim,nspace,mv) then
                    res &= "ludr"[mv]
                    return true
                end if
                puzzle[nspace] = tile
                puzzle[space] = 0
            end if
        end for
    end if
    return false
end function

function pack(string s)
integer n = length(s), n0 = n
    for i=1 to 4 do
        integer ch = "lrud"[i], k
        while 1 do
            k = match(repeat(ch,3),s)
            if k=0 then exit end if
            s[k+1..k+2] = "3"
            n -= 2
        end while
        while 1 do
            k = match(repeat(ch,2),s)
            if k=0 then exit end if
            s[k+1] = '2'
            n -= 1
        end while
    end for
    return {n,iff(MTM?sprintf("%d",n):sprintf("%d(%d)",{n,n0})),s}
end function

procedure apply_moves(string moves, integer space)
integer move, ch, nspace
    puzzle[space] = 0
    for i=1 to length(moves) do
        ch = moves[i]
        if ch>'3' then
            move = find(ch,"ulrd")
        end if
        -- (hint: "r" -> the 'r' does 1
        --        "r2" -> the 'r' does 1, the '2' does 1
        --        "r3" -> the 'r' does 1, the '3' does 2!)
        for j=1 to 1+(ch='3') do
            nspace = space+{-4,-1,+1,4}[move]
            puzzle[space] = puzzle[nspace]
            space = nspace
            puzzle[nspace] = 0
        end for
    end for
end procedure

function solvable(sequence board)
integer n = length(board)
sequence positions = repeat(0,n)
    -- prepare the mapping from each tile to its position
    board[find(0,board)] = n
    for i=1 to n do
        positions[board[i]] = i
    end for
      
    -- check whether this is an even or odd state
    integer row = floor((positions[16]-1)/4),
            col = (positions[16]-1)-row*4
    bool even_state = (positions[16]==16) or (mod(row,2)==mod(col,2))
      
    -- count the even cycles
    integer even_count = 0
    sequence visited = repeat(false,16)
    for i=1 to n do
        if not visited[i] then
            -- a new cycle starts at i. Count its length..
            integer cycle_length = 0,
                    next_tile = i
            while not visited[next_tile] do
                cycle_length +=1
                visited[next_tile] = true
                next_tile = positions[next_tile]
            end while
            even_count += (mod(cycle_length,2)==0)
        end if
    end for
    return even_state == (mod(even_count,2)==0)
end function

procedure main()

    puzzle = {15,14, 1, 6, 
               9,11, 4,12,
               0,10, 7, 3, 
              13, 8, 5, 2}

--puzzle = {14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}
--puzzle = {2,1,3,4,5,6,7,8,9,10,11,12,13,14,15,0}  -- not solveable
--puzzle = {13,10,11,6,5,3,1,4,8,0,12,2,14,7,9,15}
--puzzle = {3,5,14,4,0,10,12,7,15,9,6,11,2,1,13,8}

    if not solvable(puzzle) then
        ?puzzle
        printf(1,"puzzle is not solveable\n")
    else

        generate_mmwd()

        sequence original = puzzle
        integer space = find(0,puzzle)

        for lim=walking_distance(puzzle) to iff(MTM?43:80) do
            if iddfs(0, lim, space, '-') then exit end if
        end for

        {integer n, string ns, string ans} = pack(reverse(res))

        printf(1,"\n\noriginal:")
        ?original
        atom t = time()-t0
        printf(1,"\n%soptimal solution of %s moves found in %s: %s\n\nresult: ",
                 {iff(MTM?"mtm-":iff(STM?"stm-":"non-")),ns,elapsed(t),ans})
        puzzle = original
        apply_moves(ans,space)
        ?puzzle
    end if
end procedure
main()

{} = wait_key()
abort(0)

{{out}}
<pre>
original:{15,14,1,6,9,11,4,12,0,10,7,3,13,8,5,2}
non-optimal solution of 35(60) moves found in 2.42s: u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru2ldru2rd3lulur3dl2ur2d2
stm-optimal solution of 38(52) moves found in 1 minute and 54s: r3uldlu2ldrurd3lu2lur3dld2ruldlu2rd2lulur2uldr2d2
mtm-optimal solution of 31(60) moves found in 2 hours, 38 minutes and 28s: u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
</pre>

Partial extra credit:
<pre>
{2,1,3,4,5,6,7,8,9,10,11,12,13,14,15,0}
puzzle is not solveable
</pre>
No luck on the other one, a non-optimal 60(98) moves was the best it could manage.


working... (depth=61, tries=1878050327, time=19537s)

original:{14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}

stm-optimal solution of 43(61) moves found in 5 hours, 25 minutes and 38s: dlu2l2drdru2ldru2rdlul2d3r2u2rd2lu3rdldrul2uld2ru2ld3rur2d

result: {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0}

--?elapsed(10800)   -- 3hrs (depth 37)
--?elapsed(11940)   -- 3hrs 19 mins
--?elapsed(19870)   -- 5 hours, 31 minutes and 10s
--?elapsed(21980)   -- 6 hours, 6 minutes and 20s
--?elapsed(39275)   -- 10 hours, 54 minutes and 35s
--?elapsed(44470)   -- 12 hours, 21 minutes and 10s
--?elapsed(54225)   -- 15 hours, 3 minutes and 45s

--res = "u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru2ldru2rd3lulur3dl2ur2d2"
--res = "r3uldlu2ldrurd3lu2lur3dld2ruldlu2rd2lulur2uldr2d2"
--res = "u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2"
--?res
--?length(substitute_all(res,{"2","3"},{"",""}))
--?length(substitute_all(res,{"3"},{"33"}))
--non-opt
--u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru2ldru2rd3lulur3dl2ur2d2
--35
--60
--stm-opt:
--r3uldlu2ldrurd3lu2lur3dld2ruldlu2rd2lulur2uldr2d2
--38
--52
--opt:
--u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--31
--60

--sequence tsum = repeat(0,81)  --DEV 43?!!
--sequence tsum = repeat(0,51)  --(getting better...)
--sequence tsum = repeat(0,15)  --(erm...)
sequence tsum = repeat(0,iff(MTM?15:35))

constant T4443 = {{4,0,0,0},    -- \
                  {0,4,0,0},    --  } 4 tiles in correct row positions
                  {0,0,4,0},    -- /
                  {0,0,0,3}}    --    3 tiles in correct row position
--DEV/SUG??
--constant T4443 = {4,0,0,0,    -- \
--                0,4,0,0,  --  } 4 tiles in correct row positions
--                0,0,4,0,  -- /
--                0,0,0,3}  --    3 tiles in correct row position
--
--function visitor(object key, integer wd, object /*user_data*/)
function visitor(object key, integer wd, object user_data)
--?{key,wd,user_data}
    if wd=0 then
        if key!=T4443 then ?9/0 end if
    else
--?wd
--while wd>length(tsum) do
--  ?{wd,length(tsum)}
--  tsum &= 0
--end while
        tsum[wd] += 1
    end if
    return 1
end function


--printf(1,"mmwd tables built in %3.2fs\n",{time()-t0})
--?dict_size(mmwd)  -- 24964
--?time()-t0
--?dict_size(todo)
if 0 then
    traverse_dict(routine_id("visitor"),0,mmwd)

    ?sum(tsum)  -- ok (24963)

    for i=1 to length(tsum) do
        if tsum[i] then
            ?{i,tsum[i]}
        end if
    end for
--/*
-- erm, a bit lower than I had hoped for...
24963
{1,3}
{2,11}
{3,55}
{4,249}
{5,823}
{6,2398}
{7,4261}
{8,5957}
{9,4583}
{10,3424}
{11,1795}
{12,820}
{13,416}
{14,128}
{15,40}
--*/
end if

--with trace

--/!*
ppOpt({pp_Pause,0,pp_Nest,1})

    puzzle = { 1, 2, 3, 4,
               5, 6, 7, 8,
               9,10,11,12,
              13,14,15, 0}

--string solution = "rrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd"
--string solution = "rrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrd2"
--string solution = "u2r2d3ru2ld2ru3ld3l2u3r2d3lu3rdrdl3ur3dl2drul2drur2d"  -- 35 moves...
--string solution = "r3uldlu2ldrurd3lu2lur3dld2ruldlu2rd2lulur2uldr2d2" --- 38 moves...
--string solution = "ulldruuurdddlluurrrdllldruurrdd"
string solution = "u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2"    -- 31 moves....

--/*
sequence solutions = {
"luurdruldlurrrddlldrrulurdlluruldldrdlururdrd",
"druuulddruuldllurrdldlurdrruuldldrdluldrrruulullddrdrr",
"drrdllluurdruulldrdrrdllurruullddrdruuulldlddrrr",
"ddrurdluldruuulddrururddldrululurdruldllurrrddd",
"dluuurdllldrdruuldruulldddrruurddluuurdldrullulddruuldddrurrd",    -- (dropped from STM)
"ullurullddrdlurrurddlulururdluldrdrdlluuldrrruullldrdrdr",
"rddluululddruurdruldllddrruurdllldrruldrruluruldrdd",
"uulddrurullddrrdruuldruuldldrdlluruurdddluulurrdrddlurd",
"rrdlurruuldrulldrulldrddluurrulldrdrdruuulldddruldlurrrd",
"lurulldrrrulldrdllurdrrullddrurulullddrrulddrurd",
"luldddluurddruuulddrrdllurruullldddrururulldldrurulldrdrrd",
"dlurddluulddrulddrurdruulldlururdruldddluuurddruldrd",
"ulddlurdruluulldrddruuulddldrruuruldllddrrululurdldrurdrd",
"ruullurddrrdllururullddldrulurrrullldrdrrullurdddruuuldldrdr",
"ddruulddruuulddrruulldrddruuldldrurrdlluurrdd",
"ruldrrurullurddlurdruuldrddlullurddruurulldlurddrrd",
"rrulddruurddlullurdldrulurrrdlluurdlurrdldrulllurrrddd",
"uurdrurddluurddlluldrulurrurdlulldrdrurddluuuldddrulurdrd",
"rululdlurdlddrruuldrrulurdllurdllurdlddrurullddrrr",
--devc DODGY:::
--"dddruuuldddllurrrululdddrulldruluruldrrurdldrululddldrr"}
"l2d3rulur2d2ru3l3d3r3u3ld3rul2dr2u2ldlu2r2dldluruldlur2d3r"}
--original:{3,12,0,11,10,5,7,14,6,13,2,15,8,9,4,1}
--non-optimal solution of 41 moves found in 1.56s(1.56s):l2d3rulur2d2ru3l3d3r3u3ld3rul2dr2u2ldlu2r2dldluruldlur2d3r
--*/


--/*
original:{15,14,1,6,9,11,4,12,0,10,7,3,13,8,5,2}

non-optimal solution of 35(60) moves found in 2.42s: u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru2ldru2rd3lulur3dl2ur2d2
stm-optimal solution of 38(52) moves found in 1 minute and 54s: r3uldlu2ldrurd3lu2lur3dld2ruldlu2rd2lulur2uldr2d2
mtm-optimal solution of 31(60) moves found in 2 hours, 38 minutes and 28s: u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2


The following table shows the result of solving 20 randomly generated 15 puzzles using the C++ imperative solver. 
The average number of moves to solve the puzzle is 53, max 61 min 45. 
The average time to solve the puzzle is 2.9524 seconds. With one outlier at 29 seconds. 

0xdab6531480c2e79f       0.040s  45     luurdruldlurrrddlldrrulurdlluruldldrdlururdrd
0x92fd74c6810e5a3b       0.477s  54     druuulddruuldllurrdldlurdrruuldldrdluldrrruulullddrdrr
0x487c50df9163bea2       0.174s  48     drrdllluurdruulldrdrrdllurruullddrdruuulldlddrrr
0x7ab1093458d2e6cf       0.118s  47     ddrurdluldruuulddrururddldrululurdruldllurrrddd
0xeb8fc5d3629017a4      29.300s  61     dluuurdllldrdruuldruulldddrruurddluuurdldrullulddruuldddrurrd
0x4cf92de35786b1a0       2.818s  56     ullurullddrdlurrurddlulururdluldrdrdlluuldrrruullldrdrdr
0xce2b170a65d489f3       0.221s  51     rddluululddruurdruldllddrruurdllldrruldrruluruldrdd
0x4d87a62950ebcf13       4.106s  55     uulddrurullddrrdruuldruuldldrdlluruurdddluulurrdrddlurd
0x45bd378c0e26af19       3.889s  56     rrdlurruuldrulldrulldrddluurrulldrdrdruuulldddruldlurrrd
0xf43627518b0ed9ac       0.277s  48     lurulldrrrulldrdllurdrrullddrurulullddrrulddrurd
0x7ad568b012ce34f9       1.603s  58     luldddluurddruuulddrrdllurruullldddrururulldldrurulldrdrrd
0xa90b16f7452ced38       4.240s  52     dlurddluulddrulddrurdruulldlururdruldddluuurddruldrd
0x4fe8a93c76d02b15       1.835s  57     ulddlurdruluulldrddruuulddldrruuruldllddrrululurdldrurdrd
0x97fc86d5e2b140a3       7.038s  60     ruullurddrrdllururullddldrulurrrullldrdrrullurdddruuuldldrdr
0x35e40ac7f96b21d8       0.027s  45     ddruulddruuulddrruulldrddruuldldrurrdlluurrdd
0x5f3a987e4dc2016b       0.252s  51     ruldrrurullurddlurdruuldrddlullurddruurulldlurddrrd
0x5872efca60914bd3       1.164s  54     rrulddruurddlullurdldrulurrrdlluurdlurrdldrulllurrrddd
0x36fd79ba21d50c84       0.714s  57     uurdrurddluurddlluldrulurrurdlulldrdrurddluuuldddrulurdrd
0x48d1b7ca230e659f       0.079s  50     rululdlurdlddrruuldrrulurdllurdllurdlddrurullddrrr
0x3c0ba57e6d2f8941       0.676s  56     dddruuuldddllurrrululdddrulldruluruldrrurdldrululddldrr
--*/

--0xdab6531480c2e79f         0.040s  45     luurdruldlurrrddlldrrulurdlluruldldrdlururdrd
--string solution = "luurdruldlurrrddlldrrulurdlluruldldrdlururdrd"
--puzzle = {13,10,11,6,5,3,1,4,8,0,12,2,14,7,9,15}  --
--non-optimal solution of 33 moves found in 1.34s(1.34s):lu2r2dlur2d2l3u2r2d3l2ur2ul2drur2uld3lu3r2dldldr2
--mtm-optimal solution of 30 moves found in 2 hours, 13 minutes and 18s: lu2r2d2l2u2r3dl3ur2d3l2ur3ul3drurd2ru3ld2lu2r2d3

--0x92fd74c6810e5a3b         0.477s  54     druuulddruuldllurrdldlurdrruuldldrdluldrrruulullddrdrr
--string solution = "druuulddruuldllurrdldlurdrruuldldrdluldrrruulullddrdrr"
--puzzle = {9,2,15,13,7,4,12,6,8,1,0,14,5,10,3,11}
--non-optimal solution of 38 moves found in 2.20s(2.20s):dru3l2d2r2u2l2d2r2ul3d2r3u2l3dr2u2rdl3ur3dl3drdlu2r2dl2urd2r2

--0x487c50df9163bea2         0.174s  48     drrdllluurdruulldrdrrdllurruullddrdruuulldlddrrr
--string solution = "drrdllluurdruulldrdrrdllurruullddrdruuulldlddrrr"
--puzzle = {4,8,7,12,5,0,13,15,9,1,6,3,11,14,10,2}
--non-optimal solution of 34 moves found in 1.41s(1.41s):dru2l2d3r3u3l2d2rdru3ld3l2urdlu3r2d2lu2rdld2ruldr2

--0x7ab1093458d2e6cf         0.118s  47     ddrurdluldruuulddrururddldrululurdruldllurrrddd
--string solution = "ddrurdluldruuulddrururddldrululurdruldllurrrddd"
--original:{7,10,11,1,0,9,3,4,5,8,13,2,14,6,12,15}
--non-optimal solution of 35 moves found in 4.33s(4.33s):rdr2ul3dr2u2rd2lu2l2dr2uld3lu3rd3ru3rd3l2urdruldr

--0xeb8fc5d3629017a4        29.300s  61     dluuurdllldrdruuldruulldddrruurddluuurdldrullulddruuldddrurrd
--string solution = "dluuurdllldrdruuldruulldddrruurddluuurdldrullulddruuldddrurrd"
--original:{14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}
--non-optimal solution of 44 moves found in 2.03s(2.03s):u2l3d3r2u3l2d3r2u3l2d3r2u2rd2lu3rd2l2uldr2u2rdl3d2r3ul2u2rd2luruld2rdr

--0x4cf92de35786b1a0         2.818s  56     ullurullddrdlurrurddlulururdluldrdrdlluuldrrruullldrdrdr
--string solution = "ullurullddrdlurrurddlulururdluldrdrdlluuldrrruullldrdrdr"
--original:{4,12,15,9,2,13,14,3,5,7,8,6,11,1,10,0}
--non-optimal solution of 41 moves found in 2.86s(2.86s):ul2u2ld3ru2r2ul3d3r3u3ld3lur2ul3dr2ul2dr2dlur2dlu3ldlur2drd2

--0xce2b170a65d489f3         0.221s  51     rddluululddruurdruldllddrruurdllldrruldrruluruldrdd
--string solution = "rddluululddruurdruldllddrruurdllldrruldrruluruldrdd"
--original:{12,14,2,11,1,7,0,10,6,5,13,4,8,9,15,3}
--non-optimal solution of 36 moves found in 1.23s(1.23s):luld2ru2r2d3lu2l2d2r2u3rd2l3dr2uldr2ulu2ldr2dl2u2rd2rd

--0x4d87a62950ebcf13         4.106s  55     uulddrurullddrrdruuldruuldldrdlluruurdddluulurrdrddlurd
--string solution = "uulddrurullddrrdruuldruuldldrdlluruurdddluulurrdrddlurd"
--original:{4,13,8,7,10,6,2,9,5,0,14,11,12,15,1,3}
--non-optimal solution of 42 moves found in 1.36s(1.36s):u2ld2r2dlu2r2ul3d2r3dl3u3rd3rul2ur3dl2ur2ul3d2ru2rdldruldrdr

--0x45bd378c0e26af19         3.889s  56     rrdlurruuldrulldrulldrddluurrulldrdrdruuulldddruldlurrrd
--string solution = "rrdlurruuldrulldrulldrddluurrulldrdrdruuulldddruldlurrrd"
--original:{4,5,11,13,3,7,8,12,0,14,2,6,10,15,1,9}
--non-optimal solution of 38 moves found in 1.22s(1.22s):r2dl2ur3ul2uld2r3u2l3d2r3u2l3dr2d2rul2dr2ul3dr3u2l2dldrur2d

--0xf43627518b0ed9ac         0.277s  48     lurulldrrrulldrdllurdrrullddrurulullddrrulddrurd
--string solution = "lurulldrrrulldrdllurdrrullddrurulullddrrulddrurd"
--original:{15,4,3,6,2,7,5,1,8,11,0,14,13,9,10,12}
--non-optimal solution of 36 moves found in 3.48s(3.48s):lurul2dr3ul2dr2dl3ur3dlu2l2drd2ru2l2drdru2rdlurd2

--/*
string solution = "ddrurdluldruuulddrururddldrululurdruldllurrrddd"
0x7ad568b012ce34f9       1.603s  58     luldddluurddruuulddrrdllurruullldddrururulldldrurulldrdrrd
0xa90b16f7452ced38       4.240s  52     dlurddluulddrulddrurdruulldlururdruldddluuurddruldrd
0x4fe8a93c76d02b15       1.835s  57     ulddlurdruluulldrddruuulddldrruuruldllddrrululurdldrurdrd
0x97fc86d5e2b140a3       7.038s  60     ruullurddrrdllururullddldrulurrrullldrdrrullurdddruuuldldrdr
0x35e40ac7f96b21d8       0.027s  45     ddruulddruuulddrruulldrddruuldldrurrdlluurrdd
0x5f3a987e4dc2016b       0.252s  51     ruldrrurullurddlurdruuldrddlullurddruurulldlurddrrd
0x5872efca60914bd3       1.164s  54     rrulddruurddlullurdldrulurrrdlluurdlurrdldrulllurrrddd
0x36fd79ba21d50c84       0.714s  57     uurdrurddluurddlluldrulurrurdlulldrdrurddluuuldddrulurdrd
0x48d1b7ca230e659f       0.079s  50     rululdlurdlddrruuldrrulurdllurdllurdlddrurullddrrr
0x3c0ba57e6d2f8941       0.676s  56     dddruuuldddllurrrululdddrulldruluruldrrurdldrululddldrr

Non-optimal Phix solutions:
The following table shows the result of solving the same puzzles using the Phix solver, with MTM=0 and STM=0. 
Move counts are listed below as mtm (stm) [stm-optimal from elsewhere].
The average number of moves to solve a puzzle is 38.45, max 44 min 29. 
The average time to solve a puzzle is none too shabby, but we can soon change that...
{13,10,11,6,5,3,1,4,8,0,12,2,14,7,9,15}   0.25s  33 (53) [45]  lu2r2dlur2d2l3u2r2d3l2ur2ul2drur2uld3lu3r2dldldr2
{9,2,15,13,7,4,12,6,8,1,0,14,5,10,3,11}   1.03s  38 (68) [54]  dru3l2d2r2u2l2d2r2ul3d2r3u2l3dr2u2rdl3ur3dl3drdlu2r2dl2urd2r2
{4,8,7,12,5,0,13,15,9,1,6,3,11,14,10,2}   0.28s  34 (56) [48]  dru2l2d3r3u3l2d2rdru3ld3l2urdlu3r2d2lu2rdld2ruldr2
{7,10,11,1,0,9,3,4,5,8,13,2,14,6,12,15}   3.20s  35 (55) [47]  rdr2ul3dr2u2rd2lu2l2dr2uld3lu3rd3ru3rd3l2urdruldr
{14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}   0.92s  44 (79) [61]  u2l3d3r2u3l2d3r2u3l2d3r2u2rd2lu3rd2l2uldr2u2rdl3d2r3ul2u2rd2luruld2rdr
{4,12,15,9,2,13,14,3,5,7,8,6,11,1,10,0}   1.72s  41 (68) [56]  ul2u2ld3ru2r2ul3d3r3u3ld3lur2ul3dr2ul2dr2dlur2dlu3ldlur2drd2
{12,14,2,11,1,7,0,10,6,5,13,4,8,9,15,3}   0.14s  36 (57) [51]  luld2ru2r2d3lu2l2d2r2u3rd2l3dr2uldr2ulu2ldr2dl2u2rd2rd
{4,13,8,7,10,6,2,9,5,0,14,11,12,15,1,3}   0.30s  42 (67) [55]  u2ld2r2dlu2r2ul3d2r3dl3u3rd3rul2ur3dl2ur2ul3d2ru2rdldruldrdr
{4,5,11,13,3,7,8,12,0,14,2,6,10,15,1,9}   0.14s  38 (66) [56]  r2dl2ur3ul2uld2r3u2l3d2r3u2l3dr2d2rul2dr2ul3dr3u2l2dldrur2d
{15,4,3,6,2,7,5,1,8,11,0,14,13,9,10,12}   2.36s  36 (52) [48]  lurul2dr3ul2dr2dl3ur3dlu2l2drd2ru2l2drdru2rdlurd2
{7,10,13,5,6,8,11,0,1,2,12,14,3,4,15,9}   0.31s  42 (62) [58]  l2d2r2u2l2ur2d2l2u2rd3lu2ldr2dl2urdrulu2ldrurd3ru3ldld2rurd
{10,9,0,11,1,6,15,7,4,5,2,12,14,13,3,8}   2.02s  34 (58) [52]  l2d2r2ul2urd3ru3l2d2r3u2l2d3ru3ld2rulurdrd2l3ur2urd2
{4,15,14,8,10,9,3,12,7,6,13,0,2,11,1,5}   0.14s  43 (71) [57]  ulul2d3r2u2l2d2r2u3l2d2r2ul2d2r3u2l3d2r2u2ld2luru2ld2rur2dluruld2rd
{9,7,15,12,8,6,13,5,14,2,11,1,4,0,10,3}   0.50s  44 (70) [60]  lu2r3dl3ur3ul2drdl2u2rd3r2ul2dlu3r2d3lu3rd2ru2ld2rul2d2rurdlurd
{3,5,14,4,0,10,12,7,15,9,6,11,2,1,13,8}   0.06s  29 (45) [45]  d2ru2ld2ru3ld2r2u2l2drd2ru2ldldrur2dl2u2r2d2
{5,15,3,10,9,8,7,14,4,13,12,2,0,1,6,11}   1.88s  40 (59) [51]  rur2ul3d2r3u3ld2lu2ld2ru2ldr3dldrul2dru2rul2d2ruruld2rd
{5,8,7,2,14,15,12,10,0,6,9,1,4,11,13,3}   0.11s  40 (68) [54]  r3uld2l2ur3dl2u2ld2ru3rd3lu3r2d2l3u2r3d2lu2rd2luld2rurdl2ur2d
{3,6,15,14,7,9,11,10,2,1,13,5,0,12,8,4}   0.06s  40 (69) [57]  uruldr3ul3dr3dl3u2r2urd3lu3ld3ru3rd3lu3l2drd2lur2u2ld2ldr3
{4,8,13,1,11,7,12,10,2,3,0,14,6,5,9,15}   0.95s  39 (70) [50]  ul2d2r3ul2u2r2dl3ur3dl3ur2dl2d2ru3rd3lu2ld2r3u3l2d3rulu2rdrd2
{3,12,0,11,10,5,7,14,6,13,2,15,8,9,4,1}   0.45s  41 (66) [56]  l2d3rulur2d2ru3l3d3r3u3ld3rul2dr2u2ldlu2r2dldluruldlur2d3r

STM-optimal solutions are quite a bit slower.. With move counts again shown as mtm (stm) [else]:
{13,10,11,6,5,3,1,4,8,0,12,2,14,7,9,15}   2.42s  38 (45) [45]  lu2rdruldlur3d2l2uldrdr2ulurdl2dlururuldrdrd
{9,2,15,13,7,4,12,6,8,1,0,14,5,10,3,11} 196.23s  38 (54) [54]  ul2ur3dluld2lur2urdld2ru2ldlu2rd3luldr3u2l2uld2rdr2
{4,8,7,12,5,0,13,15,9,1,6,3,11,14,10,2}  46.23s  30 (48) [48]  dr2dl3u2rdru2l2drdr2dl2ur2u2l2d2rdru3l2dld2r3
{7,10,11,1,0,9,3,4,5,8,13,2,14,6,12,15}  71.92s  37 (47) [47]  d2rurdluldru3ld2rururd2ldrululurdruldl2ur3d3
{14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}                  [61]  -- took too long...
{4,12,15,9,2,13,14,3,5,7,8,6,11,1,10,0} 657.56s  44 (56) [56]  ul2urul2d2rdlur2urdl2ururdluldrd2ruldlu2ldr3u2l3drdrdr
{12,14,2,11,1,7,0,10,6,5,13,4,8,9,15,3}  48.39s  39 (51) [51]  luld2ruld2rur2dl2ulururdrdl2ururd2l2ururd2lul2d2r3
{4,13,8,7,10,6,2,9,5,0,14,11,12,15,1,3} 462.69s  41 (55) [55]  u2ld2rurul2d2r2dru2ldru2ldldrdl2uru2rd3lu2lur2drd2lurd
{4,5,11,13,3,7,8,12,0,14,2,6,10,15,1,9} 388.74s  40 (56) [56]  r2dl2ur3ul2uld2rururdlul2d2r2uldrdru3l3d2rdruldlur3d
{15,4,3,6,2,7,5,1,8,11,0,14,13,9,10,12}  36.92s  36 (48) [48]  lurul2dr3ul2drdl2urdr2ul2d2rurulul2d2r2uld2rurd
{7,10,13,5,6,8,11,0,1,2,12,14,3,4,15,9}  98.28s  42 (58) [58]  luld3lu2rd2ru2ldr2dl2ur2ulul2d3ruru2rdl3dru2rdluldrdr2d
{10,9,0,11,1,6,15,7,4,5,2,12,14,13,3,8} 421.03s  36 (52) [52]  l2d2rdru2l2drdrurululd3ru3ld2rurul2dr2d2l3ur2urd2
{4,15,14,8,10,9,3,12,7,6,13,0,2,11,1,5} 134.48s  44 (57) [57]  ldlurdru2lul2drd2r2ulu2ld2ldr2u2l2d2r2ululurdldrur2uld2rd
{9,7,15,12,8,6,13,5,14,2,11,1,4,0,10,3} 678.39s  43 (60) [60]  lurur2d2l2u2ldrururd2ldrulu2rd2l2u2r2dld2ru2l3urd3lu2rdrdr
{3,5,14,4,0,10,12,7,15,9,6,11,2,1,13,8}   4.78s  29 (45) [45]  d2ru2ld2ru3ld2r2u2l2drd2ru2ldldrur2dl2u2r2d2
{5,15,3,10,9,8,7,14,4,13,12,2,0,1,6,11}  60.02s  40 (51) [51]  ruldr2urul2urd2lurdru2ldrd2lul2urd2ru2rul2dlurd2r2d
{5,8,7,2,14,15,12,10,0,6,9,1,4,11,13,3}  68.48s  38 (54) [54]  r2ul2drdru2rd2lululd2rulur3dl2u2rdlur2dldrul3ur3d3
{3,6,15,14,7,9,11,10,2,1,13,5,0,12,8,4} 145.20s  43 (57) [57]  u2rdrurd2lu2rd2l3urdlu2r2urdlul2drdrurd2lu3ld3rulurdrd
{4,8,13,1,11,7,12,10,2,3,0,14,6,5,9,15}  17.14s  37 (50) [50]  rulul2druld3r2u2ldr2ulurdl2urdl2urdld2rurul2d2r3
{3,12,0,11,10,5,7,14,6,13,2,15,8,9,4,1} 278.75s  43 (56) [56]  ldld2rur2dluruldl2ur2drdlul2uruldr2urd2lu2rd2lu2ld2ldr3

MTM-optimal solutions take even longer to find, so much so that I only did the first!
puzzle = {13,10,11,6,5,3,1,4,8,0,12,2,14,7,9,15}
mtm-optimal solution of 30 moves found in 2 hours, 13 minutes and 18s: lu2r2d2l2u2r3dl3ur2d3l2ur3ul3drurd2ru3ld2lu2r2d3


--*/

integer space = find(0,puzzle), m, nspace, rep = 1
sequence moveset = {}
procedure reverse_engineer()
    space = find(0,puzzle)
    rep = 1
    ?puzzle
    integer moves = 0
    moveset = {}
    for i=length(solution) to 1 by -1 do
        integer ch = solution[i]
        if ch<='3' then
            rep = ch-'0'
        else
--?ch&rep+'0'
            m = {-4,-1,1,4}[find(ch,"drlu")]
--          moves += 1
            moves += iff(MTM?1:rep)
moveset = prepend(moveset,{ch,rep})
            for k=1 to rep do
                nspace = space+m
                {puzzle[space],puzzle[nspace]} = {puzzle[nspace],0}
                space = nspace
            end for
            rep = 1
--      ?puzzle
--trace(1)
            integer wd = walking_distance(puzzle)
if 0 then
            ?{puzzle,moves,wd}
end if
            if wd>moves then ?9/0 end if
        end if
    end for
end procedure
if 0 then
    reverse_engineer()
end if

--puzzle = {3,12,0,11,10,5,7,14,6,13,2,15,8,9,4,1}

--constant udlr = {"up", "down", "left", "right"}
--sequence board = tagset(15)&0
--integer pos = 16

integer collected = 0
sequence lines = repeat("",5) 

procedure print_board(integer last)
integer k = 2
    for i=1 to length(puzzle) do
        integer piece = puzzle[i]
        string this = iff(piece=0?"   ":sprintf("%3d",{piece}))
        lines[k] &= this
        if mod(i,4)=0 then k+=1 end if
    end for
    collected += 1
    if collected=8 or last then
        puts(1,join(lines,"\n")&"\n\n")
        lines = repeat("",5)
        collected = 0
    else
        for i=2 to 5 do
            lines[i] &= "      "
        end for
    end if
end procedure

if 0 then
--  pos = pos0
--  board = board0
    space = find(0,puzzle)
    lines[1] = "solved!!:         "
    print_board(0)
    for i=1 to length(moveset) do
--  for i=length(moveset) to 1 by -1 do
        integer {ch,rep} = moveset[i]
--      string m = udlr[mi]
--      integer mi = 
--      m = {-4,-1,1,4}[find(ch,"drlu")]
        m = {-4,-1,1,4}[find(ch,"ulrd")]
        string reps = iff(rep=1?"":sprintf("%d",rep)),
               this = sprintf("move %d:%s%s",{i,ch,reps})
        lines[1] &= sprintf("%-18s",{this})
--      moves[i] = upper(m[1])
--      {} = move(mi)
        for k=1 to rep do
            nspace = space+m
            {puzzle[space],puzzle[nspace]} = {puzzle[nspace],0}
            space = nspace
        end for
        print_board(i=length(moveset))
    end for
    printf(1,"solved in %d moves:%s\n",{length(moveset),solution})
--/*
--lovely...
solved!!:         move 1:u2         move 2:r2         move 3:d3         move 4:r          move 5:u2
 15 14  1  6          14  1  6       14  1     6       14  1  4  6       14  1  4  6       14  1  4  6
  9 11  4 12       15 11  4 12       15 11  4 12       15 11  7 12       15 11  7 12       15 11  7
    10  7  3        9 10  7  3        9 10  7  3        9 10  5  3        9 10  5  3        9 10  5 12
 13  8  5  2       13  8  5  2       13  8  5  2       13  8     2       13  8  2          13  8  2  3

move 6:l          move 7:d2         move 8:r          move 9:u3         move 10:l         move 11:d3
 14  1  4  6       14  1  4  6       14  1  4  6       14  1  4          14  1     4       14  1  5  4
 15 11     7       15 11  5  7       15 11  5  7       15 11  5  6       15 11  5  6       15 11  2  6
  9 10  5 12        9 10  2 12        9 10  2 12        9 10  2  7        9 10  2  7        9 10  3  7
 13  8  2  3       13  8     3       13  8  3          13  8  3 12       13  8  3 12       13  8    12

move 12:l2        move 13:u3        move 14:r2        move 15:d2        move 16:l2        move 17:d
 14  1  5  4           1  5  4        1  5     4        1  5  2  4        1  5  2  4        1  5  2  4
 15 11  2  6       14 11  2  6       14 11  2  6       14 11  3  6       14 11  3  6       14 11  3  6
  9 10  3  7       15 10  3  7       15 10  3  7       15 10     7          15 10  7        9 15 10  7
    13  8 12        9 13  8 12        9 13  8 12        9 13  8 12        9 13  8 12          13  8 12

move 18:r         move 19:u3        move 20:r         move 21:d3        move 22:l2        move 23:u2
  1  5  2  4        1     2  4        1  2     4        1  2  3  4        1  2  3  4        1  2  3  4
 14 11  3  6       14  5  3  6       14  5  3  6       14  5 10  6       14  5 10  6           5 10  6
  9 15 10  7        9 11 10  7        9 11 10  7        9 11  8  7        9 11  8  7       14 11  8  7
 13     8 12       13 15  8 12       13 15  8 12       13 15    12          13 15 12        9 13 15 12

move 24:r3        move 25:d         move 26:l3        move 27:d         move 28:r         move 29:u2
  1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4
  5 10  6           5 10  6  7        5 10  6  7        5 10  6  7        5 10  6  7        5     6  7
 14 11  8  7       14 11  8             14 11  8        9 14 11  8        9 14 11  8        9 10 11  8
  9 13 15 12        9 13 15 12        9 13 15 12          13 15 12       13    15 12       13 14 15 12

move 30:r2        move 31:d2
  1  2  3  4        1  2  3  4
  5  6  7           5  6  7  8
  9 10 11  8        9 10 11 12
 13 14 15 12       13 14 15

--solved in 31 moves:u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
Solution of 31 moves found in 2 hours, 38 minutes and 28s:u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2

--better??
</lang>
{{out}}
<pre>
</pre>
<lang Phix>
</lang>
Same output
{{out}}
<pre>
</pre>
<pre style="font-size: 2px">
<pre style="font-size: 8px; float:left">
<pre style="float:left">
<pre style="font-size: 8px">
<pre style="font-size: 12px">
solved!!:         move 1:u2         move 2:r2         move 3:d3         move 4:r          move 5:u2         move 6:l          move 7:d2
 15 14  1  6          14  1  6       14  1     6       14  1  4  6       14  1  4  6       14  1  4  6       14  1  4  6       14  1  4  6
  9 11  4 12       15 11  4 12       15 11  4 12       15 11  7 12       15 11  7 12       15 11  7          15 11     7       15 11  5  7
    10  7  3        9 10  7  3        9 10  7  3        9 10  5  3        9 10  5  3        9 10  5 12        9 10  5 12        9 10  2 12
 13  8  5  2       13  8  5  2       13  8  5  2       13  8     2       13  8  2          13  8  2  3       13  8  2  3       13  8     3

move 8:r          move 9:u3         move 10:l         move 11:d3        move 12:l2        move 13:u3        move 14:r2        move 15:d2
 14  1  4  6       14  1  4          14  1     4       14  1  5  4       14  1  5  4           1  5  4        1  5     4        1  5  2  4
 15 11  5  7       15 11  5  6       15 11  5  6       15 11  2  6       15 11  2  6       14 11  2  6       14 11  2  6       14 11  3  6
  9 10  2 12        9 10  2  7        9 10  2  7        9 10  3  7        9 10  3  7       15 10  3  7       15 10  3  7       15 10     7
 13  8  3          13  8  3 12       13  8  3 12       13  8    12          13  8 12        9 13  8 12        9 13  8 12        9 13  8 12

move 16:l2        move 17:d         move 18:r         move 19:u3        move 20:r         move 21:d3        move 22:l2        move 23:u2
  1  5  2  4        1  5  2  4        1  5  2  4        1     2  4        1  2     4        1  2  3  4        1  2  3  4        1  2  3  4
 14 11  3  6       14 11  3  6       14 11  3  6       14  5  3  6       14  5  3  6       14  5 10  6       14  5 10  6           5 10  6
    15 10  7        9 15 10  7        9 15 10  7        9 11 10  7        9 11 10  7        9 11  8  7        9 11  8  7       14 11  8  7
  9 13  8 12          13  8 12       13     8 12       13 15  8 12       13 15  8 12       13 15    12          13 15 12        9 13 15 12

move 24:r3        move 25:d         move 26:l3        move 27:d         move 28:r         move 29:u2        move 30:r2        move 31:d2
  1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4        1  2  3  4
  5 10  6           5 10  6  7        5 10  6  7        5 10  6  7        5 10  6  7        5     6  7        5  6  7           5  6  7  8
 14 11  8  7       14 11  8             14 11  8        9 14 11  8        9 14 11  8        9 10 11  8        9 10 11  8        9 10 11 12
  9 13 15 12        9 13 15 12        9 13 15 12          13 15 12       13    15 12       13 14 15 12       13 14 15 12       13 14 15

solved in 31 moves:u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
</pre>
Solution of 31 moves found in 2 hours, 38 minutes and 28s:u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2

--*/
end if


--sequence board = {{15, 14,    1,  6},
--                { 9, 11,  4, 12},
--                { 0, 10,  7,  3},
--                {13,  8,  5,  2}}
--puzzle = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0}  -- Solution of 0 moves found in 1.69s:
--puzzle = {1,2,3,4,5,6,7,8,9,10,11,0,13,14,15,12}  -- Solution of 1 moves found in 1.67s:d
--puzzle = {1,2,3,4,5,6,7,8,9,0,10,11,13,14,15,12}  -- Solution of 2 moves found in 2.11s:r2d
--puzzle = {1,2,3,4,5,6,7,8,9,14,10,11,13,0,15,12}  -- Solution of 3 moves found in 2.11s:ur2d
--puzzle = {1,2,3,4,5,6,7,8,9,14,10,11,0,13,15,12}  -- Solution of 4 moves found in 1.70s:rur2d
--puzzle = {1,2,3,4,5,6,7,8,0,14,10,11,9,13,15,12}  -- Solution of 5 moves found in 1.64s:drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,10,0,11,9,13,15,12}  -- Solution of 6 moves found in 1.91s:l2drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,10,15,11,9,13,0,12}  -- Solution of 7 moves found in 1.98s:ul2drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,10,15,11,9,0,13,12}  -- Solution of 8 moves found in 1.84s:rul2drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,0,15,11,9,10,13,12}  -- Solution of 9 moves found in 1.89s:drul2drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,15,11,0,9,10,13,12}  -- Solution of 10 moves found in 2.19s:l2drul2drur2d
--puzzle = {1,2,3,4,5,6,7,0,14,15,11,8,9,10,13,12}  -- Solution of 11 moves found in 2.12s:dl2drul2drur2d
--puzzle = {1,2,3,4,0,5,6,7,14,15,11,8,9,10,13,12}  -- Solution of 12 moves found in 2.03s:r3dl2drul2drur2d
--puzzle = {1,2,3,4,14,5,6,7,0,15,11,8,9,10,13,12}  -- Solution of 13 moves found in 2.12s:ur3dl2drul2drur2d
--puzzle = {1,2,3,4,14,5,6,7,15,11,8,0,9,10,13,12}  -- Solution of 14 moves found in 2.03s:l3ur3dl2drul2drur2d
--puzzle = {1,2,3,4,14,5,6,0,15,11,8,7,9,10,13,12}  -- Solution of 15 moves found in 2.11s:dl3ur3dl2drul2drur2d
--puzzle = {1,2,3,4,14,5,0,6,15,11,8,7,9,10,13,12}  -- Solution of 16 moves found in 2.27s:rdl3ur3dl2drul2drur2d
--puzzle = {1,2,0,4,14,5,3,6,15,11,8,7,9,10,13,12}  -- Solution of 17 moves found in 2.61s:drdl3ur3dl2drul2drur2d
--puzzle = {1,0,2,4,14,5,3,6,15,11,8,7,9,10,13,12}  -- Solution of 18 moves found in 3.33s:rdrdl3ur3dl2drul2drur2d
--puzzle = {1,5,2,4,14,11,3,6,15,10,8,7,9,0,13,12}  -- {"solution found","uuurdrdlllurrrdlldrulldrurrd",74.453}     -- (19 moves)
                                                    -- Solution of 18 moves found in 3.31s:rul2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {1,5,2,4,14,11,3,6,15,10,8,7,9,13,0,12}  -- {"solution found","ulldruuurdddlluurrrdllldruurrdd",27.594}  -- (17 moves!)
                                                    -- Solution of 17 moves found in 2.45s:ul2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {1,5,0,4,14,11,2,6,15,10,3,7,9,13,8,12}  -- {"solution found","ddlldruuurdddlluurrrdllldruurrdd",25.579} -- (18 moves)
                                                    -- Solution of 17 moves found in 2.41s:d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {0,1,5,4,14,11,2,6,15,10,3,7,9,13,8,12}  -- {"solution found","rrddlldruuurdddlluurrrdllldruurrdd",63.532}   -- (19 moves)
                                                    -- Solution of 18 moves found in 2.62s:r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,5,4,15,11,2,6,9,10,3,7,0,13,8,12}  -- {"solution found","uuurrddlldruuurdddlluurrrdllldruurrdd",81.047}    -- (20 moves)
                                                    -- Solution of 19 moves found in 2.62s:u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,5,4,15,11,2,6,9,10,3,7,13,8,0,12}  -- Solution of 20 moves found in 2.81s:l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,0,4,15,11,5,6,9,10,2,7,13,8,3,12}  -- Solution of 21 moves found in 4.80s:d3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,0,15,11,5,6,9,10,2,7,13,8,3,12}  -- Solution of 22 moves found in 7.19s:ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,5,7,9,10,2,12,13,8,3,0}  -- Solution of 23 moves found in 29.39s:u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,5,7,9,10,2,12,13,8,0,3}  -- Solution of 24 moves found in 1 minute and 29s:ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,0,7,9,10,5,12,13,8,2,3}  -- Solution of 25 moves found in 2 minutes and 51s:d2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,7,0,9,10,5,12,13,8,2,3}  -- Solution of 26 moves found in 275.62s:ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,7,12,9,10,5,3,13,8,2,0}  -- Solution of 27 moves found in 936.36s:u2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,7,12,9,10,5,3,13,8,0,2}  -- Solution of 28 moves found in 47 minutes and 12s:ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,0,6,15,11,4,12,9,10,7,3,13,8,5,2}  -- 
--puzzle = {0,14,1,6,15,11,4,12,9,10,7,3,13,8,5,2}  -- 

puzzle = {15,14,1,6,9,11,4,12,0,10,7,3,13,8,5,2}    -- non-optimal solution of 35(60) moves found in 2.39s: u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru2ldru2rd3lulur3dl2ur2d2
                                                    -- stm-optimal solution of 38(52) moves found in 1 minute and 54s: r3uldlu2ldrurd3lu2lur3dld2ruldlu2rd2lulur2uldr2d2
                                                    -- mtm-optimal solution of 31(60) moves found in 2 hours, 38 minutes and 28s: u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2

--puzzle = {14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}

--(1 hour, 30 minutes and 20s so far...)
--(make that 2 hours, 4 minutes and 40s)
--offs:
--working... (depth=31, tries=1073714361, time=9451s) [[ that be 2 hours, 37 minutes and 31s ]]
--C:\Program Files (x86)\Phix\e01.exw:305 in function iddfs() type check failure, tries is 1073741824.0
--===
--{15,14,1,6,9,11,4,12,0,10,7,3,13,8,5,2}

--puzzle = {2,1,3,4,5,6,7,8,9,10,11,12,13,14,15,0}  -- unsolveable

puzzle = {0,12,9,13,15,11,10,14,3,7,2,5,4,8,6,1}    -- hard?
--non-optimal solution of 60(98) moves found in 4.22s: d3ru3ld3ru2ld2ruruldr2u2l2d2rdru3ld3l2ur3u2l3d2r2dlu2rdrul3d2ru3ld2r2ulurdl2dr2dru2l2d2r2

--Xpuzzle = {1,6,15,0,14,11,5,7,10,9,8,3,2,13,12,4} -- 45 moves? (killed on 6 mins)

-->
--better solution for problem 1:
--original:{13,10,11,6,5,3,1,4,8,0,12,2,14,7,9,15}
--
--Solution of 30 moves found in 2 hours, 13 minutes and 18s:
--
--lu2r2d2l2u2r3dl3ur2d3l2ur3ul3drurd2ru3ld2lu2r2d3
--
--result: {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0}

--/*
>
--*/

--OLD:
--/*
-- Note/DEV: this is now (probably) broken due to my incessant fiddling.
-- For a working version see http://rosettacode.org/wiki/15_puzzle_solver#Phix
--

constant udlr = {"up", "down", "left", "right"}
sequence board = tagset(15)&0
integer pos = 16

integer collected = 0
sequence lines = repeat("",5) 

procedure print_board(integer last)
integer k = 2
    for i=1 to length(board) do
        string this = iff(i=pos?"   ":sprintf("%3d",{board[i]}))
        lines[k] &= this
        if mod(i,4)=0 then k+=1 end if
    end for
    collected += 1
    if collected=6 or last then
        puts(1,join(lines,"\n")&"\n\n")
        lines = repeat("",5)
        collected = 0
    else
        for i=2 to 5 do
            lines[i] &= "      "
        end for
    end if
end procedure
 
function move(integer d)
integer valid = 0
integer stick = 0
    for k=1 to 8 by 2 do
        if board[k]!=k then exit end if
        if board[k+1]!=k+1 then exit end if
        stick = k+1
    end for
    integer new_pos = pos+{+4,-4,+1,-1}[d]
    if new_pos>=1 and new_pos<=16
    and (mod(pos,4)=mod(new_pos,4) -- same col, or row:
     or floor((pos-1)/4)=floor((new_pos-1)/4)) then
        {board[pos],board[new_pos]} = {board[new_pos],0}
        valid = pos>stick and new_pos>stick
        pos = new_pos
    end if
    return {valid,stick}
end function

constant posns = {1,2,3,4,5,6,7,8,9,13,10,14,11,12,15}

function score(sequence board)
integer res = 0, pos, act_pos
    for i=1 to 15 do
        pos = posns[i]
        act_pos = find(pos,board)
        res += (abs(mod(pos,4)-mod(act_pos,4))+
                abs(floor((pos-1)/4)-floor((act_pos-1)/4)))*10*pos
    end for
    return res
end function

function manhattan(sequence board)
integer res = 0
    for i=1 to length(board) do
        integer bi = board[i]
        if bi!=i
--      and (i!=16 or bi!=0) then
        and bi!=0 then
            res += (abs(mod((i+1),4)-mod((bi+1),4))+
                    abs(floor((i-1)/4)-floor((bi-1)/4)))
--?{i,bi,res,abs(mod((i+1),4)-mod((bi+1),4)),abs(floor((i-1)/4)-floor((bi-1)/4))}
        end if
    end for
    return res
end function
--/*

sequence board0 = { 1, 2, 3, 4,
                    5, 6, 7, 8,
                    9,10,11,12,
                   13,14,15, 0},
--                 13,14, 0,15},
         board1 = {15, 2, 3, 4,
                    5, 6, 7, 8,
                    9,10,11,12,
                   13,14, 1, 0},
$
?manhattan(board0) -- 0 rqd
if 01 then
    ?manhattan(board1) -- 10 rqd
end if
--*/

--/*
function sign(sequence board)
integer n = length(board), s = 0, i = 1, j
?board
    while i!=n do
        j = board[i]
--if j!=0 then
--      if i!=j then
        if j!=0 and i!=j then
--6 swap(a,i, a[i])
            board[i] = j
            i = j
            s = 1 - s
        else
            i += 1
        end if
?{board,i}
--end if
    end while
?board
    return s
end function
--*/

--bool es

--broken, I think...
--function solveable(sequence board)
--integer n = length(board)
--  -- prepare the mapping from each tile to its position
--  sequence positions = repeat(0,n),
--           visited = repeat(false,n)
--  board[find(0,board)] = n
--  for i=1 to n do
--       positions[board[i]] = i
--  end for
--  
--  -- check whether this is an even or odd state
--  bool even_state = (mod(positions[n],2) == 0)
--es = even_state
--  
--  -- count the even cycles
--  integer even_count = 0
--  for i=1 to length(positions) do
--      if not visited[i] then
--          -- a new cycle starts at i. Count its length..
--          integer cycle_length = 0, next_tile = i
--          while not visited[next_tile] do
--              cycle_length += 1 
--              visited[next_tile] = true
--              next_tile = positions[next_tile]
--          end while
--          even_count += (mod(cycle_length,2)==0)
--      end if
--  end for   
--  return even_state == (mod(even_count,2)==0)
--end function

function isSolvable(sequence board)
integer n = length(board)
sequence positions = repeat(0,n)
    -- prepare the mapping from each tile to its position
    board[find(0,board)] = n
    for i=1 to n do
--       positions[board[i]] = mod(i,16)
        positions[board[i]] = i
    end for
      
    -- check whether this is an even or odd state
    integer row = floor((positions[16]-1)/4),
            col = (positions[16]-1)-row*4
    bool isEvenState = (positions[16]==16) or (mod(row,2)==mod(col,2))
--es = isEvenState
      
    -- count the even cycles
    int evenCount = 0;
    sequence visited = repeat(false,16)
    for i=1 to n do
        if not visited[i] then
            -- a new cycle starts at i. Count its length..
            int cycleLength = 0;
            int nextTile = i;
            while not visited[nextTile] do
                cycleLength +=1
                visited[nextTile] = true;
                nextTile = positions[nextTile];
            end while
            evenCount += (mod(cycleLength,2)==0)
        end if
    end for
    return isEvenState == (mod(evenCount,2)==0)
end function


if 0 then
    for i=1 to 5555555 do {}=move(rand(4)) end for      -- (25% are likely invalid)
else
--  board = {15,14, 1, 6,
--            9,11, 4,12,
--            0,10, 7, 3,
--           13, 8, 5, 2}
--  board = {12,15, 6,10,
--            4, 9, 5, 8,
--           14,13, 0, 2,
--            1, 7,11, 3}
--  board = { 1, 2, 3, 4,
--            5, 6, 7, 8,
--            9,10,11,12,
--           13,14,15, 0}
----             13,14,0, 15}
--hard:
-- DOH, unsolvable!
--  board = { 2, 1, 3, 4,
--            5, 6, 7, 8,
--            9,10,11,12,
--           13,14,15, 0}
-- (but this /is/ solveable)
    board = { 0,12, 9,13,
             15,11,10,14,
              3, 7, 2, 5,
              4, 8, 6, 1}
-- unsolvable:
--  board = { 1, 2, 3, 4,
--            5, 6, 7, 8,
--            9,10,11,12,
--           13,15,14, 0}
-- 7 10 14 9 2 0 3 4 1 13 8 11 12 5 6 15
-- 2 1 3 4 5 6 7 8 9 10 11 12 13 14 15 0
-- 0 12 9 13 15 11 10 14 3 7 2 5 4 8 6 1
    pos = find(0,board)
end if
--?{"sign",sign(board)}
if 01 then -- good:
--  ?{"solveable",solveable(board),isSolvable(board)}
    ?{"solveable",isSolvable(board)}
--  bool s0=solveable(board)
    bool s0=isSolvable(board)
    for i=1 to 100 do 
        integer m = rand(4)
        {}=move(m)
--      bool s=solveable(board)
        bool s=isSolvable(board)
        ?{"solveable",s,board,m}
        if s!=s0 then ?9/0 end if
    end for

atom t0 = time()
    for i=1 to 10-00000 do
--      bool res = solveable(board)
        bool res = isSolvable(board)
    end for
    ?time()-t0

    if 01 then
        {} = wait_key()
        abort(0)
    end if
end if

atom t0 = time()
atom t1 = time()+1
integer pos0 = pos, s, valid, stick
sequence board0 = board, boards = {{0,score(board),{},board,pos}}, new_boards, moves
--?boards
integer active = new_dict(),
        visited = new_dict()
integer scr
?"one"
with trace
if 0 then -- new a* approach
--trace(1)
--umm... I think we need to store the (shortest) moves on visited.... and an active flag...
    moves = {}
    while 1 do
        setd(board,0,visited)
        sequence boardn = board
        integer posn = pos
        scr = 1
        for i=1 to 4 do
            {valid} = move(i)
            if valid then
                integer k = getd_index(board,visited)
                if k then
--                  {active,prev_moves} = getd_by_index(k,visited)
--                  k = 0
                end if                  
                if k=0 then
                    scr = manhattan(board)
                    if scr=0 then exit end if
                    scr += length(moves)+1
--                  integer scr = manhattan(board)+length(moves)+1
--                  object prev_moves = getd({score,board})
                    object prev_moves = getd({scr,board},active)
                    if sequence(prev_moves)
                    and length(prev_moves)<length(moves) then
                        -- keep old
--                      setd({?,board},prev_moves&
                    else
                        -- write/overwrite
                        setd({scr,board},moves&i,active)
                    end if
                end if
            end if
            if scr=0 then exit end if
            board = boardn
            pos = posn
        end for
        if scr=0 then exit end if
--DEV result of 0??
        sequence key = getd_partial_key({},active)
        board = key[2]
        pos = find(0,board)
        moves = getd(key,active)
        deld(key,active)
if time()>t1 then
    ?key[1]
    print_board(1)
    t1 = time()+1
end if
    end while
else -- old code:
setd(board,0,visited)
while 1 do
    new_boards = {}
    for i=1 to length(boards) do
--  for i=1 to min(100,length(boards)) do
        for c=1 to 4 do
            {?,?,moves,board,pos} = boards[i]
            {valid,stick} = move(c)
--?{valid,stick}
            if valid and getd_index(board,visited)=0 then
                moves &= c
                s = score(board)
                if s=0 then exit end if
--if s=290 then ?9/0 end if
--object key = getd_partial_key(object pkey, integer tid=1, bool rev=false) 
                new_boards = append(new_boards,{8-stick,s,moves,board,pos})
                setd(board,0,visited)
            end if
        end for
        if s=0 then exit end if
    end for

    if s=0 then exit end if
    if length(new_boards)=0 then ?9/0 end if
--?length(new_boards)
--  if length(new_boards)>16384*4 then
    if length(new_boards)>16384 then
        boards = sort(new_boards)[1..16384]
--      boards = sort(new_boards)
        integer dsv = dict_size(visited)
        {?,s,{},board,pos} = boards[1]
        lines[1] = sprintf("thinking... %d boards visited, best score: %d (0=solved):",{dsv,s})
--      integer trimmed = length(new_boards)-length(boards)
--      lines[1] = sprintf("thinking... %d boards visited (%d trimmed), best score: %d (0=solved):",{dsv,trimmed,s})
        print_board(1)
--  elsif length(boards)>100 then
--      boards = sort(new_boards&boards[101..$])
    else
        boards = sort(new_boards)
    end if
end while
end if

pos = pos0
board = board0
lines[1] = "solved!!:         "
print_board(0)
for i=1 to length(moves) do
    integer mi = moves[i]
    string m = udlr[mi]
    string this = sprintf("move %d, %s:",{i,m})
    lines[1] &= sprintf("%-18s",{this})
    moves[i] = upper(m[1])
    {} = move(mi)
    print_board(i=length(moves))
end for
printf(1,"solved in %d moves (%d boards visited, %s)\n",{length(moves),dict_size(visited),elapsed(time()-t0)})
printf(1,"moves: %s\n",{moves})

{} = wait_key()

--/*
--include <stdio.h>
--#include <math.h>
 
--#define N 4
constant N = 4
 
--//int search(int board[N][N], int min, int limit, int r_0, int c_0, char mv);
 
function search(sequence board, int min_, int limit, int r_0, int c_0, integer mv)
sequence md_c = repeat(min_,4),
         res = repeat(-1,4),
         op = {r_0-1,r_0+1,c_0-1,c_0+1},
--tryme:
--       op = {r_0,r_0+2,c_0,c_o+2},
         num = repeat(0,4)
string dirs = "nswe"

--?{"search",board,min_,limit,r_0,c_0,mv}
?{"search",min_,limit,r_0,c_0,mv}
 
  if min_==0 then return 0 end if
 
  if op[1]>=0 then
    if mv!='s' then
      num[1] = board[op[1]+1][c_0+1];
      md_c[1] -= floor(abs((num[1]-1)/N - op[1]))
      md_c[1] += floor(abs((num[1]-1)/N - r_0))
    end if
  end if
 
  if op[2]<=N-1 then
    if mv!='n' then
      num[2] = board[op[2]+1][c_0+1];
      md_c[2] -= floor(abs((num[2]-1)/N - op[2]))
      md_c[2] += floor(abs((num[2]-1)/N - r_0))
    end if
  end if
 
  if op[3]>=0 then
    if mv!='e' then
      num[3] = board[r_0+1][op[3]+1];
      md_c[3] -= floor(abs(mod(num[3]-1,N) - op[3]))
      md_c[3] += floor(abs(mod(num[3]-1,N) - c_0))
    end if
  end if
 
  if op[4]<=N-1 then
    if mv!='w' then
      num[4] = board[r_0+1][op[4]+1];
      md_c[4] -= floor(abs(mod(num[4]-1,N) - op[4]))
      md_c[4] += floor(abs(mod(num[4]-1,N) - c_0))
    end if
  end if
 
  for i=1 to 4 do
    if md_c[i] - min_ == -1 then
      if (floor((i-1) / 2) == 0) then
        board[op[i]+1][c_0+1] = 0;
        board[r_0+1][c_0+1] = num[i];
        res[i] = search(board, md_c[i], limit-1, op[i], c_0, dirs[i]);
        if res[i] == -1 then
            board[op[i]+1][c_0+1] = num[i]
            board[r_0+1][c_0+1] = 0;
        else
            res[i] += 1
        end if
      else
        board[r_0+1][op[i]+1] = 0
        board[r_0+1][c_0+1] = num[i];
        res[i] = search(board, md_c[i], limit-1, r_0, op[i], dirs[i]);
        if res[i] == -1 then
            board[r_0+1][op[i]+1] = num[i]
            board[r_0+1][c_0+1] = 0;
        else
            res[i] += 1
        end if
      end if
    end if
    if res[i] != -1 then exit end if
  end for
 
  for i=1 to 4 do
    if md_c[i] - min_ == 1 then
      if md_c[i] <= limit - 1 then
        if (floor((i-1) / 2) == 0) then
          board[op[i]+1][c_0+1] = 0
          board[r_0+1][c_0+1] = num[i]
          res[i] = search(board, md_c[i], limit-1, op[i], c_0, dirs[i])
          if res[i] == -1 then
            board[op[i]+1][c_0+1] = num[i]
            board[r_0+1][c_0+1] = 0
          else
            res[i] += 1
          end if
        else
          board[r_0+1][op[i]+1] = 0
          board[r_0+1][c_0+1] = num[i]
          res[i] = search(board, md_c[i], limit-1, r_0, op[i], dirs[i])
          if res[i] == -1 then
            board[r_0+1][op[i]+1] = num[i]
            board[r_0+1][c_0+1] = 0
          else
            res[i] += 1
          end if
        end if
      else
        res[i] = -1
      end if
    end if
  end for
--  if (res[0] == -1 && res[1] == -1 && res[2] == -1 && res[3] == -1) return -1;
--  else if (res[0] != -1) return res[0];
--  else if (res[1] != -1) return res[1];
--  else if (res[2] != -1) return res[2];
--  else return res[3];
  for i=1 to 4 do
    integer ri = res[i]
    if ri!=-1 then return ri end if
  end for
  return -1
end function
 
 
--int main(int argc, char *argv[]){
procedure main()
sequence board = repeat(repeat(0,N),N)
  int md;
  int i, j, r, c, r_0, c_0, found;
  int res;
 
--  for (i=0; i<N; i++) {
--  for (j=0; j<N; j++) scanf("%d", &board[i][j]);
--  }
-- 
    board = {{ 1, 6,15, 0},
             {14,11, 5, 7},
             {10, 9, 8, 3},
             { 2,13,12, 4}}

  md = 0;
  for i=1 to N*N do
    found = 0;
    for r=1 to N do
      for c=1 to N do
        if board[r][c] == i-1 then
          if i=1 then
            r_0 = r-1;
            c_0 = c-1;
          else
            md += floor(abs(floor((i-2)/N) - r)) + floor(abs(mod(i-2,N) - c))
          end if
          found = 1;
          exit
        end if
      end for
      if (found == 1) then exit end if
    end for
  end for
 
--  for (i=0; ; i+=2) {
  i = 0
  while 1 do
--  if ((r_0 + c_0) % 2 == 0) {
--    if (md % 2 == 0) res = search(board, md, md+i, r_0, c_0, 'c');
--    else res = search(board, md, md+i+1, r_0, c_0, 'c');
--    } else {
--      if (md % 2 == 0) res = search(board, md, md+i+1, r_0, c_0, 'c');
--      else res = search(board, md, md+i, r_0, c_0, 'c');
--    }
--PL
    j = i+(mod(r_0+c_0,2)=mod(md,2))
    res = search(board,md,md+j,r_0,c_0,'c')
    if res!=-1 then exit end if
    i += 2
  end while
 
  printf(1,"%d\n", res);
 
end procedure
main()

Another failed attempt:
=======================
--with trace
--?factorial(10)
--?factorial(3)
--?factorial(2)
--?"=="
--?k_perm(10,3)
--?choose(10,3)
--?k_perm(3,2)
--?choose(3,2)
--?k_perm(3,10)
--?choose(3,10)
--?k_perm(2,3)
--?choose(2,3)
--function permutes(sequence set)
--sequence res = repeat(0,factorial(length(set)))
--  for i=1 to length(res) do
--      res[i] = permute(i,set)
--  end for
--  return res
--end function
--?permutes("abcd")
--?length(permutes("abcd"))
--?k_perm(20,4)

--?choose(16,3) -- 560  -- that might fly...
--?choose(16,4) -- 1820 -- that might fly...
--?choose(16,5) -- 4368 -- that might fly...
--?choose(16,6) -- 8008 -- that might fly...
--?choose(16,4)*choose(12,4)*choose(8,4)*choose(4,4)    -- 63063000
-- (a tad too many for the number of patterns!)
--?choose(4,4)  -- 1

--/*
sequence ptz = {},
         p0 = repeat(15,4)&repeat(0,12),
         found = repeat(false,16)
integer fc = 0
    while fc<16 do
        sequence p1 = shuffle(p0)
        if not find(p1,ptz) then
            ptz = append(ptz,p1)
            for i=1 to 16 do
                if p1[i]=15 and not found[i] then
                    found[i] = true
                    fc += 1
                end if
            end for
        end if
    end while
?length(ptz)
pp(ptz)
--*/
--/*
12
{{0,0,0,0,0,0,0,0,15,0,0,15,15,0,0,15},
 {0,0,0,0,15,0,0,0,0,15,15,0,0,15,0,0},
 {0,0,0,15,0,0,0,0,0,15,0,15,15,0,0,0},
 {15,0,0,0,0,0,0,0,15,0,0,0,0,15,15,0},
 {0,0,0,0,0,0,0,0,15,0,15,15,15,0,0,0},
 {0,0,15,0,0,0,15,0,15,0,0,0,0,0,0,15},
 {0,0,0,0,15,0,0,0,0,15,15,0,15,0,0,0},
 {0,0,0,15,0,15,0,15,0,0,0,0,15,0,0,0},
 {0,0,15,15,0,0,0,0,0,0,0,15,0,0,15,0},
 {15,0,15,0,0,0,0,0,0,0,15,0,15,0,0,0},
 {15,0,0,0,0,15,0,0,0,15,0,0,0,0,15,0},
 {15,15,0,0,0,0,15,0,0,0,0,0,0,15,0,0}}
--*/

-- pattern databases...
-- xxxxx0000000000-
-- 00000xxxxx00000-
-- 0000000000xxxxx-
-- 122211331133133-
--
-- 1111122222333333: (556)
-- 1111
-- 1222
-- 2233
-- 3333
--
-- 1231231231231231: (655)
-- 1231
-- 2312
-- 3123
-- 1231
--
-- 1231212332121321: (664)
-- 1231
-- 2123
-- 3212
-- 1321
--?{1,factorial(16)/factorial(15),power(16,16)}
--?{2,factorial(16)/factorial(14),power(16*15,8)}
--?{3,factorial(16)/factorial(13),power(16*15*14,5)}
--?{4,factorial(16)/factorial(12),power(16*15*14*13,4)}
--?{5,factorial(16)/factorial(11),power(16*15*14*13*12,3)}
--?{6,factorial(16)/factorial(10),power(16*15*14*13*12*11,2)*4*3*2*1}
--?524160+2*5765760 -- 12055680
--?16*15*14*13*12*23
-- Bisect Method: 
-- Rather than build a complete pattern database (12,055,680 entries) at the start,
-- it alternates between building patterns and searching for solutions. This works
-- because if we build all patterns that are one step away and then search for all
-- solutions that are one step away, we can dismiss any missing patterns as being
-- 2 or more steps away.
-- ??? For mtm, diagonal patterns (seem to) perform much better than square block patterns.... (he says hopefully)

-- 1111122222333333: (556)
?"556"
constant patterns = {{15,15,15,15,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                     { 0, 0, 0, 0, 0,15,15,15,15,15, 0, 0, 0, 0, 0, 0},
                     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15,15,15,15,15,15}}
-- 1231231231231231: (655)
--constant patterns = {{15, 0, 0,15, 0, 0,15, 0, 0,15, 0, 0,15, 0, 0,15},
--                   { 0,15, 0, 0,15, 0, 0,15, 0, 0,15, 0, 0,15, 0, 0},
--                   { 0, 0,15, 0, 0,15, 0, 0,15, 0, 0,15, 0, 0,15, 0}}
-- 1231212332121321: (664)
--constant patterns = {{15, 0, 0,15, 0,15, 0, 0, 0, 0,15, 0,15, 0, 0,15},
--                   { 0,15, 0, 0,15, 0,15, 0, 0,15, 0,15, 0, 0,15, 0},
--                   { 0, 0,15, 0, 0, 0, 0,15,15, 0, 0, 0, 0,15, 0, 0}}
-- 4444(l)
--constant patterns = {{15,15,15,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
--                   { 0, 0, 0, 0,15,15,15,15, 0, 0, 0, 0, 0, 0, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0,15,15,15,15, 0, 0, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15,15,15,15}}
-- 4444(s)
--constant patterns = {{15,15, 0, 0,15,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
--                   { 0, 0,15,15, 0, 0,15,15, 0, 0, 0, 0, 0, 0, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0, 0,15,15, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0, 0,15,15}}
--88(h)
--constant patterns = {{15,15,15,15,15,15,15,15, 0, 0, 0, 0, 0, 0, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0,15,15,15,15,15,15,15,15}}
--88(odd)
--constant patterns = {{15,15,15,15, 0, 0, 0, 0,15,15,15,15, 0, 0, 0, 0},
--                   { 0, 0, 0, 0,15,15,15,15, 0, 0, 0, 0,15,15,15,15}}
--88(v)
--constant patterns = {{15,15, 0, 0,15,15, 0, 0,15,15, 0, 0,15,15, 0, 0},
--                   { 0, 0,15,15, 0, 0,15,15, 0, 0,15,15, 0, 0,15,15}}
--88(checkerboard)
--constant patterns = {{15, 0,15, 0,15, 0,15, 0,15, 0,15, 0,15, 0,15, 0},
--                   { 0,15, 0,15, 0,15, 0,15, 0,15, 0,15, 0,15, 0,15}}
--16 (killed at 1.6GB mem)
--constant patterns = {{15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15}}
--8 (crashes unless maxk check and goal, plus I expect that is not enuf - killed) 
--constant patterns = {{15,15,15,15,15,15,15,15, 0, 0, 0, 0, 0, 0, 0, 0}}
--33334
--  1122
--  1552
--  3554
--  3344
--?"33334"
--constant patterns = {{15,15, 0, 0,15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
--                   { 0, 0,15,15, 0, 0, 0,15, 0, 0, 0, 0, 0, 0, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0,15, 0, 0, 0,15,15, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, 0, 0,15,15},
--                   { 0, 0, 0, 0, 0,15,15, 0, 0,15,15, 0, 0, 0, 0, 0}}
--754:
--  1111
--  1222
--  1233
--  1233
--?"754"
--constant patterns = {{15,15,15,15,15, 0, 0, 0,15, 0, 0, 0,15, 0, 0, 0},
--                   { 0, 0, 0, 0, 0,15,15,15, 0,15, 0, 0, 0, 0, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15, 0, 0},
--                   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0, 0,15,15}}
--664d:
--  1231
--  2123
--  3212
--  1321
--?"664d"
--constant patterns = {{15, 0, 0,15, 0,15, 0, 0, 0, 0,15, 0,15, 0, 0,15},
--                   { 0,15, 0, 0,15, 0,15, 0, 0,15, 0,15, 0, 0,15, 0},
--                   { 0, 0,15, 0, 0, 0, 0,15,15, 0, 0, 0, 0,15, 0, 0}}

--?"r12" (killed, though mem use seemed ok)
--constant patterns =
--{{0,0,0,0,0,0,0,0,15,0,0,15,15,0,0,15},
-- {0,0,0,0,15,0,0,0,0,15,15,0,0,15,0,0},
-- {0,0,0,15,0,0,0,0,0,15,0,15,15,0,0,0},
-- {15,0,0,0,0,0,0,0,15,0,0,0,0,15,15,0},
-- {0,0,0,0,0,0,0,0,15,0,15,15,15,0,0,0},
-- {0,0,15,0,0,0,15,0,15,0,0,0,0,0,0,15},
-- {0,0,0,0,15,0,0,0,0,15,15,0,15,0,0,0},
-- {0,0,0,15,0,15,0,15,0,0,0,0,15,0,0,0},
-- {0,0,15,15,0,0,0,0,0,0,0,15,0,0,15,0},
-- {15,0,15,0,0,0,0,0,0,0,15,0,15,0,0,0},
-- {15,0,0,0,0,15,0,0,0,15,0,0,0,0,15,0},
-- {15,15,0,0,0,0,15,0,0,0,0,0,0,15,0,0}}
--


integer plim,slim       -- set in main loop

constant patdb = new_dict("patdb")  -- lookup table, data is walking distance.

sequence puzzle

constant USETODO = 0

integer todo = new_dict("todo")
integer tdnx = new_dict("tdnx")

procedure set_distance(integer mv)
bool already_added = false
    for i=1 to length(patterns) do
        sequence key = sq_and_bits(puzzle,patterns[i])
        integer k = getd_index(key,patdb)
        if k=0 then
if USETODO then
            setd(key,plim+1,patdb)
            if not already_added then
                setd(puzzle,mv,tdnx)
                already_added = true
            end if
else
            setd(key,plim,patdb)
end if
        end if
    end for
end procedure

function distance_check(integer step)
integer maxk = 0
    for i=1 to length(patterns) do
        sequence key = sq_and_bits(puzzle,patterns[i])
        integer k = getd_index(key,patdb)
        k = iff(k=0?plim+1:getd_by_index(k,patdb))
        if k+step>slim then return -1 end if
        maxk = max(maxk,k)
    end for
    return maxk
end function

constant STM = 0    -- single-tile metrics.
constant MTM = 0    -- multi-tile metrics.
--if STM and MTM then ?9/0 end if -- both prohibited
--  0       0   -- fastest, but non-optimal
--  1       0   -- optimal in STM
--  0       1   -- optimal in MTM (slowest by far)

--Note: The fast method uses an inadmissible heuristic - see "not STM" in iddfs().
--      It explores mtm-style using the higher stm heuristic and may therefore 
--      fail badly in some cases.

--constant SIZE = 4

constant goal = { 1, 2, 3, 4,
                  5, 6, 7, 8,
                  9,10,11,12,
                 13,14,15, 0}

--
-- multi-tile-metric walking distance heuristic lookup (mmwd).
-- ==========================================================
-- Uses patterns of counts of tiles in/from row/col, eg the solved state 
--  (ie goal above) could be represented by the following:
--      {{4,0,0,0},
--       {0,4,0,0},
--       {0,0,4,0},
--       {0,0,0,3}}
--  ie row/col 1 contains 4 tiles from col/row 1, etc. In this case
--  both are identical, but you can count row/col or col/row, and then
--  add them together. There are up to 24964 possible patterns. The
--  blank space is not counted. Note that a vertical move cannot change
--  a vertical pattern, ditto horizontal, and basic symmetry means that
--  row/col and col/row patterns will match (at least, that is, if they 
--  are calculated sympathetically), halving the setup cost.
-- The data is just the number of moves made before this pattern was
--  first encountered, in a breadth-first search, backwards from the
--  goal state, until all patterns have been enumerated.
-- (The same ideas/vars are now also used for stm metrics when MTM=0)
--
--sequence wdkey                -- one such 4x4 pattern
--constant mmwd = new_dict()    -- lookup table, data is walking distance.


--
-- We use two to-do lists: todo is the current list, and everything
-- of walkingdistance+1 ends up on tdnx. Once todo is exhausted, we
-- swap the dictionary-ids, so tdnx automatically becomes empty.
-- Key is an mmwd pattern as above, and data is {distance,space_idx}.
--
--integer todo = new_dict()
--integer tdnx = new_dict()

--

string res = ""
atom setup_time = 0,
     search_time = 0
atom t0 = time(),
     t1 = time()+1
atom tries = 0

constant ok = {{0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1},   -- left
               {0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1},   -- up
               {1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0},   -- down
               {1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0}}   -- right

procedure explore(integer space, integer mv)
    integer nspace = space+{-1,-4,+4,+1}[mv]
    integer tile = puzzle[nspace]
    if puzzle[space]!=0 then ?9/0 end if    -- sanity check     
    puzzle[space] = tile
    puzzle[nspace] = 0
    set_distance(mv)
    if ok[mv][nspace] then
        explore(nspace,mv)
    end if
    puzzle[nspace] = tile
    puzzle[space] = 0
end procedure   

--NO, this has to work off a todo list...
procedure set_patterns(integer step, space, prevmv)
if USETODO then
--DEV prevmv and space can/shd become locals, step no longer rqd...
    while dict_size(todo)>0 do
        puzzle = getd_partial_key(0,todo)
        prevmv = getd(puzzle,todo)
        deld(puzzle,todo)
        space = find(0,puzzle)
        for mv=1 to 4 do
            if prevmv!=(5-mv) -- not l after r or vice versa, ditto u/d
            and ok[mv][space] then
                explore(space,mv)
            end if
        end for
    end while
    {todo,tdnx} = {tdnx,todo}
--      
else
    if time()>t1 then
        printf(1,"working(set)... (depth=%d, tries=%d, time=%3ds)\r",{plim,tries,setup_time+time()-t0})
        t1 = time()+1
    end if
    tries += 1

    if step=plim then set_distance(0) end if
    for mv=1 to 4 do -- l/u/d/r
        if prevmv!=(5-mv) -- not l after r or vice versa, ditto u/d
        and ok[mv][space]
        and step+(prevmv!=mv)<=plim then
            integer nspace = space+{-1,-4,+4,+1}[mv]
            integer tile = puzzle[nspace]
            if puzzle[space]!=0 then ?9/0 end if    -- sanity check     
            puzzle[space] = tile
            puzzle[nspace] = 0
            set_patterns(step+(prevmv!=mv),nspace,mv)
            puzzle[nspace] = tile
            puzzle[space] = 0
        end if
    end for
end if
end procedure

function iddfs(integer step, space, prevmv)
    if time()>t1 then
        printf(1,"working... (depth=%d, tries=%d, time=%3ds)\r",{slim,tries,search_time+time()-t0})
        t1 = time()+1
    end if
    tries += 1
    integer maxk = distance_check(step)
    if maxk<=0 then
--  integer d = iff(step==slim?0:walking_distance(puzzle))
--  if d=0 then

--      return (puzzle==goal)
if maxk=0 then
    if puzzle!=goal then ?9/0 end if
end if
        return maxk=0
--      return maxk=0 and puzzle=goal
    end if
--  elsif step+d<=slim then

    for mv=1 to 4 do -- l/u/d/r
        if prevmv!=(5-mv) -- not l after r or vice versa, ditto u/d
        and ok[mv][space]
        and step+(prevmv!=mv)<=slim then
        integer nspace = space+{-1,-4,+4,+1}[mv]
            integer tile = puzzle[nspace]
            if puzzle[space]!=0 then ?9/0 end if    -- sanity check     
            puzzle[space] = tile
            puzzle[nspace] = 0
            if iddfs(step+(prevmv!=mv),nspace,mv) then
                res &= "ludr"[mv]
                return true
            end if
            puzzle[nspace] = tile
            puzzle[space] = 0
        end if
    end for
--  end if
    return false
end function

function pack(string s)
integer n = length(s), n0 = n
    for i=1 to 4 do
        integer ch = "lrud"[i], k
        while 1 do
            k = match(repeat(ch,3),s)
            if k=0 then exit end if
            s[k+1..k+2] = "3"
            n -= 2
        end while
        while 1 do
            k = match(repeat(ch,2),s)
            if k=0 then exit end if
            s[k+1] = '2'
            n -= 1
        end while
    end for
    return {n,iff(MTM?sprintf("%d",n):sprintf("%d(%d)",{n,n0})),s}
end function

procedure apply_moves(string moves, integer space)
integer move, ch, nspace
    puzzle[space] = 0
    for i=1 to length(moves) do
        ch = moves[i]
        if ch>'3' then
            move = find(ch,"ulrd")
        end if
        -- (hint: "r" -> the 'r' does 1
        --        "r2" -> the 'r' does 1, the '2' does 1
        --        "r3" -> the 'r' does 1, the '3' does 2!)
        for j=1 to 1+(ch='3') do
            nspace = space+{-4,-1,+1,4}[move]
            puzzle[space] = puzzle[nspace]
            space = nspace
            puzzle[nspace] = 0
        end for
    end for
end procedure

function solvable(sequence board)
integer n = length(board)
sequence positions = repeat(0,n)
    -- prepare the mapping from each tile to its position
    board[find(0,board)] = n
    for i=1 to n do
        positions[board[i]] = i
    end for
      
    -- check whether this is an even or odd state
    integer row = floor((positions[16]-1)/4),
            col = (positions[16]-1)-row*4
    bool even_state = (positions[16]==16) or (mod(row,2)==mod(col,2))
      
    -- count the even cycles
    integer even_count = 0
    sequence visited = repeat(false,16)
    for i=1 to n do
        if not visited[i] then
            -- a new cycle starts at i. Count its length..
            integer cycle_length = 0,
                    next_tile = i
            while not visited[next_tile] do
                cycle_length +=1
                visited[next_tile] = true
                next_tile = positions[next_tile]
            end while
            even_count += (mod(cycle_length,2)==0)
        end if
    end for
    return even_state == (mod(even_count,2)==0)
end function

procedure main()

    puzzle = {15,14, 1, 6, 
               9,11, 4,12,
               0,10, 7, 3, 
              13, 8, 5, 2}
--556
--{0,3}
--{1,11}
--{2,35}
--{3,93}
--{4,220}
--{5,544}
--{6,1325}
--{7,3156}
--{8,7239}
--{9,15861}
--{10,32596}
--{11,64126}
--{12,118584}
--{13,208550}
--{14,345374}
--{15,549256}
--working(set)... (depth=16, tries=365865042, time=1323s)
--{16,838757}
--working... (depth=32, tries=374205743, time=1249s)
--original:{15,14,1,6,9,11,4,12,0,10,7,3,13,8,5,2}
--non-optimal solution of 31(60) moves found in setup 22 minutes and 04s, search 20 minutes and 50s: u2r2d3ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2


--puzzle = {14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}
--556
--{0,3}
--{1,11}
--{2,35}
--{3,93}
--{4,220}
--{5,544}
--{6,1325}
--{7,3156}
--{8,7239}
--{9,15861}
--{10,32596}
--{11,64126}
--{12,118584}
--{13,208550}
--{14,345374}
--{15,549256}
--{16,838757}
--{17,1238295}
--working(set)... (depth=18, tries=3294456626, time=11476s)
--{18,1748892}
--working... (depth=37, tries=5679731954, time=28379s)
--original:{14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4}
--non-optimal solution of 36(75) moves found in setup 3 hours, 11 minutes and 16s, search 7 hours, 53 minutes: u2l3d2ru2ld3r3u3l3d2r3dl2u3ld3r2u3rd3lu3rd2l3urd2ru3rdl3d2r3

--puzzle = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0}  -- Solution of 0 moves found in 1.69s:
--puzzle = {1,2,3,4,5,6,7,8,9,10,11,0,13,14,15,12}  -- Solution of 1 moves found in 1.67s:d
--puzzle = {1,2,3,4,5,6,7,8,9,0,10,11,13,14,15,12}  -- Solution of 2 moves found in 2.11s:r2d
--puzzle = {1,2,3,4,5,6,7,8,9,14,10,11,13,0,15,12}  -- Solution of 3 moves found in 2.11s:ur2d
--puzzle = {1,2,3,4,5,6,7,8,9,14,10,11,0,13,15,12}  -- Solution of 4 moves found in 1.70s:rur2d
--puzzle = {1,2,3,4,5,6,7,8,0,14,10,11,9,13,15,12}  -- Solution of 5 moves found in 1.64s:drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,10,0,11,9,13,15,12}  -- Solution of 6 moves found in 1.91s:l2drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,10,15,11,9,13,0,12}  -- Solution of 7 moves found in 1.98s:ul2drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,10,15,11,9,0,13,12}  -- Solution of 8 moves found in 1.84s:rul2drur2d
--puzzle = {1,2,3,4,5,6,7,8,14,0,15,11,9,10,13,12}  -- Solution of 9 moves found in 1.89s:drul2drur2d
--/* oops..
{0,3}
{1,11}
{2,35}
{3,93}
{4,220}
{5,544}
{6,1325}
{7,3156}
{8,7239}
{9,15861}
original:{1,2,3,4,5,6,7,8,14,0,15,11,9,10,13,12}

non-optimal solution of 14(21) moves found in 0.80s: lu2rd3rulu2ld3rur2d

result: {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0}

--without odd/even stuff:
{9,15861}
working(set)... (depth=10, tries=242815, time=  2s)
{10,32596}
original:{1,2,3,4,5,6,7,8,14,0,15,11,9,10,13,12}

non-optimal solution of 9(11) moves found in 2.19s: drul2drur2d

result: {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0}
--*/
--puzzle = {1,2,3,4,5,6,7,8,14,15,11,0,9,10,13,12}  -- Solution of 10 moves found in 2.19s:l2drul2drur2d
--puzzle = {1,2,3,4,5,6,7,0,14,15,11,8,9,10,13,12}  -- Solution of 11 moves found in 2.12s:dl2drul2drur2d
--ok, but 17 secs to build patdb... (not any more!)
--p1 with o/e:
--{6,1325}
--non-optimal solution of 11(14) moves found in setup 0.03s, search 0.02s: dl2drul2drur2d
--p1 with todo:
--{6,1325}
--non-optimal solution of 11(14) moves found in setup 0.02s, search 0.05s: dl2drul2drur2d

--p1 w/o o/e:
--{9,15861}
--{10,32596}
--{11,64126}
--{12,118584}
--non-optimal solution of 11(14) moves found in setup 17.53s, search 0s: dl2drul2drur2d

--puzzle = {1,2,3,4,0,5,6,7,14,15,11,8,9,10,13,12}  -- Solution of 12 moves found in 2.03s:r3dl2drul2drur2d
--puzzle = {1,2,3,4,14,5,6,7,0,15,11,8,9,10,13,12}  -- Solution of 13 moves found in 2.12s:ur3dl2drul2drur2d
--puzzle = {1,2,3,4,14,5,6,7,15,11,8,0,9,10,13,12}  -- Solution of 14 moves found in 2.03s:l3ur3dl2drul2drur2d
--p2 w/o o/e:
--{0,3}
--{1,15}
--{2,50}
--{3,150}
--{4,415}
--{5,1121}
--{6,2781}
--{7,6561}
--{8,14424}
--{9,29923}
--{10,58987}
--{11,109897}
--{12,194407}
--{13,330952}
--{14,536914}
--{15,837244}
--non-optimal solution of 14(21) moves found in setup 8 minutes and 23s, search 0s: l3ur3dl2drul2drur2d
--p2 with o/e:
--{7,6561}
--non-optimal solution of 14(21) moves found in setup 0.11s, search 0.13s: l3ur3dl2drul2drur2d

--puzzle = {1,2,3,4,14,5,6,0,15,11,8,7,9,10,13,12}  -- Solution of 15 moves found in 2.11s:dl3ur3dl2drul2drur2d
--puzzle = {1,2,3,4,14,5,0,6,15,11,8,7,9,10,13,12}  -- Solution of 16 moves found in 2.27s:rdl3ur3dl2drul2drur2d
--puzzle = {1,2,0,4,14,5,3,6,15,11,8,7,9,10,13,12}  -- Solution of 17 moves found in 2.61s:drdl3ur3dl2drul2drur2d
--puzzle = {1,0,2,4,14,5,3,6,15,11,8,7,9,10,13,12}  -- Solution of 18 moves found in 3.33s:rdrdl3ur3dl2drul2drur2d
--puzzle = {1,5,2,4,14,11,3,6,15,10,8,7,9,0,13,12}  -- {"solution found","uuurdrdlllurrrdlldrulldrurrd",74.453}     -- (19 moves)
                                                    -- Solution of 18 moves found in 3.31s:rul2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {1,5,2,4,14,11,3,6,15,10,8,7,9,13,0,12}  -- {"solution found","ulldruuurdddlluurrrdllldruurrdd",27.594}  -- (17 moves!)
                                                    -- Solution of 17 moves found in 2.45s:ul2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {1,5,0,4,14,11,2,6,15,10,3,7,9,13,8,12}  -- {"solution found","ddlldruuurdddlluurrrdllldruurrdd",25.579} -- (18 moves)
                                                    -- Solution of 17 moves found in 2.41s:d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {0,1,5,4,14,11,2,6,15,10,3,7,9,13,8,12}  -- {"solution found","rrddlldruuurdddlluurrrdllldruurrdd",63.532}   -- (19 moves)
                                                    -- Solution of 18 moves found in 2.62s:r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,5,4,15,11,2,6,9,10,3,7,0,13,8,12}  -- {"solution found","uuurrddlldruuurdddlluurrrdllldruurrdd",81.047}    -- (20 moves)
                                                    -- Solution of 19 moves found in 2.62s:u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,5,4,15,11,2,6,9,10,3,7,13,8,0,12}  -- Solution of 20 moves found in 2.81s:l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,0,4,15,11,5,6,9,10,2,7,13,8,3,12}  -- Solution of 21 moves found in 4.80s:d3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,0,15,11,5,6,9,10,2,7,13,8,3,12}  -- Solution of 22 moves found in 7.19s:ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,5,7,9,10,2,12,13,8,3,0}  -- Solution of 23 moves found in 29.39s:u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--p1 with o/e:
--{12,118584}
--non-optimal solution of 23(46) moves found in setup 17.41s, search 21.22s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--same with todo...
--p2:42s
--p2 with odd/even:
--{0,3}
--{1,15}    -- oh... (DOH, different pattern!)
--{2,50}
--{3,150}
--{4,415}
--{5,1121}
--{6,2781}
--{7,6561}
--{8,14424}
--{9,29923}
--{10,58987}
--{11,109897}
--{12,194407}
--non-optimal solution of 23(46) moves found in setup 20.03s, search 22.14s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--p3 with o/e:
--{12,308210}
--non-optimal solution of 23(46) moves found in setup 22.19s, search 21.80s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2

--p1 with todo and o/e:
--{0,11}
--{1,35}
--{2,93}
--{3,219}
--{4,474}
--{5,994}
--{6,1928}
--{7,3621}
--{8,6330}
--{9,10616}
--{10,17074}
--{11,26742}
--{12,40128}
--{13,58460}
--non-optimal solution of 23(46) moves found in setup 3.38s, search 2 minutes and 08s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
-- p1 without todo and o/e
--{0,3}
--{1,11}
--{2,35}
--{3,93}
--{4,220}
--{5,544}
--{6,1325}
--{7,3156}
--{8,7239}
--{9,15861}
--{10,32596}
--{11,64126}
--{12,118584}
--non-optimal solution of 23(46) moves found in setup 17.45s, search 21.27s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
-- with one extra step...
--{12,118584}
--non-optimal solution of 23(46) moves found in setup 17.59s, search 14.25s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
-- with two extra steps...
--{13,208550}
--non-optimal solution of 23(46) moves found in setup 53.66s, search 7.61s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
-- with three extra steps...
--{13,208550}
--non-optimal solution of 23(46) moves found in setup 51.30s, search 4.95s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
-- with four extra steps...
--{14,345374}
--non-optimal solution of 23(46) moves found in setup 2 minutes and 32s, search 2.52s: u3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2


--puzzle = {14,1,4,6,15,11,5,7,9,10,2,12,13,8,0,3}  -- Solution of 24 moves found in 1 minute and 29s:ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--556
--non-optimal solution of 24(47) moves found in setup 15.86s, search 38.36s: ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2

--puzzle = {14,1,4,6,15,11,0,7,9,10,5,12,13,8,2,3}  -- Solution of 25 moves found in 2 minutes and 51s:d2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,7,0,9,10,5,12,13,8,2,3}  -- Solution of 26 moves found in 275.62s:ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,7,12,9,10,5,3,13,8,2,0}  -- Solution of 27 moves found in 936.36s:u2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,4,6,15,11,7,12,9,10,5,3,13,8,0,2}  -- Solution of 28 moves found in 47 minutes and 12s:ru2ld2ru3ld3l2u3r2d2l2dru3rd3l2u2r3dl3dru2r2d2
--puzzle = {14,1,0,6,15,11,4,12,9,10,7,3,13,8,5,2}  -- 
--puzzle = {0,14,1,6,15,11,4,12,9,10,7,3,13,8,5,2}  -- 


--puzzle = {13,10,11,6,5,3,1,4,8,0,12,2,14,7,9,15} --  0.25s  33 (53) [45]  lu2r2dlur2d2l3u2r2d3l2ur2ul2drur2uld3lu3r2dldldr2
--was: mtm-optimal solution of 30 moves found in 2 hours, 13 minutes and 18s: lu2r2d2l2u2r3dl3ur2d3l2ur3ul3drurd2ru3ld2lu2r2d3
--new (without todo)
--non-optimal solution of 30(55) moves found in setup 7 minutes and 40s, search 11 minutes and 12s: lu2r2d2l2u2r3dl3ur2d3l2ur3ul3drurd2ru3ld2lu2r2d3
-- with four extra steps...
--working(set)... (depth=17, tries=587835233, time=4098s)
--{17,1238295}
--non-optimal solution of 30(55) moves found in setup 1 hour, 8 minutes and 19s, search 1 minute and 35s: lu2r2d2l2u2r3dl3ur2d3l2ur3ul3drurd2ru3ld2lu2r2d3

--puzzle = {9,2,15,13,7,4,12,6,8,1,0,14,5,10,3,11} --   1.03s  38 (68) [54]  dru3l2d2r2u2l2d2r2ul3d2r3u2l3dr2u2rdl3ur3dl3drdlu2r2dl2urd2r2
--{0,3}
--{1,11}
--{2,35}
--{3,93}
--{4,220}
--{5,544}
--{6,1325}
--{7,3156}
--{8,7239}
--{9,15861}
--{10,32596}
--{11,64126}
--{12,118584}
--{13,208550}
--{14,345374}
--{15,549256}
--{16,838757}
--working(set)... (depth=17, tries=1098814746, time=4113s)
--{17,1238295}
--working... (depth=34, tries=1099338449, time=3955s)
--non-optimal solution of 33(68) moves found in setup 1 hour, 8 minutes and 34s, search 1 hour, 5 minutes and 56s: l2u2rd2lu2rd2r2u2ld3l2ur3ul2d2r2u3l3d2r2dru3l2d3r2u3l3d3r3

--puzzle = {4,8,7,12,5,0,13,15,9,1,6,3,11,14,10,2} --   0.28s  34 (56) [48]  dru2l2d3r3u3l2d2rdru3ld3l2urdlu3r2d2lu2rdld2ruldr2
--4444(l) [I think]
--{0,4}
--{1,13}
--{2,40}
--{3,97}
--{4,214}
--{5,465}
--{6,998}
--{7,2090}
--{8,4008}
--{9,7341}
--{10,12842}
--{11,20704}
--{12,31464}
--{13,45169}
--working(set)... (depth=14, tries=40792071, time=193s)
--{14,62276}
--working... (depth=29, tries=68512690, time=476s)
--non-optimal solution of 28(52) moves found in setup 3 minutes and 14s, search 7 minutes and 57s: dru2l2d2r2dl2ur3dl2ur2u2l2d2rdl2u3rd3r2u3l2d3r2
--4444(s) [I think]
--{12,21531}
--{13,34145}
--working(set)... (depth=14, tries=40676009, time=197s)
--{14,50605}
--working... (depth=29, tries=67256849, time=438s)
--non-optimal solution of 28(52) moves found in setup 3 minutes and 17s, search 7 minutes and 19s: dru2l2d2r2dl2ur3dl2ur2u2l2d2rdl2u3rd3r2u3l2d3r2
--88(cb)
--{0,2}
--{1,11}
--{2,38}
--{3,119}
--{4,362}
--{5,1061}
--{6,3051}
--{7,8481}
--{8,22853}
--{9,59282}
--{10,149662}
--{11,365022}
--{12,862272}
--{13,1957945}
--working(set)... (depth=14, tries=40576112, time=219s)
--{14,4281647}
--working... (depth=29, tries=66576470, time=266s)
--non-optimal solution of 28(52) moves found in setup 3 minutes and 40s, search 4 minutes and 26s: dru2l2d2r2dl2ur3dl2ur2u2l2d2rdl2u3rd3r2u3l2d3r2
--88(h)
--{0,2}
--{1,9}
--{2,30}
--{3,81}
--{4,198}
--{5,501}
--{6,1255}
--{7,3200}
--{8,7921}
--{9,19490}
--{10,47184}
--{11,113302}
--{12,267115}
--{13,615285}
--working(set)... (depth=14, tries=40528403, time=134s)
--{14,1378791}
--working... (depth=29, tries=66610992, time=249s)
--non-optimal solution of 28(52) moves found in setup 2 minutes and 15s, search 4 minutes and 10s: dru2l2d2r2dl2ur3dl2ur2u2l2d2rdl2u3rd3r2u3l2d3r2

--puzzle = {7,10,11,1,0,9,3,4,5,8,13,2,14,6,12,15} --   3.20s  35 (55) [47]  rdr2ul3dr2u2rd2lu2l2dr2uld3lu3rd3ru3rd3l2urdruldr
--88(h) [I think]
--{0,2}
--{1,9}
--{2,30}
--{3,81}
--{4,198}
--{5,501}
--{6,1255}
--{7,3200}
--{8,7921}
--{9,19490}
--{10,47184}
--{11,113302}
--{12,267115}
--{13,615285}
--{14,1378791}
--{15,3003301}
--non-optimal solution of 30(55) moves found in setup 7 minutes and 15s, search 18 minutes and 03s: r3d2lurul3d2r2u3rd2l3dru3ld2ru2r2d2lu2rdl3ur3d3
--33334:
--{0,5}
--{1,13}
--{2,38}
--{3,83}
--{4,155}
--{5,346}
--{6,766}
--{7,1631}
--{8,3299}
--{9,6341}
--{10,11286}
--{11,18335}
--{12,26649}
--{13,35864}
--{14,43587}
--working(set)... (depth=15, tries=158443263, time=692s)
--{15,48978}
--working... (depth=31, tries=638290082, time=7655s)
--non-optimal solution of 30(55) moves found in setup 11 minutes and 33s, search 2 hours, 7 minutes and 36s: r3d2lurul3d2r2u3rd2l3dru3ld2ru2r2d2lu2rdl3ur3d3

--754:
--{0,4}
--{1,14}
--{2,38}
--{3,89}
--{4,200}
--{5,483}
--{6,1124}
--{7,2503}
--{8,5242}
--{9,11015}
--{10,22454}
--{11,43989}
--{12,83829}
--{13,160855}
--{14,305692}
--working(set)... (depth=15, tries=122309740, time=642s)
--{15,570187}
--working... (depth=31, tries=242149637, time=1847s)
--non-optimal solution of 30(55) moves found in setup 10 minutes and 43s, search 30 minutes and 48s: r3d2lurul3d2r2u3rd2l3dru3ld2ru2r2d2lu2rdl3ur3d3

--puzzle = {14,11,8,15,12,5,13,3,6,2,9,0,1,7,10,4} --   0.92s  44 (79) [61]  u2l3d3r2u3l2d3r2u3l2d3r2u2rd2lu3rd2l2uldr2u2rdl3d2r3ul2u2rd2luruld2rdr

--{4,12,15,9,2,13,14,3,5,7,8,6,11,1,10,0} --   1.72s  41 (68) [56]  ul2u2ld3ru2r2ul3d3r3u3ld3lur2ul3dr2ul2dr2dlur2dlu3ldlur2drd2
--see above...
--{12,14,2,11,1,7,0,10,6,5,13,4,8,9,15,3} --   0.14s  36 (57) [51]  luld2ru2r2d3lu2l2d2r2u3rd2l3dr2uldr2ulu2ldr2dl2u2rd2rd
--{4,13,8,7,10,6,2,9,5,0,14,11,12,15,1,3} --   0.30s  42 (67) [55]  u2ld2r2dlu2r2ul3d2r3dl3u3rd3rul2ur3dl2ur2ul3d2ru2rdldruldrdr
--{4,5,11,13,3,7,8,12,0,14,2,6,10,15,1,9} --   0.14s  38 (66) [56]  r2dl2ur3ul2uld2r3u2l3d2r3u2l3dr2d2rul2dr2ul3dr3u2l2dldrur2d
--{15,4,3,6,2,7,5,1,8,11,0,14,13,9,10,12} --   2.36s  36 (52) [48]  lurul2dr3ul2dr2dl3ur3dlu2l2drd2ru2l2drdru2rdlurd2
--{7,10,13,5,6,8,11,0,1,2,12,14,3,4,15,9} --   0.31s  42 (62) [58]  l2d2r2u2l2ur2d2l2u2rd3lu2ldr2dl2urdrulu2ldrurd3ru3ldld2rurd
--{10,9,0,11,1,6,15,7,4,5,2,12,14,13,3,8} --   2.02s  34 (58) [52]  l2d2r2ul2urd3ru3l2d2r3u2l2d3ru3ld2rulurdrd2l3ur2urd2
--{4,15,14,8,10,9,3,12,7,6,13,0,2,11,1,5} --   0.14s  43 (71) [57]  ulul2d3r2u2l2d2r2u3l2d2r2ul2d2r3u2l3d2r2u2ld2luru2ld2rur2dluruld2rd
--{9,7,15,12,8,6,13,5,14,2,11,1,4,0,10,3} --   0.50s  44 (70) [60]  lu2r3dl3ur3ul2drdl2u2rd3r2ul2dlu3r2d3lu3rd2ru2ld2rul2d2rurdlurd
--{3,5,14,4,0,10,12,7,15,9,6,11,2,1,13,8} --   0.06s  29 (45) [45]  d2ru2ld2ru3ld2r2u2l2drd2ru2ldldrur2dl2u2r2d2
--{5,15,3,10,9,8,7,14,4,13,12,2,0,1,6,11} --   1.88s  40 (59) [51]  rur2ul3d2r3u3ld2lu2ld2ru2ldr3dldrul2dru2rul2d2ruruld2rd
--{5,8,7,2,14,15,12,10,0,6,9,1,4,11,13,3} --   0.11s  40 (68) [54]  r3uld2l2ur3dl2u2ld2ru3rd3lu3r2d2l3u2r3d2lu2rd2luld2rurdl2ur2d
--{3,6,15,14,7,9,11,10,2,1,13,5,0,12,8,4} --   0.06s  40 (69) [57]  uruldr3ul3dr3dl3u2r2urd3lu3ld3ru3rd3lu3l2drd2lur2u2ld2ldr3
--{4,8,13,1,11,7,12,10,2,3,0,14,6,5,9,15} --   0.95s  39 (70) [50]  ul2d2r3ul2u2r2dl3ur3dl3ur2dl2d2ru3rd3lu2ld2r3u3l2d3rulu2rdrd2
--{3,12,0,11,10,5,7,14,6,13,2,15,8,9,4,1} --   0.45s  41 (66) [56]  l2d3rulur2d2ru3l3d3r3u3ld3rul2dr2u2ldlu2r2dldluruldlur2d3r

--SUG:
--working(set)... (depth=14, tries=21625654, time=148s (predicted 150s, diff 2s))
-- ie it may finish early, or diff may sail through 0 and go negative.

--AH: if we set a flag on Q for quit, then pretend we found a solution (return true), we can, I think, resume at that point.
-- Since Ctrl C mullers edb databases, maybe flat files would be better? (or, why not, copy/rename etc once closed?)
-- Could dict.e perform a width-first traversal to minimise the rebuild cost (and/or is that worth it)?
--  [actually, an inorder rebuild ought to create ever-increasing final left nodes anyway??]
-- Test: a 1..N vs a "recursive" mid-point add - should be easy enough to do? - maybe not...
--      ah, just start with {1..N} and repeatedly split {i,k} to {i..j-1},{j+1..k}, in two even-length sequences.

--/*
    that = {1,N}
    while length(that) do
        this = that
        that = {}
        for i=1 to length(this) by 2 do
            integer l = this[i], r = this[i+1], m = floor((l+r)/2)  -- (or round?)
            <add m>
            if m>l then that &= {l,m-1} end if
            if m<r then that &= {m+1,r} end if
        end for
    end while
--*/


    if not solvable(puzzle) then
        ?puzzle
        printf(1,"puzzle is not solveable\n")
    else

--      generate_mmwd()

        sequence original = puzzle
        integer space = find(0,puzzle)

if USETODO then
--trace(1)
--      setd(puzzle,'-',todo)
        setd(goal,'-',todo)
        plim = -1
        puzzle = goal
        set_distance('-')
?{0,dict_size(patdb)}
end if

--      for lim=walking_distance(puzzle) to iff(MTM?43:80) do
--trace(1)
        for i=0 to 43 do
--      for i=-4 to 43 do
            t0 = time()
if and_bits(i,1)=0 then
--if and_bits((i+4),1)=0 then
            plim = i/2
--          plim = (i+4)/2
--          plim = i
--          lim = i
--if lim>prebuilt then...
            puzzle = goal
if USETODO then
            set_patterns(i,16,'-')
else
            set_patterns(0,16,'-')
end if
            setup_time += time()-t0

?""
?{plim+USETODO,dict_size(patdb)}
end if
if i>=0 then
            t0 = time()
            slim = i
            puzzle = original
            if iddfs(0, space, '-') then exit end if
            search_time += time()-t0
end if
        end for
        search_time += time()-t0

        {integer n, string ns, string ans} = pack(reverse(res))

        printf(1,"\n\noriginal:")
        ?original
--      atom t = time()-t0
        string t = "setup "&elapsed(setup_time)&", search "&elapsed(search_time)
        printf(1,"\n%soptimal solution of %s moves found in %s: %s\n\nresult: ",
--               {iff(MTM?"mtm-":iff(STM?"stm-":"non-")),ns,elapsed(t),ans})
                 {iff(MTM?"mtm-":iff(STM?"stm-":"non-")),ns,t,ans})
        puzzle = original
        apply_moves(ans,space)
        ?puzzle
    end if
end procedure
main()

{} = wait_key()
abort(0)


::: Whatever, twist the task to fit your solution better, and move mine, that's not vandalism at all. ~~~~
.. Pot calling the kettle black, methinks. Anyhow, 
:::In the context of this site, and not just about this one task, it may be nice to have optimal solutions but near-optimal solutions 
which can be delivered significantly faster might also be worthwhile. Obviously, as per my code, I am a little biased here, but I think
mtm should be preferred, but <b>both</b> stm and non-optimal should also be acceptable, as long as they are clearly marked as such.
:::"less damage to the tasks structure"???? Did I somehow force you to change the task description in order to justify removing the 
incorrect tags? Oh dear, my bad :-) Sorry, but 31 moves <i>can</i> be compared to 52 moves. You might have had a point with "unfair",
but I just don't buy that "silly" at all.
As above, I will accept broadened rather than narrowed terms. ~~~~
It was perhaps wrong of me to mark your entries as incorrect, but no more than you did first.
-- ==Code golf==
-- Not to make a big fuss about it, but the F# entry is better suited to codegolf.stackexchange - (n,i,g,e,l) may be cute, but is less than ideal here. ~~~~

Do what you want.Take offence at me doing to you what you did to me first. Twist the task to make your solution.

Whatever. I can accept a moratorium on incorrect tags, but redefining/splitting the task the way you have is simply dishonest.
In fact I have always thought that other short/clear/elegant/readable solutions, optional or not, should be perfectly acceptable, and welcome. ~~~~

--*/

--/*
--DE-GOLF attempt...
--IGEL=?DURL
if machine!bits()!=64 then ?9/0 end if  -- needs 64 bits
constant D=0x01, 
         U=0x02,
         R=0x04,
         L=0x08

// Solve Random 15 Puzzles : Nigel Galloway - October 18th., 2017
--class fifteenSolver{
constant Nr = {3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3}, 
         Nc = {3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2}
--constant i=1, g=8, e=2, l=4;
integer n{},_n{}
sequence rows = repeat('\0',85),
         cols = repeat('\0',85),
         moves = repeat(' ',85),
         N4 = repeat('\0',85)
sequence N2 = repeat({},85)
  bool fU(){
    if (N2[n]==0x123456789abcdef0) return true; 
    if (N4[n]<=_n) return fN();
    return false;
  }
--PL I think these flags were mismatched...
  bool fZ(const int w){
    if ((w&D)>0){fD(); if (fU()) return true; --n;}
    if ((w&L)>0){fG(); if (fU()) return true; --n;}
    if ((w&U)>0){fE(); if (fU()) return true; --n;}
    if ((w&R)>0){fL(); if (fU()) return true; --n;}
    return false;
  }
  bool fN(){
    integer r = rows[n],
            c = cols[n],
            m = moves[n],
            t = 0
--???
--  if r<3 and m!='l' then t += R end if
    switch r do case  0: switch c do case  0: switch m do case 'l': return fZ(D);
                                                          case 'u': return fZ(e);
                                                          default : return fZ(D+e) end switch
                                     case  3: switch m do case 'r': return fZ(D);
                                                          case 'u': return fZ(l);
                                                          default : return fZ(D+l) end switch
                                     default: switch m do case 'l': return fZ(D+l);
                                                          case 'r': return fZ(D+e);
                                                          case 'u': return fZ(e+l);
                                                          default : return fZ(D+e+l) end switch end switch
                case  3: switch c do case  0: switch m do case 'l': return fZ(g);
                                                          case 'd': return fZ(e);
                                                          default : return fZ(e+g) end switch
                                     case  3: switch m do case 'r': return fZ(g);
                                                          case 'd': return fZ(l);
                                                          default : return fZ(g+l) end switch
                                     default: switch m do case 'l': return fZ(g+l);
                                                          case 'r': return fZ(e+g);
                                                          case 'd': return fZ(e+l);
                                                          default : return fZ(g+e+l) end switch  end switch
                default: switch c do case  0: switch m do case 'l': return fZ(D+g);
                                                          case 'u': return fZ(g+e);
                                                          case 'd': return fZ(D+e);
                                                          default : return fZ(D+g+e) end switch
                                     case  3: switch m do case 'd': return fZ(D+l);
                                                          case 'u': return fZ(g+l);
                                                          case 'r': return fZ(D+g);
                                                          default : return fZ(D+g+l) end switch
                                     default: switch m do case 'd': return fZ(D+e+l);
                                                          case 'l': return fZ(D+g+l);
                                                          case 'r': return fZ(D+g+e);
                                                          case 'u': return fZ(g+e+l);
                                                          default : return fZ(D+g+e+l) end switch  end switch  end switch
  }
  void fD(){
    int           g = (15-4-cols[n]-rows[n]*4)*4;
    integer tile = N2[n][g]
    if N2[n][g-4]!=0 then ?9/0 end if
    unsigned long a = N2[n]&((unsigned long)15<<g);
    N2[n+1] = N2[n]
    N2[n+1][g] = 0
    N2[n+1][g-4] = tile
    rows[n+1]=rows[n]+1; cols[n+1]=cols[n]; N2[n+1]=N2[n]-a+(a<<16); moves[n+1]='d'; N4[n+1]=N4[n]+(Nr[a>>g]<=rows[n++]?0:1);
  } 
  void fG(){
    int           g = (15+4-cols[n]-rows[n]*4)*4;
    unsigned long a = N2[n]&((unsigned long)15<<g);
    rows[n+1]=rows[n]-1; cols[n+1]=cols[n]; N2[n+1]=N2[n]-a+(a>>16); moves[n+1]='u'; N4[n+1]=N4[n]+(Nr[a>>g]>=rows[n++]?0:1);
  } 
  void fE(){
    int           g = (15-1-cols[n]-rows[n]*4)*4;
    unsigned long a = N2[n]&((unsigned long)15<<g);
    rows[n+1]=rows[n]; cols[n+1]=cols[n]+1; N2[n+1]=N2[n]-a+(a<<4); moves[n+1]='r'; N4[n+1]=N4[n]+(Nc[a>>g]<=cols[n++]?0:1);
  } 
  void fL(){
    int           g = (15+1-cols[n]-rows[n]*4)*4;
    unsigned long a = N2[n]&((unsigned long)15<<g);
    rows[n+1]=rows[n]; cols[n+1]=cols[n]-1; N2[n+1]=N2[n]-a+(a>>4); moves[n+1]='l'; N4[n+1]=N4[n]+(Nc[a>>g]>=cols[n++]?0:1);
  }
--public:
procedure fifteenSolver(int row, int col, sequence board)
    rows[1]=row
    cols[1]=col
    N2[1]=board
    N4[1]=0
end procedure

procedure Solve()
    while not fN() do
        n = 0
        _n += 1
    end while
--  std::cout<<"Solution found in "<<n<<" moves: "; for (int g{1};g<=n;++g) std::cout<<(char)moves[g]; std::cout<<std::endl;
    printf(1,"Solution found in %d moves: %s\n",{n,moves[1..n]})
end procedure

int main (){
  fifteenSolver start(2,0,0xfe169b4c0a73d852);
  start.Solve();
}
0xfe16
  9b4c
  0a73
  d852
--*/

--/*
--#!/usr/bin/lua
----[[
--Solve 3X3 sliding tile puzzle using Astar on Lua. Requires 3mb and
--millions of recursions.
--by RMM    2020-may-1
--]]--
 
--with trace
constant MAX_F_VALUE = 100,
         N = 4,
         Goal  = {1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,15,0}
 
sequence goal_cols = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
         goal_rows = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
         curr_cols = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
         curr_rows = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0},
         Tiles = {15,14,1,6, 9,11,4,12, 0,10,7,3, 13,8,5,2},
--       Tiles = {5,1,4,8, 9,6,3,11, 10,2,15,7, 13,14,12,0},
--       Tiles = {0,12,9,13, 15,11,10,14, 3,7,2,5, 4,8,6,1},    -- type check failure, recursions is 1073741824.0 (eventually...)
--       Tiles  = {1,2,3,4, 5,6,7,8, 9,10,11,12, 13,0,14,15},   -- good
--       Tiles  = {1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,0,15},   -- good
--       Tiles  = {1,2,3,4, 5,6,7,8, 9,10,11,0, 13,14,15,12},   -- good
--       Tiles  = {1,2,3,4, 5,6,7,0, 9,10,11,8, 13,14,15,12},   -- good
--       Tiles  = {1,2,3,0, 5,6,7,4, 9,10,11,8, 13,14,15,12},   -- good
         solution = {}, -- final path is instance of desc
         desc           -- descending path       
 
integer recursions=0, found=0, threshold=0, times=0

function rcidx(integer row, col)
-- return 1D array index given 2D row,column
   return (row-1)*N + col
end function
 
-- @brief recursive search
-- @return f_score
function search(integer depth, x_row, x_col, h_score)
   integer rc1_row = 1,
           rc1_col = 1,
           rc2_row = 1,
           rc2_col = 1,
--         gr = 1,
--         gtmp_col = 1,
           move, go_back_move,
           last_move_by_current,
           f_score = depth + h_score

   if f_score > threshold then return f_score end if
   if h_score == 0 then
      found = true
--?{"soln",depth,find('\0',desc)}
--    Solution = desc[2..find('\0',desc)-1]
      solution = desc[2..depth]
      return f_score
   end if 

   recursions += 1
   times += 1
   if times > 200000 then
         printf(1,"Recursions %d\n",recursions)
         times = 0
   end if
 
   integer minres = 999999
   last_move_by_current = desc[depth];
   rc1_row = x_row;
   rc1_col = x_col;
   for ix=1 to 4 do -- (the four possible moves)
        move = "udlr"[ix]
        go_back_move = "durl"[ix]
        rc2_row = x_row+{-1,+1,0,0}[ix]
        rc2_col = x_col+{0,0,-1,+1}[ix]
      if  rc2_row>=1 and rc2_row<=N
      and rc2_col>=1 and rc2_col<=N
      and (last_move_by_current!=go_back_move) then
          integer idx1 = rcidx(rc1_row,rc1_col),
                  idx2 = rcidx(rc2_row,rc2_col),
                  tdx = Tiles[idx2]+1,
                  gtmp_row = goal_rows[tdx],
                  gtmp_col = goal_cols[tdx],
                  curr_row = curr_rows[tdx],
                  curr_col = curr_cols[tdx],
                  h_adj
          switch go_back_move do
            case 'u': h_adj = gtmp_row < curr_row
            case 'd': h_adj = gtmp_row > curr_row
            case 'l': h_adj = gtmp_col < curr_col
            case 'r': h_adj = gtmp_col > curr_col
          end switch
          integer hscore2 = h_score + iff(h_adj ? -1 : 1)
          curr_rows[1] = rc2_row;
          curr_cols[1] = rc2_col;
          curr_rows[tdx] = rc1_row;
          curr_cols[tdx] = rc1_col; 
          Tiles[idx1] = tdx-1;
          Tiles[idx2] = 0;
          desc[depth+1] = move
 
          integer temp = search(depth+1, rc2_row, rc2_col, hscore2); -- descend
--        minres = min(minres,search(depth+1, rc2_row, rc2_col, hscore2)) -- descend
          if found then return 0 end if -- (return value not used post-found)

          -- regress
          Tiles[idx1] = 0
          Tiles[idx2] = tdx-1
          curr_rows[1] = rc1_row;
          curr_cols[1] = rc1_col;
          curr_rows[tdx] = rc2_row;
          curr_cols[tdx] = rc2_col;
          if temp < minres then  minres = temp end if
      end if
   end for
   found = false
   -- return the minimum f_score greater than threshold
   return minres;
end function
 
-- @brief  Run solver using A-star algorithm
-- @param Tiles .. 3X3 sliding tile puzzle
procedure solve(sequence Tiles)
    integer temp, x_row = 0, x_col = 0, h_score = 0
 
    found = false
    for i=1 to N do
       for j=1 to N do
          integer r = rcidx(i,j),
                  g = Goal[r]+1,
                  t = Tiles[r]+1
          goal_rows[g] = i
          goal_cols[g] = j
          curr_rows[t] = i
          curr_cols[t] = j
          if Tiles[r]==0 then
                x_row = i;
                x_col = j;
          end if
       end for
    end for
    desc = repeat('$',200)
 
   h_score = 0;   -- Manhattan/Taxicab heuristic
   for i=2 to N*N do -- (do not count the '0' being in the wrong place!)
      h_score += abs(curr_rows[i] - goal_rows[i]) +
                 abs(curr_cols[i] - goal_cols[i])
   end for
   threshold = h_score
   printf(1,"solve -> search\n")
   while true do
      temp = search( 1, x_row, x_col, h_score);
      if found then
            printf(1,"Found solution of length %d\n%s\n",{length(solution),solution})
            exit
      end if
 
      if temp > MAX_F_VALUE then
            printf(1,"Maximum f value reached! terminating! \n");
            exit
      end if
      threshold = temp;
   end while
end procedure
 
procedure print_tiles(sequence pt)
-- show sliding tile puzzle rows and columns
    for i=1 to N do
       for j=1 to N do
          printf(1,"%02d ",pt[rcidx(i,j)])
       end for
       printf(1,"\n")
    end for
    printf(1,"\n")
end procedure
 
printf(1,"Solve sliding 15 tile puzzle\n");
print_tiles(Tiles);
print_tiles(Goal)
atom t0 = time()
solve(Tiles);  
?elapsed(time()-t0) 

--Output:
--
--FOUND SOLUTION of length 52 rrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd
--Found solution of length 199$rrdruulurdlddruulddluulurrddlluurrdlddluurdrdlluuurrrdld$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"done"
--Found solution of length 56$rrdruulurdlddruulddluulurrddlluurrdlddluurdrdlluuurrrdld"done"
--Found solution of length 50 $rdlurulurdldrurrddlluruurdddluulurrdlllurrrdlldluu"done"
--Recursions 27400137
--Found solution of length 52
--rrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd
--"44.4s"

--*/
