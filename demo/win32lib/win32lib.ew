--/makedoc title Documentation for Win32lib v0.70.2
--/topic introduction
--/i "see also:" /"General Info"
--/code
--------------------NOTICE-------------------------------*
-- Software ID: win32lib
-- Version:     0.70.2c 28/Nov/2007 (Phix compatible)
-- Copyright:   (c) 2000 /"David Cuny" and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*
--/endcode

-- when a toolbar was subclassed, a problem arises when inserting a new item with an image, since
-- the image lists may not be the same. However, the library doesn't provide a wrapper for using 
--  the TB_ADDBITMAP message, so this should be ok.

--/topic Authors
--/info
--A bit of background on the authors of this library.
--
--/bm "David Cuny" /n
--David originally wrote Win32lib in an attempt to create a platform independant
-- GUI add-on for Euphoria.
--
--/bm "Matthew Lewis" /n
--Matthew implemented most of the common Windows controls
--
--/bm "Derek Parnell" /n
--Derek has acted as custodian once David could no longer concentrate on the library.
-- Since then he has reorganised the code and implemented improvements
-- based on submissions from the many users of the library.
--
--/bm "Christian Cuvier" /n
--Christian has been changing and repairing the library since 2006.
--
--/topic General Info
--/info
-- Some background and historical notes about win32lib.
-- The library was originally developed by /"David Cuny", and over time, a
-- number of other people have made additions and corrections. Where
-- appropriate the work that other people have contributed is marked thus...
--/code
--      -- Begin ~<person's name>~
--      -- End  ~<person's name>~
--/endcode
-- This library provides access to the /i"Window32 API" from a fairly high
-- level, hiding most of the guts from the user.
--
--See also: /lit'<a href="win32geninfo.html">Further Information</a>'

--/topic Frequently Asked Questions
--/info
-- Questions and Answers that are often sought by new comers to Win32lib.
-- This section contains the answers to many questions that beginners have.
--Details in /lit'<a href="w32faq.htm">Win32Lib FAQ</a>'

---/topic Known Bugs
-- Okay, so not everything is perfect. At least we admit it!
-- The following are known bugs. They will probably be fixed before the next major release.
--/define
--/term Bug
-- Undocumented feature.
--/term Feature
-- Documented bug.
--/enddefine
-- quoted from EuForum, Don Cole's signature.

--/makedoc insert ..\include\options.e
--/makedoc insert ..\include\rttext.e
--/makedoc insert ..\include\seqop.e
--/makedoc insert series.e
--/makedoc insert ..\include\w32advapi.ew
--/makedoc insert ..\include\w32comctl.ew
--/makedoc insert ..\include\w32comdlg.ew
--/makedoc insert ..\include\w32dll.ew
--/makedoc insert ..\include\w32file.ew
--/makedoc insert ..\include\w32gdi.ew
--/makedoc insert ..\include\w32kernel.ew
--/makedoc insert ..\include\w32msgs.e
--/makedoc insert ..\include\w32ole.ew
--/makedoc insert ..\include\w32shell.ew
--/makedoc insert ..\include\w32sock.ew
--/makedoc insert ..\include\w32start.ew
--/makedoc insert ..\include\w32utils.e
--/makedoc insert ..\include\w32user.ew
--/makedoc insert ..\include\w32winmm.ew
--/makedoc insert ..\include\changes.txt
--/makedoc insert ..\include\w32constants.ew
--/makedoc insert ..\include\w32memory.ew
--/makedoc insert ..\include\w32forms.ew
--/makedoc insert ..\include\w32resources.ew

--/topic Defaults
--/info
--Setting the default values that Win32lib applications use.
--There are a number of values that Win32lib uses that can be changed
-- on a per application basis. These new values are specified using the
-- operating system's SET environment symbol command.
--
--The symbol to use is 'w32Defaults'. This takes a comma separated list of
--keyword/value pairs. The keyword is delimited from the value by a colon ':'
-- character.
--
--/b FONT /n
--Unless you explicitly specify a font for a control, the get the
-- Win32lib default font.
--The default font used for text is /b"MS Sans Serif 8-point Normal". You can change
-- this with the /i Font keyword. It is followed by a list of one to three
-- values enclosed in brackets.
--
-- Font:{/b facename, /b size, /b style} /n
--where /i facename is the name of the font, /i size is the point-size required,
-- and /i style is an integer whose value is the sum of ...
--/code
--    Normal    = 0
--    Bold      = 1
--    Italic    = 2
--    Underline = 4
--    Strikeout = 8
--/endcode
--Thus to get /b Bold and /i Italic you add 1 and 2 and make the /i style value
--equal 3.
--
--Example:
--/code
--      set w32Defaults=Font:(Comic Sans MS,12,3)
--/endcode

-----------------------------------------------------------------------------

--/topic Change History
-- This records, in brief, the major changes done to the source code.
-- Where possible, the appropriate people are given credit as well.
-- See details in /lit'<a href="change.htm">Changes</a>'

-----------------------------------------------------------------------------
-- info on topics

-----------------------------------------------------------------------------
--/topic System Attributes
--/info
-- These are routines that let you inspect and alter attributes of various system-wide elements.

-----------------------------------------------------------------------------
--/topic Values
--/info
-- These are routines that let you inspect and alter the current value of a control.
-- This is usually a text value but also include checkboxes,
-- progress bars, and scroll bars.

--/topic Attributes
--/info
-- These are routines that let you inspect and alter attributes of controls.
-- For more specialized routines, see:
--
-- /li /"Edit Control": Working with text edit controls
--          (/EditText, /MleText).
-- /li /"List Control": Working with lists (/List, /SortedList),
--          combos (/Combo, /SortedCombo), etc.
-- /li /"ListView Control"
-- /li /"MonthCalendar Control"
-- /li /"RichEdit Control"
-- /li /"TreeView Control"
-- /li /"Scroll Control": Working with scrollbars (/HScroll, /VScroll)
--          trackbars (/HTrackBar, /VTrackbar) and the /ProgressBar.
-- /li /"UpDown Control"

-----------------------------------------------------------------------------
--/topic Controls
--/info
-- Controls are the basic elements of Windows programs.
-- You can /create them, query and change /Attributes, and respond to
-- /Events.
--
-- See Also: /Attributes

--/topic Forms
--/info
--Forms are a combination of a Window and its controls.
--Win32lib enables easy ways of creating a form and writing event handlers for it.

-----------------------------------------------------------------------------
--/topic Menus
--/info
-- Routines that deal with menu and menuitem handling.

-----------------------------------------------------------------------------
--/topic Dialogs
--/info
-- These are functions the bring up common dialogs.

-----------------------------------------------------------------------------
--/topic Edit Controls
--/info
-- These are routines that let you inspect and alter attributes of the text edit controls
-- Such as /EditText, /MleText and /RichEdit.

-----------------------------------------------------------------------------
--/topic Events
--/info
-- Events are routines that are triggered in response to actions taken by the user.
-- Application events, like mouse clicks, key presses, resizing windows, and so on,
-- are the basis for invoking user-developed routines. Once an application calls /WinMain,
-- Windows takes over and only runs the user code when an event, that has been nominated
-- by the user, occurs. To nominate which events the application wishes to respond to, the
-- application must register event handlers for each control/event combination that is relevent.
--
-- To establish an event handler, you use the /setHandler() routine. This links together
-- three things: A control, an Event Type, and a Routine that you write. /n
--Example:
--/code
--      setHandler(okButton, w32HClick, routine_id("myClickHandler"))
--/endcode
--
-- The event handler routine that you write is always passed three parameters: /n
--  /i"integer self" This is the id of the control that triggered the event. /n
--  /i"integer event" This is the Win32lib code for the event type that was
-- triggered. /n
-- /i"sequence parms" This is zero of more parameters that are specific to
-- the type of event being triggered.
--
-- A given event handler can be shared by many controls and event types. In this case, you can use
-- the /i self and /i event parameters to determine your actions.
--/code
--   procedure myClickHandler(integer self, integer event, sequence parms)
--       if self = okBtn then
--          . . .
--       else
--          . . .
--       end if
--   end procedure
--   setHandler({okBtn,cancelBtn}, w32HClick, routine_id("myClickHandler"))
--/endcode

-----------------------------------------------------------------------------
--/topic Fonts
--/info
-- These routines allow you to work with text.
-- Such as displaying text, changing the font, and so on.

-----------------------------------------------------------------------------
--/topic Graphics
--/info
-- These are routines that allow you to draw on controls.
-- Usually used with a /Window, /Pixmap or /Printer.
--
-- The predefined colors are:
--/code
--  Black, NavyBlue, Blue, BrightBlue
--  ForestGreen, Green, Cyan, SkyBlue
--  BrightGreen, BrightCyan, DarkGray, Eggplant
--  Red, Magenta, DarkBrown, Olive
--  Gray, Brown, LightGray, Purple
--  White, BrightRed, BrightMagenta, Violet
--  Orange, Pink, Yellow, Parchment, BrightWhite
--/endcode

-----------------------------------------------------------------------------
--/topic List Control
--/info
-- These are routines that let you inspect and alter attributes of controls with lists
-- This includes /Combo, /DropDownList, /List, /SimpleCombo,
-- /SortedCombo, /SortedList.
--
-- The first item in a list is 1, not 0. This makes it consistant with
-- Euphoria's indexing method, but can be a bit confusing if you are
-- used to working with zero-based arrays.

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/info
-- These routines give you access to low-level internals.
-- Such as C data structures, the device context,
-- and other Win32 API goodies.

-----------------------------------------------------------------------------
--/topic Mouse
--/info
-- These are routines that deal with the mouse and mouse pointer.

-----------------------------------------------------------------------------
--/topic Printing
--/info
-- These are routines that allow you to interact with the /Printer.

-----------------------------------------------------------------------------
--/topic Scroll Control
--/info
-- These routines let you inspect and alter attributes of the scroll bar controls.
-- Including /HScroll and /VScroll and track bar controls /HTrackBar
-- and /VTrackBar.

--/topic Updown Control
--/info
-- These routines let you manage the attributes of the UpDown control.

-----------------------------------------------------------------------------
--/topic Types
--/info
-- These are data types defined by Win32Lib.

-----------------------------------------------------------------------------
--/topic Utilities
--/info
-- These are useful routines that don't seem to fit in any other category.

-----------------------------------------------------------------------------
--/topic Date and time
--/info
-- These routines are used to extract and display system date and time information.

-----------------------------------------------------------------------------
--/topic Errors
--/info
-- These routines are used to manage warnings and errors occurring as your program runs.

-----------------------------------------------------------------------------
--/topic XPM
--/info
-- These routines deal with a portable graphics file format called XPM
-- XPM stands for "X Pixmap". XPM graphics can be embedded in programs as text data.

-----------------------------------------------------------------------------
--/topic ListView Control
--/info
-- These routines deal with the /ListView common control. /n
-- It is important to know that each item in a list view has a unique ID
-- number. In other words, no two listview items have the same ID value,
-- regardless of which listview it they are in. The item ID is not the same
-- as its index value. The index value is where in a list view the item is
-- positioned. The ID is used as a way to identify an item without referring
-- to its column values or position. When you add an item using /addLVItem,
-- you get the item's ID returned. /n
--  The following routines support /ListView as well as other controls:
-- /li /deleteItem
-- /li /eraseItems
-- /li /getIndex
-- /li /getItem
-- /li /getData
-- /li /findItem
--
-- The following routines are specific to the /b ListView control.
--
--/li /addLVItem
--/li /getLVAllChecked
--/li /getLVAllText
--/li /getLVChecked
--/li /getLVCount
--/li /getLVItem
--/li /getLVItemlParam
--/li /getLVItemText
--/li /getLVSelected
--/li /getLVSelectedCount
--/li /getLVSelectedText
--/li /hitTestLV
--/li /insertLVColumn
--/li /insertLVItem
--/li /setLVAttr
--/li /setLVChecked
--/li /setLVInsert
--/li /setLVImage
--/li /setLVItem
--/li /setLVItemlParam
--/li /setLVItemText
--/li /setLVStyle
--/li /struct_LVCOLUMN


-----------------------------------------------------------------------------
--/topic TreeView Control
--/info
-- These routines deal with the /TreeView common control.
-- The following routines support /TreeView as well as other controls:
-- /li /deleteItem
-- /li /eraseItems
-- /li /getIndex
-- /li /getItem
-- /li /getData
--
-- The following routines are specific to the /b TreeView control.
--
--/li /addTVItem
--/li /expandTV
--/li /getTVIndex
--/li /getTVParent
--/li /getTVSelectedText
--/li /getTVText
--/li /hitTestTV
--/li /removeTVItem
--/li /setTVImages
--/li /setTVParent
--/li /setTVText

-----------------------------------------------------------------------------
--/topic Image Lists
--/info
-- These routines deal with win32lib's /ImageList controls.

-----------------------------------------------------------------------------
--/topic MonthCalendar Control
--/info
-- These routines work with /MonthCalendar Controls:

-----------------------------------------------------------------------------
--/topic RichEdit controls
--/info
-- In addition to the specialized /RichEdit control routines.
-- The /"Edit Control" routines also work with /RichEdit Controls:
-- /li /clear(object)
-- /li /copy(object)
-- /li /cut(object)
-- /li /paste(object)
-- /li /undo(object)

--/topic Miscellaneous
--/info
--Routines that don't easily fit into other categories.

--/topic Text
--/info
--Routines that deal with text output.

without trace
without profile
--/* Pve: all warnings please
without warning
--*/

--/topic Constants
--/const w32VOID
--/desc This junkyard is provided so as to receive return values you don't need.
-- Although it is a regular Euphoria global variable, it is not intended to be read.

object VOID
include w32globals.e

include machine.e
include dll.e
include msgbox.e
include file.e
include get.e
include wildcard.e
include image.e
include w32Keys.e           -- Definitions of Windows keycodes.
include w32msgs.e
include w32def_series.ew    -- because both w32constants and w32memory need this
include w32support.e
--include w32memory.ew
include w32dll.ew
include w32gdi.ew
include w32constants.ew
include w32user.ew
include w32winmm.ew
include w32comdlg.ew
include w32comctl.ew
include w32Kernel.ew as KNL
include w32Shell.ew
include w32file.ew
include w32advapi.ew
include w32winspool.ew


include series.e as series
include rttext.e as rt

---------------- w32to_memory() specific --------------------------
-- must be done here, because both w32constants.ew and w32memory.ew are needed

global function prepro_FINDREPLACE(object s)
        if atom(s) then
            return s
        end if
        if length(s[3]) > 255 then
            s[3] = s[3][1..255]
        else
            s[3] = s[3] & repeat(0, 255-length(s[3]))
        end if

        if length(s[4]) > 255 then
            s[4] = s[4][1..255]
        else
            s[4] = s[4] & repeat(0, 255-length(s[4]))
        end if

        s[5] = 255
        s[6] = 255

        return s
end function
setPreprocessDataIn(ID_FINDREPLACE,routine_id("prepro_FINDREPLACE"))

global function prepro_TEXTRANGE(sequence s)
        if atom(s) then
        elsif length(s)=2 then
            s=append(s,repeat(0,s[2]-s[1]+1))
        else
            s[3] = repeat(0,s[2]-s[1]+1)
        end if
        return s
end function
setPreprocessDataIn(ID_TEXTRANGE,routine_id("prepro_TEXTRANGE"))


integer vWinMainState
integer vEndAction
global constant
         kNotStarted = 0,
         kStarted = 1,
         kFinished = 2
    vWinMainState = kNotStarted     -- If set to non-zero, then eventLoop does nothing.
    vEndAction = -1

--/topic Application
--/info
--Routines dealing with the running application process.
--/func getAppState()
--/desc Returns the current state of the application.
-- Returns either 0 (not started), 1 (running) or 2 (finished).
global function getAppState()
        return vWinMainState
end function

global procedure finishAppInternal()
        vWinMainState = kFinished
end procedure

--/topic Constants
--/info
--These are constants that are used in a number of Win32Lib routines.
--They are often required to send information to the routines in the library.
--


--/topic Constants
--/const Win32LibVersion
--/desc Contains the current version of win32lib library.
-- This is a sequence containing five elements. /n
--/li Major version number (integer)
--/li Minor version number (integer)
--/li Patch or /i Revision number (integer)
--/li Revision for patch (character)
--/li Date of the version in DD-Mmm-YYYY format (string)
--
--Example
--/code
--       setText(SB, sprintf("Win32Lib version %d.%d Patch#%d%s, %s",
--                            Win32LibVersion))
--/endcode
global constant
        Win32LibVersion = {0,70,2,'c', "28-Nov-2007"}   -- {Major, Minor, Patch, Revision, Date}
sequence vAppName vAppName = "Win32Lib AppWindow"

-- Initialise the general UI message subsystem.
    Init_UI_Msgs({{"AppName", vAppName},
                  {"AppVersion", sprintf("Win32Lib v%d.%d.%d%s %s",
                                         {Win32LibVersion[1],
                                          Win32LibVersion[2],
                                          Win32LibVersion[3],
                                          Win32LibVersion[4],
                                          Win32LibVersion[5]})
                  }
                 })

    -- Set the message handler for memory allocation errors.
    VOID = w32llSetAbort(routine_id("abortErr"))


    r_AppCallback = -1

sequence vWinMsg        vWinMsg = repeat(0, 16)
integer  vWMI           vWMI = 0
sequence vDuringPaint   vDuringPaint = {}
sequence vDragData      vDragData = {}

-- Use Logical or Screen resolutions in Font Creation.
integer vFontResolution vFontResolution = 1 -- Use screen resolution

-----------------------------------------------------------------------------
-- current id and return value
sequence idStack, returnStack
integer SP
    SP = 0
    idStack = repeat(0, 10)
    returnStack = repeat(0, 10)

-----------------------------------------------------------------------------

--/topic System Attributes
--/func setEndAction(integer code)
--/desc Sets the exit code and behaviour at application closure.
--/ret INTEGER: Current value of the exit code
--This is used to signal what is to happen when the main window
--is closed. At that time, if the last use of setEndAction() uses
--a /i code less than zero, control returns to the application
--from the /WinMain() call. However, a /i code of zero or higher
--causes the library to call the standard Euphoria abort() routine
--using the value of /i code.
--
--Example
--/code
--      integer CurrentVal
--      -- Set the app to end when the main window is closed.
--      CurrentVal = setEndAction(0)
--
--/endcode
global function setEndAction(integer code)
integer lCurVal

        lCurVal = vEndAction
        vEndAction = code
        return vEndAction
end function

--/topic Attributes
--/func getSelf()
--/desc Get the id number of the current active control.
--/ret (INTEGER) id of active control. /i Zero if no control is active.
--This is used by event handlers to find out which control was active when
--the event was invoked.
--
--Example
--/code
--      procedure Clicker()
--        integer lSelf
--
--        lSelf = getSelf()
--        if lSelf = btnOne then
--           ...
--        else
--           ...
--        end if
--      end procedure
--/endcode
global function getSelf()
        -- return id of current active control
        if SP > 0 then
            return idStack[SP]
        else
            return 0
        end if
end function



constant
        Err_GETHCHANGED = {"getHandle:The stored hWnd for id %d is now attached to id %d", 499},
--      Err_COMCTLFAIL = {"Common controls could not be initialized!", 498},
        Err_GETHOBJECTDESTROYED = {"getHandle: Object is destroyed.", 497},
        Err_GETHNULLHANDLE = {"getHandle returned Null handle.", 496},
        Err_GETHFAIL = {"getHandle failed.", 495},
--      Err_QFNOWINDOW = {"queryFont: no windows defined", 485},
        Err_GETTEXTEXTENT = {"getTextExtent:GetTextExtentPoint failed.", 484},
        Err_REGCLASS = {"RegisterClassEx failed.", 483},
        Err_CREATEWINDOW = {"CreateWindow in createWindow failed.", 482},
        Err_CREATETABITEM = {"Failed to create a TabItem in create:createTabItem.", 481},
--      Err_DESTROYWINDOW = {"destroy:Window failed", 480},
--      Err_DESTROYBUTTON = {"destroy:Button failed", 479},
--      Err_DESTROYCONTROL = {"destroy:Control failed", 478},
        Err_DESTROYMENU = {"destroy:Menu failed", 477},
--      Err_DESTROYMENUITEM = {"destroy:MenuItem failed", 476},
--      Err_DESTROYCLASS = {"destroy: Class cannot be destroyed yet.", 475},
--      Err_FPINVALIDATERECT = {"InvalidateRect in flushPaintEvent failed.", 474},
--      Err_RWINVALIDATERECT = {"InvalidateRect in repaintWindow failed.", 473},
        Err_GSGETWINDRECT = {"getRect:GetWindowRect failed.", 472},
--      Err_CREATEMDIWINDOW = {"CreateMDIWindow in createMDIWindow failed.", 471},
--      Err_CPCLIENTTOSCREEN = {"getClientPoint:ClientToScreen failed.", 470},
        Err_WNDPROCNOID = {"routine_id for WndProc failed!", 469},
        Err_SUBPROCNOID = {"routine_id for SubProc failed!", 468},
--      Err_BADID = {"Unknown control id supplied.", 467},
        Err_STACKERR = {"Internal ID or Return stack lengths incorrect.", 466},
        Err_CREATETABITEM2 = {"Cannot create a TabItem: Parent not a TabControl.", 462},
        Err_CREATECONTROL = {"Failed to acquire a hWnd when creating a control.", 461},
--      Err_CREATECONTROL2 = {"Failed to acquire a hWnd when subclassing a control.", 460},
        Err_OWNERINVALID = {"create():Invalid parent id.", 459},
        Err_SETTEXTCOLOR = {"SetTextColor in assignFont failed.",448},
        Err_SETBKMODE = {"SetBkMode in assignFont failed.",447},
        Err_GETFONTMETRIC = {"GetTextMetrics in getFontSize failed.",446},
        Err_GETFONTSIZE = {"GetTextMetrics in getFontSize failed.",445},
        Err_CREATEMENU = {"CreateMenu in createMenu failed.",444},
        Err_SETMENU = {"SetMenu in createMenu failed.",443},
        Err_CREATEPOPUP = {"CreatePopupMenu in CreateMenu failed.",442},
        Err_APPENDMENU = {"AppendMenu in createMenu failed.",441},
        Err_APPENDMENUITEM = {"AppendMenu in createMenuItem failed.",440},
        Err_CREATEPIXMAP = {"createPixmap:CreateCompatibleBitmap failed",439},
        Err_FLATTOOLBARBTN = {"createEx: failed to create button",438},
        Err_REPAINTRECT = {"InvalidateRect in repaintRect failed.",437},
        Err_GSGETBITMAP = {"getRect:GetObject for bitmap failed.",436},
        Err_GSGETPIXMAP = {"getRect:GetObject for pixmap failed.",435},
        Err_GCSGETCLIENTRECT = {"getClientSize:GetClientRect failed.",434},
--      Err_GCSCLIENTTOSCREEN = {"getClientSize:ClientToScreen failed.",433},
        Err_GCRGETCLIENTRECT = {"getClientRect:GetClientRect failed.",432},
--      Err_SETTEXT = {"SetWindowText in setText failed.",431},
        Err_SETENABLE = {"EnableMenuItem in enableMenuItem failed.",430},
        Err_SETCHECK = {"CheckMenuItem in checkMenuItem failed.",429},
        Err_SETBKCOLOR = {"SetBkColor in assignFont failed.",428},
--      Err_CLIENTTOSCREEN = {"ClientToScreen failed.", 427},
        Err_SCREENTOCLIENT = {"ScreenToClient failed.", 426}
----------------------------------------------------------------------------

--/topic System Attributes
--/func getSystemMetrics(object Code)
--/desc Allows you to get miscellaneous information about the Windows system your application is running on.
--/ret Depends on the input /i Code.
-- Note that /i Code can be an atom for single requests or a sequence of
-- atoms for multiple requests in one call. /n
--The codes and their return values are... /n
--/define
--/term  SM_CYMIN
--/term  SM_CXMIN
--/term  SM_ARRANGE
-- How the system arranges minimized windows. This consists of a starting
-- position and a direction. The starting position can be one of the
--following values. /n
-- ARW_BOTTOMLEFT Start at the lower-left corner of the screen (default position). /n
-- ARW_BOTTOMRIGHT Start at the lower-right corner of the screen. /n
-- ARW_HIDE Hide minimized windows by moving them off the visible area of the screen. /n
-- ARW_TOPLEFT Start at the upper-left corner of the screen. /n
-- ARW_TOPRIGHT Start at the upper-right corner of the screen. /n
-- The direction in which to arrange can be one of the following values. /n
-- ARW_DOWN Arrange vertically, top to bottom. /n
-- ARW_LEFT Arrange horizontally, left to right. /n
-- ARW_RIGHT Arrange horizontally, right to left. /n
-- ARW_UP Arrange vertically, bottom to top. /n
--/term  SM_CLEANBOOT
-- Value that specifies how the system was started: /n
-- 0 Normal boot /n
-- 1 Fail-safe boot /n
-- 2 Fail-safe with network boot /n
--/term  SM_CMOUSEBUTTONS
-- Number of buttons on mouse, or zero if no mouse is installed.
--/term  SM_CXBORDER
-- Width, in pixels, of a window border. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.
--/term  SM_CYBORDER
-- Height, in pixels, of a window border. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.
--/term  SM_CXCURSOR
-- Width, in pixels, of a cursor.
--/term  SM_CYCURSOR
-- Height, in pixels, of a cursor.
--/term  SM_CXDOUBLECLK
--/term  SM_CYDOUBLECLK
--/term  SM_CXDRAG
--/term  SM_CYDRAG
--/term  SM_CXEDGE
--/term  SM_CYEDGE
--/term  SM_CXFIXEDFRAME
--/term  SM_CYFIXEDFRAME
--/term  SM_CXFRAME
--/term  SM_CYFRAME
--/term  SM_CXFULLSCREEN
--/term  SM_CYFULLSCREEN
--/term  SM_CXHSCROLL
--/term  SM_CYHSCROLL
--/term  SM_CXHTHUMB
--/term  SM_CXICON
--/term  SM_CYICON
--/term  SM_CXICONSPACING
--/term  SM_CYICONSPACING
--/term  SM_CXMAXIMIZED
--/term  SM_CYMAXIMIZED
--/term  SM_CXMAXTRACK
--/term  SM_CYMAXTRACK
--/term  SM_CXMENUCHECK
--/term  SM_CYMENUCHECK
--/term  SM_CXMENUSIZE
--/term  SM_CYMENUSIZE
--/term  SM_CXMINIMIZED
--/term  SM_CYMINIMIZED
--/term  SM_CXMINSPACING
--/term  SM_CYMINSPACING
--/term  SM_CXMINTRACK
--/term  SM_CYMINTRACK
--/term  SM_CXSCREEN
--/term  SM_CYSCREEN
--/term  SM_CXSIZE
--/term  SM_CYSIZE
--/term  SM_CXSIZEFRAME
--/term  SM_CYSIZEFRAME
--/term  SM_CXSMICON
--/term  SM_CYSMICON
--/term  SM_CXSMSIZE
--/term  SM_CYSMSIZE
--/term  SM_CXVSCROLL
--/term  SM_CYVSCROLL
--/term  SM_CYVTHUMB
--/term  SM_CYCAPTION
--/term  SM_CYKANJIWINDOW
--/term  SM_CYMENU
--/term  SM_CYSMCAPTION
--/term  SM_DBCSENABLED
--/term  SM_DEBUG
--/term  SM_MENUDROPALIGNMENT
--/term  SM_MIDEASTENABLED
--/term  SM_MOUSEPRESENT
--/term  SM_MOUSEWHEELPRESENT
--/term  SM_NETWORK
--/term  SM_PENWINDOWS
--/term  SM_SECURE
--/term  SM_SHOWSOUNDS
--/term  SM_SLOWMACHINE
--/term  SM_SWAPBUTTON
--/enddefine

global function getSystemMetrics(object Code)
sequence lResult
        if atom(Code) then
            return w32Func(xGetSystemMetrics, {Code})
        end if

        lResult = repeat(0, length(Code))
        for i=1 to length(Code) do
            lResult[i] = w32Func(xGetSystemMetrics, {Code[i]})
        end for
        return lResult
end function



-----------------------------------------------------------------------
--/topic Mouse
--/proc setPointerPos(sequence pos)
--/desc Moves the mouse pointer to a specified spot on the screen.
-- /i pos is a two-element sequence that specifies the /b X and /b Y position
-- that the mouse pointer is to be moved to.
--
-- Example:
--/code
--      -- Move the mouse pointer to 120,76
--      setPointerPos({120, 76})
--/endcode

global procedure setPointerPos(sequence pos)
        w32Proc(xSetCursorPos,{pos[1],pos[2]})
end procedure




-----------------------------------------------------------------------
--/topic Mouse
--/func getWheelScrollLines()
--/desc Retrieves the number of lines that a mouse wheel movement represents.
--/ret ATOM: The number of lines.
--
-- Example:
--/code
--  atom cnt
--  cnt = getWheelScrollLines()
--/endcode
--
atom gwsMem gwsMem = w32acquire_mem(-2, 4)
global function getWheelScrollLines()
atom lLines

        VOID = w32Func(xSystemParametersInfo,{SPI_GETWHEELSCROLLLINES,0,gwsMem,0})
        lLines =  peek4u(gwsMem)
        return lLines
end function


-----------------------------------------------------------------------
--/topic Mouse
--/func getPointerPos()
--/desc Find where the mouse pointer is on the screen.
--/ret SEQUENCE: {X,Y} The mouse position.
-- This returns a two-element sequence that specifies the /b X and /b Y position
-- of the mouse pointer.
--
-- Example:
--/code
-- sequence pos
--
--  pos = getPointerPos()
--  if pos[1] > 200 then
--      -- code goes here...
--  end if
--/endcode
--
atom gppMem gppMem = w32acquire_mem(-2, 8)
global function getPointerPos()
        VOID = w32Func(xGetCursorPos,{gppMem})
        return peek4s({gppMem, 2})
end function

--/topic Mouse
--/proc clickPointerLeft()
--/desc Simulates the clicking of the left mouse button.

global procedure clickPointerLeft()
        w32Proc(xmouse_event,{6,0,0,0,0})
end procedure

--/topic Mouse
--/proc dragPointerTo(sequence pos)
--/desc Simulates the draging of the left mouse button to a specified position.
-- /i pos is a two-element sequence that contains the /b X and /b Y location to drag the pointer to.
--
--Example
--/code
--  dragPointerTo({100, 200})
--/endcode

global procedure dragPointerTo(sequence pos)
        w32Proc(xmouse_event,{#2,0,0,0,0})
        w32Proc(xSetCursorPos,{pos[1],pos[2]})
        w32Proc(xmouse_event,{#4,0,0,0,0})
end procedure


--/topic System Attributes
--/func getWinVersion()
--/desc Gets the version information of the windows platform you are running in.
--/ret SEQUENCE: {WinVer, VariantString, BuildNo}
--
-- /i WinVer return value can be one of ... /n
--<ul>
--/li WIN_3_1
--/li WIN_95
--/li WIN_95_OSR2
--/li WIN_98
--/li WIN_98SE
--/li WIN_ME
--/li WIN_NT_3_51
--/li WIN_NT_4
--/li WIN_2000
--/li WIN_XP
--/li WIN_UNKNOWN
--</ul>
-- /i VariantString is a service pack name. /n
--/i BuildNo is the operating system's build number.
--
--Example
--/code
--      sequence winver
--      winver = getWinVersion()
--/endcode

global function getWinVersion()
sequence lResult
atom lOV
atom lResp

        lOV = w32to_memory(0,ID_OSVERSIONINFOEX,0)
        lResp = w32Func(xGetVersionEx, {lOV})
        lResult = repeat(0,9)
        if lResp = 0 then
            w32store(lOV, dwOSVersionInfoSize,  SIZEOF_OSVERSIONINFO)
            lResp = w32Func(xGetVersionEx, {lOV})
        end if
        lResult[1..4] = peek4s({lOV+4, 4})
        lResult[5] = w32peek_string(lOV+20)
        lResult[6]  = w32fetch(lOV,wServicePackMajor)
        lResult[7]  = w32fetch(lOV,wServicePackMinor)
        lResult[8]  = w32fetch(lOV,wSuiteMask)
        lResult[9]  = w32fetch(lOV,wProductType)

        w32release_mem(lOV)
        if lResult[4] = 0 then
            lResult[1] = WIN_3_1
        elsif lResult[4] = 1 then
            if lResult[2] = 0 then
                if equal(lResult[5], " C") then
                    lResult[1] = WIN_95_OSR2
                else
                    lResult[1] = WIN_95
                end if

            elsif lResult[2] = 10 then
                if equal(lResult[5], " A") then
                    lResult[1] = WIN_98SE
                else
                    lResult[1] = WIN_98
                end if
            else
                lResult[1] = WIN_ME
            end if
            lResult[3] = and_bits(#FFFF, lResult[3])
        else
            if lResult[2] = 51 then
                lResult[1] = WIN_NT_3_51
            elsif lResult[2] = 0 then
                if lResult[1] = 4 then
                    lResult[1] = WIN_NT_4
                else
                    lResult[1] = WIN_2000
                end if
            elsif lResult[2] = 1 then
                lResult[1] = WIN_XP
            else
                lResult[1] = WIN_UNKNOWN
            end if
        end if
        lResult[2] = lResult[5]

        if lResult[6] = 0 then
            lResult = lResult[1..3]
        else
            lResult = lResult[1..3] & lResult[6..9]
        end if

        return lResult
end function

global constant WINDOWS_VERSION = getWinVersion()


constant ccNames = {
                    "LISTVIEW",
                    "TREEVIEW",
                    "BAR",
                    "TAB",
                    "UPDOWN",
                    "PROGRESS",
                    "HOTKEY",
                    "ANIMATE",
                    "DATE",
                    "COMBOEX",
                    "REBAR",
                    "INTERNET",
                    "PAGESCROLLER",
                    "NATIVEFNTCTL"
                   }
-----------------------------------------------------------------------------
procedure InitCommonControls()
atom icc
integer lClassFlag
sequence lNames

        lNames = {}
        icc = w32to_memory(0,ID_INITCOMMONCONTROLSEX,0)
        lClassFlag = 1
        for i=1 to length(ccNames) do
            w32store(icc, INITCOMMONCONTROLSEX_dwICC, lClassFlag)
            if w32Func(xInitCommonControlsEx, {icc}) = 0 then
                lNames &= '\t' & ccNames[i] & '\n'
            end if
            lClassFlag *= 2
        end for
        if WINDOWS_VERSION[1] >= WIN_98 and length(lNames) > 0 then
            warnErr("The following Common Control Classes cannot be used...\n" &
                    lNames & "\nYou may need to install the latest 'comctl32.dll'")
        end if
        w32release_mem(icc)
end procedure
InitCommonControls()

-----------------------------------------------------------------------------
sequence vDragPointer vDragPointer = repeat(CrossPointer, 4)

global constant
    w32Color_SCROLLBAR              = -1,
    w32Color_BACKGROUND             = -2,
    w32Color_DESKTOP                = w32Color_BACKGROUND,
    w32Color_ACTIVECAPTION          = -3,
    w32Color_INACTIVECAPTION        = -4,
    w32Color_MENU                   = -5,
    w32Color_WINDOW                 = -6,
    w32Color_WINDOWFRAME            = -7,
    w32Color_MENUTEXT               = -8,
    w32Color_WINDOWTEXT             = -9,
    w32Color_CAPTIONTEXT            = -10,
    w32Color_ACTIVEBORDER           = -11,
    w32Color_INACTIVEBORDER         = -12,
    w32Color_APPWORKSPACE           = -13,
    w32Color_HIGHLIGHT              = -14,
    w32Color_HIGHLIGHTTEXT          = -15,
    w32Color_BTNFACE                = -16,
    w32Color_3DFACE                 = w32Color_BTNFACE,
    w32Color_BTNSHADOW              = -17,
    w32Color_3DSHADOW               = w32Color_BTNSHADOW,
    w32Color_GRAYTEXT               = -18,
    w32Color_BTNTEXT                = -19,
    w32Color_INACTIVECAPTIONTEXT    = -20,
    w32Color_BTNHIGHLIGHT           = -21,
    w32Color_3DHILIGHT              = w32Color_BTNHIGHLIGHT,
    w32Color_3DDKSHADOW             = -22,
    w32Color_3DLIGHT                = -23,
    w32Color_INFOTEXT               = -24,
    w32Color_TOOLTIPTEXT            = w32Color_INFOTEXT,
    w32Color_INFOBK                 = -25,
    w32Color_TOOLTIPBK              = w32Color_INFOBK,
    w32Color_HOTLIGHT               = -27,
    w32Color_GRADIENTACTIVECAPTION  = -28,
    w32Color_GRADIENTINACTIVECAPTION = -29,
    w32Color_MENUHILIGHT            = -30,
    w32Color_MENUBAR                = -31


    constant
    WindowColor                 = w32Color_BTNFACE

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getSysColor(window, color)
--/ret ATOM:Returns the RGB value of the specified system color.
--/desc Return atom with value of a system color.
-- The system colors in Windows are:
--
-- /li /b COLOR_SCROLLBAR
-- /li /b COLOR_BACKGROUND
-- /li /b COLOR_DESKTOP
-- /li /b COLOR_ACTIVECAPTION
-- /li /b COLOR_INACTIVECAPTION
-- /li /b COLOR_MENU
-- /li /b COLOR_WINDOW
-- /li /b COLOR_WINDOWFRAME
-- /li /b COLOR_MENUTEXT
-- /li /b COLOR_WINDOWTEXT
-- /li /b COLOR_CAPTIONTEXT
-- /li /b COLOR_ACTIVEBORDER
-- /li /b COLOR_INACTIVEBORDER
-- /li /b COLOR_APPWORKSPACE
-- /li /b COLOR_HIGHLIGHT
-- /li /b COLOR_HIGHLIGHTTEXT
-- /li /b COLOR_BTNFACE
-- /li /b COLOR_BTNSHADOW
-- /li /b COLOR_GRAYTEXT
-- /li /b COLOR_BTNTEXT
-- /li /b COLOR_INACTIVECAPTIONTEXT
-- /li /b COLOR_BTNHIGHLIGHT
-- /li /b COLOR_3DDKSHADOW
-- /li /b COLOR_3DLIGHT
-- /li /b COLOR_INFOTEXT
-- /li /b COLOR_INFOBK
-- /li /b COLOR_HOTLIGHT
-- /li /b COLOR_GRADIENTACTIVECAPTION
-- /li /b COLOR_GRADIENTINACTIVECAPTION
-- /li /b COLOR_MENUHILIGHT
-- /li /b COLOR_MENUBAR
--
-- Example:
--
--/code
--          -- Set the window to the button color
--          /setWindowBackColor(MyWindow, /getSysColor(COLOR_BTNFACE))
--/endcode
global function getSysColor(atom winPart)

        -- returns the color associated with a graphical element
        -- use the COLOR_xxxx constants
        if winPart < 0 then
            winPart = -winPart-1
        end if
        return w32Func(xGetSysColor, {winPart})

end function

global function UseColor(atom x)
        x = floor(x)
        if x < 0 then
            return w32Func(xGetSysColor, {-x-1})
        else
            return and_bits(#FFFFFF, x)
        end if
end function

-----------------------------------------------------------------------------
--/topic Graphics
--/func rgb(integer red, integer green, integer blue)
--/desc Convert a {red, green, blue} tuple into a 24-bit color value.
--/ret Atom: representing the color tuple.
-- Converts the /i red, /i green and /i blue values (ranging from 0-255)
-- into an atom representing that color tuple. Each value represents the
-- relative brightness of each primary color element.
--
-- Example:
-- /code
--      -- set the pen color to a random blue
--      /setPenColor(MyControl, /rgb(0,0,rand(255))
-- /endcode

global function rgb(integer r, integer g, integer b)
        return r + g * 256 + b * 65536
end function

--/topic Events
--/const w32EventCodes
--/desc List of all recognised event codes, in the same order as /w32EventNames.
global constant w32EventCodes = {
                                 w32HBreak,
                                 w32HPause,
                                 w32HMouse,
                                 w32HClick,
                                 w32HKeyPress,
                                 w32HKeyUp,
                                 w32HKeyDown,
                                 w32HResize,
                                 w32HChange,
                                 w32HGotFocus,
                                 w32HLostFocus,
                                 w32HScroll,
                                 w32HOpen,
                                 w32HClose,
                                 w32HDestroy,
                                 w32HTimer,
                                 w32HPaint,
                                 w32HDragAndDrop,
                                 w32HEvent,
                                 w32HActivate,
                                 w32HAfterEvent,
                                 w32HDropDown,
                                 w32HCloseUp,
                                 w32HIdle,
                                 w32HKeyboard,
                                 w32HMouseTrap,
                                 w32HDataChange,
                                 w32HGetHandler
                                }

global constant w32EventNames = {
                                 "Break",
                                 "Pause",
                                 "Mouse",
                                 "Click",
                                 "KeyPress",
                                 "KeyUp",
                                 "KeyDown",
                                 "Resize",
                                 "Change",
                                 "GotFocus",
                                 "LostFocus",
                                 "Scroll",
                                 "Open",
                                 "Close",
                                 "Destroy",
                                 "Timer",
                                 "Paint",
                                 "DragAndDrop",
                                 "Event",
                                 "Activate",
                                 "AfterEvent",
                                 "DropDown",
                                 "CloseUp",
                                 "Idle",
                                 "Keyboard",
                                 "Region",
                                 "DataChange",
                                 "GetHandler"
                                }

--/topic Defining Controls
--/const w32ControlTypes
--/desc Holds the values of recognised controls, in the same order as /w32ControlNames.
global sequence w32ControlTypes
--/topic Defining Controls
--/const w32ControlNames
--/desc Holds the names of recognised controls.
global sequence w32ControlNames

sequence vControlRID
    constant
    w32CRID       = series:next_number(0),
    kCRID_Create  = series:next_number(w32CRID),
    kCRID_Destroy = series:next_number(w32CRID),
    kCRID_Process = series:next_number(w32CRID),
    kCRID_Control = series:next_number(w32CRID),
    kCRID_SIZEOF  = series:current_number(w32CRID)
--/**/  if kCRID_SIZEOF then end if -- suppress warnings    -- PL 29/4/09

--/topic Attributes
--/const w32ColorNames
--/desc List of all recognised color names.
global constant w32ColorNames = {
                                 "BLACK",
                                 "NAVYBLUE",
                                 "BLUE",
                                 "BRIGHTBLUE",
                                 "FORESTGREEN",
                                 "GREEN",
                                 "CYAN",
                                 "SKYBLUE",
                                 "BRIGHTGREEN",
                                 "BRIGHTCYAN",
                                 "DARKGRAY",
                                 "EGGPLANT",
                                 "RED",
                                 "MAGENTA",
                                 "DARKBROWN",
                                 "OLIVE",
                                 "GRAY",
                                 "BROWN",
                                 "LIGHTGRAY",
                                 "PURPLE",
                                 "WHITE",
                                 "BRIGHTRED",
                                 "BRIGHTMAGENTA",
                                 "VIOLET",
                                 "ORANGE",
                                 "PINK",
                                 "YELLOW",
                                 "PARCHMENT",
                                 "BRIGHTWHITE"
                                }


global integer
    Screen,         -- id of screen
    Printer         -- id of printer


-----------------------------------------------------------------------------
-- names of indexes for window_change
constant
    MY_SMALLCHANGE      = 1,        -- scroll bar line up/down amount
    MY_LARGECHANGE      = 2         -- scroll bar page up/down amount

-----------------------------------------------------------------------------
sequence
    className,      -- class name
    classType,      -- message class
    classAlias,     -- which class must ctrl_Type reflect
    classStyle,     -- attributes
    classStyleEx,   -- extended class attributes
    classAttr,      -- Attributes used internally by win32lib
    classBGColor,   -- Default background color
    classDefPointer,-- Default shape for Mouse Pointer
    classFGColor,   -- Default foregrond color
    classKbdInput,  -- Default value or routine for WM_GETDLGCODE
    vWindowClassStyle -- The styles used in registering a Window class.

    vWindowClassStyle = {CS_DBLCLKS}--CS_HREDRAW, CS_VREDRAW}

-- hidden classes
constant
    Screen_   = w32NewClass(),
    Printer_  = w32NewClass()

    className       = repeat(-1, w32NumClasses())
    classType       = repeat(-1, w32NumClasses())
    classAlias      = repeat(-1, w32NumClasses())
    classStyle      = repeat(0, w32NumClasses())
    classStyleEx    = repeat(0, w32NumClasses())
    classAttr       = repeat(0, w32NumClasses())
    classDefPointer = repeat(IDC_ARROW, w32NumClasses())
    classBGColor    = repeat(WindowColor, w32NumClasses())
    classFGColor    = repeat(w32Color_WINDOWTEXT, w32NumClasses())
    classKbdInput   = repeat(0, w32NumClasses())

    for i=1 to w32NumClasses() do
        classAlias[i] = i
    end for

integer AutoReBarSizing AutoReBarSizing = w32False

    classAttr[Screen_] = w32NoConv
    classAttr[Printer_] = w32NoConv

global constant
        DLGC_WANTARROWS =#0001,
        DLGC_WANTTAB =#0002,
        DLGC_WANTALLKEYS =#0004,
        DLGC_WANTCHARS =#0008,
        DLGC_WANTENTER  =#0010,
        DLGC_RADIOBUTTON =#0040,
        DLGC_HASSETSEL =#0080,
        DLGC_DEFPUSHBUTTON =#0100,
        DLGC_UNDEFPUSHBUTTON =#0200,
        DLGC_3STATE =#0800,
        DLGC_STATIC =#1000,
        DLGC_BUTTON =#2000

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Window
    --/desc A Window is a normal Win32 window.

    className[Window] = "" -- To be determined at creation time.
    classType[Window] = WINDOW
    classStyle[Window] = WS_OVERLAPPEDWINDOW
    classStyleEx[Window] = WS_EX_ACCEPTFILES
    classAttr[Window] = w32Clickable


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const PushButton
    --/desc Command button control.
    -- A PushButton is a normal push button (sometimes called
    -- /i command /i button). A PushButton has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_PUSHBUTTON: button style is pushbutton
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[PushButton] = "button"
    classType[PushButton] = BUTTON
    classStyle[PushButton] = w32or_all({WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        BS_PUSHBUTTON,
                                        WS_TABSTOP})

    classAttr[PushButton] = 0
    classBGColor[PushButton] = w32BGTransparent
    classKbdInput[PushButton] = DLGC_UNDEFPUSHBUTTON

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const DefPushButton
    --/desc Default command button control.
    -- A DefPushButton is a /PushButton, but
    -- is displayed with an extra border indicating that this button
    -- will automatically be selected if the user presses the Return
    -- button on the keyboard.
    --
    -- A DefPushButton has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_DEFPUSHBUTTON: button style is default pushbutton
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[DefPushButton] = "button"
    classType[DefPushButton] = BUTTON
    classStyle[DefPushButton] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           BS_DEFPUSHBUTTON,
                                           WS_TABSTOP})
    classAttr[DefPushButton] = w32UseSubProc
    classKbdInput[DefPushButton] = DLGC_DEFPUSHBUTTON
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const CancelButton
    --/desc Command button that reacts to the Escape key.
    -- A CancelButton is a /PushButton, but
    -- is displayed with italic font indicating that this button
    -- will automatically be selected if the user presses the Escape
    -- key.
    --
    -- A CancelButton has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[CancelButton] = "button"
    classType[CancelButton] = BUTTON
    classStyle[CancelButton] = w32or_all({WS_CLIPPINGCHILD,
                                          WS_VISIBLE,
                                          BS_PUSHBUTTON,
                                          WS_TABSTOP})
    classAttr[CancelButton] = w32AutoCancel
    classKbdInput[CancelButton] = DLGC_UNDEFPUSHBUTTON
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const CheckBox
    --/desc CheckBox control.
    -- A CheckBox is a button that can be toggled on or off.
    -- It appears as a box with a label to the side. Clicking the
    -- checkbox causes an 'X' to be toggled in the box.
    --
    -- A CheckBox has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_AUTOCHECKBOX: checkbox, default window handling
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[CheckBox] = "button"
    classType[CheckBox] = BUTTON
    classStyle[CheckBox] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      BS_AUTOCHECKBOX,
                                      WS_TABSTOP,
                                      BS_NOTIFY})
    classBGColor[CheckBox] = w32BGTransparent
    classAttr[CheckBox] = w32UseSubProc
    classKbdInput[CheckBox] = DLGC_BUTTON+DLGC_WANTCHARS
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const TriCheckBox
    --/desc Three state checkbox control.
    -- A TriCheckBox is similar to a /CheckBox, but it
    -- has three states: on, off, or dim.
    --
    -- A TriCheckBox has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_AUTO3STATE: tri-state check box
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[TriCheckBox] = "button"
    classType[TriCheckBox] = BUTTON
    classStyle[TriCheckBox] = w32or_all({WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         BS_AUTO3STATE,
                                         WS_TABSTOP,
                                         BS_NOTIFY})
    classAttr[TriCheckBox] = w32UseSubProc
    classBGColor[TriCheckBox] = w32BGTransparent
    classKbdInput[TriCheckBox] = DLGC_BUTTON+DLGC_WANTCHARS+DLGC_3STATE


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Radio
    --/desc Radio button control.
    -- A Radio is similar to a /CheckBox, in functionality.
    -- Like a checkbox, it can be toggled on and off. However, radio buttons
    -- are grouped controls - if one is toggled on, the rest in the group are
    -- toggled off.
    --
    -- Win32Lib considers a radio button in a group if they are contained
    -- by the same /Group control. If there is no /Group control,
    -- then all the radio buttons are considered to belong to the same
    -- group.
    --
    -- A Radio has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_AUTORADIOBUTTON: radio button control
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[Radio] = "button"
    classType[Radio] = BUTTON
    classStyle[Radio] = w32or_all({WS_CHILD,
                                   WS_VISIBLE,
                                   BS_AUTORADIOBUTTON,
                                   WS_TABSTOP,
                                   BS_NOTIFY})
    classStyleEx[Radio] = WS_EX_TRANSPARENT
    --classAttr[Radio] =  w32UseSubProc
    --classBGColor[Radio] = w32BGTransparent
    classKbdInput[Radio] = DLGC_BUTTON + DLGC_RADIOBUTTON

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Group
    --/desc Group control.
    -- A Group is a static control, and receives no events. It's
    -- main function is to seperate other controls into groups.
    --
    -- In addition to providing a visual cue, the group alters the behavior of
    -- the /Radio control; all the radio buttons within a single group are
    -- considered to belong to the same group.
    --
    -- When placing controls in groups, it's a good idea to make them
    -- children of the Group, instead of children of the Window. If you
    -- don't, the Group may end up routing events meant for the control to
    -- itself. For example, /onDragAndDrop events will be routed to the
    -- Group instead of the child.
    --
    -- A Group has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b WS_GROUPBOX: group box control

    className[Group] = "button"
    classType[Group] = BUTTON
    classStyle[Group] = w32or_all({WS_CHILD,
                                   WS_CLIPSIBLINGS,
                                   WS_VISIBLE,
                                   BS_GROUPBOX,
                                   WS_TABSTOP})
    classAttr[Group] = w32Clickable + w32UseSubProc + w32HasChildren
    classStyleEx[Group] = WS_EX_TRANSPARENT
    classKbdInput[Group] = DLGC_STATIC


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const SortedList
    --/desc Sorted list control.
    -- A SortedList contains a list of items, arranged in alphabetical
    -- order. To have an unsorted list, use the /List control instead.
    --
    -- A SortedList has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b LBS_NOTIFY: notify parent of events
    -- /li /b LBS_SORT: sort items in list
    -- /li /b WS_VSCROLL: attach a vertical scroll bar
    -- /li /b WS_BORDER: draw a border on the control
    -- /li /b WS_TABSTOP: the control can be tabbed to
    -- /li /b WS_EX_CLIENTEDGE: 3D effect
    -- /li /b WS_EX_ACCEPTFILES: drag and drop support


    className[SortedList] = "listbox"
    classType[SortedList] = LISTBOX
    classStyle[SortedList] = w32or_all({WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        LBS_NOTIFY,
                                        LBS_SORT,
                                        WS_VSCROLL,
                                        WS_BORDER,
                                        WS_TABSTOP})

    classStyleEx[SortedList] = w32or_all({WS_EX_CLIENTEDGE,
                                          WS_EX_ACCEPTFILES})

    classAttr[SortedList] = w32Clickable
    classBGColor[SortedList] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[SortedList] = DLGC_WANTARROWS+DLGC_WANTCHARS
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const List
    --/desc List.
    -- A List contains a list of items, arranged in the order that
    -- they were placed into the list. To have a sorted list, either sort
    -- the items before placing them into the list, or use the /SortedList
    -- control.
    --
    -- A List has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b LBS_NOTIFY: notify parent of events
    -- /li /b WS_VSCROLL: attach a vertical scroll bar
    -- /li /b WS_BORDER: draw a border on the control
    -- /li /b WS_TABSTOP: the control can be tabbed to
    -- /li /b WS_EX_CLIENTEDGE: 3D effect
    -- /li /b WS_EX_ACCEPTFILES: drag and drop support

    className[List] = "listbox"
    classType[List] = LISTBOX
    classStyle[List] = w32or_all({WS_CLIPPINGCHILD,
                                  WS_VISIBLE,
                                  LBS_NOTIFY,
                                  WS_VSCROLL,
                                  WS_BORDER,
                                  WS_TABSTOP})

    classStyleEx[List] = w32or_all({WS_EX_CLIENTEDGE,
                                    WS_EX_ACCEPTFILES})

    classAttr[List] = w32Clickable
    classBGColor[List] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[List] = DLGC_WANTARROWS+DLGC_WANTCHARS

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Combo
    --/desc Combo box control.
    -- A Combo is a combination of an edit control and a list.
    -- If you need the items in the combo to be sorted, use a /SortedCombo
    -- instead. In addition to being able to select a value from the combo's
    -- list, the user can enter their own value as well.
    --
    -- A Combo has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b WS_VSCROLL: attach a vertical scroll bar
    -- /li /b CBS_DROPDOWN: the list can drop down, like a menu
    -- /li /b CBS_HASSTRINGS: contains string values
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[Combo] = "combobox"
    classType[Combo] = COMBO
    classStyle[Combo] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   WS_VSCROLL,
                                   CBS_DROPDOWN,
                                   CBS_HASSTRINGS,
                                   WS_TABSTOP})
    classStyleEx[Combo] = w32or_all({WS_EX_CLIENTEDGE,
                                     WS_EX_ACCEPTFILES})
    classAttr[Combo] = w32Clickable
    classBGColor[Combo] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[Combo] =DLGC_WANTARROWS+DLGC_WANTCHARS


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const SortedCombo
    --/desc Sorted combo box control.
    -- A SortedCombo is a combination of an edit control and a list.
    --
    -- A SortedCombo has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b WS_VSCROLL: attach a vertical scroll bar
    -- /li /b CBS_DROPDOWN: the list can drop down, like a menu
    -- /li /b CBS_HASSTRINGS: contains string values
    -- /li /b CBS_SORT: sorted
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[SortedCombo] = "combobox"
    classType[SortedCombo] = COMBO
    classStyle[SortedCombo] = w32or_all({WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         WS_VSCROLL,
                                         CBS_DROPDOWN,
                                         CBS_HASSTRINGS,
                                         CBS_SORT,
                                         WS_TABSTOP})
    classStyleEx[SortedCombo] = w32or_all({WS_EX_CLIENTEDGE,
                                           WS_EX_ACCEPTFILES})
    classAttr[SortedCombo] = w32Clickable
    classBGColor[SortedCombo] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[SortedCombo] = DLGC_WANTARROWS+DLGC_WANTCHARS

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const SimpleCombo
    --/desc Simple combo box control.
    -- A SimpleCombo is a combo box with no dropdown. The user can
    -- select from various values by using the cursor keys.
    --
    -- A SimpleCombo has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b CBS_SIMPLE: has a list of values
    -- /li /b CBS_HASSTRINGS: contains string values
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[SimpleCombo] = "combobox"
    classType[SimpleCombo] = COMBO
    classStyle[SimpleCombo] = w32or_all({WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         CBS_SIMPLE,
                                         CBS_HASSTRINGS,
                                         WS_TABSTOP})
    classStyleEx[SimpleCombo] = w32or_all({WS_EX_CLIENTEDGE,
                                           WS_EX_ACCEPTFILES})
    classAttr[SimpleCombo] = w32Clickable
    classBGColor[SimpleCombo] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[SimpleCombo] =DLGC_WANTARROWS+DLGC_WANTCHARS


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const DropDownList
    --/desc Drop down list control.
    -- A DropDownList is like a /Combo, but the user can only
    -- select items on the list, and not enter their own value into the edit
    -- box.
    --
    -- A DropDownList has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b WS_VSCROLL: attach a vertical scroll bar
    -- /li /b CBS_DROPDOWNLIST: the list can drop down, like a menu
    -- /li /b CBS_HASSTRINGS: contains string values
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[DropDownList] = "combobox"
    classType[DropDownList] = COMBO
    classStyle[DropDownList] = w32or_all({WS_CLIPPINGCHILD,
                                          WS_VISIBLE,
                                          WS_VSCROLL,
                                          CBS_DROPDOWNLIST,
                                          CBS_HASSTRINGS,
                                          WS_TABSTOP})
    classStyleEx[DropDownList] = w32or_all({WS_EX_CLIENTEDGE,
                                            WS_EX_ACCEPTFILES})
    classAttr[DropDownList] = w32Clickable
    classBGColor[DropDownList] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[DropDownList] = DLGC_WANTARROWS+DLGC_WANTCHARS

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const EditText
    --/desc Text edit control control.
    -- An EditText allows the user to enter a single-line of text into the control.
    --
    -- /b Note that when the user presses the Return Key, the focus will move to the next control
    -- in the focus order. To prevent this from happening, you need to set a /w32HKeyPress handler
    -- that sets the return value to -1 when a VK_RETURN key without shifts is received.
    --
    --/code
    --      procedure IgnoreReturn(integer self, integer event, sequence parms)
    --          if parms[1] = VK_RETURN and parms[2] = 0 then
    --              returnValue(-1)
    --          end if
    --      end procedure
    --      setHandler(myEditField, w32HKeyPress, routine_id("IgnoreReturn"))
    --/endcode
    --
    -- A EditText has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b ES_AUTOHSCROLL: automatic vertical scrollbar, if needed
    -- /li /b ES_LEFT: left justify the text
    -- /li /b WS_BORDER: draw with a border
    -- /li /b WS_TABSTOP: the control can be tabbed to
    -- /li /b WS_EX_CLIENTEDGE: 3D effect
    -- /li /b WS_EX_ACCEPTFILES: drag and drop support

    -- single line edit, left justified
    className[EditText] = "edit"
    classType[EditText] = EDIT
    classStyle[EditText] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_TABSTOP,
                                      WS_BORDER,
                                      ES_AUTOHSCROLL,
                                      ES_LEFT})

    classStyleEx[EditText] = w32or_all({WS_EX_CLIENTEDGE,
                                        WS_EX_ACCEPTFILES})
    classAttr[EditText] = w32AutoSelect
    classDefPointer[EditText] = IDC_IBEAM
    classBGColor[EditText] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[EditText] = DLGC_WANTARROWS+DLGC_WANTCHARS+DLGC_HASSETSEL--+DLGC_WANTMESSAGE

    -- MSDN says that, if the user presses Alt-Backspace, the control also returns DLGC_WANTMESSAGE. I don't know what this is about.

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const MleText
    --/desc Multi-line edit control.
    -- An MleText (multi-line edit) control is like a mini-text editor.
    -- The user can enter in multiple lines of text.
    --
    -- Since the Tab key is accepted as input into the MLE, the user has to
    -- press Control+Tab to move to the next control, instead of the standard
    -- Tab key.
    --
    -- A MleText has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b WS_HSCROLL: horizontal scroll bar
    -- /li /b WS_VSCROLL: vertical scroll bar
    -- /li /b ES_LEFT: left justify the text
    -- /li /b WS_BORDER: draw with a border
    -- /li /b ES_MULTILINE: allow multiple lines of text
    -- /li /b WS_TABSTOP: the control can be tabbed to
    -- /li /b WS_EX_CLIENTEDGE: 3D effect
    -- /li /b WS_EX_ACCEPTFILES: drag and drop support

    className[MleText] = "edit"
    classType[MleText] = EDIT
    classStyle[MleText] = w32or_all({WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     WS_TABSTOP,
                                     WS_VSCROLL,
                                     WS_BORDER,
                                     ES_LEFT,
                                     ES_MULTILINE})
    classStyleEx[MleText] = w32or_all({WS_EX_CLIENTEDGE,
                                       WS_EX_ACCEPTFILES})
    classAttr[MleText] = w32CtrlTab
    classDefPointer[MleText] = IDC_IBEAM
    classBGColor[MleText] = w32Color_WINDOW
    classKbdInput[MleText] = DLGC_WANTARROWS+DLGC_WANTCHARS+DLGC_HASSETSEL--+DLGC_WANTMESSAGE
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const LText
    --/desc Left-justified label control.
    -- An LText control does not respond to events.
    --
    -- An LText has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b ES_LEFT: left justify the text
    -- /li /b SS_NOTIFY: Enable click events


    className[LText] = "static"
    classType[LText] = STATIC
    classStyle[LText] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   ES_LEFT,
                                   SS_NOTIFY})
    classAttr[LText] = 0
    classBGColor[LText] = w32BGTransparent
    classKbdInput[LText] = DLGC_STATIC
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const RText
    --/desc Right-justified label control.
    -- An RText control does not respond to events.
    --
    -- An RText has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b ES_RIGHT: right justify the text
    -- /li /b SS_NOTIFY: Enable click events

    className[RText] = "static"
    classType[RText] = STATIC
    classStyle[RText] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   ES_RIGHT,
                                   SS_NOTIFY})
    classAttr[RText] = 0
    classBGColor[RText] = w32BGTransparent
    classKbdInput[RText] = DLGC_STATIC


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const CText
    --/desc Center-justified label control.
    -- A CText control does not respond to events.
    --
    -- A CText has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b ES_CENTER: center justify the text
    -- /li /b SS_NOTIFY: Enable click events

    className[CText] = "static"
    classType[CText] = STATIC
    classStyle[CText] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   ES_CENTER,
                                   SS_NOTIFY})
    classAttr[CText] = 0
    classBGColor[CText] = w32BGTransparent
    classKbdInput[CText] = DLGC_STATIC


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const HScroll
    --/desc Horizontal scrollbar control.
    -- An HScroll has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b SBS_HORZ: horizontal scroll bar
    -- /li /b WS_TABSTOP: the control can be tabbed to


    -- horizontal scroll bar
    className[HScroll] = "scrollbar"
    classType[HScroll] = SCROLLBAR
    classStyle[HScroll] = w32or_all({WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     SBS_HORZ,
                                     WS_TABSTOP})
    classAttr[HScroll] = w32UseSubProc + w32NoRenderDisabled
    classBGColor[HScroll] = w32WinDefColor
    classKbdInput[HScroll] = DLGC_WANTARROWS

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const VScroll
    --/desc Vertical scrollbar control.
    --
    -- A VScroll has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b SBS_VERT: vertical scroll bar
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[VScroll] = "scrollbar"
    classType[VScroll] = SCROLLBAR
    classStyle[VScroll] = w32or_all({WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     SBS_VERT,
                                     WS_TABSTOP})
    classAttr[VScroll] = w32UseSubProc + w32NoRenderDisabled
    classBGColor[VScroll] = w32WinDefColor
    classKbdInput[VScroll] = DLGC_WANTARROWS

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Icon
    --/desc Icon control.
    -- An Icon is a static small graphic. As a static control, it does
    -- not respond to events.
    --
    -- An Icon has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b SS_ICON: icon
    -- /li /b SS_NOTIFY: Enable click events

    className[Icon] = "static"
    classType[Icon] = STATIC
    classStyle[Icon] = w32or_all({WS_CLIPPINGCHILD,
                                  WS_VISIBLE,
                                  SS_ICON,
                                  SS_NOTIFY})
    classAttr[Icon] = 0
    classKbdInput[Icon] = DLGC_STATIC

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Bitmap
    --/desc Static bitmap control.
    -- A Bitmap does not respond to events.
    --
    -- A Bitmap has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b SS_BITMAP: bitmap
    -- /li /b SS_NOTIFY: Enable click events

    className[Bitmap] = "static"
    classType[Bitmap] = STATIC
    classStyle[Bitmap] = w32or_all({WS_CLIPPINGCHILD,
                                    WS_VISIBLE,
                                    SS_BITMAP,
                                    SS_NOTIFY})
    classAttr[Bitmap] = 0
    classKbdInput[Bitmap] = DLGC_STATIC

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Menu
    --/desc Menu bar item control.
    -- A Menu is an item in a window's menubar. There is no need to
    -- declare a menubar for a window; if a Menu is created, the menubar
    -- will automatically be created for it.


    -- menu bar item
    className[Menu] = ""
    classType[Menu] = MENU
    classAttr[Menu] = w32NoConv

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Popup
    --/desc Popup menu control.
    -- A Popup is a menu not attached to a window. To display a popup,
    -- use /popup().

    className[Popup] = ""
    classType[Popup] = POPUP

    classAttr[Popup] = w32NoConv

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const MenuItem
    --/desc Dropdown menu item control.
    -- A MenuItem is an item in a window's Menu. Menu items are
    -- placed sequentially into menus.
    --
    -- There is currently no way to remove menu items.

    className[MenuItem] = ""
    classType[MenuItem] = MENUITEM

    classAttr[MenuItem] = w32NoConv
    -----------------------------------------------------------------------------

    --/topic Controls
    --/const MenuSpacer
    --/desc Horizontal spacer (line) in menu items.
    -- A MenuSpacer is placed as a horizontal line in a window's Menu.
    --
    -- There is currently no way to remove menu items.

    className[MenuSpacer] = ""
    classType[MenuSpacer] = MENUITEM

    classAttr[MenuSpacer] = w32NoConv

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const Pixmap
    --/desc Color bitmap.
    -- A Pixmap is an off-screen color bitmap. It can be displayed
    -- in a window by using one of the /i bitblt functions (see
    -- Graphics for details).

    className[Pixmap] = ""
    classType[Pixmap] = PIXMAP
    classAttr[Pixmap] = w32NoConv

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const ToolBar
    --/desc Window toolbar control.
    -- A ToolBar is a container at the top of a window that can hold
    -- other controls - typically /PushButtons or /ToggleButtons.
    -- Toolbars are implemented using the Win32 common control toolbar.
    --
    -- When the parent window is resized, Win32Lib automatically repositions
    -- the ToolBar.
    --
    -- Note that the toolbar occupies space like any other control. To determine
    -- what portion of the window's client area is not occupied by the toolbar
    -- (and statusbar), use the /getClientRect function.
    --
    -- A ToolBar has the following attributes:
    --
    -- /li /b CCS_TOP: place on top of the window
    -- /li /b CCS_NORESIZE: don't automatically resize (Win32Lib does it)
    -- /li /b WS_CHILD: child control of parent
    -- /li /b WS_BORDER: draw a border
    -- /li /b WS_CLIPSIBLINGS: clip child controls

    className[ToolBar] = TOOLBARCLASSNAMEA
    classType[ToolBar] = COMMON_CONTROL
    classStyle[ToolBar] = w32or_all({CCS_TOP,
                                     CCS_NORESIZE,
                                     WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     WS_BORDER})

    classAttr[ToolBar] = w32NoConv + w32Clickable + w32OwnerId + w32Toolbar

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const StatusBar
    --/desc Window status bar control.
    -- A StatusBar is a control placed at the bottom of the window
    -- that status messages can be written into.
    -- The status bar is implemented using the Win32 common control toolbar.
    --
    -- When the parent window is resized, Win32Lib automatically repositions
    -- the StatusBar.
    --
    -- Note that the status bar occupies space like any other control. To
    -- determine what portion of the window's client area is not occupied by
    -- the statusbar (and toolbar), use the /getClientRect function.
    --
    -- A StatusBar has the following attributes:
    --
    -- /li /b CCS_BOTTOM: place on bottom of the window
    -- /li /b WS_CHILD: child control of parent
    -- /li /b WS_BORDER: draw a border
    -- /li /b WS_CLIPSIBLINGS: clip child controls

    className[StatusBar]    = STATUSCLASSNAMEA
    classType[StatusBar]    = COMMON_CONTROL
    classStyle[StatusBar] = w32or_all({WS_CLIPPINGCHILD,
                                       WS_VISIBLE,
                                       CCS_BOTTOM})

    classAttr[StatusBar] = w32Clickable + w32OwnerId  + w32Statusbar
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const PictureButton
    --/desc Command button with graphic control.
    -- A PictureButton is a /PushButton with a graphic instead
    -- of text. The graphic can be specified by passing the name or address of
    -- a bitmap control in the /i flags parameter, or with /setBitmap,
    -- /setIcon
    --
    -- A PictureButton is typically used in a /ToolBar.
    --
    -- This can show either an Icon or a Bitmap. The choice is made when
    -- the control is created using the /create() routine. When being created,
    -- the /i style parameter is used to designate the image and format of
    -- images on the button. The /i style parameter can be one of ... /n
    --/li /w32PB_BITMAP which indicates that the application will later explicitly
    -- set a bitmap image to the button.
    --/li 0 which is the same as /i w32PB_BITMAP
    --/li /w32PB_ICON which indicates that the application will later explicitly
    -- set an icon image to the button.
    --/li A handle to a pre-loaded bitmap image.
    --/li A handle to a pre-loaded icon image.
    --/li A filename to either a .BMP or a .ICO file.
    --
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_PUSHBUTTON: button style is pushbutton
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[PictureButton] = "button"
    classType[PictureButton] = BUTTON
    classStyle[PictureButton] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           BS_PUSHBUTTON,
                                           WS_TABSTOP})
    classAttr[PictureButton] = w32PictCtrl
    classKbdInput[PictureButton] =DLGC_DEFPUSHBUTTON
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const ToggleButton
    --/desc Toggle button control.
    -- A ToggleButton is a /PushButton that behaves like a
    -- /CheckBox - clicking it toggles it down, clicking again toggles
    -- it back up. It is typically used in a /ToolBar.
    --
    -- This can show either an Icon or a Bitmap. The choice is made when
    -- the control is created using the /create() routine. When being created,
    -- the /i style parameter is used to designate the image and format of
    -- images on the button. The /i style parameter can be one of ... /n
    --/li w32PB_BITMAP which indicates that the application will later explicitly
    -- set a bitmap image to the button.
    --/li 0 which is the same as /i w32PB_BITMAP
    --/li w32PB_ICON which indicates that the application will later explicitly
    -- set an icon image to the button.
    --/li A handle to a pre-loaded bitmap image.
    --/li A handle to a pre-loaded icon image.
    --/li A filename to either a .BMP or a .ICO file.
    --
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_PUSHBUTTON: button style is pushbutton
    -- /li /b BS_BITMAP: displays a bitmap
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[ToggleButton] = "button"
    classType[ToggleButton] = BUTTON
    classStyle[ToggleButton] = w32or_all({WS_CLIPPINGCHILD,
                                          WS_VISIBLE,
                                          BS_PUSHLIKE,
                                          BS_AUTOCHECKBOX,
                                          WS_TABSTOP})

    classAttr[ToggleButton] = 0
    classKbdInput[ToggleButton] =DLGC_BUTTON+DLGC_WANTCHARS
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const TogglePicture
    --/desc Toggle button with graphic control.
    -- A TogglePicture is a combination of a /ToggleButton
    -- and a /PictureButton. The graphic can be specified by passing the
    -- name or address of a bitmap in the /i flags parameter, or with
    -- /setBitmap, /setIcon
    --
    -- This can show either an Icon or a Bitmap. The chice is made when
    -- the control is created using the /create() routine.
    --
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b BS_PUSHBUTTON: button style is pushbutton
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[TogglePicture] = "button"
    classType[TogglePicture] = BUTTON
    classStyle[TogglePicture] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           BS_PUSHLIKE,
                                           BS_AUTOCHECKBOX,
                                           WS_TABSTOP})
    classAttr[TogglePicture] = w32PictCtrl
    classKbdInput[TogglePicture] =DLGC_BUTTON+DLGC_WANTCHARS

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const HTrackBar
    --/desc Horizontal track bar control.
    -- An HTrackBar has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b TBS_HORZ: vertical scrollbar
    -- /li /b TBS_AUTOTICKS: ticks automatically created
    -- /li /b TBS_ENABLESELRANGE: range highlighted, triangles at end of range
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[HTrackBar] = TRACKBAR_CLASSA
    classType[HTrackBar] = COMMON_CONTROL
    classStyle[HTrackBar] = w32or_all({WS_CLIPPINGCHILD,
                                       WS_VISIBLE,
                                       TBS_HORZ,
                                       TBS_AUTOTICKS,
                                       TBS_ENABLESELRANGE,
                                       WS_TABSTOP})
    classAttr[HTrackBar] = w32Clickable + w32OwnerId
    classKbdInput[HTrackBar] =DLGC_WANTARROWS
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const VTrackBar
    --/desc Vertical track bar control.
    -- A VTrackBar has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b TBS_VERT: vertical scrollbar
    -- /li /b TBS_AUTOTICKS: ticks automatically created
    -- /li /b TBS_ENABLESELRANGE: range highlighted, triangles at end of range
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[VTrackBar] = TRACKBAR_CLASSA
    classType[VTrackBar] = COMMON_CONTROL
    classStyle[VTrackBar] = w32or_all({WS_CLIPPINGCHILD,
                                       WS_VISIBLE,
                                       TBS_VERT,
                                       TBS_AUTOTICKS,
                                       TBS_ENABLESELRANGE,
                                       WS_TABSTOP})
    classAttr[VTrackBar] = w32Clickable + w32OwnerId
    classKbdInput[VTrackBar] = DLGC_WANTARROWS

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const TabControl
    --/desc Tab Control.
    -- A TabControl is a container control. It can have one or more /TabItems.
    -- Selecting a /TabItem in a TabControl activates it, and displays any
    -- controls that are associated with it.
    --
    -- Since the TabControl is a container, controls can be placed into it,
    -- just like placing them into a window. However, it becomes the coder's
    -- responsibility to show and hide various controls as different /TabItems
    -- are selected. It is easier to associate controls with /TabItems, since
    -- Win32Lib will automatically take care of those details.
    --
    -- The TabControl has the following attributes:
    --
    -- /li /b WS_CHILD: child control of the parent
    -- /li /b WS_VISIBLE: it is visible
    -- /li /b WS_CLIPCHILDEN: controls not fitting on the TabControl are clipped.
    -- /li /b WS_TABSTOP: the control can be tabbed to

    className[TabControl] = WC_TABCONTROLA
    classType[TabControl] = COMMON_CONTROL
    classStyle[TabControl] = w32or_all({WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        WS_CLIPCHILDREN,
                                        WS_TABSTOP})
    classAttr[TabControl] = w32Clickable + w32OwnerId
    classKbdInput[TabControl] = DLGC_WANTARROWS+DLGC_WANTCHARS


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const TabItem
    --/desc Tab on a TabControl.
    -- A TabItem is a tab attached to the top of a /TabControl. TabItems respond
    -- to being selected by triggering an /onClick event.
    --
    -- Items can be automatically displayed in a /TabControl by setting their
    -- owner to the TabItem instead of the /TabControl. Win32Lib will
    -- automatically reparent controls with TabItems to the TabControl, and
    -- maintain a logical association between them. For example:
    --
    --/code
    --  constant
    --    Win     = create(Window, "Testing", 0, Default, Default, 100, 100, 0),
    --    Tabs    = create(TabControl, "", Win, 10, 10, 80, 80, 0),
    --    Tab1    = create(TabItem, "Tab Number &1", Tabs, 0, 0, 0, 0, 0),
    --    Tab2    = create(TabItem, "Tab Number &2", Tabs, 0, 0, 0, 0, 0),
    --    Button1 = create(PushButton, "Button 1", Tab2, 10, 60, 80, 40, 0)
    --
    --/endcode
    --
    -- In the example above, Button1 is created in Tabs (the parent of Tab2).
    -- When Tab2 is clicked, it will appear in Tabs at {10,60}. When Tab1 is
    -- clicked, it will disappear from Tabs.

    className[TabItem] = "w32 TabItem"
    classType[TabItem] = -1 -- Not a real class
    classStyle[TabItem] = 0 -- WS_TABSTOP
    classAttr[TabItem] = w32Clickable + w32Virtual
    classBGColor[TabItem] = w32WinDefColor
    classKbdInput[TabItem] =DLGC_WANTARROWS+DLGC_WANTCHARS


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const ProgressBar
    --/desc Progress Bar
    -- A ProgressBar is used to show what amount of a task is complete.
    -- To move the position of the ProgressBar indicator, call /setScrollPos.
    -- By default, the ProgressBar ranges from 1 to 100. You can change the
    -- range by calling /setScrollRange().
    --
    -- For the most part, the ProgressBar behaves like most other
    -- /"Scroll Controls".
    --
    -- The following example creates a /Window that contains a /Timer and
    -- a /ProgressBar. As the /Timer ticks, the ProgressBar is automatically
    -- incremented.
    --
    --/code
    --  constant
    --      Win   = /create(/Window,"Timer Window",0,Default,Default,200,100,0),
    --      PBar  = /create(/ProgressBar,"",Win,5,40,180,20,0),
    --      Timer = 1
    --
    --  procedure tick(integer self, integer event, sequence parms)
    --      integer timerId
    --      timerId = parms[1]
    --      -- advance the progress bar by 5 ticks
    --      /setScrollPos(PBar, /getScrollPos(PBar)+5)
    --  end procedure
    --  setHandler(Win, w32HTimer, routine_id("tick"))
    --
    --  -- tick once per second
    --  /setTimer(Win, Timer, 1000)
    --
    --  /WinMain(Win, Normal)
    --/endcode

    className[ProgressBar] = PROGRESS_CLASSA
    classType[ProgressBar] = COMMON_CONTROL
    classStyle[ProgressBar] = w32or_all({WS_CHILD,WS_VISIBLE})

    classAttr[ProgressBar] = w32Clickable + w32OwnerId

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const ListView
    --/desc ListView
    -- A list view control is a window that displays collection of
    -- items, each item consisting of an icon and a label.  List
    -- view controls provide several ways of arranging items and
    -- displaying individual items.  For example, additional information
    -- about each item can be displayed in columns to the right of the
    -- icon and label.
    --
    -- List views have 3 modes:
    -- /li Icon
    -- /li List
    -- /li Report
    --
    -- Report mode can display multiple columns, which can be defined
    -- upon creation of the control:
    --
    -- /code
    --      Win = create(/Window, "The Window", 0, 0, 0, 300, 300, 0),
    --      lv  = create(ListView, {"Column 1", Column 2"}, Win,
    --                  20, 20, 200, 200, LVS_REPORT)
    --      WinMain(Win, Normal)
    -- /endcode
    --
    -- See also: /addIcon, /addLVItem, /deleteItem

    className[ListView] = WC_LISTVIEWA
    classType[ListView] = COMMON_CONTROL
    classStyle[ListView] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_BORDER,
                                      WS_TABSTOP,
                                      LVS_SHAREIMAGELISTS})
    classStyleEx[ListView] = WS_EX_CLIENTEDGE
    classAttr[ListView] = w32Clickable + w32OwnerId
    classBGColor[ListView] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[ListView] = DLGC_WANTTAB+DLGC_WANTARROWS

    constant
    lv_Default_Properties = {0, -2, 0, 0},
    lvitem_MASK = w32or_all({LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM})

--/topic Constants
--/const kLVColTypes
--/desc Used by /setLVAttr

--/topic Constants
--/const kLVSortSeq
--/desc Used by /setLVAttr


sequence
        lv_id,
        lvitem_owner,
        lvitem_lparam,
        lv_properties,
        ilicon_list

        lv_id = {}
        lvitem_owner = {}
        lvitem_lparam = {}
        lv_properties = {}
        ilicon_list = {}
integer
        lvInsertWhere
        lvInsertWhere = 1
atom
        vNextLVItemID
        vNextLVItemID = 0

atom    ILlarge,hILlarge,
        ILsmall,hILsmall

    ILlarge = 0
    ILsmall = 0
    hILlarge = 0
    hILsmall = 0
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const TreeView
    --/desc TreeView
    -- A tree view control is a window that displays a hierarchical list
    -- of items, such as the headings in a document, the entries in an index,
    -- or the files and directories on a disc.  Each item consists of a label
    -- and an optional bitmapped image, and each item can have a list of subitems
    -- associated with it.  By clicking an item, the user can expand and collapse
    -- the associated list of subitems.
    --
    -- See also: /addTVItem, /deleteItem, /hitTestTV


    className[TreeView] = WC_TREEVIEWA
    classType[TreeView] = COMMON_CONTROL
    classStyle[TreeView] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_TABSTOP,
                                      WS_BORDER})
    classStyleEx[TreeView] = WS_EX_CLIENTEDGE
    classAttr[TreeView] =  w32OwnerId
    classBGColor[TreeView] = w32Color_WINDOW
    classKbdInput[TreeView] = DLGC_WANTARROWS+DLGC_WANTCHARS

sequence tv_id, tvitem_data, tvitem_owner, tvitem_parent, tvitem_handle
constant
        ktv_Blank = repeat(0, 5),
        tvitem_MASK = w32or_all({TVIF_TEXT,
                                 TVIF_IMAGE,
                                 TVIF_SELECTEDIMAGE,
                                 TVIF_PARAM,
                                 TVIF_CHILDREN}),
        ktv_TextAddr = 1,
        ktv_TextSize = 2,
        ktv_NormImage = 3,
        ktv_SelectImage = 4,
        ktv_HasChildren = 5


    tv_id = {}
    tvitem_owner = {}
    tvitem_data = {}
    tvitem_parent = {}
    tvitem_handle = {}

    -----------------------------------------------------------------------------
    --/topic Controls
    --/const RichEdit
    --/desc RichEdit
    -- A rich edit control is a window in which the user can enter and edit
    -- text.  The text can be assigned character and paragraph formatting,
    -- and can include embedded OLE objects.  Rich edit controls provide a
    -- programming interface for formatting text.  However, and application
    -- must implement any user interface components necessary to make formatting
    -- operations available to the user.
    --
    -- Example:
    --
    --/code
    --           -- Create the RichEdit control
    --           RE = /create(/RichEdit, "", Win, 20, 20, 360, 200, ES_NOHIDESEL)
    --/endcode

    className[RichEdit] = WC_RICHEDIT
    classType[RichEdit] = COMMON_CONTROL
    classStyle[RichEdit] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_VSCROLL,
                                      ES_DISABLENOSCROLL,
                                      ES_AUTOVSCROLL,
                                      WS_TABSTOP,
                                      ES_SAVESEL,
                                      ES_MULTILINE,
                                      WS_BORDER})
    classStyleEx[RichEdit] = WS_EX_CLIENTEDGE
    classAttr[RichEdit] = w32CtrlTab + w32OwnerId
    classDefPointer[RichEdit] = IDC_IBEAM

    classBGColor[RichEdit] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[RichEdit] = DLGC_WANTALLKEYS+DLGC_WANTARROWS+DLGC_WANTCHARS+DLGC_HASSETSEL--(+DLGC_WANTMESSAGE)
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const MonthCalendar
    --/desc MonthCalendar
    -- MonthCalendar is a control used for selecting dates.  It displays
    -- a calendar (one month at a time) from which the user can select a
    -- date or a range of dates.
    --
    -- See also: /formatDate(), /getSelectedDate(), /getSelectedDateRange(),
    --          /setMonthColor(), /setSelectedDate(), /setSelectedDateRange()

    className[MonthCalendar] = MONTHCAL_CLASS
    classType[MonthCalendar] = COMMON_CONTROL
    classStyle[MonthCalendar] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           WS_TABSTOP,
                                           WS_BORDER})
    classStyleEx[MonthCalendar] = MCS_DAYSTATE
    classAttr[MonthCalendar] =  w32OwnerId
    classKbdInput[MonthCalendar] = DLGC_WANTARROWS
    --/topic Controls
    --/const UpDown
    --/desc UpDown
    -- An Up-Down control is a pair of arrow buttons that the user can click
    -- to increment or decrement a vaue, such as a scroll position or a number
    -- displayed in a companion control.  The value associated with an up-down
    -- control is called its /i current /i position.  An up-down control is
    -- most often used with a companion control, which is called a /i buddy
    -- /i window.  The updown control will take care of scroll events
    -- automatically.
    --
    -- There are two ways to set a buddy window:
    -- /li style flag /b UDS_AUTOBUDDY sets the buddy to the previous control
    -- /li /setBuddy(id) sets control id to the buddy window
    --
    -- Typical flags for an UpDown control are ...
    --/code
    --        w32or_all({UDS_ALIGNRIGHT,
    --                   UDS_SETBUDDYINT,
    --                   UDS_ARROWKEYS,
    --                   UDS_NOTHOUSANDS    -- Avoids a thousands separator.
    --                  })
    --/endcode
    --
    -- See also: /getScrollPos, /setBuddy, /setScrollPos, /setScrollRange


    className[UpDown] = UPDOWN_CLASSA
    classType[UpDown] = COMMON_CONTROL
    classStyle[UpDown] = w32or_all({WS_CLIPPINGCHILD,
                                    WS_VISIBLE})
    classAttr[UpDown] = w32OwnerId
    classKbdInput[UpDown] = DLGC_WANTARROWS
    -----------------------------------------------------------------------------
    --/topic Controls
    --/const ReBar
    --/desc ReBar
    -- Rebars are similar to toolbars, but can do some fancier things.  You
    -- can put any sort of control into a rebar.
    --
    -- Example:
    -- /code
    --      -- create the rebar
    --      rebar = /create(/ReBar, "", owner, x, y, cx, cy, flags)
    --      -- create a band for the rebar
    --      band = /create(/ReBarBand, caption, rebar, 0, 0, cx, cy, flags)
    --          --[NOTE: to create the band on a new line within the rebar,
    --          -- use RBBS_BREAK]
    --          -- add controls to the bands.  Controls should be children
    --          -- of the rebar.
    --      combo = /create(/Combo, "", rebar, 0, 0, cx, cy, flags)
    --      /addToBand(combo, band)
    -- /endcode
    --
    -- See also: /addToBand(), /ReBarBand

    className[ReBar] = REBARCLASSNAME
    classType[ReBar] = COMMON_CONTROL
    classStyle[ReBar] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   WS_TABSTOP,
                                   WS_CLIPCHILDREN,
                                   CCS_ADJUSTABLE,
                                   WS_BORDER})
    classStyleEx[ReBar] = WS_EX_CLIENTEDGE
    classAttr[ReBar] = w32NoConv + w32OwnerId + w32Toolbar


    --/topic Controls
    --/const ToolTip
    --/desc Creates a ToolTip control.
    --This is not normally required as one is automatically created for
    --your application whenever you use /setHint() or supply tooltip
    --text when creating a control.

    className[ToolTip] = TOOLTIPS_CLASSA
    classType[ToolTip] = COMMON_CONTROL
    classStyle[ToolTip] = TTS_ALWAYSTIP
    classStyleEx[ToolTip] = WS_EX_TOPMOST
    classAttr[ToolTip] = w32NoConv


    -----------------------------------------------------------------------------
    --/topic Controls
    --/const FlatToolbar
    --/desc Creates a toolbar without a 3D border.


    className[FlatToolBar] = TOOLBARCLASSNAMEA
    classType[FlatToolBar] = COMMON_CONTROL
    classStyle[FlatToolBar] = w32or_all({CCS_TOP,
                                         CCS_NORESIZE,
                                            --CCS_ADJUSTABLE,
                                         WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         WS_BORDER,
                                         WS_TABSTOP,
                                         TBSTYLE_FLAT,
                                         TBSTYLE_TOOLTIPS})
    classStyleEx[FlatToolBar] = TBSTYLE_EX_DRAWDDARROWS
    classAttr[FlatToolBar] = w32NoConv + w32Clickable + w32OwnerId + w32Toolbar

atom himlFTBDefault, himlFTBHot, himlFTBDisabled
sequence FTB_images

    himlFTBDefault = 0
    himlFTBHot = 0
    himlFTBDisabled = 0
    FTB_images = {}

    --/topic Controls
    --/const SepButton
    --/desc Separator button for use with /FlatToolBar Controls
    -- This should only be used with /FlatToolBar controls.  It creates
    -- a divider between buttons, which is shown as a vertical line.
    className[SepButton] = "button"
    classType[SepButton] = BUTTON
    classStyle[SepButton] = TBSTYLE_SEP
    classAttr[SepButton] = w32NoConv + w32Clickable
    classKbdInput[SepButton] = DLGC_UNDEFPUSHBUTTON
    --/topic Controls
    --/const ComboBoxEx
    --/desc Combobox with images
    -- The /ComboBoxEx control works almost exactly like a normal /Combo, but
    -- you can include images to be displayed along side the item text.
    -- See /addItem for details.
    className[ComboBoxEx] = WC_COMBOBOXEX
    classType[ComboBoxEx] = COMMON_CONTROL
    classStyle[ComboBoxEx] = w32or_all({WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        CBS_DROPDOWN,
                                        CBS_NOINTEGRALHEIGHT,
                                        WS_TABSTOP})

    classAttr[ComboBoxEx] = w32Clickable + w32OwnerId
    classBGColor[ComboBoxEx] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[ComboBoxEx] =DLGC_WANTARROWS+DLGC_WANTCHARS

------------------------------------------
--/topic Constants
--/const CCflags
--/desc Used by function /classDefaults() to indicate Style Flags

--/topic Constants
--/const CCexflags
--/desc Used by function /classDefaults() to indicate Extended Style Flags

--/topic Constants
--/const CCwinstyle
--/desc Used by function /classDefaults() to set the style flags when
--registering a new window class.

global constant
    CCflags = 1,    -- The code for class Style Flags
    CCexflags = 2,  -- The code for Extended Style Flags
    CCwinstyle = 3  -- Used to set the registered class style for windows

--/topic System Attributes
--/func classDefaults(integer class, sequence pData)
--/desc Used to change the default values for style and extended style flags.
--/ret The current values of these flags prior to changing them.
-- /i class is the type of control whose defaults you want to change. /n
-- /i pData is a sequence that contains zero or more sub-sequences. Each
-- sub-sequence must have two elements, the first is the type of flag being
-- changed, and the other is the new value for the flag. The flag value can
-- be either an atom with all the flags /b"or'd", or a sequence of individual
-- flags. /n
-- The types of flags that can be changed are: /n
--/li CCflags - Standard control flags
--/li CCexflags - Extended control flags
--/li CCwinstyle - Only applies to Window - the class style flags.
--
-- Note, if /i pData is an empty sequence, the current flags are returned.
-- example:
--/code
--   sequence oldFlags
--   -- Make LText initially hidden and have a border when displayed.
--   oldFlags = classDefaults(LText, {
--                   {CCflags, {WS_CHILD, ES_LEFT}},
--                   {CCexflags, WS_EX_CLIENTEDGE}
--                      })
--   -- Change the default class flags for windows.
--   oldFlags = classDefaults(Window, {
--                   {CCwinstyle, {CS_HREDRAW,CS_DBLCLKS}}
--                      })
--/endcode

global function classDefaults(integer class, sequence pData)
sequence lCurDefaults

        -- Make sure only real class ids are supplied.
        if class < 1
        or class > length(w32ControlTypes) then
            return {} -- Bad ID supplied.
        end if

        -- Collect the current values before changing them.
        lCurDefaults = {{CCflags, w32get_bits(classStyle[class])},
                        {CCexflags, w32get_bits(classStyleEx[class])},
                        {CCwinstyle, vWindowClassStyle}
                       }

        -- Change the defaults.
        for i=1 to length(pData) do
            -- Only looking for sequences
            if sequence(pData[i]) then
                -- of two elements
                if length(pData[i]) = 2 then
                    -- Is this the Style Flags?
                    if pData[i][1] = CCflags then
                        if atom(pData[i][2]) then
                            classStyle[class] = pData[i][2]
                        else
                            classStyle[class] = w32or_all(pData[i][2])
                        end if
                    -- Is this the Extended Style Flags?
                    elsif pData[i][1] = CCexflags then
                        if atom(pData[i][2]) then
                            classStyleEx[class] = pData[i][2]
                        else
                            classStyleEx[class] = w32or_all(pData[i][2])
                        end if
                    -- Is this the Class Style flags
                    elsif pData[i][1] = CCwinstyle then
                        if atom(pData[i][2]) then
                            vWindowClassStyle = w32get_bits(pData[i][2])
                        else
                            vWindowClassStyle = pData[i][2]
                        end if
                    end if
                end if
            end if
        end for

        -- Return with what the defaults used to be.
        return lCurDefaults
end function

-----------------------------------------------------------------------------
--/topic Controls
--/const Screen
--/desc Identifes the screen.
-- The /Screen refers to the computer screen. It is automatically created,
-- and it most graphic methods that work in /Windows will also work with
-- the screen.
--
-- Example:
--/code
--          -- Draw an 'x' across the screen
--          sequence size
--
--          -- get the screen width & height
--          size = /getCtlSize(/Screen)
--
--          -- set the pen color to red
--          /setPenColor(/Screen, Red)
--
--          -- draw the lines
--          /drawLine(/Screen, 0, 0, size[1], size[2])
--          /drawLine(/Screen, size[1], 0, size[2], 0)
--/endcode

-----------------------------------------------------------------------------
--/topic Controls
--/const Printer
--/desc Handle to the printer.
-- The /Printer refers to the selected printer. Before it can be used,
-- you must first select a printer using /getPrinter. After you are done
-- printing, you should release the /Printer with /releasePrinter.
--
-- Each document should be begin and end with a /startDoc and /endDoc
-- pair. Likewise, each page should begin and end with a /startPage and
-- /endPage pair.
--
-- For the sake of space, the example doesn't use the values returned
-- by /getPrinter.
--
-- Example:
--
--/code
--    -- example of using printer
--    sequence result
--
--    -- select the printer
--    result = /getPrinter()
--
--    -- did the user select a printer?
--    if length(result) then
--
--        -- start a new document
--        if not /startDoc(sprintf("My Job, Copy %s",{i})) then
--            exit
--        end if
--
--        -- start a new page
--        if not /startPage() then
--            exit
--        end if
--
--        -- print on the page
--        /wPuts(/Printer,"Hello, Printer!")
--
--        -- close the page
--        if not /endPage() then
--            exit
--        end if
--
--        -- close the document
--        if not /endDoc() then
--            exit
--        end if
--
--        -- release the printer
--        /releasePrinter()
--
--    end if
--
--/endcode


-----------------------------------------------------------------------------
atom WndProcAddress,    -- 32 bit address of Window callback
     SubProcAddress     -- 32 bit address of Control callback
-----------------------------------------------------------------------------
-- vectors

integer mainWindow
sequence vRecent vRecent = {0, 0, 0, {-1}}
global constant
    w32RecentMenu = 1,
    w32RecentWindow = 2,
    w32RecentTabControl = 3,
    w32RecentForms = 4,
    w32GetMainWindow = "GetMainWindow"

integer
    modalWindow,
    modalStyle,
    modalDepth
atom
    modalhWnd

sequence
    modalStack

    mainWindow  = 0     -- no main window set yet
    modalStack  = {}    -- modals under modal window
    modalWindow = 0     -- no modal windows
    modalhWnd   = 0     -- no modal window handles
    modalStyle  = 0     -- Modal Style
    modalDepth  = 0     -- Depth of the Dialog stack

-- controls
integer focus_current focus_current = -1
integer vPrevCtlBlkLength
sequence 
    ctlblk_freelist,        -- A list of the free control blocks.
    ctrl_Handle,            -- hwnd of controls
    ctrl_Handle_type,       -- Type of handle
    ctrl_Destroyed,         -- true if destroyed
    ctrl_Function,          -- Long pointer to function
    ctrl_Family,            -- control class
    ctrl_Type,              -- win32lib type
    ctrl_Focus_order,       -- focus order of controls
    ctrl_Current_focus,     -- current focus
    ctrl_Previous_focus,    -- the previous current focus. For subclassed LV, the handle to large icon image list.
    ctrl_Parent,            -- owner
    ctrl_Menu,              -- for windows: the menu bar handle. For controls with an image list, that IL handle for small/default.
    ctrl_Popup,             -- records attached popmenus
    ctrl_Notify_List,       -- a list of ids that want to be notified of events
    ctrl_Toolbar,           -- toolbars/rebars in window
    ctrl_Statusbar,         -- statusbar in window
    ctrl_Hint_Text,         -- tooltip text or flattoolbar button's caption
    ctrl_Hint_Width,        -- tooltip width in pixels
    ctrl_Font,              -- font resource
    ctrl_Fg_Color,          -- foreground color
    ctrl_Bg_Color,          -- background color
    ctrl_Pen,               -- pen: {id, color, style}
    ctrl_X_Pos,             -- x position
    ctrl_Y_Pos,             -- y position
    ctrl_Erase,             -- True if user self-erases background.
    ctrl_Scroll,            -- scroll: {small,large}    or {{vSmall,vLarge},{hSmall,hLarge}} for Windows
    ctrl_Range,             -- scroll range {low,high} or {{vLow,vHigh},{hLow,hHigh}} for Windows.
    ctrl_Specific,          -- tabs in tab control, autoselect property for edit controls and 
                            --  previous rectangle to restore from for Windows. 
                            --  LVinsert flag override for ListViews. 
                            --  Also initial style flag for Windows created in forms.
    ctrl_Group,             -- items grouped with window, but not owned
    ctrl_Cursor,            -- cursor associated with window
    ctrl_Hotkey_Keys,       -- hotkeys associated with the window
    ctrl_Hotkey_Ids,        -- ids associated with hotkeys
    ctrl_Text_Alignment,    -- alignment of text
    ctrl_Closed,            -- true if window has been closed.
    ctrl_TabKey_Used,       -- true if control uses raw tab keys,
                            --   false if CTRL-tabkey must be used.
    ctrl_Handlers,          -- Routine IDs for event handlers.
    ctrl_Bg_Brush,          -- Brush for background.
    ctrl_UserData,          -- User defined data for control
    ctrl_IntData,           -- User defined data for control
    ctrl_Name,              -- User-defined name for this control
    ctrl_Init_Posns,        -- Contains the initial children control positions
    ctrl_ClassAddr,         -- RAM Address of Window class name string
    ctrl_Mousetrap,         -- List of target mousetraps in a window.
    -- added CChris <oedoc@free.fr> Oct 26, 2006
    ctrl_Visible,           -- user-defined visibility
    ctrl_SetVisible,        -- visibility as set by some set the control belongs to
    ctrl_HandlerStates,     -- same structure as ctrl_handlers, contains 1s for enables and 0s for disabled
    ctrl_ActualClass,       -- class that hides behind the known one in ctrl_Type
    ctrl_CanFocus,          -- 1 if control is allowed to get focus
    ctrl_KbdInput,          -- value or routine_id to return on a WM_GETDLGCODE
    ctrl_FormerId,          -- former id for subclassed controls that have one, or -1 (have not) or 0.
    ctrl_Hatch,             -- hatch brush for background filling
    ctrl_RecursivePaint,    -- 1 to allow recursion during paint, else(default) 0.
    ctrl_ProtectHandlers    -- flags requesting to protect handlers

    -- initialize
    vPrevCtlBlkLength   = 3
    ctlblk_freelist     = {0}
    ctrl_Handle         = {}
    ctrl_Handle_type    = {}
    ctrl_Destroyed      = {}
    ctrl_Function       = {}
    ctrl_Family         = {}
    ctrl_Type           = {}
    ctrl_Focus_order    = {}
    ctrl_Current_focus  = {}
    ctrl_Previous_focus = {}
    ctrl_Parent         = {}
    ctrl_Menu           = {}
    ctrl_Popup          = {}
    ctrl_Notify_List    = {}
    ctrl_Toolbar        = {}
    ctrl_Statusbar      = {}
    ctrl_Hint_Text      = {}
    ctrl_Hint_Width     = {}
    ctrl_Font           = {}
    ctrl_Fg_Color       = {}
    ctrl_Bg_Color       = {}
    ctrl_Pen            = {}
    ctrl_X_Pos          = {}
    ctrl_Y_Pos          = {}
    ctrl_Erase          = {}
    ctrl_Scroll         = {}
    ctrl_Range          = {}
    ctrl_Specific       = {}
    ctrl_Group          = {}
    ctrl_Cursor         = {}
    ctrl_Hotkey_Ids     = {}
    ctrl_Hotkey_Keys    = {}
    ctrl_Text_Alignment = {}
    ctrl_Closed         = {}
    ctrl_TabKey_Used    = {}
    ctrl_Handlers       = {}
    ctrl_Bg_Brush       = {}
    ctrl_UserData       = {}
    ctrl_IntData        = {}
    ctrl_Name           = {}
    ctrl_Init_Posns     = {}
    ctrl_ClassAddr      = {}
    ctrl_Mousetrap      = {}
    -- added CChris <oedoc@free.fr> Oct 26, 2006
    ctrl_Visible        = {}
    ctrl_SetVisible     = {}
    ctrl_HandlerStates  = {}
    ctrl_ActualClass    = {}
    ctrl_CanFocus       = {}
    ctrl_KbdInput       = {}
    ctrl_FormerId       = {}
    ctrl_Hatch          = {}
    ctrl_RecursivePaint = {}
    ctrl_ProtectHandlers = {}

-- 'structure' indexes for user defined properties held in tag field.
constant tagPropId = 3, tagPropInit = 2, tagPropData = 1

constant CONTROLINFOS = series:next_number(0)
global constant
        CONTROLINFO_handle      = series:next_number(CONTROLINFOS),
        CONTROLINFO_handle_type = series:next_number(CONTROLINFOS),
        CONTROLINFO_destroyed   = series:next_number(CONTROLINFOS),
        CONTROLINFO_func        = series:next_number(CONTROLINFOS),
        CONTROLINFO_class       = series:next_number(CONTROLINFOS),
        CONTROLINFO_type        = series:next_number(CONTROLINFOS),
        CONTROLINFO_focus_order = series:next_number(CONTROLINFOS),
        CONTROLINFO_focus       = series:next_number(CONTROLINFOS),
        CONTROLINFO_owner       = series:next_number(CONTROLINFOS),
        CONTROLINFO_menu        = series:next_number(CONTROLINFOS),
        CONTROLINFO_toolbar     = series:next_number(CONTROLINFOS),
        CONTROLINFO_statusbar   = series:next_number(CONTROLINFOS),
        CONTROLINFO_tooltip     = series:next_number(CONTROLINFOS),
        CONTROLINFO_font        = series:next_number(CONTROLINFOS),
        CONTROLINFO_fcolor      = series:next_number(CONTROLINFOS),
        CONTROLINFO_bcolor      = series:next_number(CONTROLINFOS),
        CONTROLINFO_pen         = series:next_number(CONTROLINFOS),
        CONTROLINFO_x           = series:next_number(CONTROLINFOS),
        CONTROLINFO_y           = series:next_number(CONTROLINFOS),
        CONTROLINFO_erase       = series:next_number(CONTROLINFOS),
        CONTROLINFO_scroll      = series:next_number(CONTROLINFOS),
        CONTROLINFO_range       = series:next_number(CONTROLINFOS),
        CONTROLINFO_tabitems    = series:next_number(CONTROLINFOS),
        CONTROLINFO_group       = series:next_number(CONTROLINFOS),
        CONTROLINFO_cursor      = series:next_number(CONTROLINFOS),
        CONTROLINFO_hotkey_keys = series:next_number(CONTROLINFOS),
        CONTROLINFO_hotkey_ids  = series:next_number(CONTROLINFOS),
        CONTROLINFO_textalign   = series:next_number(CONTROLINFOS),
        CONTROLINFO_closed      = series:next_number(CONTROLINFOS),
        CONTROLINFO_tabenabled  = series:next_number(CONTROLINFOS),
        CONTROLINFO_eventhandler = series:next_number(CONTROLINFOS),
        CONTROLINFO_bbrush      = series:next_number(CONTROLINFOS),
        CONTROLINFO_classinfo   = series:next_number(CONTROLINFOS),
        CONTROLINFO_tag         = series:next_number(CONTROLINFOS),
        CONTROLINFO_tooltipwid  = series:next_number(CONTROLINFOS),
        CONTROLINFO_lost_focus  = series:next_number(CONTROLINFOS),
        CONTROLINFO_itag        = series:next_number(CONTROLINFOS),
        CONTROLINFO_name        = series:next_number(CONTROLINFOS),
        CONTROLINFO_deferredhandlers = series:next_number(CONTROLINFOS),
        CONTROLINFO_autoheight  = series:next_number(CONTROLINFOS),
        CONTROLINFO_autowidth   = series:next_number(CONTROLINFOS),
        CONTROLINFO_init        = series:next_number(CONTROLINFOS),
        CONTROLINFO_popup       = series:next_number(CONTROLINFOS),
        CONTROLINFO_mousetrap   = series:next_number(CONTROLINFOS),
        CONTROLINFO_notifyid    = series:next_number(CONTROLINFOS),
        CONTROLINFO_handlerstates = series:next_number(CONTROLINFOS),
        CONTROLINFO_formerId = series:next_number(CONTROLINFOS),
        CONTROLINFO_alias = series:next_number(CONTROLINFOS)

    constant
    kht_Window = 1,
    kht_Bitmap = 2,
    kht_Menu   = 3,
    kht_TabItem = 4,
    kht_ImageList = 5


-----------------------------------------------------------------------------
-- Tool tips
global integer
    tooltipControl      -- id of tooltip control
    -- defaults
    tooltipControl  = 0
-----------------------------------------------------------------------------
-- Pen Colors

global constant
    Black           = rgb(#00, #00, #00),
    NavyBlue        = rgb(#00, #00, #60),
    Blue            = rgb(#00, #00, #80),
    BrightBlue      = rgb(#00, #00, #FF),
    ForestGreen     = rgb(#00, #60, #00),
    Green           = rgb(#00, #80, #00),
    Cyan            = rgb(#00, #80, #80),
    SkyBlue         = rgb(#00, #80, #FF),
    BrightGreen     = rgb(#00, #FF, #00),
    BrightCyan      = rgb(#00, #FF, #FF),
    DarkGray        = rgb(#40, #40, #40),
    Eggplant        = rgb(#70, #20, #70),
    Red             = rgb(#80, #00, #00),
    Magenta         = rgb(#80, #00, #80),
    DarkBrown       = rgb(#80, #50, #00),
    Olive           = rgb(#80, #80, #00),
    Gray            = rgb(#80, #80, #80),
    Brown           = rgb(#B0, #70, #00),
    LightGray       = rgb(#C0, #C0, #C0),
    Purple          = rgb(#D0, #80, #D0),
    White           = rgb(#E0, #E0, #E0),
    BrightRed       = rgb(#FF, #00, #00),
    BrightMagenta   = rgb(#FF, #00, #FF),
    Violet          = rgb(#FF, #80, #FF),
    Orange          = rgb(#FF, #B0, #60),
    Pink            = rgb(#FF, #B0, #B0),
    Yellow          = rgb(#FF, #FF, #00),
    Parchment       = rgb(#FF, #FF, #E0),
    BrightWhite     = rgb(#FF, #FF, #FF)

--/topic Attributes
--/const w32ColorValues
--/desc List of all known color values, in the same order as /w32ColorNames.
global sequence w32ColorValues
    w32ColorValues = {Black,
                      NavyBlue,
                      Blue,
                      BrightBlue,
                      ForestGreen,
                      Green,
                      Cyan,
                      SkyBlue,
                      BrightGreen,
                      BrightCyan,
                      DarkGray,
                      Eggplant,
                      Red,
                      Magenta,
                      DarkBrown,
                      Olive,
                      Gray,
                      Brown,
                      LightGray,
                      Purple,
                      White,
                      BrightRed,
                      BrightMagenta,
                      Violet,
                      Orange,
                      Pink,
                      Yellow,
                      Parchment,
                      BrightWhite,
                      0     -- Default value.
                     }

--  Pen Styles
global constant
    Solid        = 0,
    Dash         = 1,                   --  -------
    Dot          = 2,                   --  .......
    DashDot      = 3,                   --  _._._._
    DashDotDot   = 4                    --  _.._.._



--/Topic Constants
--/const Default
--/desc Indicates the use of the Windows default position values when creating /Controls.

global constant
    Default = CW_USEDEFAULT,
    Center = "center"




--/topic System Attributes
--/func getMainWindow()
--/desc Gets the id of the main window for this application.
--/ret INTEGER: ID of main window.
--
--Example
--/code
--      win = getMainWindow()
--/endcode
global function getMainWindow()
        return mainWindow
end function
r_getMainWindow = routine_id("getMainWindow")

--/topic System Attributes
--/func setMainWindow(integer New)
--/desc Used to tell the library which window is the primary one.
--This is only used if you wish to change the default window that
--is set by calling /WinMain().
--
--Example
--/code
--      integer CurWin
--      CurWin = setMainWindow(AltWindow)
--/endcode

global function setMainWindow(integer pNew)
integer lOld
        lOld = mainWindow
        mainWindow = pNew
        return lOld
end function

-- Changed CChris <oedoc@free.fr> Oct 26, 2006
-- If no form was created and w32RecentForm is used as argument, the function now consistently returns 0.

--/topic Utilities
--/func getRecent(integer owner_type)
--/desc Gets the most recently defined control of a specifc kind, and returns the requested id.
--/ret INTEGER: the id of the most recently created control of the specified type, or 0 if none was created so far.
--
-- The supported owner type specifications are:
--/li /b w32RecentMenu: id of the most recently created menu, or 0;
--/li /b w32RecentWindow: id of the most recently created window, or 0;
--/li /b w32RecentTabControl: id of the most recently created TabControl, or 0;
--/li /b w32RecentForms: id of the most recently created form window, or {-1}.
global function getRecent(integer pType)
        if find(pType, {w32RecentMenu, w32RecentWindow, w32RecentTabControl, w32RecentForms}) then
            return vRecent[pType]
        end if
        return 0
end function

global procedure setRecent(integer pType,integer x)
        if find(pType, {w32RecentMenu, w32RecentWindow, w32RecentTabControl}) then
            vRecent[pType] = x
        elsif pType = w32RecentForms then
            vRecent[pType] &= x
        end if
end procedure

global procedure clearRecents()
        vRecent[w32RecentMenu] = 0
        vRecent[w32RecentWindow] = 0
        vRecent[w32RecentTabControl] = 0
end procedure

--/topic System Attributes
--/func validId(object id)
--/desc Tests to see if the specified id is a valid one.
--/ret w32True if valid, w32False otherwise.

-----------------------------------------------------------------------------
global function validId(object id)
-- returns true for valid Ids
        if sequence(id) then
            if not integer(id[2]) or id[2]<1 or id[2]>length(tvitem_data) then
                return w32False
            elsif ctrl_Type[id[1]]!=TreeView or tvitem_owner[id[2]]!=id[1] then
                return w32False
            else
                return w32True
            end if
        elsif not integer(id) then
            return w32False
        end if
        if id<=0 then
            return w32False
        end if
        if id>length(ctrl_Handle) then
            return w32False
        end if
        if ctrl_Destroyed[id]<0 then
            return w32False
        end if
        if ctrl_Handle[id]=0 then
            return w32False
        end if
        if ctrl_Parent[id]=0 then
            return w32True
        end if
        return validId(ctrl_Parent[id])
end function
r_validId = routine_id("validId")

-----------------------------------------------------------------------------
procedure setId(atom hWnd, integer id)
        VOID = w32Func(xSetWindowLong,{hWnd, GWL_USERDATA, id})
end procedure

--/topic Utilities
--/func getHandles()
--/desc Gets all the hWnd handles for every control created in your application.
--/ret A sequence of atoms.
--/code
--        addBtn = create(PushButton, "", 100,100, 40,40,0)
--        allHandles = getHandles()
--        otherfunc(allHandles[addBtn], ... )
--/endcode
global function getHandles()
        return ctrl_Handle
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getId(object hWnd)
--/desc Finds the control/window ID given a Window Handle.
--/ret INTEGER: The Id corresponding to the /i hWnd supplied.
-- If the supplied hWnd is invalid or not belonging to a control
-- created by win32lib, this function will return zero.
--
-- /b"Note 1" this can be used to find a TreeView Item's Id from it's handle by
-- using the syntax:  id = getId({TV, hTVI})
--
--/b"Note 2" if /i hWnd is the special value /b w32GetMainWindow, it will return the
-- Id of the main window as used in the /WinMain() routine. This is useful if you
-- are writing an add-on library to this one.
--


constant qGetWindowLong = define_c_func(open_dll("user32.dll"), "GetWindowLongA", {C_POINTER, C_LONG}, C_LONG)

-- Added CChris <oedoc@free.fr> Oct 26, 2006
-- These record ids and handles of menus, so that the pairing is always guaranteed
sequence menu_ids menu_ids = {}
sequence menu_handles menu_handles = {}

global function getId(object hWnd)
atom lId

        if sequence(hWnd) and length(hWnd) = 2 then
            return find(hWnd[2], tvitem_handle)
        elsif not equal(hWnd, w32GetMainWindow) then
        --lId = w32Func(xGetWindowLong,{hWnd, GWL_USERDATA})

            -- Changed CChris <oedoc@free.fr> Oct 26, 2006
            -- Now returns a valid id if hWnd refers to a menu
            lId = find(hWnd,menu_handles)
            if lId then
                return menu_ids[lId]
            end if
            lId = c_func(qGetWindowLong,{hWnd, GWL_USERDATA})
            if not integer(lId) then
                lId = 0
            end if
            return lId
        else
            return mainWindow
        end if
end function

--/topic System Attributes
--/func getHWND(integer controlID)
--/desc Returns the Windows Handle of the specified control
--/ret The control's hWnd
-- This function is almost the same as /getHandle except that it does /b not
-- validate the /i controlID value supplied to it, and it cannot be used
-- to get the handle of a Treeview item. /n
-- You would use this function if you already knew that the /i controlID was
-- valid and you needed a faster routine than /getHandle.
--
--Example
--/code
--      atom hWnd
--      hWnd = getHWND(myWindow)
--/endcode

global function getHWND(object id)
        return ctrl_Handle[id]
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getHandle(integer controlID OR sequence {TVid, TVItemID})
--/desc Returns the Windows Handle of the specified control
--/ret The control's hWnd
-- This aborts the application if the specified id is invalid.
--
-- This can also return the handle of a treeview item by using the
-- syntax {tv, tvitem}
--
--Example
--/code
--      atom hWnd, hTV
--      hWnd = getHandle(myWindow)
--      hTV = getHandle({myTreeView, Itemx})
--/endcode

global function getHandle(object id)
atom hWnd
        -- return the handle for the window
        -- generates warning if not a valid id or handle
        -- in range?

        -- Special case. A zero id returns a zero handle.
        if equal(id, 0) then
            return 0
        end if

        if sequence(id)
        and length(id) = 2
        and validId(id[1])
        and ctrl_Type[id[1]] = TreeView
        and id[2] > 0
        and id[2] <= length(tvitem_handle)
        and tvitem_owner[id[2]] = id[1] then
            return tvitem_handle[id[2]]
        end if

        if validId(id) then
            -- Get the stored value of the handle.
            if ctrl_Type[id] = TabItem then
                -- Use the tab control's handle.
                hWnd = ctrl_Handle[ctrl_Parent[id]]
            else
                hWnd = ctrl_Handle[id]
            end if

            -- if its a control handle, then getID must work too.
            if ctrl_Handle_type[id]!=kht_Window then
                if hWnd=-1 then
                    hWnd = 0
                end if
            elsif getId(hWnd)=id then
                if hWnd = -1 then
                    hWnd = 0
                end if
            else
                warnErr(append(Err_GETHCHANGED,{id,getId(hWnd)}))
            end if
            return hWnd

        else
            if compare(id,0) > 0 and compare(id,length(ctrl_Handle)) <= 0 then
                if ctrl_Destroyed[id] < 0 then
                    warnErr(Err_GETHOBJECTDESTROYED)
                end if

                if ctrl_Handle[id] = 0 then
                    warnErr(Err_GETHNULLHANDLE)
                end if
            end if

            warnErr(Err_GETHFAIL)
        end if

        return 0 -- Bad handle
end function
r_getHandle = routine_id("getHandle")


--/topic System Attributes
--/func getIdName(integer controlID)
--/desc Returns the name of a control, given it's id.
--/ret SEQUENCE: The control's name /b or INTEGER: No name available.
--/b "Also see:" /setIDName and /newUIObj
--
--A return of "" means that the /i controlID was not valid. /n
--A return of 0 means that the /i controlID has no name.
--
--Example
--/code
--      sequence name
--      name = getIdName(myWindow)
--/endcode

global function getIdName(integer id)
        if validId(id) then
            return ctrl_Name[id]
        else
            return ""
        end if
end function

--/topic Miscellaneous
--/func makeStandardName(sequence Name)
--/desc Transforms a string into a standardized format suitable for naming things.
--/ret SEQUENCE: A Standard Name format
--/i Name is any string. It is converted to a standard form by removing any characters
--that are not alphanumeric, except that the first character can only be alphabetic or
-- the underscore character.
--
--Example:
--/code
--      sequence lName
--      lName = makeStandardName("Customer Dialog #1")
--      -- This should return "CustomerDialog1"
--/endcode

global function makeStandardName(sequence pName)
integer i

        pName = w32trim(pName)
        -- Remove any chars that cannot be in names.
        i = 1
        while i <= length(pName) do
            if not w32CType(pName[i], NameChar_CT) then
                pName = w32removeIndex(i, pName)
            else
                if i=1 and (w32CType(pName[1], Digit_CT) or w32CType(pName[1], Punct_CT)) then
                    pName = w32removeIndex(1, pName)
                else
                    i += 1
                end if
            end if
        end while

        return pName
end function

--/topic System Attributes
--/proc setIdName(integer controlID, sequence Name)
--/desc Sets the name of a control, given it's id.
--/b "Also see:" /getIDName and /newUIObj /n
-- This routine ensures that only alphanumeric and '_' characters are in the name. All
-- other characters stripped off the /Name parameter.
--
--Example
--/code
--      sequence name
--      setIdName(myWindow, "Prime Window")
--/endcode

global procedure setIdName(integer id, sequence pName)
        ctrl_Name[id] = makeStandardName(pName)
end procedure

--/topic System Attributes
--/func getNameId(sequence Name)
--/desc Returns the id of a control, given it's name.
--/ret SEQUENCE: The control's ID.
--/b "Also see:" /setIdName, /getIdName and /newUIObj
--
--A return of zero indicates that the name was not found. /n
--If more than one control has the same name, the result is
--still returned but it may be any of those controls. In this
--case it might be better to use /getNameIdInContext().
--
--Example
--/code
--      integer id
--      id = getNameId("Prime Window")
--/endcode

global function getNameId(sequence pName)
        return find(makeStandardName(pName), ctrl_Name)
end function

--/topic System Attributes
--/func getNameIdInContext(sequence Name, integer Parent)
--/desc Returns the id of a control, given it's name and parent control.
--/ret SEQUENCE: The control's ID.
--/b "Also see:" /setIdName, /getNameId, /getIdName and /newUIObj
--
--A return of zero indicates that the name was not found.
--
--Example
--/code
--      integer id
--      id = getNameIdInContext("AcceptButton", CustomerWindow)
--/endcode

global function getNameIdInContext(sequence pName, object pParent)
sequence lName
sequence lDependents
integer  lEnd, lStart

        -- Standardize the supplied name.
        lName = makeStandardName(pName)


        -- Build a list of candidate controls
        if sequence(pParent) then
            pParent = getNameId(makeStandardName(pParent))
        end if
        if pParent <= 0 then
            if vRecent[w32RecentWindow] > 0 then
                pParent = vRecent[w32RecentWindow]
            elsif mainWindow > 0 then
                pParent = mainWindow
            else
                pParent = 1
            end if
        end if
        lDependents = {pParent}
        lStart = 1
        lEnd = 0
        while lEnd < length(lDependents) do
            lEnd = length(lDependents)
            for i = lStart to lEnd do
                lDependents &= ctrl_Group[lDependents[i]]
            end for
            lStart = lEnd+1
        end while

        -- Start searching for the name in this context.
        for i=1 to length(lDependents) do
            lStart = lDependents[i]
            if equal(lName, ctrl_Name[lStart]) then
                return lStart
            end if
        end for

        return 0

end function

--/topic Low Level Routines
--/func sendMessage(object id, atom command, object wParam, object lParam)
--/desc Send a Win32 message to the requested control.
--/ret ATOM: Win32 result code.
--
-- /i id is either a control ID, or a control Name. /n
-- /i command is the Windows Message code to send. /n
-- /i wParam and lParam are the appropriate data items for the specific
-- /i command you are sending. These can be either atom values or text strings.
--
--There are hundreds of Windows message codes. Each type of control responds to
-- commands that are specific to it. There are too many to document here but
-- they can be found in many publications - the easiest might be the Microsoft
-- SDK documentation found at /b "http://msdn.microsoft.com"
--
--Example:
--/code
--      res = sendMessage(myToolbar, TB_ADDSTRING, 0, "Test String")
--/endcode

constant qSendMessage = define_c_func(open_dll("user32.dll"),
                                      "SendMessageA", {C_POINTER, C_UINT, C_LONG, C_LONG}, C_LONG)

global function sendMessage(object id, atom pCmd, object wParm, object lParm)
-- send a command to a control
atom memset
atom lRetVal

        if sequence(id) then
            id = getNameId(id)
        end if

        --    if validId(id) then
        --    if id > 0 then
        memset = 0
        -- Check for text being passed.
        if sequence(wParm) then
            memset = w32new_memset()
            wParm = w32acquire_mem(memset, wParm)
        end if
        if sequence(lParm) then
            if memset = 0 then
                memset = w32new_memset()
            end if
            lParm = w32acquire_mem(memset, lParm)
        end if

        lRetVal = c_func(qSendMessage,{ctrl_Handle[id], pCmd, wParm, lParm})
        if memset != 0 then
            w32release_mem(memset)
        end if
        return lRetVal
end function

-----------------------------------------------------------------------------
procedure pushSelf(integer id)
        -- push the current self and return value onto stack
        if SP = length(idStack) then
            idStack &= repeat(0, 10)
            returnStack &= repeat(0, 10)
        end if
        SP += 1
        idStack[SP] = id
        returnStack[SP] = 0
end procedure

-----------------------------------------------------------------------------
function popSelf()
        -- pop the current id from the stack
        -- return the return value

        -- get the return value
        if SP <= 0 then
            abortErr(Err_STACKERR)
        end if

        -- pop the self and return stacks
        SP -= 1
        return returnStack[SP+1]

end function

-----------------------------------------------------------------------------
--/topic Events
--/proc returnValue(value)
--/desc Override default value returned by handler.
-- This allows you to override the value an event handler returns to Win32.
-- By default, when an event is processed, it goes through these steps:
--
-- /li /onEvent: If there is an /onEvent handler for this control, it
--          is passed the event.
-- /li Event Trap: If there is a specific handler for this event, that
--          handler is triggered. For example, /b WM_SETFOCUS triggers
--          /onGotFocus, /b WM_SIZE triggers /onResize, etc.
-- /li Default Windows Handler: Finally, the default Window handler for
--          the control is called. In the case of subclassed /controls,
--          /i CallWindowProc calls the normal handler; for /windows,
--          /i DefWindowProc is called.
--
-- Setting /returnValue causes processing to stop at the step that the
-- value was set in, and return that value to Windows.
--
-- Example:
--
--/code
--          -- prevent Button1 from seeing any space bar keys
--          procedure Button1_KeyDown(integer self, integer event, sequence parms)
--              integer keycode
--              integer shift
--              keycode = parms[1]
--              shift = parms[2]
--              if keycode = VK_SPACE then
--                  -- set return value
--                  /returnValue(w32True)
--              end if
--          end procedure
--          /setHandler(Button1, w32HKeyDown, routine_id("Button1_KeyDown"))
--/endcode

global procedure returnValue(object returns)
        -- change the return value of the current control
        if SP <= 0 then
            abortErr(Err_STACKERR)
        end if

        returnStack[SP] = {returns}
end procedure

--/topic Events
--/proc resetReturnValue()
--/desc Removes any value returned by handler.
--
--Example
--/code
--      resetReturnValue()
--/endcode
global procedure resetReturnValue()
        -- change the return value of the current control
        if SP <= 0 then
            abortErr(Err_STACKERR)
        end if

        returnStack[SP] = 0
end procedure

-----------------------------------------------------------------------------
--/topic Events
--/func getReturnValue()
--/desc Gets the current value of the value that will be returned to Windows.
--/ret OBJECT: A sequence if set by an event handler, otherwise an atom.
--
--Example:
--/code
--      object rv
--      -- Set a return value if not already set.
--      rv = getReturnValue()
--      if not sequence(rv) then
--          returnValue(-1)
--      end if
--/endcode
global function getReturnValue()
        -- gets the current return value of the current control
        if SP < 0 then
            abortErr(Err_STACKERR)
        elsif SP = 0 then
            return 0
        end if

        return returnStack[SP]
end function

-----------------------------------------------------------------------------
--/topic Events
--/func setCallback(integer routineID)
--/desc gets and sets the application's generic callback routine id
--/ret INTEGER: The current value of the application's callback routine id.
--/i routineID is either -1 or a valid routine id. /n
--This sets the application's callback routine id and returns the old
--value. /n
--The application may call the callback routine for a number of reasons
--during the running of a program. It is mainly used to get information
--needed by Win32Lib that it has not received so far.
--
--The callback routine must be a /b procedure that takes three parameters:- /n
-- /b integer /i self /n
-- /b integer /i event /n
-- /b sequence /i data /n
--
--The contents of the parameters passed to the callback routine depend on
-- the value of the /i event parameter. /n
--When /i event /b"= w32HGetHandler" is called when Win32lib needs an event handler
-- to be associated for a specific control's event. This comes about when using
-- the "events=..." parameter in the /newUIObj routine./n
--The /i data contains three values... /n
--[1] A string in the form ~<eventname>_~<controlname>, eg. "Click_OkayBtn" /n
--[2] An integer with the symbolic event code, eg. w32HClick /n
--[3] A string containing the control's name. /n
--And the /i self parameter contains the control-id for the control needing
-- the handler routine.
--
--Example
--/code
--      integer oldrtn
--      oldrtn = setCallback(routine_id("AppCallback"))
--/endcode
global function setCallback(integer pRoutineID)
integer lOldRtn

        lOldRtn = r_AppCallback
        r_AppCallback = pRoutineID

        return lOldRtn
end function

-----------------------------------------------------------------------------
--/topic Events
--/func invokeHandler(integer id, integer event, sequence params)
--/desc Triggers a Win32Lib event.
--/ret OBJECT: The value set by returnValue() if called inside
--the handler, zero otherwise.
--
--Example:
--/code
--      object rv
--      -- Simulate a button press on the Close Button.
--      rv = invokeHandler(btnClose, w32HClick, {})
--      if not sequence(rv) then
--          closeWindow(mainWin)
--      end if
--/endcode

global function invokeHandler(integer id, integer event, sequence params)
sequence lRoutines, lStates
integer lPos
sequence lNotify
integer lRecvr

        if validId(id) = w32False then
            return 0
        end if

        pushSelf(id)
        lRoutines = {}
        lStates = {}

        if event = w32HGetHandler then
            lRoutines = {{r_AppCallback}}
            lStates = {{1}}
        end if

        -- Check for any 'screen' event first.
        if length(ctrl_Handlers[Screen][event]) > 0 then
            lRoutines = append(lRoutines,ctrl_Handlers[Screen][event])
            lStates = append(lStates,ctrl_HandlerStates[Screen][event])
        end if

        -- And now for any control-owned event
        if id != Screen and length(ctrl_Handlers[id][event]) > 0 then
            lRoutines = append(lRoutines,ctrl_Handlers[id][event])
            lStates = append(lStates,ctrl_HandlerStates[id][event])
        end if


        for i=1 to length(lRoutines) do
            if not equal(lRoutines[i],-1) then
                for j=1 to length(lRoutines[i]) do
                    if lStates[i][j] then
                        call_proc(lRoutines[i][j], {id, event, params})
                    end if
                end for
            end if
        end for

        -- Check if any notifications are required.
        if event != w32HNotify then
            -- Avoid recursive notifications!
            lNotify = ctrl_Notify_List[id][1]

            for i=1 to length(lNotify) do
                lRecvr = lNotify[i]
                lPos = find(event, ctrl_Notify_List[id][2][i])
                if lPos and ctrl_Notify_List[id][4][i][lPos] then
                    VOID = invokeHandler(lRecvr, w32HNotify,
                                         {id, event,ctrl_Notify_List[id][3][i][lPos],params})
                end if
            end for
        end if

        return popSelf()
end function

global constant
    w32protectLeading = 1,
    w32protectTrailing = 2

--/topic Events
--/proc setHandler(object id, object htype, object routine)
--/desc Sets up an user written event handler
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event to trap. /n
--/i routine is the routine_id of the user written code that will handle
-- the event.
--
-- /b Note that /i id can be a sequence of ids. You would do this if they all
-- shared the same handler code. /n
-- /b Note that /i htype can be a sequence of event codes. You would do this
-- if the same handler code is to be invoked for different events. /n
-- /b Note that /i routine can be a sequence of routine_id() values. You
-- would do this to set a chain of routines that are triggered for each
-- event listed in /i htype. /n
-- This routine actually adds the handler's routine_id to the end of a list
-- of such routines for this ID and Event combination. This way, you can
-- chain together independantly written routines to fire for the same
-- id and same events.
--
-- A special note. To remove the current chain, set /i routine to -1. To clear
-- the existing chain before setting a new one, you can also pass /i routine
-- as {-1, routine_id("myhandler")}
--
-- To add routine(s) as the /b last executed in the chain, insert the special value -2
-- before the routines. Thus, specifying {25,-2,13,18} as the /i routine argument
-- will cause 13 to be added at the front, then 13 and 18 to be added at the bottom,
-- 18 being bottom-most.
--
-- You can temporarily enable or disable handlers using the /enableHandler() function.
-- The event subsystem only calls enabled handlers.
--
-- /b "How the Event Handler subsystem works" /n
-- The Win32lib library receives various events notifications from Windows.
-- If an event handler has been set up for the specific control-event
-- combination, the library invokes the user written routine before
-- continuing. Each event handler is a procedure that is passed three
-- parameters by the library. /n
-- 1) integer /i ID. The control id that the event applies to. /n
-- 2) integer /i Event. The event code that invoked this routine. This
-- enables a single routine to handler multiple event types. /n
-- 3) sequence /i Params. This is a list of zero or more parameters
-- associated with the specific event. For example, a w32HKeyDown event will
-- have the keycode and shift mask in these parameters.
--
-- If you insert a handler at the top of a handler chain, and if the top of that chain
-- is protected (using /setHandlerProtection), the handler will be inserted right below
-- the top handler. Likewise, if you insert at bottom and the bottom handler is protected,
-- the new handler will be inserted right above the bottom-most one.
--
--Example
--/code
--  -- Set a single routine to be triggered by one type of event.
--  setHandler(myWindow, w32HPaint, routine_id("repaintWindow"))
--
--  -- Set the same handler for two different buttons.
--  setHandler({btn1, btn2}, w32HClick, routine_id("click_buttons"))
--
--  -- Set the same handler for two different events.
--  setHandler(btn1, {w32HClick, w32HKeyPress}, routine_id("click_buttons"))
--
--  -- Set a chain of handlers.
--  setHandler(btn1, w32HClick, routine_id("click_buttons"))
--  if DebugSwitch = w32True then
--      -- add a second routine to be called.
--      setHandler(btn1, w32HClick, routine_id("Debugger"))
--  end if
--/endcode

global procedure setHandler(object id, object htype, object routine)
integer lTemp
integer lControl
integer lEvent
integer lWhere
sequence s

        if atom(id) then
            id = {id}
        end if

        if atom(htype) then
            htype = {htype}
        end if

        if atom(routine) then
            routine = {routine}
        end if
        for i=1 to length(id) do
            lControl = id[i]
            for j=1 to length(htype) do
                lEvent = htype[j]
                if validId(lControl)
                and lEvent > 0
                and lEvent <= w32LastEventType() then

                    -- Special for Combo boxes and dragging.
                    if lEvent = w32HDragAndDrop then
                        lTemp = call_func(r_getEdit,{lControl})
                        if lTemp != 0 then
                            -- Set the same handler for the Combo's editbox.
                            setHandler(lTemp, htype, routine)
                        end if
                    elsif find(lEvent, {w32HBreak, w32HPause, w32HIdle}) then
                        -- These must only apply to the screen control.
                        lControl = Screen
                    end if

                    lWhere = 1
                    for k=1 to length(routine) do
                        if routine[k] = -1 then
                            if k = 1 then
                                -- Clear any existing list of handlers.
                                ctrl_Handlers[lControl][lEvent] = {}
                                ctrl_HandlerStates[lControl][lEvent] = {}
                            end if
                        elsif routine[k] = -2 then
                            lWhere = -1
                        else
                            -- Add this routine (if not already there) into the list.
                            if find(routine[k], ctrl_Handlers[lControl][lEvent]) = 0 then
                                if lWhere = 1 then
                                    if not and_bits(ctrl_ProtectHandlers[lControl][lEvent],w32protectLeading) then
                                        ctrl_Handlers[lControl][lEvent] &= routine[k]
                                        ctrl_HandlerStates[lControl][lEvent] &= 1
                                    else
                                        s = ctrl_Handlers[lControl][lEvent]
                                        s &= s[length(s)]
                                        s[length(s)-1] = routine[k]
                                        ctrl_Handlers[lControl][lEvent] = s
                                        s = ctrl_HandlerStates[lControl][lEvent]
                                        s &= s[length(s)]
                                        s[length(s)-1] = 1
                                        ctrl_HandlerStates[lControl][lEvent] = s
                                    end if
                                else
                                    if not and_bits(ctrl_ProtectHandlers[lControl][lEvent],w32protectTrailing) then
                                        -- Force it to be at the head of the handler list.
                                        ctrl_Handlers[lControl][lEvent] = routine[k] & ctrl_Handlers[lControl][lEvent]
                                        ctrl_HandlerStates[lControl][lEvent] = 1 & ctrl_HandlerStates[lControl][lEvent]
                                    else
                                        s = ctrl_Handlers[lControl][lEvent]
                                        s = prepend(s,s[1])
                                        s[2] = routine[k]
                                        ctrl_Handlers[lControl][lEvent] = s
                                        s = ctrl_HandlerStates[lControl][lEvent]
                                        s = prepend(s,s[1])
                                        s[2] = 1
                                        ctrl_HandlerStates[lControl][lEvent] = s
                                    end if
                                end if
                            end if
                        end if
                    end for
                end if
            end for
        end for

end procedure

--/topic Events
--/proc setProtectedHandler(integer id,integer event,object routine)
--/desc Same as setHandler(), but overrides any protection without changing it.
-- Note that you cannot use sequences of ids, events and routines here. The only
-- exception is to allow the -2 modifier.
global procedure setProtectedHandler(integer id,integer event,object routine)
integer prot

        prot = ctrl_ProtectHandlers[id][event]
        ctrl_ProtectHandlers[id][event] = 0
        setHandler(id,event,routine)
        ctrl_ProtectHandlers[id][event] = prot
end procedure

--/topic Events
--/func setHandlerProtection(integer id,integer event,integer flag)
--/desc Possibly sets the protection status for a pair {id,event}.
--/ret (INTEGER) The former protection flag for the pair.
-- The protection flag is the sum of zero or more of:
--/li /b w32protectLeading: the first handler to be executed is protected
--/li /b w32protectTrailing: the last handler to be executed is protected
-- Additionally, using w32GetValue as flag causes the current flag to be returned.
global function setHandlerProtection(integer id,integer event,integer flag)
integer oldVal

        oldVal = ctrl_ProtectHandlers[id][event]
        if flag != w32GetValue then
            ctrl_ProtectHandlers[id][event] = and_bits(flag,w32protectLeading+w32protectTrailing)
        end if
        return oldVal
end function

--/topic Events
--/func enableHandler(object id, object htype, object routine,integer flag)
--/desc Retrieves and possibly sets the state of a user written event handler.
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event to trap. /n
--/i routine is the routine_id of the user written code that handles
-- the event.
--/i flag tells the routine what to do.
--
-- /b Note that /i id can be a sequence of ids. You would do this if they all
-- shared the same handler code. /n
-- /b Note that /i htype can be a sequence of event codes. You would do this
-- if the same handler code is to be invoked for different events. /n
-- /b Note that /i routine can be a sequence of routine_id() values. You
-- would do this to set the state of a chain of routines that are triggered for each
-- event listed in /i htype. /n
--
-- If flag is greater than zero, the handler will be enabled if found; if it is zero,
-- it will be disabled if found. In any case, its previous state will be returned:
-- 1 = enabled, 0 = disabled, -1 = not found.
-- If id or htype or routines is a sequence, a sequence will be returned;
-- otherwise, only an integer is returned.
--
--/endcode

global function enableHandler(object id, object htype, object routine,integer flag)
integer lTemp
integer lControl
integer lEvent
integer lWhere
sequence result
integer lIndex

        if atom(id) then
            id = {id}
        end if

        if atom(htype) then
            htype = {htype}
        end if

        if atom(routine) then
            routine = {routine}
        end if

        flag=compare(flag,0)
        lIndex = 1
        result=repeat(-1,length(id)*length(htype)*length(routine))

        for i=1 to length(id) do
            lControl = id[i]
            for j=1 to length(htype) do
                lEvent = htype[j]
                if validId(lControl)
                and lEvent > 0
                and lEvent <= w32LastEventType() then

                    -- Special for Combo boxes and dragging.
                    if lEvent = w32HDragAndDrop then
                        lTemp = call_func(r_getEdit,{lControl})
                        if lTemp != 0 then
                            -- Set the same handler for the Combo's editbox.
                            VOID = enableHandler(lTemp, htype, routine,flag)
                        end if
                    elsif find(lEvent, {w32HBreak, w32HPause, w32HIdle}) then
                        -- These must only apply to the screen control.
                        lControl = Screen
                    end if

                    for k=1 to length(routine) do
                        -- Locate this routine in the list.
                        lWhere = find(routine[k], ctrl_Handlers[lControl][lEvent])
                        if lWhere then
                            result[lIndex] = ctrl_HandlerStates[lControl][lEvent][lWhere]
                            if flag>=0 then
                                ctrl_HandlerStates[lControl][lEvent][lWhere] = flag
                            end if
                        end if
                        lIndex += 1
                    end for
                end if
            end for
        end for
        if length(result)=1 then
            return result[1]
        else
            return result
        end if
end function

--/topic Events
--/func getHandler(integer id, integer htype)
--/desc Gets the event handler(s) defined for a control.
--/ret SEQUENCE: A list of handlers defined so for this control event.
--
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event being handled. /n
-- The first executed handler is the last one on the returned list;
-- second executed is second last and so on.
--
--Example
--/code
--       object hl
--       -- Make sure my handler is installed before any others.
--       hl = getHandler(myWindow, w32HPaint)
--       -- Chain mine to the front.
--       setHandler(myWindow, w32HPaint, -1 & routine_id("mypainter") & hl)
--/endcode

global function getHandler(integer id, integer htype)
        if validId(id) and htype >= 0 and htype <= w32LastEventType() then
            return ctrl_Handlers[id][htype]
        else
            return {}
        end if
end function

--/topic Events
--/proc removeHandler(object id, object htype, object routine)
--/desc Removes user written event handlers previously set with /setHandler()
--/i id is one or more control IDs. /n
--/i htype is one or more event types. /n
--/i routine is one or more routine_ids previously set for the control-event combinations
-- in the previous parameters.
--
-- You use this routine to get rid of a handler that had been established earlier.
-- To temporarily disable or enable a handler, use /enableHandler().
--
--Example:
--/code
--      -- This causes the CommonHandler routine to no longer process the w32HClick event for the controls Btn1 and Btn2.
--      removeHandler({Btn1, Btn2}, w32HClick, routine_id("CommonHandler"))
--/endcode
global procedure removeHandler(object id, object pEvent, object pRoutine)
integer lControl, lEvent, lIndex
sequence lHandlers, lRoutines
sequence lStates, lHStates

        if atom(id) then
            id = {id}
        end if
        if atom(pEvent) then
            pEvent = {pEvent}
        end if
        if atom(pRoutine) then
            pRoutine = {pRoutine}
        end if
        for i=1 to length(id) do
            lControl = id[i]
            if validId(lControl) then
                lHandlers = ctrl_Handlers[id[i]]
                lHStates = ctrl_HandlerStates[id[i]]
                for j= 1 to length(pEvent) do
                    lEvent = pEvent[j]
                    if lEvent > 0 and lEvent <= w32LastEventType() then
                        lRoutines = lHandlers[lEvent]
                        lStates = lHStates[lEvent]
                        for k= 1 to length(pRoutine) do
                            lIndex = find(pRoutine[k], lRoutines)
                            if lIndex > 0 then
                                lRoutines = w32removeItem(lIndex,lRoutines)
                                lStates = w32removeItem(lIndex,lStates)
                            end if
                        end for
                        lHandlers[lEvent] = lRoutines
                        lHStates[lEvent] =lStates
                    end if
                end for
                ctrl_Handlers[id[i]] = lHandlers
                ctrl_HandlerStates[id[i]] = lHStates
            end if
        end for
end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/func colorValue(object Color)
--/desc Converts the parameter into the equivalent 24-bit color value.
--/ret ATOM: 24-bit color value.
--The /i Color parameter can take one of the following forms ... /n
--/li A atom expression that results in an integer from 0 to #FFFFFF
--/li One of the predefined Win32Lib color names, eg. Cyan, BrightMagenta, ...
--/li One of the system symbolic color names, eg. COLOR_BUTTONFACE
--/li One of the predefined Win32Lib color names as a negative string, eg. -"cyan", -"red", ...
--/li One of the predefined Win32Lib color names as a string, except for "red" eg. "cyan", "blue", ...
--/li A 3-element sequence in the form {red,green,blue} where each element is
-- an integer in the range 0 to 255.
--
--Example:
--/code
--      atom theColor
--      theColor = colorValue(-"Parchment")
--      theColor = colorValue({45,82,191})
--      theColor = colorValue(Magenta)
--      theColor = colorValue(COLOR_ACTIVEBORDER)
--      theColor = colorValue(#C0C0C0)
--/endcode
global function colorValue(object pColor)
atom lColor
integer lPos

        lColor = 0  -- Default is Black
        if sequence(pColor) then
            if length(pColor) = 3 and pColor[1] >= 0 then
                -- Note that this can be ambiguous if the string for "red" is used,
                -- as that is a 3-element sequence.
                return rgb(pColor[1], pColor[2], pColor[3])
            end if

            lPos = find(upper(pColor), w32ColorNames)
            if lPos = 0 then
    --/**/      lPos = find(sq_uminus(upper(pColor)), w32ColorNames)    --/* Pve
                lPos = find(-upper(pColor), w32ColorNames)              --  RDS */
            end if
            if lPos != 0 then
                lColor = w32ColorValues[lPos]
            end if
        else
            lColor = UseColor(pColor)
        end if

        return lColor
end function
r_colorValue  = routine_id("colorValue")


--/topic Utilities
--/func getStyleFlags(id)
--/desc Retrieves the standard and extra style flags for a control.
--/ret SEQUENCE: {ATOM: standard, ATOM: extra}
--Example
--/code
--      sequence lFlags
--      lFlags = getStyleFlags(myButton)
--/endcode
global function getStyleFlags(integer id)
atom hWnd

        hWnd = getHWND(id)
        return {w32Func(xGetWindowLong,{hWnd, GWL_STYLE}),
                w32Func(xGetWindowLong,{hWnd, GWL_EXSTYLE})
               }
end function

-----------------------------------------------------------------------------
--/topic Utilities
--/proc removeStyle(id, style)
--/desc Remove a style from a control.
--If /i style is an atom then only the normal Windows style is modified,
-- but if style is a sequence, it must be a tw-atom sequence. The first is
-- the normal styles, and the second is the extended styles.
--
--Example
--/code
--        removeStyle(w1, {
--                          -- normal styles
--                          (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
--                          -- extended styles
--                          (WS_EX_CLIENTEDGE)
--                        })
--/endcode
global procedure removeStyle(integer id, object styles)
atom curStyle, styleMask, hWnd, style

        if equal(styles, w32AUTOCLOSE) then
            VOID = enableHandler(id,w32HClick,r_autoclose,w32False)
            return
        end if

        hWnd = getHandle(id)
        if sequence(styles) then
            style = styles[1]
        else
            style = styles
        end if

        if style != 0 then
            curStyle = w32Func(xGetWindowLong,{hWnd, GWL_STYLE})
            styleMask = xor_bits(#FFFFFFFF, style)
            style = and_bits(styleMask,curStyle)
            if style != curStyle then
                VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, style})
            end if
        end if

        if sequence(styles) and styles[2] != 0 then
            style = styles[2]
            curStyle = w32Func(xGetWindowLong,{hWnd, GWL_EXSTYLE})
            styleMask = xor_bits(#FFFFFFFF, style)
            style = and_bits(styleMask,curStyle)
            if style != curStyle then
                VOID = w32Func(xSetWindowLong,{hWnd, GWL_EXSTYLE, style})
            end if
        end if

        VOID = w32Func(xSetForegroundWindow, {hWnd})
        VOID = w32Func(xSetWindowPos, {hWnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})

end procedure

--/topic Utilities
--/proc addStyle(id, style)
--/desc Add a style to a control.
--If /i style is an atom then only the normal Windows style is modified,
-- but if style is a sequence, it must be a two-atom sequence. The first is
-- the normal styles, and the second is the extended styles.
--
--A special use of this is to set a control to close its parent window. To
-- do this call the routine using the style /i w32AUTOCLOSE.
--
--Example
--/code
--        addStyle(w1, {
--                      -- normal styles
--                      (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
--                      -- extended styles
--                      (WS_EX_CLIENTEDGE)
--                     })
--      -- Set the control to close the window
--      addStyle(BtnClose, w32AUTOCLOSE)
--/endcode

global procedure addStyle(integer id, object styles)
atom curStyle, hWnd, style

        if equal(styles, w32AUTOCLOSE) then
            setHandler(id, w32HClick, r_autoclose)
            return
        end if

        hWnd = getHandle(id)

        if sequence(styles) then
            style = styles[1]
        else
            style = styles
        end if

        if style != 0 then
            curStyle = w32Func(xGetWindowLong, {hWnd, GWL_STYLE})
            style = or_bits(style,curStyle)
            if style != curStyle then
                VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, style})
            end if
        end if

        if sequence(styles) and styles[2] != 0 then
            style = styles[2]
            curStyle = w32Func(xGetWindowLong,{hWnd, GWL_EXSTYLE})
            style = or_bits(style,curStyle)
            if style != curStyle then
                if and_bits(style, WS_EX_TOPMOST) then
                    call_proc(r_moveZOrder,{id, HWND_TOPMOST})
                end if
                VOID = w32Func(xSetWindowLong,{hWnd, GWL_EXSTYLE, style})
            end if
        end if

        VOID = w32Func(xSetForegroundWindow, {hWnd})
        VOID = w32Func(xSetWindowPos, {hWnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})
end procedure
r_addStyle = routine_id("addStyle")

--/topic System Attributes
--/func ClientToScreen(integer id, integer x, integer y)
--/desc Converts a point in a control to screen-based coordinates.
--/ret SEQUENCE: {screenX, screenY}
--
--Example
--/code
--      sequence sPosn
--      -- Find the screen position of the window's top left corner.
--      sPosn = ClientToScreen(myWindow, 0, 0)
--      printf(o, "Window is at %d, %d", {sPosn[1], sPosn[2]})
--/endcode

-- Create a buffer of 16 point structs to allow for 16 levels of nested interrrupts (not likely to happen)
atom cts_preallocated
    cts_preallocated = w32acquire_mem(-2, SIZEOF_POINT * 16)

global function ClientToScreen(integer id, integer x, integer y)
atom pt
sequence lPoints

        pt = cts_preallocated
        cts_preallocated += SIZEOF_POINT

        poke4(pt, {x,y})
        -- convert to screen space
        VOID = w32Func(xClientToScreen,{getHandle(id), pt})

        -- get position
        lPoints = peek4s({pt,2})
        cts_preallocated = pt

        return lPoints
end function

--/topic System Attributes
--/func ScreenToClient(integer id, integer x, integer y)
--/desc Converts a point on a screen to control-based coordinates.
--/ret SEQUENCE: {ControlX, ControlY}
--
--Example
--/code
--      sequence cPosn, mXY
--      -- Find where the mouse is relative to the window.
--      mYX = getPointerPos()
--      cPosn = ScreenToClient(myWindow, mXY[1], mXY[2])
--      printf(o, "Mouse is at %d, %d", {cPosn[1], cPosn[2]})
--/endcode

global function ScreenToClient(integer id, integer x, integer y)
integer viewX, viewY
atom pt
        pt = w32acquire_mem(0,SIZEOF_POINT)

        -- set to client (0, 0)
        w32store(pt, ptX, x)
        w32store(pt, ptY, y)

        -- convert to screen space
        if not w32Func(xScreenToClient,{getHandle(id),pt}) then
            abortErr(Err_SCREENTOCLIENT)
        end if

        -- get position
        viewX = w32fetch(pt, ptX)
        viewY = w32fetch(pt, ptY)

        w32release_mem(pt)

        return {viewX, viewY}
end function


--/topic System Attributes
--/func clientToClient(integer id1, integer id2, sequence xy)
--/desc Converts a point in /i id1 to a relative point in /i id2
--/ret SEQUENCE: {X, Y}
--/i xy is a sequence in the format {X, Y} which specifies a point in
-- the control /i id1. This value is transformed so that it is relative to
-- the control /i id2.
--
--Example
--/code
--      sequence mXY
--      -- Find where the point 2,-4 relative to the editbox is
--      -- relative to the label.
--      mXY = clientToClient(MyEditBox, MyLabelText, {2, -4})
--
--/endcode

global function clientToClient(integer id1, integer id2, sequence xy)
atom pt
sequence lPoints

        -- Allocate a point structure
        pt = cts_preallocated
        cts_preallocated += SIZEOF_POINT

        poke4(pt, xy[1..2])
        -- convert to screen space relative to id1
        VOID = w32Func(xClientToScreen,{getHandle(id1),pt})
        -- convert from screen space relative to id2
        VOID = w32Func(xScreenToClient,{getHandle(id2),pt})

        -- get position
        lPoints = peek4s({pt,2})
        cts_preallocated = pt

        return lPoints
end function


--/topic Constants
--/const w32Edge
--/desc Specifies the extreme edge required when creating or moving a control.
--example
--/code
--          -- Create a edit area
--          myEdit = /create(MleText, "", myWin,
--                      0.50,           -- left edge is 50% of window's width
--                      20,             -- top edge is 20 pixels down
--                      w32Edge,        -- right edge is window's right edge
--                      {w32Edge, -25}, -- bottom edge is window's bottom
--                                      --  edge less 25 pixels.
--                      0)
--/endcode

--/topic Constants
--/const w32AltEdge
--/desc Specifies the alternate edge required when creating or moving a control.
-- This only makes sense when used in specifing the X,Y positions. The constant
-- is a reference to the 'far' edge. This is the Righthand side for the X
-- co-ordinate, and the Bottom edge for the Y co-ordinate. It is usually used
-- in conjection with negative offsets.
--example
--/code
--          -- Create a edit area aligned with the righhand edge.
--          fldWidth = 100
--          myEdit = /create(MleText, "", myWin,
--                      -- left edge is 'fldWidth' pixels from the RHS side of the window.
--                      {w32AltEdge, -fldWidth}
--                      20,            -- top edge is 20 pixels down
--                      fldWidth,      -- width of the field
--                      200,           -- height of 200 pixels
--                      0)
--/endcode

global constant w32Edge = {-1},
w32AltEdge = {-2},
w32SameSize = {-3}

--------------------------------------
function convDimension(object pRaw, atom pLowEdge, atom pExtremeEdge, atom pParentSize, atom pControlEdge)
--------------------------------------
atom lNewDimension
atom lPctSize
atom lOffset
sequence lMinMax
atom lEdge
object lRaw_1
object lRaw_2

        if equal(pRaw, CW_USEDEFAULT) then
            return pRaw
        end if

        -- Initialise
        lMinMax = {}
        lPctSize = 0
        lOffset = 0
        lEdge = 0

        -- Check for a sequence first.
        if sequence(pRaw) then
            -- Check for simple edge request
            if equal(pRaw, w32Edge) then
                lPctSize = 0
                lOffset = pExtremeEdge
                lEdge = 1
            -- Check for complex request
            elsif length(pRaw) >= 2 then
                -- Copy to locals for performance reasons.
                lRaw_1 = pRaw[1]
                lRaw_2 = pRaw[2]

                -- Either the first or second could be the edge request.
                if equal(lRaw_1, w32Edge) then
                    lOffset = pExtremeEdge
                    lPctSize = lRaw_2
                    lEdge = 1
                elsif equal(lRaw_2, w32Edge) then
                    lOffset = pExtremeEdge
                    lPctSize = lRaw_1
                    lEdge = 1
                elsif equal(lRaw_1, w32AltEdge) then
                    lOffset = pParentSize
                    lPctSize = lRaw_2
                elsif equal(lRaw_2, w32AltEdge) then
                    lOffset = pParentSize
                    lPctSize = lRaw_1
                    -- Either the first or second could be a % request
                elsif integer(lRaw_2) then
                    lPctSize = lRaw_1
                    lOffset = lRaw_2
                elsif atom(lRaw_2) and (lRaw_2 >= 1 or lRaw_2 < 0) then
                    lPctSize = lRaw_1
                    lOffset = floor(lRaw_2)
                else
                    lPctSize = lRaw_2
                    lOffset = lRaw_1
                end if
                -- Check to see if a limit has been requested.
                if length(pRaw) = 3
                and sequence(pRaw[3])
                and length(pRaw[3]) = 2 then
                    lMinMax = pRaw[3]
                end if
            end if
        else
            -- A simple % or pixel specified.
            lPctSize = pRaw
            lOffset = 0
        end if

        -- Calc the percentage of the parent size.
        if lPctSize > 0 and lPctSize < 1 then
            lPctSize *= pParentSize
        end if

        -- Add LowEdge to cater for client borders etc...
        lNewDimension = floor(lPctSize)+lOffset+pLowEdge

        -- Make adjustment if 'extreme' edge was asked for.
        if lEdge = 1 then
            lNewDimension += pControlEdge
        end if

        -- Check that the result is within the limits.
        if length(lMinMax) = 2 then
            if lNewDimension < lMinMax[1] then
                lNewDimension = lMinMax[1]
            end if
            if lNewDimension > lMinMax[2] then
                lNewDimension = lMinMax[2]
            end if
        end if


        return floor(lNewDimension)
end function

--------------------------------------
--/topic System Attributes
--/func convPctToPixel(integer id, object x, object y, object width, object height)
--/desc Converts relative coordinates to pixel coordinates.
--/ret SEQUENCE: 4-element list {Left, Top, Width, Height}
--This is used internally by /create() and a number of other routines
--to convert things like %values to pixels.
--
-- Each dimension can be expressed as either... /n
-- a) an integer >= 0, in which case it is not touched. /n
--     eg.  50 (= 50 pixels) /n
-- b) an atom in the range > 0 and ~< 1, which is taken to be a % /n
--    of the control's parent dimension. /n
--     eg.  0.50 (= 50% of parent's size) /n
-- c) The constant /i w32Edge which signifies the parent's extreme  /n
--    client edge for the dimension. That is, either the rightmost or /n
--    bottom most edge, as appropriate. /n
-- d) a sequence of two elements, the first as in (b) or (c) above, and /n
--    the other a pixel offset. The offset is added after converting. /n
--     eg.  {0.50, -3} (= 50% of parent size less 3 pixels) /n
--     eq   (w32Edge, -10} (= right/bottom pixel less 10 pixels) /n
-- e) a sequence of three elements, the first two as in (d), and /n
--    the other a two-element sequence containing the minimum and /n
--    maximum allowable values. These can be a percentage or a /n
--    pixel amount.  /n
--     eg.  {0.50, -3, {20, 300}} (= 50% of parent size less /n
--            3 pixels, and a minimum of 20 pixels and a /n
--            maximum of 300 pixels) /n
--Example:
--/code
--       sequence BBox
--       BBox = convPctToPixels(myEditBox, 0.30, {w32Edge,-40}, {0.1,4}, 35)
--
--/endcode
global function convPctToPixel(integer id, object x, object y, object width, object height)
-- Converts a controls coordinates from percentages to pixels.
sequence BBox
sequence PBox
integer lParent


        -- Not a valid ID, or this type of control cannot
        -- be converted, just return what was supplied.
        if validId(id) = w32False
        or and_bits(classAttr[ctrl_Type[id]], w32NoConv)!=0 then
            return {x, y, width, height}
        end if

        --Get the control's parent.
        lParent = ctrl_Parent[id]
        if lParent = 0 then
            lParent = Screen
        end if

        -- Get the parent's current dimensions.
        PBox = call_func(r_getClientRect, {lParent})

        -- Convert Right/Bottom pixel to width and height
        PBox[3] = PBox[3]-PBox[1]-1
        PBox[4] = PBox[4]-PBox[2]-1

        if integer(x) and integer(y) and integer(width) and integer(height) then
            return {x+PBox[1], y+PBox[2], width, height}
        end if

        BBox = {0, 0, 0, 0}

        if equal(x, Center) then
            if equal(y, Default) then
                y = 0
            end if
            BBox[1] = floor(PBox[3]/2)
        else
            BBox[1] = convDimension(x, PBox[1], PBox[1], PBox[3], 0)
        end if

        if equal(y, Center) then
            if equal(x, Default) then
                BBox[1] = 0
            end if
            BBox[2] = floor(PBox[4]/2)
        else
            BBox[2] = convDimension(y, PBox[2], PBox[2], PBox[4], 0)
        end if

        BBox[3] = convDimension(width, 0, PBox[3], PBox[3], PBox[1]-BBox[1])

        BBox[4] = convDimension(height, 0, PBox[4], PBox[4], PBox[2]-BBox[2])

        if equal(x, Center) then
            BBox[1] = BBox[1]-floor(BBox[3]/2)
        end if

        if equal(y, Center) then
            BBox[2] = BBox[2]-floor(BBox[4]/2)
        end if

        return BBox
end function


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setReadOnly(integer id, integer YesNo)
--/desc Sets the read-only state of an edit control.
-- /i YesNo is w32True to set it to read-only, and w32False to allow keystrokes.
--
--Example:
--/code
--      -- the following prevents keyboard input to myEdit (paste still works)
--      setReadOnly(myEdit, w32True)
--/endcode
global procedure setReadOnly(integer id, integer YesNo)
        VOID = sendMessage(id,EM_SETREADONLY,YesNo,0)
end procedure


--/topic Attributes
--/func getWindowInfo(integer id, object pFields)
--/desc Get various information about a window.
--/ret SEQUENCE: A list of the requested field values.
--/i id is the id of a window that you want information from. /n
--/i pFields is a list of fields whose value can be requested. /n
--/define
--/term WINDOWINFO_WLeft
--      The Window border's left pixel position
--/term WINDOWINFO_WTop
--      The Window border's top pixel position
--/term WINDOWINFO_WRight
--      The Window border's right pixel position
--/term WINDOWINFO_WBottom
--      The Window border's bottom pixel position
--/term WINDOWINFO_CLeft
--      The Window client area's left pixel position
--/term WINDOWINFO_CTop
--      The Window client area's top pixel position
--/term WINDOWINFO_CRight
--      The Window client area's right pixel position
--/term WINDOWINFO_CBottom
--      The Window client area's bottom pixel position
--/term WINDOWINFO_Style
--      The Window style flags
--/term WINDOWINFO_ExStyle
--      The Window extended style flags
--/term WINDOWINFO_WindowStatus
--      The Window's activation status. Zero = not-active.
--/term WINDOWINFO_xWindowBorders
--      The width, in pixels, of the window border.
--/term WINDOWINFO_yWindowBorders
--      The height, in pixels, of the window border.
--/term WINDOWINFO_WindowType
--      The window class atom. Used in Win32 CreateWindow() calls.
--/term WINDOWINFO_CreatorVersion
--      The version of Windows 32 that created this window.
--/enddefine
--
--Example:
--/code
--       sequence lValues
--       lValues = getWindowInfo(myWin,
--                      {WINDOWINFO_WLeft,
--                       WINDOWINFO_WTop,
--                       WINDOWINFO_WindowStatus
--                      })
--       printf(o, "Window is at %d, %d and is %s",
--             {lValues[1], lValues[2],
--              w32iff(lValues[3], "active", "inactive")})
--/endcode

global function getWindowInfo(integer id, sequence pFields)
sequence lResult
atom     lWindowInfo
        lResult = {}

        lWindowInfo = w32to_memory(0,ID_WINDOWINFO,0)
        if w32Func(xGetWindowInfo,{getHandle(id), lWindowInfo}) then
            for i=1 to length(pFields) do
                lResult = append(lResult, w32fetch(lWindowInfo, pFields[i]))
            end for
        end if

        w32release_mem(lWindowInfo)

        return lResult
end function

integer ctrl_Deferred_Handlers,r_getAutoSize
--/topic Attributes
--/func getControlInfo(integer id, object pFields)
--/desc Get various internal information about a control.
--/ret SEQUENCE: A list of the requested field values.
--/i id is the id of a control that you want information from. /n
--/i pFields is a list of fields whose value can be requested. /n
--/define
--/term     CONTROLINFO_handle
--  Windows hWnd value of control
--/term     CONTROLINFO_handle_type
--  Type of handle /n
--    Window = 1  /n
--    Bitmap = 2  /n
--    Menu   = 3  /n
--    TabItem = 4  /n
--    ImageList = 5   /n
--/term     CONTROLINFO_destroyed
--  true if destroyed
--/term     CONTROLINFO_func
--  Long pointer to function
--/term     CONTROLINFO_class
--  control class
--/term     CONTROLINFO_classinfo
--  control class info used during create /n
-- The returns a sequence that contains... /n
--<ul>
--/li Name  : The name of the registered Window Class
--/li Type  : The family of controls. Possible values are:
-- WINDOW, BUTTON, COMBO, EDIT, LISTBOX, SCROLLBAR,
-- STATIC, MENU, POPUP, MENUITEM, PIXMAP, COMMON_CONTROL
--/li Style : The default Style Flags used by /createEx()
--/li StyleEx: The default Extended Style Flags used by /createEx()
--/li Attributes: The win32lib attributes of this control. Possible values are: /n
--  /b w32Clickable: Can allow mouseup detection to fire Click handler /n
--  /b w32NoConv: Must not allow relative dimension conversions /n
--  /b w32PictCtrl: Controls that pass bitmaps in the flags /n
--  /b w32CtrlTab: CTRL-tabkey must be used to move tabstops /n
--/li Background Color : The default background color
--/li Foreground Color : The default foreground color
--/li Pointer : The default mouse pointer shape.
--</ul>
--/term     CONTROLINFO_type
--  win32lib type
--/term     CONTROLINFO_focus_order
--  focus order of controls
--/term     CONTROLINFO_focus
--  current focus
--/term     CONTROLINFO_owner
--  owner
--/term     CONTROLINFO_menu
--  menu in window
--/term     CONTROLINFO_popup
--  attached popup menu for the control
--/term     CONTROLINFO_notifyid
--  a list of ids that wish to be notified of events that happen to this control.
--/term     CONTROLINFO_toolbar
--  toolbars in window
--/term     CONTROLINFO_statusbar
--  statusbar in window
--/term     CONTROLINFO_tooltip
--  tooltip text or flattoolbar button's caption
--/term     CONTROLINFO_font
--  font resource
--/term     CONTROLINFO_fcolor
--  foreground color
--/term     CONTROLINFO_bcolor
--  background color
--/term     CONTROLINFO_pen
--  pen: {id, color, style}
--/term     CONTROLINFO_x
--  x position of the pen
--/term     CONTROLINFO_y
--  y position of the pen
--/term     CONTROLINFO_erase
--  True if application is responsible for erasing the window background.
--/term     CONTROLINFO_scroll
--  scroll: {small change, large change}
--/term     CONTROLINFO_range
--  scroll range {low, high}
--/term     CONTROLINFO_tabitems
--  tabs in tab control
--/term     CONTROLINFO_group
--  items owned by this window, regardless whether they are in the tab order or not.
--/term     CONTROLINFO_cursor
--  cursor associated with window
--/term     CONTROLINFO_hotkey_keys
--  hotkeys associated with the window
--/term     CONTROLINFO_hotkey_ids
--  ids associated with hotkeys
--/term     CONTROLINFO_textalign
--  alignment of text
--/term     CONTROLINFO_closed
--  true if window has been closed.
--/term     CONTROLINFO_tabenabled
--  true if control uses raw tab keys, false if CTRL-tabkey must be used.
--/term     CONTROLINFO_eventhandler
--  Routine IDs for event handlers.
--/term     CONTROLINFO_bbrush
--  The current Brush used to paint a control's background.
--/term     CONTROLINFO_cursor
--  The stack of cursor's used to set the current cursor shape
--/term     CONTROLINFO_tag
--  The current set of user defined properties for the control.
--/term     CONTROLINFO_name
--  The current user defined name for the control.
--/term     CONTROLINFO_deferredhandlers
--  The current set of unresolved event handlers for the control.
--/term     CONTROLINFO_autoheight
--  Is this an automatic height resizing control
--/term     CONTROLINFO_autowidth
--  Is this an automatic width resizing control
--/term     CONTROLINFO_init
--  Contains the initial Rect data for children controls if there is a toolbar in the window
--/term     CONTROLINFO_mousetrap
--  Contains a list of the defined mousetraps for a control.
--/term     CONTROLINFO_tooltipwid
--  Contains the maximum width of the tooltip display window for a control.
--/term     CONTROLINFO_lost_focus
--  Contains the previous owned control that had the focus.
--/term     CONTROLINFO_itag
--  Contains the list of unnamed user defined properties for a control (they were defined using an index).
--/term     CONTROLINFO_handlerstates
--  Contains the list of the handler states (0 = disabled) for a control.
--/term     CONTROLINFO_formerId
--  Returns 0 for non subclassed controls, -1 for subclassed controls that had no id, else the former id.
--/enddefine
--
-- Note that you can index the entries in the returned sequence for CONTROLINFO_font using the following index values:
--/li w32FontName
--/li w32FontSize
--/li w32FontAttrib
--/li w32FontColor
--Example:
--/code
--       sequence lValues
--       lValues = getControlInfo(myWin,
--                      {CONTROLINFO_handle,
--                       CONTROLINFO_owner,
--                       CONTROLINFO_type
--                      })
--/endcode

global function getControlInfo(integer id, object pFields)
object lResult
sequence lFields

        lResult = {}
        if atom(pFields) then
            lFields = {pFields}
        else
            lFields = pFields
        end if
        if id > 0 and id <= length(ctrl_Handle) then
            for i=1 to length(lFields) do
                if lFields[i] = CONTROLINFO_handle then
                    lResult = append(lResult, ctrl_Handle[id])
                elsif lFields[i] = CONTROLINFO_handle_type then
                    lResult = append(lResult, ctrl_Handle_type[id])
                elsif lFields[i] = CONTROLINFO_destroyed then
                    lResult = append(lResult, ctrl_Destroyed[id])
                elsif lFields[i] = CONTROLINFO_func then
                    lResult = append(lResult, ctrl_Function[id])
                elsif lFields[i] = CONTROLINFO_class then
                    lResult = append(lResult, ctrl_Family[id])
                elsif lFields[i] = CONTROLINFO_type then
                    lResult = append(lResult, ctrl_Type[id])
                elsif lFields[i] = CONTROLINFO_focus_order then
                    lResult = append(lResult, ctrl_Focus_order[id])
                elsif lFields[i] = CONTROLINFO_focus then
                    lResult = append(lResult, ctrl_Current_focus[id])
                elsif lFields[i] = CONTROLINFO_lost_focus then
                    lResult = append(lResult, ctrl_Previous_focus[id])
                elsif lFields[i] = CONTROLINFO_owner then
                    lResult = append(lResult, ctrl_Parent[id])
                elsif lFields[i] = CONTROLINFO_menu then
                    lResult = append(lResult, ctrl_Menu[id])
                elsif lFields[i] = CONTROLINFO_popup then
                    lResult = append(lResult, ctrl_Popup[id])
                elsif lFields[i] = CONTROLINFO_notifyid then
                    lResult = append(lResult, ctrl_Notify_List[id])
                elsif lFields[i] = CONTROLINFO_toolbar then
                    lResult = append(lResult, ctrl_Toolbar[id])
                elsif lFields[i] = CONTROLINFO_range then
                    lResult = append(lResult, ctrl_Range[id])
                elsif lFields[i] = CONTROLINFO_tooltip then
                    lResult = append(lResult, ctrl_Hint_Text[id])
                elsif lFields[i] = CONTROLINFO_tooltipwid then
                    lResult = append(lResult, ctrl_Hint_Width[id])
                elsif lFields[i] = CONTROLINFO_font then
                    lResult = append(lResult, ctrl_Font[id])
                elsif lFields[i] = CONTROLINFO_fcolor then
                    lResult = append(lResult, ctrl_Fg_Color[id])
                elsif lFields[i] = CONTROLINFO_bcolor then
                    lResult = append(lResult, ctrl_Bg_Color[id])
                elsif lFields[i] = CONTROLINFO_pen then
                    lResult = append(lResult, ctrl_Pen[id])
                elsif lFields[i] = CONTROLINFO_x then
                    lResult = append(lResult, ctrl_X_Pos[id])
                elsif lFields[i] = CONTROLINFO_y then
                    lResult = append(lResult, ctrl_Y_Pos[id])
                elsif lFields[i] = CONTROLINFO_erase then
                    lResult = append(lResult, ctrl_Erase[id])
                elsif lFields[i] = CONTROLINFO_scroll then
                    lResult = append(lResult, ctrl_Scroll[id])
                elsif lFields[i] = CONTROLINFO_range then
                    lResult = append(lResult, ctrl_Range[id])
                elsif lFields[i] = CONTROLINFO_tabitems then
                    lResult = append(lResult, ctrl_Specific[id])
                elsif lFields[i] = CONTROLINFO_group then
                    lResult = append(lResult, ctrl_Group[id])
                elsif lFields[i] = CONTROLINFO_cursor then
                    lResult = append(lResult, ctrl_Cursor[id])
                elsif lFields[i] = CONTROLINFO_hotkey_keys then
                    lResult = append(lResult, ctrl_Hotkey_Keys[id])
                elsif lFields[i] = CONTROLINFO_hotkey_ids then
                    lResult = append(lResult, ctrl_Hotkey_Ids[id])
                elsif lFields[i] = CONTROLINFO_textalign then
                    lResult = append(lResult, ctrl_Text_Alignment[id])
                elsif lFields[i] = CONTROLINFO_closed then
                    lResult = append(lResult, ctrl_Closed[id])
                elsif lFields[i] = CONTROLINFO_tabenabled then
                    lResult = append(lResult, ctrl_TabKey_Used[id])
                elsif lFields[i] = CONTROLINFO_eventhandler then
                    lResult = append(lResult, ctrl_Handlers[id])
                elsif lFields[i] = CONTROLINFO_bbrush then
                    lResult = append(lResult, ctrl_Bg_Brush[id])
                elsif lFields[i] = CONTROLINFO_tag then
                    lResult = append(lResult, ctrl_UserData[id])
                elsif lFields[i] = CONTROLINFO_itag then
                    lResult = append(lResult, ctrl_IntData[id])
                elsif lFields[i] = CONTROLINFO_name then
                    lResult = append(lResult, ctrl_Name[id])
                elsif lFields[i] = CONTROLINFO_deferredhandlers then
                    lResult = append(lResult, call_func(ctrl_Deferred_Handlers,{id}))
                elsif lFields[i] = CONTROLINFO_autoheight then
                    lResult = append(lResult, call_func(r_getAutoSize,{id,1}))
                elsif lFields[i] = CONTROLINFO_autowidth then
                    lResult = append(lResult, call_func(r_getAutoSize,{id,2}))
                elsif lFields[i] = CONTROLINFO_init then
                    lResult = append(lResult, ctrl_Init_Posns[id])
                elsif lFields[i] = CONTROLINFO_mousetrap then
                    lResult = append(lResult, ctrl_Mousetrap[id])
                elsif lFields[i] = CONTROLINFO_handlerstates then
                    lResult = append(lResult, ctrl_HandlerStates[id])
                elsif lFields[i] = CONTROLINFO_formerId then
                    lResult = append(lResult, ctrl_FormerId[id])
                elsif lFields[i] = CONTROLINFO_classinfo then
                    lResult = append(lResult,{
                                              className[ctrl_Type[id]],
                                              classType[ctrl_Type[id]],
                                              classStyle[ctrl_Type[id]],
                                              classStyleEx[ctrl_Type[id]],
                                              classAttr[ctrl_Type[id]],
                                              classBGColor[ctrl_Type[id]],
                                              classFGColor[ctrl_Type[id]],
                                              classDefPointer[ctrl_Type[id]]
                                             })
                end if
            end for
        end if

        if atom(pFields) then
            lResult = lResult[1]
        end if
        return lResult
end function

global procedure resetFont(integer id)
        -- empty name indicates default font
        ctrl_Font[id][w32FontName]   = ""
end procedure

global procedure setCursorInternal(integer id,sequence data)
        ctrl_Cursor[id] = data
end procedure

--include w32resources.ew
--------------------NOTICE-------------------------------*
-- Software ID: w32resources.ew
-- Version:     0.60
-- Copyright:   (c) 2000 David Cuny and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*

-- w32resources.ew contains most of the code dealing with GDI objects. Some parts
-- have been kept in win32lib.ew, most importantly font handling.
without trace
without type_check
--without warning
--include series.e as series

--object VOID

constant
   Err_GETDCFAIL = {"getDC:GetDC failed.", 494},
--   Err_SAVEDCFAIL = {"getDC:SaveDC failed.", 493},
   Err_RELEASEDCRESTORE = {"releaseDC:RestoreDC failed.", 492},
   Err_ECFSAVEDCFAIL = {"ezCreateFont:SaveDC failed.", 491},
--   Err_ECFSETVIEWPORT = {"ezCreateFont:SetViewportOrgEx failed.", 490},
--   Err_ECFSETWINDOW = {"ezCreateFont:SetWindowOrgEx failed.", 489},
--   Err_ECFDPTOLP = {"ezCreateFont:DPtoLP failed.", 488},
--   Err_ECFGETTEXTMETRICS = {"ezCreateFont:GetTextMetrics failed.", 487},
   Err_ECFRESTOREDC = {"ezCreateFont:RestoreDC failed.", 486},
   Err_RELEASEPRINTER = {"releasePrinter:DeleteDC failed.",458},
--   Err_GETDCBITMAP = {"getDC(bitmap):CreateCompatibleDC failed.",457},
--   Err_GETDCSELECTBITMAP = {"getDC:SelectObject(bitmap) failed.",456},
--   Err_GETDCPIXMAP = {"getDC(pixmap):CreateCompatibleDC failed.",455},
--   Err_GETDCSELECTPIXMAP = {"getDC:SelectObject(pixmap) failed.",454},
--   Err_EMPTYDCSTACK = {"ReleaseDC without matching GetDC.",453},
   Err_RELEASESCREEN = {"releaseDC:ReleaseDC (screen) failed.",452},
   Err_RELEASEBITMAP = {"releaseDC:DeleteDC (bitmap) failed.",451},
   Err_RELEASEPIXMAP = {"releaseDC:DeleteDC (Pixmap) failed.",450},
   Err_RELEASEDC = {"releaseDC:ReleaseDC failed.",449},
   Err_WRONGOWNER = {"LOGIC ERROR: Held resource owner is not the actual owner.", 425}

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- RESOURCE TRACKING
--
-- This is used to track GDI resources held by the application.
-- This module is defined early on so that on an abortErr, the
-- code can still run the cleanup.

--/topic Resources
--/const ForPaint
--/desc Indicates that the resource lives until the end of the onPaint operation.

--/topic Resources
--/const ForProgram
--/desc Indicates that the resource lives until the end of the program.

global constant
    ForPaint   = -1,    -- resource lives until end of onPaint
    ForProgram = -2     -- resource lives until end of program

global constant
    ResSTRUCT   = series:next_number(0),
    ResHandle   = series:next_number(ResSTRUCT),    -- Win32 handle (primary key)
    ResOwner    = series:next_number(ResSTRUCT),    -- the resource WinLib id
    ResLife     = series:next_number(ResSTRUCT),    -- how long the resource lives
    ResObjType  = series:next_number(ResSTRUCT),    -- Type of resource being tracked.
    ResCnt      = series:next_number(ResSTRUCT),    -- Number of times tracked.
    ResTag      = series:next_number(ResSTRUCT),    -- Optional user supplied data
    ResStatus   = series:next_number(ResSTRUCT),    -- Optional user supplied data
    NewRes      = repeat(0, series:current_number(ResSTRUCT)),

    enumObject = series:next_number(0),
    kPenObject = series:next_number(enumObject),
    kBrushObject = series:next_number(enumObject),
    kFontObject = series:next_number(enumObject),
    kBitmapObject = series:next_number(enumObject),
    kIconObject = series:next_number(enumObject),
    kObjectTypes = {kPenObject,kBrushObject, kFontObject,
                    kBitmapObject, kIconObject},
    kNewDC = 0 & repeat({}, series:current_number(enumObject)),

    kUnknownObject = 0,
    kTrackedID = 1,
    kTrackedCurDC = 2,
    kTrackedDCCnt = 1,
    kTrackedDCHdl = 2,
    kTrackedDCSaved = 3,
    kTrackedDCReason = 4,
    kDCReasonApp = 1,
    kDCReasonPaint = 0


sequence
    heldResource,   -- list of held resources, and their scope
    heldCursor,     -- list of held cursors
    vHRFree         -- list of free spots in heldResource
integer vHRI

sequence grabbedHDC
    grabbedHDC = {}

-- This variable is used to help debugging of resources. It is not
-- 'used' in the library itself.


    -- initialize
    heldResource    = {}
    heldCursor      = {}
    vHRFree = {}
    vHRI = 0

integer vFontWeight     vFontWeight = FW_BOLD
sequence vFontKeys      vFontKeys = {}
-- default font
global atom DefaultFontID  DefaultFontID = -1


--/topic Fonts
--/func setFontWeight(integer pNewWeight)
--/desc Possibly sets what you mean by 'bold' when using /setFont(..., /i Bold)
--/ret The font weight setting before you changed it.
-- You can use the following names for the standard font weights... /n
--/li /w32GetValue Just return the current bold weight value
--/li FW_DONTCARE  Sets to the Windows default.
--/li FW_THIN
--/li FW_EXTRALIGHT /i aka FW_ULTRALIGHT
--/li FW_LIGHT
--/li FW_NORMAL /i aka FW_REGULAR
--/li FW_MEDIUM
--/li FW_SEMIBOLD /i aka FW_DEMIBOLD
--/li FW_BOLD /i"The default for Win32lib"
--/li FW_EXTRABOLD /i aka FW_ULTRABOLD
--/li FW_HEAVY /i aka FW_BLACK
--
-- Note, if you call this function with /i pNewWeight set to -1, the current
-- weight value is returned without changing it.
--
-- For video devices, there is not much difference in the rendering, but on other devices
-- it might make a difference.
--
-- Example:
--/code
--    integer lOldWeight
--    lOldWeight = setFontWeight(FW_LIGHT)
--    /setFont(aControl, "Courier New", 12, Bold)
--
--/endcode
------------------------------------------------------------------------------
global function setFontWeight(integer pNewWeight)
integer lOldWeight

    lOldWeight = vFontWeight

    if pNewWeight>=0 then
        pNewWeight = 100 * floor((pNewWeight + 99)/100)
        if pNewWeight>FW_HEAVY then
            pNewWeight = FW_HEAVY
        end if
        vFontWeight = pNewWeight
    end if

    return lOldWeight
end function

global constant
    -- null brush
    NullBrushID     = w32Func(xGetStockObject, {NULL_BRUSH}),
    -- default pen
    DefaultPenID    = w32Func(xGetStockObject, {BLACK_PEN}),
    -- pen attributes
    PenColor        = 1,
    PenStyle        = 2,
    PenROP2         = 3,
    PenBkMode       = 4,
    PenWidth        = 5,
    PenBkColor      = 6,
    PenBrushColor   = 7,
    PenDefaults     = {Black, Solid, R2_COPYPEN, TRANSPARENT,
                       1, w32Color_BTNFACE, {}}
sequence vStockResources
vStockResources = {DefaultFontID, DefaultPenID, NullBrushID}
for i = 0 to STOCK_LAST  do
    vStockResources &= i
end for

-----------------------------------------------------------------------------
function isStockResource(atom a)
    -- returns true if a is a stock object
    -- any resource created with GetStockObject should be added here

    return find(a, vStockResources)
end function


sequence vDCs vDCs = {}
--integer vMaxPenCache vMaxPenCache = 20    -- PL 29/4/09

--/topic Resources
--/info
-- This set of routines helps you to manage Windows resources.
--
-- A number of different types of resources are used in Windows programmming. The
-- main ones are GDI objects, such as Fonts, and Brushes.
--
-- Whenever a resource is created by the library, it is tracked so that it can be released back to
-- Windows when finished with. Typically, a resource is created when you call a drawing routine or
-- change a font, and a resource is deleted when the drawing routine is fininshed or replaced with
-- another resource of the same type.


--/topic Resources
--/proc deleteObject(object resource)
--/desc Deletes a Windows GDI resource.
-- /i resource is the Handle of the object to be deleted.
global procedure deleteObject(object resource)
    atom lObject
    -- deletes an object if not a stock resource
    -- removes it from the tracking list
    integer at
    integer lDelete
--  atom lRC    -- PL 29/4/09

    if atom(resource) then
        lObject = resource
        lDelete = w32True
    else
        lObject = resource[1]
        lDelete = resource[2]
    end if

    -- Stock resources are not tracked.
    if isStockResource(lObject) then
        return
    end if

    -- Was a real delete requested?
    if lDelete=w32True then
        VOID = w32Func(xDeleteObject, {lObject})
    end if

    -- is this a known resource?
    at = w32findKey(lObject, heldResource)
    if at!=0 then
        -- remove from my list of held resources --
        heldResource[at][ResHandle] = 0  -- Invalidate entry
        heldResource[at][ResStatus] = 0  -- Invalidate entry
        vHRI += 1 -- Point to next freelist entry
        vHRFree[vHRI] = at -- Update free list
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Resources
--/func findTrackedObject(integer pOwner, sequence pTag)
--/desc Looks amongst the tracked objects for one that matches the criteria.
--/ret A sequence containing a list of resources matching the criteria.
-- /i pOwner is the /b ID of the control that owns the resource being tracked. /n
-- /i pTag is the 'tag' data stored with the resource when it was first tracked.
-- If this is an empty sequence, all resources for this /i pOwner will be returned.
global function findTrackedObject(object pOwner, sequence pTag)
    sequence lResult
    sequence lResource

    lResult = {}
    for i = 1 to length(heldResource) do
        lResource = heldResource[i]
        if lResource[ResStatus]=1 and equal(lResource[ResOwner],pOwner) then
            if length(pTag)>0 then
                if equal(pTag,lResource[ResTag]) then
                    lResult &= lResource[ResHandle]
                end if
            else
                lResult &= lResource[ResHandle]
            end if
        end if
    end for

    return lResult
end function

--/topic Resources
--/func getTrackedObject(object Resource)
--/desc Gets the data saved against this /i Resource
--/ret A sequence containing the tracking data
-- /i Resource is the resource, eg. Bitmap, Pen, Brush, that was tracked. /n
-- If this is an empty sequence, it means that the resource was not being tracked.
global function getTrackedObject(object pResource)
    sequence lResult

    lResult = {}
    for i = 1 to length(heldResource) do
        if heldResource[i][ResStatus]=1 and equal(heldResource[i][ResHandle],pResource) then
            return heldResource[i]
        end if
    end for
    return {}
end function

-----------------------------------------------------------------------------
--/topic Resources
--/proc trackObject(object owner, object resource, integer lifetime)
--/desc Tracks an object as a held resource.
-- /i owner is the /b ID of the control that owns the resource being tracked. It
-- can be a simple control id or  a 2-element sequence {id, object-type}. There
-- are some predefined object types: /n
--<ul>
--/li IMAGE_BITMAP
--/li IMAGE_ICON
--</ul>
-- /i resource is the resource being tracked. This is usually a memory address of a structure you have created.
-- /i lifetime is how long this resource needs to be kept for. The possible code values are /n
-- /li /ForPaint if this a resource held during a Paint operation. /n
-- /li /ForProgram if this is to be held for the duration of the application. Win32lib
-- won't delete this resource. If you need to, you have to explicitly delete it.
--
-- Note that /i resource can be a two-element sequence. The first element is the
-- actual resource being tracked, and the second is anything you wish to tag
-- along with the resource. You can then use /findTrackedObject() to retrieve
-- the resource being tracked.
--
-- You don't need to track objects created by loadIconFromFile(), loadBitmapFromFile(), 
-- createPixmap() and setFont(), because the library does so for the purpose of reducing
-- memory leaks. All objects that get replaced at any point are tracked too.
--
--Example:
--/code
--      trackObject (myEdit, hBGBrush, ForProgram)
--/endcode

global procedure trackObject(object owner, object pObject, integer lifetime)
    atom lObject
    integer at

    -- tracks object as held resource
--  sequence res    -- PL 29/4/09
    object lTag
    integer lObjType
    -- Get the 'extra' parameters...
    if atom(pObject) then
        lObject = pObject
        lTag = -1
    else
        lObject = pObject[1]
        lTag = pObject[2]
    end if
    if isStockResource(lObject) then
        -- Don't bother tracking stock resources.
        return
    end if

    if atom(owner) then
        lObjType = kUnknownObject
    else
        lObjType = owner[2]
        owner = owner[1]
    end if


    -- don't add to list if it's already there.
    at = w32findKey(lObject,heldResource)
    if at=0 then
        -- add the resource to the resource list

        if vHRI<1 then
            heldResource &= repeat(NewRes, 16)
            vHRFree &= repeat(0, 16)
            for i = 1 to 16 do
                vHRFree[i] = length(heldResource) - i + 1
            end for
            vHRI = 16
        end if
        at = vHRFree[vHRI]
        vHRI -= 1
        -- create a resource and assign its attributes
        heldResource[at][ResHandle] = lObject
        heldResource[at][ResOwner]  = owner
        heldResource[at][ResLife]   = lifetime
        heldResource[at][ResTag]    = lTag
        heldResource[at][ResObjType] = lObjType
        heldResource[at][ResCnt] = 1
        heldResource[at][ResStatus] = 1 -- Valid entry

    else
        if heldResource[at][ResOwner]=owner then
            heldResource[at][ResCnt] += 1

        elsif heldResource[at][ResOwner]=-1 then
            -- This resource now has an owner
            heldResource[at][ResOwner] = owner

        else
            -- ?? Should this ever happen?
            warnErr(Err_WRONGOWNER)
        end if
    end if

end procedure

sequence vFontHandles   vFontHandles = {}

-----------------------------------------------------------------------------
global procedure replaceObject(object pId, integer pObjType, atom pDC, atom pNewObject,
                        integer pLifetime)

    -- adds resource tracking to selectObject
    atom lReplacedObject
    integer lDCI
    integer lObjType
    sequence lDC


    -- Track the DC's current objects
    lDCI = w32findKey(pDC, vDCs)
    if lDCI=0 then
        vDCs = append(vDCs, kNewDC)
        lDCI = length(vDCs)
        vDCs[lDCI][1] = pDC
    end if

    -- select current, replace prior
    lReplacedObject = w32Func(xSelectObject, {pDC, pNewObject})

    lObjType = pObjType + 1

    -- Take a local copy of the DC's tracking data for performance reasons.
    lDC = vDCs[lDCI][lObjType]

    if length(lDC)=0 then
        -- First time this type of object has been replaced in this DC.
        lDC = {lReplacedObject, pNewObject}
        -- track the object
        trackObject({pId, pObjType}, pNewObject, pLifetime)

    elsif lReplacedObject=lDC[2] then
        -- Candidate for deletion (except fonts, bitmaps and icons)
        -- 'cos I've just replaced the one I previously installed.
        if find(pObjType,{kBitmapObject,kIconObject,kFontObject})=0 then
            deleteObject(lReplacedObject)
        else
            deleteObject({lReplacedObject, w32False})
        end if

        if pNewObject=lDC[1] then
            -- Just replaced the original, so remove tracking data.
            deleteObject({pNewObject, w32False})
            lDC = {}
        else
            -- Record the one I just installed.
            lDC[2] = pNewObject
            -- track the object
            trackObject({pId,pObjType}, pNewObject, pLifetime)
        end if

    elsif lReplacedObject=lDC[1] then
        -- I've just replaced the original object
        -- So I must delete the one I just replaced.
        if pObjType!=kFontObject then
            deleteObject(lDC[2])
        end if
        lDC = {}

    else
        -- Not one of mine.
        if lReplacedObject!=0 then
            if find(lReplacedObject,vFontHandles)=0 then
                deleteObject(lReplacedObject)
            end if
        end if

        -- Remember to delete installed resource, unless its a font.
        if (pObjType!=kFontObject) and length(getTrackedObject(lDC[2]))>0 then
            deleteObject(lDC[2])
        end if

        -- If I've just replaced the original, then
        -- clear out the entries.
        if pNewObject = lDC[1] then
            if find(pNewObject, vFontHandles) = 0 then
                deleteObject(pNewObject)
            end if
            lDC = {}
        else
            -- Record the one I just installed.
            lDC[2] = pNewObject
        end if

    end if

    -- Update the shared DC tracking variable.
    vDCs[lDCI][lObjType] = lDC
end procedure

-----------------------------------------------------------------------------
global procedure trackCursor(object hCursor)

    -- tracks cursors as resources
    -- don't add to list if already there
    if not find(hCursor, heldCursor) then
        -- add to list
        heldCursor = append(heldCursor, hCursor)
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Mouse
--/func loadCursor(sequence CursorFile)
--/desc Loads a cursor from a file.
--/ret ATOM: The handle to a loaded cursor
--
-- If this returns zero, then the cursor was not loaded.
--
--/Example:
--/code
--      mC = loadCursor("hands.ani")
--      setMousePointer(myList, mC)
--/endcode
global function loadCursor(sequence pCursorFile)
    atom hCursor

    hCursor = w32Func(xLoadCursorFromFile, {pCursorFile})
    trackCursor(hCursor)

    return hCursor
end function

-----------------------------------------------------------------------------
global procedure releaseResourcesForID(object pIdLife)
    atom id
    integer lSpecificLifetime

    -- Free resources associated with a particular resource
    sequence lHeld
    sequence lResList

    if atom(pIdLife) then
        id = pIdLife
        lSpecificLifetime = 0    -- Force release to happen.
    else
        id = pIdLife[1]
        lSpecificLifetime = pIdLife[2]
        if lSpecificLifetime = ForProgram then
            return -- Not allowed to get rid of these ones.
        end if
    end if

    -- copy, because list shrinks
    lHeld = heldResource

    -- for each resource
    for i = 1 to length(lHeld) do
        lResList = lHeld[i]
        if lResList[ResStatus] = 1  -- still valid
        and lResList[ResOwner] = id -- got the correct id
        and (lSpecificLifetime = 0 or lResList[ResLife] = lSpecificLifetime) then
            -- release the object
            deleteObject(lResList[ResHandle])

        end if
    end for


end procedure

-----------------------------------------------------------------------------
-- Handle to the cryptographic service provider
atom vCSP vCSP = 0

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- Printer Support

atom printerDC
printerDC = 0
global constant
    w32InchScale = 'i',
    w32MillScale = 'm',
    w32PixelScale = 'p',
    w32TwipsScale = 't'


-----------------------------------------------------------------------------
--/topic Printing
--/proc releasePrinter()
--/desc Release the /Printer, freeing it up for others to use.
-- The /Printer must first be grabbed with /getPrinter.
--
-- Refer to /Printer for details.

global procedure releasePrinter()
--  integer p   -- PL 29/4/09
    -- is there a dc to delete?
    if printerDC then

        -- release resources
        releaseResourcesForID({Printer, ForPaint})

        -- attempt to delete it
        if not w32Func(xDeleteDC, {printerDC}) then
            warnErr(Err_RELEASEPRINTER)
        end if

        -- clear the handle
        printerDC = 0

    end if

end procedure

sequence vPrinterName

----------------------------pointers
atom hdmPtr,hdefPtr          --handles to dvmode structure with default values
atom pname -- points to printer name
pname = 0

---------------------------------------------------------------------------
--      for default printer name w/o printer dialog use next 2 functions
--      returning default printer name and the printer DC
--                              OR
--      can use SelectedPrinterName with PD_RETURNDEFAULT to start printing
--                                                           ----- --------
--      on default printer with default settings.
----------------------------------------------------------------------------

function default_printer_exit(atom mem,atom pBuffer)
    if not pBuffer then
        w32release_mem(mem)
        return ""
    else
        vPrinterName  = w32peek_string(pBuffer)
        pname = w32acquire_mem(0,vPrinterName)
        w32release_mem(mem)
        return vPrinterName
    end if
end function

constant ERROR_FILE_NOT_FOUND=2

--/topic Printing
--/func getDefaultPrinterName()
--/desc Determines the name of the current default printer.
--/ret (STRING) "" on failure, printer name on success.
global function getDefaultPrinterName()
-- this compiles code by J. Deschnes, -- api_wrap.ew
--                       J. Evans,      -- prt32lib.ew, ca 1999
--                       L. Miller,     -- EuForum, Jan 10, 2006
--                       W. Fritz,      -- EuForum, Feb 2006
--                       C. Cuvier      -- May 27, 2007
atom pPInfo5, pNeeded, pReturned,mem,pBuffer
--sequence PrinterName  -- PL 29/4/09
integer rc, needed

    mem = w32new_memset()
    pNeeded = w32acquire_mem(mem,Long)

    if WINDOWS_VERSION[1] >= WIN_2000 then -- Win2K and later
        needed=64  -- some supposedly reasonable start value
        pBuffer = w32acquire_mem(mem,needed)
        poke4(pNeeded,needed)
        rc = w32Func(xGetDefaultPrinter,{pBuffer,pNeeded})
        if rc=0 then
            rc=1 -- buffer holds the ASCIZ string
        elsif rc=ERROR_FILE_NOT_FOUND then
            return default_printer_exit(mem,0) -- no default printer
        else
            -- reallocate buffer based on function result
            pBuffer = w32acquire_mem(mem,peek4u(pNeeded)) 
            -- try again, now it will work
            rc = not w32Func(xGetDefaultPrinter,{pBuffer,pNeeded})
        end if
    elsif WINDOWS_VERSION[1]<=WIN_ME then
        pReturned = w32acquire_mem(mem,Long)
        -- first try to know how many bytes needed for pPInfo5
        VOID = w32Func(xEnumPrinters, {PRINTER_ENUM_DEFAULT,NULL,5,0,0,pNeeded,pReturned})
    
        needed = peek4u(pNeeded)

        pPInfo5 = w32acquire_mem(mem,needed)    
    
        -- now get the struing
        rc = w32Func(xEnumPrinters,{PRINTER_ENUM_DEFAULT,NULL,5,pPInfo5,needed,
                                    pNeeded,pReturned})
        if rc then
            pBuffer = peek4u(pPInfo5)
        else
            pBuffer = 0
        end if                                
    else -- WinNT4.0 and earlier
        needed=64  -- some supposedly reasonable start value
        pBuffer = w32acquire_mem(mem,needed) 
        rc = needed-1
        while rc=needed-1 do
            rc = w32Func(xGetProfileString,{
                                            w32acquire_mem(mem,"windows"),
                                            w32acquire_mem(mem,"device"),
                                            w32acquire_mem(mem," "),pBuffer,needed})
            if rc=0 then
                return default_printer_exit(mem,0)
            elsif rc=needed-1 then -- buffer just large enough or not enough
                needed+=64
                pBuffer = w32acquire_mem(mem,needed) 
            end if            
        end while
        pReturned = pBuffer
        rc = peek(pBuffer)
        while rc!=',' do
            if rc=0 then
                return default_printer_exit(mem,0)
            else
                pReturned+=1
            end if
        end while
        poke(pReturned,0)  -- cut returned string short
    end if
    
    return default_printer_exit(mem,pBuffer)
end function
vPrinterName = getDefaultPrinterName()

atom vPrinterHandle
integer vDevmodeSize
procedure setPrinterPointers(integer flag)
    atom phndl
    atom ptr,ptr2
    
    if flag then
        VOID = w32Func(xClosePrinter,{vPrinterHandle})
        w32release_handle(hdmPtr,1)
        w32release_handle(hdefPtr,1)
    end if
    phndl=allocate(4)
    VOID = w32Func(xOpenPrinter,{pname,phndl,0})
    vPrinterHandle=peek4u(phndl)
    vDevmodeSize = w32Func(xDocumentProperties,{0,vPrinterHandle,pname,0,0,0})
    hdefPtr = w32acquire_handle(GMEM_MOVEABLE,vDevmodeSize)
    hdmPtr = w32acquire_handle(GMEM_MOVEABLE,vDevmodeSize)
    ptr = w32handle_to_memory(hdefPtr)
    ptr2 = w32handle_to_memory(hdmPtr)
    VOID = w32Func(xDocumentProperties,{0,vPrinterHandle,pname,ptr,0,DM_COPY})
    mem_copy(ptr2,ptr,vDevmodeSize)
    w32release_handle(hdefPtr,0)
    w32release_handle(hdmPtr,0)
    free(phndl)
end procedure
if length(vPrinterName) then    -- PL 29/4/09: this condition added
    setPrinterPointers(0)
end if

--/topic Printing
--/func getPrinterName()
--/desc Gets the current printer name.
--/ret (STRING) The current printer name.
global function getPrinterName()
    return vPrinterName
end function

sequence job_properties
job_properties={1,1,1,1,1,0,0,0,0,0,0,0}

constant known_props = {
                        JP_FromPage,
                        JP_ToPage,
                        JP_MinPage,
                        JP_MaxPage,
                        JP_Copies,
                        JP_PrintFlags,
                        JP_Orientation,
                        JP_SetupFlags,
                        JP_PaperSize,
                        JP_PaperBin,
                        JP_Collate,
                        JP_Margins
                       }
constant wsp = w32acquire_mem(0,"WINSPOOL") -- name of the printer spool .drv/.dll
integer new_left_margin,new_top_margin
    new_left_margin=0
    new_top_margin=0
                 
function setPageMargins(sequence new_value)
        integer margin_l,margin_w,ppi_l,ppi_w, unit,phy_l,phy_w
    -- PL 29/4/09
    --  atom dp2lp,flags, ptr, info_dc
        atom dp2lp,flags, info_dc
    --  sequence result -- PL 29/4/09

        -- get printer margins in logical pixels
        info_dc = w32Func(xCreateIC, {wsp, pname,0,0})
        dp2lp = w32acquire_mem(0,16)
        margin_w = w32Func(xGetDeviceCaps,{info_dc,PHYSICALOFFSETX})
        margin_l = w32Func(xGetDeviceCaps,{info_dc,PHYSICALOFFSETY})
        phy_w = w32Func(xGetDeviceCaps,{info_dc,PHYSICALWIDTH})
        phy_l = w32Func(xGetDeviceCaps,{info_dc,PHYSICALHEIGHT})
        poke4(dp2lp,{margin_w,margin_l, phy_w,phy_l})
        VOID = w32Func(xDPtoLP,{info_dc,dp2lp,2})

        -- convert all margins to logical pixels
        ppi_w = w32Func(xGetDeviceCaps,{info_dc,LOGPIXELSX})
        ppi_l = w32Func(xGetDeviceCaps,{info_dc,LOGPIXELSY})
        unit = new_value[5]
        if unit != w32PixelScale then
    --/**/  new_value = sq_mul(new_value[1..4],{ppi_w,ppi_l,ppi_w,ppi_l})   --/* -- Phix
            new_value = new_value[1..4] * {ppi_w,ppi_l,ppi_w,ppi_l}         --*/ -- RDS
            if unit = w32MillScale then
    --/**/      new_value = sq_floor_div(new_value,25.4)        --/* -- Phix
                new_value = floor(new_value/25.4)               --*/ -- RDS
            elsif unit = w32TwipsScale then
    --/**/      new_value = sq_floor_div(new_value,1440)        --/* -- Phix
                new_value = floor(new_value/1440)               --*/ -- RDS
            elsif unit != w32InchScale then
                warnErr("Unknown custom paper size unit - pixels assumed")
            end if
        end if

        -- ensure that margins are not set any thinner than what the device can support, and
        if new_value[1]<peek4u(dp2lp) then
            new_value[1]=peek4u(dp2lp)
        end if
        if new_value[2]<peek4u(dp2lp+4) then
            new_value[2]=peek4u(dp2lp+4)
        end if
        -- left/top margins are implemented by setting the printer viewport.
        -- this will be done on a real printer DC, which may not be available yet
        new_left_margin = new_value[1]
        new_top_margin = new_value[2]

        -- right/bottom margins are implemented by faking a paper size with lesser dimensions
        -- new paper width = standard - (new right margin - std right margin), and similar for height.
        -- convert offsets to tenths of millimeters
        margin_l = new_value[4]-peek4u(dp2lp+4)
        if margin_l<=0 then
            margin_l = 0
            flags = 0
        else
            flags = DM_PAPERLENGTH
            margin_l = floor(margin_l*254/ppi_l)
            phy_l = floor(peek4u(dp2lp+12)*254/ppi_l)
            margin_l = phy_l - margin_l
        end if
        margin_w = new_value[3]-peek4u(dp2lp)
        if margin_w<=0 then
            margin_w = 0
        else
            flags += DM_PAPERWIDTH
            margin_w = floor(margin_w*254/ppi_w)
            phy_w = floor(peek4u(dp2lp+8)*254/ppi_l)
            margin_w = phy_w - margin_w
        end if

        w32release_mem(dp2lp)
        VOID = w32Func(xDeleteDC,{info_dc})
        return {margin_l,margin_w,flags}
    end function

--/topic Printing
--/func setPrintJobProperty(integer which,object new_value)
--/desc Gets, and possibly sets, a print job property.
--/ret Current/former value for the property.
-- Using the w32GetValue pseudo value will cause the current property value to be returned
-- without attempting to set it.
-- This function is typically used after a call to /newPrinter() to set a few settings
-- without the user having to interact with a print/page setup dialog box.
-- Changes will be effective on the next call to getPrinter().
--
-- Recognised properties, and respective meanings of /i new_value, are:
-- /li /b JP_FromPage : the starting page number
-- /li /b JP_ToPage   : the last page number
-- /li /b JP_MinPage  : the minimum value allowed for the starting page number
-- /li /b JP_MaxPage  : the maximum value allowed for the last page number
-- /li /b JP_Copies   : the number of requested copies
--/li /b JP_PrintFlags: the flags used to build the print dialog. Please refer to Microsoft documentation for more details on uses and values.
--              Tge supported values are the PD_* values in w32constants.ew
--/li /b JP_Orientation : either DMORIENT_PORTRAIT or DMORIENT_LANDSCAPE
--/li /b JP_SetupFlags  : the flags used to build the page setup dialog.
--/li /b JP_PaperBin: the source of paper the printer is to use. Please refer to w32constants.ew
--             for a list of supported DMBIN_* values.
--/li /b JP_PaperSize: either a predefined DMPAPER_* constants in w32constants.ew,
--             or a triple {length,width,unit}. Supported units are:
--<ul>
--/li w32InchScale : values are in inches
--/li w32MillScale : values are in millimeters
--/li w32PixelScale : values are in pixels
--/li w32TwipsScale : values are in twips (1/1440th of an inch)
--</ul>
--/li /b JP_Margins: a 5 element sequence {left margin,top margin,right margin,bottom margin,unit}
--              where /i unit is as above.
--/li /b JP_Collate: 0 to disable collation of multiple copies, any positive value to enable.
--
-- The first properties (JP_From/To/Min/MaxPage) only affect the print dialog box, not
-- the printer itself. You can control which pages are printed in the contents of a RichEdit control by using /printRichEditPages().
-- In later versions, /startPage() may be modified to take these parameters into account.
global function setPrintJobProperty(integer which,object new_value)
        integer p, alt_value, ppi_l, ppi_w, use_alt_value 
        object old_value
        atom ptr,flags, converter 
        sequence storage

        p = find(which,known_props) -- p = which if valid
        if p=0 then 
            return 0  -- unknown property
        else
            if which = JP_Collate then
                new_value = compare(new_value,0)
            end if
            old_value = job_properties[p]
            if compare(new_value,0) = -1 then -- just peeking
                return old_value
            end if
        end if

        if p=JP_Orientation and not (new_value=DMORIENT_PORTRAIT or new_value=DMORIENT_LANDSCAPE) then
            warnErr("Not a valid orientation: " & sprintf("%d",new_value)&"\nOrientation reset to Portrait.")
            new_value = DMORIENT_PORTRAIT
        end if
        job_properties[p] = new_value
        use_alt_value = 0

        -- now setup the printer
        if which = JP_Orientation then
            storage = DEVMODE_dmOrientation
            flags = DM_ORIENTATION
        elsif which = JP_Copies then
            storage = DEVMODE_dmCopies
            flags = DM_COPIES
        elsif which = JP_PaperSize then
            if atom(new_value) then
                storage = DEVMODE_dmPaperSize
                flags = DM_PAPERSIZE
            else
                storage = DEVMODE_dmPaperLength
                flags = DM_PAPERLENGTH + DM_PAPERWIDTH
                -- convert length and width to tenths of millimeter
                converter = new_value[3]
                if converter = w32InchScale then
                    converter = 254.0
                elsif converter = w32MillScale then
                    converter = 10.0
                elsif converter = w32TwipsScale then
                    converter = 254/1440
                elsif converter = w32PixelScale then
                    ppi_w = w32Func(xGetDeviceCaps,{printerDC,LOGPIXELSX})
                    ppi_l = w32Func(xGetDeviceCaps,{printerDC,LOGPIXELSY})
                    new_value[2] *= 254.0 / ppi_w
                    new_value[1] *= 254.0 / ppi_l
                    converter = 1.0
                else
                    warnErr("Unknown custom paper size unit - millimeters assumed")
                    converter = 10.0
                end if
    --/**/      new_value = sq_mul(new_value,converter)     --/* -- Phix
                new_value *= converter                      --*/ -- RDS
                alt_value = floor(new_value[2]) -- new width
                new_value = floor(new_value[1]) -- new length
                use_alt_value = 1
            end if
        elsif which = JP_PaperBin then
            storage = DEVMODE_dmDefaultSource
            flags = DM_DEFAULTSOURCE
        elsif which = JP_Collate then
            storage = DEVMODE_dmCollate
            flags = DM_COLLATE
        elsif which = JP_Margins then
            new_value = setPageMargins(new_value)
            flags = new_value[3]
            if and_bits(flags,DM_PAPERWIDTH) then
                alt_value = new_value[2]
                use_alt_value = 1
            end if
            new_value = new_value[1]
            storage = DEVMODE_dmPaperLength
        else
            flags = 0
        end if

        if flags then -- other properties are not sent to printer
            ptr = w32handle_to_memory(hdmPtr)
            if and_bits(flags,DM_PAPERLENGTH) then
                flags += DM_PAPERSIZE
                w32store(ptr,DEVMODE_dmPaperSize,DMPAPER_USER)
            end if
            w32store(ptr,DEVMODE_dmFields,flags)
            w32store(ptr,storage,new_value)
            if use_alt_value then
                w32store(ptr,DEVMODE_dmPaperWidth,alt_value)
            end if
            VOID = w32Func(xDocumentProperties,{0,vPrinterHandle,pname,ptr,ptr,DM_IN_BUFFER+DM_OUT_BUFFER})
            w32release_handle(hdmPtr,0)
        end if

        return old_value
    end function

procedure clean_release(integer iBuiltDevMode,atom struct)
        if struct then
            w32release_mem(struct)
        end if
        if iBuiltDevMode then
            w32release_handle(hdmPtr,w32True)
        end if
    end procedure

global constant Err_NOPRINTERDIALOG = {"Unable to open printer dialog",454}

--/topic Printing
--/func getPrintChoice(integer pMaxPages, object pFlags, atom pPrintDlg)
--/desc Get the choices from a user before printing.
--/ret SEQUENCE: {startpage, endpage, copies, printerDC, collate, p2f, orient, paper}, or {} if user aborted.
-- This pops up the "Select Printer" dialog for the
-- user to select a printer from.
--
-- /i pMaxPages specifies the maximum number of pages that a user can print,
-- /i pFlags is additional flags for the dialog box. See the Microsoft
-- documentation for details. It is either a sequence of flag values, in
-- which case it replaces the default ones, or it is an atom of OR'd flags
-- which are OR'd with the defaults (PD_ALLPAGES). If pFlags is {}, the current value
-- for the JP_PrintFlags job property will be used.
--
-- /i pPrintDlg is used for experts only. If zero, it is ignored. Otherwise
-- it is the address of a PRINTDLG structure which has been correctly setup
-- by the caller.
--
-- The returned sequence has the starting and ending pages that the user selected. If
-- these are both 0, then the user only wants the current document selection printed.
-- If these are both -1, then the user wants all pages printed.
--
-- /i copies is the number of copies to be printed. /n
-- /i printerDC is the Printer's Device Context. This is not normally used directly
-- but is available for advanced users. /n
-- /i collate is w32True if the user wants the output collated. /n
-- /i p2f is w32True if the user wants output to go to a file rather than the printer. /n
-- /i orient is either DMORIENT_PORTRAIT or DMORIENT_LANDSCAPE. /n
-- /i paper is the numeric code for the type of paper requested. /n
-- /i flags is the state of the print dialog after user interaction. /n
--
-- See also /Printer

global function getPrintChoice(integer pMaxPages, object pFlags, atom pPrintDlg)
        integer rc,fromPage, toPage, copies, collate, p2f, orient, paper,iBuiltDevMode
    -- PL 29/4/09
    --  atom mem, flags, hDevMode,ptr, curr_devmode,pDC
        atom mem, flags, ptr, curr_devmode,pDC
        sequence pName

        if pMaxPages then end if    -- suppress warnings    -- PL 29/4/09
        --if PD_RETURNDEFAULT is not one of the flags we can pass the 
        --orientation and/or printer name:
        --if we already have orientation (from users use of page dialog or
        --author supplied)
        --or printer name (from users use of page dialog or from
        --   GetDefaultPrinter)
        --then we will global allocate the devMode structure and fill with 
        --these items.

        -- default flags
        if equal(pFlags ,{}) then
            pFlags = job_properties[JP_PrintFlags]
        elsif atom(pFlags) then
            pFlags &= PD_ALLPAGES -- initially set the 'All Pages' radio button
        end if
        flags = w32or_all(pFlags & PD_RETURNDC)
                  
            -- set up
        if pPrintDlg = 0 then
        -- get memory for the dialog
            mem = w32acquire_mem(0,SIZEOF_PRINTDLG)
            w32store(mem, PRINTDLG_lStructSize, SIZEOF_PRINTDLG)
            w32store(mem, PRINTDLG_flags, flags)
            w32store(mem, PRINTDLG_nMaxPage, job_properties[JP_MaxPage])
            w32store(mem, PRINTDLG_nMinPage, job_properties[JP_MinPage])
            w32store(mem, PRINTDLG_nCopies, job_properties[JP_Copies])
            w32store(mem, PRINTDLG_nToPage, job_properties[JP_ToPage])
            w32store(mem, PRINTDLG_nFromPage, job_properties[JP_FromPage])
        else
            mem = pPrintDlg -- use externally supplied structure
        end if

        iBuiltDevMode=0
        if and_bits(PD_RETURNDEFAULT,flags) then
            curr_devmode = hdefPtr
        elsif job_properties[JP_Orientation] or length(vPrinterName) then
            iBuiltDevMode=1

            --get the pointer
            -- This function returns a pointer to the 'fixed' memory block
            -- need to do this only if print dialog created the structure
            ptr = w32handle_to_memory(hdmPtr)

            -- set up some fields
            w32store(ptr,DEVMODE_dmSize,SIZEOF_DEVMODE)
            w32store(ptr,DEVMODE_dmOrientation,job_properties[JP_Orientation])   --poke in orientation flag
            w32store(ptr,DEVMODE_dmFields,DM_ORIENTATION)
            w32store(ptr,DEVMODE_dmDeviceName,vPrinterName)       --poke in printer name
            w32store(ptr,DEVMODE_dmCopies,job_properties[JP_Copies])

            -- register new devmode state
            VOID = w32Func(xDocumentProperties,{0,vPrinterHandle,pname,ptr,ptr,DM_IN_BUFFER+DM_OUT_BUFFER})

            -- tell the dlg box that curr_devmode is the starting point
            w32store(mem,PRINTDLG_hDevMode,hdmPtr)
            w32release_handle(hdmPtr,0)
        end if

        -- call the routine
        if not w32Func(xPrintDlg, {mem}) then
        --check CommDlgExtendedError for error reason. A zero return means user
        --closed or cancelled the dialog.
            rc = w32Func(CommDlgExtendedError,{})
            clean_release(iBuiltDevMode,pPrintDlg)
            if rc then
                abortErr(Err_NOPRINTERDIALOG)
            else
                return {}        --user closed or cancelled dialog
            end if
        end if 
       
        -- get some values from devMode structure after user has accessed Print Dialog
        --    (user might have changed something)

        if iBuiltDevMode then
        -- first look for the handle DEVMODE
            curr_devmode = w32fetch(mem ,PRINTDLG_hDevMode)
            hdmPtr = curr_devmode
        end if
        -- DevMode is a dynamic, moveable structure
        -- so lock the memory so it can't be moved. 
        ptr = w32handle_to_memory(curr_devmode)

        --get the printer orientation and the selected printer
        copies = w32fetch(ptr,DEVMODE_dmCopies)
        --print for the number of copies in printdlg if devmode copies 1
        if copies=1 or copies=0 then
            copies = w32fetch(mem,PRINTDLG_nCopies)  
        end if
        job_properties[JP_Copies] = copies

        orient = w32fetch(ptr,DEVMODE_dmOrientation)
        job_properties[JP_Orientation] = orient
        
        pName = w32peek_string(w32address(ptr,DEVMODE_dmDeviceName))
        paper = w32fetch(ptr, DEVMODE_dmPaperSize)

        flags = w32fetch(mem, PRINTDLG_flags)
        if and_bits(flags, PD_PAGENUMS) then
            fromPage = w32fetch(mem, PRINTDLG_nFromPage)
            toPage   = w32fetch(mem, PRINTDLG_nToPage)
            job_properties[JP_FromPage] = fromPage
            job_properties[JP_ToPage] = toPage
            job_properties[JP_MinPage] = w32fetch(mem,PRINTDLG_nMinPage)      
            job_properties[JP_MaxPage] = w32fetch(mem,PRINTDLG_nMaxPage)      

        elsif not and_bits(flags, PD_SELECTION) then    --PD_ALLPAGES is 0!
            fromPage = -1
            toPage   = -1

        else -- PD_SELECTION active
            fromPage = 0
            toPage   = 0
        end if

        collate= (and_bits(flags,PD_COLLATE) != 0)
        p2f = (and_bits(flags,PD_PRINTTOFILE) != 0)

        -- unlock the memory so the program can use the datastructure
        w32release_handle(curr_devmode,0)

        -- check for printer or DC change
        if compare(pName,vPrinterName) then
            releasePrinter()
            setPrinterPointers(1)
            vPrinterName = pName
        end if

        pDC = w32fetch(mem ,PRINTDLG_hdc)
        if pDC != printerDC then -- this will happen if name changed, as pinterDC will be zero
            if printerDC then
                releasePrinter()
            end if
            printerDC = pDC
        end if

        if pPrintDlg then
            w32release_mem(pPrintDlg)
        end if

        if printerDC then
            -- information the user selected
            return {fromPage, toPage, copies, printerDC, collate, p2f, orient, paper,flags}
        else
            -- failed
            return {}
        end if
end function

-----------------------------------------------------------------------------
--/topic Printing
--/func getPrinter()
--/desc Get the /Printer.
--/ret SEQUENCE: {start page, end page, copies, printerDC, collate, p2f, orient, paper}, or {} if user aborted.
-- This pops up the "Select Printer" dialog for the
-- user to select a printer from. It defaults to a maximum of 999 pages.
--
-- See /getPrintChoice for details about this routine. /n
--
-- See also /Printer.

global function getPrinter()
    return getPrintChoice(999, 0, 0)
end function

global constant Err_NOPAGEDIALOG = {"Unable to open page dialog ",453}

--/topic Dialogs
--/func getPageSetupEx(atom Flags)
--/desc Page setup dialog
--/ret SEQUENCE : {paperSize, margins , orientation, papertype}  /b or  w32False if the user cancels
--/i Flags are the /b"or'd" flags... /n
--<ul>
--/li PSD_DEFAULTMINMARGINS
--/li PSD_DISABLEMARGINS
--/li PSD_DISABLEORIENTATION
--/li PSD_DISABLEPAGEPAINTING
--/li PSD_DISABLEPAPER
--/li PSD_DISABLEPRINTER
--/li PSD_ENABLEPAGEPAINTHOOK
--/li PSD_ENABLEPAGESETUPHOOK
--/li PSD_ENABLEPAGESETUPTEMPLATE
--/li PSD_ENABLEPAGESETUPTEMPLATEHANDLE
--/li PSD_INHUNDREDTHSOFMILLIMETERS
--/li PSD_INTHOUSANDTHSOFINCHES
--/li PSD_INWININIINTLMEASURE
--/li PSD_MARGINS
--/li PSD_MINMARGINS
--/li PSD_NOWARNING
--/li PSD_RETURNDEFAULT
--/li PSD_SHOWHELP
--
-- Passing an empty sequence will use whatever last value iwas stored for the page setup flags.
--
--The return values are ... /n
--</ul>
-- /li /i paperSize: {x, y}
-- /li /i margins: {left, top, right, bottom}
-- /li /i orientation: Either DMORIENT_PORTRAIT or DMORIENT_LANDSCAPE.
-- /li /i papertype: The numeric code for the type of paper.
--
-- This also sets the printer to the user's selection.
global function getPageSetupEx(object pFlags, atom pSetupDlg)
    atom psd,  devname
    sequence result
-- PL 29/4/09
--  integer rc,orient, iBuiltDevMode
    integer orient, iBuiltDevMode
    atom ptr,curr_devmode,flags
    
    iBuiltDevMode=0

    -- get memory for the dialog
    if pSetupDlg = 0 then
        psd = w32to_memory(0, ID_PAGESETUPDLG,0)
    else
        psd = pSetupDlg
    end if


    if atom(pFlags) then
        flags = pFlags
    elsif not length(pFlags) then
        flags = job_properties[JP_SetupFlags]
    else
        flags = w32or_all(pFlags)
    end if
    
    if and_bits(PSD_RETURNDEFAULT,flags) then   
        curr_devmode = hdefPtr
    elsif job_properties[JP_Orientation] or length(vPrinterName) then
        iBuiltDevMode=1

        --get the pointer
        ptr = w32handle_to_memory(hdmPtr)

        w32store(ptr,DEVMODE_dmSize,SIZEOF_DEVMODE)
        w32store(ptr,DEVMODE_dmOrientation,job_properties[JP_Orientation])   --poke in orientation flag
        w32store(ptr,DEVMODE_dmFields,DM_ORIENTATION)
        w32store(ptr,DEVMODE_dmDeviceName,vPrinterName)       --poke in printer name
        w32store(psd,PAGESETUPDLG_hDevMode,hdmPtr)
        VOID = w32Func(xDocumentProperties,{0,vPrinterHandle,pname,ptr,ptr,DM_IN_BUFFER+DM_OUT_BUFFER})
        w32release_handle(hdmPtr,w32False)
    end if
    w32store(psd, PAGESETUPDLG_Flags, flags)

    -- call OS
    if not w32Func(xPageSetupDlg, {psd}) then
    --check CommDlgExtendedError for error reason. A zero return means user
    --closed or cancelled the dialog.
        clean_release(iBuiltDevMode,pSetupDlg)
        if w32Func(CommDlgExtendedError,{}) then
            abortErr(Err_NOPAGEDIALOG)
        else
            return {}
        end if
    end if
    releasePrinter()

    if iBuiltDevMode then
        curr_devmode = w32fetch(psd,PAGESETUPDLG_hDevMode)
        hdmPtr = curr_devmode
    end if
    ptr = w32handle_to_memory(curr_devmode)

    --  get the orientation from devMode
    orient = w32fetch(ptr,DEVMODE_dmOrientation)
    job_properties[JP_Orientation] = orient

    --  get the selected printer name from devMode
    result = w32peek_string(ptr)
    if compare(result,vPrinterName) then
        setPrinterPointers(1)
        vPrinterName = result
    end if

    -- get the flags
    job_properties[JP_SetupFlags]  = w32fetch(psd,PAGESETUPDLG_Flags)

    result = {
              w32fetch(psd, PAGESETUPDLG_ptPaperSize),
              w32fetch(psd, PAGESETUPDLG_rtMargin),
              orient,
              w32fetch(ptr, DEVMODE_dmPaperSize)
             }

    -- get new printer's DC
    devname = w32fetch(psd, PAGESETUPDLG_pDevNames)
    printerDC = w32Func(xCreateDC,{
                                   wsp, -- 0 doesn't seem to be a problm under XP, but in theortyr is
                 -- and actually was (CChris 06/17/2007)
            --devname + w32fetch(devname, DEVNAMES_wDeviceOffset) ,
                                   pname,
                                   0,
                                   ptr
                                  })

    -- release the memory
    w32release_handle(curr_devmode,w32False)
    if pSetupDlg then
        w32release_mem(pSetupDlg)
    end if
    return result
end function

--/topic Printing
--/proc getDefaultPrinter()
--/desc Sets up the last printer used (or default printer) for printing
-- The other printing options are the one that were set at the last printing attempt or 
-- subsequent calls to /setPrintJobProperty().
global procedure getDefaultPrinter()
    atom ptr

    ptr = w32handle_to_memory(hdmPtr)
    printerDC = w32Func(xCreateDC, {wsp,pname,0,ptr})
    w32release_handle(hdmPtr,w32False)
    VOID = w32Func(xSetViewportOrgEx,{printerDC,new_left_margin,new_top_margin,0})
end procedure

--/topic Printing
--/proc newPrinter(sequence s,integer flag)
--/desc Sets up the printer whose friendly name is supplied.
-- If /i flag is set, all properties that had been set using /setPrintJobProperty() will
-- be applied to the new printer. Otherwise, the default new printer configuraton will be
-- in force.
global procedure newPrinter(sequence s,integer flag)
--PL 28/4/09:
--  pname = s
    pname = w32acquire_mem(0,s)
    setPrinterPointers(1)
    if flag then
        for i=JP_Copies to length(job_properties) do
            if not equal(job_properties[i],0) then
                VOID = setPrintJobProperty(i,job_properties[i])
            end if
        end for
    else -- reset to defaults
        job_properties[JP_Copies..length(job_properties)]=0
        new_left_margin = 0
        new_top_margin = 0
    end if
end procedure

--/topic Dialogs
--/func getPageSetup()
--/desc Page setup dialog
--/ret SEQUENCE: {paperSize, margins, orientation, papertype}  /b or    w32False if the user cancels
-- This calls /getPageSetupEx() using the default flags of ... /n
--<ul>
--/li PSD_DEFAULTMINMARGINS
--/li PSD_INTHOUSANDTHSOFINCHES
--</ul>
global function getPageSetup()
    return getPageSetupEx(or_bits(PSD_DEFAULTMINMARGINS,
                                  PSD_INTHOUSANDTHSOFINCHES),
                          0
                         )
end function

--/topic Printing
--/proc checkPrinter(integer release_if_exists)
--/desc Checks if a printer was chosen. Prompts the user if none found, or possibly release it.
-- If the passed flag is 0, and there is a printer, it won't be released.
-- If there is no printer, getPrinterChoice() will be invoked. If still no
-- printer is selected, the procedure raises an error.
global procedure checkPrinter(integer release_if_exists)
    if not length(vPrinterName) then
        if not length(getPageSetup()) then
            warnErr("Printer has not be chosen")
            return
        end if
    elsif release_if_exists then
        releasePrinter()
    end if
end procedure


---------------------------------------------------------------------------
--/topic Printing
--/func startDoc(sequence jobname)
--/desc Starts a new document on /Printer.
--/ret INTEGER: w32True if succeeds.
-- Start a new document on the /Printer. /n
-- The /i jobname parameter can either be the name of the job as seen by the system or
-- {jobname, filename}. If /i filename is "", then the default of "FILE:" is used. /n
--
-- If the filename is specified, the document is sent to the file rather than the printer device. /n
-- If the filename is "FILE:" then the user will be prompted for the name of the file to use.
--
-- Refer to /Printer for details.

global function startDoc(sequence job)
    -- start the document

    atom di, result
    sequence docName,out

    result = 0
    checkPrinter(0)
    if printerDC != 0 then
        if length(job)=2 and sequence(job[2]) then  -- print to file requested
            docName=job[1]
            if length(job[2]) != 0 then
                out = job[2]
            else
                out = "FILE:"
            end if
        else
            docName=job
            out = ""
        end if

        -- Allocate the structure, and store the values
        di = w32to_memory(0,ID_DOCINFO, {docName,out})

        result = w32Func(xStartDoc, {printerDC, di})

        -- Free the structure
        w32release_mem(di)
    end if

    -- returns true if succeeds
    return (result > 0)

end function

-----------------------------------------------------------------------------
--/topic Printing
--/func endDoc()
--/desc Ends the print job.
--/ret w32True if succeeds.
-- Applications should call endDoc() when finished printing.
--
-- Refer to /Printer for details.

global function endDoc()
    checkPrinter(0)
    if printerDC != 0 then
        -- end the document
        return w32Func(xEndDoc, {printerDC}) >= 0
    else
        return 0
    end if

end function

--/topic Printing
--/proc abortDoc()
--/desc Abandons the print job, flushing anything created so far for it.
-- Applications should call abortDoc() to cancel a print job.

global procedure abortDoc()
    checkPrinter(0)
    if printerDC != 0 then
        -- cancel the document.
        VOID = w32Func(xAbortDoc, {printerDC})
    end if
end procedure


-----------------------------------------------------------------------------
--/topic Printing
--/func startPage()
--/desc Prepares the printer to begin a new page.
--/ret w32True if succeeds.
--
-- Refer to /Printer for details.

global function startPage()
    checkPrinter(0)
    if printerDC != 0 then
        -- start the document
        return w32Func(xStartPage, {printerDC}) >= 0
    else
        return 0
    end if
end function

-----------------------------------------------------------------------------
--/topic Printing
--/func endPage()
--/desc Ends the printing of the current page.
--/ret w32True if succeeds.
--
-- Refer to /Printer for details.

global function endPage()
    checkPrinter(0)
    if printerDC != 0 then
        -- end the document
        return w32Func(xEndPage, {printerDC}) >= 0
    else
        return 0
    end if
end function

-----------------------------------------------------------------------------

global constant
    DC_OPT_ERROR = 1,
    DC_OPT_WINDOW = 2
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
--/topic Low Level Routines
--/func getDC(id)
--/desc Get the DC (device context) of the control.
--/ret ATOM: Device Context (DC) of the control.
-- If the DC is already grabbed, the value is simply returned without
-- grabbing it again.
--
-- /i id is either a simple integer or a sequence {id,option}. In the latter case, /i option 
-- is the sum of zero or more flags:
--/li DC_OPT_ERROR: if returned DC is 0, trigger an error instead of quietly returning it
--/li DC_OPT_WINDOW: get a full window DC rather than a standard client DC. This flag only makes sense for standard windows. 
--
-- When using the DC_OPT_WINDOW flag, be sure to have released the standard window DC prior.
-- In these DC's, coordinates are relative to the window rectangle, and not to the client rectangle.
--
-- There are some special cases that are handled:
-- /li Normal controls: This includes any control that is normally
--          visible on the screen. This performs a normal /b GetDC.
-- /li /Screen: Passing the parameter of /Screen returns the
--          DC of the monitor.
-- /li /Printer: Passing the parameter of /Printer returns the
--          printer's DC, assuming that one has been selected with
--          /getPrinter.
-- /li /b Pixmaps: This causes a DC compatible with the screen resolution
--          to be created with the pixmap selected into it.
-- /li /b Other: If the value passed is not identifiable as a valid
--          Win32Lib control, it is assumed to be a DIB. A compatible DC
--          is created, and the DIB is selected into it.
--
-- When you are done with the DC, it should be released with /releaseDC
-- /b unless the DC was obtained during an /onPaint event, since the DC
-- will be released automatically.

global function getDC(object pID)
    -- get device context.

    integer lPos
    atom lhDC, lNewBmp, lSavedDC
    object lOption

    lOption = {}

    if sequence(pID) then
        lOption = pID[2]
        if sequence(lOption) then
            lOption = DC_OPT_ERROR
        end if
        pID = pID[1]
    else
        lOption = 0
    end if

    -- Check that I haven't already got a DC for this control.
    lPos = w32findKey(pID, grabbedHDC)
    if lPos != 0 then
        grabbedHDC[lPos][kTrackedCurDC][kTrackedDCCnt] += 1
        return grabbedHDC[lPos][kTrackedCurDC][kTrackedDCHdl]
    end if

    lhDC = NULL
    lSavedDC = NULL
    lNewBmp = NULL

    -- get the device context
    if pID = Screen then

        lhDC = w32Func(xGetDC, {0})

    elsif pID = Printer then
        -- the printer dc
        lhDC = printerDC

    elsif not validId(pID) then
        -- the pID isn't a valid handle, so assume it is a bitmap.

        -- create a memory device context compatible with the screen
        lhDC = w32Func(xCreateCompatibleDC, {NULL})

        -- select the bitmap into it
        lNewBmp = pID

    elsif getControlInfo(pID,CONTROLINFO_class) = PIXMAP then
        -- pixmap class

        -- create a memory device context compatible with the screen
        lhDC = w32Func(xCreateCompatibleDC, {NULL})
        
        -- select the bitmap into it
        lNewBmp = getHandle(pID)

    else
        if not and_bits(lOption,DC_OPT_WINDOW) then
            lhDC = w32Func(xGetDC, {getHandle(pID)})
        else
            lhDC = w32Func(xGetWindowDC, {getHandle(pID)})
        end if

    end if

    if lhDC = NULL then
        if and_bits(lOption,DC_OPT_ERROR) then
            warnErr(Err_GETDCFAIL)
        else
            return 0
        end if
    end if


    if lNewBmp != NULL then

        replaceObject(pID, kBitmapObject, lhDC, lNewBmp, ForProgram)
    else
        -- save the current device context
        lSavedDC = w32Func(xSaveDC, {lhDC})
    end if

    -- add to list

    grabbedHDC = prepend(grabbedHDC, {pID,{1,lhDC,lSavedDC,kDCReasonApp}})

    return lhDC

end function
r_getDC = routine_id("getDC")

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc releaseDC(control)
--/desc Release the device context of the control.
-- The DC should have been obtained with /getDC.
--
-- If the control is not a Pixmap or DIB, and the DC was obtained during an
-- /onPaint event, there is no need to release the DC. Win32Lib will
-- automatically release all DCs obtained during an /onPaint event.
--
-- If the control is the /Printer, there is no need to release the
-- DC using /releaseDC. Instead, use /releasePrinter
global procedure releaseDC(atom pID)

-- PL 29/4/09
--  atom lhDC, lSavedDC
    atom lhDC
    integer lPos, lObjIdx
    sequence lData

    lPos = w32findKey(pID, grabbedHDC)
    if lPos = 0 then
        -- Nothing to release.
        return
    end if

    -- Count down the references.
    grabbedHDC[lPos][kTrackedCurDC][kTrackedDCCnt] -= 1
    if grabbedHDC[lPos][kTrackedCurDC][kTrackedDCCnt] > 0 then
        -- Still some 'gets' outstanding, so don't release it yet.
        return
    end if

    -- get the lhDC from the list
    lData = grabbedHDC[lPos][kTrackedCurDC]

    -- remove from grabbed list
    grabbedHDC[lPos] = w32removeIndex(kTrackedCurDC, grabbedHDC[lPos])
    if length(grabbedHDC[lPos]) = 1 then
        -- No DCs remaining for this ID.
        grabbedHDC = w32removeIndex(lPos, grabbedHDC)
    end if

    lhDC = lData[kTrackedDCHdl]
    lPos = 0
    -- Restore any original resources.
    lPos = w32findKey(lhDC, vDCs) 
    if lPos != 0 then
        for i = 1 to length(kObjectTypes)  do
            lObjIdx = kObjectTypes[i]+1
            if length(vDCs[lPos][lObjIdx]) > 0 then
                replaceObject(pID, kObjectTypes[i], lhDC, vDCs[lPos][lObjIdx][1], 0)
            end if
        end for
        vDCs = w32removeIndex(lPos, vDCs)
    end if

    -- restore the device context if required.
    if lData[kTrackedDCSaved] != NULL then
        if not w32Func(xRestoreDC, {lhDC, lData[kTrackedDCSaved]}) then
            abortErr(Err_RELEASEDCRESTORE)
        end if
    end if
    -- Do a real release if not during a Paint event.
    if lData[kTrackedDCReason] = kDCReasonApp then
        if pID = Screen then

            -- release screen
            if w32Func(xReleaseDC, {0, lhDC}) = 0 then
                warnErr(Err_RELEASESCREEN)
            end if

        elsif pID = Printer then
            -- does nothing; use releasePrinter instead.

        elsif not validId(pID) then
            -- release the device context
            if not w32Func(xDeleteDC, {lhDC}) then
                warnErr(Err_RELEASEBITMAP)
            end if

        elsif getControlInfo(pID,CONTROLINFO_class) = PIXMAP then
            -- release the device context
            if not w32Func(xDeleteDC, {lhDC}) then
                warnErr(Err_RELEASEPIXMAP)
            end if

        else
            -- normal release
            if w32Func(xReleaseDC, {getHandle(pID), lhDC}) = 0 then
                warnErr(Err_RELEASEDC)
            end if

        end if

    end if
end procedure
r_releaseDC = routine_id("releaseDC")

integer extract_mode
function extractDC(object pDC)
    atom lDC

    if sequence(pDC) then -- an actual DC
        if length(pDC)=0 then
            return 0
        else
            lDC=pDC[1]
            extract_mode=2
        end if
    else
        if w32Func(xIsWindow,{pDC}) then
            --  Windows handle
            lDC = w32Func(xGetDC,{pDC})
            extract_mode = 1
        else
            -- Then a control ID was passed
            lDC = getDC(pDC)
            extract_mode = 0
        end if

    end if
    
    return lDC
end function

procedure resetDC(atom pDC)
    VOID = w32Func(xSaveDC, {pDC})
    if VOID = 0 then
        abortErr(Err_ECFSAVEDCFAIL)
    end if

    -- these are NT specific. they should have no effect in Win95
    VOID = w32Func(xSetGraphicsMode, {pDC, GM_ADVANCED})
    VOID = w32Func(xModifyWorldTransform, {pDC, NULL, MWT_IDENTITY})

    VOID = w32Func(xSetViewportOrgEx, {pDC, 0, 0, NULL})
    VOID = w32Func(xSetWindowOrgEx,   {pDC, 0, 0, NULL})
end procedure

--/topic Fonts
--/func convPointsToLogical(object id, object points, integer pLogRes)
--/desc Calculates the 'logical' height of a font given its 'points' size.
--/ret The logical font height.
--This can be used to speed up /setFont and /EzCreateFont calls by allowing
--you to pre-calculate the font heights that Windows needs to find the correct
--font. See example for how it can be used.
--
--/i id is either a control's ID or a sequence starting with a control's DC or a Window handle. /n
--/i points is either a single font point value, or a sequence containing
-- a set of point values to convert. /n
--/i pLogRes is a flag - w32True or w32False. If w32True then the logical device
--resolution is used otherwise the physical device resolution is used.
--
--/b Note that if the /i points is supplied as a sequence, the the /b return
-- value is also a sequence of the same length.
--
--Examples:
--/code
--      sequence lFontHeights
--      -- Calc font heights to be used.
--      -- This returns a set of 4 height values.
--      lFontHeights = convPointsToLogical(mainpanel, {10,12,15,26}, w32True)
--      . . .
--      -- Set the font using one of the precalc heights.
--      setFont(mainpanel, "Arial", {lFontHeights[kHeading1]}, Normal)
--/endcode
global function convPointsToLogical(object pDC, object pHeight, integer pLogRes)
    sequence lHeight
    atom lDC
    atom lDpiY
    atom lPoint

    -- save the current device context because I'm about to
    -- possibly mess it up.

    if atom(pHeight) then
        lHeight = {pHeight}
    else
        lHeight = pHeight
    end if

    lDC = extractDC(pDC)

    -- reset the DC
    resetDC(lDC)

    if (pLogRes) then
        lDpiY = w32Func(xGetDeviceCaps, {lDC, LOGPIXELSY})

    else
        lDpiY = (25.4 * w32Func(xGetDeviceCaps, {lDC, VERTRES}) /
                 w32Func(xGetDeviceCaps, {lDC, VERTSIZE}))

    end if

    -- w32allot
    lPoint  = w32acquire_mem(0, SIZEOF_POINT)
    for i = 1 to length(lHeight) do
        w32store(lPoint,ptY, floor(lHeight[i]*lDpiY/72.0))
        VOID = w32Func(xDPtoLP, {lDC, lPoint, 1})
        lHeight[i] = w32fetch(lPoint,ptY)
    end for
    w32release_mem(lPoint)

    -- restore the device context
    if not w32Func(xRestoreDC, {lDC, -1}) then
        abortErr(Err_ECFRESTOREDC)
    end if

    if extract_mode = 0 then
        releaseDC(pDC)
    elsif extract_mode = 1 then
        VOID = w32Func(xReleaseDC,{lDC})
    end if
    if extract_mode!=2 then

    end if

    if atom(pHeight) then
        return lHeight[1]
    else
        return lHeight
    end if

end function

--/topic Fonts
--/func getFontPointSize(object pDC)
--/desc Returns the logical size, in points, of the font currently used by the target window.
--/ret (INTEGER) The logidal font size in points.
-- The argument is either:
--/li an integer, the id of a win32lib control;       
--/li a sequence starting with a window handle;
--/li a sequence starting wih the handle to a device context.
global function getFontPointSize(object pDC)
    integer pointSize
    atom lDC
    atom currentFont
    atom lDpiY
    atom lPoint,logFont

    lDC = extractDC(pDC)

    -- save the current device context because I'm about to
    -- possibly mess it up.

    resetDC(lDC)

    lDpiY = w32Func(xGetDeviceCaps, {lDC, LOGPIXELSY})

    -- w32allot
    lPoint = w32acquire_mem(0, SIZEOF_POINT)
    currentFont = w32Func(xGetCurrentObject,{lDC,OBJ_FONT}) 
    logFont = w32acquire_mem(0,SIZEOF_LOGFONT)
    VOID = w32Func(xGetObject,{currentFont,SIZEOF_LOGFONT,logFont})
    w32store(lPoint,ptY, peek4u(logFont))
    VOID = w32Func(xLPtoDP, {lDC, lPoint, 1})
    pointSize = w32fetch(lPoint,ptY)
    w32release_mem(lPoint)
    w32release_mem(logFont)
    pointSize = floor(pointSize*(72.0/lDpiY)+0.5)

    -- restore the device context
    if not w32Func(xRestoreDC, {lDC, -1}) then
        abortErr(Err_ECFRESTOREDC)
    end if

    if extract_mode = 0 then
        releaseDC(pDC)
    elsif extract_mode = 1 then
        VOID = w32Func(xReleaseDC,{lDC})
    end if
    if extract_mode!=2 then

    end if

    return pointSize

end function

 
--/topic Fonts
--/func EzCreateFont(integer id, atom pDC, sequence faceName, object pHeight, integer iDeciPtWidth, object iAttributes, integer fLogRes, atom logfont)
--/desc Creates a Font resource
--/ret The new font resource.
-- This is a low-level routine that is not normally required to be called
-- directly. It is primarily for advanced users. /n
--The parameters are: /n
--/code
-- /i id           : The control whose Device Context will be used. /n
-- /i pDC          : The device context. If zero, the routine will
--                   get and release the device context itself. /n
-- /i faceName     : font name /n
-- /i iHeight      : font size, * 10 (i.e.: 125 = 12.5 points /n
-- /i iWidth       : /b Note this is no longer supported. /n
-- /i iAttributes  : flags for attributes, see Bold, etc. /n
-- /i fLogRes      : if true, uses logical resolution instead of screen res. /n
-- /i logfont      : if non-zero, a pointer to user-supplied LOGFONT structure. /n
--/endcode
--
global function EzCreateFont(integer id, atom pDC, sequence pFaceName,
                                object pHeight, atom pDeciPtWidth,
                                object pAttributes, integer pLogRes,
                                atom pLogFont)
    atom    hdc
    atom    hFont
    atom    lf
    atom    lHeight,
--          lWidth,             -- PL 29/4/09
--          lEscapement,        -- PL 29/4/09
--          lOrientation,       -- PL 29/4/09
--          lCharSet,           -- PL 29/4/09
--          lOutPrecision,      -- PL 29/4/09
--          lClipPrecision,     -- PL 29/4/09
--          lQuality,           -- PL 29/4/09
--          lPitchAndFamily,    -- PL 29/4/09
            lStdAttribs

    sequence lFontKey
    integer lPosn

    if pDeciPtWidth then end if -- suppress warnings    -- PL 29/4/09
    if pLogFont != 0 then
        return w32Func(xCreateFontIndirect, {pLogFont})
    end if

    if sequence(pHeight) then
        -- User supplied the logical device height
        lHeight = pHeight[1]

    else
        -- Need to convert point size into logical device height.
        if pDC = 0 then
            hdc = getDC(id)
        else
            hdc = pDC
        end if

        lHeight = convPointsToLogical({hdc}, pHeight/10.0, pLogRes)
                
        if pDC = 0 then
            releaseDC(id)
        end if

    end if

    lFontKey =  {
                 'E',
                 lHeight,
                 pAttributes,
                 vFontWeight,
                 pFaceName
                }
    lPosn = find(lFontKey, vFontKeys)
    if lPosn = 0 then

        lf = w32acquire_mem(0, SIZEOF_LOGFONT)
        w32store(lf, lfHeight,      lHeight)
        w32store(lf, lfFaceName,    pFaceName)
          
        if sequence(pAttributes) then
            lStdAttribs = pAttributes[1]
            w32store(lf, lfWidth,           pAttributes[2])
            w32store(lf, lfEscapement,      pAttributes[3])
            w32store(lf, lfOrientation,     pAttributes[4])
            w32store(lf, lfCharSet,         pAttributes[5])
            w32store(lf, lfOutPrecision,    pAttributes[6])
            w32store(lf, lfClipPrecision,   pAttributes[7])
            w32store(lf, lfQuality,         pAttributes[8])
            w32store(lf, lfPitchAndFamily,  pAttributes[9])
        else
            lStdAttribs   = pAttributes
        end if

        w32store(lf, lfWeight,      (and_bits(lStdAttribs, Bold) != 0) * vFontWeight)
        w32store(lf, lfItalic,      and_bits(lStdAttribs, Italic) != 0)
        w32store(lf, lfUnderline,   and_bits(lStdAttribs, Underline) != 0)
        w32store(lf, lfStrikeOut,   and_bits(lStdAttribs, Strikeout) != 0)
           
        -- create the font
        hFont = w32Func(xCreateFontIndirect, {lf})

        vFontKeys = append(vFontKeys, lFontKey)
        vFontHandles &= hFont
        w32release_mem(lf)
    else
        hFont = vFontHandles[lPosn]
    end if
-- **NOTE** This is not supported from v0.59.2
--    if (pDeciPtWidth != 0) then
--
--        -- replace the current font
--       replaceObject(id, kFontObject, hdc, hFont, ForProgram)
--
--        -- text metric
--        tm  = w32acquire_mem(mset, SIZEOF_TEXTMETRIC)
--
--        -- get the text metrics on the font
--        if not w32Func(xGetTextMetrics, {hdc, tm}) then
--            abortErr(Err_ECFGETTEXTMETRICS)
--        end if
--
--        -- calculate the new size
--        w32store(lf, lfWidth, floor(w32fetch(tm,tmAveCharWidth) *
--                                   w32abs(w32fetch(pt,ptX)) /
--                                   w32abs(w32fetch(pt,ptY)) + 0.5
--                                )
--             )
--
--        -- build the font
--        hFont = w32Func(xCreateFontIndirect, {lf})
--
--    end if




    -- return handle to font
    return hFont

end function

--/topic Low Level Routines
--/func getIdFromDC(atom DC)
--/desc Finds the control Id associated with the supplied Device Context.
--/ret INTEGER: Control ID or 0 if the DC is not associated with a win32lib control.
--/i DC is the device context returned by /getDC
--
--This is primarily used by add-on libraries as a way to use Win32lib routines that need
-- a control ID rather than a device context.
--
--Example:
--/code
--      integer id
--      id = getIdFromDC (theDC)
--/endcode

global function getIdFromDC(atom pHDC)
    integer lID
    integer lPos

    lPos = w32findKeyEx(pHDC, grabbedHDC, {kTrackedCurDC, kTrackedDCHdl})
    if lPos != 0 then
        lID = grabbedHDC[lPos][kTrackedID]
    else
        lID = 0
    end if
    return lID
end function
r_getIdFromDC = routine_id("getIdFromDC")

-- Begin Wolf
--/topic Fonts
--/proc setStartupFont(integer font)
--/desc Establishes the default font to use when creating a window or control.
--/i font is one of the system constants... /n
--/li    OEM_FIXED_FONT
--/li    ANSI_FIXED_FONT
--/li    ANSI_VAR_FONT
--/li    SYSTEM_FONT
--/li    DEVICE_DEFAULT_FONT
--/li    SYSTEM_FIXED_FONT
--
--Example
--/code
--     setStartupFont(SYSTEM_FIXED_FONT)
--/endcode

global procedure setStartupFont(integer font)
    DefaultFontID = w32Func(xGetStockObject, {font})
    vStockResources[1] = DefaultFontID
end procedure
-- End Wolf



-----------------------------------------------------------------------------
--/topic Graphics
--/func getPixel(window, x, y)
--/desc Get a pixel value from /i window's client area.
--/ret rgb value of point.
-- Example:
--
--/code
--      -- get a pixel color from {10,10} in TheWindow
--      atom rgb
--      rgb = /getPixel(TheWindow, 10, 10)
--/endcode

-- NEW! 0.43b restored as global
global function getPixel(integer id, integer x, integer y)

    integer rgb
    atom hdc

    -- get the device context
    hdc = getDC(id)

    -- get pixel
    rgb = w32Func(xGetPixel, {hdc, x, y})

    -- release the device context
    releaseDC(id)

    return rgb

end function
r_getPixel = routine_id("getPixel")

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPixel(window, x, y, rgb color)
--/desc Set a pixel value in /i window's client area.
--
-- Example:
--
--/code
--      -- set pixel at {10,10} to Red
--      /setPixel(TheWindow, 10, 10, Red)
--/endcode

global procedure setPixel(integer id, integer x, integer y, object rgbColor)

    -- returns RGB value from point
    atom hdc

    -- get the device context
    hdc = getDC(id)

    -- get pixel
    VOID = w32Func(xSetPixel, {hdc, x, y, colorValue(rgbColor)})

    -- release the device context
    releaseDC(id)

end procedure

-----------------------------------------------------------------------------
procedure createPen(integer id, atom hdc)

    -- make sure the pen is set

-- PL 29/4/09
--  atom result, rop2, hPen
    atom rop2, hPen
--  integer lLifeTime   -- PL 29/4/09
--  integer idx         -- PL 29/4/09
    sequence lPenDefn,pen

    pen = getControlInfo(id,CONTROLINFO_pen)
    lPenDefn = {
                pen[PenStyle],
                pen[PenWidth],
                UseColor(pen[PenColor])
               }

    hPen = w32Func(xCreatePen, lPenDefn)

    -- select into the current device
    replaceObject(id, kPenObject, hdc, hPen, ForProgram)

    -- set the ROP2 style
    rop2 = pen[PenROP2]
    if rop2 then
        if not w32Func(xSetROP2, {hdc, rop2}) then
            warnErr("SetROP2 in createPen failed.")
        end if
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawLine(window, pStartX, pStartY, pEndX, pEndY)
--/desc Draw a line.
-- The line is drawn in the current pen color between {/i pStartX, /i pStartY}
-- and {/i pEndX, /i pEndY}.
--
-- Example:
--
--/code
--      -- draw a line in TheWindow from {10,10} to {100,100}
--      /drawLine(TheWindow, 10, 10, 100, 100)
--/endcode

global procedure drawLine(integer id, integer pStartX, integer pStartY, integer pEndX, integer pEndY)

    object hdc

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- move to the first point
    VOID = w32Func(xMoveToEx, {hdc, pStartX, pStartY, NULL})

    -- draw the line
    VOID = w32Func(xLineTo, {hdc, pEndX, pEndY})

    -- release the device context
    releaseDC(id)

end procedure

-----------------------------------------------------------------------------
global procedure createBrush(integer id, integer filled, atom hdc)

    -- create the appropriate brush for the filled shape
    -- 'filled' is the brush flag

    atom hBrush
--  integer idx     -- PL 29/4/09
    atom lColor

    if filled != 0 then
        -- create a pen
        VOID = getControlInfo(id,CONTROLINFO_pen)
        if length(VOID[PenBrushColor]) = 0 then
            lColor = colorValue(VOID[PenColor])
        else
            lColor = colorValue(VOID[PenBrushColor][1])
        end if
        hBrush = w32Func(xCreateSolidBrush, {lColor})

    else
        -- use null brush
        hBrush = NullBrushID
    end if

    -- replace the brush in the dc
    replaceObject(id, kBrushObject, hdc, hBrush, ForProgram)

end procedure
r_createBrush=routine_id("createBrush")

--/topic Graphics
--/proc drawLines(integer id, sequence coords)
--/desc Draws zero or more lines.
-- The lines are drawn between the sets of coordinates in /i coords. /n
-- This sequence can contain Colors, Points, Lines, or Rects. /n
--/li A /b Color is a single atom that is a 24-bit color value. Subsequent lines use this color.
--/li A /b Point is a 2-element sequence {X,Y} that gives the X,Y position of the end-point
-- of a line. The line is drawn to this position from the last end-point supplied,
-- or if this is the first Point specified, the current pen position for the control.
-- See /setPenPos().
--/li A /b Line is a 4-element sequence {X1,Y1,X2,Y2} that specifies the X,Y position of a line's
-- starting point and the X,Y position of its end point. The line is drawn from X1,Y1
-- to X2,Y2.
-- /li A /b Rect is a 5-element sequence {Fill, X1,Y1,X2,Y2} that specifies a rectangle.
-- The first element is w32True for a filled rectangle and w32False for an outline only. The
-- X1,Y1 is the X,Y position of the top-left corner and X2,Y2 is the X,Y position of the
-- bottom-right corner.
--
-- If no color parameters are supplied, the current pen color for the control is used.
--
-- Example:
--
--/code
--      -- draw a shape in TheWindow
--      /drawLines(TheWindow, {White,{40,0,0,80},{80,80},{40,0},
--                              Blue,{40,5,0,85},{80,85},{40,5}
--                             })
--/endcode
global procedure drawLines(integer id, sequence coords)
    integer x1, y1,
            x2, y2

-- PL 29/4/09
--  object hdc, result
    object hdc

    -- Initialize them to improbable values.
    x2 = -987654321
    y2 = -987654321

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    if length(coords) > 0 and not atom(coords[1]) then
        -- Make sure we have a pen to start with.
        createPen(id, hdc)
    end if

    x1 = getControlInfo(id,CONTROLINFO_x)
    y1 = getControlInfo(id,CONTROLINFO_y)

    for i = 1 to length(coords) do
        if atom(coords[i]) then
            call_proc(r_setPenColor,{id, coords[i]})
            createPen(id, hdc)

        elsif length(coords[i]) = 5 then
            createBrush(id, coords[i][1], hdc)
            x1 = coords[i][2]
            y1 = coords[i][3]
            x2 = coords[i][4]
            y2 = coords[i][5]
            VOID = w32Func(xRectangle, {hdc, x1, y1, x2, y2})

        elsif length(coords[i]) = 4 then
            x1 = coords[i][1]
            y1 = coords[i][2]
            x2 = coords[i][3]
            y2 = coords[i][4]
            -- move to the first point
            VOID = w32Func(xMoveToEx, {hdc, x1, y1, NULL})

            -- draw the line
            VOID = w32Func(xLineTo, {hdc, x2, y2})

        elsif length(coords[i]) = 2 then
            if x2 != -987654321 or y2 != -987654321 then
                x1 = x2
                y1 = y2
            end if
            x2 = coords[i][1]
            y2 = coords[i][2]

            -- move to the first point
            VOID = w32Func(xMoveToEx, {hdc, x1, y1, NULL})

            -- draw the line
            VOID = w32Func(xLineTo, {hdc, x2, y2})
        end if
    end for

    -- release the device context
    releaseDC(id)

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawRectangle(window, filled, x1, y1, x2, y2)
--/desc Draw a rectangle.
-- Draws the rectangle in the current pen color from {/i x1, /i y1}
-- to {/i x2, /i y2}. If /i filled is true, the rectangle is filled
-- in the current pen color.
--
-- Example:
--
--/code
--      -- draw a filled green rectangle in TheWindow
--      /setPenColor(TheWindow, Green)
--      /drawRectangle(TheWindow, w32True, 10, 10, 100, 100)
--/endcode
global procedure drawRectangle(integer id, integer filled,
                    integer x1, integer y1,
                    integer x2, integer y2)

    -- draw a rectangle
    atom hdc
--  atom lErr   -- PL 29/4/09

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- create the brush
    createBrush(id, filled, hdc)

    -- call Rectangle
    VOID = w32Func(xRectangle, {hdc, x1, y1, x2, y2})

    -- release the device context
    releaseDC(id)
end procedure
r_drawRectangle = routine_id("drawRectangle")

-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawRoundRect(window, filled, x1, y1, x2, y2, xc, yc)
--/desc Draw a rounded rectangle.
-- Draws the rounded rectangle in the current pen color. The upper left of the carved 
-- out rectangle is at {/i x1, /i y1}, and its lower right corner at
-- to {/i x2, /i y2}. The ellipse corner width and height are specified
-- in /i xc and /i yc. If /i filled is true, the rectangle is filled
-- in the current pen color.
--
-- Example:
--
--/code
--      -- draw a filled blue round rectangle in TheWindow
--      /setPenColor(TheWindow, Green)
--      /drawRoundRect(TheWindow, w32True, 10, 10, 100, 100, 5, 5)
--/endcode

global procedure drawRoundRect(integer id, integer filled,
                    integer x1, integer y1,
                    integer x2, integer y2,
                    integer xc, integer yc)

    -- draw a rounded rectangle
    -- xc = ellipse corner width
    -- yc = ellipse corner height
    atom hdc

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- create the brush
    createBrush(id, filled, hdc)

    -- call RoundRect
    VOID = w32Func(xRoundRect, {hdc, x1, y1, x2, y2, xc, yc})

    -- release the device context
    releaseDC(id)
end procedure



-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawEllipse(window, filled, x1, y1, x2, y2)
--/desc Draw an ellipse.
-- Draws the ellipse in the current pen color within the rectangle
-- bounded by {/i x1, /i y1} and {/i x2, /i y2}. If /i filled
-- is true, the ellipse is filled in the current pen color.
--
-- Example:
--
--/code
--      -- draw a black ellipse in TheWindow
--      /setPenColor(TheWindow, Black)
--      /drawEllipse(TheWindow, w32True, 10, 10, 100, 100)
--/endcode

global procedure drawEllipse(integer id, integer filled,
                    integer x1, integer y1,
                    integer x2, integer y2)

    -- draw an ellipse
    atom hdc

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- create the brush
    createBrush(id, filled, hdc)

    -- call Ellipse
    VOID = w32Func(xEllipse, {hdc, x1, y1, x2, y2})

    -- release the device context
    releaseDC(id)

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawArc(window, filled, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd)
--/desc Draw an arc.
-- Draws the arc in the current pen color. The arc's bounding rectangle
-- is defined as {/i x1, /i y1} to {/i x2, /i y2}. If /i filled
-- is true, the ellipse is filled in the current pen color.
--
-- The arc is defined by the intersection between the radial start point
-- and radial end point. The radial start point is a line running from
-- the center of the bounding rectangle to {/i xStart, /i yStart}, and
-- radial end point by a line running from the center of the bounding
-- rectangle to {/i xEnd, /i yEnd}.
--
-- If /i filled is true, the arc will be filled.
--
-- Example:
--
--/code
--      -- draw a bright cyan filled arc in TheWindow
--      /setPenColor(TheWindow, BrightCyan)
--      /drawArc(TheWindow,
--                  w32True,           -- filled
--                  1, 1,           -- upper left boundary
--                  100, 100,       -- lower right boundary
--                  49, 1,          -- top center of rectangle
--                  100, 49)        -- right center of rectangle
--/endcode

global procedure drawArc(integer id, integer filled,
                    integer x1, integer y1,
                    integer x2, integer y2,
                    integer xStart, integer yStart,
                    integer xEnd, integer yEnd)

    -- draw an arc
    -- xStart, yStart: start of arc; on imaginary line from center of arc
    -- xEnd, yEnd    : end of arc; on imaginary line from center of arc
    atom hdc

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- create the brush
    createBrush(id, filled, hdc)

    -- call Arc
    VOID = w32Func(xArc, {hdc, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd})

    -- release the device context
    releaseDC(id)

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawChord(window, filled, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd)
--/desc Draw a chord.
-- Draws the chord in the current pen color.
--
-- A /i chord is a region bounded by the intersection of an ellipse and a
-- line segment. The ellipse is bounding rectangle is defined
-- {/i x1, /i y1} to {/i x2, /i y2}.  If /i filled is true, the
-- chord is filled in the current pen color.
--
-- The chord is defined by the intersection between the radial start point
-- and radial end point. The radial start point is a line running from
-- the center of the bounding rectangle to {/i xStart, /i yStart}, and
-- radial end point by a line running from the center of the bounding
-- rectangle to {/i xEnd, /i yEnd}.
--
-- If /i filled is true, the chord will be filled.
--
-- Example:
--
--/code
--      -- draw a yellow chord in TheWindow
--      /setPenColor(TheWindow, Yellow)
--      /drawChord(TheWindow,
--                  w32True,           -- filled
--                  1, 1,           -- upper left boundary
--                  100, 100,       -- lower right boundary
--                  49, 1,          -- top center of rectangle
--                  100, 49)        -- right center of rectangle
--/endcode

global procedure drawChord(integer id, integer filled,
                    integer x1, integer y1,
                    integer x2, integer y2,
                    integer xStart, integer yStart,
                    integer xEnd, integer yEnd)

    -- draw an chord
    -- xStart, yStart: start of arc; on imaginary line from center of arc
    -- xEnd, yEnd    : end of arc; on imaginary line from center of arc
    atom hdc

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- create the brush
    createBrush(id, filled, hdc)

    -- call Chord
    VOID = w32Func(xChord, {hdc, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd})

    -- release the device context
    releaseDC(id)

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawPie(window, filled, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd)
--/desc Draw a pie slice.
-- Draws the pie slice in the current pen color. The bounding rectangle
-- is defined as {/i x1, /i y1} to {/i x2, /i y2}. If /i filled
-- is true, the slice is filled in the current pen color.

--
-- The curve start and end points are defined by the intersection between
-- the radial start point and radial end point. The radial start point is
-- a line running from the center of the bounding rectangle to {
--  /i xStart, /i yStart}, and radial end point by a line running from
-- the center of the bounding rectangle to {/i xEnd, /i yEnd}.
--
-- If /i filled is true, the pie will be filled.
--
-- Example:
--
--/code
--      -- draw a blue filled arc in TheWindow
--      /setPenColor(TheWindow, Blue)
--      /drawPie(TheWindow,
--                  w32True,           -- filled
--                  1, 1,           -- upper left boundary
--                  100, 100,       -- lower right boundary
--                  49, 1,          -- top center of rectangle
--                  100, 49)        -- right center of rectangle
--/endcode

global procedure drawPie(integer id, integer filled,
                    integer x1, integer y1,
                    integer x2, integer y2,
                    integer xStart, integer yStart,
                    integer xEnd, integer yEnd)

    -- draw a pie slice
    -- xStart, yStart: start of arc; on line from center of arc
    -- xEnd, yEnd    : end of arc; on line from center of arc
    atom hdc

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- create the brush
    createBrush(id, filled, hdc)

    -- call DrawPie
    VOID = w32Func(xPie, {hdc, x1, y1, x2, y2, xStart, yStart, xEnd, yEnd})

    -- release the device context
    releaseDC(id)

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawPolygon(integer id, integer filled, sequence points)
--/desc Draw a polygon.
-- Draws the polygon in /i id in the current pen color using /i points.
-- If i/ filled is true, the polygon will be filled.
--
-- /i points is either a set of two-element co-ordinates or a list of alternating
-- x,y coordinates.
--
-- Example:
--
--/code
--      -- draw a blue filled triangle in TheWindow
--      sequence points
--
--      -- define the points
--      points = {{10, 10},
--                {80, 40},
--                {40, 80}}
--
--      -- alternative method to define the points
--      points = {10, 10,
--                80, 40,
--                40, 80}
--      -- set pen color
--      /setPenColor(TheWindow, Blue)
--
--      -- draw a filled polygon using the points
--      /drawPolygon(TheWindow, w32True, points)
--/endcode

global procedure drawPolygon(integer id, integer filled, sequence points)

    -- draw a polygon
    integer count, offset
    atom hdc, address

    -- count of points
    count = length(points)
    if count = 0 then
        return
    end if

    if atom(points[1]) then
        -- Allocate room for points
        address = w32acquire_mem(0, count * 4)
        poke4(address, points)
        count /= 2
    else
        -- Allocate room for points
        address = w32acquire_mem(0, count * 4 * 2)
        -- poke the points
        offset = address
        for i = 1 to count do

            -- x,y point
            poke4(offset, points[i])
            -- increment offset
            offset += 8

        end for
    end if

    -- get the device context
    hdc = getDC(id)

    -- create a pen
    createPen(id, hdc)

    -- create the brush
    createBrush(id, filled, hdc)

    -- call Polygon
    VOID =  w32Func(xPolygon, {hdc, address, count})

    -- release the device context
    releaseDC(id)

    -- release the memory
    w32release_mem(address)

end procedure

------------------------------------------------------------------------------
function loadBitmapFromFile2(sequence fileName)

    -- alternate version of loadBitmapFromFile
    -- this should work for NT and other versions not
    -- supporting LoadImage's load from file option.
    --
    -- this version is called if the default version fails

    atom        bmFile, bmInfoHeader, bmBits, bmColors, hdc, hDib
    integer     hFile, fSize, byte
--  sequence    info    -- PL 29/4/09


    hFile = w32FileOpen(fileName, "rb")
    if hFile = -1 then
        -- warning
        warnErr(sprintf("Unable to open '%s', in ReadDIB", {fileName}))
        return NULL
    end if

    -- Get the file size
    VOID = seek(hFile, -1)
    fSize = where(hFile)
    VOID = seek(hFile, 0)

    -- read the whole file
    bmFile = w32acquire_mem(0, fSize)
    for i = 0 to fSize-1 do

        -- get a byte from the file
        byte = getc(hFile)

        -- eof?
        if byte = -1 then

            -- Free memory
            w32release_mem(bmFile)

            -- warning
            warnErr(sprintf("Early EOF in '%s', in ReadDIB", {fileName}))

            -- return failure
            return NULL

        else
            -- poke into structure
            poke(bmFile+i, byte)
        end if

    end for


    -- check header
    if compare(w32fetch(bmFile, bfType), "BM") != 0 then
        close(hFile)
        w32release_mem(bmFile)
        -- warning
        warnErr(sprintf("'%s' not a bitmap file, in ReadDIB", {fileName}))
        return NULL
    end if

    -- check header size against file size
    if w32fetch(bmFile, bfSize) != fSize then
        -- warning
        warnErr(sprintf("Bitmap '%s' is corrupt, in ReadDIB", {fileName}))
        -- correct header in memory
        w32store(bmFile, bfSize, fSize)
    end if

    -- address of BitmapInfoHeader
    bmInfoHeader = bmFile + SIZEOF_BITMAPFILEHEADER

    -- offset to bitmap data
    bmBits = bmFile + w32fetch(bmFile, bfOffBits)

    -- address of color information
    bmColors = bmInfoHeader + SIZEOF_BITMAPINFOHEADER

    -- Get the screen's device context.
    hdc = getDC(Screen)

    -- Create the DIB.
    hDib = w32Func(xCreateDIBitmap,{
                                    hdc,                -- handle to device context
                                    w32address(bmInfoHeader, bmiHeader), -- pointer to BITMAPINFOHEADER
                                    CBM_INIT,           -- initialization flag
                                    bmBits,             -- address of initialization data
                                    bmInfoHeader,       -- pointer to color data
                                    DIB_RGB_COLORS})    -- colors are RGB tuples

    -- release the screen dc
    releaseDC(Screen)

    -- Free memory
    w32release_mem(bmFile)

    return hDib

end function



-----------------------------------------------------------------------------
--/topic Graphics
--/func loadBitmapFromFile(file name)
--/desc Loads a bitmap file.
--/ret Win32 handle of bitmap, or /b Null if an error occured.
-- /b Note: The name /i bitmap is a bit confusing; it should be more
-- properly called /i loadDIBFromFile. At some point, the graphic
-- routines need to be renamed in a more consistant manner.
--
-- Example:
--
--/code
--          -- load a bitmap, and display in window
--          atom hBitmap
--
--          -- load the bitmap
--          hBitmap = /loadBitmapFromFile("graphic.bmp")
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap(theWindow, hBitmap, 1, 1)
--
--/endcode

global function loadBitmapFromFile(sequence fName)

    -- loads a bitmap, returns the handle
    atom hImage
    atom lImageType
    integer lObjectType


    -- load it
    lImageType = IMAGE_BITMAP
    lObjectType = kBitmapObject
    fName = w32FindFile(fName)
    if match(".ico", lower(fName)) = length(fName) - 3 then
        lImageType = IMAGE_ICON
        lObjectType = kIconObject
    end if

    hImage = w32Func(xLoadImage,
                     {NULL, fName, lImageType, 0, 0, LR_LOADFROMFILE})

    -- success?
    if hImage = NULL then
        -- try using alternate version
        hImage = loadBitmapFromFile2(fName)
        -- failed again?
        if hImage = NULL then
            warnErr("LoadImage in loadBitmapFrom File failed.")
        end if
    end if

    trackObject({-1, lObjectType}, hImage, ForProgram)

    return hImage

end function
r_loadBitmapFromFile = routine_id("loadBitmapFromFile")
                


-----------------------------------------------------------------------------
--/topic Graphics
--/proc drawBitmap(window, DIB handle, x, y)
--/desc Draws /i DIB (device independant bitmap) in /i window at {/i x, /i y}.
-- /b Note: The term /i bitmap is inconsistant; I expect to be renaming
-- these routines in the future.
--
-- Example:
--
--/code
--          -- load a bitmap, and display in window
--          atom hBitmap
--
--          -- load the bitmap
--          hBitmap = /loadBitmapFromFile("graphic.bmp")
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap(theWindow, hBitmap, 1, 1)
--
--/endcode

global procedure drawBitmap(integer id, object bitmap,
                integer xStart, integer yStart)

    -- Draw a bitmap onto the requested device
    atom lTargetDC, lSourceDC, lImageHandle
    atom mset, bm, ptSize, ptOrg
    atom lPrevBmp

    mset    = w32new_memset()
    bm      = w32acquire_mem(mset, SIZEOF_BITMAP)
    ptSize  = w32acquire_mem(mset, SIZEOF_POINT)
    ptOrg   = w32acquire_mem(mset, SIZEOF_POINT)


    -- need to load the bitmap?
    lImageHandle = 0
    if w32string(bitmap) then
        -- passed a file name
        lImageHandle = loadBitmapFromFile(bitmap)

    elsif atom(bitmap) then
        lImageHandle = w32Func(xGetObjectType, {bitmap})
        if lImageHandle = 0 or lImageHandle = OBJ_BITMAP then
            -- passed handle
            lImageHandle = bitmap
        end if
    end if

    -- get the dimensions of the bitmap
    if not w32Func(xGetObject, {lImageHandle, SIZEOF_BITMAP, bm}) then
        warnErr("drawBitmap:GetObject failed.")
        w32release_mem(mset)
        return
    end if


    -- get the DC of the destination
    lTargetDC = getDC(id)

    -- create a memory device context based on the destination
    lSourceDC = w32Func(xCreateCompatibleDC, {lTargetDC})
    if lSourceDC = NULL then
        warnErr("drawBitmap:CreateCompatibleDC failed.")
        releaseDC(id)
        w32release_mem(mset)
        return
    end if

    -- select the bitmap into it
    lPrevBmp = w32Func(xSelectObject, {lSourceDC, lImageHandle})

    -- set mapping mode to same as destination
    VOID = w32Func(xSetMapMode, {lSourceDC, w32Func(xGetMapMode, {lTargetDC})})

    -- move the size into the point structure ptSize (logical coordinates)
    w32store(ptSize, ptX, w32fetch(bm, bmWidth))
    w32store(ptSize, ptY, w32fetch(bm, bmHeight))
    VOID = w32Func(xDPtoLP, {lTargetDC, ptSize, 1})

    -- get the origin of the bitmap (logical coordinates)
    w32store(ptOrg, ptX, 0)
    w32store(ptOrg, ptY, 0)
    VOID = w32Func(xDPtoLP, {lTargetDC, ptOrg, 1})

    -- copy bitmap to device context
    VOID = w32Func(xBitBlt, {
                             lTargetDC, xStart, yStart,
                             w32fetch(ptSize, ptX), w32fetch(ptSize, ptY),
                             lSourceDC,
                             w32fetch(ptOrg, ptX), w32fetch(ptOrg, ptY),
                             SRCCOPY})

    -- release the device context
    VOID = w32Func(xSelectObject, {lSourceDC, lPrevBmp})
    VOID = w32Func(xDeleteDC, {lSourceDC})

    -- cleanup
    releaseDC(id)
    w32release_mem(mset)

end procedure



-----------------------------------------------------------------------------
function codeToBytes(sequence bits)
    -- Convert a sequence of text into bytes
    -- This is a support routine for createMonochromeBitmap
    -- Ex:  "1,1,1,1,1,1,1,1,0,0"
    --      --> {#FF, #00}

    integer byte, extra
    sequence slice, bytes

    -- add extra bits: must be multiple of 16
    extra = remainder(length(bits), 16)
    if extra then
        bits = bits & repeat(1, 16-extra)
    end if

    -- convert bits to bytes
    bytes = {}

    for i = 1 to length(bits) by 8 do
        -- get an 8 bit slice
        slice = bits[i..i+7]
        -- reverse it for conversion
        slice = reverse(slice)
        -- convert bits to a byte
        byte = bits_to_int(slice)
        -- add to list
        bytes = append(bytes, byte)
    end for
    return bytes
end function


-- NEW! 0.43 removed global
function createBitmap(sequence s)
    -- build a monochrome bitmap from text

    integer wide, high
    atom bitmapData, hBitmap
    sequence data

    -- get the size
    wide = length(s[1])
    high = length(s)


    -- build the data
    data = {}
    for i = 1 to length(s) do
        data = data & codeToBytes(s[i])
    end for

    -- poke the bitmap into memory
    bitmapData = w32acquire_mem(0, length(data))
    poke(bitmapData, data)

    -- create a bitmap
    hBitmap = w32Func(xCreateBitmap, {wide, high, 1, 1, bitmapData})

    if hBitmap = 0 then
        warnErr("CreateBitmap failed.")
    end if

    -- track resource for length of program
    trackObject({-1,kBitmapObject}, hBitmap, ForProgram)

    -- release memory
    w32release_mem(bitmapData)

    return hBitmap

end function



-----------------------------------------------------------------------------
--/topic Graphics
--/func textToBitmap(text)
--/desc Converts a sequence of text into a monochrome bitmap.
--/ret Handle to Win32 bitmap, or /b Null on an error.
-- Spaces are converted to White pixels; all other characters are
-- converted to Black pixels.
--
-- /b Note: This routine should probably be deprecated, or at least
--          renames.
--
-- Example:
--
--/code
--          -- create a bitmap, and display it
--          atom hBitmap
--          sequence image
--
--          -- the image
--          image = {   " xxxxxx ",
--                      "x      x",
--                      "x x  x x",
--                      "x      x",
--                      "x x  x x",
--                      "x x  x x",
--                      "x xxxx x",
--                      " xxxxxx ",
--
--
--          -- create the bitmap
--          hBitmap = /textToBitmap(image)
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap(theWindow, hBitmap, 1, 1)
--
--/endcode

global function textToBitmap(sequence s)

    -- build a monochrome bitmap from text

    -- all spaces become 1 and all non-spaces become 0.
--/**/  s = sq_eq(s,' ')    --/* Phix
        s = ( s = ' ' )     --  RDS */

        -- create the bitmap
        return createBitmap(s)

end function

-----------------------------------------------------------------------------
function packScanLine(sequence pal, sequence pixels, integer bitsPer)
    -- convert a scanline of data into a packed scanline
-- PL 29/4/09
--  integer fill, bytes, byte, at, perByte, pixtemp
    integer fill, bytes, at, pixtemp
    sequence packed

-- NEW! 0.43 handled 24 bits
    if bitsPer = 24 then
        -- bytes in packed array
        bytes = length(pixels) * 3

        -- packed pixels
        packed = repeat(0, bytes)

        -- 3 byte triplet; blue, green, red
        at = 1
        for i = 1 to bytes/3 do
            pixtemp = pixels[i] + 1
            packed[at]   = pal[ pixtemp ][3]
            packed[at+1] = pal[ pixtemp ][2]
            packed[at+2] = pal[ pixtemp ][1]
            -- move to start of next triplet
            at += 3
        end for

-- NEW! 0.43 changed >= to =
    elsif bitsPer = 8 then -- 1:1
        packed = pixels

    elsif bitsPer = 4 then -- 4:1

        -- pad to even length
        pixels = pixels & repeat(0, 1)  ---- 3

        -- bytes in packed array
        bytes = floor(length(pixels)/2)  ---- 4

        -- packed pixels
        packed = repeat(0, bytes)

        -- 4 bits per; 2 numbers per byte
        at = 1
        for i = 1 to bytes*2 by 2 do  ---- 4

            -- build a byte
            packed[at] = (pixels[i] * 16) + pixels[i+1]

            -- move to start of next byte
            at = at + 1

        end for

    elsif bitsPer = 1 then -- 8:1

        -- pad to even length
        pixels = pixels & repeat(0, 7)

        -- bytes in packed array
        bytes = floor(length(pixels)/8)

        -- packed pixels
        packed = repeat(0, bytes)

        -- 1 bits per; 8 numbers per byte
        at = 1
        for i = 1 to bytes*8 by 8 do

            -- build a byte
            packed[at] =  (pixels[i] *  128)
                          + (pixels[i+1] * 64)
                          + (pixels[i+2] * 32)
                          + (pixels[i+3] * 16)
                          + (pixels[i+4] * 8)
                          + (pixels[i+5] * 4)
                          + (pixels[i+6] * 2)
                          +  pixels[i+7]

            -- move to next byte
            at = at + 1

        end for

    end if

    -- scanline needs to fall on an long boundary (4 bytes)
    fill = remainder(length(packed), 4)
    if fill then
        packed = packed & repeat(0, 4-fill)
    end if

    return packed

end function


-----------------------------------------------------------------------------
--/topic Graphics
--/func createDIB(data)
--/ret Handle to Win32 bitmap, or /b Null on an error.
--/desc Converts a Euphoria bitmap format into a Win32 bitmap.
-- The data is in the form {pal, data}.
--
-- You only need to supply as many palette entries that are actually
-- used by the image. Pixel indexes into the palette start at 0 (to be
-- compatible with how Euphoria uses bitmaps)
--
-- Palette entries are color tuples in the form {r, g, b}, with each
-- color value ranging from 0 to 255.
--
-- Example:
--
--/code
--          -- create a bitmap, and display it
--          atom hBitmap
--          sequence pixels, pal
--
--          -- the pixels data
--          pixels = {
--              {0,0,0,0},      -- scan line 1
--              {0,1,1,0},      -- scan line 2
--              {0,1,1,0},      -- scan line 3
--              {0,0,0,0}}      -- scan line 4
--
--          -- the pal data (color tuples)
--          pal = {
--                {255, 0, 0},  -- color 0 is bright red
--                {0, 0, 255}}  -- color 1 is bright blue
--
--          -- create the DIB
--          hBitmap = /createDIB({Pal, Pixels})
--
--          -- display the bitmap in TheWindow at {1,1}
--          /drawBitmap(theWindow, hBitmap, 1, 1)
--/endcode

-- NEW! 0.41 now is passed a Euphoria bitmap
global function createDIB(sequence euBmp)

    -- create a DIB (bitmap) from pixels and palette
    -- note that the sequence of pixels is *zero* based.

-- PL 29/4/09
--  integer colors, palSize, headerSize, bitsPer, h, w, fill
    integer colors, palSize, headerSize, bitsPer, h, w
    sequence pal, pixels
    atom memBitmapInfo, memBits, at, hdc, hDIB, mset

    mset = w32new_memset()
    -- get values
    pal = euBmp[1]
    pixels = euBmp[2]

    -- number of colors
    colors = length(pal)

    -- palette and packing size
    if colors <= 2 then
        palSize = 2
        bitsPer = 1
    elsif colors <= 16 then
        palSize = 16
        bitsPer = 4
    elsif colors <= 256 then
        palSize = 256
        bitsPer = 8

    elsif colors <= 16777216 then
        palSize = colors
        bitsPer = 24
    end if

    -- size of bitmap
    w = length(pixels[1])
    h = length(pixels)

    -- calculate the size of the BITMAPINFO header
    headerSize = SIZEOF_BITMAPINFOHEADER + (SIZEOF_RGBQUAD * palSize)

    -- Allocate memory for DIB
    memBitmapInfo = w32acquire_mem(mset,headerSize)
    w32set_memory(memBitmapInfo, ID_BITMAPINFOHEADER,
                  {SIZEOF_BITMAPINFOHEADER,w, -h, 1, bitsPer,0,0,0,0,colors,0})
    -- at this stage, the palette hasn't been allocated yet

    -- pack the pixels
    for i = 1 to h do
        pixels[i] = packScanLine(pal, pixels[i], bitsPer)
    end for

    -- get bytes per scanline
    w = length(pixels[1])

    -- Allocate storage
    memBits = w32acquire_mem(mset, h * w)

    -- copy pixels to memory
    at = memBits
    for i = 1 to h do
        poke(at, pixels[i])
        at = at + w
    end for

    -- get the address of the first rgb tuple
    at = w32address(memBitmapInfo, bmiColors)

    -- copy the pal to memory
    for i = 1 to colors do

        -- store values
        w32store(at, rgbRed, pal[i][1])
        w32store(at, rgbGreen, pal[i][2])
        w32store(at, rgbBlue, pal[i][3])
        w32store(at, rgbReserved, 0)
        

        -- move to next quad
        at += SIZEOF_RGBQUAD

    end for

    -- Get the screen's device context.
    hdc = getDC(Screen)

    -- Create the DIB.
    hDIB = w32Func(xCreateDIBitmap, {
                                     hdc,
                                     w32address(memBitmapInfo, bmiHeader),
                                     CBM_INIT,
                                     memBits,
                                     memBitmapInfo,
                                     DIB_RGB_COLORS})


    -- release the screen dc
    releaseDC(Screen)

    -- Free memory
    w32release_mem(mset)

    trackObject({-1,kBitmapObject}, hDIB, ForProgram)

    return hDIB


end function


-----------------------------------------------------------------------------
--/topic System Attributes
--/func loadIconFromFile(object iconfile)
--/desc Get an icon from a file.
--/ret ATOM: A handle to an icon
-- /i iconfile is the name of an icon file. This can be a ICO, EXE,
-- or DLL file. However, this will only fetch the first icon in that file. Some
-- icon files can contain multiple icons. To use one of the other icons in a
-- multi-icon file, you need to use the syntax {filename, icon#}. The /icon# is the
-- number of the icon to use. The first icon is 1, the second is 2, etc...
--
-- Example:
--
--/code
--      -- get the icon from a file
--      hIcon = loadIconFromFile("euphoria.ico")
--
--      -- get the 3rd icon from a file
--      hIcon = loadIconFromFile({"applib.ico", 3})
--/endcode

global function loadIconFromFile(object icon)
    atom handle
    integer lIconNum

    -- is the icon a string (pathname) or a constant?
    if sequence(icon) then
        lIconNum = 0
        if length(icon) = 2 and sequence(icon[1]) then
            lIconNum = icon[2]-1
            icon = icon[1]
        end if
        -- get the icon handle
        icon = w32FindFile(icon)
        handle = w32Func(xExtractIcon, {instance(), icon, lIconNum})
        trackObject({-1,kIconObject}, handle, ForProgram)
    else
        handle = 0
    end if

    return handle
end function
r_loadIconFromFile = routine_id("loadIconFromFile")

-----------------------------------------------------------------------------
--/topic Values
--/proc setIcon(integer id, object icon)
--/desc Assign an icon to /i object.
-- /i id can be one of the following:
--
-- /li /Window
-- /li /Icon
-- /li /PictureButton
-- /li /TogglePicture
--
-- /i icon can represent a file name, a handle to an icon, or a predefined system
-- icon code. /n
--
-- To use an icon handle, you need to first get the handle using some other
-- method (eg /loadIconFromFile) and pass it to this routine as a
-- sequence that only contains the handle. For example:  /b"{hIcon}" /n
--
-- To use a system icon, you need to specify one of the names: /n
--<ul>
--/li IDI_APPLICATION
--/li IDI_HAND
--/li IDI_QUESTION
--/li IDI_EXCLAMATION
--/li IDI_ASTERISK
--/li IDI_WINLOGO
--</ul>
--
-- To use an icon from a file, just supply the file name. This can be a ICO, EXE,
-- or DLL file. However, this will only fetch the first icon in that file. Some
-- icon files can contain multiple icons. To use one of the other icons in a
-- multi-icon file, you need to use the syntax {filename, icon#}. The /icon# is the
-- number of the icon to use. The first icon is 1, the second is 2, etc...
--
-- Example:
--
--/code
--      -- assign an icon to the window
--      setIcon(TheWindow, "euphoria.ico")
--
--      -- assign the third icon to a button
--      setIcon(pBtnStop, {"applib.ico", 3})
--
--      -- Use a icon handle
--      hIcon = /loadIconFromFile({"applib.ico", 2})
--      setIcon(pBtnGo, {hIcon})
--
--      -- Use a system icon
--      setIcon(bBtnErr, IDI_ERROR)
--
--/endcode

global procedure setIcon(integer id, object icon)
    -- assign an icon to an window
    -- Credit: Pete Eberlein

-- PL 29/4/09
--  atom szFile, handle, pstr
atom handle
integer lIconNum

    -- is the icon a string (pathname) or a constant?
    if sequence(icon) then
        if length(icon)=1 and atom(icon[1]) then
            handle = icon[1]
        else
            lIconNum = 0
            if length(icon)=2 and sequence(icon[1]) then
                lIconNum = icon[2]-1
                icon = icon[1]
            end if
            -- get the icon handle
            icon = w32FindFile(icon)
            handle = w32Func(xExtractIcon, {getHandle(id), icon, lIconNum})
        end if
    elsif getControlInfo(id,CONTROLINFO_class) = WINDOW then
        handle = icon

    elsif find(icon, WinIcons) then
        -- use LoadIcon to load a Windows icon resource
        handle = w32Func(xLoadIcon, {NULL, icon})

    else
        handle = icon

    end if

    VOID = getControlInfo(id,CONTROLINFO_classinfo)
    if and_bits(VOID[5], w32PictCtrl) != 0 then
        VOID = sendMessage(id, BM_SETIMAGE, IMAGE_ICON, handle)

    elsif getControlInfo(id,CONTROLINFO_class) = WINDOW then
        -- WM_SETICON associates an icon with a window
        VOID = sendMessage(id, WM_SETICON, ICON_BIG, handle)
        VOID = sendMessage(id, WM_SETICON, ICON_SMALL, handle)

    else
        -- STM_SETICON associates an icon with a control
        VOID = sendMessage(id, STM_SETICON, handle, 0)
    end if

end procedure
r_setIcon = routine_id("setIcon")


-----------------------------------------------------------------------------
--/topic Values
--/proc setBitmap(integer Object, object Bitmap)
--/desc Assign an bitmap to /i Object.
-- /i Object can be one of the following:
--
-- /li /Bitmap
-- /li /PictureButton
-- /li /TogglePicture
--
-- If /i Bitmap is a sequence, it will be assumed to be the name of an
-- bitmap file, and Win32Lib will attempt to load the bitmap.
--
-- Otherwise, /i bitmap is assumed to be the handle of a bitmap.
--
-- Example:
--
--/code
--          -- assign a bitmap to the picture button
--          /setBitmap(PictureButton1, "close.bmp")
--/endcode

global procedure setBitmap(integer id, object bitmap)

    -- assign an bitmap to a control
    -- Credit: Pete Eberlein
--  atom pstr   -- PL 29/4/09
    atom lImageType
    atom lMsgCode
    sequence lTrackingDetails


    -- is it a constant, or a file path?
    if sequence(bitmap) then
        -- it's a pathname. use LOADFROMFILE.
        bitmap = call_func(r_loadBitmapFromFile,{bitmap})

    elsif bitmap = 0 then
        return
    end if

    lTrackingDetails = getTrackedObject(bitmap)
    if length(lTrackingDetails) > 0 then
        if lTrackingDetails[ResObjType] = kBitmapObject then
            lImageType = IMAGE_BITMAP
        else
            lImageType = IMAGE_ICON
        end if
    else
        lImageType = IMAGE_BITMAP
    end if

    VOID = getControlInfo(id,CONTROLINFO_classinfo)
    if and_bits(VOID[5], w32PictCtrl) != 0 then
        lMsgCode= BM_SETIMAGE
    else
        lMsgCode = STM_SETIMAGE
    end if

    VOID = sendMessage(id, lMsgCode,  lImageType, bitmap)

end procedure
r_setBitmap = routine_id("setBitmap")

-----------------------------------------------------------------------------
--/topic Graphics
--/func split_rgb(object pColor)
--/desc Convert a color into a {red, green, blue}.
--/ret Sequence: 3-element {RED, GREEN, BLUE}
-- Converts the color value into its component colors.
--
-- Example:
-- /code
--      -- get the colors got a pixel
--      RGB = split_rgb(getPixel(myBMP,4,7))
--      RGB = split_rgb("BrightCyan")
--      RGB = split_rgb(COLOR_BUTTONFACE)
--      RGB = split_rgb(Magenta)
-- /endcode
atom gColors gColors = w32acquire_mem(-2, 4)
global function split_rgb(object pColor)
    poke4(gColors, colorValue(pColor))
    return peek({gColors,3})
end function


-----------------------------------------------------------------------------
--/topic Graphics
--/func copyToBitmapFile(window, fileName, x1, y1, x2, y2)
--/desc Copies image from /i window to file /i fileName.
--/ret Returns 0 if succeeds.
--
-- /i x1 and /i y1 refer to the top left pixel corner of the image,
-- and /i x2 and /i y2 refer to the bottom right corner of the image.
--
-- There are a number of caveats:
--
-- /li It uses /getPixel , so it's slow.
-- /li It uses /b save_bitmap, so it's currently limited to 256 colors.
-- The error codes are the also the same as those returned by /b save_bitmap.
--
-- Example:
--
--/code
--          -- save {0,0} {100,100} on the screen to a file
--          /copyToBitmapFile(Screen, "screen.bmp", 0, 0, 100, 100)
--/endcode

global function copyToBitmapFile(integer id, sequence fileName,
    integer x1, integer y1,
    integer x2, integer y2)

-- PL 29/4/09
--  integer index, cx, cy, colors, r, g, b, row, column
    integer index, cx, cy, colors, row, column
    atom hdc, lColor
    sequence image, scanline, lPalette

    -- get DC of the control
    hdc = getDC(id)

    -- empty palette
    lPalette = {}

    -- calculate width (cx) and height (cy) of the bitmap
    cx = x2 - x1 + 1
    cy = y2 - y1 + 1

    -- empty scanline of width cx
    scanline = repeat(0, cx)

    -- empty image of height cy
    image = repeat(scanline, cy)

    -- start at row 1
    row = 1

    -- scan a cx*cy image from the window
    for y = y1 to y2 do

        -- start at column 1
        column = 1

        -- scan the x column
        for x = x1 to x2 do

            -- get the pixel
            lColor = w32Func(xGetPixel, {hdc, x, y})

            -- is it in the palette yet?
            index = find(lColor, lPalette)
            if index = 0 then

                -- save the atom in the pixel palette
                lPalette = append(lPalette, lColor)

                -- index the last palette entry
                index = length(lPalette)

            end if

            -- add the palette index to the scanline
            scanline[column] = index

            -- go to the next column
            column += 1

        end for

        -- add the scanline to the image
        image[row] = scanline

        -- go to the next row
        row += 1

    end for

    -- The indexes are zero-based
--/**/  image = sq_sub(image,1)     --/* -- Phix
    image -= 1                  --*/ -- RDS

    -- release the DC of the control
    releaseDC(id)

    -- the palette size MUST be 2, 16 or 256, or Euphoria
    -- will not save the file.
    if length(lPalette) <= 2 then
        colors = 2
    elsif length(lPalette) <= 16 then
        colors = 16
    elsif length(lPalette) <= 256 then
        colors = 256
    else
        -- error
        return BMP_INVALID_MODE
    end if

    -- Convert palette to RGB triplets
    for i = 1 to length(lPalette) do
        lPalette[i] = split_rgb(lPalette[i])
    end for

    -- pad the palette, if needed
    if length(lPalette) < colors then
        lPalette &= repeat({0,0,0}, colors - length(lPalette))
    end if

    -- write the bitmap
    return save_bitmap({lPalette, image}, fileName)

end function

-----------------------------------------------------------------------------
--/topic Graphics
--/func copyToTrueColorBitmapFile(window, fileName, x1, y1, x2, y2)
--/desc Copies image from /i window to file /i fileName.
--/ret Returns 0 if succeeds.
--
-- /i x1 and /i y1 refer to the top left pixel corner of the image,
-- and /i x2 and /i y2 refer to the bottom right corner of the image.
--
-- /b "Note 1:" It uses /getPixel , so it's slow. /n
-- /b "Note 2:" It uses the full 24-bit color range (16+ million colors). /n
--
-- Example:
--
--/code
--          -- save {0,0} {100,100} on the screen to a file
--          /copyToTrueColorBitmapFile(Screen, "screen.bmp", 0, 0, 100, 100)
--/endcode

-------------------------------
global function copyToTrueColorBitmapFile(integer id, sequence fileName, integer x1, integer y1, integer x2, integer y2)
-------------------------------
    integer fn, width, height, index, r, g, b
    atom hdc, rgb
    sequence line

    width = x2 - x1 + 1 -- calculate the width of the bitmap
    height = y2 - y1 + 1 -- calculate the height of the bitmap
    fn = w32FileOpen(fileName, "wb") -- open the file for writing
    if fn = -1 then return 1 end if -- unable to open? return 1

    line = repeat(0, floor(((24 * width) + 31)/32) * 4) -- create an empty line

    -- write the bitmap-header
    puts(fn, "BM")
    puts(fn, int_to_bytes(54 + height * length(line)))
    puts(fn, {0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0})
    puts(fn, int_to_bytes(width))
    puts(fn, int_to_bytes(height))
    puts(fn, {1, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 11, 0, 0, 64, 11, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0})

    hdc = getDC(id) -- get the device context
    for y = y2 to y1 by -1 do -- the bitmap has to be saved bottom to top
        index = 1
        for x = x1 to x2 do
            rgb = w32Func(xGetPixel,{hdc, x, y}) -- get the pixel
            r = and_bits(rgb, #FF) -- calculate r (red)
            rgb = floor(rgb/#100)
            g = and_bits(rgb, #FF) -- calculate g (green)
            b = floor(rgb/#100) -- calculate b (blue)
            line[index] = b -- each pixel is 3 bytes, each element in line is 1 byte
            index += 1 -- the color of a pixel has to be saved as #BBGGRR instead of #RRGGBB
            line[index] = g
            index += 1
            line[index] = r
            index += 1
        end for
        puts(fn, line) -- write the current line to the file
    end for
    releaseDC(id) -- release the device context
    close(fn) -- close the file
    return 0 -- return 0 if successful
end function


-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- BitBlt Support Routines

-----------------------------------------------------------------------------
--/topic Graphics
--/proc bitBlt(dst, dstX, dstY, src, srcX, srcY, wide, high, rop)
--/desc Copy image (or partial image) from source to destination.
-- The /bitBlt function can be used to rapidly copy images, or
-- portions of images.
--
-- If you want to copy the entire source image with the /b SRCCOPY
-- /b ROP code, /copyBlt does the same thing, but requires less
-- arguments.
--
-- To copy images with transparency, use /transBlt.
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i src: Image source
-- /li /i srcX: X position in source
-- /li /i srcY: Y position in source
-- /li /i wide: Width of image to copy
-- /li /i high: Height of image to copy
-- /li /i rop: Raster opeartion (ROP) code to apply
--
-- The /b ROP (raster operation) specifies how to combine the source with
-- the destination. The codes are:
--
-- /li /b SrcCopy     dest = source
-- /li /b SrcPaint    dest = source OR dest
-- /li /b SrcAnd      dest = source AND dest
-- /li /b SrcInvert   dest = source XOR dest
-- /li /b SrcErase    dest = source AND (NOT dest)
-- /li /b NotSrcCopy  dest = (NOT source)
-- /li /b NotSrcErase dest = (NOT src) AND (NOT dest)
-- /li /b MergeCopy   dest = (source AND pattern)
-- /li /b MergePaint  dest = (NOT source) OR dest
-- /li /b PatCopy     dest = pattern
-- /li /b PatPaint    dest = dest OR (pattern OR (NOT source))
-- /li /b PatInvert   dest = pattern XOR dest
-- /li /b DstInvert   dest = (NOT dest)
-- /li /b Blackness   dest = BLACK
-- /li /b Whiteness   dest = WHITE
--
-- /b Note: The coordinates are relative to zero.
--
--/b Note: The destination and source can be the same control.
--
-- Example:
--/code
--          -- draw a bitmap in a window
--          atom hDIB
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile("lizard.bmp")
--
--          -- copy 40x40 portion of source image to destination
--          /bitBlt(TheWindow,  -- copy to TheWindow
--                  10, 10,     -- put at {10,10} in TheWindow
--                  hDIB,        -- copy from loaded bitmap
--                  0, 0        -- upper left hand corner is {0,0}
--                  40, 40,     -- copy a 40x40 pixel portion
--                  SRCCOPY)    -- replace destination with image
--/endcode

global procedure bitBlt(atom dst, integer dstX, integer dstY,
                atom src, integer srcX, integer srcY,
                integer wide, integer high,
                integer rop)


    -- wrapper to bitblt

    -- copy portion of window into bitmap
    atom srcDC, dstDC

    -- get the DCs
    srcDC = getDC(src)
    dstDC = getDC(dst)


    -- copy area, ignoring any errors.
    VOID = w32Func(xBitBlt, {
                             dstDC, dstX, dstY,
                             wide, high,
                             srcDC,
                             srcX, srcY,
                             rop})

    -- release the DCs
    releaseDC(dst)
    releaseDC(src)

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc copyBlt(dst, dstX, dstY, src)
--/desc Copy full image from source to destination.
-- If you only want to copy a portion of the source or need to combine
-- the source and destination, use /bitBlt.
--
-- To copy images with transparency, use /transBlt.
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i src: Image source
--
--
-- /b Note: At the moment, the coordinates are zero relative; this will
--          be changed in later releases.
-- Example:
--/code
--          -- draw a bitmap in a window
--          atom hDIB
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile("shuttle.bmp")
--
--          -- copy the entire image to TheWindow
--          /copyBlt(TheWindow, 10, 10, hDib)
--/endcode

global procedure copyBlt(atom dst, integer x, integer y, atom src)

    -- copy entire destination to source
    sequence size
                     
    -- get the size of the pixmap
    size = call_func(r_getCtlSize,{src})

    -- bitblt with scrCopy
    bitBlt(dst, x, y, src, 0, 0, size[1], size[2], SRCCOPY)

end procedure

atom transColor    -- transparent color
sequence transTuple

global function getTransparentColor()
    return transColor
end function

-----------------------------------------------------------------------------
--/topic Graphics
--/proc transBlt(dst, dstX, dstY, src)
--/desc Copy full image from source to destination, with transparency.
-- TransBlt is typically used for displaying non-rectangular bitmaps -
-- /i sprites. It is a computationally expensive operation; if there
-- is no transparency in your image, you should use /copyBlt or /bitBlt
-- instead.
--
-- By default, /transBlt assumes that the color {255,0,255} is to be
-- treated as transparent. To change the transparent color, use
-- /setTransparentColor.
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i src: Image source
--
-- /b Note: At the moment, the coordinates are zero relative; this will
--          be changed in later releases.
-- Example:
--/code
--          -- draw a bitmap using transparency
--          atom hDIB
--          sequence size
--
--          -- get the size of TheWindow
--          size = getCtlSize(TheWindow)
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile("shuttle.bmp")
--
--          -- treat the color BrightWhite as transparent
--          /setTransparentColor(BrightWhite)
--
--          -- copy multiple images to TheWindow
--          for i = 1 to 20 do
--              /transBlt(TheWindow,    -- destination
--                  rand(size[1]),      -- x position
--                  rand(size[2]),      -- y position
--                  hDib)               -- image to copy
--          end for
--/endcode
global procedure transBlt(atom dest, integer destX, integer destY, object src)

    integer
    wide,           -- width of the source bitmap
    high,            -- height of the source bitmap
    xoff, yoff

    atom
    srcBmp,         -- source bitmap
    destDC,         -- device context of destination
    srcDC,          -- source bitmap (color)
    saveDC,         -- backup copy of source bitmap
    maskDC,         -- mask bitmap (monochrome)
    invDC,          -- inverse of mask bitmap (monochrome)
    resultDC,       -- combination of source bitmap & background
    hResultBmp,     -- Bitmap combination of source & background
    hSaveBmp,       -- Bitmap stores backup copy of source bitmap
    hMaskBmp,       -- Bitmap stores mask (monochrome)
    hInvBmp,        -- Bitmap holds inverse of mask (monochrome)
    hSrcPrevBmp,    -- Holds previous bitmap in source DC
    hSavePrevBmp,   -- Holds previous bitmap in saved DC
    hDestPrevBmp,   -- Holds previous bitmap in destination DC
    hMaskPrevBmp,   -- Holds previous bitmap in the mask DC
    hInvPrevBmp,    -- Holds previous bitmap in inverted mask DC
    OrigColor       -- Holds original background color from source DC

    sequence
    size            -- holder for size of source

    -- is the source a bitmap, or a pixmap?
    if sequence(src) then
        xoff = src[2]
        yoff = src[3]
        wide = src[4]
        high = src[5]
        src = src[1]
    else
        wide = -1
        high = -1
        xoff = 0
        yoff = 0
    end if

    if not validId(src) then
        -- assume it's a bitmap
        srcBmp = src

    elsif getControlInfo(src,CONTROLINFO_class) = PIXMAP then

        -- get the handle
        srcBmp = getHandle(src)

        -- release resources for it
        releaseResourcesForID({src, ForPaint})

    else
        -- no good
        warnErr("Source to transBlt must be bitmap or Pixmap")
        return

    end if

    if wide = -1 then
        -- get the size of the bitmap
        size = call_func(r_getCtlSize,{srcBmp})

        -- get the values from the bitmap
        wide = size[1]
        high = size[2]
    end if
    -- get the DC of the destintation
    destDC = getDC(dest)

    -- create DCs to hold temporary information
    srcDC = w32Func(xCreateCompatibleDC, {destDC})
    saveDC = w32Func(xCreateCompatibleDC, {destDC})
    maskDC = w32Func(xCreateCompatibleDC, {destDC})
    invDC = w32Func(xCreateCompatibleDC, {destDC})
    resultDC = w32Func(xCreateCompatibleDC, {destDC})

    -- Create monochrome bitmaps for the mask-related bitmaps:
    hMaskBmp = w32Func(xCreateBitmap, {wide, high, 1, 1, 0})
    hInvBmp = w32Func(xCreateBitmap, {wide, high, 1, 1, 0})

    -- Create color bitmaps for final result & stored copy of source
    hResultBmp = w32Func(xCreateCompatibleBitmap, {destDC, wide, high})
    hSaveBmp = w32Func(xCreateCompatibleBitmap, {destDC, wide, high})

    -- select the bitmaps into the DCs
    hSrcPrevBmp = w32Func(xSelectObject, {srcDC, srcBmp})
    hSavePrevBmp = w32Func(xSelectObject, {saveDC, hSaveBmp})
    hMaskPrevBmp = w32Func(xSelectObject, {maskDC, hMaskBmp})
    hInvPrevBmp = w32Func(xSelectObject, {invDC, hInvBmp})
    hDestPrevBmp = w32Func(xSelectObject, {resultDC, hResultBmp})

    -- Make backup of source bitmap to restore later
    VOID = w32Func(xBitBlt, {saveDC, 0, 0, wide, high, srcDC, xoff, yoff, SRCCOPY})

    -- Create mask: set background color of source to transparent color.
    OrigColor = w32Func(xSetBkColor, {srcDC, UseColor(transColor)})
    VOID = w32Func(xBitBlt, {maskDC, 0, 0, wide, high, srcDC, xoff, yoff, SRCCOPY})

    -- restore the original color
    VOID = w32Func(xSetBkColor, {srcDC, OrigColor})

    -- Create inverse of mask to AND w/ source & combine w/ background.
    VOID = w32Func(xBitBlt, {invDC, 0, 0, wide, high, maskDC, 0, 0, NOTSRCCOPY})

    -- Copy background bitmap to result & create final transparent bitmap
    VOID = w32Func(xBitBlt, {resultDC, 0, 0, wide, high, destDC, destX, destY, SRCCOPY})

    -- AND mask bitmap w/ result DC to punch hole in the background by
    -- painting black area for non-transparent portion of source bitmap.
    VOID = w32Func(xBitBlt, {resultDC, 0, 0, wide, high, maskDC, 0, 0, SRCAND})

    -- AND inverse mask w/ source bitmap to turn off bits associated
    -- with transparent area of source bitmap by making it black.
    VOID = w32Func(xBitBlt, {srcDC, xoff, yoff, wide, high, invDC, 0, 0, SRCAND})

    -- XOR result w/ source bitmap to make background show through.
    VOID = w32Func(xBitBlt, {resultDC, 0, 0, wide, high, srcDC, xoff, yoff, SRCPAINT})

    -- Display transparent bitmap on backgrnd
    VOID = w32Func(xBitBlt, {destDC, destX, destY, wide, high, resultDC, 0, 0, SRCCOPY})

    -- Restore backup of bitmap.
    VOID = w32Func(xBitBlt, {srcDC, xoff, yoff, wide, high, saveDC, 0, 0, SRCCOPY})

    -- select the original objects
    VOID = w32Func(xSelectObject, {srcDC, hSrcPrevBmp})
    VOID = w32Func(xSelectObject, {saveDC, hSavePrevBmp})
    VOID = w32Func(xSelectObject, {resultDC, hDestPrevBmp})
    VOID = w32Func(xSelectObject, {maskDC, hMaskPrevBmp})
    VOID = w32Func(xSelectObject, {invDC, hInvPrevBmp})

    -- remove system resources
    VOID = w32Func(xDeleteObject, {hSaveBmp})
    VOID = w32Func(xDeleteObject, {hMaskBmp})
    VOID = w32Func(xDeleteObject, {hInvBmp})
    VOID = w32Func(xDeleteObject, {hResultBmp})
    VOID = w32Func(xDeleteDC, {srcDC})
    VOID = w32Func(xDeleteDC, {saveDC})
    VOID = w32Func(xDeleteDC, {invDC})
    VOID = w32Func(xDeleteDC, {maskDC})
    VOID = w32Func(xDeleteDC, {resultDC})

    -- release the DC of the destintation
    releaseDC(dest)

end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc stretchBlt(dst, dstX, dstY, dstWide, dstHigh, src, srcX, srcY, srcWide, srcHigh, rop)
--/desc Copy image (or partial image) from source to destination, changing its size as you go.
-- This is used to resize an image and/or create mirror images. If the dstWide and dstHigh
-- parameters are negative, the image is also reflected in the X-axis and Y-axis
-- respectively.
--
--
-- The arguments are:
--
-- /li /i dst: Image destination
-- /li /i dstX: X position in destination
-- /li /i dstY: Y position in destination
-- /li /i dstWide: Width of resulting image
-- /li /i dstHigh: Height of resulting image
-- /li /i src: Image source
-- /li /i srcX: X position in source
-- /li /i srcY: Y position in source
-- /li /i srcWide: Width of image to copy
-- /li /i srcHigh: Height of image to copy
-- /li /i rop: Raster opeartion (ROP) code to apply
--
-- The /b ROP (raster operation) specifies how to combine the source with
-- the destination. The codes are:
--
-- /li /b SrcCopy     dest = source
-- /li /b SrcPaint    dest = source OR dest
-- /li /b SrcAnd      dest = source AND dest
-- /li /b SrcInvert   dest = source XOR dest
-- /li /b SrcErase    dest = source AND (NOT dest)
-- /li /b NotSrcCopy  dest = (NOT source)
-- /li /b NotSrcErase dest = (NOT src) AND (NOT dest)
-- /li /b MergeCopy   dest = (source AND pattern)
-- /li /b MergePaint  dest = (NOT source) OR dest
-- /li /b PatCopy     dest = pattern
-- /li /b PatPaint    dest = dest OR (pattern OR (NOT source))
-- /li /b PatInvert   dest = pattern XOR dest
-- /li /b DstInvert   dest = (NOT dest)
-- /li /b Blackness   dest = BLACK
-- /li /b Whiteness   dest = WHITE
--
-- /b Note: The coordinates are relative to zero.
--
--/b Note: The destination and source can be the same control.
--
-- Example:
--/code
--          -- draw a bitmap in a window
--          atom hDIB
--
--          -- load the bitmap
--          hDib = /loadBitmapFromFile("lizard.bmp")
--
--          -- copy 40x40 portion of source image to destination
--          /stretchBlt(TheWindow,  -- copy to TheWindow
--                  10, 10,     -- put at {10,10} in TheWindow
--                  100, 50,    -- cause it to be this size
--                  hDIB,       -- copy from loaded bitmap
--                  0, 0        -- upper left hand corner is {0,0}
--                  40, 40,     -- copy a 40x40 pixel portion
--                  SRCCOPY)    -- replace destination with image
--/endcode

global procedure stretchBlt(
            atom dst, integer dstX, integer dstY,
                integer dstWide, integer dstHigh,
                atom src, integer srcX, integer srcY,
                integer srcWide, integer srcHigh,
                integer rop)


    -- wrapper to bitblt

    -- copy portion of window into bitmap
    atom srcDC, dstDC

    -- get the DCs
    srcDC = getDC(src)
    dstDC = getDC(dst)


    -- copy area, ignoring any errors.
    VOID = w32Func(xStretchBlt, {
                                 dstDC, dstX, dstY, dstWide, dstHigh,
                                 srcDC, srcX, srcY, srcWide, srcHigh,
                                 rop})

    -- release the DCs
    releaseDC(dst)
    releaseDC(src)

end procedure

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

integer xpmErrFlag          -- on error, sets code

global constant
    XPM_OK          = 0,    -- no error
    XPM_ERR_FILE    = -1,   -- file related error
    XPM_ERR_COLORS  = -2,   -- too many colors in bitmap
    XPM_ERR_HEADER  = -3,   -- error in XPM header
    XPM_ERR_COLOR   = -4    -- couldn't translate color code

constant XPM_CODES =
    " .+@#$%&*=-;>,')!~{]^/(_:<[}|1234567890" &
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

-----------------------------------------------------------------------------
--/topic XPM
--/proc setTransparentColor(object color)
--/desc Defines what the transparent color is to be.
-- The /i color can be an rgb atom, or a sequence in the form {r,g,b}.
--
-- The default color is {255,0,255} (a light pink).
--
-- For routines that create XPMs, this means that the color specified
-- in the XPM as /i None are rendered using this color.
--
-- The /transBlt routine uses this value to determine what color /i not
-- to render on the destination.
--
-- This routine can also be used to make the transparent color of XPMs
-- match the system color of buttons. This is useful for /PictureButtons.
--
--/code
--          -- set transparent colors to match button face color
--          setTransparentColor(/getSysColor(COLOR_BTNFACE))
--/endcode

global procedure setTransparentColor(object pColor)
    transColor = colorValue(pColor)
    transTuple = split_rgb(transColor)
end procedure

-- set default transparent color
setTransparentColor(BrightMagenta)

-- NEW! 0.42
------------------------------------------------------------------------------
--/topic XPM
--/func createXpm(filename, euphoria bitmap)
--/desc Creates an XPM file from a Euphoria bitmap.
--/ret (INTEGER) Status code.
-- Status codes:
--
-- /li /b XPM_OK. File created successfully
-- /li /b XPM_ERR_FILE: File related error
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap


global function createXpm(sequence outFile, sequence euBmp)

    -- create an XPM file from a euphoria bitmap
    integer
    handle,     -- out file handle
    index,      -- convenience counter
    colors,     -- count of colors used in XPM
    charsWide,  -- chars wide of encoding
    at          -- index
    sequence
    bmp,        -- bitmap portion of data
    pal,        -- pal portion of data
    code,       -- reassignment of codes to palette indexes
    encode      -- encoding of color codes

    -- get values
    pal = euBmp[1]
    bmp = euBmp[2]

    -- build a set of 'used' flags for the palette
    code = repeat(0, length(pal))

    -- scan through the bitmap, and
    colors = 0
    for i = 1 to length(bmp) do
        for j = 1 to length(bmp[i])  do

            -- get palette index
            index = bmp[i][j]+1

            -- already assigned an index?
            if not code[ index ] then

                -- increment index count
                colors = colors + 1

                -- assign an index
                code[ index ] = colors

            end if
        end for
    end for

    -- need 1 or 2 byte codes?
    if colors > length(XPM_CODES) then

        -- need to construct 2 byte codes
        charsWide = 2

        -- initialize sequence
        encode = repeat(0, colors)

        -- index
        at = 1

        for i = 1 to length(XPM_CODES) do
            for j = 2 to length(XPM_CODES) do

                -- build a two byte code
                encode[at] = XPM_CODES[i] & XPM_CODES[j]

                -- increment
                at += 1

                -- filled?
                if at > colors then
                    -- leave inner loop
                    exit
                end if

            end for

            -- filled?
            if at > colors then
                -- leave outer loop
                exit
            end if

        end for

    else

        -- 1 byte coding
        charsWide = 1

        -- list of codes is subset of
        encode = XPM_CODES[1..colors]

    end if

    -- open the file
    handle = w32FileOpen(outFile, "w")
    if handle = -1 then
        -- error opening file
        return XPM_ERR_FILE
    end if

    -- header
    puts(handle, "/* XPM */\n")
    puts(handle, "static char * xpm[] = {\n")

    -- values: width, height, colors, code width
    printf(handle, "\"%d %d %d %d\",\n",
           {length(bmp[1]), length(bmp), colors, charsWide})

    -- the color tuples
    for i = 1 to length(code) do
        -- color used?
        if code[i] then
            -- create an entry
            printf(handle, "\"%s        c #%02x%02x%02x\",\n",
                   {encode[code[i]]} & pal[i])
        end if

    end for

    -- build the xpm data
    for i = 1 to length(bmp) do
        -- "
        puts(handle, "\"")
        for j = 1 to length(bmp[i]) do

            -- get palette index
            index = bmp[i][j]+1

            -- write the code out
            puts(handle, encode[code[index]])

        end for

        -- end of line
        if i = length(bmp) then
            -- "};
            puts(handle, "\"};\n")
        else
            -- ",
            puts(handle, "\",\n")
        end if

    end for

    -- close the file
    close(handle)

    -- return success
    return XPM_OK

end function


------------------------------------------------------------------------------
--/topic XPM
--/func createXpmFromBmpFile(filename, euphoria bitmap)
--/desc Creates an XPM file from a bitmap file.
--/ret (INTEGER) Status code.
-- Status codes:
--
-- /li /b XPM_OK. File created successfully
-- /li /b XPM_ERR_FILE: File related error
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap

-- NEW! 0.43 renamed
global function createXpmFromBmpFile(sequence inFile, sequence outFile)

    -- create an XPM file from a bitmap file
    object bmp

    -- read the bitmap in
    bmp = read_bitmap(inFile)
    if integer(bmp) then
        -- file error
        return XPM_ERR_FILE
    end if

    -- convert to xpm
    return createXpm(outFile, bmp)

end function


------------------------------------------------------------------------------
function convertToWords(sequence s)
    -- convert s into space delimited words
    sequence word, words

    words = {}
    word = ""
    s = s & " "
    for i = 1 to length(s) do
        if s[i] = ' ' then
            if length(word) then
                words = append(words, word)
                word = ""
            end if
        else
            word = word & s[i]
        end if
    end for

    return words

end function


-- NEW! 0.42
------------------------------------------------------------------------------
function xpmConvertToNumber(sequence s)

    -- convert a string to a number
    -- this should only return positive numbers,
    -- -1 indicates error

    s = value(s)
    if s[1] != GET_SUCCESS then
        -- flag error
        xpmErrFlag = 1
    end if

    return s[2]

end function

------------------------------------------------------------------------------
function xpmConvertToRGB(sequence s)

    -- convert a color code string into an {r,g,b} tuple
    integer r,g,b

    if s[1] = '#' then
        -- hex tuple: #rrggbb

        -- upper case
        s = upper(s)

        r = xpmConvertToNumber(s[1..3])
        g = xpmConvertToNumber("#" & s[4..5])
        b = xpmConvertToNumber("#" & s[6..7])

        -- return tuple
        return {r,g,b}

    elsif equal(s, "None") then

        -- set color to clear
        return transTuple

    end if

    -- unable to convert color
    xpmErrFlag = 1

    return {0,0,0}

end function


-- NEW! 0.42 added for XPM support
-- NEW! 0.43 renamed
------------------------------------------------------------------------------
--/topic XPM
--/func xpmToEuBmp(xpm)
--/desc Convert XPM data into a standard Euphoria bitmap.
--/ret A Euphoria bitmap in a sequence. On failure, an integer error code.
-- The error codes are:
--
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap
-- /li /b XPM_ERR_HEADER: Error in XPM header
-- /li /b XPM_ERR_COLOR: Couldn't translate color code


global function xpmToEuBmp(sequence xpm)


    integer
    line,           -- current line in file
    at,             -- used to find positions in strings
    bitsWide,       -- width of the xpm
    bitsTall,       -- height of the xpm
    colors,         -- colors in the xpm
    codeWide        -- width of the color code

    sequence
    colorCode,      -- text of color code
    colorRGB,       -- palette of tuples
    bits            -- bits of image

    object
    data            -- generic bucket


    -- clear error flag
    xpmErrFlag = 0

    -- extract the values: "<wide> <tall> <colors> <bytes per color>"
    data = convertToWords(xpm[1])
    bitsWide = xpmConvertToNumber(data[1])
    bitsTall = xpmConvertToNumber(data[2])
    colors   = xpmConvertToNumber(data[3])
    codeWide = xpmConvertToNumber(data[4])

    -- error?
    if xpmErrFlag then
        -- error in header
        return XPM_ERR_HEADER
    end if

    -- create a palatte and data
    colorCode  = repeat("", colors)
    colorRGB   = repeat({}, colors)

    -- start of data
    line = 2

    -- read the color data
    for i = 1 to colors do

        -- extract the color code
        colorCode[i] = xpm[line][1..codeWide]

        -- get a line
        data = xpm[line]

        -- seek to the color
        data = data[3..length(data)]
        at = match("c ", data)
        if at = 0 then
            -- badly formed color definition
            return XPM_ERR_COLOR
        end if

        -- extract the color code
        data = data[at+2..length(data)]

        -- convert to an {r,g,b} code
        colorRGB[i] = xpmConvertToRGB(data)

        -- increment line
        line += 1

    end for

    -- check condition
    if xpmErrFlag then
        -- error in call to colorRGB
        return XPM_ERR_COLOR
    end if

    -- create data area
    bits = repeat(repeat(0, bitsWide), bitsTall)

    -- convert the text into indexes
    for i = 1 to bitsTall do

        -- get a line
        data = xpm[line]

        -- convert to w32lookup
        at = 0

        for j = 1 to length(data) by codeWide do

            -- move 1 pixel at a time
            at += 1

            -- find the position, subtract to make base zero
            bits[i][at] = find(data[j..j+codeWide-1], colorCode) - 1

        end for

        -- read the next line
        line += 1

    end for

    return {colorRGB, bits}

end function


------------------------------------------------------------------------------
global function readXpm(sequence fName)

    -- read a file into a sequence
    -- removes line feeds

    integer handle, at
    sequence file
    object data

    file = {}

    -- open the file
    handle = w32FileOpen(fName, "r")
    if handle = -1 then
    -- error opening file
        return XPM_ERR_FILE
    end if

    -- check header
    data = gets(handle)
    if not match("/* XPM */", data) then
        return XPM_ERR_HEADER
    end if

    -- read to eof
    while 1 do

        -- read a line
        data = gets(handle)

        -- eof?
        if integer(data) then exit end if

        -- remove line feed, if any
        if data[length(data)] = '\n' then
            data = data[1..length(data)-1]
        end if

        -- blank line?
        if length(data) = 0 then
            -- ignore

        -- not quoted?
        elsif data[1] != '"' then
            -- ignore

        else

            -- first quote
            at = find('"', data)
            data = data[at+1..length(data)]

            -- last quote
            at = find('"', data)
            data = data[1..at-1]

            -- add to file
            file = append(file, data)

        end if

    end while

    -- close the file
    close(handle)

    -- reads an XPM from disk, returns bitmap
    return xpmToEuBmp(file)

end function

-----------------------------------------------------------------------------
------------------------------------------------------------------------------
--/topic XPM
--/func xpmToPixmap(xpm)
--/desc Create a /Pixmap from XPM data.
--
--/ret A Euphoria bitmap, or an integer error code.
-- The error codes are:
--
-- /li /b XPM_ERR_COLORS: Too many colors in bitmap
-- /li /b XPM_ERR_HEADER: Error in XPM header
-- /li /b XPM_ERR_COLOR: Couldn't translate color code


global function xpmToPixmap(sequence xpm)

    -- convert xpm to bmp, and then to dib
    atom pixmap
    sequence bmp

-- NEW! 0.43 function renamed
    -- convert xpm to bmp using the TransRGB for the transparent color
    bmp = xpmToEuBmp(xpm)

    -- create an empty pixmap
    pixmap = call_func(r_createEx,{Pixmap, "", 0, 0, 0, 0, 0, 0, 0})

    -- create a dib, and assign it to the pixmap
    call_proc(r_setPixmap, {pixmap, createDIB(bmp)})

    return pixmap

end function

global atom w32Seed w32Seed = #30000000 + rand(#FFFFFFF)
--/topic Miscellaneous
--/func getRandInt(atom pMin, atom pMax)
--/desc Gets a random number.
--/ret ATOM: A random number from /i Min and /i Max inclusive.
--This uses the cryptographic routines built into Windows. It gathers entropy from
--various sources in between calls and thus you cannot seed this generator
--to produce a known stream of numbers.
--
-- /i pMin and pMax are limited to 32-bit integer values.
--
--Example:
--/code
--      integer guess
--      Get a random number between 4 and 19.
--      guess = getRandInt(4, 19)
--/endcode

global function getRandInt(atom pMin, atom pMax)
    atom lRC
    atom lMem
    atom lValue
    atom lRange
    atom lMax
    sequence lProviders
    atom lTempSeed
    integer intSeed

    lProviders = {
                  PROV_RSA_FULL        ,
                  PROV_RSA_SIG         ,
                  PROV_DSS             ,
                  PROV_FORTEZZA        ,
                  PROV_MS_EXCHANGE     ,
                  PROV_SSL             ,
                  PROV_RSA_SCHANNEL    ,
                  PROV_DSS_DH          ,
                  PROV_EC_ECDSA_SIG    ,
                  PROV_EC_ECNRA_SIG    ,
                  PROV_EC_ECDSA_FULL       ,
                  PROV_EC_ECNRA_FULL       ,
                  PROV_DH_SCHANNEL     ,
                  PROV_SPYRUS_LYNKS    ,
                  PROV_RNG             ,
                  PROV_INTEL_SEC           ,
                  PROV_REPLACE_OWF     ,
                  PROV_RSA_AES
                 }


    if vCSP = 0 then
        intSeed = remainder(w32Seed,#3FFFFFFF)+floor(w32Seed/#40000000)
        set_rand(intSeed)
        lMem = w32acquire_mem(0, 8)
        -- Locate a default crypto provider.
        for i = 1 to length(lProviders) do
            lRC = w32Func(xCryptAcquireContext, {lMem, 0, 0, lProviders[i], 0})
            if lRC != 0 then
                vCSP = peek4u(lMem)
                exit
            end if
        end for
        if vCSP = 0 then
            -- There are no crypto providers.
            vCSP  = -1
        end if

    elsif vCSP= -1 then
        lTempSeed = rand(w32Seed) * w32Seed
        lTempSeed -= floor(lTempSeed/#3FFFFFFF)*#3FFFFFFF
        w32Seed = remainder(xor_bits(w32Seed, lTempSeed), #100000000)
        set_rand(w32Seed)
    else
        lMem = w32acquire_mem(0, 4)

    end if

    if vCSP > 0 then
        poke4(lMem, w32Seed)
        lRC = w32Func(xCryptGenRandom, {vCSP, 4, lMem})
        lMax = #100000000
        lValue = peek4u(lMem)
        w32release_mem(lMem)
    else
        lMax = #100000000
        lValue = w32rand32(lMax)
    end if


    lRange= pMax - pMin  + 1
    if lRange < 0 then
        lRange = -lRange
    end if
    lValue = pMin + floor((lValue/lMax) * lRange)

    return lValue
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setDefaultFont(id)
--/desc Set the font to default system font.
--
-- Example:
--
--/code
--      -- restore MyWindow to the default font
--      /setDefaultFont(MyWindow)
--/endcode

global procedure setDefaultFont(integer id)

    -- Window fonts are set as attributes for later assignment

    resetFont(id)

    VOID = getControlInfo(id,CONTROLINFO_class)
    if VOID = WINDOW or VOID = PIXMAP then
        -- defer creation until print event

    else
        -- update immediately
        VOID = sendMessage(id, WM_SETFONT, DefaultFontID, w32True)

    end if

end procedure

--/topic RichEdit controls
--/proc printRichText(integer OutId, integer InId, integer Start, integer End, sequence Box, integer Render)
--/desc Prints some or all the contents of a rich edit control.
--/i OutId is the control Id where the text is displayed. Usually 'Printer' but can be
-- a Window or Pixmap. If not a printer, this can be used to do a print-preview display. /n
--/i InId is the RichText control /n
--/i Start is the first position in the RichEdit to start from. /n
--/i End is the last position in the RichEdit control. Use /b "-1" to include all text up
-- to the end of the control. /n
--/i Box is the area in the output control that will receive the formatted text. It is in the form
-- {Left, Top, Right, Bottom, Scale}, where /i Scale is one of ... /n
--/li w32InchScale : values are in inches
--/li w32MillScale : values are in millimeters
--/li w32PixelScale : values are in pixels
--/li w32TwipsScale : values are in twips (1/1440th of an inch)
--
--/i Render is w32True if you wish to actually output the text, w32False to format it but
-- not print it.
--
--Example:
--/code
--    if length(getPrinter()) > 0 then
--        VOID = startDoc("RichText Printer Test")
--        VOID = startPage()
--        printRichText(Printer, RE, 0, -1, {0.5, 0.5, 2.5, 3, w32InchScale}, w32True)
--        VOID = endPage()
--        VOID = endDoc()
--
--        releasePrinter()
--        repaintWindow(PPV)
--    end if
--/endcode
global procedure printRichText(integer pOutId, integer pInId, integer pStart, integer pEnd, sequence pBox, integer pRender)
    atom lFR
    atom lOldMode
    atom lIDDC
    atom lHScale
    atom lVScale

    if pOutId = Printer then
        lIDDC = printerDC
    else
        lIDDC = getDC(pOutId) 
    end if
    lOldMode = w32Func(xGetMapMode, {lIDDC})
    VOID = w32Func(xSetMapMode, {lIDDC, MM_TEXT})

    if length(pBox) = 5 then
        if pBox[5] = w32InchScale then
            -- Inches supplied
            lHScale = 1440
            lVScale = 1440

        elsif pBox[5] = w32MillScale then
            -- Millimeters supplied
            lHScale = 1440 / 24.5
            lVScale = 1440 / 24.5

        elsif pBox[5] = w32PixelScale then
            -- Pixels supplied
            lHScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSX})
            lVScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSY})

        else
            -- Twips supplied
            lHScale = 1
            lVScale = 1
        end if
    else
        -- Pixels supplied
        lHScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSX})
        lVScale = 1440 / w32Func(xGetDeviceCaps,{lIDDC, LOGPIXELSY})
    end if

    lFR = w32to_memory(0, ID_FORMATRANGE,{
                                          lIDDC, lIDDC,
                                          {floor(pBox[1]*lHScale),floor(pBox[2]*lVScale),
                                           floor(pBox[3]*lHScale),floor(pBox[4]*lVScale)},
                                          {0,0,
                                           floor(w32Func(xGetDeviceCaps,{lIDDC, HORZRES})*lHScale),
                                           floor(w32Func(xGetDeviceCaps,{lIDDC, VERTRES})*lVScale)},
                                          pStart, pEnd
                                         })

    VOID = sendMessage(pInId, EM_FORMATRANGE, pRender, lFR)

    -- Release cached formatting.
    VOID = sendMessage(pInId, EM_FORMATRANGE, 0, 0)

    w32release_mem(lFR)
    if lIDDC != printerDC then
        releaseDC(pOutId)
    end if
    VOID = w32Func(xSetMapMode, {lIDDC, lOldMode})

end procedure

global constant
    w32RP_Print     = 'P',
    w32RP_LastPage  = 'L',
    w32RP_Skip      = 'S',
    w32RP_SkipAll   = 'A',
    w32RP_Cancel    = 'C',
    w32RP_Build     = 'b',
    w32RP_Output    = 'o'

--/topic RichEdit controls
--/proc printRichTextPages(integer InId, integer pCallBack, object pUserData)
--/desc Prints the contents of a RichText control.
--/i InId is the RichText control /n
--/i pCallBack is a routine_id of a user defined function that is called before each page
-- is built and again just before each page is output. If this is not a valid routine_id
-- (eg. -1) then this routine will assume a 0.5 inch margin and print the entire RichText
-- document, using multiple pages if required. /n
--
-- The function will be passed a two parameters.
--<ul>
--/li An integer that will either have the value w32RP_Build or w32RP_Output
--/li A sequence that contains ...
--<ul>
-- /li the Page number,
-- /li the Index into the richedit control for the first element on the page,
-- /li the value -1 (for w32RP_Build) or the Index into the richedit control
-- for the last element on the page (for w32RP_Output)
--/li the Page Size in pixels {Width, Height}
--/li the /i pUserData parameter
--</ul>
--</ul>
-- When the function is called using w32RP_Build, the function must return one of ...
--/li w32RP_SkipAll ==> Do not build this page, just end the document.
--/li w32RP_Cancel ==> Do not build this page, just cancel the document.
--/li {Left, Top, Right, Bottom, Scale} ==> the area in the page that will receive the formatted text.
--
--/i Left and /i Top indicate an offset from the left and top edges of the page, respectively. /n
--/i Right and /i Bottom, if positive values are also offsets from the left and top
-- edges respectively, but if negative, they are offsets from the right and bottom
--edges. /n
--/i Scale is one of ... /n
--<ul>
--/li w32InchScale : values are in inches
--/li w32MillScale : values are in millimeters
--/li w32PixelScale : values are in pixels
--/li w32TwipsScale : values are in twips (1/1440th of an inch)
--</ul>
--
-- When the function is called using w32RP_Output, the function must return one of ...
--/li w32RP_Print ==> Print the page
--/li w32RP_LastPage ==> Print the page and then end the document.
--/li w32RP_Skip ==> Skip this page and go on to the next page.
--/li w32RP_SkipAll ==> Do not print this page or any others, just end the document.
--/li w32RP_Cancel ==> Do not print this page but cancel the document.
--
--/b Note that you need to set the Printer device context before calling this. That can be
-- done by calling getPrinter() or getPrintChoice().
--
--Example:
--/code
--    function RTPager(integer pCode, sequence pParms)
--      if pCode = w32RP_Build then
--         -- Return the printable page area
--         -- which is different for odd
--         -- and even pages.
--         if and_bits(pParms[1], 1) then
--            return {0.25, 1, -0.75, -0.5, w32InchScale}
--         else
--            return {0.75, 1, -0.25, -0.5, w32InchScale}
--         end if
--      end if
--
--      if pCode = w32RP_Output then
--          -- The page has been built with text from the richedit control, so now
--          -- I can add my own touches...
--
--         -- Display the title text on the top left corner.
--         wPuts({Printer, 0, 0}, pParms[5])
--
--          -- Display the page number on the bottom-right of the page.
--         lFooter = sprintf(" Page %d", pParms[1])
--         wPuts({Printer, lParms[4][1] -   getTextWidth(lFooter),
--                          lParms[4][2] - (getTextHeight(lFooter) * 2)}, lFooter)
--
--         -- Tell win32lib to output the page now.
--         return w32RP_Print
--      end if
--    end function
--
--    . . .
--
--    if length(getPrinter()) > 0 then
--        printRichTextPages(RE, routine_id("RTPager"), "This Is The Title")
--        releasePrinter()
--    end if
--/endcode

global procedure printRichTextPages(integer pInId, sequence pDocName, integer pCallBack, object pUserData)
    atom lFR
    atom lOldMode
    atom lHScale
    atom lVScale
--  integer lOutId      -- PL 29/4/09
    integer lStart
--  integer lEnd        -- PL 29/4/09
    object lBox
--  integer lRender     -- PL 29/4/09
    integer lPageNo
    atom lNextElem
    integer lDocStarted
    integer lTextPrinted
    integer lTextLength
    sequence lPageSizePixels
    sequence lPageSizeTwips
    integer lResponse
    sequence lPageRect

    if printerDC = 0 then
        return
    end if

    lOldMode = w32Func(xGetMapMode, {printerDC})
    if lOldMode != MM_TEXT then
        VOID = w32Func(xSetMapMode, {printerDC, MM_TEXT})
    end if

    lHScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSX})
    lVScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSY})
    lPageSizeTwips = {floor(w32Func(xGetDeviceCaps,{printerDC, HORZRES})*lHScale),
                      floor(w32Func(xGetDeviceCaps,{printerDC, VERTRES})*lVScale)
                     }
    lPageSizePixels = {w32Func(xGetDeviceCaps,{printerDC, HORZRES}) - w32Func(xGetDeviceCaps,{printerDC, PHYSICALOFFSETX}),
                       w32Func(xGetDeviceCaps,{printerDC, VERTRES}) - w32Func(xGetDeviceCaps,{printerDC, PHYSICALOFFSETY})
                      }
    lFR = w32to_memory(0, ID_FORMATRANGE,{printerDC, printerDC,{0,0,  lPageSizeTwips[1], lPageSizeTwips[2]}})

    lPageNo = 0
    lNextElem = 0
    lTextPrinted = 0
    lTextLength = sendMessage(pInId, WM_GETTEXTLENGTH, 0, 0)

    VOID = startDoc(pDocName)
    lDocStarted = w32True

    while lTextPrinted < lTextLength do
        lPageNo += 1
        lStart = lNextElem
        if pCallBack >= 0 then
            lBox = call_func(pCallBack, {w32RP_Build, {lPageNo, lStart, -1, lPageSizePixels,  pUserData}})
            if equal(lBox, w32RP_SkipAll) then
                exit
            elsif equal(lBox, w32RP_Cancel) then
                abortDoc()
                lDocStarted = w32False
                exit
            end if

        else
            lBox = {0.5, 0.5, -0.5, -0.5, w32InchScale}
        end if

        if length(lBox) = 5 then
            if lBox[5] = w32InchScale then
                -- Inches supplied
                lHScale = 1440
                lVScale = 1440

            elsif lBox[5] = w32MillScale then
                -- Millimeters supplied
                lHScale = 1440 / 24.5
                lVScale = 1440 / 24.5

            elsif lBox[5] = w32PixelScale then
                -- Pixels supplied
                lHScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSX})
                lVScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSY})

            else
                -- Twips supplied
                lHScale = 1
                lVScale = 1
            end if
        else
            -- Pixels supplied
            lHScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSX})
            lVScale = 1440 / w32Func(xGetDeviceCaps,{printerDC, LOGPIXELSY})
        end if
        lPageRect = w32fetch(lFR,FORMATRANGE_rcRect)
        lPageRect[1] = floor(lBox[1]*lHScale)
        lPageRect[2] = floor(lBox[2]*lVScale)
        if lBox[3] < 0 then
            lPageRect[3] = lPageSizeTwips[1] + floor(lBox[3]*lHScale)
        else
            lPageRect[3] = floor(lBox[3]*lHScale)
        end if

        if lBox[4] < 0 then
            lPageRect[4] = lPageSizeTwips[2] + floor(lBox[4]*lVScale)
        else
            lPageRect[4] = floor(lBox[4]*lVScale)
        end if

        w32store(lFR,FORMATRANGE_rcRect,lPageRect)
        w32store(lFR, FORMATRANGE_chrgStart, lStart)
        w32store(lFR, FORMATRANGE_chrgEnd, -1)

        if pCallBack >= 0 then
            lNextElem = sendMessage(pInId, EM_FORMATRANGE, 0, lFR)
            if lNextElem > lTextPrinted then
                lResponse = call_func(pCallBack, {w32RP_Output, {lPageNo, lStart, lNextElem-1, lPageSizePixels, pUserData}})

                if find(lResponse, {w32RP_Print, w32RP_LastPage}) then
                    VOID = startPage()
                    VOID = sendMessage(pInId, EM_DISPLAYBAND, 0, w32address(lFR, FORMATRANGE_rcRect))
                    VOID = endPage()

                    if equal(lResponse, w32RP_LastPage) then
                        -- Pretend we are at the end.
                        lNextElem = lTextLength + 1
                    end if
                end if

            elsif equal(lResponse, w32RP_Skip) then
                -- Don't bother printing it.

            elsif equal(lResponse, w32RP_SkipAll) then
                -- Pretend we are at the end.
                lNextElem = lTextLength + 1

            elsif equal(lResponse, w32RP_Cancel) then
                -- Pretend we are at the end.
                lNextElem = lTextLength + 1
                abortDoc()
                lDocStarted = w32False
            end if
        else
            -- Default is to print the page.
            lNextElem = sendMessage(pInId, EM_FORMATRANGE, 0, lFR)
            if lNextElem > lTextPrinted then
                VOID = startPage()
                VOID = sendMessage(pInId, EM_DISPLAYBAND, 0, w32address(lFR, FORMATRANGE_rcRect))
                VOID = endPage()
            end if
        end if

        if lNextElem <= lTextPrinted then
            -- Nothing happened?!
            exit
        end if

        lTextPrinted = lNextElem

    end while

    if lDocStarted = w32True then
        -- That's all folks.
        VOID = endDoc()
    end if

    -- Release cached formatting.
    VOID = sendMessage(pInId, EM_FORMATRANGE, 0, 0)

    w32release_mem(lFR)
    if lOldMode != MM_TEXT then
        VOID = w32Func(xSetMapMode, {printerDC, lOldMode})
    end if

end procedure

--/topic Mouse
--/proc restoreMousePointer(object id)
--/desc Gets back the previous pointer the mouse had before the last /setMousePointer call.
-- This restores the pointer shape for /i id by popping it from the /i id's stack. /n
-- /i id can either be a single control ID, or a sequence containing a control ID.
--You use the second form to restore the pointer for all the controls contained
-- in /i id.
--
-- Example:
--
--/code
--     -- Change mouse pointer in MyWindow to hourglass
--     /setMousePointer({MyWindow}, WaitPointer)
--     -- Do some long job...
--     . . .
--     -- Restore the previous shape.
--     /restoreMousePointer({MyWindow})
--/endcode

global procedure restoreMousePointer(object id)
    sequence lKids

    if sequence(id) then
        lKids = call_func(r_findChildren,{id[1]})
        for i = 1 to length(lKids) do
            restoreMousePointer({lKids[i][1]})
        end for

        id = id[1]
    end if

    -- set pointer style
    VOID = getControlInfo(id,CONTROLINFO_cursor)
    if length(VOID) > 1 then
        setCursorInternal(id, VOID[2..length(VOID)])
    end if

    -- Force windows to show new shape right now!

    -- Really should try to find out which ID the mouse is currently over first,
    -- and uses its pointer shape.
    VOID = w32Func(xSetCursor, {VOID[1]})
end procedure

--/topic Mouse
--/proc setMousePointer(object id, object pointer)
--/desc Set the pointer the mouse displays when in /i id.
-- This saves the current pointer for /i id by pushing it onto the /i id's stack
-- and sets the /i pointer as the new shape. You can get the previous pointer
-- shape by calling /restoreMousePointer().
--
-- /i id can either be a single control ID, or a sequence that contains a control
-- ID. You use the second form to set the pointer for all the controls contained
-- in /i id.
--
-- The initial mouse pointer displayed is the /i ArrowPointer, except
-- for /TextEdit and /MleText controls, which use the /i IBeamPointer.
--
-- The /i pointer can either be a system pointer, or one created with
-- the /createMousePointer function, or a path to .CUR or .ANI file.
--
-- System mouse pointers are:
-- /li /i ArrowPointer: Standard arrow
-- /li /i IBeamPointer: Text I-Beam
-- /li /i WaitPointer: Hourglass
-- /li /i CrossPointer: Crosshair
-- /li /i UpArrowPointer: Vertical arrow
-- /li /i SizeNWSEPointer: Double-pointed arrow pointing northwest and southeast
-- /li /i SizeNESWPointer: Double-pointed arrow pointing northeast and southwest
-- /li /i SizeWEPointer: Double-pointed arrow pointing west and east
-- /li /i SizeNSPointer: Double-pointed arrow pointing north and south
-- /li /i SizeAllPointer: Same as /i SizePointer
-- /li /i NoPointer: Slashed circle
-- /li /i AppStartingPointer: Standard arrow with small hourglass
-- /li /i IconPointer: Four-pointed arrow
-- /li /i Null: This is identical to calling /restoreMousePointer()
-- /li /i -1: This pops all pushed mouse shapes and restores the default one for /i id.
--
-- These system pointers can also be specified as a string value:
--/li    "ARROW",
--/li    "IBEAM",
--/li    "WAIT" or "HOURGLASS",
--/li    "CROSS",
--/li    "UPARROW",
--/li    "SIZENWSE",
--/li    "SIZENESW",
--/li    "SIZEWE",
--/li    "SIZENS",
--/li    "SIZEALL",
--/li    "NO" or "NOT",
--/li    "APPSTARTING",
--/li    "ICON",
--/li    "NULL",
--/li    "DEFAULT"
-- Example:
--
--/code
--     -- Change mouse pointer in MyWindow and all its child controls to hourglass
--     /setMousePointer({MyWindow}, WaitPointer)
--     -- Do some long job...
--     . . .
--     -- Restore the previous shape.
--     /restoreMousePointer({MyWindow})
--
--      /setMousePointer(ListPanel, "SpecialCursor.cur")
--      /setMousePointer({WindowX}, "hourglass")
--/endcode

constant PointerValues = {
                          ArrowPointer,
                          IBeamPointer,
                          WaitPointer,
                          WaitPointer,
                          CrossPointer,
                          UpArrowPointer,
                          SizeNWSEPointer,
                          SizeNESWPointer,
                          SizeWEPointer,
                          SizeNSPointer,
                          SizeAllPointer,
                          NoPointer,
                          NoPointer,
                          AppStartingPointer,
                          IconPointer,
                          0,
                          -1
                         }
constant PointerNames = {
                         "ARROW",
                         "IBEAM",
                         "WAIT",
                         "HOURGLASS",
                         "CROSS",
                         "UPARROW",
                         "SIZENWSE",
                         "SIZENESW",
                         "SIZEWE",
                         "SIZENS",
                         "SIZEALL",
                         "NO",
                         "NOT",
                         "APPSTARTING",
                         "ICON",
                         "NULL",
                         "DEFAULT"
                        }
global procedure setMousePointer(object id, object style)

    -- load the cursor
-- PL 29/4/09
--  atom handle, point, result
    atom handle, result
--  integer x, y    -- PL 29/4/09
    sequence lKids,lCursors

    if sequence(style) then
        result = find(upper(style), PointerNames)
        if result != 0 then
            style = PointerValues[result]
        else
            handle = w32Func(xLoadCursorFromFile, {style})
            if handle then
                trackCursor(handle)
                style = handle
            else
                warnErr(sprintf("setPointer: The cursor file '%s' didn't load.", {style}))
                return
            end if
        end if
    end if

    if equal(style, 0)  then
        restoreMousePointer(id)
        return
    end if


    if not equal(style, -1) then
        if find(style, heldCursor) then
            -- don't need to load. either null or user defined
            handle = style
        elsif find({style}, heldCursor) then
            -- don't need to load. either null or user defined
            handle = style
        else
            -- load system cursor
            handle = w32Func(xLoadCursor, {NULL, style})
            if handle = NULL then
                -- warning
                warnErr("setPointer:LoadCursor failed.")
            else
                trackCursor({handle})
            end if
        end if
    else
        handle = -1
    end if

    -- set pointer style
    if sequence(id) then
        lKids = call_func(r_findChildren,{id[1]})
        for i = 1 to length(lKids) do
            setMousePointer({lKids[i][1]}, handle)
        end for
        id = id[1]
    end if

    lCursors = getControlInfo(id,CONTROLINFO_cursor)
    if equal(style, -1) then
        lCursors = {lCursors[length(lCursors)]}
    else
        lCursors = prepend(lCursors, handle)
    end if
    setCursorInternal(id,lCursors)

    -- Force windows to show new shape right now!
    VOID = w32Func(xSetCursor, {lCursors[1]})

end procedure
r_setMousePointer = routine_id("setMousePointer")

-----------------------------------------------------------------------------
--/topic Mouse
--/func createMousePointer(hotspotX, hotspotY, image)
--/desc Create a new mouse pointer.
-- The /i hotspotX and /i hotspotY values are the "hotspot". The image is
-- a 2x2 text sequence of the pointer. Bytes are interpreted as follows:
--
--~s~s  /ff<' '> = transparent /n
--~s~s  /ff<'.'> = solid white /n
--~s~s  /ff<'x'> = solid black /n
--
-- Example:
--
--/code
--      constant PlusPointer = /createMousePointer(8, 8, {
--          "     xxxxxx      ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "xxxxxx....xxxxxx ",
--          "x..............xx",
--          "x..............xx",
--          "x..............xx",
--          "x..............xx",
--          "xxxxxx....xxxxxxx",
--          " xxxxx....xxxxxxx",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     x....xx     ",
--          "     xxxxxxx     ",
--          "      xxxxxx     "})
--
--          -- set as pointer for MyWindow
--          /setMousePointer(MyWindow, PlusPointer)
--
--/endcode

global function createMousePointer(integer x, integer y, sequence image)

    -- load the cursor
    integer cx, cy, diff
    atom andPlane, xorPlane, hCursor, mset
    sequence data, maskBits

    mset = w32new_memset()
    -- get the metrics for the cursor
    cx = w32Func(xGetSystemMetrics, {SM_CXCURSOR})
    cy = w32Func(xGetSystemMetrics, {SM_CYCURSOR})

    -- ensure image is wide enough
    diff = cx - length(image[1])
    for i = 1 to length(image) do

        -- add padding...
        image[i] &= repeat(' ', cx)

        -- trim
        image[i] = image[i][1..cx]

    end for

    -- ensure the image is tall enough
    for i = 1 to cy do
        -- add extra padding
        image = append(image, repeat(' ', cx))
    end for
    -- trim
    image = image[1..cy]

    -- create the and mask
--/**/  maskBits = sq_eq(image,' ')     --/* Phix
    maskBits = ( image = ' ' )      --  RDS */

    -- convert the bits to bytes
    data = {}
    for i = 1 to length(maskBits) do
        data = data & codeToBytes(maskBits[i])
    end for

    -- Allocate and poke the and plane data
    andPlane = w32acquire_mem(mset, length(data))
    poke(andPlane, data)

    -- create the xor mask
--/**/  maskBits = sq_eq(image,'.')     --/* Phix
    maskBits = (image = '.')        --  RDS */

    -- convert the bits to bytes
    data = {}
    for i = 1 to length(maskBits) do
        data = data & codeToBytes(maskBits[i])
    end for

    -- Allocate and poke the xor plane data
    xorPlane = w32acquire_mem(mset, length(data))
    poke(xorPlane, data)

    -- create the cursor
    hCursor = w32Func(xCreateCursor,
                      {instance(),      -- application instance
                       x, y,            -- x and y of hotspot
                       length(image),     -- cursor width
                       length(image[1]), -- cursor height
                       andPlane,
                       xorPlane})

    -- keep track of cursor
    trackCursor(hCursor)

    -- Free the data
    w32release_mem(mset)

    return hCursor

end function

global procedure updateHDCInternal(integer id,atom hdc)
    integer pos

    pos = w32findKey(id, grabbedHDC)
    if pos = 0 then
        grabbedHDC = prepend(grabbedHDC, {id,{1, hdc, 0, kDCReasonPaint}})
    else
      -- Insert the Paint hdc as the 'topmost' dc.
        grabbedHDC[pos] = {id , {1, hdc, 0, kDCReasonPaint} , grabbedHDC[pos][2]}
    end if
end procedure

global procedure releaseAllResources(integer pMode)
    integer lType

    -- Free up all resources
    VOID = detachCleanUp(r_libCleanUp)

    for i = 1 to length(getHandles()) do
        lType = getControlInfo(i,CONTROLINFO_type)
        if lType = Window then
            if getControlInfo(i,CONTROLINFO_owner) = 0 then
                call_proc(r_destroy,{i})
            end if
        elsif lType = Pixmap then
            call_proc(r_destroy,{i})
        end if
    end for

    -- for each resource
    for i = 1 to length(heldResource) do
        -- release the object and remove it from the list
        if heldResource[i][ResStatus] = 1 then
            deleteObject(heldResource[i][ResHandle])
        end if
    end for

    -- release the cursors
    for i = 1 to length(heldCursor) do
        if atom(heldCursor[i]) then
            VOID = w32Func(xDestroyCursor, {heldCursor[i]})
        end if
    end for

    heldCursor = {}

    -- Release the crypto handle.
    if vCSP != 0 then
        VOID = w32Func(xCryptReleaseContext,{vCSP, 0})
        vCSP = 0
    end if

    -- give back all memory blocks acquired.
    w32release_mem(-2)

    -- w32release_all_mem() -- obsolete

    finishAppInternal()

    if pMode = 0 then
        abortErr("") -- Force any user cleanups to run.
    end if
end procedure

----------------------------------------------------------------------------
--/topic Fonts
--/func assignFont(integer id)
--/desc Gets the device context for /i id with the current font installed.
--/ret ATOM: A Device Context (hDC)
-- This is different to the /getDC() function, which only returns the DC with
-- the default font installed. This one assigns the 'current' font to the DC.
--
--/b Note that /i id can have the form {id, DC} which allows you to pass an
-- existing DC, to which you can assign a font to. The DC passed is returned
-- by this routine. However, if /i DC is zero, a new DC is created.
--
--Example:
--/code
--    atom dc
--    dc = assignFont(myPixMap)
--    w32Proc(xTextOut,{dc, x, y, textaddr, textlen})
--    releaseDC(dc)
--/endcode
global function assignFont(object id)
--
-- set font into the hdc, using the attributes of the font
--  this is shared by wPuts, getFontSize and getTextExtent
--
atom fontID
--object result     -- PL 29/4/09
atom hdc
atom factor
object font

        if sequence(id) then
            hdc = id[2]
            id = id[1]
        else
            hdc = 0
        end if

        if hdc = 0 then
            hdc = getDC(id)
        end if

        factor = 10
        -- need to create a font based on the attributes?
        if length(ctrl_Font[id][w32FontName]) > 0 then
            font = ctrl_Font[id][w32FontSize]
            if atom(font) then
                font = floor(font*factor)
            end if
            fontID = EzCreateFont(id, hdc,           -- create font
                                  ctrl_Font[id][w32FontName],   -- font name
                                  font,
                                  0,
                                  ctrl_Font[id][w32FontAttrib], -- attributes
                                  vFontResolution, 0)
        elsif id = Printer then
            -- set to hard-coded values for default printer font.
            fontID = EzCreateFont(id, hdc, "Times New Roman", 100, 0, 0,
                                  vFontResolution, 0)

        else
            -- get the stock system font object
            fontID = DefaultFontID
        end if

        -- replace the font
        replaceObject(id, kFontObject, hdc, fontID, ForPaint)

        -- use the pen color?

        if w32Func(xSetTextColor,{hdc, UseColor(ctrl_Font[id][w32FontColor])}) = CLR_INVALID then
            -- unable to set color
            warnErr(Err_SETTEXTCOLOR)
        end if

        -- set transparent or opaque
        if not w32Func(xSetBkMode,{hdc, ctrl_Pen[id][PenBkMode]}) then
            -- unable to set mode
            warnErr(Err_SETBKMODE)
        end if

        if not w32Func(xSetBkColor,{hdc, UseColor(ctrl_Pen[id][PenBkColor])}) then
            -- unable to set mode
            warnErr(Err_SETBKCOLOR)
        end if

        return hdc
end function

-----------------------------------------------------------------------------
-- FONTS
--
-----------------------------------------------------------------------------

--/topic Fonts
--/func useLogicalResolution(integer pLogRes)
--/desc Possibly sets the flag that determines if logical font resolution is used or not.
--/ret The previous value of the flag
-- /i pLogRes is 1 to use logical resolution (initial value),
-- 0 to use physical resolution, /w32GetValue to just return the current value of the flag.
global function useLogicalResolution(integer pLogRes)
integer lOldValue

        lOldValue = vFontResolution
        vFontResolution = pLogRes

        return lOldValue
end function


-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPuts(object window, object text)
--/desc Equivalent to Euphoria's /i puts() function.
-- The /i window parameter determines what /Window will be written to. /n
-- It can be either a control id or a sequence in the form {id, X, Y} to move
-- the pen to X,Y before writing the text.
--
-- This is usually used inside an Paint event handler.
--
-- If /i text is actually a number, it will be converted to text first. The
-- /i text parameters can also be used to specify a formatting string. To do
-- so place the format string as the first element and the second element then
-- should contain a list of parameters for the format string.
--
-- It is also possible to supply a RAM address if the text is pre-stored in
-- memory rather than a sequence. To do this, you must format the second
-- parameter as {{RAMaddress, length}}
--
-- Example:
--/code
--      -- put text in a window
--      /wPuts(MyWindow, "Hello, World!")
--      /wPuts(TotalAmountFld, 1234.56)
--      /wPuts({MyWindow, 17, 5}, {"Name: %s", {firstName}})
--
--      /wPuts(MyWindow, {{hSavedText, 45}})
--/endcode

global procedure wPuts(object id, object s)
atom hdc
integer sLen

        -- Move pen first if asked.
        if sequence(id) then
            call_proc(r_setPenPos,{id[1], id[2], id[3]})
            id = id[1]
        end if

        -- Check for formatting
        if atom(s) then
            s = sprintf("%g", s)
            sLen = length(s)
        elsif length(s) = 2 and sequence(s[1]) then
            s = sprintf(s[1], s[2])
            sLen = length(s)
        elsif length(s) = 1
          and sequence(s[1])
          and length(s[1]) = 2
          and atom(s[1][1])
          and atom(s[1][2]) then
            sLen = length(s[1][2]) -- Length of RAM text
            s = s[1][1] -- RAM address of text.
        else
            sLen = length(s)
        end if

        hdc = assignFont(id)

        VOID = w32Func(xSetTextAlign,{hdc, ctrl_Text_Alignment[id]})

        -- display the text in the buffer
        w32Proc(xTextOut,{hdc,ctrl_X_Pos[id],ctrl_Y_Pos[id],s,sLen})

        releaseDC(id)
end procedure

--/topic Text
--/proc textOut(atom HDC, sequence TextDef)
--/desc Writes text to a control.
--This is a special version of /wPuts that can be faster under certain
-- circumstances. /n
-- /i HDC is the Device Context of a control and not its /b Id. This can
-- be obtained by /getDC() or /assignFont(). And must be released after
-- use. /n
-- /i TextDef is a sequence of up to 7 elements. Elements 4 thru 7 are
-- optional and can be 'omitted' by using an empty sequence for them. /n
-- The elements are ... /n
--/li pTextDefn[1]  = text string to display.
--/li pTextDefn[2]  = x (horizontal pixel position)
--/li pTextDefn[3]  = y (vertical pixel position)
--/li pTextDefn[4]  = Foregroud color
--/li pTextDefn[5]  = Background color
--/li pTextDefn[6]  = Mode (OPAQUE or TRANSPARENT)
--/li pTextDefn[7]  = Vertical Alignment with respect to character height.
-- (AlignTop, AlignBottom, AlignBaseline) /n
--
-- Example:
--/code
--      atom hdc
--      hdc = assignFont(Mypixmap)
--      H = getTextHeight(Mypixmap, "|")
--      W = 4
--      textOut(hdc,{"   Name:", W, 0 * H, Black, White, OPAQUE})
--      textOut(hdc,{"Address:", W, 1 * H})
--      textOut(hdc,{"    Age:", W, 2 * H})
--      textOut(hdc,{" Weight:", W, 3 * H})
--
--      W = getTextWidth(Mypixmap, "_") * 9
--      textOut(hdc,{NameFld, W, 0 * H, Blue, BrightWhite})
--      textOut(hdc,{AddressFld, W, 1 * H})
--      textOut(hdc,{sprintf("%d",AgeFld), W, 2 * H})
--      textOut(hdc,{sprintf("%5.2f", WeightFld), W, 3 * H})
--      releaseDC(Mypixmap)
--/endcode

global procedure textOut(atom hdc, sequence pTextDefn)


        pTextDefn &= repeat({},7)

        if atom(pTextDefn[6]) then
            VOID = w32Func(xSetBkMode, {hdc, pTextDefn[6]})
        end if

        if atom(pTextDefn[4]) then
            VOID = w32Func(xSetTextColor,{hdc, UseColor(pTextDefn[4])})
        end if

        if atom(pTextDefn[5]) then
            VOID = w32Func(xSetBkColor, {hdc, UseColor(pTextDefn[5])})
        end if

        if atom(pTextDefn[7]) then
            VOID = w32Func(xSetTextAlign,{hdc, pTextDefn[7]})
        end if

        -- display the text in the buffer
        w32Proc(xTextOut, {hdc,pTextDefn[2],pTextDefn[3],pTextDefn[1],length(pTextDefn[1])})

end procedure

-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPrintf(window, format, data)
--/desc Equivalent to Euphoria's /i printf() routine.
-- /i window specifies the /Window to receive the text. /n
-- /i window can either be a single window id, or a sequence in the form
-- {id, x, y} where /i x and /y is the pen position to write at. /n
-- This is usually used inside an Paint event handler. /n
-- Note that this does not handle NEWLINE characters, use /drawText for that.
--
--Example:
--/code
--      -- show value of a
--      /wPrintf(MyWindow, "the value of a is %d", {a})
--
--      -- Now print at pen position (5,25).
--      /wPrintf({MyWindow, 5, 25}, "Code %s", {theCode})
--/endcode

global procedure wPrintf(object id, sequence s1, object o)
        wPuts(id,sprintf(s1,o))
end procedure

integer vShowChars
    vShowChars = 0
--/topic Fonts
--/proc showChars(integer pFlag)
--/desc Determines if /wPrint displays characters or numbers
-- If /i pFlag is zero, then the /wPrint routine acts like Euphoria's
-- print command and displays normal characters as numbers in a sequence.
-- If /i pFlag is non-zero, the /wPrint command displays these characters
-- as quoted characters. /n
-- The initial setting is zero.
--
--Example
--/code
--        showChars(0)
--        wPrint(mywin, "abc") -- displays {97,98,99}
--        showChars(1)
--        wPrint(mywin, "abc") -- displays {'a','b','c'}
--/endcode

global procedure showChars(integer pFlag)
        vShowChars = (pFlag != 0)
end procedure

-----------------------------------------------------------------------------
function print_format(object o)
-- returns object formatted for wPrint
sequence s

        if integer(o) then
            -- number
            if vShowChars != 0
            and find(o,"`~!@#$%^&*()_+-={}|[]\\:\";'<>?,./" &
                     "1234567890" &
                     "abcdefghijklmnopqrstuvwxyz" &
                     "ABCDEFGHIJKLMNOPQRSTUVWXYZ") then
                return sprintf("'%s'", o)
            else
                return sprintf("%d", o)
            end if
        elsif atom(o) then
            return sprintf("%f", o)
        else
        -- list
            s = "{"
            for i=1 to length(o) do
                s = s & print_format(o[i])
                if i < length(o) then
                    s = s & ","
                end if
            end for
            s = s & "}"
            return s
        end if

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPrint(window, object)
--/desc Equivalent to Euphoria's /i print() routine.
-- /i window specifies the /Window to receive the data.
--
-- For example:
--/code
--      -- dump s to the window
--      /wPrint(MyWindow, s)
--/endcode

global procedure wPrint(integer id, object o)
-- win32 version of Euphoria's print statement
        wPuts(id, print_format(o))
end procedure


--/topic RichEdit controls
--/proc setAlignment(id, alignment)
--/desc Align text in a /RichEdit Control
-- Sets Alignment of the paragraph which includes the selection in a
-- /RichEdit control.
-- /i alignment should be one of the following values:
-- /li /b AlignLeft
-- /li /b AlignRight
-- /li /b AlignCenter
global procedure setAlignment(integer id, integer align)
atom PF

        if align = AlignLeft then
            align = PFA_LEFT
        elsif align = AlignRight then
            align = PFA_RIGHT
        else
            align = PFA_CENTER
        end if

        PF = w32to_memory(0,ID_PARAFORMAT, {PFM_ALIGNMENT, 0, 0, 0, 0, align, {}})
        VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

        w32release_mem(PF)

end procedure

--/topic RichEdit controls
--/proc setBullet(id)
-- Toggles the bulleting of the paragraph which includes the selection in a
-- /RichEdit control.
global procedure setBullet(integer id)
atom PF

        PF = w32to_memory(0,ID_PARAFORMAT, 0)

        VOID = sendMessage(id, EM_GETPARAFORMAT, 0, PF)
        w32store(PF, PARAFORMAT_wNumbering, not w32fetch(PF, PARAFORMAT_wNumbering))
        w32store(PF, PARAFORMAT_dwMask, PFM_NUMBERING)
        VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

        w32release_mem(PF)

end procedure

--/topic RichEdit controls
--/proc setIndent(id, start, right, offset)
--/desc Change indenting in a /RichEdit Control
-- Sets indenting.  If you don't want to change any of the indent modes,
-- pass it's parameter as a sequence.  All values should be in pixels.
global procedure setIndent(integer id, object start, object right, object offset)
atom PF, mask

        mask = 0

        if atom(start) then
            mask = PFM_STARTINDENT
        else
            start = 0
        end if

        if atom(right) then
            mask = or_bits(mask,PFM_RIGHTINDENT)
        else
            right = 0
        end if

        if atom(offset) then
            mask = or_bits(mask,PFM_OFFSET)
        else
            offset = 0
        end if

        PF = w32to_memory(0,ID_PARAFORMAT,{mask, 0, start, right, offset, 0, {}})

        VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

        w32release_mem(PF)

end procedure

--/topic List Control
--/proc setTabs(id, tabs)
--/desc Set/change tab stops in a /List or /SortedList Control.
-- /i tabs should be a sequence of integers. Each one is a tabstop
-- position measured in 1/4 character widths.

--/topic RichEdit controls
--/proc setTabs(id, tabs)
--/desc Change tab stops in a /RichEdit Control.
-- /i tabs should be a sequence of absolute positions for the tab stops
-- in 1/1000 of an inch.
global procedure setTabs(integer id, sequence tabs)
atom PF
atom TabArrayAddress -- address of integer array of TAB stops

        if ctrl_Type[id] = RichEdit then
            PF = w32to_memory(0,ID_PARAFORMAT,{PFM_TABSTOPS, 0, 0, 0, 0, 0, tabs})

            VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

            w32release_mem(PF)
        elsif find(ctrl_Type[id],{List, SortedList}) then
            -- Build and array of integers in memory to pass to windows
            -- w32allot bytes for each tab stop element to build a 32 bit tab array
            TabArrayAddress = w32acquire_mem(0,length(tabs)*4)
            -- poke the values into the tab array address
            poke4(TabArrayAddress,tabs)
            -- send a windows message to the list box to set tabstops
            VOID = sendMessage(id,LB_SETTABSTOPS,length(tabs),TabArrayAddress)

            w32release_mem(TabArrayAddress)

        end if

end procedure

--/topic Attributes
--/func setErasePolicy(integer id, integer Flag)
--/desc Possibly sets and gets the Background Erasing policy for the control /i id
--/ret INTEGER: The current policy value.
--/i id is a control id. /n
--If /i Flag is negative (eg. -1) then this routine just returns the current
-- policy value. If it is zero it sets the policy that the window's background
-- is automatically cleared to the default color whenever it needs erasing. If
-- it is positive (eg. 1) then the application must take responsibility of
-- erasing the background during a Paint event.
--
--Example:
--/code
--      integer oldval
--      oldval = setErasePolicy(TickerWin, 1)
--/endcode
global function setErasePolicy(integer id, integer pFlag)
integer lCurrentValue

        lCurrentValue = ctrl_Erase[id]
        if pFlag >= 0 then
            ctrl_Erase[id] = (pFlag != 0)
        end if

        return lCurrentValue
end function

global constant
    findDown = FR_DOWN,
    findWholeWord = FR_WHOLEWORD,
    findMatchCase = FR_MATCHCASE

--/topic RichEdit controls
--/func findText(id, text, range, flags)
--/desc Find text in a /RichEdit Control.
--/ret Index where text begins, or zero if not found
-- /i range should be a sequence containing the range of text you'd
-- like to search within the /RichEdit, or an atom, if you want to search
-- through all of the text.
-- /i flags can be a combination of the folowing:
-- /li /b findWholeWord
-- /li /b findMatchCase
-- /li /b findDown = Current to DocEnd, else Current to DocStart
--
-- Note that this function does not work with the latest release (v431) of the RichEdit control, which ships with Windows XP.
--/code
--   atom fnd, frompoint
--   integer cnt
--   sequence word
--      -- Count all occurances of a word.
--      word = "procedure"
--      cnt = 0
--      frompoint = 0
--      fnd = -1
--      while fnd != 0 do
--          fnd = findText(myRichFld, word, {frompoint,-1},
--                                  findDown + findMatchCase + findWholeWord)
--          if fnd then
--               cnt += 1
--               frompoint = fnd
--          end if
--      end while
--
--/endcode
global function findText(integer id, sequence text, object range, integer flags)
atom FT, index

        if atom(range) then
            range = {0, -1}
        end if

        FT = w32to_memory(0,ID_FINDTEXTEX,{range[1], range[2], text, 0, -1})

        index = sendMessage(id, EM_FINDTEXTEX, flags, FT)

        w32release_mem(FT)

        -- convert to one-based index
        return index+1

end function

--/topic Dialogs
--/proc getFindText(id)
--/desc Opens the "Find" Dialog
-- /i id should be the id of the control in which the Find Dialog will
-- search.  The Find dialog is a modeless dialog, which means that it
-- will remain open and on top, until the user closes it.
global procedure getFindText(object id)
atom fr, dlg

        if atom(id) then
            fr = w32to_memory(0,ID_FINDREPLACE,{getHandle(id),0,"",""})
            dlg = w32Func(FindTextA,{fr})
        else
        -- TODO: Implement callback hook
        end if
end procedure

--/topic Dialogs
--/proc getReplaceText(id)
--/desc Opens the "Replace" Dialog
-- /i id should be the id of the control in which the Replace Dialog will
-- search.  The Replace dialog is a modeless dialog, which means that it
-- will remain open and on top, until the user closes it.
global procedure getReplaceText(object id)
atom fr, dlg
        if atom(id) then
            fr = w32to_memory(0,ID_FINDREPLACE,{getHandle(id),0,"",""})
            dlg = w32Func(ReplaceTextA,{fr})
        else
        -- TODO: Implement callback hook
        end if
end procedure

sequence vStreamCallbackBuffer
    vStreamCallbackBuffer = {}
integer vStreamCBPosn
    vStreamCBPosn = 1

function getStreamCallback(atom dwCookie, atom pbBuff, atom cb, atom pcb)
--/**/  if dwCookie then end if -- suppress warnings    -- PL 29/4/09
    -- Get the characters from the buffer
    vStreamCallbackBuffer &= peek({pbBuff, cb})
    -- Let the control know how many I pulled out.
    poke4(pcb, cb)
    -- Return 'no error'
    return  0
end function
constant gscb = call_back(routine_id("getStreamCallback"))

function putStreamCallback(atom dwCookie, atom pbBuff, atom cb, atom pcb)
atom lCBLen, lStart, lEnd, lRemaining
    --/**/  if dwCookie then end if -- suppress warnings    -- PL 29/4/09
    lStart = vStreamCBPosn
    lRemaining = length(vStreamCallbackBuffer)-lStart+1

    if lRemaining < 1 then
        -- Tell Windows that nothing is left.
        poke4(pcb, 0)
        return 0
    end if

    if cb > lRemaining then
        lCBLen = lRemaining
    else
        lCBLen = cb
    end if
    poke4(pcb, lCBLen)
    lEnd = lStart+lCBLen-1

    -- Avoid creating a slice if using the entire buffer.
    if lEnd=length(vStreamCallbackBuffer) and lStart=1 then
        poke(pbBuff,vStreamCallbackBuffer)
    else
        poke(pbBuff,vStreamCallbackBuffer[lStart..lEnd])
    end if
    if lEnd=length(vStreamCallbackBuffer) then
        vStreamCallbackBuffer = ""
    else
        vStreamCBPosn = lEnd+1
    end if

    return 0
end function
constant pscb = call_back(routine_id("putStreamCallback"))

-----------------------------------------------------------------------------
--/topic RichEdit controls
--/func getStream(integer id, integer flags)
--/desc Convert the data in a RichEdit control to a sequence.
--/ret SEQUENCE: The contents of the RichEdit control.
-- Use flag /b StreamText to return plain text, or /b StreamRTF to return
-- rich text. This can be combined to /b StreamSelection to only return
-- any selected content from the RichEdit.
--
-- Example:
--
--/code
--           -- Create a RichEdit control
--           RE = /create(/RichEdit, "", Win, 20, 20, 360, 200, ES_NOHIDESEL)
--           . . .
--           -- Save the text into a file from a RichEdit control
--           richout = open("MyRich.txt", "w")
--           -- Get the selected text from the control.
--           printf(richout, "%s", {/getStream(RE,StreamText+StreamSelection)})
--
--           close(richout)
--
--/endcode
--
global function getStream(integer id, integer flags)
atom EDITSTREAM, uFormat
sequence streamout

        uFormat = and_bits(StreamMask, flags)

        vStreamCallbackBuffer = ""
        EDITSTREAM = w32to_memory(0,ID_EDITSTREAM, {0, 0, gscb})

        VOID = sendMessage(id, EM_STREAMOUT, uFormat, EDITSTREAM)

        w32release_mem(EDITSTREAM)
        streamout = vStreamCallbackBuffer
        vStreamCallbackBuffer = {}

        return streamout
end function

-----------------------------------------------------------------------------
--/topic RichEdit controls
--/proc putStream(integer id, integer flag, sequence text)
--/desc Load text into a RichEdit control from a text sequence.
-- Use /i flag /b StreamText to indicate that /i contains plain text,
-- or /b StreamRTF to indicate that /i text contains rich text.
-- This can be combined with StreamSelection so that only any selected
-- text in the control is replaced with /i text data.
--
-- Example:
--
--/code
--           sequence rich
--           integer RE, fn, c
--           . . .
--           -- Create a RichEdit control
--           RE = /create(/RichEdit, "", Win, 20, 20, 360, 200, ES_NOHIDESEL)
--
--           -- Load the text into the RichEdit control
--           fn = open("rich.rtf", "r")
--           if fn != -1 then
--               rich = {}
--               c = getc(fn)
--               while c != -1 do
--                   rich &= c
--                   c = getc(fn)
--               end while
--
--               /putStream(RE, StreamRTF, rich)
--
--               close(fn)
--           end if
--
--/endcode

global procedure putStream(integer id, integer flags, sequence streamin)
atom uFormat
atom EDITSTREAM
integer lLen
atom lResult

        if not length(streamin) then
            return
        end if

        lLen  = length(streamin)
        uFormat = and_bits(StreamMask, flags)

        vStreamCallbackBuffer = streamin
        vStreamCBPosn = 1

        EDITSTREAM = w32to_memory(0,ID_EDITSTREAM, {0, 0, pscb})

        VOID = sendMessage(id, EM_STREAMIN, uFormat, EDITSTREAM)
        lResult = w32fetch(EDITSTREAM, EDITSTREAM_dwError)
        w32release_mem(EDITSTREAM)

end procedure

--/topic Attributes
--/func setReBarAutoSizing(integer Flag)
--/desc Sets/Gets the automatic resizing facility for ReBar controls.
--/ret INTEGER: Current Value
--/i Flag is either /b w32True to enable Win32Lib to automatically take care
--of moving controls around relative to the height of the ReBar control,
--/b w32False to disable this facility, or /w32GetValue to get the current status..
--
-- The current value for this facility is returned. Initially this facility
-- is disabled.
--
--Example:
--/code
--      integer CurVal
--      -- Enable automatic handling of rebar height changes.
--      CurVal = setReBarAutoSizing(w32True)
--/endcode

global function setReBarAutoSizing(integer pFlag)
integer lOldFlag

        lOldFlag = AutoReBarSizing
        if pFlag != w32GetValue then
            AutoReBarSizing = (pFlag != 0)
        end if

        return lOldFlag
end function

-----------------------------------------------------------------------------
function queryFont(integer id, atom pRequest, sequence pArgs)

-- this runs a query about font attributes. Because the query
-- can run against controls which have no obtainable DC, the
-- queries are performed on the mainWindow. The exception is
-- the Printer, which uses it's own DC.
--
-- The DC is automatically prepended to the /i pArgs list.
--
-- Since the mainWindow is used, it has to be restored to it's
-- prior state when the query is complete.

integer lUseId
atom lHDC, lResult
sequence lSavedFont

        lSavedFont = {}

        -- Attempt to get a DC for this control.
        lHDC = getDC({id, "ignorenull"})

        -- If I can't then use the Screen's DC
        if lHDC = 0 then

            lUseId = Screen
            -- Swap font defn
            lSavedFont = ctrl_Font[lUseId]
            ctrl_Font[lUseId] = ctrl_Font[id]
        else
            lUseId = id
        end if

        -- set the font and get control's dc
        lHDC = assignFont({lUseId, lHDC})

        -- perform the requested function
        lResult = w32Func(pRequest, lHDC & pArgs)

        releaseDC(lUseId)

        -- used the main window?
        if length(lSavedFont) != 0 then
            -- restore the font attributes
            ctrl_Font[lUseId] = lSavedFont
        end if

        return lResult

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/func getFontMetric(id, field)
--/desc Gets font metric field value for /i id's current font.
--/ret field's value
-- The /i field can be one of:
--/li    tmHeight
--/li    tmAscent
--/li    tmDescent
--/li    tmInternalLeading
--/li    tmExternalLeading
--/li    tmAveCharWidth
--/li    tmMaxCharWidth
--/li    tmWeight
--/li    tmOverhang
--/li    tmDigitizedAspectX
--/li    tmDigitizedAspectY
--/li    tmFirstChar
--/li    tmLastChar
--/li    tmDefaultChar
--/li    tmBreakChar
--/li    tmItalic
--/li    tmUnderlined
--/li    tmStruckOut
--/li    tmPitchAndFamily
--/li    tmCharSet
--/li    ntmFlags
--/li    ntmSizeEM
--/li    ntmCellHeight
--/li    ntmAveWidth
--
-- Example:
--
--/code
--          -- get the descent for the default font
--          integer descent
--
--          /setDefaultFont(MyWindow)
--          descent = /getFontMetric(MyWindow,tmDescent)
--          /wPrintf(MyWindow,"The default font's descent is %",descent)
--/endcode

global function getFontMetric(integer id, sequence field)

-- get metrics for current font

atom result
atom tm

        tm  = w32acquire_mem(0,SIZEOF_TEXTMETRIC)

        -- get the metrics of the font (queryFont will prepend the DC)
        if not queryFont(id,xGetTextMetrics,{tm}) then
            warnErr(Err_GETFONTMETRIC)
        end if

        result = w32fetch(tm, field)

        w32release_mem(tm)

        return result

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func getFontSize(id)
--/desc Gets font metrics for /i id's current font.
--/ret {width,height} of average character.
--
-- Example:
--
--/code
--          -- show the metrics of the default font
--          sequence size
--
--          /setDefaultFont(MyWindow)
--          size = /getFontSize(MyWindow)
--          /wPrintf(MyWindow,"The default font is %d by %d",size)
--/endcode

global function getFontSize(integer id)

-- get metrics for current font

integer width, height, maxwidth
atom tm

        tm  = w32acquire_mem(0,SIZEOF_TEXTMETRIC)

        -- get the metrics of the font (queryFont will prepend the DC)
        if not queryFont(id,xGetTextMetrics,{tm}) then
            warnErr(Err_GETFONTSIZE)
        end if

        width   = w32fetch(tm,tmAveCharWidth)
        maxwidth= w32fetch(tm,tmMaxCharWidth)
        height  = w32fetch(tm,tmHeight) +
                  w32fetch(tm,tmInternalLeading) +
                  w32fetch(tm,tmExternalLeading)

        w32release_mem(tm)

        return {width, height, maxwidth}

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextHeight(integer Id, sequence text)
--/desc Gets the height of the /i text using the current font for the /i id
--/ret ATOM: Height of the text.
global function getTextHeight(integer id, sequence text)
-- get metrics for current font
atom size, str, mset, height

        mset = w32new_memset()
        size  = w32acquire_mem(mset,SIZEOF_SIZE)
        text = w32removeItem('&', text)
        str = w32acquire_mem(mset,text)

        -- get the metrics of the font (queryFont will prepend the DC)
        if not queryFont(id,xGetTextExtentPoint,{str, length(text), size}) then
            abortErr(Err_GETTEXTEXTENT)
        end if

        height  = w32fetch(size,sizY)

        w32release_mem(mset)

        return height

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextWidth(integer Id, sequence text)
--/desc Gets the width of the /i text using the current font for the /i id
--/ret ATOM: Width of the text.
global function getTextWidth(integer id, sequence text)
-- get metrics for current font
atom size, str, mset, width

        mset = w32new_memset()
        size  = w32acquire_mem(mset,SIZEOF_SIZE)
        text = w32removeItem('&', text)
        str = w32acquire_mem(mset, text)

        -- get the metrics of the font (queryFont will prepend the DC)
        if not queryFont(id,xGetTextExtentPoint,{str, length(text), size}) then
            abortErr(Err_GETTEXTEXTENT)
        end if

        width = w32fetch(size,sizX)

        w32release_mem(mset)

        return width

end function
r_getTextWidth = routine_id("getTextWidth")


-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextExtent(integer Id, sequence textset)
--/desc Gets the metrics of the /i textset strings, using /i Id's current font.
--/ret SEQUENCE: maxwidth, maxheight, minwidth, minheight, totalwidth, totalheight
--The /i textset parameter can either be a normal text string or a sequence of
-- strings. /n
-- /b Note: The first or only /b'&' character in each string will not be included
-- in the metrics.
--
-- Example #1: Show the size of a text string.
--/code
--          sequence text, extent
--
--          -- the string to measure
--          text = "Hi, there!"
--
--          -- measure the string
--          extent = /getTextExtent(MyWindow, text)
--
--          -- show results
--          /wPrintf(MyWindow, "The string %s is %d by %d pixels",
--                               {string, extent[1], extent[2]})
--/endcode
--
-- Example #2: Calculate the size of some buttons
--/code
--          sequence btntext, extent, btns
--          integer btnheight, btnwidth
--          sequence x
--          integer y
--
--          -- the strings to measure
--          btntext = {"&Print", "&Cancel", "&Ok", "&Help"}
--
--          -- measure the string
--          extent = /getTextExtent(MyWindow, btntext)
--
--          -- calc button dimensions
--          btnheight = extent[2] + 10 -- adjust for borders
--          btnwidth  = extent[1] + 8  -- adjust for borders
--
--          -- Draw the buttons
--          btns = {}
--          x = 5
--          y = 10
--          for i=1 to length(btntext) do
--              btns &= create(PushButton, MyWindow, btntext[i],
--                          x, y, btnwidth, btnheight, 0)
--              y += btnheight+1
--          end for
--
--/endcode

global function getTextExtent(integer id, sequence text)

-- get metrics for current font

integer width, height
integer maxwidth, maxheight
integer minwidth, minheight
integer totwidth, totheight
atom size, lStrAddr, mset

        if length(text) = 0 or atom(text[1]) then
            text = {text}
        end if
        maxheight = 0
        maxwidth = 0
        minheight = 0
        minwidth = 0
        totheight = 0
        totwidth = 0

        mset = w32new_memset()
        size  = w32acquire_mem(mset, SIZEOF_SIZE)
        for i=1 to length(text) do
            text[i] = w32removeItem('&', text[i])
            lStrAddr = w32acquire_mem(mset, text[i])

            -- get the metrics of the font (queryFont will prepend the DC)
            if not queryFont(id,xGetTextExtentPoint,{lStrAddr,length(text[i]),size}) then
                abortErr(Err_GETTEXTEXTENT)
            end if

            -- assign values
            width   = w32fetch(size,sizX)
            height  = w32fetch(size,sizY)

            -- determine maximums
            if i = 1 or width > maxwidth then
                maxwidth = width
            end if
            if i = 1 or height > maxheight then
                maxheight = height
            end if
            -- determine minimums
            if i = 1 or width < minwidth then
                minwidth = width
            end if
            if i = 1 or height < minheight then
                minheight = height
            end if
            -- determine totals
            totwidth += width
            totheight += height

        end for

        w32release_mem(mset)

        return {maxwidth, maxheight, minwidth, minheight, totwidth, totheight}

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc getCharExtent(integer Id)
--/desc Gets the average character width and height for the /i Id's current font.
--/ret SEQUENCE: avgwidth, avgheight
--/b Note 1: The averages are not integers. You may have to floor() them. /n
--/b Note 2: These are averages! Be wary of this when using them to calculate
-- field sizes for proportional fonts.
--
-- Example
--/code
--          sequence extent
--          integer fldWidth
--
--          extent = /getCharExtent(MyWindow)
--
--          -- Calculate the amount of space need to display the text.
--          fldWidth = floor(extent[1] * length(text))
--/endcode
--
-- Example #2: Calculate the size of some buttons
--/code
--          sequence btntext, extent, btns
--          integer btnheight, btnwidth
--          sequence x
--          integer y
--
--          -- the strings to measure
--          btntext = {"&Print", "&Cancel", "&Ok", "&Help"}
--
--          -- measure the string
--          extent = /getTextExtent(MyWindow, btntext)
--
--          -- calc button dimensions
--          btnheight = extent[2] + 10 -- adjust for borders
--          btnwidth  = extent[1] + 8  -- adjust for borders
--
--          -- Draw the buttons
--          btns = {}
--          x = 5
--          y = 10
--          for i=1 to length(btntext) do
--              btns &= create(PushButton, MyWindow, btntext[i],
--                          x, y, btnwidth, btnheight, 0)
--              y += btnheight+1
--          end for
--
--/endcode

global function getCharExtent(integer id)
sequence lExtent, lResult

        lExtent = getTextExtent(id, {"W"," ._-|@0123456789" &
                                     "abcdefghijklmnopqrstuvwxyz" &
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"})
        lResult = {(lExtent[1] / 68 + lExtent[3]) / 2,
                   (lExtent[2]      + lExtent[4]) / 2
                  }

        return lResult
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setTextAlign(id, style)
--/desc Set the font alignment to use when printing text.
--
-- The default option is AlignTop. Options include:
--
-- /li /b AlignTop: Text is displayed below {x,y}
-- /li /b AlignBottom: Text is displayed above {x,y}
-- /li /b AlignBaseline: Text is displayed on baseline {x,y}
--
-- Example:
--
--/code
--          -- draw a line
--          drawLine(Win, 10, 100, 100, 100)
--
--          -- top alignment (default)
--          setTextAlign(Win, AlignTop)
--          setPenPos(Win, 10, 100)
--          wPuts(Win, "AlignTop")
--
--          -- bottom alignment
--          setTextAlign(Win, AlignBottom)
--          setPenPos(Win, 10, 100)
--          wPuts(Win, "AlignBottom")
--
--/endcode

global procedure setTextAlign(integer id, integer flag)
        ctrl_Text_Alignment[id] = flag
end procedure

--/topic Graphics
--/func adjustBrightness(atom pColor, atom pAdjustment)
--/desc Applies a luminosity factor to a color supplied as a 24-bit integer.
--/ret A 24-bit integer representing the adjusted color.
--
-- The higher the factor, the brighter the output color.
--
-- Example:
--/code
--         constant win=create(Window,"Test",0,Default,Default,Default,Default,0),
--                  btn=create(PushButton,"1.2 times brighter",win,10,10,100,30,0)
--
--        procedure slightlyBrighter(integer id,integer event,sequence data)
--            integer newColor
--            newColor=adjustBrightness(getControlInfo(win,CONTROLINFO_bcolor),1.2)
--            setWindowBackColor(win,newColor)
--        end procedure
--        setHandler(btn,w32HClick,routine_id("slightlyBrighter"))
--
--        setWindowBackColor(win,Parchment)
--        WinMain(0,Normal)
--/endcode

global function adjustBrightness(atom pColor, atom pAdjustment)
sequence lRGB

        lRGB = split_rgb(pColor)
-- PL 29/4/09
--/**/  lRGB = sq_floor(sq_mul(lRGB,pAdjustment))   --/* -- Pve
        lRGB = floor(lRGB * pAdjustment)            --*/ -- RDS
        for i=1 to 3 do
            if lRGB[i] > 255 then
                lRGB[i] = 255
            elsif lRGB[i] < 0 then
                lRGB[i] = 0
            end if
        end for
        return rgb(lRGB[1], lRGB[2], lRGB[3])

end function
-----------------------------------------------------------------------------
--/topic Graphics
--/func fillRectangle(integer id,object rectangle,integer isColor,object filler,integer transp)
--/desc Fills a rectangle in the window /i id with an arbitrary brush.
--/ret INTEGER 0 on failure, nonzero on success.
-- If the /i isColor is not w32False, filler designates a color, and this call
-- is equivalent to one to /drawRectangle() with the /i filled parameter nonzero.
-- Otherwise:
--/li If /i filler is an atom, it is a brush handle.
--/li If it is a string, it is the name of a bitmap file. The bitmap will be loaded and tiled over the filled rectangle.
--/li If it is a sequence of length 1, the element is a bitmap handle already obtained.
--/li Otherwise, the first element is a hatch style, and the second one a foreground value.
--      See the hatch style values in the documentation for /setBackground().
--/li The empty sequence is a reserved special value and currently does nothing.
--
-- /i rectangle may be specified as:
--/li a {left,top,right,bottom} sequence;
--/li 0, in which case the client rectagle of /i id will be filled.
--/li a nonzero atom, the address of a rectangle already poked in RAM.
--
-- /i transp is nonzero to request a background mode of TRANSPARENT, and 0 to have it OPAQUE, during this operation.

global function fillRectangle(integer id,object rectangle,integer isColor,object filler, integer transp)
integer ret_code,saved_mode
atom rect_addr,fill_brush

        -- interpret special values for rectangle
        if equal(filler,{}) or not validId(id) then
            return 0
        end if
        if equal(rectangle,0) then
            rectangle=call_func(r_getClientRect,{id})
        end if

        -- rect_addr must point to the rectangle
        if sequence(rectangle) then
            rect_addr=w32acquire_mem(0,{Long,4})
            poke4(rect_addr,rectangle)
        else
            rect_addr=rectangle
        end if

        -- Get the brush
        if isColor then
            fill_brush = w32Func(xCreateSolidBrush,{colorValue(filler)})
        elsif atom(filler) then
            fill_brush = filler
        elsif w32string(filler) then
            fill_brush = w32Func(xCreatePatternBrush,{call_func(r_loadBitmapFromFile,{filler})})
        elsif length(filler)=1 then
            fill_brush = w32Func(xCreatePatternBrush,filler)
        else
            fill_brush = w32Func(xCreateHatchBrush,{filler[1],colorValue(filler[2])})
        end if

        -- Temporary background mode override
        if transp then
            transp = TRANSPARENT
        else
            transp = OPAQUE
        end if
        if transp = ctrl_Pen[id][PenBkMode] then
            saved_mode = -1
        else
            saved_mode = ctrl_Pen[id][PenBkMode]
            ctrl_Pen[id][PenBkMode] = transp
        end if

        ret_code = w32Func(xFillRect,{getHandle(id),rect_addr,fill_brush})

        -- Cleanup
        if sequence(rectangle) then
            w32release_mem(rect_addr)
        end if

        if saved_mode >= 0 then
            ctrl_Pen[id][PenBkMode] = saved_mode
        end if

        return ret_code

end function

-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintWindow(window)
--/desc Force /i window to be entirely repainted.
-- This repaints the entire window in it's background color, effectively
-- erasing everything in it. It then triggers an /w32HPaint event
-- for that window, requesting that the entire window be repainted.
--
-- Example:
--
--/code
--      -- force MyWindow to be repainted
--      /repaintWindow(myWindow)
--/endcode

global procedure repaintWindow(integer id)
-- redraws *everything*
atom hwnd
        -- get handle
        if id <= 0 or id > length(ctrl_Handle) then
            hwnd = 0
        else
            hwnd = ctrl_Handle[id]
        end if

        -- invalidate all of the current window, and clear it
        VOID = w32Func(xInvalidateRect,{hwnd, NULL, 1})

        -- trigger an immediate paint message
        VOID = w32Func(xSendMessage,{hwnd, WM_PAINT, 0, 0})

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintFG(window)
--/desc Force /i window to be repainted but without clearing it first.
-- This triggers an /w32HPaint event
-- for that window, requesting that the entire window be repainted.
--
-- It is different to /repaintWindow() in that the window is not cleared
-- to its background color first.
--
-- Example:
--
--/code
--      -- force MyWindow to be repainted
--      /repaintFG(myWindow)
--/endcode
global procedure repaintFG(integer id)
-- redraws *everything*
atom hwnd

        -- get handle
        if id <= 0 or id > length(ctrl_Handle) then
            hwnd = 0
        else
            hwnd = ctrl_Handle[id]
        end if

        -- invalidate all of the current window, and clear it
        VOID = w32Func(xInvalidateRect,{hwnd, NULL, 0})

        -- trigger an immediate paint message
        VOID = w32Func(xSendMessage,{hwnd, WM_PAINT, 0, 0})


end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintRect(window, x1, y1, x2, y2)
--/desc Force /i window to be partially repainted.
-- This sends repaints at the specified portion of the /i window with
-- the background color, erasing that portion of it. It then triggers
-- an /Paint event for that window, passing the erased area as
-- parameters.
--
-- Example:
--
--/code
--      -- repaint only a portion of MyWindow
--      /repaintRect(myWindow, 1, 1, 10, 10)
--/endcode

global procedure repaintRect(integer id, integer x1, integer y1, integer x2, integer y2)
-- invalidates only a portion of the window
atom hWnd
atom rect

        rect = w32acquire_mem(0,SIZEOF_RECT)
        poke4(rect,{x1,y1,x2,y2})

        hWnd = getHandle(id)

        -- invalidate all of the current window, and clear it
        if not w32Func(xInvalidateRect,{hWnd, rect, 1}) then
            warnErr(Err_REPAINTRECT)
        end if

        w32release_mem(rect)

        -- trigger an immediate paint message
        VOID = w32Func(xSendMessage,{hWnd, WM_PAINT, 0, 0})


end procedure



------------------------------------------------------
--/topic Attributes
--/proc clearWindow(integer id)
--/desc Sets /i id to its background color
-- This is used to wipe a Window or Pixmap
-- Example:
--
--/code
--          /clearWindow(MyWindow)
--          /clearWindow(MyPixmap)
--/endcode

global procedure clearWindow(integer id)
sequence lRect
sequence lSavedBrushColor

        if compare(ctrl_Bg_Color, w32WinDefColor) then
            lRect = call_func(r_getRect,{id})
            lSavedBrushColor = ctrl_Pen[id][PenBrushColor]
            -- Use Back color as temporary brush color.
            ctrl_Pen[id][PenBrushColor] = {ctrl_Bg_Color[id]}
            call_proc(r_drawRectangle,{id, w32True, 0, 0, lRect[3], lRect[4]})
            ctrl_Pen[id][PenBrushColor] = lSavedBrushColor
        end if

        return

end procedure

------------------------------------------------------
global constant EM_SETBKGNDCOLOR = #443

global constant
        HatchHorz = 0,
        HatchVert = 1,
        HatchNWSE = 2,
        HatchSWNE = 3,
        HatchCross = 4,
        HatchXCross = 5

--/topic Attributes
--/proc setBackground(integer id,integer flag,object bkData)
--/desc Sets the background of control /i id with a color, pattern or bitmap.
-- /i id is the target control. The procedure will not affect buttons, menus and tab controls. /n
-- /i flag is either w32False or w32True. If w32False is passed, bkData is a color specification,
--  and the call is equivalent to /setWinbackColor(/i id, /i bkData). /n
-- Otherwise, bkData is either a bitmap handle or a three element sequence. In the former case, 
--  the bitmap is tiled to form the background of the window. In the latter case, a hatch pattern 
--  is being specified as {style, background color, line color}.
-- The style parameter is any of the following:
--/li /b HatchHorz: horizontal lines
--/li /b HatchVert: vertical lines
--/li /b HatchNWSE: lines at a 45 degrees slope, going down from left to right
--/li /b HatchSWNE: lines at a 45 degrees slope, going up from left to right
--/li /b HatchCross: a canvas aligned on the client rectangle of the window
--/li /b HatchXCross: a canvas at a 45 degree sope relative to the client rectangle of the window.

global procedure setBackground(object id, integer flag, object bkData)

-- set the background color of a window or control
-- use rgb() to calculate a color

atom lNewBrush, lOldBrush, lFillBrush
atom bStyles
integer lId,lColor,hatched,changed
atom hdc,rect
sequence s

        if not sequence(id) then
            id = {id}
        end if
        hatched=0
        for i=1 to length(id) do
            lId = id[i]
            -- save color
            if equal(bkData,w32WinDefColor) then
                repaintWindow(lId)
                return
            end if
            if not flag then
                lColor = colorValue(bkData)
                if not ctrl_Bg_Brush[lId] then
                    ctrl_Bg_Brush[lId] = w32Func(xCreateSolidBrush,{lColor})
                end if
                changed=(lColor!= colorValue(ctrl_Bg_Color[lId]))
                if changed then
                    ctrl_Bg_Color[lId] = bkData

                    -- create a new brush
                    lNewBrush = w32Func(xCreateSolidBrush, {lColor})
                else
                    repaintWindow(lId)
                    return
                end if
            else
                changed=0
                if atom(bkData) then
                    lNewBrush = w32Func(xCreatePatternBrush,{bkData})
                    ctrl_Bg_Color[lId] = {bkData}
                elsif length(bkData)=1 then
                    lNewBrush = w32Func(xCreatePatternBrush,bkData)
                    ctrl_Bg_Color[lId] = bkData
                else
                    bkData[2] = colorValue(bkData[2])
                    bkData[3] = colorValue(bkData[3])
                    ctrl_Bg_Color[lId] = bkData
                    lNewBrush=w32Func(xCreateSolidBrush,{bkData[2]})
                    lFillBrush = w32Func(xCreateHatchBrush,{bkData[1],bkData[3]})
                    hatched=1
                end if
            end if

            if ctrl_Type[lId] = Pixmap then
                clearWindow(lId)
            else
                -- set that as the background color
                lOldBrush = ctrl_Bg_Brush[lId]
                ctrl_Bg_Brush[lId] = lNewBrush

                -- delete the prior brush
                deleteObject(lOldBrush)

                -- If this is a window, then change the Class background too.
                if ctrl_Type[lId] = Window then
                    VOID = w32Func(xSetClassLong, {getHandle(lId), GCL_HBRBACKGROUND, lNewBrush})
                elsif not flag then
                    if ctrl_Family[lId] = BUTTON then
                        s = getStyleFlags(lId)
                        bStyles = s[1]
                        if and_bits(bStyles,BS_CHECKBOX) then
                            VOID = floodFill(lId,1,1,{-1,lColor},FLOODFILLSURFACE)
                        end if
                    elsif ctrl_Type[lId] = ListView then
                        VOID = sendMessage(lId,LVM_SETBKCOLOR,0,lColor)
                    elsif ctrl_Type[lId] = TreeView then
                        VOID = sendMessage(lId,TVM_SETBKCOLOR,0,lColor)
                    elsif ctrl_Type[lId] = MonthCalendar then
                        call_proc(r_setMonthColor,{lId,lColor,MCSC_MONTHBK})
                    elsif ctrl_Type[lId] = ReBar then
                        VOID = sendMessage(lId,RB_SETBKCOLOR,0,lColor)
                    elsif find(ctrl_Family[lId],{EDIT,STATIC,SCROLLBAR,LISTBOX}) then
                        VOID = floodFill(lId,1,1,{-1,lColor},FLOODFILLSURFACE)
                    elsif ctrl_Family[lId]=COMBO or ctrl_Type[lId]=ComboBoxEx then
                        VOID = floodFill(lId,1,1,{-1,lColor},FLOODFILLSURFACE)
                        changed = call_func(r_getEdit,{lId})
                        if changed then
                            setBackground(changed,0,lColor)
                        end if
                    elsif ctrl_Type[lId]=RichEdit then
                        VOID=sendMessage(lId,EM_SETBKGNDCOLOR,0,lColor)
                    end if
                end if
    -- use owner drawn menus or tab controls in order to get a non default color
    -- same for dropdown lists in dropdowns or combos
    -- for toolbars, you need to use XP's visual styles

                -- redraw the screen
                if hatched then
                    ctrl_Hatch[lId] = lFillBrush
                    if ctrl_Type[lId]=Window then
                        addStyle(lId,WS_CLIPCHILDREN)
                    end if
                    hdc=getDC(lId)
                    w32Proc(xSetBkMode,{hdc,TRANSPARENT})
                    VOID=w32Func(xSetBkColor,{hdc,bkData[2]})
                    s=call_func(r_getClientRect,{lId})
                    rect=w32acquire_mem(0,16)
                    poke4(rect,s[1..4])
                    VOID=w32Func(xFillRect,{hdc,rect,lFillBrush})
                    w32release_mem(rect)
                    releaseDC(lId)
                else
                    ctrl_Hatch[lId] = 0
                    repaintWindow(lId)
                end if
            end if
        end for
end procedure

--/topic Attributes
--/proc setWindowBackColor(object id, object Color)
--/desc Sets the background of /i id to /i color.
-- This is used to change the background color of a window or control.
--
-- /i id can be a single control id or a list of ids.       -- PL 6/8/09 not so...
--
-- /i Color can either be an atom with a rgb value or a three-element sequence
-- formated as {red, green, blue} values (0-255). /n
-- You can also use /getSysColor to get a default system color. /b
-- This will trigger an /Paint event.
--
-- /b Note: this will not affect menus, tab controls, buttons and toolbars.
--
-- Example:
--
--/code
--          -- Set the window background color to bright white
--          /setWindowBackColor(MyWindow, BrightWhite)
--          -- Set a list's background color to salmon pink
--          /setWindowBackColor(List1, {255, 128, 128})
--          -- Set an edit field to look like a button color.
--          /setWindowBackColor(Edit1, getSysColor(COLOR_BTNFACE))
--          -- Set a group of controls
--          /setWindowBackColor({ctl1, ctl2, ctl3}, Cyan)
--/endcode
global procedure setWindowBackColor(object id, object rgbColor)
        setBackground(id,w32False,rgbColor)
end procedure


-----------------------------------------------------------------------------
-- CREATING CONTROLS
--
-----------------------------------------------------------------------------

-- added CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: The handle-id pairing for menus wouldn't work, because menus have no attached user data
-- Enhanced: now x is a position parameter, y a rank or id, cx the unchecked bitmaphandle, cy the 
--              checked bitmap handle, exFlags is hBitmap

--/topic Menus
--/func getMenuPosn(integer id)
--/desc Get the zero-based relative position of a menu item.
--/ret INTEGER: Zero-Based Position of the menu item, or -1 if not a menu item.
--/i id is the id of a menu (item).
--
--Example
--/code
--  integer pos
--  pos = getMenuPosn(miSave)
--/endcode

global function getMenuPosn(integer id)
        if validId(id) and find(ctrl_Family[id],{MENU,MENUITEM}) then
            return find(id,ctrl_Group[ctrl_Parent[id]])-1
        else
            return -1
        end if
end function

--/topic Menus
--/func setMenuItemBitmaps(integer id,object bitmap)
--/desc Sets the bitmap on a menu item, or the checked/unchecked marks
--/ret SEQUENCE: the handles for unchecked,checked and main bitmaps
-- /i id is the identifier of the menu item to be considered.
-- If /i bitmap is an atom, it is the handle to the bitmap displayed by the item.
-- If it is a sequence starting with a pair, the pair is {unchecked mark handle,checked mark handle}, and these marks will be set.
-- If it is an empty sequence, no attempt to change anything will be made.
-- Otherwise, bitmap is some text to be displayed instead of the current bitmap, if any.
-- The returned value always has 3 elements, unless the function fails in any way, in which case it returns {}.
global function setMenuItemBitmaps(integer id,object bitmap)
atom minfo,hmenu
integer itype,checkmarks
sequence result

        if not validId(id) and bitmap then
            return {}
        end if
        if ctrl_Type[id] != MenuItem then
            return {}
        end if
        hmenu=w32lookup(ctrl_Parent[id],menu_ids,menu_handles)

        -- get info about the item
        minfo = w32to_memory(0,ID_MENUITEMINFO,0)
        w32store(minfo,MENUITEMINFO_fMask,MIIM_CHECKMARKS+MIIM_TYPE)
        if not w32Func(xGetMenuItemInfo,{hmenu,id,0,minfo}) then
            return {}
        end if
        result={w32fetch(minfo,MENUITEMINFO_hbmpUnchecked),w32fetch(minfo,MENUITEMINFO_hbmpChecked),0}
        itype = w32fetch(minfo,MENUITEMINFO_fType)

        -- set new the marks
        if sequence(bitmap) and length(bitmap)=1 and sequence(bitmap[1]) then
            checkmarks=1
            w32store(minfo,MENUITEMINFO_hbmpUnchecked,bitmap[1][1])
            w32store(minfo,MENUITEMINFO_hbmpChecked,bitmap[1][2])
        else
            checkmarks=0
        end if
        if and_bits(itype,MFT_BITMAP) then
            result[3] = w32fetch(minfo,MENUITEMINFO_dwTypeData)

            -- set new bitmap, or text
            if not checkmarks then
                if atom(bitmap) then
                    w32store(minfo,MENUITEMINFO_dwTypeData,bitmap)
                else
                    w32store(minfo,MENUITEMINFO_fType,xor_bits(itype,MFT_BITMAP+MFT_STRING))
                    w32store(minfo,MENUITEMINFO_dwTypeData,w32acquire_mem(0,bitmap))
                end if
            end if
        elsif not checkmarks then
            if atom(bitmap) then
                w32store(minfo,MENUITEMINFO_fType,xor_bits(itype,MFT_BITMAP+MFT_STRING))
                w32store(minfo,MENUITEMINFO_dwTypeData,bitmap)
            else
                w32store(minfo,MENUITEMINFO_dwTypeData,w32acquire_mem(0,bitmap))
            end if
        end if
        if w32Func(xGetMenuItemInfo,{hmenu,id,0,minfo}) then
            return result
        else
            return {}
        end if
end function

constant mi_position=1, mi_rank=2,mi_hbmpunchecked=3,mi_hbmpchecked=4,mi_hbitmap=5
global constant MP_AT=1,MP_BEFORE=2,MP_AFTER=3,MP_END=0

procedure createMenuBar(integer id)
        -- create a menu bar
        ctrl_Menu[id] = w32Func(xCreateMenu, {})
        if ctrl_Menu[id] = 0 then
            warnErr(Err_CREATEMENU)
        end if
        -- attach the menu to the window
        if not w32Func(xSetMenu,{getHandle(id),ctrl_Menu[id]}) then
            warnErr(Err_SETMENU)
        end if

        VOID = call_func(r_subClassControl,{{Menu,id},ctrl_Menu[id]})
end procedure



function menuCreate(atom menuHandle,integer flag,atom id,sequence mText,sequence extraInfo)
integer pos,lRC,codepos
atom pstr
sequence s

        -- sanity check
        if length(w32get_bits(and_bits(flag,MF_SEPARATOR+MF_STRING+MF_BITMAP)))>1 then
            return 1
        end if
        if not find(extraInfo[mi_position],{MP_BEFORE,MP_AT,MP_AFTER,MP_END}) then
            codepos = MP_END    -- unknown position, assume at end
        else
            codepos = extraInfo[mi_position]
        end if
        if codepos!=MP_END and (not integer(extraInfo[mi_rank]) or extraInfo[mi_rank]<=0) then
            return 1
        end if

        if and_bits(flag,MF_BITMAP) then
            pstr = extraInfo[mi_hbitmap]
        else
            pstr = w32acquire_mem(0,mText)
        end if

        if codepos!=MP_END then
            if codepos=MP_AFTER then
                flag += MF_BYPOSITION
                pos = getMenuPosn(extraInfo[mi_rank])
            elsif codepos=MP_AT then
                flag += MF_BYPOSITION
                pos = extraInfo[mi_rank]-1
            else
                pos = extraInfo[mi_rank]
            end if
            if pos >= w32Func(xGetMenuItemCount,{menuHandle}) then
                codepos = MP_END
            end if
        end if
        if codepos != MP_END then
            lRC = w32Func(xInsertMenu,{
                                       menuHandle,      -- menu to attach to
                                       pos,             -- id or rank following inserted item
                                       flag,            -- string or seperator
                                       id,              -- id
                                       pstr})           -- text or bitmap
        else
            lRC = w32Func(xAppendMenu,{
                                       menuHandle,  -- menu to attach to
                                       flag,            -- string or seperator
                                       id,          -- id
                                       pstr})           -- text or bitmap
        end if
        if lRC then
            if extraInfo[mi_hbmpchecked] or extraInfo[mi_hbmpunchecked] then
                VOID = w32Func(xSetMenuItemBitmaps,{menuHandle,id,MF_BYCOMMAND,extraInfo[mi_hbmpunchecked],extraInfo[mi_hbmpchecked]})
            end if
            if codepos != MP_END then
                if codepos = MP_BEFORE then
                    pos = getMenuPosn(extraInfo[mi_rank])
                end if
                flag = w32lookup(menuHandle,menu_handles,menu_ids)
                s=ctrl_Group[flag][pos..length(ctrl_Group[flag])]
                ctrl_Group[flag][pos+1..length(ctrl_Group[flag])] = s[1..length(s)-1]
                ctrl_Group[flag][pos] = id
            end if
        end if
        w32release_mem(pstr)
        return not lRC

end function

procedure createMenu(integer id, sequence mText, integer owner, integer flag, sequence extraInfo)

-- used to assign a menu or popup menu to a window
-- the structure is already created by create()
atom ownerHandle
--atom pstr, result     -- PL 29/4/09
atom mstyle
atom mid
integer class

    class = ctrl_Family[id]

    -- create popup menu for this item
    ctrl_Handle[id] = w32Func(xCreatePopupMenu,{})
    ctrl_Handle_type[id] = kht_Menu
    if ctrl_Handle[id] = NULL then
        warnErr(Err_CREATEPOPUP)
    end if
    menu_ids &= id
    menu_handles &= ctrl_Handle[id]
    -- attach a menu item if it's not a popup
    if class = MENU then
        -- where does this attach to?
        if ctrl_Family[owner] = MENU
        or ctrl_Family[owner] = MENUITEM then
            ownerHandle = getHandle(owner)

        elsif ctrl_Family[owner] = WINDOW then
            ownerHandle = ctrl_Menu[owner]
        else
            ownerHandle = 0
        end if

        mstyle = find('!', mText)
        if mstyle != 0 then
            mText = mText[1..mstyle-1] & mText[mstyle+1..length(mText)]
            mid=id
        else
            flag = or_bits(flag, MF_POPUP)
            mid=ctrl_Handle[id]
        end if

        if menuCreate(ownerHandle,
                      flag,
                      mid,
                      mText,
                      extraInfo) then
            warnErr(Err_APPENDMENU)
        end if
    end if

    vRecent[w32RecentMenu] = id

end procedure

-----------------------------------------------------------------------------
procedure createMenuItem(integer id, sequence mText, integer owner, object styleFlags, sequence extraInfo   )

integer flag,lRC
--atom pstr     -- PL 29/4/09
atom lMenuHandle

    lMenuHandle = getHandle(owner)

    -- store owner's handle
    ctrl_Handle[id] = lMenuHandle
    ctrl_Handle_type[id] = ctrl_Handle_type[owner]

    -- string, or seperator?
    if equal(mText,"-") or length(mText) = 0 then
        flag = MF_SEPARATOR
    elsif extraInfo[mi_hbitmap] then
        flag = w32or_all(MF_BITMAP & styleFlags)
    else
        flag = w32or_all(MF_STRING & styleFlags)
    end if

    -- create a menu item
    lRC = menuCreate(lMenuHandle,flag,id,mText,extraInfo)
    if lRC then
        warnErr(Err_APPENDMENUITEM)
    end if

end procedure

-----------------------------------------------------------------------------
--/topic System Attributes
--/func setAppName(sequence Name)
--/desc Sets the text used as a class name prefix for new Windows.
--/ret Zero if the same application name is not already running
--/b "This needs to be run before the first Window is created in your application."
--The initial value is /i "Win32Lib AppWindow"
--
--A non-zero return code is actually the Windows hWnd value for the other
-- instance of the application.
--
--
--Example
--/code
--     if setAppName("Super Database") != 0 then
--         warnErr("Application is already running")
--     end if
--/endcode

global function setAppName(sequence pName)
-- PL 29/4/09
--atom rc, ExWin, ExClass
atom rc, ExWin


    if length(pName) > 0 then
        vAppName = pName
    end if


    ExWin = w32acquire_mem(0, sprintf("%s 1", {vAppName}))

    rc= w32Func(xFindWindow,{ExWin,0})

    w32release_mem(ExWin)

    return rc
end function

--/topic System Attributes
--/func getAppName()
--/desc Gets the application's name.
--/ret SEQUENCE: The application's name as set by /setAppName
global function getAppName()
    return vAppName
end function


--/topic System Attributes
--/func findWindow(sequence ClassName, sequence WindowTitle)
--/desc Looks to see if the named window exists in the system. Only top level or pop-up windows are inspected.
--/ret SEQUENCE: {0,0} if not found otherwise {id, hWnd} if found.
--
--/i ClassName can be zero or a string containing the registered
-- classname of the window you are looking for. /n
--/i WindowTitle can be zero or a string containing the sought after
-- window's caption text.
--
--/b "Note:" You must supply at least one non-zero parameter.
--
--Example
--/code
--      sequence h
--      h = findWindow(0, "Super Database")
--      if equal(h, {0,0}) then
--          -- not found
--      else
--          if h[1] > 0 then
--              -- A control in my running app
--          else
--              -- A window belonging to another app
--          end if
--      end if
--/endcode

global function findWindow(object pClassName, object pWindowCaption)
atom rc
atom id

    if equal(pClassName,0) and equal(pWindowCaption,0) then
        return {0,0}
    end if

    rc = w32Func(xFindWindow,{pClassName,pWindowCaption})
    if rc = 0 then
        return {0,0}
    end if

    id = getId(rc)
    if not validId(id) then
        id = 0
    end if
    return {id, rc}
end function

integer regCount regCount = 1
sequence sharedClasses sharedClasses = {}
sequence sharedClassCount sharedClassCount = {}
-----------------------------------------------------------------------------
global procedure registerClass(object szClassName)

-- register the application class
atom wndClassEx
atom lAppIcon
sequence lClassStyle
integer lExtraWinSpace

    if atom(szClassName) then
        lClassStyle = vWindowClassStyle
        lExtraWinSpace = 0
    else
        if length(szClassName) = 3 and sequence(szClassName[1]) then
            lExtraWinSpace = szClassName[3]
        else
            lExtraWinSpace = 0
        end if
        lClassStyle = szClassName[2]
        szClassName = szClassName[1]
    end if

    lAppIcon = w32Func(xLoadIcon,{instance(),"exw"})
    if lAppIcon = 0 then
        lAppIcon = w32Func(xLoadIcon,{NULL,IDI_APPLICATION})
    end if

    -- get some memory for the window class structure
    wndClassEx = w32to_memory(0,ID_WNDCLASSEX, {w32or_all(lClassStyle),
                                                WndProcAddress,
                                                0,0,
                                                instance(),
                                                lAppIcon,
                                                NULL,
                                                (-WindowColor-1)+1,
                                                NULL,
                                                szClassName,
                                                lAppIcon
                                               })

    if w32Func(xRegisterClassEx,{wndClassEx}) = 0 then
        abortErr(Err_REGCLASS)
    end if

    w32release_mem(wndClassEx)

end procedure

--/topic System Attributes
--/func getClassName(integer id)
--/desc Gets the Windows Class name for the control.
--/ret SEQUENCE: The class name string
--
--Example
--/code
--      sequence lName
--      lName = getClassName(fld1)
--/endcode
global function getClassName(integer id)
sequence lResult
atom lMem
integer lSize

    lSize = 256
    lMem = w32acquire_mem(0, lSize)
    lSize = w32Func(xGetClassName,{getHandle(id), lMem, lSize})
    lResult = peek({lMem, lSize})
    w32release_mem(lMem)
    return lResult
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setTextColor(integer window, object color)
--/desc Set the text color to use when drawing text in /i window.
-- To set the color of the graphics pen, use /setPenColor.
--
-- Example:
--/code
--          -- draw text in red in TheWindow
--          /setTextColor(TheWindow, Red)
--          /wPuts(TheWindow, "This text is in red")
--          /setTextColor(TheWindow, "Cyan")
--          /wPuts(TheWindow, "This text is in cyan")
--/endcode


global procedure setTextColor(integer id, object color)

    -- set the text color for the window
    ctrl_Font[id][w32FontColor] = color

end procedure

-- Code from dEbUg_magic_box by Antonio Alessi
function get_effects(atom attrib)

    return  and_bits(attrib, CFE_BOLD)
           +and_bits(attrib, CFE_ITALIC)
           +and_bits(attrib, CFE_UNDERLINE)
           +and_bits(attrib, CFE_STRIKEOUT)

end function

function decodeREfont(integer id,sequence faceName)
atom color
sequence font_name

    color = ctrl_Font[id][w32FontColor]
    font_name = ctrl_Font[id][w32FontName]
    if length(faceName) = 0 then
        faceName = {color,font_name}

    elsif length(faceName) = 1 then
        if sequence(faceName[1]) then
            faceName = {color, faceName[1]}
        else
            faceName = {faceName[1], font_name}
        end if

    elsif length(faceName) = 2 then
        if sequence(faceName[1]) then
            if atom(faceName[2]) then
                faceName = {faceName[2], faceName[1]}
            else --Ooops I've got two sequences
                faceName = {color, faceName[2]}
            end if
        else
            if atom(faceName[2]) then -- I've got two atoms
                faceName = {faceName[1], font_name}
            end if
        end if
    elsif length(faceName) > 2 then
        faceName = {color, faceName}
    end if

    return faceName
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setFont(object id, sequence w32FontName, object size, object attributes)
--/desc Set the font for a control or window.
--
-- /i id can be either a single control's id, or a sequence list of ids.
--
-- /i w32FontName is the name of a font, eg. "Arial" /n
-- For RichEdit controls this parameter can also specify the color of the font.
-- In this case it takes to form {color, name}, eg.  {Red, "Arial"}
--
-- The /i attributes flag can be a atom that combines the following:
--
-- /li /b Normal
-- /li /b Bold
-- /li /b Italic
-- /li /b Underline
-- /li /b Strikeout
--
-- or a sequence of nine elements. This form is used when using non-TrueType
-- fonts or using some of the advanced features of the Windows font engine. /n
--
--/li[1] Attributes (eg Bold+Italic)
--/li[2] Average Char Width
--/li[3] Escapement  (How much it slopes in 10-degree increments)
--/li[4] Orientation (Should be set to the same as Escapement)
--/li[5] CharSet  (eg. ANSI_CHARSET, SYMBOL_CHARSET)
--/li[6] OutPrecision
--/li[7] ClipPrecision
--/li[8] Quality
--/li[9] PitchAndFamily
--
-- For RichEdit controls only, the /i attrib parameter can also prepend "ALL"
-- to the attrib sequence so that all the text is set to the font, otherwise
-- the change of font just applies to the insertion point.
--
-- For example:
--
--/code
--      -- change the font in MyWindow
--      setFont(MyWindow, "Arial", 10, Bold+Italic)
--      /wPuts(MyWindow, "This is Arial 10 point bold italic.")
--
--      setFont(MyWindow, "System", 14, {Bold,0,0,0,ANSI_CHARSET,0,0,0,0})
--
--      setFont(MyWindow, "Symbol", 10, {0,0,0,0,SYMBOL_CHARSET,0,0,0,0})
--
--      change all the text to courier.
--      setFont(MyRichEdit, "Courier New", 12, {"ALL",Normal})
--
--      -- Set a group of fields to all the same font.
--      setFont({fld1, fld3, fld2, fld7}, "Arial", 10, Normal)
--/endcode

global procedure setFont(object id, sequence faceName, object points, object attrib)
-- set the current font attributes
-- Window fonts are set as attributes for later assignment
atom
    hFont,
    color,
    effects,
    font_effect,
    dp2lp,hdc
sequence
    lResult
--, FontName,   -- PL 29/4/09
--  tracked,    -- PL 29/4/09
--  lres        -- PL 29/4/09
integer
-- PL 29/4/09
--  lPos,ppi
    ppi

    if atom(points) then
        points = floor(points+0.5)
    end if

    if sequence(id) then
        for i=1 to length(id) do
            setFont(id[i], faceName, points, attrib)
        end for
        return
    end if

    -- Note that the faceName is {color, "faceName"} for RichEdit
    if ctrl_Type[id] = RichEdit then
        -- Do some sanity checks on this parameter.

        faceName = decodeREfont(id,faceName)
        color = faceName[1]
        faceName = faceName[2]
        ctrl_Font[id][w32FontColor] = color

        font_effect = SCF_SELECTION
        if sequence(attrib) then
            if length(attrib) = 0 then
                attrib = Normal
            else
                if sequence(attrib[1]) then
                    if equal(attrib[1], "ALL") then
                        font_effect = SCF_ALL
                    else
                        font_effect = SCF_SELECTION
                    end if
                    attrib = attrib[2..length(attrib)]
                end if
                if length(attrib) = 0 then
                    attrib = Normal
                elsif length(attrib) = 1 then
                    attrib = attrib[1]
                end if
            end if
        end if

    end if

    ctrl_Font[id][w32FontName]   = faceName
    ctrl_Font[id][w32FontSize]   = points
    ctrl_Font[id][w32FontAttrib] = attrib

    if ctrl_Type[id] = RichEdit then
        effects = 0

        lResult = findTrackedObject(id, {faceName,points,attrib,color})
        if length(lResult) = 0 then
            if atom(attrib) then
                effects = get_effects(attrib)
            else
                effects = get_effects(attrib[1])
            end if
            hdc = getDC(id)
            ppi = w32Func(xGetDeviceCaps,{hdc,LOGPIXELSY})
            dp2lp = w32acquire_mem(0,8)
            poke4(dp2lp,{0,points*1440})
            VOID = w32Func(xDPtoLP,{hdc,dp2lp,1})
            points = floor(0.5+(peek4u(dp2lp+4)/ppi))
            releaseDC(hdc)
            w32release_mem(dp2lp)
            hFont = w32to_memory(0,ID_CHARFORMAT,{CFM_ALL,effects,points,0,color,0,0,faceName})

            -- track it
            trackObject({id,kFontObject},{hFont,{faceName,points,attrib,color}},ForProgram)
        else
            hFont = lResult[1]
        end if

        VOID = sendMessage(id, EM_SETCHARFORMAT, font_effect, hFont)

    elsif find(id,{Printer,Screen})
       or find(ctrl_Family[id], {WINDOW, PIXMAP, MENU, MENUITEM, POPUP}) then
        -- defer creation until print event
    else
        -- create now

        hFont = EzCreateFont(id, 0, faceName,
                             w32iff(sequence(points), points,points * 10), 0, attrib,
                             vFontResolution, 0)

        -- update immediately
        VOID = sendMessage(id, WM_SETFONT, hFont, w32True)

    end if

end procedure
r_setFont = routine_id("setFont")

sequence FontDefaults

--/topic System Attributes
--/func setCreateFont(sequence faceName, atom points, object attrib, atom color)
--/desc sets the font used for controls when they are created.
--/ret SEQUENCE: The previous values for the creation font.
--When controls are created, they need to have a font associated with them. By
-- default Win32lib initially uses "ms sans serif, 8 point, Normal. You
-- can use this function to set a different font for new controls rather than
-- change the font after they are created.
--
--Example
--/code
--      sequence oldFont
--      -- Set a special font to use.
--      oldFont = setCreateFont("Times New Roman", 14, Normal, Black)
--      -- Create some controls
--      fldA = create(Editbox, ...
--      fldB = create(Editbox, ...
--      fldC = create(List, ...
--      -- Restore fot to initial one.
--      VOID = setCreateFont(oldFont[1], oldFont[2], oldFont[3], oldFont[4])
--/endcode
global function setCreateFont(sequence faceName, atom points, object attrib, atom color)
sequence lOldFont
    lOldFont = FontDefaults

    FontDefaults = {faceName, floor(points+0.5), attrib, color}

    return lOldFont
end function

-- Grab the Win32lib default values from the system environment symbol "w32Defaults"

procedure GetDefaults()
object lDefaults

    -- Hardcoded defaults.
    FontDefaults = {"ms sans serif", 8, 0, Black}

    lDefaults = getenv("w32Defaults")
    if sequence(lDefaults) then
        lDefaults = w32MakeArgs(lDefaults, ',', ':')
        for i=1 to length(lDefaults) do
            if equal(lDefaults[i][w32AKey], "FONT") then
                if length(lDefaults[i]) = 2 then
                    FontDefaults = lDefaults[i][w32AValue]
                    if length(FontDefaults) = 0 then
                        FontDefaults = {{{},"Arial"}}
                    end if
                    if length(FontDefaults) = 1 then
                        FontDefaults = append(FontDefaults, {{},8})
                    end if
                    if length(FontDefaults) = 2 then
                        FontDefaults = append(FontDefaults, {{},Normal})
                    end if
                    if length(FontDefaults) = 3 then
                        FontDefaults = append(FontDefaults, {{},Black})
                    end if
                end if
                for j=1 to 4 do
                    FontDefaults[j] = FontDefaults[j][2]
                end for
            end if
        end for
    end if
end procedure
GetDefaults()

--/topic Rich Edit
--/func getSelectionFont(integer id)
--/desc Returns the address of a LOGFONT structure which describes the font used in the selection.
--/ret (ATOM) 0 on failure, address of the LOGFONT structure on success.
-- Failure will occur if the control is not a RichEdit, or if the character in the selected range don't have the same font.
-- You must free the returned memory when done with it.
global function getSelectionFont(integer id)
atom result

    result = 0
    if ctrl_Type[id]=RichEdit then
        result = w32to_memory(0,ID_CHARFORMAT, {0,0,0,0,0,0,0,""})
        VOID = sendMessage(id, EM_GETCHARFORMAT, SCF_SELECTION, result)
    end if
    return result
end function

--DEV temp:
function peek_string(atom addr)
atom last

    last = addr

    -- find the string's null terminator
    while peek(last) do
        last += 1
    end while

    if addr != last then
        return peek( {addr, last - addr} )
    else
        return ""
    end if

end function
------------------------------------+-----------------------------------------
global procedure createWindow(object id, sequence caption, atom owner, atom x, atom y, atom xSize, atom ySize, object styleFlags, object exFlags)
atom szClassName
-- PL 29/4/09
--atom hWnd, hParent, result, hMenu
atom hWnd, hParent, hMenu
atom lFlags, lExFlags, pstr
integer cloned,shared
object lColor

    cloned = sequence(id)
    hMenu = 0
    if not cloned then
        -- need to register each window, so each has seperate background
        -- color attributes, etc.
        szClassName = w32acquire_mem(0,sprintf("%s %d",{vAppName, regCount}))
        regCount += 1
        ctrl_ClassAddr[id] = szClassName

        registerClass(szClassName)
    else
        cloned = id[2]
        szClassName = ctrl_ClassAddr[cloned]
        id=id[1]
        shared = find(szClassName,sharedClasses)
        if shared then
            sharedClassCount[shared] += 1
        else
            sharedClasses = append(sharedClasses,szClassName)
            sharedClassCount &= 2
            hMenu=ctrl_Menu[cloned]
        end if
    end if

    -- if flags specified, combine them with the defaults
    if atom(styleFlags) then
     -- combine with user's values
        lFlags = or_bits(classStyle[ctrl_ActualClass[id]],styleFlags)
    else
        -- replace with user's values
        lFlags = w32or_all(styleFlags)
    end if

    -- extended flags
    if atom(exFlags) then
        lExFlags = or_bits(classStyleEx[ctrl_Type[id]],exFlags)
    else
        lExFlags = w32or_all(exFlags)
    end if

    if owner then
        hParent = getHandle(owner)
    else
        hParent = NULL
    end if

    pstr = w32acquire_mem(szClassName, caption)
--?{
--                                lExFlags,             -- extended style
--          peek_string(szClassName),           -- window class name
--          peek_string(pstr),  -- window caption
--                                lFlags,               -- window style
--                                x,                    -- initial x position
--                                y,                    -- initial y position
--                                xSize,                -- initial x size
--                                ySize,                -- initial y size
--                                hParent,              -- parent window handle
--                                hMenu,                -- window menu handle
--                                instance(),           -- program instance handle
--                                NULL}

    hWnd = w32Func(xCreateWindow,{
                                  lExFlags,             -- extended style
                                  szClassName,          -- window class name
                                  pstr,                 -- window caption
                                  lFlags,               -- window style
                                  x,                    -- initial x position
                                  y,                    -- initial y position
                                  xSize,                -- initial x size
                                  ySize,                -- initial y size
                                  hParent,              -- parent window handle
                                  hMenu,                 -- window menu handle
                                  instance(),           -- program instance handle
                                  NULL})                -- creation parameters

    if hWnd = 0 then
        abortErr(Err_CREATEWINDOW)
    end if


    -- save attributes
    vRecent[w32RecentWindow] = id
    setId(hWnd,id)
    ctrl_Handle[id] = hWnd
    ctrl_Handle_type[id] = kht_Window
    ctrl_Parent[id] = owner

    -- set the text and background colors

    --    setTextColor(id,w32Color_WINDOWTEXT)
    --    call_proc(r_setBackColor,{id,w32Color_WINDOW})
    if not cloned then
        lColor = ctrl_Bg_Color[id]
        setBackground(id, sequence(lColor),lColor)
    else
        ctrl_Bg_Color[id] = ctrl_Bg_Color[cloned]
    end if

    -- set default font
    setDefaultFont(id)
    setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])

    if owner != 0 then
        if and_bits(WS_VISIBLE, lFlags) then
            call_proc(r_openWindow, {id, Normal})
        end if

        if and_bits(WS_TABSTOP,lFlags) then
            -- add to the owner's focus_order list
            ctrl_Focus_order[owner] &= id
        end if
    end if


end procedure

-----------------------------------------------------------------------------

--/topic Attributes
--/proc makeFront(object id)
--/desc Brings to control to the front
--/i id can either be a control's id value or take the form {hWnd}.
--
--Example:
--/code
--      atom hwnd_MsgWindow
--      hwnd_MsgWindow = getHandle(MsgWindow)
--      . . .
--      -- Using a control id
--      makeFront(GroupX)
--      -- Using a hWnd
--      makeFront({hwnd_MsgWindow})
--/endcode

--------------------------------------------
global procedure makeFront(object id)
--------------------------------------------
atom hWnd

    if sequence(id) then
        hWnd = id[1]
    else
        if id = 0 then
            id = mainWindow
        end if
        hWnd = getHandle(id)
    end if
    VOID = w32Func(xSetForegroundWindow, {hWnd})

end procedure

procedure AddIconToImageList(integer pRtn, integer pIL, object pIcon)
    VOID = w32Func(pRtn, getHandle(pIL) & pIcon)
end procedure

procedure ILAddIcon(atom himl, atom hicon)
    AddIconToImageList(ImageList_AddIcon, himl, hicon)
end procedure

procedure ILAdd(atom himl, atom hbmImage, atom hbmMask)
    AddIconToImageList(ImageList_Add, himl, {hbmImage, hbmMask})
end procedure

procedure ILAddMasked(atom himl, atom hbmImage)
    AddIconToImageList(ImageList_AddMasked, himl, {hbmImage, getTransparentColor()})
end procedure

function bmpToMask(sequence bmp)

    bmp[1] = {split_rgb(getTransparentColor()), split_rgb(Black)}

    for i=1 to length(bmp[2]) do
        for j=1 to length(bmp[2][i]) do
            if bmp[2][i][j] then
                bmp[2][i][j] = 1
            end if
        end for
    end for

    return bmp
end function

--/topic Image Lists
--/func addEuBmp(bmp)
--/desc Adds EuBitmaps to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addEuBmp:
-- /li /b bmp is a sequence in Eu Bitmap form
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b xpm is a sequence of 3 Eu Bitmaps
--      used for /FlatToolBar
-- The Bitmaps passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
global function addEuBmp(object bmp)
sequence list, dib

    if length(bmp) = 1 then
        list = ilicon_list

        dib = {w32Func(CopyImage,{createDIB(bmp),IMAGE_BITMAP,32,32,LR_COPYDELETEORG}),
               w32Func(CopyImage,{createDIB(bmpToMask(bmp)),IMAGE_BITMAP,32,32,or_bits(LR_MONOCHROME,LR_COPYDELETEORG)})}

        ILAdd(ILlarge,dib[1],dib[2])
        ILAdd(ILsmall,dib[1],dib[2])

        VOID = w32Func(xDeleteObject,{dib[1]})
        VOID = w32Func(xDeleteObject,{dib[2]})

        list &= 0

        ilicon_list = list

    else

        list = FTB_images
        dib = repeat({},3)

        for i=1 to 3 do
            dib[i] = {w32Func(CopyImage,{createDIB(bmp[i]),IMAGE_BITMAP,32,32,LR_COPYDELETEORG}),
                      w32Func(CopyImage,{createDIB(bmpToMask(bmp[i])),IMAGE_BITMAP,32,32,or_bits(LR_MONOCHROME,LR_COPYDELETEORG)})}
        end for

        ILAdd(himlFTBDefault,dib[1][1],dib[1][2])
        ILAdd(himlFTBHot,dib[2][1],dib[2][2])
        ILAdd(himlFTBDisabled,dib[3][1],dib[3][2])

        for i=1 to 3 do
            VOID = w32Func(xDeleteObject,{dib[i][1]})
            VOID = w32Func(xDeleteObject,{dib[i][2]})
        end for

        list &= {{0,0,0}}
        FTB_images = list
    end if

    return length(list)

end function

integer pm
pm = 0

function createMonochromeDIB(atom hBmp)
-- PL 29/4/09
--atom dib, p, t, wide, tall
atom dib, p, t
sequence bmp, test

    if not pm then
        pm = call_func(r_createEx, {Pixmap, "", 0, 0, 0, 31, 31, 0, 0})
    end if

    call_proc(r_setPenColor,{pm, getTransparentColor()})
    drawRectangle(pm, 1, 1, 32, 32, w32True)
    drawBitmap(pm, hBmp, 0, 0)

    bmp = repeat(repeat(' ',32),32)
    test = bmp
    p = getPixel(pm, 1, 1)

    for i=1 to 30 do
        for j=1 to 30 do
            t = getPixel(pm, j, i)
            if t != p then
                bmp[i][j] = 'x'
            end if
            test[i][j] = t
        end for
    end for

    dib = textToBitmap(bmp)
    dib = w32Func(CopyImage,{dib, IMAGE_BITMAP, 32, 32, LR_MONOCHROME})

    return dib
end function

--/topic Image Lists
--/func addDIB(hBmp)
--/desc Adds DIB's to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addDIB:
-- /li /b hBmp is a handle to a DIB (see /createDIB)
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b hBmp is a sequence of 3 handles to DIBs
--      used for /FlatToolBar
-- The DIBs passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
-- NOTE: This function does not work very well, due to difficulties
-- in generating a mask for the image.  Use /addEuBmp or /addXpm if
-- possible.

global function addDIB(object hBmp)
integer iIcon
sequence list
object bmp


    if atom(hBmp) then
        list = ilicon_list
    else
        list = FTB_images
    end if

    iIcon = find(hBmp, list)

    if iIcon then
        return iIcon
    end if

    iIcon = length(list)

    if atom(hBmp) then

        bmp = w32Func(CopyImage,{hBmp, IMAGE_BITMAP, 32, 32, 0})

        ILAddMasked(ILlarge, hBmp)
        ILAddMasked(ILsmall, hBmp)

        VOID = w32Func(xDeleteObject,{hBmp})

        list &= hBmp
        ilicon_list = list

    else
        -- Need to use CopyImage, since the mask feature wrecks the image
        bmp = repeat({0,0},3)

        for i=1 to 3 do
            bmp[i][1] = w32Func(CopyImage,{hBmp[i], IMAGE_BITMAP, 32, 32, 0})
            bmp[i][2] = createMonochromeDIB(bmp[i][1])
        end for

        ILAdd(himlFTBDefault, bmp[2][1], bmp[1][2])
        ILAdd(himlFTBHot,     bmp[1][2], bmp[2][2])
        ILAdd(himlFTBDisabled,bmp[1][1], bmp[3][2])

        for i=1 to 3 do
            for j=1 to 2 do
                VOID = w32Func(xDeleteObject,{bmp[i][j]})
            end for
        end for

        list &= {hBmp}
        FTB_images = list

    end if


    return iIcon+1

end function
r_addDIB = routine_id("addDIB")

--/topic Image Lists
--/func addXpm(xpm)
--/desc Adds xpm's to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addXpm:
-- /li /b xpm is an xpm sequence
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b xpm is a sequence of 3 xpm's
--      used for /FlatToolBar
-- The xpm's passed for the /FlatToolBar should be the xpms to be used
-- for the default, hot and disabled images, respectively.
global function addXpm(sequence xpm)
sequence xpm_mask, himl
object hIcon, iIcon
object hbmp, hmask

    if length(xpm) = 3 then
        xpm_mask = {}
        hIcon = {}

        himl = {himlFTBDefault, himlFTBHot, himlFTBDisabled}
        for i=1 to 3 do

            hbmp = createDIB(xpmToEuBmp(xpm[i]))

            hmask = createDIB(bmpToMask(xpmToEuBmp(xpm[i])))

            hbmp  = w32Func(CopyImage,{hbmp,IMAGE_BITMAP,32,32,LR_COPYDELETEORG})
            hmask = w32Func(CopyImage,{hmask,IMAGE_BITMAP,32,32,or_bits(LR_MONOCHROME, LR_COPYDELETEORG)})

            ILAdd(himl[i], hbmp, hmask)
            hIcon &= hbmp

        end for

        FTB_images &= {hIcon}
        iIcon = length(FTB_images)
    else
        hbmp = createDIB(xpmToEuBmp(xpm))
        hmask = createDIB(bmpToMask(xpmToEuBmp(xpm)))
        ILAdd(ILlarge, hbmp, hmask)
        ILAdd(ILsmall, hbmp, hmask)
        ilicon_list &= hbmp
        iIcon = length(ilicon_list)
    end if


    return iIcon
end function

-----------------------------------------------------------------------------
procedure createTabItem(integer id, sequence caption, integer pOwner,integer tabNumber,integer imgIndex)

-- insert a tab into a tab control
integer numItems,mask
atom hTabData, hTabItem

    if ctrl_Type[pOwner] != TabControl then
        abortErr(Err_CREATETABITEM2)
    end if

    numItems = length(ctrl_Specific[pOwner])
    -- get tab index
    if tabNumber<=0 or tabNumber>numItems+1 then
        tabNumber = numItems
    else
        tabNumber -= 1
    end if

    -- Allocate a tab structure
    hTabData = w32acquire_mem(0,SIZEOF_TC_ITEM)

    if imgIndex>0 then
        if ctrl_Menu[pOwner]=0 then
            VOID = sendMessage(pOwner,TCM_SETIMAGELIST,0,hILsmall)
            ctrl_Menu[pOwner] = hILsmall
        elsif ctrl_Menu[pOwner]!=hILsmall then
            imgIndex = w32Func(ImageList_AddIcon,{ctrl_Menu[pOwner],ilicon_list[imgIndex]})+1
        end if
    end if

    if imgIndex>0 then
        mask = TCIF_TEXT+TCIF_IMAGE
    else
        mask = TCIF_TEXT
    end if

    w32store(hTabData, TC_ITEM_mask, mask)
    w32store(hTabData, TC_ITEM_iImage, imgIndex-1)
    w32store(hTabData, TC_ITEM_pszText, caption)

    -- insert into tab list
    hTabItem = sendMessage(pOwner, TCM_INSERTITEM, tabNumber, hTabData)

    -- add id to owner's tab list
    if hTabItem = -1 then
        abortErr(Err_CREATETABITEM)
    elsif tabNumber=numItems then
        ctrl_Specific[pOwner] &= id
    else
        ctrl_Specific[pOwner] = w32insertElement(ctrl_Specific[pOwner],tabNumber+1,id)
    end if

    -- store the handle
    ctrl_Handle[id]  = ctrl_Handle[pOwner] --hTabItem
    ctrl_Handle_type[id] = kht_TabItem

    w32release_mem(hTabData)

    vRecent[w32RecentWindow] = id

end procedure



--/topic Attributes
--/func isTopLevelWindow(integer id)
--/desc Used to determine if the /i id is a Window that acts independently of other windows.
--/ret INTEGER: w32True or w32False
--
--Example:
--/code
--      if isTopLevelWindow(xx) then
--          moveWindow( . . . )
--      end if
--/endcode

global function isTopLevelWindow(integer id)

    if ctrl_Family[id]=WINDOW
    and and_bits(WS_CHILD,w32Func(xGetWindowLong,{getHWND(id),GWL_STYLE}))=0 then
        return w32True
    end if

    return w32False
end function

--/topic Attributes
--/func findParentWindow(integer id)
--/desc Used to get the Window id of the control specified by /i id
--/ret The id of the Window or zero if this /i id is not in a window.

global function findParentWindow(integer id)
    ----------------------------------------------------------
    -- find the parent window
    if id<0 or ctrl_Parent[id] = 0 then
        -- This is already the top level.
        return id
    end if
    -- loop until I hit top of the tree or a Window control.
    while id and ctrl_Type[id] != Window and isTopLevelWindow(id) = w32False do
        -- move up
        id = ctrl_Parent[id]
    end while
    return id
end function


--/topic System Attributes
--/func getActiveWindow()
--/desc Returns the /b id of the control that the user is working on.
--/ret INTEGER: The id of the window or 0 if the app does not have an active window.
--You can use this to find out if the application is currently the active one.
--
--Example:
--/code
--      integer ActiveID
--      ActiveID = getActiveWindow()
--      if ActiveID = 0 then
--          -- No window for this app is active
--      else
--          -- I have an active window.
--      end if
--/endcode
global function getActiveWindow()
atom lId

    lId = getId(w32Func(xGetForegroundWindow, {}))
    if not validId(lId) then
        lId = 0
    end if

    return lId
end function

--/topic Attributes
--/func findParent(object id)
--/desc Used to find the owning control for the specified /i id.
--/ret The id of the control that owns the one specified.
-- This can be used for TreeView items as well by using the syntax for /i id
-- as {TV, TVItemId}
--
-- If the /i id has no parent, this function returns 0. /n
-- If the /i id is invalid, this function returns -1. /n

global function findParent(object id)
integer lOwner

    if sequence(id) then
        if ctrl_Type[id[1]] = TreeView then
            if id[2] > 0 and id[2] <= length(tvitem_data) then
                lOwner = tvitem_parent[id[2]]
            else
                lOwner = -1
            end if
        else
            lOwner = -1
        end if
    else
        lOwner = ctrl_Parent[id]
    end if

    return lOwner
end function
r_findParent = routine_id("findParent")


--/topic Attributes
--/func getParent(object id)
--/desc an alias for /findParent
--/ret The id of the control that owns the one specified.

global function getParent(object id)
    return findParent(id)
end function

-- these internal variables allow reentrancy for the window enumerator
-- in cas several requests are processed at the same time
integer enumRequests enumRequests=0 -- counter for requests
sequence hrequests hrequests={}     -- list of handles being queried
sequence crequests crequests={}     -- list of result lists

function childenum(atom h,integer index)
    if w32Func(xGetParent,{h})=hrequests[index] then
        crequests[index] &= h       -- only return level 1 children
    end if
    return w32True
end function

--/topic Attributes
--/func findChildren(integer id)
--/desc Used to find all the children controls contained in the specified /i id.
--/ret SEQUENCE: Zero or more subsequences {id, controlType}.
-- Each subsequence returned has the control id and the control's type, for
--all the controls owned by /i id. /n
-- It returns an empty sequence if the /i id has no children created by the application.
-- As a result, subclassed controls have no children unless you create some, or unless they have items, like menus or tab controls.
--
--/see /getChildren
--
--Example
--/code
--    sequence children
--    -- Get a list of all the controls owned by this window
--    children = findChildren(myWin)
--
--    -- Set the caption for each of the PushButtons.
--    for i=1 to length(children) do
--       if find(children[i][2],{PushButton,DefPushButton}) then
--          setText(children[i][1], sprintf("Button%d", i))
--       end if
--    end for
--/endcode

global function findChildren(integer id)
sequence lChildren
integer thisRequest -- request index for enumerating child windows

    lChildren = {}
    if ctrl_Type[id] = TabItem then

        for i=1 to length(ctrl_Group[id]) do
            lChildren &= {{ctrl_Group[id][i], ctrl_Type[ctrl_Group[id][i]]}}
        end for

    elsif ctrl_Type[id] = TabControl then
        -- Can only allow tabitems to be children
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i] = id and ctrl_Type[i] = TabItem then
                lChildren &= {{i, ctrl_Type[i]}}
            end if
        end for
    elsif ctrl_FormerId[id] and not length(ctrl_Group[id]) then
    -- subclassed control
        hrequests &= getHandle(id)
        crequests = append(crequests,{})
        enumRequests+=1
        thisRequest=enumRequests
        VOID=w32Func(xEnumChildWindows,{getHandle(id),call_back(routine_id("childenum")),enumRequests})
        lChildren=crequests[thisRequest]
        for i=1 to length(lChildren) do
            lChildren[i] = {lChildren[i]}
        end for
    else
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i] = id then
                lChildren &= {{i, ctrl_Type[i]}}
            end if
        end for
    end if
    return lChildren
end function
r_findChildren = routine_id("findChildren")

--/topic Attributes
--/func getChildren(integer id)
--/desc Used to get all the child controls contained in the specified /i id.
--/ret SEQUENCE: Contains two subsequences {{idlist}, {controlTypes}}.
-- The first subsequences is a list of all the child controls' ids. /n
-- The second subsequence is a list of their corresponding control type codes. /n
-- It returns an empty subsequences if the /i id has no children.
--
--/see /findChildren
--
--Example
--/code
--    sequence children
--    -- Get a list of all the controls owned by this window
--    children = getChildren(myWin)
--
--    -- Set the caption for each of the PushButtons.
--    for i=1 to length(children) do
--       if find(children[2][i],{PushButton,DefPushButton}) then
--          setText(children[1][i], sprintf("Button%d", i))
--       end if
--    end for
--/endcode
global function getChildren(integer id)
sequence lChildren
integer thisRequest

    lChildren = {{},{}}
    if ctrl_Type[id] = TabItem then

        for i=1 to length(ctrl_Group[id]) do
            lChildren[1] &= ctrl_Group[id][i]
            lChildren[2] &= ctrl_Type[ctrl_Group[id][i]]
        end for

    elsif ctrl_Type[id] = TabControl then
        -- Can only allow tabitems to be children
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i] = id and ctrl_Type[i] = TabItem then
                lChildren[1] &= i
                lChildren[2] &= ctrl_Type[i]
            end if
        end for

    elsif ctrl_FormerId[id] and not length(ctrl_Group[id]) then
    -- subclassed control
        hrequests &= getHandle(id)
        crequests = append(crequests,{})
        enumRequests+=1
        thisRequest=enumRequests
        VOID=w32Func(xEnumChildWindows,{getHandle(id),call_back(routine_id("childenum")),enumRequests})
        lChildren={crequests[thisRequest]}
    else
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i] = id then
                lChildren[1] &= i
                lChildren[2] &= ctrl_Type[i]
            end if
        end for
    end if

    return lChildren
end function

procedure copyTVChildren(sequence id,atom index,atom struct,atom instruct)
integer parent,idx
atom hSource,newchild,newdest

    parent = tvitem_owner[index]
    hSource = tvitem_handle[id[2]]
    w32store(instruct,TVINSERTSTRUCT_hParent,index)
    newchild = sendMessage(parent,TVM_GETNEXTITEM,TVGN_CHILD,hSource)
    while newchild do
        idx = find(newchild,tvitem_handle)
        w32store(struct,TVITEM_hItem,newchild)
        VOID = sendMessage(parent,TVM_GETITEM,0,struct)
        newdest = sendMessage(id[1],TVM_INSERTITEM,0,instruct)
        tvitem_handle[idx] = newdest
        if w32fetch(struct,TVITEM_cChildren) then
            copyTVChildren({id[1],idx},newdest,struct,instruct)
            w32store(instruct,TVINSERTSTRUCT_hParent,index)
        end if
        newchild = sendMessage(parent,TVM_GETNEXTITEM,TVGN_NEXT,newchild)
    end while
end procedure

--/topic Menus
--/func removeMenu(integer id,integer item,integer flag,integer reuse)
--/desc Removes a menu item from a menu.
--/ret (INTEGER) w32False on failure, else nonzero.
-- /i item is a 0-based index if /i flag is w32False, else an item id which must belong
-- to the menu /i id (or the menu bar of the window /i id).
-- If /i reuse is w33False, Windows is asked to free the memory of the menu, effectively destroying /i item. 
--  By passing another value, and if /i item is a menu, the function will leave the internal data alone and 
--  return the handle.

global function removeMenu(integer id,integer item,integer flag,integer reuse)
atom hmenu
integer routine,pos

    if flag then
        item = getMenuPosn(item)
    end if
    if ctrl_Family[id]=WINDOW then
        hmenu = ctrl_Menu[id]
    elsif ctrl_Family[id]=MENU then
        hmenu = w32lookup(id,menu_ids,menu_handles)
    else
        return 0
    end if
    if ctrl_Family[item]=MENUITEM or not reuse then
        routine = xDeleteMenu
    else
        routine = xRemoveMenu
    end if
    if ctrl_Family[item]=MENU and not reuse then
        pos = find(ctrl_Group[id][item+1],menu_ids)
        menu_handles = w32removeIndex(pos,menu_handles)
        --ctrl_Menu[menu_ids[pos]] = -1
        menu_ids = w32removeIndex(pos,menu_ids)
    end if
    return w32Func(routine,{hmenu,item,MF_BYPOSITION})
end function

function insertMenu(atom hp,atom id_or_h,object index,atom struct,integer flag,integer is_id)
integer id,lRC,pos
sequence s
integer pNewParent

    pNewParent=getId(hp)

    if atom(index) then
        if index=MP_END then
            index={MP_END}
        elsif index >=0 then
            index={MP_AT,floor(index)}
        else
            index={MP_END}
        end if
    end if
    if index[1]!=MP_END then
        if index[2]<0 then
            index[2] = -(index[1]=MP_AFTER)
        elsif index[1]!=MP_AT and not find(index[2],ctrl_Group[pNewParent]) then
            index[1] = MP_END
        elsif index[1]=MP_AFTER and index[2]=ctrl_Group[pNewParent][length(ctrl_Group[pNewParent])] then
            index[1] = MP_END
        elsif index[1]=MP_AT and index[2]>w32Func(xGetMenuItemCount,{hp}) then
            index[1] = MP_END
        end if
    end if

    if not is_id then
        id = call_func(r_subClassControl,{{Menu,pNewParent},id_or_h})
    else
        id = id_or_h
    end if
    flag += MF_BYPOSITION

    if index[1]=MP_END then
        if ctrl_Family[id]=MENU and is_id then
            lRC = w32Func(xAppendMenu,{hp,flag,ctrl_Handle[id],struct})
        else
            lRC = w32Func(xAppendMenu,{hp,flag,id_or_h,struct})
        end if
        if lRC then
            ctrl_Group[pNewParent] &= id
        end if
    else
        if index[1]=MP_AT then
            pos = index[2]
        elsif index[2]=-1 then
            pos = 0
        else
            pos = getMenuPosn(index[2])+(index[1]=MP_AFTER)
        end if
        if ctrl_Family[id]=MENU and is_id then
            lRC = w32Func(xInsertMenu,{hp,pos,flag,getHandle(id),struct})
        else
            lRC = w32Func(xInsertMenu,{hp,pos,flag,id,struct})
        end if
        if lRC then
            s = ctrl_Group[pNewParent]&0
            s[pos+2..length(s)] = s[pos+1..length(s)-1]
            s[pos+1] = id
            ctrl_Group[pNewParent] = s
        end if
    end if

    if lRC then
        return id
    else
        return 0
    end if
end function

--/topic Menus
--/func attachMenuHandle(atom hMenu, integer newparent,object index,sequence caption)
--/desc Changes (or sets) the parent of the control /i id to /i newparent, using the /i index attachment data if it is relevant.
--/ret INTEGER: True if successful otherwise False.
-- This function works like /setPrent, but targets menus whose only the handle is known.
-- They may have been created from a memory template. Since such a menu has no caption,
-- you must supply one.

global function attachMenuHandle(atom hMenu, integer pNewParent,object index,sequence caption)
integer menubar,lRC
atom struct,hp,lOldParent

    if not w32Func(xIsMenu,{hMenu}) or not validId(pNewParent) then
        return 0
    end if

    hp=w32Func(xGetParent,{hMenu}) -- hopefully works
    if hp then
        if w32Func(xIsWindow,{hp}) and hMenu=w32Func(xGetMenu,{hp}) then
            return 0 -- don't reparent the menu bar
        end if
    end if

    menubar=0
    if ctrl_Family[pNewParent]=WINDOW then
    -- inserting into a menu bar
        lOldParent = hp
        hp = ctrl_Menu[pNewParent]
        pNewParent = w32lookup(hp,menu_handles,menu_ids)
        menubar = 1
    end if

    if ctrl_Family[pNewParent]!=MENU then
        return 0
    end if

    struct = w32acquire_mem(0,caption)

    lRC = insertMenu(hp,hMenu,index,struct,MF_POPUP,0)

    if lRC and menubar then
        VOID = w32Func(xDrawMenuBar,{lOldParent})
    end if
    w32release_mem(struct)

    return lRC
end function

--/topic Attributes
--/func setParent(integer id, integer newparent,object index)
--/desc Changes (or sets) the parent of the control /i id to /i newparent, using the /i index attachment data if it is relevant.
--/ret INTEGER: True if successful otherwise False.
--
-- When /id is a menu or menu item, /i index is a sequence {position_type,position_value,caption}:
--/li If position_type is MP_AT, position_value is an item 1-based index before which to insert.
--/li If position_type  is MP_BEFORE or MP_AFTER, position_value is a menu(item) identifier.
--/If position_type  is MP_END, the item is inserted at the end and position_value is ignored.
-- If index is an atom, it is assumed to mean {MP_END} if <0, and {MP_AT,index} otherwise.
-- You may optionally supply an alternate caption for parented items. Do so by including the new 
--  caption string as the third element of /i index.
--
-- When /i id references a TabItem, /i index is the new 1-based index it is suppose to have in its new parent.
-- Note that it is unsafe to change the parent of a subclassed TabControl or TabItem, since Windows doesn't 
--  keep track of the controls that display when some tab item is selected.
--
-- When /id is a sewuence {TV_id,TVitem_id}, /i index is a pair {new TVitem_id of parent, position}. 
--  The position is either a 1-based one to insert before, or any of:
--/li TVI_FIRST: insert as first child of parent
--/li TVI_LAST: insert as last child
--/li TVI_SORT: insert and then sort children of the parent in alphabetical ascending order.
-- To specify the root of a tree view, use indifferently 0 or the TVI_ROOT constant.
--
-- When /i id is a sequence and /i id[1] is a ListView, /i id[2] is an item id if /i id has more elements, 
--  or a 1-based position otherwise. Then, index is the position at which to insert in the target ListView.
--
-- Otherwise, index is {x,y}, the new position of the control, and the control /i id gets focus.

global function setParent(integer id, integer pNewParent,object index)
integer lRC,pos,flag,menubar,release
-- PL 29/4/09
--atom lOldParent,struct,instruct,hp
atom lOldParent,struct,hp
object data
sequence s

    if validId(pNewParent) = w32False or atom(ctrl_Group[pNewParent]) then   -- invalid parent
        return w32False
    end if

    if validId(id) = w32False then  -- invalid control
        return w32False
    end if

    if sequence(ctrl_Group[pNewParent]) and find(id,ctrl_Group[pNewParent]) then
    -- control already a child of the new parent
        return w32False
    end if

    if and_bits(classAttr[ctrl_Type[id]],w32Toolbar) then
        ctrl_Toolbar[ctrl_Parent[id]] = w32removeItem(id,ctrl_Toolbar[ctrl_Parent[id]])
        ctrl_Toolbar[pNewParent] &= id
    end if
    if and_bits(classAttr[ctrl_Type[id]],w32Statusbar) then
        ctrl_Statusbar[ctrl_Parent[id]] = 0
        ctrl_Statusbar[pNewParent] = id
    end if
    -- adjust ctrl_Focus_order
    data = ctrl_Focus_order[ctrl_Parent[id]]
    if sequence(data) and find(id,data) then
        ctrl_Focus_order[ctrl_Parent[id]] = w32removeItem(id,data)
    end if
    data = ctrl_Focus_order[pNewParent]
    if sequence(data) then
        ctrl_Focus_order[pNewParent] &= id
    end if

    hp = getHandle(pNewParent)
    release=1

    if find(ctrl_Family[id],{MENU,MENUITEM}) then
        if ctrl_Family[ctrl_Parent[id]] = WINDOW then
        -- don't reparent the menu bar
            return 0
        end if
        menubar=0
        if ctrl_Family[pNewParent]=WINDOW then
        -- inserting into a menu bar
            lOldParent = hp
            hp = ctrl_Menu[pNewParent]
            pNewParent = w32lookup(hp,menu_handles,menu_ids)
            menubar = 1
        end if
        if ctrl_Family[pNewParent]!=MENU then
            return 0
        end if

        if sequence(index) and length(index)>=3 then
            struct = w32acquire_mem(0,index[3])
        else
            struct = w32acquire_mem(0,call_func(r_getCaption,{id}))
        end if

        flag = w32Func(xGetMenuState,{ctrl_Handle[ctrl_Parent[id]],getMenuPosn(id),MF_BYPOSITION})
        if ctrl_Family[id]=MENU then
            flag = and_bits(flag,#FF)
        end if

        lRC = insertMenu(hp,id,index,struct,flag,1)

        if lRC then
            VOID = w32Func(xRemoveMenu,{ctrl_Handle[ctrl_Parent[id]],find(id,ctrl_Group[ctrl_Parent[id]])-1,MF_BYPOSITION})
            ctrl_Group[ctrl_Parent[id]] = w32removeItem(id,ctrl_Group[ctrl_Parent[id]])
            if menubar then
                VOID = w32Func(xDrawMenuBar,{lOldParent})
            end if
        end if
    elsif ctrl_Type[id]=TabItem then
        struct = w32acquire_mem(0,SIZEOF_TC_ITEM)
        w32store(struct,TC_ITEM_mask,TCIF_TEXT+TCIF_IMAGE+TCIF_PARAM)
        pos = find(id,ctrl_Specific[ctrl_Parent[id]])
        if pos then
            pos -= 1
            index -= 1
            VOID = sendMessage(ctrl_Parent[id],TCM_GETITEM,pos,struct)
            lRC = sendMessage(pNewParent,TCM_INSERTITEM,index-(index>0),struct)
            if lRC then  -- can optimise when the parent remains the same
                ctrl_Group[pNewParent] &= id
                s = ctrl_Specific[pNewParent]&0
                s[index+1..length(s)] = s[index..length(s)-1]
                s[index] = id
                ctrl_Specific[pNewParent] = s
                if pNewParent!=ctrl_Parent[id] then
                    for i=1 to length(ctrl_Group[id]) do
                        VOID = w32Func(xSetParent,{getHandle(ctrl_Group[id][i]),hp})
                    end for
                end if
                VOID = sendMessage(ctrl_Parent[id],TCM_DELETEITEM,pos,0)
                ctrl_Group[ctrl_Parent[id]] = w32removeItem(id,ctrl_Group[ctrl_Parent[id]])
                ctrl_Specific[ctrl_Parent[id]] = w32removeItem(id,ctrl_Specific[ctrl_Parent[id]])
            end if
        end if
--PL removed 28/4/09: (this follows "elsif ctrl_Type[id]=TabItem then"!!)
--  elsif sequence(id) then
--      if not integer(id[1]) or not integer(id[2]) then
--          return 0
--      end if
--      if ctrl_Type[id[1]]=TreeView then
--          if not validId(id) or not validId({pNewParent,index[1]}) then
--              return 0
--          end if
--          hp=tvitem_handle[id[2]]
--          mask = TVIF_TEXT+TVIF_STATE+TVIF_PARAM+TVIF_IMAGE+TVIF_SELECTEDIMAGE+TVIF_CHILDREN
--          struct=w32to_memory(0,ID_TVITEM, {mask,hp,0,0,0,0,0,0,0,0})
--          instruct=w32to_memory(0,ID_TVINSERTSTRUCT, index & struct)
--          lRC=sendMessage(id[1],TVM_GETITEM,0,struct)
--          if lRC then
--              pos=tvitem_parent[id[2]]
--              lOldParent=sendMessage(pNewParent,TVM_INSERTITEM,0,instruct)
--              if lOldParent then
--                  tvitem_parent[id[2]] = index[1]
--                  tvitem_owner[id[2]] = tvitem_owner[index[1]]
--                  tvitem_handle[id[2]] = lOldParent
--                  -- now copy the children, if any
--                  if w32fetch(struct,TVITEM_cChildren) then
--                      w32store(instruct,TVINSERTSTRUCT_hInsertAfter,TVI_LAST)
--                      copyTVChildren(id,tvitem_handle[index[1]],struct,instruct)
--                  end if
--                  VOID=sendMessage(id[1],TVM_DELETEITEM,0,hp)
--                  lRC=1
--              else
--                  lRC=0
--              end if
--          end if
--          w32release_mem(instruct)
--      elsif ctrl_Type[id[1]]=ListView then
--          if ctrl_Type[pNewParent]!=ListView then
--              return 0
--          end if
--          if length(id)>2 then
--              struct = w32acquire_mem(0,20)
--              poke4(struct,LVFI_PARAM)
--              poke4(struct+8,id[2])
--              id[2] = sendMessage(id[1],LVM_FINDITEM,-1,struct)
--              w32release_mem(struct)
--          else
--              id[2] -= 1
--          end if
--          if id[2]<0 or id[2]>=sendMessage(id[1],LVM_GETITEMCOUNT,0,0) or not integer(index) then
--              return 0
--          end if
--          struct = w32acquire_mem(0,SIZEOF_LVITEM)
--          w32store(struct,LVITEM_mask,LVIF_TEXT+LVIF_PARAM+LVIF_IMAGE+LVIF_STATE)
--          w32store(struct,LVITEM_stateMask,LVIS_DROPHILITED+LVIS_CUT+LVIS_FOCUSED+LVIS_SELECTED)
--          w32store(struct,LVITEM_iItem,id[2])
--          w32store(struct,LVITEM_iSubItem,0)
--          VOID = sendMessage(id[1],LVM_GETITEM,0,struct)
--          index -= 1
--          if index<0 then
--              index = 0
--          end if
--          lRC = sendMessage(pNewParent,TVM_INSERTITEM,0,struct)
--          if lRC>=0 then
--              VOID = sendMessage(id[1],LVM_DELETEITEM,0,struct)
--          end if
--      else
--          return 0
--      end if
    else
        release = 0
        lRC = (pNewParent=0)!=(ctrl_Parent[id]=0)
        if lRC and not ctrl_Parent[id] then
            removeStyle(id,WS_POPUP)
            addStyle(id,WS_CHILD)
        end if
        lOldParent = w32Func(xSetParent, {getHandle(id), hp})
        if ctrl_Parent[id] then
            ctrl_Group[ctrl_Parent[id]] = w32removeItem(id,ctrl_Group[ctrl_Parent[id]])
        end if
        ctrl_Parent[id] = pNewParent
        if lRC and not pNewParent then
            removeStyle(id,WS_CHILD)
            addStyle(id,WS_POPUP)
        end if
        lRC = (lOldParent!=0)
        call_proc(r_setCtlPosition,id & index)
        call_proc(r_setFocus,{id})
    end if

    if release then
        w32release_mem(struct)
    end if
    if lRC = 0 then
        return w32False
    else
        return w32True
    end if

end function


--/topic Attributes
--/proc registerHotKey(integer id, object caption)
--/desc Allows you to associate a ALT-key combination to set focus to a control.
-- Any control or Window can have any number of hotkeys registered. /n
-- /i id is the control/window id returned by /create() /n
-- /i caption is either a single keycode, or a string containing a '&' character. /n
-- If using a keycode, you must use the keycode names in w32Keys.e. If using a string,
-- the uppercase version of the character following the '&' is used. /b Note that this
-- is happens automatically when you /create() a control with some caption text. Also,
-- the default pushbutton, if any, is automatically registered with VK_RETURN.
--
-- Typical use of this procedure is when a control is created without a caption.
--
-- example:
--/code
--       -- Attached the '+' keys to the addBtn control.
--       registerHotKey(addBtn, VK_ADD)
--       registerHotKey(addBtn, VK_OEM_PLUS)
--/endcode

-----------------------------------------------------------------------------
global procedure registerHotKey(integer id, object caption)

-- register the hotkey with the parent window
integer at, parent, key

    -- find the parent window
    parent = findParentWindow(id)
    if parent = 0 then
        return
    end if

    -- is this a default key?
    if ctrl_Type[id] = DefPushButton then
        -- associate the return key with the control
        ctrl_Hotkey_Keys[parent] &= VK_RETURN
        ctrl_Hotkey_Ids[parent]  &= id
    end if

    if sequence(caption) then
        -- is there a hotkey in the caption?
        at = find('&', caption)
        if at=0 or at=length(caption) then
            return -- no hotkey symbol
        else
            key = upper(caption[at+1]) -- convert the key to upper case
        end if
    else
        key = caption
    end if
    -- register the key with the parent
    ctrl_Hotkey_Keys[parent] &= key
    ctrl_Hotkey_Ids[parent]  &= id

end procedure

global constant
w32GFD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCRIPTSONLY+CF_SCREENFONTS+CF_EFFECTS+CF_FORCEFONTEXIST,
w32GFD_OLD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCREENFONTS+CF_EFFECTS
-----------------------------------------------------------------------------
--/topic Dialogs
--/func getFontDialogEx(window, atom flags, object extra)
--/desc "Get Font" Dialog. /i flags controls which fonts are selectable, as well as other features of the dialog.
--/ret SEQUENCE: {font name, points, style flags, color} or -1 if cancelled.
-- flags is the sum of various flags. Supported values to add up are:
--/li /b CF_SCREENFONTS: get screen fonts
--/li /b CF_PRINTERFONTS: get printer fonts
--/li /b CF_BOTH  = CF_SCREENFONTS + CF_PRINTERFONTS,
--/li /b CF_SHOWHELP: dialog box has a help button. The parent window is responsible for displaying help. 
--/li /b CF_ENABLEHOOK: specify the address of a hook procedure for the dialog box
--/li /b CF_ENABLETEMPLATE: specify a module name and template name to override the default one
--/li /b CF_ENABLETEMPLATEHANDLE: specify a handle to a memory block containing a template to override the default
--/li /b CF_INITTOLOGFONTSTRUCT: the current font of the control sets the initially displayed values
--/li /b CF_USESTYLE: specifies an initialisation string for the font style combo box
--/li /b CF_EFFECTS: when used, the dialog box allows to select a color, as well as the underlined or struck out styles for a font
--/li /b CF_APPLY: displays an Apply button. Requires the CF_ENABLEHOOK flag.
--/li /b CF_SCRIPTSONLY: displays all fonts NOT based on the OEM or Symbol character set.
--/li /b CF_NOVECTORFONTS: don't display vector fonts
--/li /b CF_NOOEMFONTS   = CF_NOVECTORFONTS
--/li /b CF_NOSIMULATIONS: don't display fonts that are emulated by GDI
--/li /b CF_LIMITSIZE: sizes outside specified range will not be shown.
--/li /b CF_FIXEDPITCHONLY: only display fixed pitch fonts
--/li /b CF_WYSIWYG: display only fonts which are available on both the screen and printer.
--      The CF_BOTH and CF_SCALABLEONLY flags will be assumed
--/li /b CF_FORCEFONTEXIST: cause an error if a font or style that doesn't exist is selected
--/li /b CF_SCALABLEONLY: only display scalable fonts (among which TrueType, vector fonts, ...)
--/li /b CF_TTONLY: only display TrueType fonts
--/li /b CF_NOFACESEL: when the CF_INITTOLOGFONTSTRUCT is used, don't initialise the font name combo box edit field
--/li /b CF_NOSTYLESEL: when the CF_INITTOLOGFONTSTRUCT is used, don't initialise the font style combo box edit field
--/li /b CF_NOSIZESEL: when the CF_INITTOLOGFONTSTRUCT is used, don't initialise the font size combo box edit field
--/li /b CF_SELECTSCRIPT: only allow fonts based on specified character set
--/li /b CF_NOSCRIPTSEL: don't display the character set combo box
--/li /b CF_NOVERTFONTS: don't display vertical fonts (their names often starts with '@')
--
-- In addition, two canned flag combinations are provided:
--/li w32GFD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCRIPTSONLY+CF_SCREENFONTS+CF_EFFECTS+CF_FORCEFONTEXIST,
--     (default value corresponding to a call to getFontDialog())
--/li w32GFD_OLD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCREENFONTS+CF_EFFECTS
--     (in library versions prior to v0.56, default value corresponding to a call to getFontDialog())
--
-- The /i extra argument can be any atom or a sequence of pairs. The first element of the 
-- pair is a flag name as above, and the second element depends on the flag. Only some values
-- for the flag are supported (and meaningful).
-- Conversely, if you specify a flag listed below, you must supply the corresponding extra data.
-- Results are undefined if extra data is missing when the use of a flag would require some.
--/li If the CF_SELECTSCRIPT flag is given, the second element is a character set identifier.
-- See a complete list of these *_CHARSET constants in w32constants.ew.
--/li If the CF_LIMITSIZE flag is given, the second element is a pair {lower bound, upper bound}.
-- Sizes are measured in points.
--/li If the CF_USESTYLE flag is used, the second element is either a string or the address of a buffer for it.
--/li If the CF_ENABLETEMPLATE is used, the second element is a pair {module handle, template name} or 
--      {module handle,template name address}.
--/li If the CF_ENABLETEMPLATEHANDLE is used, the second element is a handle to a memory block holding the requested template.
--/li If the CF_ENABLEHOOK flag is used, then second element is the address of a hook procedure,
-- or a pair {hook address, pointer to custom data}.
--/li If the CF_INITTOLOGFONTSTRUCT flag is specified, the extra data is the adress of a LOGFONT structure
-- prealably set up. The couple {CF_INITTOLOGFONTSTRUCT, addr} is not required if you 
-- use the CF_INITTOLOGFONTSTRUCT flag.

global function getFontDialogEx(integer id, atom flags, object extra)

integer points, attrib
sequence  font
atom hChooseFont, hLogFont, color, mset
object result
integer owner
atom extra_flag
integer charset
object extra_data

    -- assume failure
    result = -1
    owner = findParentWindow(id)
    mset = w32new_memset()
    charset=-1
    hChooseFont = w32acquire_mem(mset, SIZEOF_CHOOSEFONT)
    hLogFont = 0

    if sequence(extra) then
        for i=1 to length(extra) do
            extra_flag = extra[i][1]
            extra_data=extra[i][2]
            if and_bits(extra_flag,flags) then
                if extra_flag=CF_ENABLEHOOK then
                    if atom(extra_data) then
                        w32store(hChooseFont,CF_lpfnHook, extra_data)
                    else
                        w32store(hChooseFont,CF_lpfnHook, extra_data[1])
                        w32store(hChooseFont,CF_lCustData, extra_data[2])
                    end if
                elsif extra_flag=CF_LIMITSIZE then
                    w32store(hChooseFont,CF_nSizeMin, extra_data[1])
                    w32store(hChooseFont,CF_nSizeMax, extra_data[2])
                elsif extra_flag=CF_USESTYLE then
                    if sequence(extra_data[1]) then
                        extra_flag=w32acquire_mem(mset,extra_data)
                    else
                        extra_flag = extra_data
                    end if
                    w32store(hChooseFont,CF_lpszStyle,extra_flag)
                elsif extra_flag=CF_SELECTSCRIPT then
                    charset = extra_data
                elsif extra_flag=CF_ENABLETEMPLATEHANDLE then
                    w32store(hChooseFont,CF_hInstance, extra_data)
                elsif extra_flag=CF_ENABLETEMPLATE then
                    w32store(hChooseFont,CF_hInstance, extra_data[1])
                    if sequence(extra_data[1]) then
                        extra_flag=w32acquire_mem(mset,extra_data[2])
                    else
                        extra_flag = extra_data[2]
                    end if
                    w32store(hChooseFont,CF_lpszStyle,extra_flag)
                elsif extra_flag = CF_INITTOLOGFONTSTRUCT then
                    hLogFont = extra_data
                end if
            end if
        end for
    end if

    if and_bits(flags, CF_WYSIWYG) then
        flags = or_bits(flags,CF_BOTH+CF_SCALABLEONLY)
    end if
    -- populate the choose font structure
    if and_bits(flags,CF_INITTOLOGFONTSTRUCT) and not hLogFont then
        hLogFont = w32acquire_mem(mset, SIZEOF_LOGFONT)
        if not and_bits(flags,CF_NOFACESEL) then
            w32store(hLogFont, lfFaceName, ctrl_Font[id][w32FontName])
        end if
        if not and_bits(flags,CF_NOSTYLESEL) then
            attrib = ctrl_Font[id][w32FontAttrib]
            w32store(hLogFont,lfWeight,    (and_bits(attrib, Bold)      != 0)*setFontWeight(w32GetValue))
            w32store(hLogFont,lfItalic,     and_bits(attrib, Italic)    != 0)
            w32store(hLogFont,lfUnderline,  and_bits(attrib, Underline) != 0)
            w32store(hLogFont,lfStrikeOut,  and_bits(attrib, Strikeout) != 0)
        end if
        if not and_bits(flags,CF_NOSIZESEL) then
            if sequence(ctrl_Font[id][w32FontSize]) then
                w32store(hLogFont, lfHeight, ctrl_Font[id][w32FontSize][1])
            else
                w32store(hLogFont, lfHeight, convPointsToLogical(id,ctrl_Font[id][w32FontSize],1))
            end if
        end if
        if charset>=0 then
            w32store(hLogFont, lfCharSet, charset)
        end if
    end if

    w32store(hChooseFont, CF_hLogFont, hLogFont)
    w32store(hChooseFont, CF_lStructSize, SIZEOF_CHOOSEFONT)
    w32store(hChooseFont, CF_hwndOwner, getHandle(owner))
    w32store(hChooseFont, CF_Flags, flags)
    w32store(hChooseFont, CF_rgbColors, ctrl_Font[id][w32FontColor])
    w32store(hChooseFont, CF_iPointSize, ctrl_Font[id][w32FontSize])

    -- call the dialog
    if w32Func(xChooseFont,{hChooseFont}) then

        -- pointer to structure good?
        if w32fetch(hChooseFont,CF_hLogFont) then

            -- got pointer successfully
            font = w32peek_string(w32address(hLogFont,lfFaceName))
            points = floor(w32fetch(hChooseFont,CF_iPointSize)/10)

            -- clear attributes
            attrib = 0

-- NEW! 0.45o check correct flag
            -- bold?
            if w32fetch(hLogFont,lfWeight)>=setFontWeight(w32GetValue) then
                attrib += Bold
            end if

            -- italic?
            if w32fetch(hLogFont,lfItalic) then
                attrib += Italic
            end if

            -- underline?
            if w32fetch(hLogFont,lfUnderline) then
                attrib += Underline
            end if

            -- strikeout?
            if w32fetch(hLogFont,lfStrikeOut) then
                attrib += Strikeout
            end if

            --get font color
            color = w32fetch(hChooseFont,CF_rgbColors)

            -- save result
            result = {font, points, attrib, color}

        end if

    end if
    w32release_mem(mset)
    return result
end function

-----------------------------------------------------------------------------
--/topic Dialogs
--/func getFontDialog(window)
--/desc "Get Font" Dialog
--/ret {font name, points, style flags, color} or -1 if cancelled.
-- Calling this function brings up the modal "Select Font" dialog, allowing
-- the user to select a font from the list of available fonts.
--
-- Example:
--
--/code
--          integer flags, points
--          atom color
--          sequence font
--          object result
--
--          -- get a font choice from the user
--          result = getFontDialog(MyWindow)
--          if sequence(result) then
--              -- get the values
--              font = result[1]
--              points = result[2]
--              flags  = result[3]
--              color  = result[4]
--          end if
--/endcode
global function getFontDialog(integer window)
        return getFontDialogEx(window,w32GFD_DEFAULT_FLAGS,0)
end function

-- ListView wrappers

--/topic ListView Control
--/func struct_LVCOLUMN(atom mask, atom fmt, atom cx, object text, object Column)
--/desc Allocates RAM for a LVCOLUMN structure and initialises it.
--/ret ATOM: Address of a LVCOLUMN structure.
-- /i text can be a 3-element sequence in the form {headingtext, width, alignment}
-- where /i headingtext is the text for the column heading, /i width is the
-- column width in pixels, and /i alignment is a code for Left, Center, or
-- Right aligned text ('~<', '^', '>' respectively). /n
-- In this form, if /i width or /i alignment is -1, it is ignored and the
-- existing settings for the column are not changed. If /i headingtext is
-- "" it is ignored. This means that to blank out a column's heading you
-- must specify a space character as the heading text value.
--
-- /i Column is either ... /n
--/li an integer column number for the new column /n
--/li a two-element sequence {column#, image#}. This form lets you specify
-- the column number and the image list id for the column's image.
--/li a three-element sequence {column#, image#, order}. This form lets you
-- specify the column number, the image list id for the column's image (zero
-- for no image, and the order value.
--
global function struct_LVCOLUMN(atom mask, atom fmt, atom cx,
                            object text, object Column)
--atom LV_COLUMN    -- PL 29/4/09
atom lMask, lFmt, lCX
atom lColImage
atom lColOrder

        lMask = 0
        lFmt = 0
        lCX = 0

        lColImage = 0
        lColOrder = 0

        if sequence(Column) then
            if length(Column) = 2 then
                lColImage = Column[2]
            elsif length(Column) >= 3 then
                lColImage = Column[2]
                lColOrder = Column[3]
            elsif length(Column) = 0 then
                Column = {1}
            end if
            Column = Column[1]
        end if

        if sequence(text) then

            if length(text) = 3 and sequence(text[1]) then
                if text[2] >= 0 then
                    lCX = text[2]
                end if

                if text[3] = '<' or text[3] = LVCFMT_LEFT then
                    lMask = or_bits(lMask, LVCF_FMT)
                    lFmt = LVCFMT_LEFT
                elsif text[3] = '^' or text[3] = LVCFMT_CENTER then
                    lMask = or_bits(lMask, LVCF_FMT)
                    lFmt = LVCFMT_CENTER
                elsif text[3] = '>' or text[3] = LVCFMT_RIGHT then
                    lMask = or_bits(lMask, LVCF_FMT)
                    lFmt = LVCFMT_RIGHT
                end if

                text = text[1]
            end if

            if length(text) > 0 then
                lMask = or_bits(lMask, LVCF_TEXT)
            else
                text = 0
            end if
        end if

        lCX += cx
        if lCX > 0 then
            lMask = or_bits(lMask, LVCF_WIDTH)
        end if

        if lColImage > 0 then
            lMask = or_bits(lMask, LVCF_IMAGE)
        end if

        if lColOrder > 0 then
            lMask = or_bits(lMask, LVCF_ORDER)
        end if

        if fmt != 0 then
            lMask = or_bits(lMask, LVCF_FMT)
        end if

        return w32to_memory(0,ID_LVCOLUMN,{or_bits(mask,lMask), or_bits(fmt,lFmt),
                                           lCX, text, Column-1,lColImage-1,lColOrder-1})
end function

--/topic ListView Control
--/proc setColumn(integer id, integer column, sequence text)
--/desc Changes the column header text, or width, or alignment.
--See /struct_LVCOLUMN for a description of what format /i text can take.
--
--Example:
--/code
--     -- Set the width of the third column to 230
--     setColumn(myListView, 3, {"",230,-1})
--/endcode
global procedure setColumn(integer id, integer column, object text)
atom LV_COLUMN

        LV_COLUMN = struct_LVCOLUMN(0, 0, 0, text, 0)

        VOID = sendMessage(id, LVM_SETCOLUMN, column-1, LV_COLUMN)

        w32release_mem(LV_COLUMN)

end procedure

--/topic ListView Control
--/proc getColumnHeadings(integer id)
--/desc Gets a list of headings for each column in a list view.
--The headings are returned in the same left-to-right order as they are
-- currently displayed. Note that, because the user can sometimes change the
-- order of the columns, the 'column number' may not always be the same
-- as the order that they appear in.
--
-- The returned sequence contains one entry per heading. Each entry contains
-- two-elements: the first is the true column number and the second is
-- the heading text. The true column number can be used to get the
-- values from the column. See example below ...
--
--Example:
--/code
--      -- Output the columns in the right order
--      lheads = getColumnHeadings(myListView)
--      puts(fh, '\n')
--      for i=1 to length(lheads) do
--          printf(fh, "%-25s", {lheads[i][2]})
--      end for
--      printf(fh, "\n%s\n", {repeat('-', 75)})
--      for i=1 to getLVCount(myListView) do
--          for j=1 to length(lheads) do
--              lData = getLVItemText(myListView, i, lheads[j][1])
--              printf(fh, "%-25s", lData)
--          end for
--          puts(fh, '\n')
--      end for
--/endcode
global function getColumnHeadings(integer id)
atom LV_COLUMN
sequence lHeads
integer column
atom textbuf
sequence coldef

        textbuf = w32acquire_mem(0, 4000)
        LV_COLUMN = struct_LVCOLUMN(LVCF_TEXT+LVCF_ORDER+LVCF_SUBITEM, 0, 0, 0, 0)

        w32store(LV_COLUMN,LVCOLUMN_pszText, {{},{textbuf, 4000}})
        lHeads = {}
        column = 1

        VOID = w32True
        while VOID = w32True do
            VOID = sendMessage(id, LVM_GETCOLUMN, column-1, LV_COLUMN)
            if VOID then
                coldef = {w32fetch(LV_COLUMN, LVCOLUMN_iOrder),
                          w32fetch(LV_COLUMN, LVCOLUMN_iSubItem)+1,
                          w32peek_string(textbuf)
                         }
                lHeads = append(lHeads, coldef)
                column += 1
            end if
        end while
        lHeads = sort(lHeads)
        for i=1 to length(lHeads) do
            lHeads[i] = lHeads[i][2..3]
        end for

        w32release_mem(LV_COLUMN)
        w32release_mem(textbuf)

        return lHeads
end function

--/topic ListView Control
--/proc setColumnHeadings(integer id, sequence text)
--/desc Sets the heading text for the columns in a /ListView Control.
--The /i text parameter is a sequence list of column formatting options,
--one per column. Each column formatting option is either a simple text
--heading, or a 3-element sequence: {heading-text, column-width, alignment-code}.
--The alignment code is a single character (integer) and can be one of '~<',
--'^', or '>' meaning left, center, and right alignment respectively. /n
--When calling this routine, sometimes you might need to leave the current
-- setting for heading text, width or alignment alone. To leave the text
-- alone, use an empty string. To leave the width alone, use -1. To leave
-- the alignment alone, use -1.
--
--Example:
--/code
--       -- Set the heading text for each column.
--       setColumnHeadings(myLV, {"Title","Author","Publisher","When"})
--       -- Change the width of the second column
--       setColumnHeadings(myLV, {{},{"",200,-1}})
--       -- Another way to change the width of the second column
--       setColumn(myLV, 2, {{"",200,-1}})
--/endcode
global procedure setColumnHeadings(integer id, sequence text)
sequence lHeadings
integer lTab

        if length(text) > 0 then
            if not sequence(text[1]) then
                lHeadings = {}
                lTab = find('\t', text)
                while lTab != 0 do
                    lHeadings = append(lHeadings, text[1..lTab-1])
                    text = text[lTab+1..length(text)]
                    lTab = find('\t', text)
                end while
                if length(text) > 0 then
                    lHeadings = append(lHeadings, text)
                end if
                text = lHeadings
            end if
            for i=1 to length(text) do
                setColumn(id, i, text[i])
            end for
        end if
end procedure

--/topic ListView Control
--/proc insertLVColumn(id,index,mask,fmt,cx,text, ColumnNumber)
--/desc Inserts a new column into a listview control.
-- See the description of the parameters in the documentation for /struct_LVCOLUMN().
--
global procedure insertLVColumn(atom id, integer index,
            atom mask, atom fmt, atom cx, object text, object pColumn)

atom LV_COLUMN

--/**/  if index or mask then end if -- suppress warnings   -- PL 29/4/09
        LV_COLUMN = struct_LVCOLUMN(LVCF_SUBITEM, fmt, cx, text, pColumn)

        if sequence(pColumn) then
            pColumn = pColumn[1]
        end if
        VOID = sendMessage(id, LVM_INSERTCOLUMN, pColumn-1, LV_COLUMN)

        w32release_mem(LV_COLUMN)

end procedure

--/topic ListView Control
--/proc deleteLVColumn(id,index,mask,fmt,cx,text, ColumnNumber)
--/desc Removes a column from a listview control.
--
--Example:
--/code
--      -- Delete the third column
--      deleteLVColumn(myListView, 3)
--/endcode
global procedure deleteLVColumn(atom id, integer pColumn)
        VOID = sendMessage(id, LVM_DELETECOLUMN, pColumn-1, 0)
end procedure

--/topic ListView Control
--/func setLVImage(integer id, atom pInfo)
--/desc Possibly sets the new background image of the ListView, and returns previous state.
--/ret (SEQUENCE) {} on failure, a nonempty sequence if previous info could be gathered.
-- pInfo is the address of a structure of type ID_LVBKIMAGE.
-- If not succesful in getting the information about the background image before the call, the function returns {}.
-- If pInfo is 0 or w32GetValue, the function does not set the background image.
-- If succesful, the function returns {bitmap_handle, flags,url,xOffset,yOffset,return_code}.
--   /i return_code is w32True if the background image could be set, else w32False.
-- The other elements are like the parameters for an ID_LVBKIMAGE structure.
-- Note that the ListView control owns the bitmap whose handle, if any, is in
-- /i bitmap_handle.
--
-- To obtain a valid /i pInfo, you have to call /w32to_memory(ID_LVBKIMAGE,{pFlags,hBitmap,url,xOffsetPercent,yOffsetPercent}).
-- hBitmap is the handle of the background bitmap. If url is not "", it is
-- an url where the background image is to be picked at.
-- pFlags is made of one or more of the following:
--/define
--/term LVBKIF_SOURCE_NONE
-- The list-view control has no background image.
--/term LVBKIF_SOURCE_HBITMAP
-- A background bitmap is supplied via /i hBitmap. If the message LVM_SETBKIMAGE succeeds, 
--  then the list-view takes ownership of the bitmap.
--/term LVBKIF_SOURCE_URL
-- /i url contains the URL of the background image.
--/term LVBKIF_STYLE_NORMAL
-- The background image is displayed normally.
--/term LVBKIF_STYLE_TILE
-- The background image will be tiled to fill the entire background of the control.
--/term LVBKIF_FLAG_TILEOFFSET
-- Specify the coordinates of the first tile. This flag is valid only if the LVBKIF_STYLE_TILE flag is also specified. 
--  If this flag is not specified, the first tile begins at the upper-left corner of the client area.
--/term LVBKIF_TYPE_WATERMARK
-- A watermark background bitmap is supplied /i hBitmap. If the LVM_SETBKIMAGE message succeeds, 
--  then the list-view control takes ownership of the bitmap.
--/term LVBKIF_FLAG_ALPHABLEND
-- Only valid when LVBKIF_TYPE_WATERMARK is also specified. This flag indicates the bitmap 
--  provided via LVBKIF_TYPE_WATERMARK contains a valid alpha channel.
--/enddefine
--
-- xOffset and yOffset are integer percentages which indicate the image placement when 
--  the LVBKIF_STYLE_NORMAL flag is present. 0 aligns the image along the left or top edge;
-- 100 aligns the image aong the right or bottom edge; 50 centers the image, and so on.
-- Under Windows XP, if using a manifest file, and if the LVBKIF_FLAG_TILEOFFSET is resent, 
--  /i xOffset and /i yOffset then are the offset /i "in poxels" of the first tile.

global function setLVImage(integer id,atom pInfo)
atom result,hbm
integer rc
sequence rtn

        result=w32to_memory(0,ID_LVBKIMAGE, 0)
        rc=sendMessage(id,LVM_GETBKIMAGE,0,result)
        if not rc then
            w32release_mem(result)
            return 0
        end if
        hbm=0
        if pInfo!=0 and pInfo!=w32GetValue then
            rc=sendMessage(id,LVM_SETBKIMAGE,0,pInfo)
            hbm=w32fetch(pInfo,LVBKIMAGE_hbm)
            if hbm then
                trackObject(id,hbm,ForProgram)
            end if
        end if
        rtn={w32fetch(result,LVBKIMAGE_hbm),
             w32fetch(result,LVBKIMAGE_ulFlags),"",
             w32fetch(result,LVBKIMAGE_xOffsetPercent),
             w32fetch(result,LVBKIMAGE_yOffsetPercent),rc
            }
        if and_bits(rtn[2],LVBKIF_SOURCE_URL) then
            rtn[3] = w32peek_string(w32fetch(result,LVBKIMAGE_pszImage))
        end if
        -- do something about the returned hbm not being owned by the listview?
        w32release_mem(result)
        return rtn
end function

integer internal_lvinsert
internal_lvinsert=0
--/topic ListView Control
--/func insertLVItem(id,mask,row,column,state,stateMask,text,image,lparam)
--/desc Low-Level version of /addLVItem.
--/ret SEQUENCE: {index, itemid}
global function insertLVItem(integer id, atom mask, atom row,
    atom iSubItem, atom state, atom stateMask,
    object text, atom image, object lparam)

atom LV_ITEM, lIdx
integer setMask

        if not validId(id) or ctrl_Type[id] != ListView then
            return {-1, -1}
        end if

        -- Get next item ID to use
        vNextLVItemID += 1

        -- Check for 'end of list' position
        if row < 0 then
            row = sendMessage(id, LVM_GETITEMCOUNT, 0, 0)+1
        end if

        if ctrl_Menu[id]!=hILsmall then
            lIdx=image
            image=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[image]})+1
            VOID=w32Func(ImageList_AddIcon,{ctrl_Previous_focus[id],ilicon_list[lIdx]})
        end if

        -- don't use Windows lparam, as this is the position independent index
        if not internal_lvinsert then
            setMask = and_bits(mask,LVIF_PARAM)
            mask -= setMask
        else
            setMask=0
        end if

        LV_ITEM = w32to_memory(0,ID_LVITEM, {mask, row-1, iSubItem-1, state, stateMask,
                                             text, image-1, vNextLVItemID})

        lIdx = sendMessage(id, LVM_INSERTITEM, 0, LV_ITEM)
        lvitem_owner &= id

        if not setMask then
            lparam=0
        end if
        lvitem_lparam = append(lvitem_lparam,lparam)

        w32release_mem(LV_ITEM)

        return {lIdx+1, vNextLVItemID}
end function

global constant
ROW_BASE_1=1,
COL_BASE_1=2,
IMG_BASE_1=4,
ROW_BASE_0=0,
COL_BASE_0=0,
IMG_BASE_0=0

--/topic ListView Control
--/proc setLVItemEx(id, mask, Row, Column, state, stateMask, text, image, lparam,base)
--/desc Enables you to set a number of the properties of a ListView item in one call,
-- like /setLVItem() does.
--<ul>
--/li /i id is the ListView's Id as returned by /createEx()
--/li /i mask determines which what properties are being changed. This is any combination of
-- the values /b"LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM," and /b LVIF_STATE. For each one of these included,
-- the respective parameter /i "text, image, lparam," and /i state is required.
--/li Row is the row number in the list
--/li Column is the column number the parameters affect.
--/li base is made of flags or'ed together which specify whether the /i row, /i column and /i image 
--      are passed as 1-based (Euphoria-like) or 0-based (C-like) indexes. Available flags are:
--<ul>
--/li ROW_BASE_1 to indicate that the first row is numbered 1;
--/li ROW_BASE_0 to indicate that the first row is numbered 0;
--/li COL_BASE_1 to indicate that the first column is numbered 1;
--/li COL_BASE_0 to indicate that the first column is numbered 0;
--/li IMG_BASE_1 to indicate that image indexes start at 1;
--/li IMG_BASE_0 to indicate that image indexes start at 0.
--</ul>
-- Note that the _0 constants are 0.
--</ul>
--
--Example:
--/code
--      setLVItem(myListView, w32or_all({LVIF_TEXT, LVIF_IMAGE}), 2,1,
--                    0, 0, "The Great Gatsby", bookImage, 0)
--/endcode
global procedure setLVItemEx(atom id, atom mask, atom pRow,
    atom pColumn, atom state, atom stateMask,
    object text, atom image, object lparam, integer base)

-- PL 29/4/09
--atom LV_ITEM,iItem
atom LV_ITEM
integer setMask

        if ctrl_Menu[id]!=hILsmall then
            if not and_bits(base,IMG_BASE_1) then
                image+=1
            end if
            image=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[image]})+1
            VOID=w32Func(ImageList_AddIcon,{ctrl_Previous_focus[id],ilicon_list[image]})
        end if

        setMask = and_bits(mask,LVIF_PARAM)
        mask-=setMask

        if and_bits(base,ROW_BASE_1) then
            pRow-=1
        end if
        if and_bits(base,COL_BASE_1) then
            pColumn-=1
        end if
        if and_bits(base,IMG_BASE_1) then
            image-=1
        end if

        LV_ITEM = w32to_memory(0,ID_LVITEM, {mask, pRow, pColumn, state, stateMask,
                                             text, image, 0})

        VOID = sendMessage(id, LVM_SETITEM, 0, LV_ITEM)
        if setMask then
            w32store(LV_ITEM,LVITEM_mask,LVIF_PARAM)
            VOID = sendMessage(id, LVM_GETITEM, 0, LV_ITEM)
            lvitem_lparam[w32fetch(LV_ITEM,LVITEM_lParam)] = lparam
        end if
        w32release_mem(LV_ITEM)

end procedure

--/topic ListView Control
--/proc setLVItem(id, mask, Row, Column, state, stateMask, text, image, lparam)
--/desc Enables you to set a number of the properties of a ListView item in one call.
--<ul>
--/li /i id is the ListView's Id as returned by /createEx()
--/li /i mask determines which what properties are being changed. This is any combination of
-- the values /b"LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM," and /b LVIF_STATE. For each one of these included,
-- the respective parameter /i "text, image, lparam," and /i state is required.
--/li Row is the row number in the list
--/li Column is the column number the parameters affect.
--</ul>
--
--Example:
--/code
--      setLVItem(myListView, w32or_all({LVIF_TEXT, LVIF_IMAGE}), 2,1,
--                    0, 0, "The Great Gatsby", bookImage, 0)
--/endcode
global procedure setLVItem(atom id, atom mask, atom pRow,
    atom pColumn, atom state, atom stateMask,
    object text, atom image, object lparam)
        setLVItemEx(id,mask,pRow,pColumn,state,stateMask,text,image,lparam,ROW_BASE_1+COL_BASE_1+IMG_BASE_1)
end procedure
r_setLVItem = routine_id("setLVItem")

--/topic ListView Control
--/proc setLVItemText(integer LV, integer position, integer subitem, object text)
global procedure setLVItemText(integer LV, integer pRow, integer pColumn, object text)
-- PL 29/4/09
--atom LV_ITEM, ptext
atom LV_ITEM

        if not sequence(text) then
            text = sprintf("%g", text)
        end if
        LV_ITEM = w32to_memory(0,ID_LVITEM, {LVIF_TEXT, 0, pColumn-1, 0, 0, text, 0, 0})

        VOID = sendMessage(LV, LVM_SETITEMTEXT, pRow-1, LV_ITEM)

        w32release_mem(LV_ITEM)

end procedure

--/topic Image lists
--/proc setImageList(integer id, atom IL, atom size)
--/desc Sets the image list for a ListView, TreeView, TabControl or ComboBoxEx control.
-- /i id is the id of the control, /i IL is the image list handle and /i size is the
-- size of the images the list contains.
global procedure setImageList(integer id, atom IL, atom size)
atom message

        IL = getHandle(IL)
        message = 0
        if ctrl_Type[id] = ListView then
            message = LVM_SETIMAGELIST
        elsif ctrl_Type[id] = TreeView then
            message = TVM_SETIMAGELIST
        elsif ctrl_Type[id] = TabControl then
            message = TCM_SETIMAGELIST
        elsif ctrl_Type[id] = ToolBar then
            message = TB_SETIMAGELIST
        elsif ctrl_Type[id] = ComboBoxEx then
            message = CBEM_SETIMAGELIST

        end if

        if message then
            VOID = sendMessage(id, message, size, IL)
            ctrl_Menu[id] = IL
        end if

end procedure

--/topic Image Lists
--/func addIcon(hIcon)
--/desc Adds icons to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addIcon:
-- /li /b hIcon is an icon handle
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b hIcon is a sequence of 3 icon handles
--      used for /FlatToolBar
-- The icons passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
--
-- /b "Note:" If /i hIcon is zero, it is ignored and zero is returned.
--
--/Example
--/code
--  object ret, dd
--  dd = dir("c:\\windows\\*.exe")
--  for i=1 to length(dd) do
--          ret = addIcon(extractIcon("c:\\windows\\" & dd[i][D_NAME]))
--          ret = addLVItem(lv, ret, {dd[i][D_NAME], "xxx"})
--  end for
--/endcode
global function addIcon(object hIcon)
integer iIcon
sequence list

        if equal(hIcon, 0) then
            return 0
        end if

        if atom(hIcon) then
            list = ilicon_list
        else
            list = FTB_images
        end if

        iIcon = find(hIcon, list)

        if iIcon then
            return iIcon
        end if

        iIcon = length(list)


        if atom(hIcon) then

            if ILlarge = 0 then
                ILlarge = call_func(r_createEx,{ImageList,"",0,0,0,SM_CXICON,0,ILC_COLOR8,0})
                ILsmall = call_func(r_createEx,{ImageList,"",0,0,0,SM_CXSMICON,0,ILC_COLOR8,0})
                hILsmall = ctrl_Handle[ILsmall]
                hILlarge = ctrl_Handle[ILlarge]
            end if
            ILAddIcon(ILlarge, hIcon)
            ILAddIcon(ILsmall, hIcon)

            list &= hIcon
            ilicon_list = list

        else
            if himlFTBDefault = 0 then
                -- Need to create imagelists

                himlFTBDefault  = call_func(r_createEx,{ImageList,"",0,0,0,SM_CXICON,0,ILC_COLOR8,0})
                himlFTBHot      = call_func(r_createEx,{ImageList,"",0,0,0,SM_CXICON,0,ILC_COLOR8,0})
                himlFTBDisabled = call_func(r_createEx,{ImageList,"",0,0,0,SM_CXICON,0,ILC_COLOR8,0})

            end if
            ILAddIcon(himlFTBDefault,   hIcon[1])
            ILAddIcon(himlFTBHot,       hIcon[2])
            ILAddIcon(himlFTBDisabled,  hIcon[3])

            list &= {hIcon}
            FTB_images = list

        end if


        return iIcon+1
end function

global constant
w32TB_BUTTONSIZE = 1,
w32TB_BITMAPSIZE = 2,
w32TB_HEIGHT = 3

--/Topic Controls
--/proc setToolBarSize(integer id, object Property, object Values)
--/desc Set one or more size properties of a ToolBar or FlatToolBar.
--This is really only needed for Win95 as later versions do this automatically. /n
--/i id is the Id of the tool bar. /n
--/i Property is a list of properties to affect. These can be any combination of
-- /b "w32TB_BUTTONSIZE, w32TB_BITMAPSIZE," and /b w32TB_HEIGHT. /n
--/i Values is a list of the new value(s) to set. /n
-- There must be the same number of values as properties. /n
--/b Note for the button size and bitmap size, the values must be expressed as
-- a 2-element sequence containing {width, height}. For the height value, this
-- must be a single integer. /n
--
-- There is no way to set the width of a toolbar as it always matches it's window's width.
--
--Example:
--/code
--      setToolBarSize(myToolbar, {w32TB_HEIGHT, w32TB_BUTTONSIZE},
--                                 {    38,        {24, 26} })
--/endcode

global procedure setToolBarSize(integer id, object pProperty, object pValues)
atom lXY
integer lIdx
sequence lParentSize

        if atom(pProperty) then
            pProperty = {pProperty}
        end if
        if atom(pValues) then
            pValues = {pValues}
        end if

        if length(pProperty) != length(pValues) then
            return
        end if

        lIdx = find(w32TB_BUTTONSIZE, pProperty)
        if lIdx != 0 and sequence(pValues[lIdx]) and length(pValues[lIdx]) = 2 then

            lXY = w32pack_word(pValues[lIdx][1], pValues[lIdx][2])
            VOID = sendMessage(id, TB_SETBUTTONSIZE, 0, lXY)
        end if

        lIdx = find(w32TB_BITMAPSIZE, pProperty)
        if lIdx != 0 and sequence(pValues[lIdx]) and length(pValues[lIdx]) = 2 then

            lXY = w32pack_word(pValues[lIdx][1], pValues[lIdx][2])
            VOID = sendMessage(id, TB_SETBITMAPSIZE, 0, lXY)
        end if


        lIdx = find(w32TB_HEIGHT, pProperty)
        if lIdx != 0 and integer(pValues[lIdx]) then
            lParentSize = call_func(r_getCtlSize,{ctrl_Parent[id]})

            VOID = w32Func(xMoveWindow, {getHandle(id), 0, 0, lParentSize[1], pValues[lIdx], 1})
        end if

end procedure

--/topic ListView Control
--/func setLVInsert(object pFlag)
--/desc Possibly sets the default position for ListView inserts.
--/ret The flag setting before this change.
--If /i pFLag is zero, /addLVItem() adds new items to the top of the list.
-- If pFlag is /w32GetValue, the value of the flag is returned without modifying it.
-- Otherwise, new items are added at the end. The default is to add items to the
-- top of lists.
-- If pFlag is a sequence, it is a pair {id,pFlag}, where the flag has the above meaning and /i id identifies a ListView. 
--  The function then possibly sets, then returns the override flag for this listview.
--
--Example:
--/code
--      integer lvInsert
--      -- Make listviews add to end of lists.
--      lvInsert = setLVInsert(1)
--/endcode
--PL 28/4/09:
--global function setLVInsert(integer pFlag)
global function setLVInsert(object pFlag)
atom lOld

        if integer(pFlag) then
            lOld = lvInsertWhere
            if pFlag != w32GetValue then
                lvInsertWhere = w32iff(pFlag = 0, 1, -1)
            end if
        elsif not length(pFlag) or ctrl_Type[pFlag[1]]!=ListView then
            return lvInsertWhere
        else
            lOld = ctrl_Specific[pFlag[1]]
            if length(pFlag)=1 then
                ctrl_Specific[pFlag[1]] = 0
            elsif pFlag[2]=w32False then
                ctrl_Specific[pFlag[1]] = -1
            elsif pFlag[2]!=w32GetValue then
                ctrl_Specific[pFlag[1]] = 1
            end if
        end if
        return lOld
end function

--/topic ListView Control
--/func addLVItem(object id, atom iIcon, sequence text)
--/desc Add an item to a /ListView
--/ret The new item's ID.
-- /i id: This is either the id of /ListView or a two-element sequence that
-- specifies the ListView id and the position in the list to insert the new
-- item. /b 1 is the first position, /b 2 is the second position, etc... and
-- /i -1 is the last position. /n
-- /i iIcon: index of image from /addIcon, /addEuBmp, /addXpm, or /addDIB /n
-- /i text: sequence of strings or numbers to be displayed in listview columns. The
-- number of columns is set by the number of strings in this parameter. /n
--
-- Note: Each item placed into a listview is given a unique ID. The ID is unique
-- for the application, not just the ListView the item is in. Also, the ID is
-- not the same as the position of the item in the ListView.
--
--Example:
--/code
--        sequence idx idx = {}
--        setColumnHeadings(myLV, {"Given Name","Family Name","Playing Position", "Number"})
--        idx &= addLVItem(myLV, iconCaptain, {"Brett","Ratten", "Center", 7})
--        idx &= addLVItem(myLV, iconPlayer, {"Scott","Camporeale", "Wing", 16})
--        idx &= addLVItem(myLV, iconPlayer, {"Jim","Plunkett", "Rover", 44})
--        -- Insert an item at position 2.
--        idx &= addLVItem({myLV,2}, iconPlayer, {"Andrew","McKay", "Back Pocket", 5})
--/endcode
global function addLVItem(object id, atom iIcon, sequence text)

--atom iItem    -- PL 29/4/09
integer lWhere,n_icon
sequence lNewItem

        if sequence(id) then
            lWhere = id[2]
            id = id[1]
        else
            if ctrl_Specific[id] then
                lWhere = ctrl_Specific[id]
            else
                lWhere = lvInsertWhere
            end if
        end if
        if ctrl_Type[id]!=ListView then
            return -1
        end if
        if ctrl_Menu[id]!=hILsmall then
            n_icon=iIcon
            iIcon=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[iIcon]})+1
            VOID=w32Func(ImageList_AddIcon,{ctrl_Previous_focus[id],ilicon_list[n_icon]})
        end if

        -- Sanity check
--DEV PL 28/4/09: (or should text be declared object?)
--      if not sequence(text) then
--          text = sprintf("%g", text)
--      end if
        if length(text) = 0 or not sequence(text[1]) then
            text = {text}
        end if

        internal_lvinsert=1
        lNewItem = insertLVItem(id, lvitem_MASK, lWhere, 1,0,0,
                                text[1], iIcon, 0)
        internal_lvinsert=0

        for i = 2 to length(text) do
            setLVItemText(id, lNewItem[1], i, text[i])
        end for

        return lNewItem[2]
end function

--/topic ListView Control
--/func getLVItem(integer id, atom LV_ITEM)
--/ret ATOM: 0 if routine was successful.
--/desc Gets various attributes of a listview item.
-- /i LV_ITEM is the address of a LVITEM structure that you have to correctly
-- fill out before you call this routine.
-- Note that, on return, the lParam member of the structure will not hold the item information
-- you supplied, but its unique id instead. To access the item information, use
-- /getLVItemlParam() instead.
--
--Example:
--/code
--      atom lOK
--      atom lvitem
--      lvitem = w32acquire_mem(0, SIZEOF_LVITEM)
--      w32store(lvitem, LVITEM_iItem, 1)
--      w32store(lvitem, LVITEM_mask, LVIF_TEXT)
--      lOK = getLVItem(myLV, lvitem)
--      . . .
--      w32release_mem(lvitem)
--/endcode
global function getLVItem(integer id, atom LV_ITEM)
        return sendMessage(id, LVM_GETITEM, 0, LV_ITEM)
end function

--/topic ListView Control
--/func getLVItemText(integer id, integer item, object column)
--/desc Gets the text associated with a listview item.
--/ret Sequence: The text for an item.
--/i id is the ListView control, /n
--/i row is the list view row in question, /n
--/i column is either the number of the column whose text you want,
-- or -1 if you want the text from all columns, in which case a sequence of
-- strings is returned, or a sequence of column numbers.
--
--Example:
--/code
--       sequence theText
--       -- Get the text from column 1 in row 2.
--       theText = getLVItemText(myLV, 2, 1)
--       -- Get the text from columns 3 and 2 in row 1.
--       theText = getLVItemText(myLV, 1, {3,2})
--/endcode
global function getLVItemText(integer id, integer row, object column)
sequence text
atom lvitem, taddr, lrc
object taddr_real
integer lidx
atom lMemSet

        if not validId(id) or row < 1 then
            return sprintf("Invalid getLVItemText call: ID=%d, ROW=%d", {id, row})
        end if

        if atom(column) then
            if column >= 1 then
                column = {column}
            else
                column = -1
            end if
-- PL 29/4/09
--  elsif sequence(column) and length(column) = 0 then
        elsif length(column) = 0 then
            column = -1
        end if

        text = {}
        lidx = 1

        lMemSet = w32new_memset()
        lvitem = w32acquire_mem(lMemSet, SIZEOF_LVITEM)
        taddr = w32acquire_mem(lMemSet, 4000)

        w32store(lvitem, LVITEM_iItem, row-1)
        w32store(lvitem, LVITEM_mask, LVIF_TEXT)
        w32store(lvitem, LVITEM_pszText, {{},{taddr, 3999}})

        while w32True do
            if atom(column) then
                w32store(lvitem, LVITEM_iSubItem, column+lidx)
            else
                w32store(lvitem, LVITEM_iSubItem, column[lidx]-1)
            end if

            lrc = sendMessage(id, LVM_GETITEM, 0, lvitem)
            if lrc then
                taddr_real = w32fetch(lvitem, LVITEM_pszText)
                if sequence(taddr_real) then
                    text = append(text,taddr_real)
                else
                    lrc = 0
                end if
            elsif atom(column) then
                text = append(text, "")
            end if

            lidx += 1

            if atom(column) then
                if lrc = 0 then
                    exit
                end if
            else
                if lidx > length(column) then
                    exit
                end if
            end if
        end while


        if sequence(column) and length(column) = 1 and length(text) > 0 then
            text = text[1]
        end if

        w32release_mem(lMemSet)
        return text
end function
r_getLVItemText = routine_id("getLVItemText")

--/topic ListView Control
--/func getLVAllText(integer id, integer row)
--/desc Gets the text associated with every column in a listview row.
--/ret Sequence: A sequence of text strings.
--/i id is the ListView control, /n
--/i row is the list view row in question, /n
--
--Example:
--/code
--       sequence theText
--       -- Get the text from row 1.
--       theText = getLVAllText(myLV, 1)
--/endcode
global function getLVAllText(integer id, integer pRow)
        return getLVItemText(id, pRow, -1)
end function

--/topic ListView Control
--/func getLVCount(integer id)
--/desc Gets the number of rows in a list view.
--/ret INTEGER: The count of rows.
--
--Example:
--/code
--      integer cnt
--      cnt = getLVCount(myLV)
--/endcode
global function getLVCount(integer id)
        return sendMessage(id, LVM_GETITEMCOUNT, 0, 0)
end function


--/topic ListView Control
--/func getLVChecked(integer id, integer index)
--/desc Gets whether or not an row has its checkbox ticked.
--/ret INTEGER: w32False if not checked, otherwise w32True.
--
--Example:
--/code
--      integer cnt
--      -- See if row #2 is checked.
--      cnt = getLVChecked(myLV, 2)
--/endcode

global function getLVChecked(integer id, integer row)
atom lFlags
        lFlags = sendMessage(id, LVM_GETITEMSTATE, row-1, LVIS_STATEIMAGEMASK)
        lFlags = and_bits(lFlags, LV_IS_CHECKED)
        return (lFlags != 0)
end function

--/topic ListView Control
--/func getLVAllChecked(integer id)
--/desc Returns a list of the indexes of     those rows that are Checked.
--/ret SEQUENCE: A list of rows.
--
--Example:
--/code
--      sequence items
--      items = getLVAllChecked(myLV)
--/endcode
global function getLVAllChecked(integer id)
integer totalCount
sequence lItems
atom lFlags
atom hWnd

        totalCount = getLVCount(id)
        lItems = {}
        hWnd = getHandle(id)
        for i=0 to totalCount-1 do
            lFlags = w32Func(xSendMessage,{hWnd, LVM_GETITEMSTATE,i, LVIS_STATEIMAGEMASK})
            lFlags = and_bits(lFlags, LV_IS_CHECKED)
            if lFlags!=0 then
                lItems &= i+1
            end if
        end for

        return lItems
end function

--/topic ListView Control
--/proc setLVChecked(integer id, integer Row, atom checked)
--/desc Sets the checked state for a /ListView Item
-- /i id is the win32lib id for the list view. /n
-- /i Row is the listview item to check/uncheck. /n
-- /i checked is the checked/unchecked state (~<>0=checked,0=unchecked). /n
global procedure setLVChecked(integer id, integer pRow, atom checked)
atom LV_ITEM, state, mask

        mask = LVIF_STATE
        if checked then
            state = (2 * power(2, 12))
        else
            state = (1 * power(2, 12))
        end if

        LV_ITEM = w32to_memory(0,ID_LVITEM, {LVIF_STATE, pRow-1, 0, state, LVIS_STATEIMAGEMASK})

        VOID = sendMessage(id, LVM_SETITEM, pRow-1, LV_ITEM)

        w32release_mem(LV_ITEM)
end procedure

--/topic Graphics
--/func extractIcon(sequence Filename)
--/desc Gets the an icon from the file (DLL, EXE or ICO) specified.
--/ret ATOM: Handle to the icon or NULL if none found.
--/i Filename is either ... /n
-- ** the name of a file /n
-- ** a 2-element sequence containing a filename and a 1-based index of which icon to extract.
-- ** a 3-element sequence containing a filename, a 1-based index of which icon to extract,
-- and a code indicating which size icon to return: 0 --> small, 1 --> large,  2 --> both. When
-- you ask to return both, a 2-element sequence is returned that contains {small, large}.
--
--Example:
--/code
--      atom hIcon
--      sequence lIcons
--      -- Get the first icon
--      hIcon = extractIcon("C:\\WINDOWS\\WINFILE.EXE")
--      -- Get the second icon
--      hIcon = extractIcon({"C:\\WINDOWS\\WINFILE.EXE", 2})
--      -- Get the fourth icon, large size
--      hIcon = extractIcon({"C:\\WINDOWS\\WINFILE.EXE", 4, 1})
--      -- Get the fifth icon, both sizes
--      lIcons = extractIcon({"C:\\WINDOWS\\SYSTEM32\SHELL32.DLL", 5, 2})
--      lBig = lIcons[2]
--      lSmall = lIcons[1]
--/endcode
global function extractIcon(sequence Filename)
object icon
integer lIdx
atom lBufferL
atom lBufferS
integer lType

        lIdx = 0
        lType = 0
        if length(Filename) > 0 then
            if sequence(Filename[1]) then
                if length(Filename) >= 3 then
                    lType = Filename[3]
                else
                    lType = 0
                end if
                lIdx = Filename[2]-1
                Filename = Filename[1]
            end if
        else
            lType = 1
        end if
        lBufferL = w32acquire_mem(0, 8)
        lBufferS = lBufferL + 4
        Filename = w32FindFile(Filename)
        VOID = w32Func(xExtractIconEx, {Filename, lIdx, lBufferL, lBufferS, 1})

        if lType = 0 then
            icon = peek4u(lBufferS)
        elsif lType = 1 then
            icon = peek4u(lBufferL)
        else
            icon = peek4u({lBufferL,2})
        end if

        w32release_mem(lBufferL)
        return icon
end function

--/topic ListView Control
--/func getLVSelectedCount(integer id)
--/desc Gets the number of selected items in a list view.
--/ret INTEGER: The count of selected items.
--
--Example:
--/code
--      integer cnt
--      cnt = getLVSelectedCount(myLV)
--/endcode
global function getLVSelectedCount(integer id)
        return sendMessage(id, LVM_GETSELECTEDCOUNT, 0, 0)
end function

--/topic ListView Control
--/func getLVItemlParam(integer id, integer iItem)
--/ret ATOM: The user-defined data associated with this /i iItem.
--/desc Gets the user-defined data for this specific row in the list.
--This data is set by /setLVItemlParam and can be any 32-bit integer.
--
--Example
--/code
--       atom lVal
--       -- Get the data for the second row in the list.
--       lVal = getLVItemlParam(myLV, 2)
--/endcode
global function getLVItemlParam(integer id, integer pRow)
atom LV_ITEM, lParam

        LV_ITEM = w32to_memory(0, ID_LVITEM, {LVIF_PARAM, pRow-1})
        VOID = sendMessage(id, LVM_GETITEM, 0, LV_ITEM)
        lParam = w32fetch(LV_ITEM, LVITEM_lParam)

        w32release_mem(LV_ITEM)
        return lvitem_lparam[lParam]
end function

--/topic ListView Control
--/func getLVSelected(object id)
--/desc get a list of the selected items' indexes
--/ret SEQUENCE: A list of item indexes.
-- This can return either a simple list of item index values or
-- a list of 2-element sequences where the first element is
-- the index of the selected item and the second elements is
-- the id of the selected item.
--
-- Remember that each item in a list view has a unique item id.
-- The index is the item's current position within the listview.
--
-- To return just a list of item indexes, /i id is the ListView control id. /n
-- To return a list of {index, item id} sequences, then /i id must be
-- a sequence in the form {LVid, style}. /i LVid is the listview's
-- control id and /i style is either /b 1 for the sequence list
-- return value style, or /b 0 for the simple list return value style.
--
--Example:
--/code
--          sequence indexes
--          -- Get a list of selected items' id.
--          idxs = getLVSelected(myListView)
--
--          -- Get a list of selected items AND their indexes.
--          idxs = getLVSelected({myListView, 1})
--/endcode
global function getLVSelected(object id)
-- PL 29/4/09
--integer count, start, check
integer count, start
sequence selections
atom LVITEM, LVITEM2, mset, lParam
integer lReturnStyle

        selections = {}
        lReturnStyle = 0

        if sequence(id) then
            if length(id) = 2 then
                lReturnStyle = (id[2]!=0)
                id = id[1]
            else
                return {}
            end if
        end if

        count = getLVSelectedCount(id)
        if not count then
            return selections
        end if

        mset = w32new_memset()
        LVITEM  = w32acquire_mem(mset, SIZEOF_LVITEM)
        w32store(LVITEM, LVITEM_mask, LVIF_STATE)
        w32store(LVITEM, LVITEM_stateMask, LVIS_SELECTED)

        LVITEM2 = w32acquire_mem(mset, SIZEOF_LVITEM)
        w32store(LVITEM2, LVITEM_mask, LVIF_PARAM)

        start = 0
        while count do
            w32store(LVITEM, LVITEM_iItem, start)
            if sendMessage(id, LVM_GETITEM, 0, LVITEM) then
                if w32fetch(LVITEM, LVITEM_state) then
                    if lReturnStyle = 1 then
                        w32store(LVITEM2, LVITEM_iItem, start)
                        VOID = sendMessage(id, LVM_GETITEM, 0, LVITEM2)
                        lParam = w32fetch(LVITEM2, LVITEM_lParam)
                        selections &= {{start+1, lParam}}
                    else
                        selections &= start+1
                    end if
                    count -= 1
                end if
            end if
            start += 1
        end while

        w32release_mem(mset)
        return selections
end function

procedure setTVParent(integer iItem, integer cChildren)
atom TV_ITEM
--integer id    -- PL 29/4/09

        tvitem_data[iItem][ktv_HasChildren] = cChildren

        if tvitem_owner[iItem] != -1 then
            TV_ITEM = w32to_memory(0,ID_TVITEM, {TVIF_CHILDREN, tvitem_handle[iItem],
                                                 0,0,0,0,0, cChildren,0})

            VOID = sendMessage(tvitem_owner[iItem], TVM_SETITEM, 0, TV_ITEM)

            w32release_mem(TV_ITEM)
        end if

end procedure

--/topic ListView Control
--/func getLVSelectedText(integer id)
--/desc Gets the column-1 text for each selected item in the listview.
--/ret SEQUENCE: Each element returned is a text sequence.
-- Note that an empty sequence returned means that there is no selected
-- items.
--
--Example:
--/code
--      sequence strings
--      strings = getLVSelectedText(myListView)
--      for i=1 to length(strings) do
--          puts(1, strings[i] & '\n')
--      end for
--/endcode
global function getLVSelectedText(object id)
sequence text
sequence lRowList

        if sequence(id) then
            if sequence(id[2]) then
                lRowList = id[2]
            else
                lRowList = {id[2]}
            end if
            id = id[1]
        else
            lRowList = {1}
        end if

        text = getLVSelected(id)


        for i=1 to length(text) do
            text[i] = getLVItemText(id, text[i], lRowList)
        end for

        return text

end function

procedure removeTVItem(integer iItem)
integer iParent
    -- Free up memory taken for the item
        if tvitem_data[iItem][ktv_TextAddr] then
            w32release_mem(tvitem_data[iItem][ktv_TextAddr])
        end if

        tvitem_data[iItem] = ktv_Blank

        iParent = tvitem_parent[iItem]
        tvitem_parent[iItem] = 0
        if not find(iParent, tvitem_parent) then
            tvitem_data[iParent][ktv_HasChildren] = 0
            -- Need to reset cChildren flag
            setTVParent(iParent, 0)
        end if

        VOID=sendMessage(tvitem_owner[iItem],TVM_DELETEITEM,0,tvitem_handle[iItem])
        tvitem_owner[iItem] = -1 -- Remove link to owner
        -- Remove this from the internal table if it is the end one.
        if iItem = length(tvitem_data) then
            tvitem_data   = tvitem_data [1..length(tvitem_data)-1]
            tvitem_owner  = tvitem_owner[1..length(tvitem_owner)-1]
            tvitem_parent = tvitem_parent[1..length(tvitem_parent)-1]
            tvitem_handle = tvitem_handle[1..length(tvitem_handle)-1]
        end if
end procedure

--/topic Attributes
--/func idToIndex(object id)
--/desc Given an item id, returns its index in the control parent.
--/ret (INTEGER) The 1-based position of the item.
-- /i id is either a menu (item) id, a TabItem id, or a pair {parent id,item id}, where the
-- parent id is the one of a ListView or TreeView control.
global function idToIndex(object id)
atom struct,hch
integer idx

        if atom(id) then
            if find(ctrl_Family[id],{MENUITEM,MENU}) then
                return find(id,ctrl_Group[ctrl_Parent[id]])
            elsif ctrl_Type[id]=TabItem then
                return find(id,ctrl_Specific[ctrl_Parent[id]])
            else
                return 0
            end if
        else
            if ctrl_Type[id[1]]=ListView then
                if lvitem_owner[id[2]]!=id[1] then
                    return 0
                else
                    struct=w32acquire_mem(0,20)
                    poke4(struct,LVFI_PARAM)
                    poke4(struct+8,id[2])
                    id=sendMessage(id[1],LVM_FINDITEM,-1,struct)
                    w32release_mem(struct)
                    return id
                end if
            elsif ctrl_Type[id[1]]=TreeView then
                if id[2]=0 or lvitem_owner[id[2]]!=id[1] then
                    return 0
                else
                    struct=tvitem_handle[id[2]]
                    hch=sendMessage(id[1],TVM_GETNEXTITEM,TVGN_CHILD,tvitem_handle[tvitem_parent[id[2]]])
                    idx=1
                    while hch!=struct do
                        hch=sendMessage(id[1],TVM_GETNEXTITEM,TVGN_NEXT,hch)
                        idx+=1
                    end while
                    return idx
                end if
            else
                return 0
            end if
        end if
end function

--/topic Attributes
--/func indexToId(integer parent,object idx)
--/desc Given a parent control id and an index, returns an id for the item with that index.
--/ret (INTEGER) The item id for the requested item.
-- The parent may be either a Menu, TabControl, ListView or TreeView. Otherwise, an 
-- invalid id of -1 is returned.
-- If the parent is a TreeView, the index must have the form {parent node,index}, where
-- parent node is the TreeView item id of the parent node of the sought after item.
global function indexToId(integer parent,object idx)
atom struct,hch

        if ctrl_Family[parent]=MENU then
            return ctrl_Group[parent][idx]
        elsif ctrl_Type[parent]=TabControl then
            return ctrl_Specific[parent][idx]
        elsif ctrl_Type[parent]=ListView then
            struct = w32acquire_mem(0,SIZEOF_LVITEM)
            w32store(struct,LVITEM_mask,LVIF_PARAM)
            w32store(struct,LVITEM_iItem,idx-1)
            parent = sendMessage(parent,LVM_GETITEM,0,struct)
            parent = w32fetch(struct,LVITEM_lParam)
            w32release_mem(struct)
            return parent
        elsif ctrl_Type[parent]=TreeView then
            if atom(idx) or tvitem_owner[idx[1]]!=parent then
                return -1
            end if
            hch = sendMessage(parent,TVM_GETNEXTITEM,TVGN_CHILD,tvitem_handle[idx[1]])
            for i=2 to idx[2] do
                hch = sendMessage(parent,TVM_GETNEXTITEM,TVGN_NEXT,hch)
            end for
            return find(hch,tvitem_handle)
        else
            return -1
        end if
end function

--/topic ListView Control
--/proc setLVItemlParam(integer id, integer pRow, atom lParam)
--/desc Sets the user-defined data for this specific row in the list.
--This data is got by /getLVItemlParam and can be any 32-bit integer.
--
--Example
--/code
--       -- Set the data for the second row in the list.
--       setLVItemlParam(myLV, 2, 17)
--/endcode
global procedure setLVItemlParam(integer id, integer pRow, object lParam)
        lvitem_lparam[indexToId(id,pRow)] = lParam
end procedure

--/topic List Control
--/const w32AllItems
--/desc This signifies that all items are to be deleted.
--
--/code
--      atom rc
--      rc = deleteItem(myCombo, w32AllItems)
--/endcode
global constant w32AllItems = -1

-----------------------------------------------------------------------------
--/topic List Control
--/func deleteItem(list, position)
--/desc Delete item from /i list's list at position /i.
--/ret ATOM: 0 indicates failure.
-- The /i position starts at 1.
--
-- Example:
--/code
--          -- delete item 2 from the list
--          /deleteItem(TheList, 2)
--/endcode
--
-- /deleteItem() also works with list view and tree view controls.
-- /i position should be the item id returned when the item was
-- created.  To delete all items in a list view or tree view,
-- /i position should be -1.

global function deleteItem(atom id, integer pos)

-- deletes an item at position

integer msg
atom lRC
sequence lExtra
integer lEventType

atom lParam, iItem

        lParam = 0
        lExtra = {w32CHG_Del}

        -- get the message, based on control type
        if ctrl_Family[id] = LISTBOX then
            lEventType = w32HDataChange
            if pos = w32AllItems then
                msg = LB_RESETCONTENT
                pos = 1
                lExtra &= 0
            else
                msg = LB_DELETESTRING
                lExtra &= pos
            end if

        elsif ctrl_Family[id] = COMBO
           or ctrl_Type[id] = ComboBoxEx then
            lEventType = w32HDataChange
            if pos = w32AllItems then
                msg = CB_RESETCONTENT
                pos = 1
                lExtra &= 0
            else
                msg = CB_DELETESTRING
                lExtra &= pos
            end if

        elsif ctrl_Type[id] = ListView then
            lEventType = w32HChange
            if pos = w32AllItems then
                msg = LVM_DELETEALLITEMS
                pos = 1
                for i=1 to length(lvitem_owner) do
                    if lvitem_owner[i]=id then
                        lvitem_owner[i] = -1
                    end if
                end for
            else
                msg = LVM_DELETEITEM
                lExtra &= pos
                lvitem_owner[indexToId(id,pos)] = -1
            end if

        elsif ctrl_Type[id] = TreeView then
            lEventType = w32HChange
            msg = TVM_DELETEITEM
            if pos = w32AllItems then
                lParam = TVI_ROOT
                pos = 1
                -- changed to only delete items in the treeview specified
                iItem = 1
                lExtra &= 0
                while iItem <= length(tvitem_owner) do
                    if tvitem_owner[iItem] = id then
                        removeTVItem(iItem)
                        if iItem <= length(tvitem_owner) then
                            iItem += 1
                        end if
                    else
                        iItem += 1
                    end if

                end while
            else
                -- take care of any children
                iItem = find(pos, tvitem_parent)
                while iItem do
                    VOID = deleteItem(id, iItem)
                    iItem = find(pos, tvitem_parent)
                end while

                lParam = tvitem_handle[pos]
                removeTVItem(pos)
                lExtra &= pos
            end if
            pos = 1


        end if


        lRC =  sendMessage(id, msg, pos-1, lParam)

        VOID = invokeHandler(id, lEventType, lExtra)

        return lRC
end function



-- TreeView wrappers

--BEG CJT01: Additions made by Sascha Zindel and posted by C.K. Lester
-----------------------------------------------------------------------------
--/topic TreeView Control
--/func deleteTVChildren(TheTreeView, position)
--/desc Deletes all children at "position" in the /i tree view.
--
-- Example:
--/code
--          atom position
--          position = getTVIndex(TheTreeView)
--          /deleteTVChildren(TheTreeView, position)
--/endcode

global procedure deleteTVChildren(integer id, integer pos)
atom iItem
        if ctrl_Type[id] = TreeView then
            -- take care of any children
            iItem = find(pos, tvitem_parent)
            while iItem do
                VOID = deleteItem(id, iItem)
                iItem = find(pos, tvitem_parent)
            end while
        end if
end procedure

-----------------------------------------------------------------------------
--/topic TreeView Control
--/func getTVChildren(TheTreeView, position)
--/desc Returns all child items for the passed item in the /i tree view.
--
-- Example:
--/code
--          atom position
--          sequence children
--
--          position = getTVIndex(TheTreeView)
--          children = /getTVChildren(TheTreeView, position)
--/endcode

global function getTVChildren(integer id, integer pos)
sequence children

        children = {}

        if ctrl_Type[id] = TreeView then
             -- take care of any children
            for i=1 to length(tvitem_parent) do
                if tvitem_owner[i] = id and tvitem_parent[i] = pos then
                    children &= i
                    children &= getTVChildren(id, i)
                end if
            end for
        end if
        return children
end function
--END CJT01

--/topic TreeView Control
--/func getTVParent(id)
--/desc Get the parent id of a /TreeView item.
--/ret id of parent item, or 0 if item is at root, or -1 if /i id is invalid.
-- Note well. /i id is a TreeView ITEM and not the TreeView control.
global function getTVParent(integer id)
        if id > 0 and id <= length(tvitem_data) then
            return tvitem_parent[id]
        else
            return -1
        end if
end function

--/topic TreeView Control
--/func addTVItem(integer id, atom iImage, atom iSelectedImage, sequence text, integer iParent)
--/desc Add an item to a /TreeView
--/ret Index to item.
-- /li /b id: /TreeView to add to
-- /li /b iImage: Index to default image
-- /li /b iSelectedImage: Index to image for when item is selected
-- /li /b text: String of text to be displayed for item
-- /li /b iParent: index of parent item.  Should be 0 if item is at root.
-- See /addIcon, /addEuBmp, /addXpm, /addDIB for information on
-- using images with /TreeViews.

global function addTVItem(integer id, atom iImage, atom iSelectedImage,
                            sequence text, integer iParent)
atom TV_ITEM, TV_INSERTSTRUCT, hNewItem, lParam, hParent
atom mset

        -- need to get hParent, since we only have our own id number to
        -- go by.  We can search based on lParam.
        mset = w32new_memset()

        lParam = find(-1, tvitem_owner)
        if not lParam then
            tvitem_data &= {ktv_Blank}
            tvitem_owner &= id
            tvitem_parent &= iParent
            tvitem_handle &= 0
            lParam = length(tvitem_data)
        else
            tvitem_data[lParam] = ktv_Blank
            tvitem_owner[lParam] = id
            tvitem_parent[lParam] = iParent
        end if

        if ctrl_Menu[id]!=hILsmall then
            iImage=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[iImage]})+1
            iSelectedImage=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[iSelectedImage]})+1
        end if

        if iParent > 0 then
            hParent = tvitem_handle[iParent]
        else
            hParent = 0
        end if

        TV_ITEM = w32to_memory(0,ID_TVITEM, {tvitem_MASK, 0, 0, 0, {{},{LPSTR_TEXTCALLBACK,0}},
                                             iImage-1, iSelectedImage-1, 0, lParam})
        w32manage_mem(mset, TV_ITEM)
        -- ??? why using a calback when no user-defined routine is supplied?

        TV_INSERTSTRUCT = w32to_memory(0,ID_TVINSERTSTRUCT, {hParent, TVI_LAST,TV_ITEM})
        w32manage_mem(mset, TV_INSERTSTRUCT)

        hNewItem = sendMessage(id, TVM_INSERTITEM, 0, TV_INSERTSTRUCT)

        tvitem_handle[lParam] = hNewItem
        tvitem_data[lParam][ktv_NormImage] = iImage
        tvitem_data[lParam][ktv_SelectImage] = iSelectedImage
        tvitem_data[lParam][ktv_TextAddr] = w32acquire_mem(0,text)
        tvitem_data[lParam][ktv_TextSize] = length(text)
        tvitem_data[lParam][ktv_HasChildren] = w32False

        if iParent>0 and not tvitem_data[iParent][ktv_HasChildren] then
            setTVParent(iParent, 1)
        end if

        w32release_mem(mset)

        return lParam

end function

function tv_release(atom struct,integer item)
        w32release_mem(struct)
        return item
end function

--/topic TreeView Control
--/func getTVIndex(atom id)
--/desc Find which is the selected item in a treeview.
--/ret 0 if none selected, otherwise the Treeview item id that is selected.
--
--/code
--        integer theItem
--        theItem = getTVIndex(theTreeview)
--        if theItem != 0 then
--           -- found a selected item
--        end if
--/endcode
global function getTVIndex(integer id)
atom state, hItem, hChild, TV_ITEM
sequence path

        hItem = sendMessage(id, TVM_GETNEXTITEM, 0, TVGN_ROOT)
        TV_ITEM = w32to_memory(0,ID_TVITEM, {TVIF_STATE+TVIF_PARAM, hItem})
        path = {}

        while 1 do
            VOID = sendMessage(id, TVM_GETITEM, 0, TV_ITEM)
            state = w32fetch(TV_ITEM, TVITEM_state)

            if and_bits(state,TVIS_SELECTED) then
                -- assuming only one item is selected at a time
                return tv_release(TV_ITEM,w32fetch(TV_ITEM,TVITEM_lParam))
            end if

            hChild = sendMessage(id, TVM_GETNEXTITEM, TVGN_CHILD, hItem)
            if hChild then
                path &= hItem
                hItem = hChild
            else
                hItem = sendMessage(id, TVM_GETNEXTITEM, TVGN_NEXT, hItem)
                while not hItem do
                    if not length(path) then
                        return tv_release(TV_ITEM,0)
                    end if
                    hItem=path[length(path)]
                    path=path[1..length(path)-1]
                    hItem = sendMessage(id, TVM_GETNEXTITEM, TVGN_NEXT, hItem)
                end while
            end if

            w32store(TV_ITEM, TVITEM_hItem, hItem)
        end while

end function

--/topic TreeView Control
--/func getTVText(integer iItem)
--/desc Gets the text associated with a TreeView item with id /i iItem.
--/ret SEQUENCE: The item's text.
--
--/code
--       sequence text
--       atom anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--       text = getTVText(anItem)
--/endcode
global function getTVText(integer item)

        if item > 0 and item <= length(tvitem_handle) then
            return w32peek_string(tvitem_data[item][ktv_TextAddr])
        else
            return ""
        end if

end function

--/topic TreeView Control
--/func getTVSelectedText(integer id)
--/desc Gets the text associated with the selected item in a TreeView.
--/ret SEQUENCE: The selected item's text.
--
--/code
--       sequence text
--       text = getTVSelectedText(theTreeView)
--/endcode
global function getTVSelectedText(integer id)
        return getTVText(getTVIndex(id))
end function

--/topic TreeView Control
--/proc setTVText(integer iItem, sequence NewText)
--/desc Sets the text associated with a TreeView item.
--
--/code
--       integer anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--        setTVText(anItem, "G'Day")
--/endcode
global procedure setTVText(integer iItem, sequence pNewText)

        if iItem > 0 and iItem <= length(tvitem_data) then
            w32release_mem(tvitem_data[iItem][ktv_TextAddr])
            tvitem_data[iItem][ktv_TextAddr] = w32acquire_mem(0, pNewText)
            tvitem_data[iItem][ktv_TextSize] = length(pNewText)
        end if

end procedure


--/topic TreeView Control
--/proc setTVImages(integer iItem, atom NewImage, atom NewSelected)
--/desc Sets the images associated with a TreeView item.
-- /i NewImage is the image used for an unselected item, and /i NewSelected
-- is the image used when the item is selected. /n
-- If either /i NewImage or /i NewSelected is -1, the respective image
-- is not changed.
--
--/code
--       integer anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--        setTVImages(anItem, img3, -1)
--/endcode
global procedure setTVImages(integer pItem, atom pNewImage, atom pSelected)
atom lTVITEM
-- PL 29/4/09
--atom lMask,hIcon
atom lMask

        if pItem <= 0 or pItem > length(tvitem_data) then
            return
        end if

        lTVITEM = w32acquire_mem(0, SIZEOF_TVITEM)
        lMask = TVIF_HANDLE
        if pNewImage > 0 then
            lMask = TVIF_IMAGE
            if ctrl_Menu[tvitem_owner[pItem]]!=hILsmall then
                pNewImage=w32Func(ImageList_AddIcon,{ctrl_Menu[tvitem_owner[pItem]],ilicon_list[pNewImage]})
            else
                pNewImage-=1
            end if
            w32store(lTVITEM, TVITEM_iImage, pNewImage)
        end if
        if pSelected > 0 then
            lMask = or_bits(lMask, TVIF_SELECTEDIMAGE)
            if ctrl_Menu[tvitem_owner[pItem]]!=hILsmall then
                pSelected=w32Func(ImageList_AddIcon,{ctrl_Menu[tvitem_owner[pItem]],ilicon_list[pSelected]})
            else
                pSelected-=1
            end if
            w32store(lTVITEM, TVITEM_iSelectedImage, pSelected)
        end if

        if lMask = TVIF_HANDLE then
            return
        end if

        w32store(lTVITEM, TVITEM_mask, lMask)
        w32store(lTVITEM, TVITEM_hItem, tvitem_handle[pItem])

        VOID = sendMessage(tvitem_owner[pItem], TVM_SETITEM, 0, lTVITEM)

        w32release_mem(lTVITEM)
end procedure

--/topic TreeView Control
--/proc expandItem(id)
--/desc Show the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created.
global procedure expandItem(integer item)
        if item > 0 and item <= length(tvitem_data) then
            VOID = sendMessage(tvitem_owner[item],
                               TVM_EXPAND, TVE_EXPAND, tvitem_handle[item])
        end if
end procedure

--/topic TreeView Control
--/proc collapseItem(id)
--/desc Hides the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created.
global procedure collapseItem(integer item)
        if item > 0 and item <= length(tvitem_data) then
            VOID = sendMessage(tvitem_owner[item],
                               TVM_EXPAND, TVE_COLLAPSE, tvitem_handle[item])
        end if
end procedure

--/topic TreeView Control
--/proc toggleItem(id)
--/desc Shows or Hides the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created. /n
-- If the item has its children hidden, this shows them. /n
-- If the item has its children shown, this hides them. /n
global procedure toggleItem(integer item)
        if item > 0 and item <= length(tvitem_data) then
            VOID = sendMessage(tvitem_owner[item],
                               TVM_EXPAND, TVE_TOGGLE, tvitem_handle[item])
        end if
end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc defineUserProperty(object pControl, object pPropId, object pData)
--/desc Defines a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i pPropId specifies a unique 'name' for the property. /n
--/i pData is the data used to initialize the property. This value is also used
-- by /resetUserProperty.
--
--This is used to create a property or attribute of a control that is not
-- standard. You  can use this property however you like. The most common
-- usage is to store information for specific controls that are not
-- normally tracked.
--
--Example:
--/code
--      -- Create a property called 'OrigValue' for three controls.
--      defineUserProperty({fldName, fldAddr, fldPhone},
--                          "OrigValue", "")
--/endcode
global procedure defineUserProperty(object pControl, object pPropId, object pData)
integer lPropIdx
        if sequence(pControl) then
            for i=1 to length(pControl) do
                defineUserProperty(pControl[i], pPropId, pData)
            end for
            return
        end if

        if not validId(pControl) then
            return
        end if

        -- See if this has already been defined for the control.
        if integer(pPropId) then

            lPropIdx = pPropId
            if lPropIdx > length(ctrl_IntData[pControl][tagPropData]) then
                ctrl_IntData[pControl][tagPropInit] = append(ctrl_IntData[pControl][tagPropInit],
                                                             repeat(lPropIdx-length(ctrl_IntData[pControl][tagPropInit]), 0))
                ctrl_IntData[pControl][tagPropData] = append(ctrl_IntData[pControl][tagPropData],
                                                             repeat(lPropIdx-length(ctrl_IntData[pControl][tagPropData]), 0))
                ctrl_IntData[pControl][tagPropInit][lPropIdx] = pData
            end if
            ctrl_IntData[pControl][tagPropData][lPropIdx] = pData

        else
            lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

            -- If not, then add it a new property.
            if lPropIdx = 0 then
                ctrl_UserData[pControl][tagPropId] = append(ctrl_UserData[pControl][tagPropId], pPropId)
                ctrl_UserData[pControl][tagPropInit] = append(ctrl_UserData[pControl][tagPropInit], pData)
                ctrl_UserData[pControl][tagPropData] = append(ctrl_UserData[pControl][tagPropData], pData)
            else
                -- else change the property's initial data value.
                ctrl_UserData[pControl][tagPropInit][lPropIdx] = pData
            end if

        end if
end procedure
r_defineUserProperty = routine_id("defineUserProperty")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setUserProperty(object id, object PropId, object Data)
--/desc Stores data into a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i PropId specifies a property defined by an early call to /defineUserProperty /n
--/i Data is any data you wish to store in that property. /n
--
--/b Note: If the property named in /i PropId hasn't been defined yet for
-- /i id, this routine will automatically define it, using /i Data as the
-- default value for it.
--
--Example:
--/code
--      -- Set the original values for these fields.
--      setUserProperty(fldName, "OrigValue", lRecord[cName])
--      setUserProperty(fldAddr, "OrigValue", lRecord[cAddr])
--      setUserProperty(fldPhone, "OrigValue", lRecord[cPhone])
--/endcode
global procedure setUserProperty(object pControl, object pPropId, object pData)
integer lPropIdx

        if sequence(pControl) then
            for i=1 to length(pControl) do
                setUserProperty(pControl[i], pPropId, pData)
            end for
            return
        end if

        if not validId(pControl) then
            return
        end if

        -- See if this has already been defined for the control.
        if integer(pPropId) then

            if pPropId > length(ctrl_IntData[pControl][tagPropInit]) then
                defineUserProperty(pControl, pPropId, pData)
            else
                ctrl_IntData[pControl][tagPropData][pPropId] = pData
            end if
        else
            lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

            -- If yes, set the new value
            if lPropIdx = 0 then
                defineUserProperty(pControl, pPropId, pData)
            else
                ctrl_UserData[pControl][tagPropData][lPropIdx] = pData
            end if
        end if

end procedure
r_setUserProperty = routine_id("setUserProperty")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc resetUserProperty(object pControl, object pPropId)
--/desc Initializes a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i pPropId specifies a property defined by an early call to /defineUserProperty.
-- The property is reset to the initial value originally supplied
-- when defined with /defineUserProperty.
--
--Example:
--/code
--      -- Set the original values back to their initial value.
--      resetUserProperty({fldName,fldAddr, fldPhone}, "OrigValue")
--/endcode
global procedure resetUserProperty(object pControl, object pPropId)
integer lPropIdx

        if sequence(pControl) then
            for i=1 to length(pControl) do
                resetUserProperty(pControl[i], pPropId)
            end for
            return
        end if

        if not validId(pControl) then
            return
        end if

        -- See if this has already been defined for the control.
        if integer(pPropId) then

            if pPropId <= length(ctrl_IntData[pControl][tagPropData]) then
                ctrl_IntData[pControl][tagPropData][pPropId] =
            ctrl_IntData[pControl][tagPropInit][pPropId]
            end if
        else
            lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

            -- If yes, set the value to the initialisation value
            if lPropIdx != 0 then
                ctrl_UserData[pControl][tagPropData][lPropIdx] =
            ctrl_UserData[pControl][tagPropInit][lPropIdx]
            end if
        end if
end procedure


-----------------------------------------------------------------------------
--/topic Attributes
--/func getUserProperty(object pControl, object pPropId)
--/desc Retrieves data from a user defined property for this control /i id.
--/ret Sequence: The contents of the user defined property.
-- /i pControl specifies the id of the control. This can be either a
-- single id, or a list of ids in a sequence. /n
-- /i pPropId specifies a
-- property defined by an early call to /defineUserProperty. /n
-- The data is returned as the first, and only, element in a sequence.
-- If an empty sequence is returned, it means that the specified
-- property has not been defined for this control. /n
-- If /i id is a sequence, then the returned sequence contains two
-- subsequences. The first is a list of the returned property values and
-- the second is a list of w32True/w32False values; one per control listed
-- in /i id. A w32True indicates that the respective control has this property
-- set and w32False indicates that it has not been set.
--
--Examples:
--
--/code
--      sequence lValues
--      lValues = getUserProperty(fldX, "Animation")
--      if length(lValues) = 0 then
--          -- No value, so use a default.
--          lValues = {20}
--      end if
--      -- NB: The property value is always in element[1]!
--      doAnimation(lValues[1])
--/endcode
--
-- This next example shows how to get the property values from a list of controls
--/code
--      sequence lValues
--      sequence lFlds
--
--      lFlds = {fldA, fldB, fldC}
--      lValues = getUserProperty(lFlds, "TimeOut")
--      for i=1 to length(lValues) do
--          if lValues[2][i] = w32False then
--              -- Provide a default value then.
--              lValues[1][i] = 5
--          end if
--          -- Process the property value which is in lValues[1][i]
--          doSomethingClever(lFlds[i], lValues[1][i])
--      end for
--/endcode
global function getUserProperty(object pControl, object pPropId)
sequence lData
integer lPropIdx
integer lMultiple

        lData = {{},{}}
        if atom(pControl) then
            pControl = {pControl}
            lMultiple = w32False
        else
            lMultiple = w32True
        end if

        for i=1 to length(pControl) do
            if validId(pControl[i]) then

                -- See if this has already been defined for the control.
                if integer(pPropId) then

                    if pPropId <= length(ctrl_IntData[pControl[i]][tagPropData]) then
                        lData[1] = append(lData[1], ctrl_IntData[pControl[i]][tagPropData][pPropId])
                        lData[2] &= w32True
                    else
                        lData[1] &= w32False
                        lData[2] &= w32False
                    end if
                else
                    lPropIdx = find(pPropId, ctrl_UserData[pControl[i]][tagPropId])

                    -- If yes, return the value
                    if lPropIdx != 0 then
                        lData[1] = append(lData[1], ctrl_UserData[pControl[i]][tagPropData][lPropIdx])
                        lData[2] &= w32True
                    else
                        lData[1] &= w32False
                        lData[2] &= w32False
                    end if
                end if
            end if
        end for

        if lMultiple = w32False then
            if length(lData[2]) > 0 and lData[2][1] = w32True then
                lData = lData[1]
            else
                lData = {}
            end if
        end if
        return lData
end function
r_getUserProperty = routine_id("getUserProperty")

--/topic Attributes
--/proc deleteUserProperty(object pControl, object pPropId)
--/desc Deletes a user defined property for this control /i id.
-- /i pControl specifies the id of the control. This can be either a
-- single id, or a list of ids in a sequence. /n
-- /i pPropId specifies a
-- property defined by an early call to /defineUserProperty. /n
--
--Examples:
--
--/code
--      deleteUserProperty(fldX, "Animation")
--      deleteUserProperty({fldA, fldB, fldC}, "TimeOut")
--/endcode

global procedure deleteUserProperty(object pControl, object pPropId)
integer lIdx

        if atom(pControl) then
            pControl = {pControl}
        end if

        for i=1 to length(pControl) do
            if not integer(pPropId) then
                lIdx = find(pPropId, ctrl_UserData[pControl[i]][tagPropId])
                if lIdx != 0 then
                    ctrl_UserData[pControl[i]][tagPropId] = w32removeIndex(lIdx, ctrl_UserData[pControl[i]][tagPropId])
                    ctrl_UserData[pControl[i]][tagPropData] = w32removeIndex(lIdx, ctrl_UserData[pControl[i]][tagPropData])
                end if
            end if
        end for

end procedure
r_deleteUserProperty = routine_id("deleteUserProperty")

--/topic Controls
--/proc closeWindow(window)
--/desc Close /i window.
-- If /i window is not a main window, /i window will be hidden
-- and the /Close event will be triggered.
--
-- If /i window is the /b "main window" (see /WinMain) or zero, then the
-- application will be shut down and the /Close event will
--
-- If /i window is not a valid id, then no action is taken.
--
-- Example:
--
--/code
--          -- close TheDialog
--          /closeWindow(TheDialog)
--/endcode

global procedure closeWindow(integer id)
        if id = 0 then
            id = mainWindow
        end if
        if validId(id) then
            -- close the window
            VOID = sendMessage(id, WM_CLOSE, 0, 0)
        end if

end procedure
r_closeWindow = routine_id("closeWindow")

global procedure autoclose(integer self, integer event, sequence parms)
--/**/  if event or sequence(parms) then end if -- suppress warnings    -- PL 29/4/09
        closeWindow(findParentWindow(self))
end procedure
r_autoclose = routine_id("autoclose")

integer vEmptySlots
vEmptySlots = 16

--/topic Controls
--/proc setControlBlocks(integer pQty)
--/desc Sets the number of new memory areas created for new controls
--Whenever a new control is created, it requires some memory to be allocated
--to manage it, and because this can be a performance hit win32lib has the
-- ability to created multiple new control blocks in one operation. This
-- means that when a new control is being created, and there is no available
-- control blocks, it will create /i pQty control blocks so that the next
-- new control doesn't have to allocate memory. Initially win32lib will
-- allocate 16 new control memory blocks. /n
-- /b Note: /i pQty must be 1 or more, otherwise 16 will be used.
--
--Example
--/code
--          -- lots of Controls will be created in this app
--          -- so allocate all the control blocks in one go.
--          setControlBlocks(147)
--          -- The first new create() will actually allocate the memory.
--          constant myWin = /create(Window, ...)
--/endcode

---------------------------------------------------------
global procedure setControlBlocks(integer pQty)
---------------------------------------------------------
        if pQty >= 1 then
            vEmptySlots = pQty
        else
            vEmptySlots = 16
        end if
end procedure


--/topic MouseTraps
--/info
--Defined sub-regions of a window that can generate /w32HMouseTrap events.
--These are used to make it easy to detect mouse activity in specific sub-regions of a window or other control.


--/topic MouseTraps
--/func createMouseTrap(integer pWindow, object pRect)
--/desc Defines a mousetrap area
--/ret INTEGER: A mousetrap ID.
--This defines an subregion of /i pWindow, bounded by /i pRect that can generate
-- /w32HMouseTrap events. /n
--/i pWindow is a top-level Window control. It must not have any parent. /n
--/i pRect is either a four-element sequence in the form
-- {left, top, right, bottom} relative to /i pWindow, or the id of a
-- child control of /i pWindow. In the second case, the mousetrap covers the entire
-- area of the child control.
--
--Example:
--/code
--      integer mt
--      mt1 = createMouseTrap(myWin, {10,10,30,30})
--      mt2 = createMouseTrap(myWin, myBitMap)
--/endcode

---------------------------------------------------------
global function createMouseTrap(integer pWindow, object pRect)
---------------------------------------------------------
integer lNewMouseTrap
integer lRelId

        if atom(ctrl_Mousetrap[pWindow]) then
            ctrl_Mousetrap[pWindow] = repeat(-1, 10)
        end if

        lNewMouseTrap = find(-1, ctrl_Mousetrap[pWindow])
        if lNewMouseTrap = 0 then
            lNewMouseTrap = length(ctrl_Mousetrap[pWindow])+1
            ctrl_Mousetrap[pWindow] &= repeat(-1, 10)
        end if

        if atom(pRect) then
            lRelId = pRect
            pRect = call_func(r_getRect,{lRelId})
            pRect = pRect[1..4]
            if findParent(lRelId) != pWindow then
            -- Convert coordinates so they are relative to window.
-- PL 29/4/09
--/**/          pRect[3..4] = sq_sub(pRect[3..4],pRect[1..2])                   --/* Pve
                pRect[3..4] -= pRect[1..2]                                      -- RDS */
                pRect[1..2] = clientToClient(lRelId, pWindow, pRect[1..2])
                pRect[3..4] = clientToClient(lRelId, pWindow, pRect[3..4])
            end if
        end if
        ctrl_Mousetrap[pWindow][lNewMouseTrap] = 0 & pRect & w32True & 0 & {{WM_LBUTTONDOWN}}

        return lNewMouseTrap
end function


--/topic MouseTraps
--/proc updateMouseTrap(integer pWindow, integer pMouseTrap, object pRect)
--/desc This changes the bounding rectangle for a mousetrap.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to update. /n
--/i pRect is either a four-element sequence in the form
-- {left, top, right, bottom} relative to the /i pWindow control, or the id of a
-- child control of /i pWindow. In the second case, the mousetrap covers the entire
-- area of the child control. /n
--
--/b Note that if the specified mousetrap does not exist, it will be created
-- automatically.
--
--Example:
--/code
--      updateMouseTrap(myWin, 2, {20,17,156, 281})
--      updateMouseTrap(myWin, 1, myBitMap)
--/endcode
---------------------------------------------------------
global procedure updateMouseTrap(integer pWindow, integer pMouseTrap, object pRect)
---------------------------------------------------------
        if atom(ctrl_Mousetrap[pWindow]) then
            ctrl_Mousetrap[pWindow] = repeat(-1, 10)
        end if
        if pMouseTrap > length(ctrl_Mousetrap[pWindow]) then
            ctrl_Mousetrap[pWindow] = repeat(-1, pMouseTrap-length(ctrl_Mousetrap[pWindow]))
        end if

        if atom(pRect) then
            pRect = call_func(r_getRect,{pRect})
            pRect = pRect[1..4]
        end if
        if atom(ctrl_Mousetrap[pWindow][pMouseTrap]) then
            ctrl_Mousetrap[pWindow][pMouseTrap] = 0 & pRect & w32True & 0 & {{WM_LBUTTONDOWN}}
        else
            ctrl_Mousetrap[pWindow][pMouseTrap][2..5] = pRect
        end if
end procedure

--/topic MouseTraps
--/proc deleteMouseTrap(integer pWindow, integer pMouseTrap)
--/desc This removes the specified mousetrap area from the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to remove. /n
--
--/b Note that if /i pMouseTrap is less than one, all mousetraps
-- for the window will be deleted.
--
--Example:
--/code
--      -- Remove mousetrap #3
--      deleteMouseTrap(MyWindow, 3)
--      -- Remove all mousetraps from the window.
--      deleteMouseTrap(DiagWin, -1)
--/endcode
---------------------------------------------------------
global procedure deleteMouseTrap(integer pWindow, integer pMouseTrap)
---------------------------------------------------------
        if pMouseTrap > 0 then
            ctrl_Mousetrap[pWindow][pMouseTrap] = -1
        else
            -- Remove all mousetraps.
            ctrl_Mousetrap[pWindow] = -1
        end if
end procedure

--/topic MouseTraps
--/proc enableMouseTrap(integer pWindow, object pMouseTrap, integer pState)
--/desc This alters the 'enabled' state of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to enable. /n
--/i pState is either w32True or w32False. A setting of w32False will prevent this mousetrap
-- from generating events.
--
--/b Note that /i pMouseTrap can also be a list of mousetrap Ids.
--
--Example:
--/code
--      -- Disable mousetrap #1
--      enableMouseTrap(myWin, 1, w32False)
--      -- Enable mousetraps #2, 8, 5, and 4.
--      enableMouseTrap(myWin, {2,8,5,4}, w32True)
--/endcode
---------------------------------------------------------
global procedure enableMouseTrap(integer pWindow, object pMouseTrap, integer pState)
---------------------------------------------------------
        if atom(pMouseTrap) then
            pMouseTrap = {pMouseTrap}
        end if
        for i=1 to length(pMouseTrap) do
            ctrl_Mousetrap[pWindow][pMouseTrap[i]][6] = pState
        end for
end procedure

--/topic MouseTraps
--/proc filterMouseTrap(integer pWindow, object pMouseTrap, object pEvents)
--/desc This alters the 'filters' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to filter. /n
--/i pEvents is a list of Windows mouse event codes. These are the only mouse events
-- that can cause this mousetrap area to react.
--
--/b Note that /i pMouseTrap can also be a list of mousetrap Ids.
--
--Example:
--/code
--      -- Check for Wheel movement
--      filterMouseTrap(myWin, 1, WM_WHEELMOUSE)
--      -- Check for Right Button events
--      filterMouseTrap(myWin, {2,8,5,4}, {WM_RBUTTONDOWN, WM_RBUTTONUP})
--/endcode
---------------------------------------------------------
global procedure filterMouseTrap(integer pWindow, object pMouseTrap, object pEvents)
---------------------------------------------------------
        if atom(pEvents) then
            pEvents = {pEvents}
        end if
        if atom(pMouseTrap) then
            pMouseTrap = {pMouseTrap}
        end if
        for i=1 to length(pMouseTrap) do
            ctrl_Mousetrap[pWindow][pMouseTrap[i]][8] = pEvents
        end for
end procedure

--/topic MouseTraps
--/proc zorderMouseTrap(integer pWindow, object pMouseTrap, integer pOrder)
--/desc This alters the 'depth' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to order. /n
--/i pOrder the absolute depth value. The higher the number, the further in the
-- background the mousetrap area is. Initially a mousetrap is created with a depth value
-- of zero. Negative numbers move the mousetrap closer to the foreground.
--
-- Use this if you have mousetrap areas that can overlap. When the w32HMouseTrap
-- event fires, you get a list of mousetrap areas sorted from closest (in foreground)
-- to furtherest (in background).
--
--Example:
--/code
--      -- move area #1 close to the front.
--      zorderMouseTrap(MyWindow, 1, -10)
--
--      -- Order things so that the man is in front of the
--      -- bush and the bush is in front of the wall.
--      zorderMouseTrap(MyWindow, Wall, 3)
--      zorderMouseTrap(MyWindow, Bush, 2)
--      zorderMouseTrap(MyWindow, Man, 1)
--
--/endcode
---------------------------------------------------------
global procedure zorderMouseTrap(integer pWindow, integer pMouseTrap, integer pOrder)
---------------------------------------------------------
        ctrl_Mousetrap[pWindow][pMouseTrap][1] = pOrder
end procedure

--/topic MouseTraps
--/proc setTagMouseTrap(integer pWindow, object pMouseTrap, object pData)
--/desc This alters the 'user data' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to hold the data. /n
--/i pData is any data you wish to store with this mousetrap.
--
-- Win32lib never uses this data. It is a convenience for the coder to
-- save data specific for the user-defined mousetrap event processing.
--
-- You can use /getTagMouseTrap() to retrieve this data.
--
--Example:
--/code
--      -- Save a routine id to handle things.
--      setTagMouseTrap(MyWindow, 1, routine_id("MT1_Catch"))
--
--      -- Save some color data
--      setTagMouseTrap(MyWindow, 2, {Red, Cyan, BrightGreen})
--
--/endcode
---------------------------------------------------------
global procedure setTagMouseTrap(integer pWindow, integer pMouseTrap, object pData)
---------------------------------------------------------
        ctrl_Mousetrap[pWindow][pMouseTrap][7] = pData
end procedure

--/topic MouseTraps
--/func getTagMouseTrap(integer pWindow, object pMouseTrap)
--/desc This fetches the data stored by /setTagMouseTrap()
--/ret OBJECT: Whatever the user data has been set for the mousetrap.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap that holds the data. /n
--
-- You must use /setTagMouseTrap() to store this data.
--
--Example:
--/code
--      -- Save a routine id to handle things.
--      setTagMouseTrap(MyWindow, 1, routine_id("MT1_Catch"))
--      . . .
--      -- Fetch the routine id to use.
--      rtnid = getTagMouseTrap(MyWindow, 1)
--      call_proc(rtnid, . . .)
--
--/endcode

global function getTagMouseTrap(integer pWindow, integer pMouseTrap)
        return ctrl_Mousetrap[pWindow][pMouseTrap][7]
end function

--/topic MouseTraps
--/func getMouseTrap(integer pWindow, object pMouseTrap)
--/desc This fetches all the information about the specified mousetrap.
--/ret OBJECT: -1 if /i pMouseTrap is not valid, otherwise a MouseTrap sequence.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap. /n
--
-- Each mousetrap is a sequence of 8 elements: /n
--/li integer: /b zorder, the higher numbers are further in the background. The
-- initial value is zero when a mousetrap is created.
--/li integer: /b left, the leftmost position of the mousetrap area
--/li integer: /b top, the topmost position of the mousetrap area
--/li integer: /b right, the rightmost position of the mousetrap area
--/li integer: /b bottom, the bottommost position of the mousetrap area
--/li integer: /b enableFlag, either w32True if enabled else w32False.
--/li object: /b userdata, the data set by calling /setTagMouseTrap(). This is
--never used by win32lib and is intended for use by the user for anything.
--/li sequence: /b filters, a list of zero or more mouse event codes that are used
--to filter in this mousetrap. Initially this set to {WM_LBUTTONDOWN} when
--then mousetrap is created. It can be changed by calling /filterMouseTrap().
--
--Example:
--/code
--      -- Fetch the mousetrap info.
--      object MT
--      MT = getMouseTrap(MyWindow, 1)
--      if atom(MT) then
--          -- the mousetrap doesn't exist.
--      else
--          -- process it...
--      end if
--/endcode
---------------------------------------------------------
global function getMouseTrap(integer pWindow, integer pMouseTrap)
---------------------------------------------------------
        if atom(ctrl_Mousetrap[pWindow]) or pMouseTrap>length(ctrl_Mousetrap[pWindow]) or pMouseTrap<1 then
            return -1
        end if
        return ctrl_Mousetrap[pWindow][pMouseTrap]
end function

--/topic MouseTraps
--/func hitMouseTrap(integer pWindow, integer pEvent, integer pX, integer pY)
--/desc This returns all mousetraps for the window that are under the /i pX and /i pY position.
--/ret SEQUENCE: A list of zero or more mousetraps.
--/i pWindow is the window that owns the mousetrap. /n
--/i pEvent used to filter. Only mousetraps looking for this event can be returned./n
--/i pX, /i pY are  coordinates. Only mousetraps that are under this position can be returned.
--
--/b Note that disabled mousetraps are ignored.
--
-- The returned list is sorted from closest to furtherest away, based on the z-order settings
-- of the mousetraps. These are set by calling /zorderMouseTrap().
--
--The format of each element in the returned list is :
--/li integer: /b zorder
--/li integer: /b left
--/li integer: /b top
--/li integer: /b right
--/li integer: /b bottom
--/li integer: /b "mousetrap id"
--/li object: /b userdata
--/li sequence: /b filters
--
--Example:
--/code
--      sequence MTList
--      -- Get all the mousetraps that are under (100,100) that are looking for
--      -- left button down events.
--      MTList = hitMouseTrap(myWindow, WM_LBUTTONDOWN, 100, 100)
--
--/endcode
---------------------------------------------------------
global function hitMouseTrap(integer pWindow, integer pEvent, integer pX, integer pY)
---------------------------------------------------------
sequence lMouseTraps
sequence lR

        if atom(ctrl_Mousetrap[pWindow]) then
            return {}
        end if

        lMouseTraps = {}
        lR = {}
        for i=1 to length(ctrl_Mousetrap[pWindow]) do
            if sequence(ctrl_Mousetrap[pWindow][i]) then
                lR = ctrl_Mousetrap[pWindow][i]
                if lR[6] = w32True and find(pEvent, lR[8])
                and lR[2] <= pX and lR[3] <= pY
                and lR[4] > pX and lR[5] > pY then
                    lR[6] = i
                    lMouseTraps = append(lMouseTraps, lR)
                end if
            end if
        end for

        if length(lMouseTraps) > 0 then
            lMouseTraps = sort(lMouseTraps)
        end if
        return lMouseTraps
end function

procedure statusbar_resize(integer self, integer event, sequence parms)
sequence lSize
integer lWidth
integer lHeight

--/**/  if event then end if -- suppress warnings   -- PL 29/4/09
        if parms[2] = w32HResize then
            -- get size of statusbar
            lSize = call_func(r_getClientRect,{self})
            lWidth = parms[4][2]
            lHeight = parms[4][3]

            -- calculate position
            VOID = w32Func(xMoveWindow,{getHandle(self), 0, lHeight-lSize[4], lWidth, 0, w32True})
        end if
end procedure

procedure toolbar_resize(integer self, integer event, sequence parms)
sequence lOuterSize
sequence lInnerSize
integer lWidth
--/**/  if event then end if -- suppress warnings   -- PL 29/4/09
        if parms[2] = w32HResize then
            -- get size of toolbar
            lInnerSize = call_func(r_getClientRect,{self})
            lWidth = parms[4][2]

            if lWidth != lInnerSize[3] then
                lOuterSize = call_func(r_getCtlSize,{self})
                VOID = w32Func(xMoveWindow, {getHandle(self), 0, 0, lWidth, lOuterSize[2], 1})
                repaintWindow(self)
            end if
        end if
end procedure

---------------------------------------------------------
function NewControl(integer pType, integer pOwner)
---------------------------------------------------------
-- Allocates an ID and management areas for a new control.
-- PL 29/4/09
--integer id,lTemp
integer id
sequence lEmptySlots

        -- look for an available slot

        id = ctlblk_freelist[1]
        if id = 0 then
            for i = length(ctrl_Destroyed) to vPrevCtlBlkLength by -1 do
                if ctrl_Destroyed[i] = -1 then
                    id = i
                    exit
                end if
            end for
        else
            ctlblk_freelist = ctlblk_freelist[2..length(ctlblk_freelist)]
        end if

        --id = find(-1, ctrl_Destroyed)
        if id = 0 then   -- create slots for attributes
            vPrevCtlBlkLength    = length(ctrl_Destroyed)+1
            lEmptySlots          = repeat(-1, vEmptySlots)
            ctrl_Destroyed       &= lEmptySlots
            ctrl_Handle          &= lEmptySlots
            ctrl_Handle_type     &= lEmptySlots
            ctrl_Function        &= lEmptySlots
            ctrl_Family          &= lEmptySlots
            ctrl_Type            &= lEmptySlots
            ctrl_Focus_order     &= lEmptySlots
            ctrl_Current_focus   &= lEmptySlots
            ctrl_Previous_focus  &= lEmptySlots
            ctrl_Parent          &= lEmptySlots
            ctrl_X_Pos           &= lEmptySlots
            ctrl_Y_Pos           &= lEmptySlots
            ctrl_Erase           &= lEmptySlots
            ctrl_Font            &= lEmptySlots
            ctrl_Pen             &= lEmptySlots
            ctrl_Fg_Color        &= lEmptySlots
            ctrl_Bg_Color        &= lEmptySlots
            ctrl_Scroll          &= lEmptySlots
            ctrl_Range           &= lEmptySlots
            ctrl_Specific        &= lEmptySlots
            ctrl_Group           &= lEmptySlots
            ctrl_Cursor          &= lEmptySlots
            ctrl_Menu            &= lEmptySlots
            ctrl_Popup           &= lEmptySlots
            ctrl_Notify_List     &= lEmptySlots
            ctrl_Toolbar         &= lEmptySlots
            ctrl_Statusbar       &= lEmptySlots
            ctrl_Hint_Text       &= lEmptySlots
            ctrl_Hint_Width      &= lEmptySlots
            ctrl_Hotkey_Keys     &= lEmptySlots
            ctrl_Hotkey_Ids      &= lEmptySlots
            ctrl_Text_Alignment  &= lEmptySlots
            ctrl_Closed          &= lEmptySlots
            ctrl_TabKey_Used     &= lEmptySlots
            ctrl_Handlers        &= lEmptySlots
            ctrl_Bg_Brush        &= lEmptySlots
            ctrl_UserData        &= lEmptySlots
            ctrl_IntData         &= lEmptySlots
            ctrl_Name            &= lEmptySlots
            ctrl_Init_Posns      &= lEmptySlots
            ctrl_ClassAddr       &= lEmptySlots
            ctrl_Mousetrap       &= lEmptySlots
            ctrl_Visible         &= lEmptySlots
            ctrl_SetVisible      &= lEmptySlots
            ctrl_HandlerStates   &= lEmptySlots
            ctrl_ActualClass     &= lEmptySlots
            ctrl_CanFocus        &= lEmptySlots
            ctrl_KbdInput        &= lEmptySlots
            ctrl_FormerId        &= lEmptySlots
            ctrl_Hatch           &= lEmptySlots
            ctrl_RecursivePaint  &= lEmptySlots
            ctrl_ProtectHandlers &= lEmptySlots


            id = length(ctrl_Destroyed)-vEmptySlots+1
        end if

        -- initialize to defaults
        ctrl_Destroyed[id]      = 0
        ctrl_Handle[id]         = -1
        ctrl_Handle_type[id]    = -1
        ctrl_Function[id]       = -1
        ctrl_Family[id]         = classType[pType]
        ctrl_Type[id]           = pType
        ctrl_Focus_order[id]    = {}
        ctrl_Current_focus[id]  = 0
        ctrl_Previous_focus[id] = 0
        ctrl_Parent[id]         = pOwner
        ctrl_X_Pos[id]          = 0
        ctrl_Y_Pos[id]          = 0
        ctrl_Erase[id]          = w32False
        ctrl_Font[id]           = FontDefaults
        ctrl_Pen[id]            = PenDefaults
        ctrl_Fg_Color[id]       = classFGColor[pType]
        ctrl_Bg_Color[id]       = classBGColor[pType]
        ctrl_Range[id]          = {{0,100},{0,100}}
        ctrl_Scroll[id]         = {{1,10}, {1,10}}
        ctrl_Specific[id]       = 0
        ctrl_Group[id]          = {}
        ctrl_Cursor[id]         = {w32Func(xLoadCursor, {NULL, classDefPointer[pType]})}
        ctrl_Menu[id]           = 0
        ctrl_Popup[id]          = {-1,-1,-1,-1} -- One for normal, shift, ctrl, shift-ctrl.
        ctrl_Notify_List[id]    = {{},{},{},{}}  -- {{id ...},{{events per id...}},{{userdata ...}},{{states per id ...}}}
        ctrl_Toolbar[id]        = {} -- a window may have several toolbars
        ctrl_Statusbar[id]      = 0
        ctrl_Hint_Text[id]      = ""
        ctrl_Hint_Width[id]     = 200
        ctrl_Hotkey_Keys[id]    = {}
        ctrl_Hotkey_Ids[id]     = {}
        ctrl_Text_Alignment[id] = TA_TOP
        ctrl_Closed[id]         = -11  -- Until its opened.
        ctrl_TabKey_Used[id]    = w32iff(and_bits(classAttr[pType], w32CtrlTab),0,1)
        ctrl_Handlers[id]       = repeat({}, w32LastEventType())
        ctrl_Bg_Brush[id]       = 0
        ctrl_UserData[id]       = {{},{},{}}
        ctrl_IntData[id]        = {{},{}}
        ctrl_Name[id]           = 0
        ctrl_Init_Posns[id]     = {{},{}}
        ctrl_ClassAddr[id]      = 0
        ctrl_Mousetrap[id]      = 0
        -- added CChris <oedoc@free.fr> Oct 26, 2006
        ctrl_Visible[id] = w32True
        ctrl_SetVisible[id] = w32True
        ctrl_HandlerStates[id] = repeat({}, w32LastEventType())
        ctrl_ActualClass[id] = pType
        ctrl_CanFocus[id] = 1
        ctrl_KbdInput[id] = -1
        ctrl_FormerId[id] = 0
        ctrl_Hatch[id] = 0
        ctrl_RecursivePaint[id] = 0
        ctrl_ProtectHandlers[id] = repeat(0, w32LastEventType())

        if pOwner > 0 and pOwner <= length(ctrl_Group) then
            ctrl_Group[pOwner] &= id
        end if

        if and_bits(classAttr[pType], w32AutoSelect) then
            ctrl_Specific[id] = w32True
        end if

        -- Changed CChris <oedoc@free.fr> Dec 23,2006
        -- moved this chunk from createEx() so that NewControl (hence subClassControl) can take care of nearly all parenthood issues
        if and_bits(classAttr[pType], w32Toolbar) then
            -- track toolbar in owner
            ctrl_Toolbar[pOwner] &= id
            setHandler(id, w32HNotify, routine_id("toolbar_resize"))
            call_proc(r_registerNotification, {pOwner, 1, w32HResize, id, 0})
        end if
        -- windows aren't supposed to have several status bars
        if and_bits(classAttr[pType], w32Statusbar)
        and ctrl_Statusbar[pOwner] = 0 then
            -- track statusbar in owner
            ctrl_Statusbar[pOwner] = id
            setHandler(id, w32HNotify, routine_id("statusbar_resize"))
            call_proc(r_registerNotification, {pOwner, 1, w32HResize, id, 0})
        end if

        return id
end function

procedure handleLV(integer id,atom flags,sequence lvcol)
-- CC: moved this chunk from createEx() so that subclassed LV could be handled right
-- set up image lists and columns
integer count,len
--PL 28/4
--  sequence attribs
object attribs
atom il

        if not ILlarge then
            ILlarge = call_func(r_createEx,{ImageList, "", 0, 0,0,SM_CXICON,0,ILC_COLOR8,0})
            ILsmall = call_func(r_createEx,{ImageList, "", 0, 0,0,SM_CXSMICON,0,ILC_COLOR8,0})
            hILlarge=ctrl_Handle[ILlarge]
            hILsmall=ctrl_Handle[ILsmall]
        end if

        if and_bits(LVS_REPORT, flags) != 0 then
            if not length(lvcol) then   -- subclassed control
                count = call_func(qSendMessage,{sendMessage(id,LVM_GETHEADER,0,0),HDM_GETITEMCOUNT,0,0})
                attribs = repeat('i',count)
                lv_id &= id
                lv_properties = append(lv_properties,{attribs,0,0})
                attribs = -2
                len=length(lv_properties)
                lv_properties[len][3] = attribs
                if and_bits(flags,LVS_SORTDESCENDING) then
                    attribs = -attribs
                end if
                lv_properties[len][2] = attribs
            else
                if w32string(lvcol) then
                    lvcol = {lvcol}
                end if
                for i=1 to length(lvcol) do
                    if sequence(lvcol[i]) then
                        if length(lvcol[i]) > 0 then
                            if not sequence(lvcol[i][1]) then
                                -- We only have a column heading
                                lvcol[i] = {lvcol[i], 100, 0}
                            else
                                if length(lvcol[i]) < 2 then
                                    -- No width, so set default
                                    lvcol[i] = append(lvcol[i], 100)
                                end if
                                if length(lvcol[i]) < 3 then
                                    -- No alignment, so set default
                                    lvcol[i] = append(lvcol[i], 0)
                                end if
                            end if
                        else
                            lvcol[i] = {"", 100,0}
                        end if
                    else
                        -- We only have a width.
                        lvcol[i] = {"", w32abs(floor(lvcol[i])),0}
                    end if
                    insertLVColumn(id, 0, 0,0,0,lvcol[i][1..3], i)
                end for
            end if
        end if

        il = sendMessage(id,LVM_GETIMAGELIST,LVSIL_SMALL,0)
        if il=0 or il=1 then -- this value of 1 is strange
            setImageList(id, ILlarge, LVSIL_NORMAL)
            setImageList(id, ILsmall, LVSIL_SMALL)
            ctrl_Menu[id] = hILsmall
        else
            ctrl_Menu[id] = il
            ctrl_FormerId[id] = sendMessage(id,LVM_GETIMAGELIST,LVSIL_NORMAL,0)
        end if


        lv_id &= id
        lv_properties &= {lv_Default_Properties}
        lv_properties[length(lv_id)][kLVSortRtn] = r_lvSortitems
end procedure

procedure registerMenu(integer id,atom h)
-- registers recursively items and submenus
atom info,hsub
integer count,ch_id,flags

        menu_ids &= id
        menu_handles &= h
        info = w32to_memory(0,ID_MENUITEMINFO,0)
        w32store(info,MENUITEMINFO_fMask,MIIM_TYPE+MIIM_SUBMENU+MIIM_ID)
        count = w32Func(xGetMenuItemCount,{h})
        for i=1 to count do
            VOID = w32Func(xGetMenuItemInfo,{h,i-1,MF_BYPOSITION,info})
            hsub = w32fetch(info,MENUITEMINFO_hSubMenu)
            flags = w32fetch(info,MENUITEMINFO_fType)
            if hsub then
                ch_id = NewControl(Menu,id)
                ctrl_FormerId[id] = -1
                registerMenu(ch_id,hsub)
            else
                if and_bits(flags,MFT_SEPARATOR) then
                    ch_id = MenuSpacer
                else
                    ch_id = MenuItem
                end if
                ch_id = NewControl(ch_id,id)
                ctrl_FormerId[ch_id] = w32fetch(info,MENUITEMINFO_wID)
            end if
        end for
        w32release_mem(info)
end procedure

--/topic Menus
--/func inMenuBar(integer id)
--/desc Determines whether a menu belongs to a window menu bar.
--/ret (INTEGER) -1 if not a menu, 1 if the menu appears in a menu bar, else 0.
global function inMenuBar(integer id)
        if not validId(id) or ctrl_Type[id]!=Menu then
            return -1
        else
            id=ctrl_Parent[id]
            if ctrl_Type[id]!=Menu then
                return 0
            else
                return ctrl_Family[ctrl_Parent[id]] = WINDOW
            end if
        end if
end function

--/topic Menus
--/func getMenuBar(integer window,integer returnHandle)
--/ret (atom) id of window menu bar if /i returnHandle is 0, else its Windows handle.

global function getMenuBar(integer id,integer returnHandle)
atom result
        if ctrl_Family[id]!=WINDOW then
            return 0
        end if
        result=ctrl_Menu[id]
        if returnHandle then
            return result
        else
            return w32lookup(result,menu_handles,menu_ids)
        end if
end function

procedure getTVitem(integer id,atom h,integer idp,atom tvitem)
        tvitem_owner&=id
        tvitem_handle&=h
        tvitem_parent&=idp
        w32store(tvitem,TVITEM_hItem,h)
        VOID=sendMessage(id,TVM_GETITEM,0,tvitem)
        tvitem_data = append(tvitem_data,peek4u({tvitem,5}))
end procedure

procedure registerTV(integer id)
-- update all internal data
atom hItem,tvitem
sequence hParent

        tv_id &= id
        tvitem=w32to_memory(0,ID_TVITEM, {TVIF_TEXT+TVIF_IMAGE+TVIF_SELECTEDIMAGE+TVIF_CHILDREN,0,0,0,0,0,0,0,0})
        hItem=sendMessage(id,TVM_GETNEXTITEM,TVGN_ROOT,0)
        hParent={0}
        while hItem do
            getTVitem(id,hItem,hParent[length(hParent)],tvitem)
            if tvitem_data[length(tvitem_data)][ktv_HasChildren] then
            -- start analysing children
                hParent &= hItem
                hItem = sendMessage(id,TVM_GETNEXTITEM,TVGN_CHILD,hItem)
            else
            -- more siblings?
                hItem = sendMessage(id,TVM_GETNEXTITEM,TVGN_NEXT,hItem)
                while not hItem do
                -- no more, back up and next
                    hItem = hParent[length(hParent)]
                    hParent = hParent[1..length(hParent)-1]
                    hItem = sendMessage(id,TVM_GETNEXTITEM,TVGN_NEXT,hItem)
                end while
            end if
        end while
        w32release_mem(tvitem)
end procedure

--/topic Events
--/func subClassControl(sequence Id,  atom hWnd)
--/desc Used to access Windows created controls as if they were win32lib controls.
--/ret INTEGER: A win32lib control id. ZERO if it fails.
-- /i Id is a sequence {ControlType, ParentID} /n
-- /i hWnd is the Windows handle to the control.
-- Attempting to subclass a control several times results in the same id being returned.
--
--Example
--/code
--      -- Use an edit fld that was created outside of win32lib as if it was
--      -- a normal win32lib control.
--    newid = subClassControl({EditText, myWindow}, winhandle)
--
--      -- Use an external bitmap as if it was a pixmap.
--    bmh = loadBitmapFromFile("..\\demoresources\\java.bmp")
--    myPixMap = subClassControl({Pixmap, 0}, bmh)
--    setPenColor(myPixMap, Cyan)
--    drawRectangle(myPixMap, 1, 0, 0, 40, 40)
--/endcode

global function subClassControl(sequence pId,  atom phWnd)
integer lNewId
integer lParent
integer lControlType
integer count

        if phWnd = 0 then
            return 0
        end if

        lControlType = pId[1]
        lParent = pId[2]
        lNewId = getId(phWnd)
        if lNewId != 0 then -- hWnd already has an ID
            return lNewId
        elsif (lParent !=0 and phWnd = getHandle(lParent)) -- is its own parent
        or lControlType < 1      -- invalid control class
        or lControlType > length(w32ControlTypes) then
            return 0
        else
            lNewId = NewControl(lControlType, lParent)
        end if

        if ctrl_Family[lNewId]!=MENU then
            setId(phWnd, lNewId)
        end if

        -- Set up data for child control

        -- Changed CChris <oedoc@free.fr> Oct 26, 2006
        -- Bug fixed: subclassed menus and image lists didn't have the right handle type recorded
        ctrl_Handle[lNewId] = phWnd
        if ctrl_Type[lNewId] = Pixmap then
            ctrl_Handle_type[lNewId] = kht_Bitmap
        elsif ctrl_Type[lNewId] = Menu or ctrl_Type[lNewId] = Popup then
            ctrl_Handle_type[lNewId] = kht_Menu
        elsif ctrl_Type[lNewId] = ImageList then
            ctrl_Handle_type[lNewId] = kht_ImageList
        elsif ctrl_Type[lNewId] = Window then
            ctrl_Handle_type[lNewId] = kht_Window
        end if
        if ctrl_Handle_type[lNewId] then
            ctrl_FormerId[lNewId] = -1
        elsif ctrl_Type[lNewId] = Pixmap then
            ctrl_FormerId[lNewId] = -1
        else
            ctrl_FormerId[lNewId] = w32Func(xGetWindowLong,{phWnd,GWL_USERDATA})
        end if
        ctrl_Function[lNewId] = w32Func(xSetWindowLong, {phWnd, GWL_WndProc, SubProcAddress})

        -- children
        if ctrl_Type[lNewId]=TabControl then
            count=sendMessage(lNewId,TCM_GETITEMCOUNT,0,0)
            for i=1 to count do
                count = NewControl(TabItem,lNewId)
            end for
            ctrl_Menu[lNewId] = sendMessage(lNewId,TCM_GETIMAGELIST,0,0)
        elsif ctrl_Family[lNewId]=MENU then
            registerMenu(lNewId,phWnd)
        elsif ctrl_Type[lNewId]=ListView then
            handleLV(lNewId,w32Func(xGetWindowLong,{phWnd,GWL_STYLE}),"")
        elsif ctrl_Type[lNewId]=TreeView then
            registerTV(lNewId)
            ctrl_Menu[lNewId] = sendMessage(lNewId,TVM_GETIMAGELIST,0,0)
        end if

        return lNewId
end function
r_subClassControl = routine_id("subClassControl")

-----------------------------------------------------------------------------
procedure createPixmap(integer id, atom pWidth, atom pHeight)

atom hdc, handle
sequence s

        ctrl_Handle_type[id] = kht_Bitmap

        -- need to initialize pixmap?
        if pWidth > 0 and pHeight > 0 then

            pWidth = floor(pWidth)
            pHeight = floor(pHeight)

            -- get the dc of the screen
            hdc = getDC(Screen)

            -- create a window sized bitmap compatible with the screen
            handle = w32Func(xCreateCompatibleBitmap, {hdc, pWidth, pHeight})
            releaseDC(Screen)

            if handle = NULL then
                warnErr(Err_CREATEPIXMAP)
            end if


            -- store the handle
            ctrl_Handle[id] = handle

            -- track the bitmap as a resource
            trackObject({id,kBitmapObject}, handle, ForProgram)

            -- Fill it with its background color
            if atom(ctrl_Bg_Color[id]) then
                if equal(ctrl_Bg_Color[id], w32WinDefColor) then
                    ctrl_Pen[id][PenColor] = Black
                else
                    ctrl_Pen[id][PenColor] = ctrl_Bg_Color[id]
                end if
                call_proc(r_drawRectangle,{id, w32True, 0, 0, pWidth, pHeight})
            else
                s = ctrl_Bg_Color[id]
                if length(s)=1 then
                    handle = w32Func(xCreatePatternBrush,s)
                else
                    handle = w32Func(xCreateHatchBrush,{s[1],s[3]})
                    call_proc(r_setBackColor,{id,s[2]})
                end if
                trackObject(id,handle,ForPaint)
                hdc = getDC(id)
                w32Proc(xSelectObject,{hdc,handle})
                if length(s)=3 then
                    w32Proc(xSetBkMode,{hdc,TRANSPARENT})
                end if
                w32Proc(xRectangle,{hdc,0,0,pWidth,pHeight})
                releaseDC(id)
            end if

        end if
end procedure

-----------------------------------------------------------------------------
--/topic Values
--/proc setPixmap(pixmap, bitmap)
--/desc Assign a new value to a /Pixmap.
-- If /i bitmap is a sequence, it will be assumed to be the name of an
-- bitmap file, and Win32Lib will attempt to load the bitmap.
--
-- Otherwise, /i bitmap is assumed to be the handle of a bitmap.
--
-- Example:
--
--/code
--          -- assign a bitmap to the picture button
--          /setPixmap(Pixmap1, "spaceship.bmp")
--/endcode

-- NEW! 0.45m bitmap is now passed as an object
global procedure setPixmap(integer id, object bitmap)
-- assign a new value to a pixmap

        -- is there an old bitmap?
        if getHandle(id) > 0 then
            deleteObject(getHandle(id))
        end if

        -- file name or handle?
        if sequence(bitmap) then
            -- try to load bitmap file
            ctrl_Handle[id] = loadBitmapFromFile(bitmap)
        else
            -- just assign to handle
            ctrl_Handle[id] = bitmap
        end if
        ctrl_Handle_type[id] = kht_Bitmap

end procedure
r_setPixmap=routine_id("setPixmap")

sequence vs_PreviousControl -- static
vs_PreviousControl = {}

integer vAutoFocusLabels
vAutoFocusLabels = w32False
-----------------------------------------------------------------------------

--/topic System Attributes
--/func setAutoFocusLabels(integer NewValue)
--/desc Possibly sets whether or not a '&' in labels set focus to subsequent edit field.
--/ret Returns INTEGER: The current value of the flag.
--By default, this is set to w32False. Which means that any '&' in label captions
-- is ignored as far as setting focus to a subsequently defined input field. /n
-- If you set this to w32True then the '&' notation will cause focus to move to
-- the next input field defined after the label. Passing /w32GetValue will return the
-- current flag without setting it.
--
--Example:
--/code
--      integer lPrevFlag
--      . . .
--      -- Make labels focus on its input field.
--      lPrevFlag = setAutoFocusLabels(w32True)
--      -- The '&N' in the caption means that Alt-N will
--      -- set focus to the next input field.
--      lblX = create(LText, "&Name", Win, 5, 5, 40, 25, 0)
--      fldX = create(Editbox, "", Win, 5, 30, 120, 25, 0)
--      -- Set the flag back to whatever it was.
--      lPrevFlag = setAutoFocusLabels(lPrevFlag)
--
--/endcode

-----------------------------------------------------------------------------
global function setAutoFocusLabels(integer pNewValue)
-----------------------------------------------------------------------------
integer lOldValue

        lOldValue = vAutoFocusLabels
        if pNewValue != w32GetValue then
            vAutoFocusLabels = pNewValue
        end if
        return lOldValue

end function


--/topic Attributes
--/func setKbdInput(integer id,object newVal)
--/desc Possibly sets the value to return, or the routine_id to use, when control receives the WM_GETDLGCODE message.
--/ret OBJECT: the previous value.
-- If newVal is -1, the returned value is the default one for the actual class of /i id;
-- If it is any ther integer, this integer is returned;
-- If it is an empty sequence, the current return policy remains unchanged;
-- Otherwise, the first element must be a positive integer, the routine_id of a function.
-- The function is called with the parameters of the message, and its returned
-- value is returned to Windows. The returned values are either one or more DLGC_ flags
-- added together, or -1 to revert to --the defaults for the control's class.

global function setKbdInput(integer id,object newVal)
object oldVal

        if not validId(id) then
            return {}
        end if
        oldVal = ctrl_KbdInput[id]
        if compare(newVal,{}) then
            ctrl_KbdInput[id] = newVal
        end if
        return oldVal

end function

-----------------------------------------------------------------------------
--/topic Defining Controls
--/func createEx(integer controlType, sequence caption, atom Owner, object Left, object Top, 
--              object Width, object Height, object flags, object exFlags)
--/desc Create an object of type /i controlType.
--/ret Control identifier.
--
-- This is the same as /create, but allows you to specify extented
-- attribute flags.

global function createEx(object pControl, sequence pCaption, atom pOwner, object pLeft, object pTop, object pWidth, object pHeight, object styleFlags, object exFlags)

-- PL 29/4/09
--integer id, at, hotkey
integer id
integer bgControl
-- PL 29/4/09
--atom style, result, hWnd, flags, extendedflags, lParenthWnd
atom hWnd, flags, extendedflags, lParenthWnd
-- PL 29/4/09
--atom szClassName, szCaption, hMenu, newhWnd, pstr,
atom szClassName, szCaption, hMenu, newhWnd,
-- PL 29/4/09
--struct, ok, newobj
struct, ok
sequence BBox,lvcol
object sbPanels
sequence lHintText
integer iIconInfo
integer autoclose
object lBGColor
object lUserPre
object lUserPost
object lTemp
-- PL 29/4/09
--integer lControl, kbdInput, cloneIt
integer lControl, cloneIt

        if sequence(pControl) then
            cloneIt = pControl[1]
            pControl = Window
        else
            cloneIt = 0
        end if

        -- Check for AutoClose flag.

        autoclose = w32False
        lControl = classAlias[pControl]

        if sequence(styleFlags) then

            if equal(styleFlags, w32AUTOCLOSE) then
                autoclose = w32True
                styleFlags = 0
            else
                flags = find(w32AUTOCLOSE, styleFlags)
                if flags != 0 then
                    autoclose  = w32True
                    styleFlags = w32removeIndex(flags, styleFlags)
                end if
            end if
        end if

        if lControl = ListView then
            lvcol = pCaption
            pCaption = ""
            lHintText = ""

        elsif length(pCaption) = 2
          and w32string(pCaption[1])
          and w32string(pCaption[2]) then

            lHintText = pCaption[2]
            pCaption = pCaption[1]

        else
            lHintText = ""
        end if

        if pOwner!=0 and not validId(pOwner) then
            abortErr(Err_OWNERINVALID)
        end if

        if sequence(vControlRID[pControl]) then
            -- User defined control might have to change the owner.
            pOwner = call_func(vControlRID[pControl][kCRID_Control], {"NewOwner", pOwner})
        end if

        if pOwner = 0 then
            if lControl = MenuItem then
                pOwner = vRecent[w32RecentMenu]

            elsif lControl = MenuSpacer then
                pOwner = vRecent[w32RecentMenu]

            elsif lControl = TabItem then
                pOwner = vRecent[w32RecentTabControl]

            elsif lControl = ReBarBand then
                -- Need to find the rebar for the recent window.
                lTemp = findChildren(vRecent[w32RecentWindow])
                for i=1 to length(lTemp) do
                    if lTemp[i][2] = ReBar then
                        pOwner = lTemp[i][1]
                        exit
                    end if
                end for
                if pOwner = 0 then
                    abortErr(Err_OWNERINVALID)
                end if

            elsif find(lControl, {Window, Pixmap}) = 0 then
                pOwner = vRecent[w32RecentWindow]

            end if
        else
            -- Certain controls must never have an owner.
            if find(lControl,{ToolTip, Pixmap, Screen_, Printer_}) then
                pOwner = 0
            elsif lControl = Menu and ctrl_Family[pOwner]=WINDOW then
                if ctrl_Menu[pOwner]=0 then
                    createMenuBar(pOwner)
                end if
                -- reparent to the menu bar
                pOwner = getMenuBar(pOwner,0)
            end if

        end if

        -- set up a new Control space
        id = NewControl(lControl, pOwner)

        -- Set the default name for this control.
        setIdName(id, pCaption)
        ctrl_ActualClass[id] = pControl

        if lControl = TabControl then
            ctrl_Specific[id] = {}
        end if

        -- If this control is tab-stoppable and the previous
        -- control is a label, then set the hotkey for this control
        -- based on the previous control's caption,
        -- otherwise set the hotkey based on the current caption.
        if vAutoFocusLabels = w32False then
            registerHotKey(id, pCaption)
        else
            if and_bits(WS_TABSTOP, classStyle[lControl]) and length(vs_PreviousControl) != 0 then
                if classType[ctrl_Type[vs_PreviousControl[1]]] = STATIC then
                    registerHotKey(id, vs_PreviousControl[2])
                else
                    registerHotKey(id, pCaption)
                end if
            elsif classType[lControl] != STATIC then
                registerHotKey(id, pCaption)
            end if
        end if
        vs_PreviousControl = {id, pCaption}

        if lControl = CancelButton then
            registerHotKey(id, VK_ESCAPE)
        end if

        -- actual creation
        if sequence(vControlRID[pControl]) and vControlRID[pControl][kCRID_Create] >= 0 then
            -- User defined control.
            lUserPre = call_func(vControlRID[pControl][kCRID_Create],{"Pre",
                                                                      {id, pCaption, pOwner,
                                                                       pLeft, pTop, pWidth, pHeight,
                                                                       styleFlags, exFlags}
                                                                     })
            if sequence(lUserPre) and length(lUserPre) = 9 and lUserPre[1] = id then
                pCaption = lUserPre[2]
                pOwner = lUserPre[3]
                pLeft = lUserPre[4]
                pTop = lUserPre[5]
                pWidth = lUserPre[6]
                pHeight = lUserPre[7]
                styleFlags = lUserPre[8]
                exFlags = lUserPre[9]
            end if
        else
            -- Built in controls.
            lUserPre = {}

            if find(lControl,{StatusBar}) = 0 then
                BBox = convPctToPixel(id, pLeft, pTop, pWidth, pHeight)
                pLeft  = BBox[1]
                pTop  = BBox[2]
                pWidth = BBox[3]
                pHeight = BBox[4]

            elsif lControl = StatusBar then
                pLeft = 0
                pWidth = 0
                if sequence(pTop) then
                    sbPanels = pTop
                else
                    sbPanels = -1
                end if
                pTop = 0

                if sequence(pHeight)
                or (pHeight>0 and pHeight<1) then
                    BBox = convPctToPixel(id, 0, 0, 0, pHeight)
                    pHeight = BBox[4]
                end if
            end if
        end if

        ---- Creation ----
        if atom(lUserPre) then
        -- do nothing, custom create routine did the job
        elsif lControl = Screen_
        or lControl = Printer_ then
-- nothing to do. Just wanted to manage it's storage.
            lUserPre = 0

        elsif lControl = Window then
            lUserPre = 0
            -- create a window
            if not cloneIt then
                createWindow(id, pCaption, pOwner, pLeft, pTop, pWidth, pHeight,
                             styleFlags, exFlags)
            else
                createWindow({id, cloneIt}, pCaption, pOwner, pLeft, pTop, pWidth, pHeight,
                             styleFlags, exFlags)
            end if

        elsif lControl = Menu then
            lUserPre = 0
            createMenu(id, pCaption, pOwner,styleFlags,{pLeft,pTop,pWidth,pHeight,exFlags})

        elsif lControl = Popup then
            lUserPre = 0
            -- create a popup menu
            createMenu(id, pCaption, pOwner,styleFlags,{pLeft,pTop,pWidth,pHeight,exFlags})

        elsif lControl = MenuItem then
            lUserPre = 0
            -- create a menu bar item
            createMenuItem(id,pCaption,pOwner,styleFlags,{pLeft,pTop,pWidth,pHeight,exFlags})

        elsif lControl = MenuSpacer then
            lUserPre = 0
            -- create a menu bar item
            createMenuItem(id, "-", pOwner, 0,{0,0,0,0,0})

        elsif lControl = Pixmap then
            lUserPre = 0
            -- create a pixmap item
            createPixmap(id, pWidth, pHeight)

            -- set default font
            setDefaultFont(id)
            setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])


        elsif lControl = TabItem then
            lUserPre = 0
            -- create a tab control item
            createTabItem(id, pCaption, pOwner, pLeft, exFlags)
            call_proc(r_setFocus,{id})

        elsif lControl = ImageList then
            lUserPre = 0
            if pWidth = SM_CXSMICON then
                pWidth = getSystemMetrics(SM_CXSMICON)
                pHeight = getSystemMetrics(SM_CYSMICON)
            else
                pWidth = getSystemMetrics(SM_CXICON)
                pHeight = getSystemMetrics(SM_CYICON)
            end if

            hWnd = w32Func(ImageList_Create, {pWidth, pHeight, ILC_MASK+styleFlags,1,1})
            -- save the handle with the control
            setId(hWnd, id)

            VOID = w32Func(ImageList_SetBkColor, {hWnd, CLR_NONE})
            -- save the handle in the sequence
            ctrl_Handle[id] = hWnd
            ctrl_Handle_type[id] = kht_ImageList

        elsif lControl = ReBarBand then
            lUserPre = 0

            struct = w32to_memory(0,ID_REBARBANDINFO, {w32or_all({RBBIM_ID, -- fMask
                                                                  RBBIM_SIZE,
                                                                  RBBIM_TEXT,
                                                                  RBBIM_STYLE}),
                                                       w32or_all({RBBS_CHILDEDGE, -- fStyle
                                                                  RBBS_GRIPPERALWAYS,
                                                                  styleFlags}),
                                                       0,           -- clrFore
                                                       0,           -- clrBack
                                                       pCaption,     -- lpText
                                                       0,           -- iImage
                                                       0,           -- hwndChild
                                                       0,           -- cxMinChild
                                                       0,           -- cyMinChild
                                                       pWidth,      -- pWidth
                                                       0,           -- hbmBack
                                                       id,          -- wID
                                                       0,           -- cyChild
                                                       0,           -- cyMaxChild
                                                       0,           -- cyIntegral
                                                       0,           -- cxIdeal
                                                       0,           -- lParam
                                                       0})          -- cxHeader

            hWnd = sendMessage(pOwner, RB_INSERTBAND, -1, struct)

            w32release_mem(struct)


        elsif pOwner != 0
        and ctrl_Type[pOwner] = FlatToolBar
        and classType[lControl] = BUTTON then
            lUserPre = 0
            -- adding a button to a flat toolbar!
            ctrl_Family[id] = BUTTON
            ctrl_Hint_Text[id] = pCaption

            if length(pCaption) > 0 then
                szCaption = sendMessage(pOwner, TB_ADDSTRING, 0, pCaption & 0)
            else
                -- Use "" by default.
                szCaption = -1
            end if

            struct = w32acquire_mem(0, SIZEOF_TBBUTTON)
            w32store(struct, TBBUTTON_idCommand, id)
            w32store(struct, TBBUTTON_dwData, id)
            w32store(struct, TBBUTTON_iBitmap, pLeft-1)
            w32store(struct, TBBUTTON_fsState, TBSTATE_ENABLED)
            w32store(struct, TBBUTTON_iString, szCaption)

            styleFlags = w32or_all({styleFlags, classStyle[lControl]})

            w32store(struct, TBBUTTON_fsStyle, styleFlags)

            ok = sendMessage(pOwner, TB_ADDBUTTONS, 1, struct)

            w32release_mem(struct)

            if not ok then
                warnErr(Err_FLATTOOLBARBTN)
            end if
        end if

        if sequence(lUserPre) then
            -- Use standard (built-in) creation processing --

            -- create C string for lControl name
            szClassName = w32acquire_mem(0, className[lControl])

            -- create C string for caption and link with ClassName
            szCaption = w32acquire_mem(szClassName, pCaption)

            -- user supplied flags
            if and_bits(classAttr[lControl], w32PictCtrl) = 0 then

                if atom(styleFlags) then
         -- combine with user's values
                    flags = or_bits(classStyle[pControl], styleFlags)
                else
         -- replace with user's values
                    flags = w32or_all(styleFlags)
                end if
            else
                -- 'cos styleFlags is really a DIB handle
                flags = classStyle[lControl]

                if find(lControl, {PictureButton, TogglePicture}) then
                    if equal(styleFlags, w32PB_BITMAP) or equal(styleFlags,0) then
                        flags = or_bits(flags, BS_BITMAP)
                        styleFlags = 0

                    elsif equal(styleFlags, w32PB_ICON) then
                        flags = or_bits(flags, BS_ICON)
                        styleFlags = 0

                    elsif w32string(styleFlags) then
                        if match(".ICO", upper(styleFlags))!=0
                        or equal("ICON", upper(styleFlags)) then
                            flags = or_bits(flags, BS_ICON)
                        else
                            flags = or_bits(flags, BS_BITMAP)
                        end if
                    elsif atom(styleFlags) then
                        ok = w32Func(xGetObjectType, {styleFlags})
                        if ok = 0 then
                            flags = or_bits(flags, BS_ICON)

                        elsif ok = OBJ_BITMAP then
                            flags = or_bits(flags, BS_BITMAP)

                        else
                            warnErr("The image used to create a picture button\nis not an ICON or a BITMAP")
                            styleFlags = 0
                        end if
                    else
                        warnErr("The image used to create a picture button\nis not valid")
                        styleFlags = 0
                    end if
                end if
            end if

            -- extended flags
            if atom(exFlags) then
                extendedflags = or_bits(classStyleEx[lControl], exFlags)
            else
                extendedflags = w32or_all(exFlags)
            end if

            -- Some controls interpret hMenu differently
            if and_bits(w32OwnerId, classAttr[lControl]) != 0 then
                -- identifier of parent
                hMenu = pOwner
            else
                -- null
                hMenu = NULL
            end if

            -- create control
            if and_bits(w32Virtual, classAttr[lControl]) != 0 then
                lParenthWnd = getHandle(findParent(pOwner))
            else
                lParenthWnd = getHandle(pOwner)
            end if

--?{
--                                         extendedflags,           -- extended style
--                                         peek_string(szClassName),        -- window class name
--                                         peek_string(szCaption),              -- window caption
--                                         flags,                   -- window style
--                                         pLeft, pTop,         -- initial pLeft, pTop position
--                                         pWidth, pHeight,     -- initial pLeft, pTop size
--                                         lParenthWnd,         -- parent window handle
--                                         hMenu,                   -- window menu handle
--                                         instance(),          -- program instance handle
--                                         NULL}
            hWnd = w32Func(xCreateWindow, {
                                           extendedflags,           -- extended style
                                           szClassName,         -- window class name
                                           szCaption,               -- window caption
                                           flags,                   -- window style
                                           pLeft, pTop,         -- initial pLeft, pTop position
                                           pWidth, pHeight,     -- initial pLeft, pTop size
                                           lParenthWnd,         -- parent window handle
                                           hMenu,                   -- window menu handle
                                           instance(),          -- program instance handle
                                           NULL})               -- creation parameters

            w32release_mem(szClassName)

            -- associate id with hWnd
            -- Changed CChris <oedoc@free.fr> Oct 26, 2006
            -- Not using subClassControl() any longer here, because an user might use the 
            --  undocumented way the routine was called unwittingly.
            if hWnd <= 0 then
                abortErr(Err_CREATECONTROL)
            end if
            ctrl_Handle[id] = hWnd
            setId(hWnd,id)
            -- record the processing routine
            ctrl_Function[id] = w32Func(xSetWindowLong,{hWnd,GWL_WndProc,SubProcAddress})

            -- save tab order with owner if the attribute is tab stop
            if and_bits(WS_TABSTOP, flags) and pOwner != 0 then
                -- add to the owner's focus_order list
                ctrl_Focus_order[pOwner] &= id
            end if

            -- picture control that's not in a flattoolbar?
            if and_bits(classAttr[lControl], w32PictCtrl) != 0 then
                if ctrl_Type[pOwner] != FlatToolBar
                and not equal(styleFlags,0) then
                    -- need to load image?
                    call_proc(r_setBitmap,{id, styleFlags})
                end if

            end if

            -- Set the new control's background color.
            -- If the control's bg color is -1 then it is "transparent" and
            -- takes on whatever its parent's bg color is.
            if pOwner != 0 and equal(classBGColor[lControl], w32BGTransparent) then
                lBGColor = ctrl_Bg_Color[pOwner]
                while equal(lBGColor, w32BGTransparent) do
                    bgControl = getParent(pOwner)
                    if bgControl = 0 then
                        lBGColor = classBGColor[lControl]
                        exit
                    end if
                    lBGColor = ctrl_Bg_Color[bgControl]
                end while
            else
                lBGColor = classBGColor[lControl]
            end if

            setBackground(id, sequence(lBGColor),lBGColor)

            -- set default font
            setDefaultFont(id)
        end if

        ----- Post Creation ----
        if length(lHintText) > 0 then
            call_proc(r_setHintEx,{id, lHintText, 0})
        end if

        -- added CChris <oedoc@free.fr> Oct 26, 2006
        -- set logical visibility according to style flags
        if sequence(lUserPre) and not and_bits(flags,WS_VISIBLE) then
            ctrl_Visible[id] = w32False
        end if
        if lControl = ReBarBand then
            ctrl_Visible[id] = not and_bits(styleFlags,RBBS_HIDDEN)
        end if


        if sequence(vControlRID[pControl]) and vControlRID[pControl][kCRID_Create] != -1 then
            -- User defined control
            lUserPost = call_func(vControlRID[pControl][kCRID_Create], {"Post", {id}})
            if sequence(lUserPost) and lUserPost[1] = id then
                if find(lUserPost[2], {w32RecentMenu, w32RecentTabControl, w32RecentWindow}) != 0 then
                    vRecent[lUserPost[2]] = id
                end if
            end if
        else
            -- Built in controls.
            if sequence(lUserPre) then
                -- Standard create used.

                if lControl = CancelButton then
                    setFont(id, FontDefaults[1],FontDefaults[2],Italic)
                else
                    setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])
                end if


                if lControl = TabControl then
                    vRecent[w32RecentTabControl] = id

                elsif lControl = Group then
                    vRecent[w32RecentWindow] = id

                end if
            end if

            -- Ensure that toolbars have at least one 'string'
            if find(lControl, {FlatToolBar, ToolBar}) then
                VOID = sendMessage(id, TB_ADDSTRING, 0, {0})
                -- Set default bitmap and button sizes
                lTemp = w32pack_word(w32Func(xGetSystemMetrics,{SM_CXICON}),
                                     w32Func(xGetSystemMetrics,{SM_CYICON}))

                VOID = sendMessage(id, TB_SETBUTTONSIZE, 0, lTemp)
                VOID = sendMessage(id, TB_SETBITMAPSIZE, 0, lTemp)
            end if

            -- track as children, since they need to resize
            if lControl = StatusBar then

                if sequence(sbPanels) then
                    call_proc(r_setSubFields,{id, sbPanels})
                end if
                if pHeight > 0 then
                    VOID = sendMessage(id, SB_SETMINHEIGHT, pHeight, 0)
                end if

            elsif lControl = ToolTip then
                if tooltipControl != 0 then
                    VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 0, 0)
                end if

                tooltipControl = id
                VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 1, 0)

            elsif lControl = TreeView then
                if not ILlarge then
                    ILlarge = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,
                                       ILC_COLOR8,0)
                    ILsmall = createEx(ImageList, "", 0, 0,0,SM_CXSMICON,0,
                                       ILC_COLOR8,0)
                    hILlarge=ctrl_Handle[ILlarge]
                    hILsmall=ctrl_Handle[ILsmall]
                end if

                setImageList(id, ILsmall, TVSIL_NORMAL)
                -- Haven't set State icons

                tv_id &= id


            elsif lControl = FlatToolBar then

                VOID = sendMessage(id, TB_BUTTONSTRUCTSIZE, SIZEOF_TBBUTTON, 0)

                if himlFTBDefault = 0 then
                    -- Need to create imagelists

                    himlFTBDefault = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,
                                              ILC_COLOR8,0)
                    himlFTBHot = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,
                                          ILC_COLOR8,0)
                    himlFTBDisabled = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,
                                               ILC_COLOR8,0)

                end if

                if not tooltipControl then
                    tooltipControl = createEx(ToolTip, "", 0, 0, 0, 0, 0, 0, 0)
                end if

                VOID = sendMessage(id, TB_SETTOOLTIPS, 0, getHandle(tooltipControl))

                -- Set image lists for the 3 states
                VOID = sendMessage(id, TB_SETIMAGELIST, 0, getHandle(himlFTBDefault))
                VOID = sendMessage(id, TB_SETHOTIMAGELIST, 0, getHandle(himlFTBHot))
                VOID = sendMessage(id, TB_SETDISABLEDIMAGELIST, 0, getHandle(himlFTBDisabled))
                ctrl_Menu[id] = himlFTBDefault
            elsif lControl = ComboBoxEx then

                if not ILlarge then
                    ILlarge = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,
                                       ILC_COLOR8,0)
                    ILsmall = createEx(ImageList, "", 0, 0,0,SM_CXSMICON,0,
                                       ILC_COLOR8,0)
                    hILlarge=ctrl_Handle[ILlarge]
                    hILsmall=ctrl_Handle[ILsmall]
                end if

                VOID = sendMessage(id, CBEM_SETIMAGELIST, 0, hILsmall)
                ctrl_Menu[id] = hILsmall
            elsif lControl = Bitmap then
                if match(".BMP", upper(pCaption)) = length(pCaption)-3 then
                    call_proc(r_setBitmap,{id, pCaption})
                end if

            elsif lControl = Icon then
                iIconInfo = 0
                if length(pCaption)=2 and integer(pCaption[2]) and pCaption[2]>0 then
                    iIconInfo = pCaption[2]
                end if
                if iIconInfo 
                or match(".ICO", upper(pCaption)) = length(pCaption)-3 then
                    call_proc(r_setIcon,{id, pCaption})
                end if

            elsif lControl = ListView then
                handleLV(id,or_bits(classStyle[lControl],styleFlags),lvcol)

            end if

            -- See if I have to subclass this control.
            if ctrl_Family[id] = COMBO
            or equal(className[lControl], WC_COMBOBOXEX) then
                newhWnd = w32Func(xGetWindow,{hWnd, GW_CHILD})
                VOID = subClassControl({EditText,id}, newhWnd)
            end if

        end if


        if autoclose then
            setHandler(id, w32HClick, r_autoclose)
        end if

        if ctrl_Type[id]=RichEdit then
            VOID = sendMessage(id,EM_EXLIMITTEXT,0,#FFFFFFFF)
        end if

        return id

end function
r_createEx = routine_id("createEx")


-----------------------------------------------------------------------------
--/topic Defining Controls
--/func create(pControl, title, parent, x, y, cx, cy, flags)
--/desc Create an object of type /i pControl.
--/ret Control identifier.
--
-- The /i title is the text that will appear in the object's caption. It can be
-- a single string or a sequence of two strings. In this later form, the first
-- string is the caption text, and the second is the tooltip text. /n
-- /n Note for /Bitmap or /Icon controls, the caption can also be the name of a bitmap
-- (.BMP) or icon (.ICO) file. In this case, it will be automatically loaded into the
-- Bitmap control and placed in RAM until the program ends.
--
-- /i x and /i y specify the position of the object, and /i cx and
-- /cy specify the width and height.
--
-- You can specify additional attributes by passing them in the /i flags
-- parameter. If /i flags is an atom, then these are combined with the
-- default style flags for the control class. If /i flags is a sequence of
-- flags, then they replace the default style flags.
--
-- The /i flags parameter is used differently for /PictureButton and /TogglePicture
-- controls. In this case, it can be the name of a bitmap (.BMP) or an icon (.ICO) file
-- which causes that image to be displayed on the button face. Alternatively, you can
-- pass the handle of bitmap or icon in the flags parameter. This technique is useful
-- if you have preloaded images from files and intend to reuse them. Once the type
-- of image, bitmap or icon, is determined for the control, you cannot change
-- it to the other type. For icons, you can specify the caption as {filename,icon_index}.
--
-- Note that if the /i flags parameter contains the flag 'w32AUTOCLOSE', the
-- control's click event will close its parent window.
--
-- /b Returns: The value returned is the /i id of the control. This is
-- typically the first parameter expected in Win32Lib functions.
--
-- The parent of the main window is 0.
--
-- If you don't care about the positioning of a window, you can
-- use the parameter /b Default, and Windows will automatically
-- position the window.
--
-- /b Note: for windows, the size specified by /i cx, /i cy is
-- the /i total size of the window, not the size of the client area.
-- After creating a Window, you can use /setClientRect to give an exact
-- client area size.
--
-- If you wish a window to share the background and menu bar of another automatically,  
--  pass {id} as first argument, where /i id is the ID of the base window. This link can never be broken.
--
-- /b Note: The /i x and /i y values are relative to the parent's client area.
--
-- Each dimension for /i x, /i y, /i cx, and /i cy can be expressed as either... /n
-- a) an integer >= 0, in which case it is not touched. /n
--     eg.  50 (= 50 pixels) /n
-- b) an atom in the range > 0 and ~< 1, which is taken to be a %
--    of the control's parent dimension. /n
--     eg.  0.50 (= 50% of parent's size) /n
-- c) The constant /i w32Edge which signifies the parent's extreme
--    client edge for the dimension. That is, either the rightmost or
--    bottom most edge, as appropriate. /n
-- d) a sequence of two elements, the first as in (b) or (c) above, and
--    the other a pixel offset. The offset is added after converting. /n
--     eg.  {0.50, -3} (= 50% of parent size less 3 pixels) /n
--     eq   (w32Edge, -10} (= right/bottom pixel less 10 pixels) /n
-- e) a sequence of three elements, the first two as in (d), and
--    the other a two-element sequence containing the minimum and
--    maximum allowable values. These can be a percentage or a
--    pixel amount. /n
--     eg.  {0.50, -3, {20, 300}} (= 50% of parent size less
--            3 pixels, and a minimum of 20 pixels and a
--            maximum of 300 pixels) /n
--
-- However, for /StatusBar controls, the /i x and /i cx values are ignored,
-- as a statusbar is always aligned to the bottom left edge of a window.
-- Also for /StatusBar controls, the /i x can be used to define subPanels
-- in the bar. See /setSubFields for details.
--
-- For /b Menus, if the /i title contains a '!' character, a /b Command menu
-- is created rather than a /b Popup menu. The difference is that a Command menu
-- reacts immediately to being clicked, while a Popup menu will display its
-- menu items instead. /n
-- /b "Note 1:" This type of menu will not be allowed
-- to contain MenuItems. The reason being that when you click on the menu
-- a w32HClick event is generated and any items are never shown. /n
-- /b "Note 2:" The '!' character is stripped out of the title before displaying
-- it on screen. /n
-- For Menu, Popup, MenuItem and MenuSpacer controls, the position, size and extended flags are interpreted as follows:
--/li /b x: insertion point. This may be any of
--<ul>
--<li>MP_BEFORE: /b y is the id of the item before which to insert;
--<li>MP_AT: /b y is the 1-based position at which to insert;
--<li>MP_AFTER: /b y is the id of the item after which to insert;
--<li>MP_END: insert at end, /b y is ignored.
--</ul>
--/li /b cx is the handle to the unchecked mark bitmap;
--/li /b cy is the handle to the checked mark bitmap;
--/li exFlags is the handle to the displayed bitmap.
--
-- For tab items, the /b x parameter is the 1 based position at which to insert (use 0
-- to insert at end), and exFlags is the index of an image in the common image list. /n
--Examples:
--/code
--      -- create a window
--      --  The following will create a /Window called /b MyWindow:
--      constant MyWindow = create(Window,      -- the pControl
--                          "My Window",        -- the caption
--                          0,                  -- the parent
--                          Default, Default,   -- x and y position
--                          0.5,                -- 50% of the screen width
--                          40,                 -- 40 pixels high
--                          0)                  -- no special flags
--
--      constant MsgWindow = create(Window,     -- the pControl
--                          "Messages",         -- the caption
--                          0,                  -- the parent
--                          Default, Default,   -- x and y position
--                          200,                -- 200 pixels wide
--                          200,                -- 200 pixels high
--                          {WS_DLGFRAME,
--                           WS_SYSMENU,
--                           WS_MINIMIZEBOX
--                           })-- replacement flags
--/endcode
--
-- The following will create a /PushButton in /b MyWindow:
--/code
--      -- create a pushbutton
--      constant MyButton = create(
--                              PushButton,         -- the pControl
--                              {"Push Me!",        -- the caption
--                               "Go on, have a go!"}, -- the tooltip text
--                              MyWindow,           -- the parent
--                              10, 10,             -- x and y position
--                              60, 40,             -- width and height
--                              0)              -- no special flags
--/endcode
--
-- The following will create a /Bitmap in /b MyWindow:
--/code
--      -- create a bitmap
--      constant BM1 = create(
--                              Bitmap,         -- the pControl
--                              "images\\logo.bmp", -- the file to display
--                              MyWindow,           -- the parent
--                              10, 90,             -- x and y position
--                              60, 40,             -- width and height
--                              0)              -- no special flags
--/endcode
--
-- The different classes of objects are:
-- /li /Bitmap: static bitmap
-- /li /CheckBox: check box
-- /li /Combo: combo box - has edit box and drop down list (aka ComboBox)
-- /li /ComboBoxEx: Combo with images
-- /li /CText: static text lable, center justified
-- /li /DefPushButton: default push button
-- /li /DropDownList: drop down list, non-editable
-- /li /EditText: edit text (aka EditBox, TextBox, SleText)
-- /li /FlatToolBar: like a toolbar, only flat
-- /li /Group: group box  (aka GroupBox)
-- /li /HScroll: horizontal scroll bar
-- /li /HTrackBar: horizontal track bar
-- /li /Icon: static icon
-- /li /ImageList: A storage container for images.
-- /li /List: list with scroll bar (aka ListBox)
-- /li /ListView: list with icons, labels and columns
-- /li /LText: left justified static label
-- /li /Menu: menu bar item
-- /li /MenuItem: dropdown menu item
-- /li /MenuSpacer: Horizontal line in a menu.
-- /li /MleText: multiple line text edit
-- /li /MonthCalendar: select dates
-- /li /PictureButton: push button with graphic
-- /li /Pixmap: off-screen color bitmap
-- /li /Popup: a pop up menu
-- /li /ProgressBar: shows task completion state
-- /li /PushButton: push button (aka Button, CommandButton)
-- /li /Radio: radio button (aka RadioButton)
-- /li /ReBar: advanced toolbars
-- /li /ReBarBand: Rebar divider for grouping controls
-- /li /RichEdit: text edit with formatting
-- /li /RText: right-justified static text label
-- /li /SepButton: divider on FlatToolBars
-- /li /SimpleCombo: combo box, no drop down list
-- /li /SortedCombo: combo box, with sorted list
-- /li /SortedList: list, with sorted elements
-- /li /StatusBar: control for status text
-- /li /TabControl: control containing tab items
-- /li /TabItem: control item in /TabControl
-- /li /ToggleButton: push button that toggles off and on
-- /li /TogglePicture: toggle button with picture
-- /li /ToolBar: control for placing other controls into
-- /li /ToolTip: A group of tooltips with all the same style.
-- /li /TreeView: hierarchical list
-- /li /TriCheckBox: 3 state check box
-- /li /UpDown: increment/decrement control
-- /li /VScroll: vertical scroll bar
-- /li /VTrackBar: vertical track bar
-- /li /Window: window
global function create(integer pControl, sequence caption, atom pOwner, object x, object y, object cx, object cy,object styleFlags)
-- create with no extended style flags
        return createEx(pControl, caption, pOwner, x, y, cx, cy, styleFlags, 0)
end function

w32ControlNames = {"WINDOW",
"PUSHBUTTON",
"COMMANDBUTTON",
"BUTTON",
"DEFPUSHBUTTON",
"DEFBUTTON",
"CANCELBUTTON",
"CHECKBOX",
"TRICHECKBOX",
"RADIO",
"RADIOBUTTON",
"GROUP",
"GROUPBOX",
"LIST",
"LISTBOX",
"SORTEDLIST",
"COMBO",
"COMBOBOX",
"SORTEDCOMBO",
"SIMPLECOMBO",
"DROPDOWNLIST",
"EDITTEXT",
"EDITBOX",
"TEXTBOX",
"SLETEXT",
"MLETEXT",
"LTEXT",
"LABEL",
"RTEXT",
"CTEXT",
"HSCROLL",
"VSCROLL",
"ICON",
"BITMAP",
"MENU",
"POPUP",
"MENUITEM",
"MENUSPACER",
"PIXMAP",
"TOOLBAR",
"STATUSBAR",
"PICTUREBUTTON",
"TOGGLEBUTTON",
"TOGGLEPICTURE",
"HTRACKBAR",
"VTRACKBAR",
"TABCONTROL",
"TABITEM",
"PROGRESSBAR",
"LISTVIEW",
"IMAGELIST",
"TREEVIEW",
"RICHEDIT",
"MONTHCALENDAR",
"UPDOWN",
"REBAR",
"REBARBAND",
"TOOLTIP",
"FLATTOOLBAR",
"SEPBUTTON",
"COMBOBOXEX"
                  }

w32ControlTypes = {Window,
PushButton,
CommandButton,
Button,
DefPushButton,
DefButton,
CancelButton,
CheckBox,
TriCheckBox,
Radio,
RadioButton,
Group,
GroupBox,
List,
ListBox,
SortedList,
Combo,
ComboBox,
SortedCombo,
SimpleCombo,
DropDownList,
EditText,
EditBox,
TextBox,
SleText,
MleText,
LText,
Label,
RText,
CText,
HScroll,
VScroll,
Icon,
Bitmap,
Menu,
Popup,
MenuItem,
MenuSpacer,
Pixmap,
ToolBar,
StatusBar,
PictureButton,
ToggleButton,
TogglePicture,
HTrackBar,
VTrackBar,
TabControl,
TabItem,
ProgressBar,
ListView,
ImageList,
TreeView,
RichEdit,
MonthCalendar,
UpDown,
ReBar,
ReBarBand,
ToolTip,
FlatToolBar,
SepButton,
ComboBoxEx
                  }
vControlRID = repeat(0, length(w32ControlNames))


function parseImage(object image)
-- retrieves an image from a string and reurns either the string or an image index
integer pos,pos2,filetype,index
sequence v
atom hImg

        pos=find('.',image)
        if pos then
            pos2=find(',',image)
            if not pos2 then
                pos2=length(image)+1
            end if
            filetype = find(upper(w32trim(image[pos+1..pos2-1])),{"BMP","ICO"})
            if filetype then
                index=0
                if filetype=2 and pos2<length(image) then -- index
                    v=value(image[pos2+1..length(image)])
                    if v[1] = GET_SUCCESS then
                        index=v[2]
                    end if
                end if
                if filetype = 1 then
                    hImg = call_func(r_loadBitmapFromFile,{image[1..pos2-1]})
                elsif not index then
                    hImg = call_func(r_loadIconFromFile,{image[1..pos2-1]})
                else
                    hImg = call_func(r_loadIconFromFile,{{image[1..pos2-1],index}})
                end if
                if hImg then
                    if filetype = 1 then
                        return call_func(r_addDIB,{hImg})
                    else
                        return addIcon(hImg)
                    end if
                end if
            end if
        end if
        return image
end function

--/topic Attributes
--/func setTabImage(integer id,object image)
--/desc Possibly sets the image associated to a tab item and returns index of previous one.
-- If /i image is an integer, it is an index into the common image list, as returned by
-- /addIcon() or /addDIB().
-- If it is a sequence, it is a filename string possibly followed by a comma and the
-- litteral representation of the icon index. The bitmap or icon will be loaded into
-- the common image list.
-- If /i image is "", then no attempt to set the image is made.
-- If /i image is 0, there will be no image associated with /i id.
-- If /i id is not a TabItem, -1 is returned; otherwise, the previous image index is returned (0 for no image).

global function setTabImage(integer id,object image)

integer index,oldVal,parent
-- PL 29/4/09
--atom item, hIcon
atom item

        -- test for valid request and set some helper variables
        if ctrl_Type[id] != TabItem then
            return -1
        else
            parent = ctrl_Parent[id]
            index = find(id,ctrl_Specific[parent])
        end if

        if sequence(image) and length(image) then
        -- convert it to an index into the common image list
            image = parseImage(image)
        end if

        -- get current image for item
        item = w32acquire_mem(0,SIZEOF_TC_ITEM)
        w32store(item,TC_ITEM_mask,TCIF_IMAGE)
        VOID = sendMessage(parent,TCM_GETITEM,index,item)
        oldVal = w32fetch(item,TC_ITEM_iImage)+1

        if integer(image) then
            -- set new image (perhaps to -1)
            if ctrl_Menu[id]!=hILsmall then
                image = w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[image]})
            else
                image -= 1
            end if
            w32store(item,TC_ITEM_iImage,image)
            VOID = sendMessage(parent,TCM_SETITEM,index,item)
        end if
        w32release_mem(item)
        return oldVal
end function

--/topic Values
--/proc showMessage(sequence Message)
--/desc Displays /i Message in a Statusbar
--/i pText is the text string which is displayed in the first (or only) panel of the
-- status bar which is on the main window. /n
--
-- It is possible to display it on a different status bar by using the format
-- {Message, pID}, where /i pID is either a Window id, which has a status bar, or
-- an actual status bar control id. /n
-- If you wish to display the message in a panel other than the first panel, the
-- /i pID has the format {id, panel#} /n
--
--In any case, if the /i pID is zero, the application's main window is assumed.
--
-- Example:
--
--/code
--      -- Show the caption of status bar in the main window
--      showMessage("Ready")
--      -- To display a message in another window:
--      showMessage({"Searching...", EditWindow})
--      -- If the statusbar has subfields, you can specify them like:
--      showMessage({"2nd subField", {EditWindow,2}})
--/endcode

-- Changed CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: specifying a window without a status bar would add a status bar to the main window.
-- Bug fix: if the supplied id had not a Window as parent, its parent window would not be queried for a status bar
global procedure showMessage(sequence pMsg)
integer lPanel
object id,win_id,win_implicit
sequence lSizeA
sequence lSizeB

        lPanel = 0
        win_implicit = 0
        if length(pMsg) = 2 and sequence(pMsg[1]) then
            id = pMsg[2]
            pMsg = pMsg[1]
            if sequence(id) then
                lPanel = id[2]
                id = id[1]
            end if
        else
            win_implicit = 1
        end if


        if win_implicit or not validId(id) then
            win_id = mainWindow
            id = ctrl_Statusbar[mainWindow]
        elsif ctrl_Type[id] != StatusBar then
            if ctrl_Type[id] = Window then
                win_id = id
            else
                win_id = findParentWindow(id)
            end if
            id = ctrl_Statusbar[win_id]
        else
        -- we already have a status bar, and win_id will not be inspected
        end if

        if id = 0 then
        -- The window has no status bar, add one
            lSizeA = call_func(r_getRect,{win_id})
            id = createEx(StatusBar, "", win_id, 0, 0, 0, 0, 0, 0)
            lSizeB = call_func(r_getRect,{id})
            call_proc(r_setRect,{win_id, lSizeA[1], lSizeA[2], lSizeA[3]-lSizeA[1],
                                 lSizeA[4]+lSizeB[4]-lSizeA[2]-lSizeB[2], 1})
        end if
        if id then
            if lPanel != 0 then
                id = {id, lPanel}
            end if
            call_proc(r_setText,{id, pMsg})
        else    -- could not create the status bar, though there wasn't one
            warnErr("Could not display this in the message area: " & pMsg)
        end if
end procedure
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- DESTROYING CONTROLS
--
-----------------------------------------------------------------------------
--/topic Attributes
--/proc destroy(id)
--/desc Destroy an object created with the /create function.
-- When a control is destroyed, it releases its resources back to
-- Windows. This also means that a /i parent control also destroys
-- its child controls.
--
-- When the control being destroyed is a Window, it cannot be reopened.
-- If you want to be able to reopen a window, use /closeWindow() instead
-- of /destroy().
--
-- When this is called, but before the control is actually destroyed,
-- the /w32HDestroy event is triggered, enabling you to clean up things
-- associated with this control. Or even prevent the control from
-- being destroyed, by returning -1 from the event handler.
--
-- The following will destroy a pushbutton called /i MyButton.
--
--/code
--      -- destroy a pushbutton
--      destroy(MyButton)
--/endcode
--

-- begin mwl 2/10/04
-- delayed destruction:
sequence vDestroyQueue
vDestroyQueue = {}

-- This is called to do the actual destruction of a control.
procedure fDoDestruction(integer id)
-- Destroy the requested item.

-- It is safe to assume that all children of this control
-- have already been destroyed before this is called.

-- PL 29/4/09
--integer class, parent, tabseq, lIdx, lKid
integer class, parent, lIdx
atom handle
--object rc             -- PL 29/4/09
--sequence parenttabs   -- PL 29/4/09
--sequence lChildren    -- PL 29/4/09
integer tabnumber
object lUserResponse
object lTemp
integer sharedclass

        lTemp = ctrl_Type[id]
        lTemp = vControlRID[lTemp]
        if sequence(lTemp) 
        and lTemp[kCRID_Destroy]>=0 then
            lUserResponse = call_func(lTemp[kCRID_Destroy], {"Destroy", {id}})
        else
            lUserResponse = 0
        end if

        if equal(lUserResponse,0) then
            -- get class and parent
            class = ctrl_Family[id]
            parent = findParent(id)

            if ctrl_Type[id] = TabItem then
                ctrl_Group[id] = {}

                -- remove from tab list
                tabnumber = find(id, ctrl_Specific[parent])
                VOID = sendMessage(parent, TCM_DELETEITEM, tabnumber-1, 0)
                ctrl_Specific[parent] = w32removeItem(id, ctrl_Specific[parent])

                -- Set focus to next tabitem
                if tabnumber > length(ctrl_Specific[parent]) then
                    tabnumber = length(ctrl_Specific[parent])
                end if
                if tabnumber != 0 then
                    call_proc(r_setFocus,{ctrl_Specific[parent][tabnumber]})
                end if

            elsif class = WINDOW then
                -- destroy window
                sharedclass = find(ctrl_ClassAddr[id],sharedClasses)
                VOID = w32Func(xDestroyWindow, {ctrl_Handle[id]})
                if sharedclass then
                    sharedClassCount[sharedclass] -= 1
                end if
                if ctrl_ClassAddr[id] != 0 then
                    if not sharedclass or sharedClassCount[sharedclass] = 0 then
                        VOID = w32Func(xUnregisterClass, {ctrl_ClassAddr[id], instance()})
                        w32release_mem(ctrl_ClassAddr[id])
                        ctrl_ClassAddr[id] = 0
                    end if
                end if

            elsif parent != 0
            and ctrl_Type[parent] = FlatToolBar then
                handle = sendMessage(parent, TB_COMMANDTOINDEX, id, 0)
                VOID = sendMessage(parent, TB_DELETEBUTTON, handle, 0)

            elsif find(class,
                       {COMMON_CONTROL,BUTTON,COMBO,EDIT,LISTBOX,SCROLLBAR,STATIC}) then
                    -- destroy control
                VOID = w32Func(xDestroyWindow, {ctrl_Handle[id]})

            elsif class = PIXMAP then
                deleteObject(ctrl_Handle[id])

            -- changed CC: ctrl_Menu may hold the handle for the menu bar only.
            -- And the OS takes care of destroying it.
            elsif find(class,{MENU, MENUITEM}) and ctrl_Family[ctrl_Parent[id]]=MENU then
                -- delete from parent
                if not removeMenu(ctrl_Parent[id],id,MF_BYPOSITION,0) then
                    abortErr(Err_DESTROYMENU)
                end if

            else
            -- no special processing.
            end if

            -- mark as destroyed
            if ctrl_Type[id] = ListView then
                lIdx = find(id, lv_id)
                if lIdx then
                    lv_id = w32removeItem(id, lv_id)
                    lv_properties= w32removeIndex(lIdx,lv_properties)
                end if
                for i=1 to length(lvitem_owner) do
                    if lvitem_owner[i]=id then
                        lvitem_owner[i] = -1
                    end if
                end for
            end if

        end if

        releaseResourcesForID(id)

        ctrl_Destroyed[id] = -1     -- Destruction completed.
        ctrl_Handle[id] = -1
        ctrl_Handle_type[id] = -1
        ctrl_Mousetrap[id] = 0      -- Delete all mousetraps for this window.
        ctlblk_freelist = id & ctlblk_freelist
        ctrl_Group[id] = {}


        ------- Remove destroyed control from ...
        if parent != 0 then

            -- parent's tabbed items.
            ctrl_Focus_order[parent] = w32removeItem(id, ctrl_Focus_order[parent])
            -- parent's group items.
            ctrl_Group[parent] = w32removeItem(id, ctrl_Group[parent])

        end if

        -- Treeview ids
        if ctrl_Type[id]=TreeView then
            tv_id = w32removeItem(id, tv_id)
            for i=1 to length(tvitem_owner) do
                if tvitem_owner[i]=id then
                    tvitem_owner[i] = -1
                end if
            end for
        end if

        -- Form ids
        vRecent[w32RecentForms] = w32removeItem(id, vRecent[w32RecentForms])

        deleteObject(ctrl_Bg_Brush[id])
end procedure

global procedure destroy(integer id)

-- destroy the requested item
--integer class, parent, tabseq, lIdx, lKid     -- PL 29/4/09
--atom handle           -- PL 29/4/09
object rc
--sequence parenttabs   -- PL 29/4/09
sequence lChildren

        -- Ignore bad control ids or subclassed controls.
        if not validId(id) or ctrl_FormerId[id] then
            return
        end if

        rc = 0
        if ctrl_Destroyed[id] = 0 then
            -- destroy routine?
            rc = invokeHandler(id, w32HDestroy, {})
            if sequence(rc) and not equal(rc[1], 0) then
                -- ignore the destroy order.
                vDestroyQueue  = {}
                return
            end if

            if ctrl_Type[id] = Window then

                ctrl_Destroyed[id] = 2 -- Destruction requested.
                -- First try to close the window.
                rc = sendMessage(id, WM_CLOSE, 0, 0)
                if not equal(rc,0) or ctrl_Closed[id] = 0 then
                    -- ignore the destroy order.
                    ctrl_Destroyed[id] = 0 -- Destruction denied.
                    return
                end if
                -- See if closing the window also destroyed it.
                if ctrl_Destroyed[id] = -1 then
                    return
                end if
            end if

        end if

        if find(id, vDestroyQueue) = 0 then
            vDestroyQueue &= id
        end if

        if sequence(rc) and not equal(rc[1],0) then
            -- ignore destroy order
            for dq=1 to length(vDestroyQueue) do
                ctrl_Destroyed[vDestroyQueue[dq]] = 0
            end for


            vDestroyQueue = {}
            return
        end if


        lChildren = findChildren(id)
        for i = length(lChildren) to 1 by -1 do
            destroy(lChildren[i][1])
            if length(vDestroyQueue) = 0 then
                exit
            end if
        end for

        -- Only really destroy things if the current id is at the head of the queue.
        if length(vDestroyQueue) > 0 and vDestroyQueue[1] = id then

            -- keep any events from being triggered
            -- by clearing all event handlers for
            -- each control being destroyed.
            for i=1 to length(vDestroyQueue) do
                ctrl_Handlers[vDestroyQueue[i]] =
            repeat({}, length(ctrl_Handlers[vDestroyQueue[i]]))
            end for

            -- Process the queue in reverse order
            -- so that owned controls get destroyed before
            -- their owner does.
            for dq = length(vDestroyQueue) to 1 by -1 do
                id = vDestroyQueue[dq]

                -- Do not do bad control ids.
                if validId(id) then
                    fDoDestruction(id)
                end if

            end for
            vDestroyQueue = {}
        end if


end procedure
r_destroy = routine_id("destroy")


-----------------------------------------------------------------------------
-- SCREEN DISPLAY
--

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setPenPos(window, x, y)
--/desc Position the text pen in /i window.
-- Example:
--
--/code
--      -- move the pen
--      /setPenPos(MyWindow, 10, 10)
--
--      -- display message
--      /wPuts(MyWindow, "This is at {10,10}")
--/endcode

global procedure setPenPos(integer id, object x, object y)
sequence BBox

        BBox = convPctToPixel(id, x,y, 0, 0)

        -- set the window cursor position
        ctrl_X_Pos[id] = BBox[1]
        ctrl_Y_Pos[id] = BBox[2]
end procedure
r_setPenPos = routine_id("setPenPos")
-----------------------------------------------------------------------------

--/topic Attributes
--/func getRect(atom id)
--/desc Get the dimensions of /i id.
--/ret Sequence: {left, top, right, bottom}
-- The returns the pixel positions of the top-left corner and the bottom
-- right corner. For Screen, Printer and bitmaps the top-left is always
-- 0,0 and thus /i right is the width and /i bottom is the height.
--
-- Example:
--
--/code
--      -- where is the window located?
--      sequence extent
--
--      -- get the extent of the window
--      extent = /getRect(MyWindow)
--
--      -- display the position
--      /wPrintf(MyWindow, "MyWindow is located at %d,%d", extent[1..2])
--/endcode

global function getRect(atom id)

-- get metrics for current window
-- returns {left, top, bottom, right}

--integer top, bottom, left, right  -- PL 29/4/09
-- PL 29/4/09
--atom struct, pt, hdc, mset, bufsize, hWnd
atom struct, hdc, mset, bufsize, hWnd
sequence xy, retval

        retval = {0, 0, 0, 0}
        if id = 0 then
            return retval
        end if

        mset = w32new_memset()

        if id = Screen
        or id = Printer then

            hdc = getDC(id)

            -- screen size
            retval[3] = w32Func(xGetDeviceCaps, {hdc, HORZRES})
            retval[4] = w32Func(xGetDeviceCaps, {hdc, VERTRES})

            releaseDC(id)

        elsif not validId(id) then
        -- probably passed a bitmap

            bufsize = w32Func(xGetObjectType, {id})
            if bufsize = OBJ_BITMAP then
                bufsize = w32Func(xGetObject, {id, 0, 0})

            else
                bufsize = 0

            end if

            if bufsize != 0 then
                -- Allocate a buffer to hold bitmap information
                struct = w32acquire_mem(mset, bufsize)

                -- load bitmap data into structure
                if w32Func(xGetObject, {id, bufsize, struct}) != bufsize then
                    warnErr(Err_GSGETBITMAP)
                end if
                -- get the values from the bitmap
                retval[3] = w32fetch(struct, bmWidth)
                retval[4] = w32fetch(struct, bmHeight)
            else
                warnErr(Err_GSGETBITMAP)
                retval[3] = 0
                retval[4] = 0
            end if

        elsif ctrl_Family[id] = PIXMAP then


            -- do we have one?
            hWnd = ctrl_Handle[id]
            if hWnd != 0 then

                bufsize = w32Func(xGetObject, {hWnd, 0, 0})
                -- Allocate a buffer to hold bitmap information
                if bufsize > 0 then
                    struct = w32acquire_mem(mset, bufsize)

                    -- load bitmap data into structure
                    if w32Func(xGetObject, {hWnd, bufsize, struct}) != bufsize then
                        warnErr(Err_GSGETPIXMAP)
                    end if

                    -- get the values from the bitmap
                    retval[3] = w32fetch(struct, bmWidth)
                    retval[4] = w32fetch(struct, bmHeight)
                end if
            end if

        else

            -- Allocate a buffer to hold the rectangle information
            struct  = w32acquire_mem(mset, SIZEOF_RECT)

            -- load rectangle information into the buffer
            if not w32Func(xGetWindowRect, {getHandle(id), struct}) then
                abortErr(Err_GSGETWINDRECT)
            end if

            -- get points
            retval = peek4s({struct,4})

            -- is it owned by a window?
            if ctrl_Parent[id] then

                -- set to owner window
                id = ctrl_Parent[id]

                xy = ClientToScreen(id, 0, 0)

                -- adjust points
-- PL 29/4/09
--/**/          retval = sq_sub(retval,(xy & xy))               --/* Pve
                retval -= (xy & xy)                             -- RDS */

            end if

        end if
        w32release_mem(mset)
        return retval -- {left, top, right+1, bottom+1}
end function
r_getRect = routine_id("getRect")

-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientSize(atom id)
--/desc Get the dimensions of /i "id's" client area.
--/ret Sequence: {Screen.left, Screen.top, right, bottom}
-- The returns the pixel positions of the top-left corner, relative to the screen
-- and the width and height of the client area.
-- For Screen, Printer and Pixmap the top-left is always 0,0
--
-- Example:
--
--/code
--      -- where is the button located?
--      sequence extent
--
--      -- get the extent of the button
--      extent = /getClientSize(MyButton)
--
--      -- display the position
--      /wPrintf(MyWindow, "MyButton is at %d,%d and width=%d, height=%d", extent)
--/endcode

global function getClientSize(integer id)

-- get metrics for current window's client area
-- returns {Sceeen.left, Screen.top, width, height}

integer cx, cy
-- PL 29/4/09
--atom rect, pt, hWnd
atom rect, hWnd
sequence xy

        if find(ctrl_Type[id],{Screen_, Printer_, Pixmap}) then
            return getRect(id)
        end if

        hWnd = getHandle(id)

        rect = w32acquire_mem(0, SIZEOF_RECT)

        if not w32Func(xGetClientRect, {hWnd, rect}) then
            warnErr(Err_GCSGETCLIENTRECT)
        end if

        cx = w32fetch(rect, rectRight   )
        cy = w32fetch(rect, rectBottom)

        -- Locate the top left corner relative to the screen.
        xy = ClientToScreen(id, 0, 0)
        --xy = {w32fetch(rect, rectLeft ), w32fetch(rect, rectTop )}

        w32release_mem(rect)

        return {xy[1], xy[2], cx, cy}

end function



-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientPoint(window, x, y)
--/desc Get screen position of point {/i x, /i y} in /i window.
--/ret {screen x, screen y}
--This routine handles relative positions similar to the /create() routine
--
-- Example:
--
--/code
--      -- where does {0.50, 10} in MyWindow appear on the screen?
--      sequence point
--
--      -- get the screen position
--      point = /getClientPoint(MyWindow, 0.50, 10)
--
--      -- display the size
--      /wPrintf(MyWindow, "The point {0.50,10} maps to {%d, %d on the screen"}, point)
--/endcode

global function getClientPoint(integer id, object x, object y)

--atom pt   -- PL 29/4/09
sequence point, BBox

    BBox = convPctToPixel(id, x, y, 0, 0)
    x = BBox[1]
    y = BBox[2]

    point = ClientToScreen(id, x, y)

    return point

end function


-----------------------------------------------------------------------------
--/topic Attributes
--/func getCtlSize(atom id)
--/desc Get the width and height of /i object.
--/ret SEQUENCE: {width, height}
--
--
-- Example:
--
--/code
--      -- how large is TheButton?
--      sequence size
--
--      -- get the size of TheButton
--      size = /getCtlSize(TheButton)
--
--      -- display the size
--      /wPrintf(MyWindow, "TheButton is %d by %d"}, size)
--/endcode

global function getCtlSize(atom id)

-- get {width, height} for the requested item
sequence s

    -- get extent
    s = getRect(id)

    -- Calculate the width and height
    return {s[3]-s[1], s[4]-s[2]}

end function
r_getCtlSize = routine_id("getCtlSize")

-----------------------------------------------------------------------------
--/topic Attributes
--/func getPosition(object)
--/desc Get the location of /i object.
--/ret {left, top}
--
--
-- Example:
--
--/code
--      -- Where is TheButton?
--      sequence posn
--
--      -- get the position of TheButton
--      posn = /getPosition(TheButton)
--
--      -- display the position
--      /wPrintf(MyWindow, "TheButton is at %d, %d}, posn)
--/endcode

global function getPosition(atom id)

-- get {left, top} for the requested item
sequence s

    -- get extent
    s = getRect(id)

    -- Return the left hand top corner position
    return {s[1], s[2]}

end function

--/topic Attributes
--/func getWindowRect(id)
--/desc Dimensions of window /i id.
--/ret {left, top, right, bottom}
-- Retrieves the dimensions of the bounding rectangle of the
-- specified window. The dimensions are given in screen coordinates
-- that are relative to the upper-left corner of the screen.
global function getWindowRect(integer id)
atom r, ok
sequence result

    r = w32acquire_mem(0, SIZEOF_RECT)
    ok = w32Func(xGetWindowRect, {ctrl_Handle[id], r})
    if not ok then
        result = {0,0,0,0}
    else
        result = peek4s({r,4})
    end if

    w32release_mem(r)

    return result
end function

--/topic Attributes
--/proc setWindowRect(integer id, sequence Rect)
--/desc Sets the dimensions of window /i id.
--/i Rect is a sequence containing the {left, top, right, bottom}
-- coordinates of the control.

global procedure setWindowRect(integer id, sequence pRect)

    pRect[3] -= pRect[1]
    pRect[4] -= pRect[2]
    VOID = w32Func(xMoveWindow, getHandle(id) & pRect & w32True)

end procedure

global constant
            CCS_VERT=#80,
            CCS_LEFT=CCS_TOP+CCS_VERT,
            CCS_RIGHT=CCS_BOTTOM+CCS_VERT,
            CCS_MASK = CCS_RIGHT    -- bit mask for all positional CCS_* values

-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientRect(integer ControlId)
--/desc Get uncovered portion of the client area.
--/ret {left, top, width, height, right, bottom}
-- Unlike the menu, toolbar and statusbar both occupy space in the window.
-- To determine what part of the window's client area is not covered, use
-- this function. This function can be used even if there is no toobar or
-- statusbar in the window.
--
-- For example, the /b generic demo has a /MleText that needs to be resized
-- every time the window is resized. It uses getClientRect to determine the
-- metrics of the /MleText.
--
--/code
--          -- color the unoccupied portion of the window red
--          sequence rect
--
--          -- find out what portion of the window is available
--          rect = getClientRect(TheWindow)
--
--          -- draw a filled rectangle
--          /setPenColor(TheWindow, Red)
--          /drawRectangle(TheWindow, w32True, rect[1], rect[2], rect[1]+rect[3], rect[2]+rect[4])
--/endcode
-----------------------------------------------------------------------------
global function getClientRect(integer id)

-- returns rectangle of the client area, accounting for
-- the toolbar and status bar.

-- PL 29/4/09
--integer x, y, cx, cy, toolbar, tb_position, statusbar
integer toolbar, tb_position, statusbar
atom ptrRect, hdc
sequence rect, size,styles

    rect = repeat(0, 6)

    if id = Screen
    or id = Printer then

        hdc = getDC(id)

        -- screen size
        rect[3] = w32Func(xGetDeviceCaps, {hdc, HORZRES})
        rect[4] = w32Func(xGetDeviceCaps, {hdc, VERTRES})

        releaseDC(id)

    elsif ctrl_Type[id] = Pixmap then
        rect[1..4] = getRect(id)

    elsif ctrl_Type[id] = ReBarBand then
        rect[1..4]  = getRect(id)

    else

        ptrRect = w32acquire_mem(0, SIZEOF_RECT)

        -- get client rectangle size
        if not w32Func(xGetClientRect, {getHandle(id), ptrRect}) then
            warnErr(Err_GCRGETCLIENTRECT)
        end if
        rect[1..4] = peek4u({ptrRect,4})

        w32release_mem(ptrRect)

        -- is there a toolbar?
        for i=1 to length(ctrl_Toolbar[id]) do
            toolbar = ctrl_Toolbar[id][i]
--PL 29/4/09:
--          if (vWinMainState = kNotStarted) or call_func(r_isVisible, {toolbar}) then
            statusbar = (vWinMainState=kNotStarted)
            if not statusbar then
                statusbar = call_func(r_isVisible, {toolbar})
            end if
            if statusbar then

                -- get the size of the toolbar
                size = getCtlSize(toolbar)
                styles = getStyleFlags(toolbar)
                if find(ctrl_Type[toolbar],{ToolBar,FlatToolBar,ReBar}) then
                    tb_position = and_bits(styles[1],CCS_MASK)
                    if tb_position = CCS_TOP then
                    -- add height to the y value
                        rect[2] += size[2]
                        rect[4] -= size[2]
                    elsif tb_position = CCS_LEFT then
                    -- add width to the x value
                        rect[1] += size[1]
                        rect[3] -= size[1]
                    elsif tb_position = CCS_BOTTOM then
                        rect[4] -= size[2]
                    else        -- CCS_RIGHT
                        rect[3] -= size[1]
                    end if
                else -- ReBar, nothing to do
                end if
            end if
        end for

        -- is there a statusbar?
        statusbar = ctrl_Statusbar[id]
--PL 29/4/09:
--      if statusbar and call_func(r_isVisible, {statusbar}) then
        if statusbar then
            if call_func(r_isVisible, {statusbar}) then

                -- get the size of the toolbar
                size = getCtlSize(statusbar)
    
                -- subtract height from the y value
                rect[4] -= size[2]
            end if
        end if

    end if

    rect[5] = rect[1]+rect[3]-1
    rect[6] = rect[2]+rect[4]-1

    return rect

end function
r_getClientRect = routine_id("getClientRect")

-----------------------------------------------------------------------------
-- GENERIC CONTROLS
--

-----------------------------------------------------------------------------
function getMenuState(integer id)
    -- get menu state
    return w32Func(xGetMenuState, {getHandle(id), id, 0})
end function


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setSubFields(integer pID, sequence pPartInfo)
--/desc Defines the sub-fields, or panels, in a status bar.
-- /i pID must refer to a status bar control. /n
-- /i pPartInfo is a list of panel size specifiers for each
-- subfield (a.k.a. panel) in the statusbar. /n
-- Each value in this list can be expressed in one of four
-- ways: /n
--<nl>
--/li A /b positive integer refers to the panels absolute right-hand side
-- pixel position
--/li A /b negitive integer less than -1. This refers to a right-hand side
-- position relative to the window's right-hand edge.
--/li An /b atom > 0 and ~< 1 refers to the panel's width
-- as a fraction of the window's width (0.25 means 25% of the window width)
-- /li A sequence (containing one integer) refers to the panel's width
-- in pixels.
--</nl>
-- If the any specification has the value -1, it means that
-- this is the last panel and it extends to the right hand edge of the
-- window.
--
-- You can use /setText() and /getText() to write and read these panels.
--
-- Example:
--/code
--       -- This specifies 6 panels.
--       -- The first one's rightedge is at pixel 55.
--       -- The second is 100 pixels wide.
--       -- The third is 10% of the window width.
--       -- The 4th is 20 pixels wide.
--       -- The 5th is 10 pixels in from the window's RHS.
--       -- The last one extends to the window's edge.
--       setSubFields(SB, {55, {100}, 0.10, {20},-10,-1})
--/endcode

global procedure setSubFields(integer pID, sequence pPartInfo)
atom lBuffer
atom lAddr
integer lRightEdge
integer lPanelCnt
object lWindowWidth

    if not validId(pID) then
        return
    end if

    if ctrl_Type[pID] != StatusBar then
        return
    end if

    if length(pPartInfo) = 0 then
        return
    end if

    lWindowWidth = getCtlSize(ctrl_Parent[pID])
    lWindowWidth = lWindowWidth[1]
    lBuffer = w32acquire_mem(0, 4 * length(pPartInfo))
    if lBuffer = 0 then
        return
    end if

    lRightEdge = 0
    lPanelCnt = 0
    lAddr = lBuffer
    for i=1 to length(pPartInfo) do
        if sequence(pPartInfo[i]) then
            lRightEdge += floor(pPartInfo[i][1])
        elsif pPartInfo[i] < 1 then
            if pPartInfo[i] > 0 then
                lRightEdge += floor(pPartInfo[i] * lWindowWidth)
            elsif pPartInfo[i] < -1 then
                lRightEdge = lWindowWidth+pPartInfo[i]
            else
                lRightEdge = -1
            end if
        else
            lRightEdge = floor(pPartInfo[i])
        end if
        poke4(lAddr, lRightEdge)
        lAddr += 4
        lPanelCnt += 1
        if lRightEdge = -1 then
            exit
        end if
    end for
    VOID = sendMessage(pID, SB_SIMPLE, 0, 0)
    VOID = sendMessage(pID, SB_SETPARTS, lPanelCnt, lBuffer)
    w32release_mem(lBuffer)
end procedure
r_setSubFields = routine_id("setSubFields")

-----------------------------------------------------------------------------
--/topic Values
--/proc insertText(object pID, object pText)
--/desc Inserts text at the current caret (insersion point)
-- Example:
--
--/code
--      -- Adds some text to the contents of the control, starting at the current insertion point, and clobbering any selected text.
--      /insertText(myedit, "\n(Ready)\n")
--/endcode
global procedure insertText(integer id, sequence text)
        -- replace selection; w32True means allow undo
        VOID = sendMessage(id, EM_REPLACESEL, w32True, text)
end procedure

--/topic Values
--/proc appendText(object pID, object pText)
--/desc Adds text to the end of a edit control.
-- Example:
--
--/code
--      -- Adds some text to the end of the control.
--      /appendText(myedit, ">Ready\n")
--/endcode
global procedure appendText(integer id, sequence text)
-- Insert text at end of edit control's existing text --
atom editlength
        editlength = sendMessage(id, WM_GETTEXTLENGTH, 0, 0)
        VOID = sendMessage(id, EM_SETSEL, editlength, editlength)
        insertText(id, text)
end procedure

--/topic Values
--/proc setText(object pID, object pText)
--/desc Set the text in /i pID control.
-- If the control is editable, it updates the data in the control.
-- Otherwise, it updates the caption text of the control. /n
-- For StatusBar controls, the /i pID can also be used to specify
-- the subField to use. It takes the form of a 2-element sequence
-- {id, subfield}.
--
-- Example:
--
--/code
--      -- change the caption of status bar
--      /setText(TheStatusBar, "Ready")
--      -- If a statusbar has subfields, you can specify
--      -- them like:
--      setText({TheStatusBar,2}, "2nd subField")
--/endcode

global procedure setText(object pID, object pText)

-- set the text in a window

atom lHandle, lTCMITEM, lMenu
-- PL 29/4/09
--integer id, lPart, lPartCnt
integer id, lPart
sequence s
integer lPosn
integer tabNumber, owner

    if atom(pID) then
        id = pID
        lPart = 1
    else
        id = pID[1]
        lPart = pID[2]
    end if

    if validId(id) = w32False then
        return
    end if

    if and_bits(classAttr[ctrl_Type[id]], w32PictCtrl)!=0
    or (ctrl_Parent[id]!=0 and ctrl_Type[ctrl_Parent[id]]=FlatToolBar) then
        return
    end if

    if atom(pText) then
        s = sprintf("%g", pText)
    elsif length(pText) = 2 and sequence(pText[1]) then
        s = sprintf(pText[1], pText[2])
    else
        s = pText
    end if

    if ctrl_Type[id] = StatusBar then

        -- send the text to the statusbar
        VOID = sendMessage(id, SB_SETTEXT,    lPart-1, s)
        VOID = sendMessage(id, SB_SETTIPTEXT, lPart-1, s)

    elsif find(ctrl_Family[id], {MENU,MENUITEM}) then
        -- Get Menu's handle

        owner = ctrl_Parent[id]
        lHandle = ctrl_Handle[owner]
        lMenu = id
        if ctrl_Family[id]=MENU then
            lMenu = getHandle(id)
        end if
        VOID = w32Func(xModifyMenu, {lHandle, lMenu, MF_BYCOMMAND, lMenu, s})
        VOID = w32Func(xDrawMenuBar, {getHandle(findParentWindow(id))})

    elsif ctrl_Type[id] = TreeView then

        if lPart > 0 and lPart <= length(tvitem_data) then
            w32release_mem(tvitem_data[lPart][ktv_TextAddr])
            tvitem_data[lPart][ktv_TextAddr] = w32acquire_mem(0, s)
            tvitem_data[lPart][ktv_TextSize] = length(s)
            lTCMITEM = w32to_memory(0,ID_TVITEM, {TVIF_TEXT,lPart,0,TVIF_TEXT,s,0,0,0})
            VOID = sendMessage(id,TVM_SETITEM,0,lTCMITEM)
            w32release_mem(lTCMITEM)
        end if

    elsif ctrl_Type[id] = TabItem then

        owner = ctrl_Parent[id]
        tabNumber = find(id, ctrl_Specific[owner])-1
        if tabNumber >= 0 then
            -- Allocate a tab structure
            lTCMITEM = w32acquire_mem(0, SIZEOF_TC_ITEM)
            w32store(lTCMITEM, TC_ITEM_mask, TCIF_TEXT)
            w32store(lTCMITEM, TC_ITEM_pszText, s)
            VOID = sendMessage(owner, TCM_SETITEM, tabNumber, lTCMITEM)
            w32release_mem(lTCMITEM)

            repaintWindow(0)

        end if

    elsif find(ctrl_Type[id], {CheckBox, TriCheckBox, Radio}) then
        lPosn = -1
        if equal(s,"0") then
            lPosn = 0
        elsif equal(s,"2") then
            lPosn = 2
        elsif equal(s,"1") then
            lPosn = 1
        end if
        if lPosn >= 0 then
            VOID = sendMessage(id, BM_SETCHECK, lPosn, 0)
        else
            VOID = w32Func(xSetWindowText, {getHandle(id), s})
        end if

    else
        -- For Mle, change single LF to CRLF
        if ctrl_Type[id] = MleText then
            lPosn = 1
            while w32True do
                if lPosn > length(s) then
                    exit
                end if
                if s[lPosn] = 10 then
                    if lPosn = 1
                    or s[lPosn-1] != 13 then
                        s = s[1..lPosn-1] & 13 & s[lPosn..length(s)]
                        lPosn += 1
                    end if
                end if

                lPosn += 1
            end while
        end if
        -- set the window text
        VOID = w32Func(xSetWindowText, {getHandle(id), s})

    end if

end procedure
r_setText = routine_id("setText")

-----------------------------------------------------------------------------
--/topic Values
--/proc setSelectedText(integer object, sequence text)
--/desc Replaces the selected text in /i object with /i text.
-- This only works with edit text controls. It doesn't work as expected with 
--  the latest version (v4.1) of RichEdit controls which ship with Winfows XP.
--
-- Example:
--
--/code
--      -- add HTML formatting to the selected text
--      text = /getSelectedText(TheMle)
--      /setSelectedText(TheMle, "~<I>" & text & "~</I>")
--/endcode
global procedure setSelectedText(integer id, sequence text)

atom addrText, result

    -- is there any text selected?
    result = sendMessage(id, EM_GETSEL, NULL, NULL)
    if result != -1 and w32lo_word(result) <= w32hi_word(result) then

        -- convert to lpsz
        addrText = w32acquire_mem(0, text)

        -- replace selection; w32True means allow undo
        result = sendMessage(id, EM_REPLACESEL, w32True, addrText)

        w32release_mem(addrText)

    end if

end procedure


-----------------------------------------------------------------------------
--/topic Text
--/func drawText(integer id, sequence text, object rect, object flags, integer tabsize, integer left, integer right)
--/desc Places the text /i text into the rectangle /i rect, wrapping words if necessary.
--/ret SEQUENCE: {height, count, {left, top, right, bottom}}
-- This returns a sequence of three values: The height, in pixels, of the text drawn,
-- the number of characters used that could fit into the rectangle specified, and the
-- rectangle actually used, given as a {left,top,right,bottom} sequence. The rectangle is given 
--  in client coordinates for the control /i id. /n
-- The meaning and valid values for the other parameters are to be found in the Win32 API documentation.
--
--Example:
--/code
--          sequence result
--          sequence rect
--          result = drawText(myWind, "Fourscore and twenty years ago, our fathers, ...",
--                   {5,5,140, 75}, DT_WORDBREAK, 4, 0, 0)
--          textheight = result[1]
--          textcnt= result[2]
--          rect = result[3]
--/endcode

global function drawText(integer id, object text, object rect,
                     object flags, integer tabsize,integer left,integer right)
atom hdc, lRect, lDT, memset
integer sLen
atom lHeight
sequence result
sequence lBorders


    -- Check for formatting
    if atom(text) then
        text = sprintf("%g", text)
        sLen = length(text)
    elsif length(text) = 2 and sequence(text[1]) then
        text = sprintf(text[1], text[2])
        sLen = length(text)
    elsif length(text) >= 2 and atom(text[1]) and text[1] = -1 and atom(text[2]) then
        if length(text) = 3 then
            sLen = text[3]
        else
            sLen = -1 -- Let windows find out.
        end if

        text = text[2] -- RAM address of text.
    else
        sLen = length(text)
    end if

    hdc = assignFont(id)

    memset = w32new_memset()
    lRect = w32acquire_mem(memset, SIZEOF_RECT)


    if atom(rect) then
        rect = getClientRect(id)
        lBorders = {0,0,0,0}
    elsif length(rect) = 2 then
        lBorders = rect[2]
        if atom(rect[1]) then
            rect = getClientRect(id)
        else
            rect = rect[1]
        end if
    else
        lBorders = {0,0,0,0}
    end if
-- PL 29/4/09
--/**/  poke4(lRect, sq_add(rect[1..4],lBorders))           --/* Pve
    poke4(lRect, rect[1..4]+lBorders)                   -- RDS */

    lDT = w32to_memory(memset, ID_DRAWTEXTPARAMS,{tabsize, left, right})

    if sequence(flags) then
        flags = w32or_all(flags)
    end if
    -- display the text in the buffer
    lHeight = w32Func(xDrawTextEx, {hdc, text, sLen, lRect, flags, lDT})

    releaseDC(id)

    result = {lHeight, w32fetch(lDT, DTP_uiLengthDrawn),peek4u({lRect,4})}
    w32release_mem(memset)

    return result
end function

-----------------------------------------------------------------------------
--/topic Text
--/func textRect(integer id,sequence text,object rect,object flags,integer tabsize,integer left,integer right)
--/desc Calculates the RECT structure need to draw all the text.
--/ret SEQUENCE: {left, top, right, bottom}
--/l rect defines the left, top and maximum right pixel (for multiple line text).
-- The parameters are the same as for drawText(), as the same API function is called by both routines.
--Example:
--/code
--          sequence result
--          result = textRect(myWind, "Fourscore and twenty years ago, our fathers, ...",
--                   {5,5,140, 75}, DT_WORDBREAK, 4, 0, 0)
--/endcode
global function textRect(integer id, object text, object rect,
                     object flags, integer tabsize,integer left,integer right)

atom hdc, lRect, lDT, memset
integer sLen
atom lHeight
sequence result
sequence lBorders

    -- Check for formatting
    if atom(text) then
        text = sprintf("%g", text)
        sLen = length(text)
    elsif length(text) = 2 and sequence(text[1]) then
        text = sprintf(text[1], text[2])
        sLen = length(text)
    elsif length(text) >= 2 and atom(text[1]) and text[1] = -1 and atom(text[2]) then
        if length(text) = 3 then
            sLen = text[3]
        else
            sLen = -1 -- Let windows find out.
        end if

        text = text[2] -- RAM address of text.
    else
        sLen = length(text)
    end if

    hdc = assignFont(id)

    memset = w32new_memset()
    lRect = w32acquire_mem(memset, SIZEOF_RECT)

    if atom(rect) then
        rect = getClientRect(id)
        lBorders = {0,0,0,0}
    elsif length(rect) = 2 then
        lBorders = rect[2]
        if atom(rect[1]) then
            rect = getClientRect(id)
        else
            rect = rect[1]
        end if
    else
        lBorders = {0,0,0,0}
    end if
-- PL 29/4/09
--/**/  poke4(lRect, sq_add(rect[1..4],lBorders))           --/* Pve
    poke4(lRect, rect[1..4]+lBorders)                   -- RDS */

    lDT = w32to_memory(memset, ID_DRAWTEXTPARAMS,{tabsize, left, right})

    if sequence(flags) then
        flags = w32or_all(flags)
    end if
    flags = or_bits(flags, DT_CALCRECT)
    -- calc the rect needed for the text in the buffer
    lHeight = w32Func(xDrawTextEx, {hdc, text, sLen, lRect, flags, lDT})

    releaseDC(id)

    result = {lHeight, w32fetch(lDT, DTP_uiLengthDrawn),peek4u({lRect,4})}
    w32release_mem(memset)

    return result
end function

--/topic Values
--/func getCaption(integer id)
--/desc This returns any caption text associated with /i id
--/ret SEQUENCE: The caption text.
--The type of controls that have caption text are windows, menus, labels, and buttons.
-- Other controls will return "".
--
--Example:
--/code
--      sequence ctext
--      sequence clst
--      clst = {Btn1, Btn2, MenuItem3, Radio1, Checkbox2}
--      for i=1 to length(ctext) do
--          ctext[i] = ReplaceText(getCaption(clst[i]), "all", "some")
--          setCaption(clst[i], ctext[i])
--      end for
--/endcode

global function getCaption(integer pId)
sequence lCapText
integer lLenMsg, lPos
-- PL 29/4/09
--atom buffer, lmh, lHandle,lText
atom buffer, lHandle


    lCapText = ""

    if find(ctrl_Type[pId], {MenuItem, MenuSpacer, Menu}) then

        if ctrl_Type[pId]=Menu and ctrl_Family[ctrl_Parent[pId]]=WINDOW then
        -- menu bars have no title
            return ""
        elsif ctrl_Type[pId]=MenuSpacer then
            return "-"
        end if

        -- Get Menu's handle
        lHandle = ctrl_Handle[ctrl_Parent[pId]]
        lPos=getMenuPosn(pId)
        -- Get the buffer for item information
        lLenMsg = w32Func(xGetMenuString, {lHandle, lPos, 0, 0, MF_BYPOSITION})+1
        -- Allocate enough room
        buffer = w32acquire_mem(0, lLenMsg)
        -- Get the current menu item text in lCapText
        VOID = w32Func(xGetMenuString, {lHandle, lPos, buffer, lLenMsg,
                                        MF_BYPOSITION})
        lCapText = w32peek_string(buffer)
        w32release_mem(buffer)


    elsif find(ctrl_Family[pId], {WINDOW, BUTTON, STATIC}) then
        lLenMsg = sendMessage(pId, WM_GETTEXTLENGTH, 0, 0)
        if lLenMsg > 0 then
            lLenMsg += 1
            buffer = w32acquire_mem(0, lLenMsg)

            lLenMsg = sendMessage(pId, WM_GETTEXT, lLenMsg, buffer)
            lCapText = peek({buffer, lLenMsg})
            w32release_mem(buffer)

        end if

    end if

    return lCapText
end function
r_getCaption = routine_id("getCaption")

--/topic Edit controls
--/func getCharacterCount(integer id,integer flag)
--/desc Returns the number of characters in the control. If /i flag is zero, 
--  this will be a fast estimate, slightly larger than the actual count. 
--  Passing a nonzero flag will return the actual count, accurate but slower.
--/ret (INTEGER) The number of characters in the control.
global function getCharacterCount(integer id,integer flag)
atom a,chars
    a=w32acquire_mem(0,8)
    poke4(a,{w32iff(flag,GTL_PRECISE,GTL_CLOSE),CP_ACP})
    chars = sendMessage(id,EM_GETTEXTLENGTHEX,a,0)
    w32release_mem(a)
    return chars
end function

--/topic Values
--/func getData(object id)
--/desc This returns any data value associated with /i id
--/ret SEQUENCE: The data as a text string.
-- Note that Menuitems, Radio, Checkbox and TriCheckbox controls
-- return a single character string of "0", "1", or "2" for
-- Unchecked, Checked, and Neither respectively.
--
-- For statusbars and treeviews, /i id can be a 2-element sequence containing
-- {ControlID, Panel#} to get the value of a specific sub-panel
-- of the statusbar, or treeview item.
--
-- For /i RichEdit controls, this returns the selected text only.
--
-- For ListView controls, this returns a sequence that contains one element
-- for each selected item in the ListView. Each element is itself a sequence
-- that contains an string element for each column in the ListView. /n
-- /i "ListView example:" /b
--/code
--      sequence text
--      text = getData(myListView)
--      -- If two rows were selected then the returned value
--      -- may look like this ...
--  {{"Col 1 data", "Col 2 data", "Col 3 data", ...},   -- 1st selected row
--   {"Col 1 data", "Col 2 data", "Col 3 data", ...}    -- 2nd selected row
--  }
--/endcode
--
-- For /i StatusBar controls, /i object can be a two-element sequence,
-- the /b first is the control's id, and the /b second is the section of
-- the status bar (this is zero-based). Also, this returns two-elements: /n
--/li s[1] is the text,
--/li s[2] is the rendering method:
--/define
--/term 0
--The text is drawn with a border to appear lower than the plane of the window.
--/term SBT_NOBORDERS
-- The text is drawn without borders.
--/term SBT_POPOUT
--The text is drawn with a border to appear higher than the plane of the window.
--/term SBT_RTLREADING
--The text will be displayed in the opposite direction to the text in the parent window.
--/enddefine
--
-- For /i /TreeView controls, /i id takes the form {TV, TVItemID}. Where /i TVItemID is the
-- id returned by /addTVItem(). To get the currently selected treeview item, use zero for
-- the /i TVItemID.
--
--Example:
--/code
--      sequence text
--      text[i] = getData(EditFld1)
--/endcode
global function getData(object pID)
-- PL 29/4/09
--integer at, iLength, result, id, lPart, lNumParts
integer iLength, result, id, lPart, lNumParts
-- PL 29/4/09
--atom buffer, lGetMsg, lLenMsg, lHandle
atom buffer
sequence text
atom lmh
sequence items

    if atom(pID) then
        id = pID
        lPart = 0
    else
        -- Get sub-item for statusbar and treeview
        id = pID[1]
        lPart = pID[2]-1
    end if
    text = ""

    if and_bits(classAttr[ctrl_Type[id]], w32PictCtrl)!=0
    or (ctrl_Parent[id]!=0 and ctrl_Type[ctrl_Parent[id]]=FlatToolBar) then
        -- Picture controls and things on a flattoolbar don't any data.
        return text
    end if

    -- edit controls
    -- get the text size

    if ctrl_Type[id] = RichEdit then
        -- return selection
        buffer = w32to_memory(0,ID_CHARRANGE, {0, -1})
        VOID = sendMessage(id, EM_EXGETSEL, 0, buffer)
        result = w32fetch(buffer, CHARRANGE_cpMax) -
                 w32fetch(buffer, CHARRANGE_cpMin)
        w32release_mem(buffer)

        if result > 0 then
            if equal(WC_RICHEDIT,WC_RICHEDIT50) then
                buffer = w32acquire_mem(0, 2*result + 2) --  add 2 for '/0' character.
                iLength = sendMessage(id, EM_GETSELTEXT, 0, buffer)
                text = repeat(0,iLength)
                lmh = buffer
                for i=1 to iLength do
                    text[i] = peek(lmh)+256*peek(lmh+1)
                    lmh += 2
                end for
            else
                buffer = w32acquire_mem(0, result+1) -- add 1 for '/0' character.
                iLength = sendMessage(id, EM_GETSELTEXT, 0, buffer)
                text = peek({buffer, iLength})
            end if
            w32release_mem(buffer)
        else
            iLength = getCharacterCount(id,0)
            buffer = w32acquire_mem(0,iLength)
            lmh = w32to_memory(0,ID_GETTEXTEX, {iLength,GT_DEFAULT,CP_ACP,0,0})
            iLength = sendMessage(id,EM_GETTEXTEX,lmh,buffer)
            text = peek({buffer,iLength})
        end if

    elsif ctrl_Type[id] = StatusBar then
        lNumParts = sendMessage(id, SB_GETPARTS, 0, 0)-1
        if lPart < 0 or lPart > lNumParts then
            lPart = 0
        end if
        iLength = sendMessage(id, SB_GETTEXTLENGTH, lPart, 0)
        if iLength > 0 then
            iLength += 1
            buffer = w32acquire_mem(0, iLength)

            result = sendMessage(id, SB_GETTEXT, lPart, buffer)
            iLength = w32lo_word(result)
            lPart   = w32hi_word(result)
            text = peek({buffer, iLength})
            w32release_mem(buffer)

        end if

    elsif find(ctrl_Type[id], {MenuItem, MenuSpacer, Menu}) then
        if call_func(r_isChecked,{id}) then
            text = "1"
        else
            text = "0"
        end if

    elsif ctrl_Type[id] = TreeView then
        lPart += 1
        if lPart = 0 then
            return getTVSelectedText(id)
        else
            return getTVText(lPart)
        end if

    elsif find(ctrl_Type[id],{Combo,SortedCombo,SimpleCombo,DropDownList,ComboBoxEx})
      and vWMI > 0 and vWinMsg[vWMI][3] = WM_COMMAND
      and w32hi_word(vWinMsg[vWMI][4]) = CBN_SELCHANGE then
        -- Get the selected item rather than the old value in edit box.
        return call_func(r_getItem,{id, 0})

    elsif find(ctrl_Type[id], {SortedList, List}) then
        return call_func(r_getItem,{id,0})

    elsif find(ctrl_Type[id], {ListView}) then
        -- Get a list of all the selected items.
        items = call_func(r_getIndex,{id})
        -- Get each row of data from the selected items
        text = {}
        for i=1 to length(items) do
            text = append(text, call_func(r_getLVItemText,{id, items[i], -1}))
        end for

    elsif find(ctrl_Type[id], {CheckBox, TriCheckBox, Radio}) then
        -- Get its checked value
        iLength = sendMessage(id, BM_GETCHECK, 0, 0)
        text = sprintf("%d", iLength)

    else
        iLength = sendMessage(id, WM_GETTEXTLENGTH, 0, 0)
        if iLength > 0 then
            iLength += 1
            buffer = w32acquire_mem(0, iLength)

            iLength = sendMessage(id, WM_GETTEXT, iLength, buffer)
            text = peek({buffer, iLength})
            w32release_mem(buffer)

        end if

    end if

    return text

end function
r_getData = routine_id("getData")

-----------------------------------------------------------------------------
--/topic Values
--/func getText(object id)
--/desc Get the text in /i object.
--/ret Text in id's caption or text area.
-- This returns the control's caption if it has one, otherwise it returns
-- its value.
--
-- See also: /getCaption and /getData
--
-- Example:
--
--/code
--      -- get the text from TheTextEdit
--      sequence text
--
--      text = /getText(TheTextEdit)
--      tvtext = /getText({myTreeView, itemid})
--      tvselectedtext = /getText({myTreeView, 0})
--      -- get the contents of the second panel in the statusbar.
--      sbtext = /getText({StatBar, 2})
--
--      btnCaption = getText(myBtn)
--/endcode

global function getText(object pID)

sequence text

    if atom(pID) then
        text = getCaption(pID)
        if length(text) = 0 then
            text = getData(pID)
        end if
    else
        text = getData(pID)
    end if


    return text

end function
r_getText = routine_id("getText")

--/topic Values
--/func getValues(integer Context, sequence Ids)
--/desc Gets the values from one or more specified controls.
--/ret SEQUENCE: A list of values, in the same order as the controls in /i Ids
--This gets the values for each of the controls specified in /i Ids. The
--controls can be specified as either a control ID (integer) or a control name.
--
--If your application has multiple controls with the same name, you can specify
--a context for this routine to limit the search to. This is usually the Window
--that the requested controls belong to. To specify that you don't use a context, give any negative value, 0 included, to /i Context.
--
--Example:
--/code
--      sequence lValues
--      lValues = getValues(CustWin, {"Name", "Address", "ZIP", "Telephone"})
--/endcode
global function getValues(integer pContext, sequence pIds)
sequence lKids
sequence lFldName
sequence lValues

    lValues = repeat(0, length(pIds))
    if pContext <= 0 then
        -- No context specified
        for j=1 to length(pIds) do
            if sequence(pIds[j]) then
                -- Convert a name to an id.
                pIds[j] = getNameId(pIds[j])
            end if
            lValues[j] = getText(pIds[j])
        end for
    else
        lKids = ctrl_Group[pContext]
        for i=1 to length(lKids) do
            lFldName = getIdName(lKids[i])
            for j=1 to length(pIds) do
                if sequence(pIds[j]) then
                    if equal(lFldName, pIds[j]) then
                        lValues[j] = getText(lKids[i])
                        exit
                    end if
                elsif find(pIds[j], lKids) then
                    lValues[j] = getText(pIds[j])
                    exit
                end if
            end for
        end for
    end if

    return lValues
end function


-----------------------------------------------------------------------------
--/topic Values
--/func getNumber(object)
--/desc Get the numeric value of text from /i object.
--/ret Numeric value of the control's text/caption value.
--
-- This uses /w32TextToNumber() function to do the conversion. /n
-- If the text value cannot be converted to a numeric value, zero is returned.
--
-- Example:
--/code
--      -- get the numeric value from TheTextEdit
--      atom number
--
--      number = /getNumber(TheTextEdit)
--/endcode

global function getNumber(integer id)
-- get the numeric value of text
--sequence text, result     -- PL 29/4/09

    -- convert the value of the text
    return w32TextToNumber(getData(id))
end function


-----------------------------------------------------------------------------
--/topic Values
--/func getSelectedText(object)
--/desc Get the selected text in /i object.
--/ret Selected text, or empty sequence if nothing is selected.
-- This only works with text edit controls.
--
-- Example:
--
--/code
--      -- get the selected text from TheTextEdit
--      sequence text
--
--      text = /getSelectedText(TheTextEdit)
--/endcode
global function getSelectedText(integer id)

integer firstPos, lastPos
atom charrange
sequence text

    -- get the range of selected text
    if ctrl_Type[id] = RichEdit then
        return getText(id)
    end if

    charrange = w32acquire_mem(0,8)
    VOID = sendMessage(id, EM_GETSEL, charrange, charrange+4)
    firstPos = peek4u(charrange)
    lastPos = peek4u(charrange+4)
    w32release_mem(charrange)

    -- is any text selected?
    if firstPos < lastPos then

        -- get all the text text from the mle
        text = getText(id)

        -- get the selected portion of the text
        return text[firstPos+1..lastPos]

    else
        -- no text selected
        return ""

    end if


end function

--/topic Attributes
--/proc addToBand(id, band)
--/desc Add a control /i id to a /RebarBand /i band

global procedure addToBand(integer id, integer band)
atom rb, bandIndex
sequence size
atom hWndRebar

    size = getCtlSize(id)

    hWndRebar = getHandle(ctrl_Parent[band])
    bandIndex = w32Func(xSendMessage,{hWndRebar, RB_IDTOINDEX, band, 0})

    rb = w32to_memory(0,ID_REBARBANDINFO, {w32or_all({RBBIM_CHILD, RBBIM_CHILDSIZE,RBBIM_TEXT}), -- fMask
                                           0,           -- fStyle
                                           0,           -- clrFore
                                           0,           -- clrBack
                                           getText(id), -- lpText
                                           0,           -- iImage
                                           ctrl_Handle[id], -- hwndChild
                                           0,           -- cxMinChild
                                           size[2],     -- cyMinChild
                                           size[1],     -- cx
                                           0,           -- hbmBack
                                           id,          -- wID
                                           0,           -- cyChild
                                           0,           -- cyMaxChild
                                           0,           -- cyIntegral
                                           0,           -- cxIdeal
                                           0,           -- lParam
                                           0})          -- cxHeader

    VOID = w32Func(xSendMessage,{hWndRebar, RB_SETBANDINFO, bandIndex, rb})

    w32release_mem(rb)

end procedure
r_addToBand = routine_id("addToBand")

--/topic Date and time
--/func getSystemTime()
--/desc Gets the date and time as UTC (a.k.a. GMT)
--/ret SEQUENCE: The date and time (See below for details)
--This does not need any parameters. The date and time are returned
-- as UTC (Coordinated Universal Time) which is the old Greenwich Mean Time.
--
--The return sequence has eight elements arranged thus /n
--/li       Year
--/li       Month
--/li       DayOfWeek
--/li       Day
--/li       Hour
--/li       Minute
--/li       Second
--/li       Milliseconds
--
--Example:
--/code
--      sequence tm
--      tm = getSystemTime()
--/endcode

global function getSystemTime()
atom lST
sequence lResult

    lST = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32Proc(xGetSystemTime,{lST})

    lResult = w32from_memory(lST,ID_SYSTEMTIME)
    w32release_mem(lST)
    return lResult

end function

--/topic Date and time
--/func getLocalTime()
--/desc Gets the date and time according to your timezone settings.
--/ret SEQUENCE: The date and time (See below for details)
-- This does not need any parameters. The date and time are returned
-- based on your system's current timezone settings.
--
--The return sequence has eight elements arranged thus /n
--/li       Year
--/li       Month
--/li       DayOfWeek
--/li       Day
--/li       Hour
--/li       Minute
--/li       Second
--/li       Milliseconds
--
--Example:
--/code
--      sequence tm
--      tm = getLocalTime()
--/endcode

global function getLocalTime()
atom lST
sequence lResult

    lST = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32Proc(xGetLocalTime,{lST})

    lResult = w32from_memory(lST,ID_SYSTEMTIME)
    w32release_mem(lST)
    return lResult

end function

--/topic MonthCalendar Control
--/func getSelectedDate(id)
--/desc Get the selected date in a /MonthCalendar Control
--/ret {Year, Month, DayOfWeek, Day}
-- This cannot be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global function getSelectedDate(integer id)
sequence DATE
atom ok
sequence result

    DATE = {w32acquire_mem(0,SIZEOF_SYSTEMTIME*2),SIZEOF_SYSTEMTIME}

    DATE[2] += DATE[1]
    ok = sendMessage(id, MCM_GETCURSEL, 0, DATE[1])

    if not ok then
        ok = sendMessage(id, MCM_GETSELRANGE, 0, DATE[1])
        if ok = 0 then
            return {}
        end if
    end if

    result = w32from_memory(DATE[1], ID_SYSTEMTIME)
    w32release_mem(DATE[1])

    return result[1..4]

end function

--/topic MonthCalendar Control
--/proc setSelectedDate(id, year, month, day)
--/desc Set the selection in a /MonthCalendar Control
-- This cannot be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setSelectedDate(integer id, integer year, integer month,
integer day)
atom st

    st = w32to_memory(0,ID_SYSTEMTIME, {year, month, 0, day})
    VOID = sendMessage(id, MCM_SETCURSEL, 0, st)

    w32release_mem(st)
end procedure

--/topic MonthCalendar Control
--/func getSelectedDateRange(id)
--/desc Get selected range of dates in a /MonthCalendar Control
--/ret {beginDate, endDate}
-- /i beginDate, /i endDate are sequences of the form:
-- {year, month, dayofweek, day}
--
global function getSelectedDateRange(integer id)
sequence result, DATE

    DATE = {w32acquire_mem(0,SIZEOF_SYSTEMTIME*2),SIZEOF_SYSTEMTIME}

    DATE[2] += DATE[1]

    VOID = sendMessage(id, MCM_GETSELRANGE, 0, DATE[1])

    if VOID = 0 then
        VOID = sendMessage(id, MCM_GETCURSEL, 0, DATE[1])
        if VOID = 0 then
            return {}
        end if
        DATE[2] = DATE[1]
    end if

    result = {w32from_memory(DATE[1], ID_SYSTEMTIME),
              w32from_memory(DATE[2], ID_SYSTEMTIME)}

    result[1] = result[1][1..4]
    result[2] = result[2][1..4]

    w32release_mem(DATE[1])

    return result
end function

--/topic MonthCalendar Control
--/proc setSelectedDateRange(id, beginDate, endDate)
--/desc Set the selected range in a /MonthCalendar Control.
-- This can only be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setSelectedDateRange(integer id, sequence d1, sequence d2)
sequence st, DATE

    DATE = {d1, d2}
    st = {w32acquire_mem(0,SIZEOF_SYSTEMTIME*2),SIZEOF_SYSTEMTIME}
    st[2] += st[1]

    for i=1 to 2 do
        w32store(st[i], SYSTEMTIME_wYear, DATE[i][1])
        w32store(st[i], SYSTEMTIME_wMonth, DATE[i][2])
        w32store(st[i], SYSTEMTIME_wDayOfWeek, DATE[i][3])
        w32store(st[i], SYSTEMTIME_wDay, DATE[i][4])
    end for

    VOID = sendMessage(id, MCM_SETSELRANGE, 0, st[1])

    w32release_mem(st[1])

end procedure

--/topic MonthCalendar Control
--/proc setMaxDateRange(id, range)
--/desc Sets the maximum number of days that can be selected.
-- This can only be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setMaxDateRange(integer id, integer r)
    VOID = sendMessage(id, MCM_SETMAXSELCOUNT, r, 0)
end procedure

--/topic MonthCalendar Control
--/proc setMonthColor(integer id, object iColor, atom Flag)
--/desc Change color of a /MonthCalendar Control
-- /i Flag must be one of the folowing values:
-- /li /b MCSC_BACKGROUND
-- /li /b MCSC_TEXT
-- /li /b MCSC_TITLEBK
-- /li /b MCSC_TITLETEXT
-- /li /b MCSC_MONTHBK
-- /li /b MCSC_TRAILINGTEXT
global procedure setMonthColor(integer id, object iColor, atom cr)
    VOID = sendMessage(id, MCM_SETCOLOR, colorValue(iColor), cr)
end procedure
r_setMonthColor=routine_id("setMonthColor")

global constant
ShortDate = 0,      -- 7/31/00
LongDate = 1,       -- Monday, July 31, 2000
MediumDate = 2      -- 31-Jul-00

--/topic MonthCalendar Control
--/func formatDate(date, format)
--/desc Format a system date as returned by /getSelectedDate, /getSelectedDateRange
--/ret Formatted date
-- /i format must be one of the following:
-- /li /b ShortDate:    "7/31/00"
-- /li /b MediumDate:   "31-Jul-00"
-- /li /b LongDate:     "Monday, July 31, 2000"
global function formatDate(sequence d, integer f)
sequence result, temp

    d[3]+=1
    if f = ShortDate then
        temp = sprint(d[1])
        result = sprint(d[2]) & "/" & sprint(d[4]) & "/" &
                 temp[length(temp)-1..length(temp)]

    elsif f = LongDate then
        result = Days[d[3]] & ", " & Months[LongMonths][d[2]] &
                 " " & sprint(d[4]) & ", " & sprint(d[1])

    elsif f = MediumDate then
        temp = sprint(d[1])
        result = sprint(d[4]) & "-" & Months[ShortMonths][d[2]] &
                 "-" & temp[length(temp)-1..length(temp)]

    end if

    return result
end function

--/topic MonthCalendar Control
--/func getToday(integer id)
--/desc Returns today's date from the MonthCalendar control /i id
--/ret SEQUENCE: {Year, Month, Day, DayOfWeek}
--
--Example:
--/code
--      sequence td
--      td = getToday(myMC)
--      setText(flddate, {"%02d/%02d/%4d", td[1..3]})
--/endcode

global function getToday(integer id)
atom lSysTime
sequence lToday

    lSysTime = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    lToday = repeat(0, 4)

    if sendMessage(id, MCM_GETTODAY, 0, lSysTime) then

        lToday[1] = w32fetch(lSysTime, SYSTEMTIME_wYear)
        lToday[2] = w32fetch(lSysTime, SYSTEMTIME_wMonth)
        lToday[3] = w32fetch(lSysTime, SYSTEMTIME_wDayOfWeek)
        lToday[4] = w32fetch(lSysTime, SYSTEMTIME_wDay)

    end if

    w32release_mem(lSysTime)
    return lToday
end function


--/topic MonthCalendar Control
--/proc setToday(integer id, integer pYear, integer pMonth, integer pDay)
--/desc Set the 'today' date in the MonthCalendar control /i id
--
--Example:
--/code
--      Set the date to 23rd of November, 2004
--      setToday(myMC, 2004, 11, 23)
--/endcode
global procedure setToday(integer id, integer pYear, integer pMonth, integer pDay)
atom lSysTime

    lSysTime = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32store(lSysTime, SYSTEMTIME_wYear,  pYear)
    w32store(lSysTime, SYSTEMTIME_wMonth, pMonth)
    w32store(lSysTime, SYSTEMTIME_wDay,   pDay)

    VOID = sendMessage(id, MCM_SETTODAY, 0, lSysTime)
    w32release_mem(lSysTime)

end procedure

--/topic Updown Control
--/proc setBuddy(id, buddy)
--/desc Set the buddy control of an /UpDown control /i id to be /i buddy. The buddy
-- control has its text updated when the data in the UpDown control changes.
global procedure setBuddy(integer id, integer buddy)
    VOID = sendMessage(id, UDM_SETBUDDY, getHandle(buddy), 0)
end procedure
r_setBuddy = routine_id("setBuddy")

sequence vControlSets vControlSets = {}
object vCurrentControlSet vCurrentControlSet = "not set"

--/topic Values
--/func getTabItem(integer id)
--/desc Used to get the current tabitem selected in a tabcontrol
--/ret The control ID of the current tabitem or 0
global function getTabItem(integer id)
integer tabitem

    if validId(id) = 0
    or ctrl_Type[id] != TabControl then
        return 0
    end if

    tabitem = w32Func(xSendMessage, {getHandle(id),TCM_GETCURSEL,0,0})+1
    if tabitem > 0 and tabitem <= length(ctrl_Specific[id]) then
        tabitem = ctrl_Specific[id][tabitem]
    end if

    return tabitem
end function
r_getTabItem=routine_id("getTabItem")

procedure checkContainersForTabs(integer id)
integer selTab
sequence s
integer idc

    if compare(ctrl_Group[id],{})!=1 then
        return
    end if
    s=ctrl_Group[id]
    for i=1 to length(s) do
        idc=s[i]
        -- control owned by window and containing other controls
        if ctrl_Type[idc] = TabControl then
            -- activate the current tab's items
            selTab = getTabItem(idc)
            ctrl_Current_focus[idc] = 0
            if selTab then -- may be 0 if tab control is empty on opening the window
                call_proc(r_activateTabItems, {selTab})
            end if
        end if
        checkContainersForTabs(idc)
    end for
end procedure

-- Added CChris <oedoc@free.fr> Oct 26, 2006
-- This routine takes a control set id, or a set of ids, and sets the group visibility of all the controls therein
integer r_setControlVisible

procedure setTCVisible(integer TC_id,integer flag)
integer tab_id

    if ctrl_Type[TC_id] = TabControl then
        tab_id = getTabItem(TC_id)
    end if
    call_proc(r_setControlVisible,{ctrl_Group[tab_id],flag})
end procedure

procedure setControlVisible(object id,integer flag)
sequence s
integer lId,lFlag

    if atom(id) then
        s=vControlSets[id]
    else
        s = id
    end if
    if flag then
        -- show a window
        lFlag = SW_SHOWNORMAL
    else
        -- hide a window
        lFlag = SW_HIDE
    end if

    for i=1 to length(s) do
        lId = s[i]
        if ctrl_SetVisible[lId] != flag then
            ctrl_SetVisible[lId] = flag
            VOID = w32Func(xShowWindow, {ctrl_Handle[lId], lFlag})
            if ctrl_Type[lId]=TabControl then
                setTCVisible(lId,flag)
            end if
        end if
    end for
end procedure
r_setControlVisible=routine_id("setControlVisible")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setVisible(object id, atom flag)
--/desc Make /i id visible or invisible.
-- /i id can also be a sequence of control ids. /n
-- Example:
--/code
--          -- make TheButton invisible
--          /setVisible(TheButton, w32False)
--          -- Hide lists one and two.
--          /setVisible({List1, List2}, w32False)
--          -- Show lists three and four.
--          /setVisible({List3, List4}, w32True)
--/endcode
--
-- /b Note: If /i object is a /Window being made visible, it will trigger
-- an /Open event. However, if it is a /Window being made invisible, it
-- will not trigger any event. This should probably be corrected.

global procedure setVisible(object id, atom flag)
integer lFlag
    if flag then
        -- show a window
        lFlag = SW_SHOWNORMAL
    else
        -- hide a window
        lFlag = SW_HIDE
    end if

    if sequence(id) then
        for i=1 to length(id) do
            setVisible(id[i], flag)
        end for
        return
    elsif not validId(id) then
        return
    else
        ctrl_Visible[id] = flag
        if ctrl_SetVisible[id] then
            VOID = w32Func(xShowWindow, {getHandle(id), lFlag})
            if ctrl_Type[id]=TabControl then
                setTCVisible(id,flag)
            end if
        end if
    end if

end procedure
r_setVisible = routine_id("setVisible")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc isVisible(object)
--/desc Returns the visibility state of /i object.
-- /b Note: A TabItem is always visible.
--
-- Example:
--/code
--          -- is TheButton visible?
--          integer flag
--
--          flag = /isVisible(TheButton)
--/endcode

global function isVisible(integer id)

    if not validId(id) then
        return w32False
    end if

    if ctrl_Type[id] = TabItem then
        -- always visible
        return w32True
    else
        -- return hidden state of control
        --return (w32Func(xIsWindowVisible,{getHandle(id)})!=0)
        return ctrl_Visible[id] and ctrl_SetVisible[id]
    end if

end function
r_isVisible = routine_id("isVisible")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setEnable(object id, atom flag)
--/desc Enable or disable /i id.
-- /i id can be a sequence of control ids.
-- Use the MF_ENABLED value in /i flag to enable a menu or menu item, and anything else to disable it. 
--  For other controls, a value of 0 disables and any other enables.
--
-- Example:
--/code
--          -- disable TheButton
--          /setEnable(TheButton, w32False)
--          -- Disable lists one and two.
--          /setEnable({List1, List2}, w32False)
--          -- Enable lists three and four.
--          /setEnable({List3, List4}, w32True)
--/endcode

global procedure setEnable(object id, atom flag)
-- enable/disable an item
sequence lKids
atom lHandle
integer lControl
object lColor

    if sequence(id) then
        for i=1 to length(id) do
            setEnable(id[i], flag)
        end for
        return
    end if


    lHandle = getHandle(id)
    if ctrl_Family[id] = MENU
    or ctrl_Family[id] = MENUITEM then

        -- convert the flag
        flag = w32iff(flag, MF_ENABLED, w32or_all({MF_DISABLED, MF_GRAYED}))

        -- enable/disable the menu
        if w32Func(xEnableMenuItem, {lHandle,id,flag})= #FFFFFFFF then
            -- item does not exist
            warnErr(Err_SETENABLE)
        end if

        -- if menubar, need to redraw
        if ctrl_Family[id] = MENU then
            VOID = w32Func(xDrawMenuBar, {ctrl_Parent[id]})
        end if

    elsif ctrl_Family[id] = BUTTON
    and ctrl_Type[ctrl_Parent[id]] = FlatToolBar then
        flag = sendMessage(ctrl_Parent[id], TB_ENABLEBUTTON, id, flag)

    else
        if find(ctrl_Type[id],{FlatToolBar, ToolBar}) then
            lKids = findChildren(id)
            for i=1 to length(lKids) do
                setEnable(lKids[i][1], flag)
            end for
        end if
        -- enable/disable the window
        w32Proc(xEnableWindow, {lHandle, flag})

        -- Show visualisation of enabled/disabled control
        if flag = 0 then
            lControl = findParent(id)
            if lControl and not and_bits(classAttr[ctrl_Type[id]], w32NoRenderDisabled) then
                lColor = ctrl_Bg_Color[lControl]
                lControl = sequence(lColor)
                setBackground(id, lControl,lColor)
            end if
        else
            lControl = ctrl_Type[id]
            if equal(classBGColor[lControl], w32BGTransparent) then
                if findParent(id) = 0 then
                    lControl = id
                else
                    lControl = findParent(id)
                end if
                setWindowBackColor(id, ctrl_Bg_Color[lControl])
            else
                setWindowBackColor(id, classBGColor[lControl])
            end if

        end if

    end if

end procedure
r_setEnable = routine_id("setEnable")

-----------------------------------------------------------------------------
--/topic Attributes
--/func isEnabled(integer id)
--/desc Returns the enabled state of /i object.
--/ret INTEGER: Zero if no enabled, Non-zero if enabled.
-- /b Note: A TabItem is always enabled.
-- Example:
--/code
--          -- is TheButton enabled?
--          integer flag
--
--          flag = /isEnabled(TheButton)
--/endcode
global function isEnabled(integer id)

-- return enabled state of control
--atom result   -- PL 29/4/09
    if not validId(id) then
        return w32False
    end if


    if ctrl_Family[id] = MENU
    or ctrl_Family[id] = MENUITEM then
    -- true if not disabled
        return not and_bits(getMenuState(id), MF_DISABLED)

    elsif ctrl_Type[id] = TabItem then
        -- always enabled
        return w32True

    else
    -- control
        return (w32Func(xIsWindowEnabled,{getHandle(id)})!=0)

    end if

end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func isMinimized(object)
--/desc Used to see if the window /i object is minimized (iconic) or not.
-- Example:
--/code
--          -- Restore a minimized window?
--          if isMinimized(myWindow) then
--              /showWindow(myWindow, SW_RESTORE)
--          end if
--/endcode
global function isMinimized(integer id)

-- return enabled state of control
--integer result    -- PL 29/4/09

    if validId(id)
    and ctrl_Family[id] = WINDOW then
        -- true if minimized, false otherwise
        return (w32Func(xIsIconic,{getHandle(id)})!= 0)
    else
        return 0
    end if

end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func isMaximized(object)
--/desc Used to see if the window /i object is maximized (zoomed) or not.
-- Example:
--/code
--          -- Restore a maximized window?
--          if isMaximized(myWindow) then
--              /showWindow(myWindow, SW_RESTORE)
--          end if
--/endcode
global function isMaximized(integer id)

-- return enabled state of control
--integer result    -- PL 29/4/09

    if validId(id)
    and ctrl_Family[id] = WINDOW then
        -- true if minimized, false otherwise
        return (w32Func(xIsZoomed,{getHandle(id)})!=0)
    else
        return 0
    end if

end function

--/topic Menus
--/proc defineMenuRadioGroup(sequence ids)
--/desc Defines a set of menu items that form a radio-group
-- /i ids is a list of menuitems that form a logical group of items,
-- in which only one can be marked witha 'radio-button' icon. /n
-- This routine ensures that only one item from the group will be
-- marked. Any that were previously marked will be 'turned off'
--
-- Note 1. The items do not have to be in the same menu. /n
-- Note 2. A given menu item can only be in one radio group.
--
-- Example:
--/code
--      -- set the current loudness level.
--      /defineMenuRadioGroup({miPianissimo, miPiano, piModerato,
--                             miForte, miFortissimo})
--      . . .
--      /setCheck(miForte, w32True)
--      -- now, all items of the same group are unchecked, except for miForte
--/endcode
sequence vMenuItemGroups vMenuItemGroups = {}
global procedure defineMenuRadioGroup(sequence ids)
integer x
    if length(ids) = 0 then
        return
    end if

    -- Ensure that only valid menuitems are supplied.
    -- and remove all the ids from existing groups.
    for i=1 to length(ids) do
        if validId(ids[i]) and find(ctrl_Type[ids[i]], {MenuItem, MenuSpacer}) then
            for j=1 to length(vMenuItemGroups) do
                x = find(ids[i], vMenuItemGroups[j])
                if x != 0 then
                    vMenuItemGroups[j] = w32removeIndex(x, vMenuItemGroups[j])
                end if
            end for
        end if
    end for

    -- Delete any empty groups
    for i=1 to length(vMenuItemGroups) do
        if length(vMenuItemGroups[i]) = 0 then
            vMenuItemGroups = w32removeIndex(i, vMenuItemGroups)
        end if
    end for

    -- Add this new group
    vMenuItemGroups = append(vMenuItemGroups, ids)
end procedure

-----------------------------------------------------------------------------
--/topic Values
--/proc setCheck(object id, checked flag)
--/desc Check or uncheck /i id.
-- This works for /MenuItems and toggle controls
-- such as /Radio, /CheckBox and /ToggleButton, and for ListViews
--
--Note that /i id can be either a single control id or
-- a list of control ids.
--
-- Example:
--/code
--      -- set a check on the SyntaxColoring option
--      /setCheck(SyntaxColoring, w32True)
--      /setCheck({TBtn1, TBtn2, TBtn3}, w32False)
--/endcode
--
-- /b Note: For ListViews, the /i id is actually in the form {{id,row}}
-- so it knows which row to check. Take note of the double sequence syntax.
--/code
--      -- Add a check mark to row 2.
--      /setCheck({{myLV, 2}}, w32True)
--/endcode
--
-- /b Note If /i id is a menu item which has been defined as being in
-- a menu item group (/defineMenuItemGroup), this routine turns on that
-- menu item.
-- This routine ensures that only one item from a menu radio group will be
-- marked. Any that were previously marked will be 'turned off'
--
-- Example:
--/code
--      -- set the current loudness level.
--      /defineMenuRadioGroup({miPianissimo, miPiano, piModerato,
--                             miForte, miFortissimo})
--      . . .
--      /setCheck(miForte, w32True)
--/endcode


global procedure setCheck(object  pControls, integer flag)
atom hMII
atom lType
integer id
integer row
-- PL 29/4/09
--atom TV_ITEM, state, lFlags, mask
atom TV_ITEM, state, mask

    if not sequence(pControls) then
        pControls = {pControls}
    end if

    for k=1 to length(pControls) do
        if sequence(pControls[k]) then
            row = pControls[k][2]
            pControls[k] = pControls[k][1]
        end if

        id = pControls[k]

        if ctrl_Family[id] = MENU
        or ctrl_Family[id] = MENUITEM then
            hMII = 0
            -- First check for Radio Group membership
            for i=1 to length(vMenuItemGroups) do
                if find(id, vMenuItemGroups[i]) then
                    -- First turn off all other items
                    if hMII = 0 then
                        hMII = w32to_memory(0,ID_MENUITEMINFO,0)
                    end if

                    for j=1 to length(vMenuItemGroups[i]) do
                        w32store(hMII, MENUITEMINFO_fMask,MIIM_STATE)
                        w32store(hMII, MENUITEMINFO_fState, MFS_UNCHECKED)
                        VOID = w32Func(xSetMenuItemInfo, {
                                                          getHandle(vMenuItemGroups[i][j]),
                                                          vMenuItemGroups[i][j],
                                                          0, hMII})
                    end for

                    -- Turn the selected item on, if required to.
                    if flag then
                        -- Get the current fType bits
                        w32store(hMII, MENUITEMINFO_fMask,MIIM_FTYPE)
                        VOID = w32Func(xGetMenuItemInfo, {getHandle(id),id,0,hMII})
                        lType = w32fetch(hMII, MENUITEMINFO_fType)
                        -- Set the new state and type.
                        w32store(hMII, MENUITEMINFO_fMask,or_bits(MIIM_STATE,MIIM_FTYPE))
                        w32store(hMII, MENUITEMINFO_fState, MFS_CHECKED)
                        w32store(hMII, MENUITEMINFO_fType, or_bits(lType, MFT_RADIOCHECK))
                        VOID = w32Func(xSetMenuItemInfo, {getHandle(id),id,0,hMII})
                    end if
                    w32release_mem(hMII)
                    return
                end if
            end for

            -- convert the flag
            flag = w32iff(flag, MF_CHECKED, MF_UNCHECKED)

            -- set the check in the menu
            if w32Func(xCheckMenuItem, {getHandle(id),id,flag})= #FFFFFFFF then
                -- item does not exist
                warnErr(Err_SETCHECK)
            end if

            -- if menubar, need to redraw
            if ctrl_Family[id] = MENU then
                VOID = w32Func(xDrawMenuBar, {ctrl_Parent[id]})
            end if

        elsif ctrl_Type[id] = ListView then
            setLVChecked(id, row, flag)

        elsif ctrl_Type[id] = TreeView then
            mask = w32or_all({TVIF_HANDLE, TVIF_STATE})
            if flag then
                state = TVIS_SELECTED_MASK
            else
                state = TVIS_DESELECTED_MASK
            end if

            TV_ITEM = w32to_memory(0,ID_TVITEM, {mask, tvitem_handle[row], state, TVIS_STATEIMAGEMASK})
            VOID = sendMessage(id, TVM_SETITEM, 0, TV_ITEM)
            w32release_mem(TV_ITEM)

        else

            -- toggle the control
            if id != Screen then
                VOID = sendMessage(id, BM_SETCHECK, flag, 0)
            end if
        end if
    end for

end procedure
r_setCheck = routine_id("setCheck")

-----------------------------------------------------------------------------
--/topic Values
--/func isChecked(object id)
--/ret INTEGER: w32True or w32False
--/desc Gets the checked state of /i id.
--
-- This can be used on MenuItems, ListView, TreeView, Radio, and Checkboxes.
--
-- /b Note for TreeView, the /i id takes the form {id, item} /n
--
-- /b Note for ListViews, the /i id normally takes to form {id, row}.
-- But if you just use /i id, then the row with focus is examined.
--
-- Example:
--/code
--          integer flag
--
--          -- is TheRadio1 checked?
--          flag = /isChecked(TheRadio1)
--          -- Is row 3 checked.
--          flag = isChecked({myLV, 3})
--/endcode

global function isChecked(object pId)
atom lRes
integer id
integer row
atom TV_ITEM, state, mask

    -- return checked state of control

    if sequence(pId) then
        row = pId[2]
        id = pId[1]
    else
        id = pId
        if ctrl_Type[id] = ListView then
            row = sendMessage(id, LVM_GETHOTITEM, 0, 0)+1
        end if
    end if

    if ctrl_Family[id] = MENU
    or ctrl_Family[id] = MENUITEM then

        -- true if not disabled
        lRes = and_bits(getMenuState(id), MF_CHECKED)
    elsif ctrl_Type[id] = ListView then
        lRes = getLVChecked(id, row)

    elsif ctrl_Type[id] = TreeView then
        lRes = 0
        if row then
            mask = w32or_all({TVIF_HANDLE, TVIF_STATE})

            TV_ITEM=w32to_memory(0,ID_TVITEM,{mask,tvitem_handle[row],0,TVIS_STATEIMAGEMASK})

            VOID = sendMessage(id, TVM_GETITEM, 0, TV_ITEM)
            state = w32fetch(TV_ITEM, TVITEM_state)
            w32release_mem(TV_ITEM)

            lRes = and_bits(state, TVIS_SELECTED_MASK)
        end if
    else
        -- controls
        lRes = sendMessage(id, BM_GETCHECK, 0, 0)

    end if

    return (lRes!=0)
end function
r_isChecked = routine_id("isChecked")

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc limitText(object, size)
--/desc Limits the amount of text a user can enter into an Edit control.
-- Example:
--/code
--      aTextBox = create(EditText, "", aWindow, x1, y1, width1, height1, 0)
--      aEditor  = create(RichEdit, "", aWindow, x2, y2, width2, height2, 0)
--      limitText(aTextBox, 50) -- No more than 50 characters allowed.
--      limitText(aEditor, 50000) -- No more than 50,000 characters allowed.
--
--/endcode
global procedure limitText(integer id, integer pSize)
atom lMsgType
        -- Limit the amount of text the user can enter.
        if validId(id) then
            if find(ctrl_Type[id], {EditText, MleText, RichEdit}) != 0 then
                if ctrl_Type[id] = RichEdit
                and pSize >= #10000 then -- 64K
                    lMsgType = EM_EXLIMITTEXT
                    VOID = sendMessage(id, lMsgType, NULL, pSize)
                else
                    lMsgType = EM_LIMITTEXT
                    VOID = sendMessage(id, lMsgType, pSize, NULL)
                end if
            end if
        end if
end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/func autoSelect(object id, integer Flag)
--/ret OBJECT: Current AutoSelect status.
--/desc Turns on and off an edit control's auto-selection property.
-- If /i flag is /b w32True, the edit control /i id is set to have Auto-Selection,
-- otherwise it is set off.
--
-- If /i id is a single control id, then the return value is a integer. /n
-- If /i id is a sequence of controls, then the return value is a sequence
-- containing one status flag per control referenced in /i id.
--
-- /i id can be either a single control id or a list of ids in a sequence.
--
-- Auto-selection means that when the edit control gets focus, all its contents
-- is selected automatically for you.
--
-- Example:
--/code
--      sequence asv
--      fldName = create(EditText, "", aWindow, x1, y1, width1, height1, 0)
--      fldAddress = create(EditText, "", aWindow, x1, y2, width1, height1, 0)
--      asv = autoSelect({fldName, fldAddress}, w32True)
--/endcode
global function autoSelect(object id, integer pFlag)
--sequence lAutoSelect  -- PL 29/4/09
object lReturnVal
integer lSingle


    if atom(id) then
        lSingle = w32True
        id = {id}
    else
        lSingle = w32False
    end if
    lReturnVal = {}

    -- Standardise the flag value to w32True or w32False.
    pFlag = not equal(pFlag,0)

    for i=1 to length(id) do
        if validId(id[i]) then
            if find(ctrl_Type[id[i]], {EditText, MleText, RichEdit}) != 0 then
                lReturnVal &= ctrl_Specific[id[i]]
                ctrl_Specific[id[i]] = pFlag
                if pFlag then
                    call_proc(r_setIndex,{id[i], {1,0}})
                else
                    call_proc(r_setIndex,{id[i], call_func(r_getIndex,{id[i]})})
                end if
            end if
        end if
    end for

    if lSingle then
        if length(lReturnVal) = 1 then
            lReturnVal = lReturnVal[1]
        else
            lReturnVal = w32False -- Defaults to w32False
        end if
    end if

    return lReturnVal
end function

--/topic Attributes
--/func canFocus(object id, integer Flag)
--/ret OBJECT: Current canFocus status.
--/desc Turns on and off a control's CanFocus property.
-- If /i flag is /b w32True, the control /i id is set to have CanFocus,
-- otherwise it is set off. The default for controls is /b on.
--
-- /i id can be either a single control id or a list of ids in a sequence.
--
-- If /i id is a single control id, then the return value is a integer. /n
-- If /i id is a sequence of controls, then the return value is a sequence
-- containing one status flag per control referenced in /i id.
--
-- CanFocus means that when the control gets focus, and if its CanFocus
-- property is /b off, then the focus is not set.
--
-- If any of the supplied ids are not managed by win32lib, no action is taken and the
-- returned status for this id is -1.
--
-- Using w32GetValue as an atom or in a sequence will cause the corresponding id to 
--  be left alone its current CanFocus property is simply returned.
-- Example:
--/code
--      -- disallows two controls from getting focus, and retrieving their current status.
--      sequence asv
--      asv = canFocus({fldName, fldAddress}, w32False)
--/endcode
global function canFocus(object id, integer pFlag)
object lReturnVal
integer lSingle

    lSingle = atom(id)
    if lSingle then
        id = {id}
    end if
    lReturnVal = repeat(-1,length(id))

    -- Standardise the flag value to w32True or w32False.
    if pFlag!=w32False and pFlag!=w32GetValue then
        pFlag = 2
    end if

    if pFlag!=w32GetValue then
        for i=1 to length(id) do
            if validId(id[i]) then
                lReturnVal[i] = ctrl_CanFocus[id[i]]
                ctrl_CanFocus[id[i]] = pFlag
            else
                lReturnVal[i] = -1
            end if
        end for
    else
        for i=1 to length(id) do
            if validId(id[i]) then
                lReturnVal[i] = ctrl_CanFocus[id[i]]
            else
                lReturnVal[i] = -1
            end if
        end for
    end if

    if lSingle then
        return lReturnVal[1]
    else
        return lReturnVal
    end if

end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/proc classAutoSelect(object type, integer Flag)
--/desc Turns on and off edit controls' default auto-selection property.
-- If /i flag is /b w32True, controls of /i type are set to have Auto-Selection,
-- otherwise they do not have Auto-Selection behaviour by default when created.
--
-- /i type can be either a single control type or a list of types in a sequence.
--
-- Auto-selection means that when the edit control gets focus, all its contents
-- is selected automatically for you.
--
-- Example:
--/code
--      -- Set the default for EditText fields.
--      classAutoSelect(EditText, w32True)
--/endcode
global procedure classAutoSelect(object pType, integer pFlag)
--sequence lAutoSelect  -- PL 29/4/09

    if atom(pType) then
        pType = {pType}
    end if

    -- Standardise the flag value to w32True or w32False.
    pFlag = not equal(pFlag,0)

    for i=1 to length(pType) do
        if find(pType[i], {EditText, MleText, RichEdit}) then
            if pFlag then
                classAttr[pType[i]] = or_bits(classAttr[pType[i]], w32AutoSelect)
            else
                classAttr[pType[i]] = and_bits(classAttr[pType[i]], not_bits(w32AutoSelect))
            end if
        end if
    end for

end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc cut(object)
--/desc Cut any selected text from /i object and place in the clipboard.
-- Example:
--/code
--          -- cut text from TheTextEdit
--          /cut(TheTextEdit)
--/endcode

global procedure cut(integer id)

    -- send a cut request to a window
    VOID = sendMessage(id, WM_CUT, 0, 0)
end procedure


-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc copy(object)
--/desc Copy any selected text from /i object and place in the clipboard.
-- Example:
--/code
--          -- copy text from TheTextEdit into the clipboard
--          /copy(TheTextEdit)
--/endcode

global procedure copy(integer id)

    -- send a copy request to a window
    VOID = sendMessage(id, WM_COPY, 0, 0)

end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc paste(object)
--/desc Paste text from the clipboard to /i object.
-- Example:
--/code
--          -- paste text from clipboard to TheTextEdit
--          /paste(TheTextEdit)
--/endcode

global procedure paste(integer id)

    -- send a paste request to a window
    VOID = sendMessage(id, WM_PASTE, 0, 0)
end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc clear(object)
--/desc Clear selected text from /i object.
-- Example:
--/code
--          -- clear selected text in TheTextEdit
--          /clear(TheTextEdit)
--/endcode

global procedure clear(integer id)

    -- send a clear request to a window
    VOID = sendMessage(id, WM_CLEAR, 0, 0)

end procedure


-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc undo(object)
--/desc Undo last edit in /i object.
-- Example:
--/code
--          -- undo last edit in TheTextEdit
--          /undo(TheTextEdit)
--/endcode

global procedure undo(integer id)

    -- send a undo request to a window
    VOID = sendMessage(id, WM_UNDO, 0, 0)

end procedure

--/topic Utilities
--/func setClipboard(object data,integer format,integer is_handle,integer size)
--/desc Sets the clipboard to /i data using the other parameters.
--/ret w32False on failure, w32True on success.
-- /i format is a clipboard format, for instance CF_TEXT.
-- The way /i data is interpreted depends on the other parameters:
-- If /i data is a sequence, and the format is any of CF_TEXT, CF_DSPTEXT, CF_OEMTEXT, CF_UNICODETEXT, 
--  then the procedure takes care of all the memory work, and /i is_handle is ignored.
-- Otherwise, if is_handle is nonzero, it means that /i data is a Window memory handle.
-- You may have acquired it through /w32acquire_handle().
-- Otherwise, /i data points to the data you wish to send, and /i size is the size of the data buffer.
-- For the CF_DIB and CF_PALETTE format, the routine is able to figure /i size out, and will do so if 
--  /i size is 0. Other formats may be supported in this way in the future.
-- For the CF_BITMAP, private GDI formats, and  formats, the only allowable value /i data may have is 
--  a handle, so that /i is_anndle and /i size are both ignored.
-- If you provide a handle, you no longer own this handle on return.
global function setClipboard(object data,integer format,integer is_handle,integer size)
integer textformat,uflag,oddlen,bitsize,bi_mode
atom handle,ptr
sequence s

    textformat=find(format,{CF_TEXT, CF_OEMTEXT, CF_UNICODETEXT})
    if not textformat and sequence(data) then
        return w32False -- not allowed
    end if

    if textformat and sequence(data) then
        size=length(data)
        uflag = (format=CF_UNICODETEXT)
        if uflag then
            size*=2
        end if
        handle=w32acquire_handle(size+1+uflag,GMEM_MOVEABLE)
        ptr=w32handle_to_memory(handle)
        if not uflag then
            poke(ptr,data)
        else
            w32poke_words(ptr,data)
            poke(ptr+size+1,0)
        end if
        poke(ptr+size,0)
        w32release_handle(handle,0) -- just unlock it
    elsif is_handle then -- we got a handle
    else
        if format=CF_PALETTE and not size then
            -- compute size
            s=peek({data+2,2})
            size=4*(1+s[1]+256*s[2])
        elsif format=CF_DIB and not size then
            bi_mode=w32fetch(data,biCompression)
            bitsize=w32fetch(data,biSizeImage)
            if bi_mode=BI_RGB and bitsize=0 then
                -- compute size
                -- number of lines
                oddlen=w32fetch(data,biHeight)
                if oddlen<0 then
                    oddlen=-oddlen
                end if
                -- line length in bits
                uflag=w32fetch(data,biWidth)*w32fetch(data,biBitCount)
                -- lines are padded to an integer number of bytes
                if and_bits(uflag,31) then
                    uflag=floor(uflag/8)+4
                else
                    uflag /= 8
                end if
                -- size in bytes of the bitmap bits
                bitsize=uflag*oddlen
            end if
            -- total structure size, minus...
            size=SIZEOF_BITMAPINFOHEADER+bitsize
            -- ... the color table
            uflag=w32fetch(data,biClrUsed)
            if uflag=0 then
                bi_mode=w32fetch(data,biBitCount)
                if bi_mode<=8 then
                    uflag = power(2,bi_mode)
                end if
            end if
            size+=4*uflag
        end if
        handle=w32acquire_handle(size,GMEM_MOVEABLE+GMEM_DDESHARE)
        ptr=w32handle_to_memory(handle)
        mem_copy(ptr,data,size)
        w32release_handle(handle,0) -- just unlock it
    end if

    -- now we have a valid object
    if not w32Func(xOpenClipboard,{0}) then
        warnErr("Unable to open clipboard")
        return w32False
    end if
    VOID = w32Func(xEmptyClipboard,{})
    if not w32Func(xSetClipboardData,{format,data}) then
        warnErr("Unable to store data into clipboard")
        return w32False
    end if
    VOID = w32Func(xCloseClipboard,{})
    return w32True
end function

--/topic Utilities
--/func getClipboard(integer format)
--/desc Retrieves data in the clipboard with this format
--/ret (OBJECT) Either a string for text formats, or a data handle otherwise.
-- If getting a data handle, you should not free it, and copy the referred contents 
--  to some other place, because you do not own the returned handle.
global function getClipboard(integer format)
atom result,ptr
integer nottext
sequence text

    if not w32Func(xOpenClipboard,{0}) then
        warnErr("Unable to open clipboard")
        return w32False
    end if

    result=w32Func(xGetClipboardData,{format})
    nottext=find(format,{CF_TEXT,CF_OEMTEXT,CF_UNICODETEXT})
    if not result then
        if nottext then
            return 0
        else
            return ""
        end if
    end if
    -- we got something
    if nottext then
        return result
    else -- get string
        ptr=w32handle_to_memory(result)
        if format!=CF_UNICODETEXT then
            text=w32peek_string(ptr)
        else
            text=w32peek_string16(ptr)
        end if
        w32release_handle(result,0)
        return text
    end if
end function

-----------------------------------------------------------------------------
-- LISTS
--
-----------------------------------------------------------------------------
--/topic List Control
--/proc addItem(integer control, sequence text)
--/desc Add /i text to the end of /i control's list.
--
-- see also: /insertItem()
--
-- Example:
--/code
--          -- add "Apples" to TheList
--          /addItem(TheList, "Apples")
--
--          -- add fruit list to TheList
--          /addItem(TheList, {"Oranges", "Pears", "Bananas", "Mangoes"})
--/endcode
--
-- addItem is also used to add items to ComboBoxEx controls by packing
-- several params into text.
-- Example:
--/code
--          -- add "Apples" to TheListEx with unselected image
--          -- i1 and selected image i2 where, i1 and i2
--          -- were values returned from /addIcon()
--          /addItem(TheListEx, {"Apples", i1, i2})
--          /addItem(TheListEx, {
--                                {"Oranges", i3, i2},
--                                {"Pears",   i4, i2},
--                                {"Bananas", i5, i2},
--                                {"Mangoes", i6, i2}
--                               })
--/endcode
--
-- See also /"Image Lists" for details on using images
global procedure addItem(integer id, sequence pTextItems)
-- add an item to a list

sequence text, lMsgCodes
integer msg, lBufsz
atom hWnd, flags
atom cbi, pstr
integer lPos,idx

    if ctrl_Type[id] = ComboBoxEx then

        if length(pTextItems) = 3
        and sequence(pTextItems[1])
        and atom(pTextItems[2])
        and atom(pTextItems[3]) then
            pTextItems = {pTextItems}
        end if

        -- Find longest text item
        lBufsz = 0
        for i=1 to length(pTextItems) do

            if atom(pTextItems[i]) then
                pTextItems[i] = sprintf("%g", pTextItems[i])
            end if

            if length(pTextItems[i])!=3
            or atom(pTextItems[i][1])
            or sequence(pTextItems[i][2])
            or sequence(pTextItems[i][3]) then
                warnErr(sprintf("Parameter %d to ComboboxEx is not valid",i))
                return
            end if

            if lBufsz < length(pTextItems[i][1]) then
                lBufsz = length(pTextItems[i][1])
            end if
        end for

        -- Grab enough RAM for the text string conversion.
        pstr = w32acquire_mem(0, lBufsz)
        -- Get the windows handle for this control
        hWnd = getHandle(id)

        cbi = w32acquire_mem(0, SIZEOF_COMBOBOXEXITEM)
        for i=1 to length(pTextItems) do

            text = pTextItems[i]
            -- convert the text sequence to a 'C'-style string
            poke(pstr, text[1])

            w32store(cbi, COMBOBOXEXITEM_iItem, -1)
            w32store(cbi, COMBOBOXEXITEM_pszText, {{},{pstr, length(text[1])}})

            flags = CBEIF_TEXT

            if text[2] then
                idx= text[2]
                if ctrl_Menu[id]!=hILsmall then
                    idx=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[idx]})
                else
                    idx-=1
                end if
                w32store(cbi, COMBOBOXEXITEM_iImage, idx)
                flags = or_bits(flags, CBEIF_IMAGE)
            end if

            if text[3] then
                idx= text[3]
                if ctrl_Menu[id]!=hILsmall then
                    idx=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[idx]})
                else
                    idx-=1
                end if
                w32store(cbi, COMBOBOXEXITEM_iSelectedImage, idx)
                flags = or_bits(flags, CBEIF_SELECTEDIMAGE)
            end if

            w32store(cbi, COMBOBOXEXITEM_mask, flags)

            lPos = w32Func(xSendMessage, {hWnd, CBEM_INSERTITEM, 0, cbi})
            if lPos >= 0 then
                VOID = invokeHandler(id, w32HDataChange, {w32CHG_Add, lPos+1})
            end if
        end for

        w32release_mem(cbi)
        w32release_mem(pstr)

        return
    end if

    -- what control is it?
    lMsgCodes = {0, LB_ADDSTRING, CB_ADDSTRING}
    msg = lMsgCodes[find(ctrl_Family[id], {LISTBOX, COMBO})+1]
    if msg = 0 then
        -- This routine doesn't apply to this type of control.
        return
    end if

    -- Convert a single text sequence into a list of text sequences
    if length(pTextItems) = 0 or atom(pTextItems[1]) then
        pTextItems = {pTextItems}
    end if

    -- Find longest text item
    lBufsz = 0
    for i=1 to length(pTextItems) do
        if atom(pTextItems[i]) then
            pTextItems[i] = sprintf("%g", pTextItems[i])
        end if
        if lBufsz < length(pTextItems[i]) then
            lBufsz = length(pTextItems[i])
        end if
    end for

    -- Grab enough RAM for the text string conversion.
    pstr = w32acquire_mem(0, lBufsz+1)
    -- Get the windows handle for this control
    hWnd = getHandle(id)

    -- add each item to the list.
    for i=1 to length(pTextItems) do
        -- convert the text sequence to a 'C'-style string
        poke(pstr, pTextItems[i])
        poke(pstr+length(pTextItems[i]), 0)
        -- send the 'add' message
        lPos = w32Func(xSendMessage, {hWnd, msg, 0, pstr})
        if lPos != LB_ERR and lPos != LB_ERRSPACE then
            lPos = invokeHandler(id, w32HDataChange, {w32CHG_Add,  lPos+1})
        end if
    end for

    w32release_mem(pstr)

end procedure
r_addItem = routine_id("addItem")

-----------------------------------------------------------------------------
--/topic List Control
--/func setListHScroll(integer id)
--/desc Recalculates the size of a horizontal scroll bar on a listbox.
--/ret INTEGER: The length, in characters, of the longest item in the list.
--Note that it returns -1 if the /i id used is not a list box.
-- Example:
--/code
--      -- Redraw the horizontal scroll bar
--      res = setListHScroll(mylist)
--/endcode

global function setListHScroll(atom id)
integer lLongest
integer lWidth
sequence lExtent
integer lCount
sequence lText
sequence lLongText

    -- Set the horizontal scroll trigger for List Boxes.
    if ctrl_Family[id] != LISTBOX then
        return -1
    end if

    lCount = call_func(r_getCount,{id})
    if lCount = 0 then
        return 0
    end if

    lLongest = -1

    for i=1 to lCount do
        lText = call_func(r_getItem,{id, i})
        if length(lText) > lLongest then
            lLongText = lText
            lLongest = length(lText)
        end if
    end for

    lWidth = call_func(r_getTextWidth,{id, '_' & lLongText})
    lExtent = getCtlSize(id)
    if lWidth < lExtent[2] then
        return lLongest
    end if

    -- Ensure that it has a scroll bar

    call_proc(r_addStyle, {id, WS_HSCROLL})

    VOID = sendMessage(id,LB_SETHORIZONTALEXTENT,lWidth, 0)

    return lLongest
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func insertItem(integer list, sequence text, integer position)
--/desc Insert /i text into /i list at /i position.
--/ret INTEGER: The position actually used by Windows. Zero is returned if it fails.
-- The /i position starts at 1, but if you use zero, it adds it to the
-- end of the list.
--
-- see also: /addItem()
--
-- Example:
--/code
--          -- insert "Bananas" at position 2 in TheList
--          /insertItem(TheList, "Bananas", 2)
--          -- insert "Mangoes" to the end of TheList
--          /insertItem(TheList, "Mangoes", 0)
--/endcode

global function insertItem(integer id, sequence text, integer pos)

-- inserts string to list

integer msg, posn
atom pstr

    -- get the message, based on control type
    if ctrl_Family[id] = LISTBOX then
        msg = LB_INSERTSTRING
    elsif ctrl_Family[id] = COMBO then
        msg = CB_INSERTSTRING
    else
        return 0
    end if

    -- send a message; subtract because it's zero based
    pstr = w32acquire_mem(0, text)
    posn = sendMessage(id, msg, pos-1, pstr)
    if posn = LB_ERR or posn = LB_ERRSPACE then
        posn = -1
    else
        VOID = invokeHandler(id, w32HDataChange, {w32CHG_Add, posn+1})
    end if
    w32release_mem(pstr)
    return posn+1
end function



-----------------------------------------------------------------------------
--/topic List Control
--/func getCount(list)
--/desc Get the count of items in /i list (/List of /Combo)
--/ret Count of items, or zero if control's list is empty.
--
--This returns zero if /i list is not an appropriate control type.
--
-- Example:
--/code
--          -- count size of TheList
--          integer count
--
--          count = /getCount(TheList)
--/endcode
-- /getCount also works with /ListView controls.
global function getCount(atom id)

-- get count of items in list

integer msg

    -- get the message, based on control type
    if ctrl_Family[id] = LISTBOX then
        msg = LB_GETCOUNT

    elsif ctrl_Family[id] = COMBO
       or ctrl_Type[id] = ComboBoxEx then
        msg = CB_GETCOUNT

    elsif ctrl_Type[id] = ListView then
        msg = LVM_GETITEMCOUNT

    else
        return 0
    end if

    return sendMessage(id, msg, 0, 0)

end function
r_getCount = routine_id("getCount")


--/topic Controls
--/func getEdit(integer ComboId)
--/desc Get the control id of the /i ComboId control's edit box.
--/ret INTEGER: The EditBox control Id. Zero if the /i ComboId is not a type of combo box.
--A combo box is made up of two parts, a listbox and an editbox. The editbox is
-- normally never directly used as it is handled by Windows. However, it is sometimes
-- useful for your application to handle the editbox's events directly. /n
--The control id for the editbox is automatically assigned by Win32lib when the
-- combobox is created. This function is used to fetch it.
--
-- Example:
--/code
--  procedure keytrap(integer self, integer event, sequence parms)
--      if parms[1] = VK_ESCAPE then
--          -- move to the first item.
--          setIndex(getParent(self), 1)
--      elsif parms[1] = VK_ENTER then
--          -- Ignore the Enter key
--          returnValue(-1)
--      end if
--  end procedure
--  setHandler(getEdit(MyCombo), w32HKeyPress, routine_id("keytrap"))
--/endcode

global function getEdit(integer id)
    if ctrl_Family[id] = COMBO
    or ctrl_Type[id] = ComboBoxEx then
        return find(id, ctrl_Parent)
    else
        return 0
    end if
end function
r_getEdit = routine_id("getEdit")

-----------------------------------------------------------------------------
--/topic List Control
--/func getIndex(list)
--/desc Get the index of the selected item(s), or cursor position in an edit control.
--/ret INTEGER: Index of selected item, or zero if no item is selected.
-- For ListView and TreeView, this returns a sequence of all selected items.
--
-- For MleEdit, EditText and RichEdit, this returns the cursor position.
--
-- For Combos this returns
--
-- For List, this returns the index of the currently selected item.
--
-- For Window, VScroll, HScroll, VTrackBar, HTrackBar, ProgressBar, UpDown this
-- returns the current scroll position.
--
-- Example:
--/code
--          -- get index of selected item in TheList
--          integer index
--          index = getIndex(TheList)
--
--          integer CPos
--          CPos = getIndex(myRichEdit)
--/endcode

global function getIndex(atom id)

-- get index of selected list item

atom msg
-- PL 29/4/09
--atom CR, start, TV_ITEM, item, state, lParam, count, check
atom CR
--sequence selections   -- PL 29/4/9

    -- get the message, based on control type
    if ctrl_Family[id] = LISTBOX then
        msg = LB_GETCURSEL

    elsif ctrl_Family[id] = COMBO
       or ctrl_Type[id] = ComboBoxEx then
        msg = CB_GETCURSEL

    elsif ctrl_Type[id] = RichEdit
       or ctrl_Family[id] = EDIT then
        CR = w32to_memory(0,ID_CHARRANGE,0)
        VOID = sendMessage(id, EM_GETSEL, CR, CR+4)
        msg = w32fetch(CR, CHARRANGE_cpMin)+1
        w32release_mem(CR)
        return msg

    elsif ctrl_Type[id] = ListView then
        return getLVSelected(id)

    elsif find(ctrl_Type[id],{Window,VScroll,HScroll,VTrackBar,HTrackBar,ProgressBar,UpDown}) then
        return call_func(r_getScrollPos,{id})

    elsif ctrl_Type[id] = TreeView then
        return getTVIndex(id)
    else
        return 0
    end if

    return sendMessage(id, msg, 0, 0)+1

end function
r_getIndex = routine_id("getIndex")

--/topic Edit controls
--/topic RichEdit controls
--/func getSelection(RE)
--/desc Gets the character range of any selected text.
--/ret A sequence {first, last} of the characters selected.
-- Example:
--/code
--          -- Find out what is selected
--          sequence posn
--
--          posn = /getSelection(myRE)
--/endcode
global function getSelection(atom id)

-- get selected text range

sequence msg
atom CR

    if validId(id)=w32True
    and (ctrl_Type[id]=RichEdit or ctrl_Family[id]=EDIT) then
        CR = w32to_memory(0,ID_CHARRANGE, 0)
        VOID = sendMessage(id, EM_GETSEL, CR, CR+4)
--      msg = {w32fetch(CR, CHARRANGE_cpMin), w32fetch(CR, CHARRANGE_cpMax)}+1
        msg = {w32fetch(CR, CHARRANGE_cpMin)+1, w32fetch(CR, CHARRANGE_cpMax)+1}
        w32release_mem(CR)
        return msg
    else
        return {0, 0}
    end if
end function

-----------------------------------------------------------------------------
--/topic List Control
--/proc setIndex(atom list, object index)
--/desc Set the selected item on the list to /i index.
-- This is used for Lists, Combo, and Treeview controls.
--
-- Use 0 to set the index to 'unselected.' /n
-- Use -1 to set the index to the last item. /n
-- /b Note that if /i index is greater than the number of items in the list
-- then the last item will be selected.
-- If the list has the LBS_MULTIPLESEL style, you can use a triple {start,end,,state}
-- as index. The state is 1 to select the range, 0 to deselect. The start and end values
-- are included in the range.
--
-- Example:
--/code
--          -- select the first item on the list
--          /setIndex(TheList, 1)
--          -- select the last item on the list
--          /setIndex(TheList, -1)
--
--          -- deselect all items in the treeview
--          /setIndex(MyTreeView, 0)
--/endcode

--/topic RichEdit controls
--/proc setIndex(atom list, object index)
--/desc Select characters in the control. /n
-- This is used for Edit and RichEdit controls. /n
-- /i index is either
--/li a single integer: the position you are setting the insertion point (caret) at, cancelling any current selection;
--/li a two-element sequence in the form {first selected char index, first NOT selected char index}: the range of 
--      characters to be selected.
-- If the unselected index is zero, everything up to, and including, the last item is selected.
-- If the two are equal, this is the same as passing the common value.
-- If the unselected index is less than the selected index, then the pair is reversed.
-- The insertion point is always set at the second index, whether reversing takes place or not.
-- However, setIndex(id,{0,x}) is equivalent to setIndex(id,1). This is a Windows quirk.
--
-- Use 0 to deselect the current selection.
--
--For ListView controls, /i index can be set to /b w32SelectAll to
--select all items.
--
-- For Window, VScroll, HScroll, VTrackBar, HTrackBar, ProgressBar, UpDown: this
-- sets the current scroll position.
--
-- Example:
--/code
--          -- select characters 30 thru 42 inclusive. Cursor blinks at character 43.
--          /setIndex(TheEdit, {30, 43})
--          -- select all characters
--          /setIndex(TheEdit, {1, 0})
--          -- select all characters from position 78
--          /setIndex(TheEdit, {78, 0})
--          -- move insertion point to char 50
--          /setIndex(TheEdit, 50)
--/endcode

global constant w32SelectAll = {1,0}
global procedure setIndex(atom id, object index)

-- set index of list
integer lCnt
integer msg
--atom result   -- PL 29/4/09
atom hWnd
atom lFlags
atom lParam
atom wParam
atom LV_ITEM
atom lCR
    -- get the message, based on control type
    if atom(index) then
        wParam = index-1
        lParam = 0

    end if

    if ctrl_Family[id] = LISTBOX then
        lFlags = w32Func(xGetWindowLong, {getHandle(id), GWL_STYLE})
        if and_bits(lFlags, LBS_MULTIPLESEL) != 0 then
            if sequence(index) then
                if length(index) = 2 then
                    msg = LB_SELITEMRANGEEX
                    wParam = index[1]-1
                    lParam = index[2]-1
                else
                    -- CChris <oedoc@free.fr> Oct 26, 2006
                    -- Bug fix: index was being used instead of index[1],
                    -- causing a run time error on detecting the -1 special value
                    msg = LB_SELITEMRANGE
                    if index[1] = -1 then
                        index[1] = call_func(r_getCount,{id})
                    end if
-- PL 29/4/09
--/**/              index = sq_sub(index,1)     --/* Pve
                    index -= 1                  --   RDS */
                    lParam = w32pack_word(index[1], index[2])
                    wParam = (index[3]!=0)
                end if
            else
                msg = LB_SETSEL
                if index = -1 then
                    index = call_func(r_getCount,{id})-1
                end if
                lParam = index-1
                wParam = (index!=0)
            end if
        else
            msg = LB_SETCURSEL
            lCnt = call_func(r_getCount,{id})
            if index < 0 or index > lCnt then
                -- Find last item.
                wParam = call_func(r_getCount,{id})-1
            end if
        end if

    elsif ctrl_Type[id] = TreeView then
        hWnd = getHandle(id)
        if index >= 1 and index <= length(tvitem_handle) then
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, tvitem_handle[index]})
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, tvitem_handle[index]})
        else
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, 0})
        end if
        return

    elsif ctrl_Type[id] = ListView then
        hWnd = getHandle(id)
        if equal(index, w32SelectAll) then
            -- deselect all items
            VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, -1, 0})
            wParam = w32Func(xSendMessage,{hWnd, LVM_GETITEMCOUNT, 0, 0})-1
            LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM)
            w32store(LV_ITEM, LVITEM_mask, LVIF_STATE)
            w32store(LV_ITEM, LVITEM_stateMask, LVIS_SELECTED)
            w32store(LV_ITEM, LVITEM_state, LVIS_SELECTED)
            for i=0 to wParam do
                w32store(LV_ITEM, LVITEM_iItem, i)
                VOID = w32Func(xSendMessage,{hWnd, LVM_SETITEM, 0, LV_ITEM})
            end for
            w32release_mem(LV_ITEM)
        elsif index >= 1 then
            VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, index-1, 0})
            VOID = w32Func(xSendMessage, {hWnd, LVM_ENSUREVISIBLE, index-1, 0})
            setLVItem(id, LVIF_STATE, index, 0, or_bits(LVIS_SELECTED,LVIS_FOCUSED),
                      or_bits(LVIS_SELECTED,LVIS_FOCUSED), 0, 0, 0)
        else
            -- deselect all items
            VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, -1, 0})
            wParam = w32Func(xSendMessage,{hWnd, LVM_GETITEMCOUNT, 0, 0})-1
            LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM)
            w32store(LV_ITEM, LVITEM_mask, LVIF_STATE)
            w32store(LV_ITEM, LVITEM_stateMask, LVIS_SELECTED)
            for i=0 to wParam do
                w32store(LV_ITEM, LVITEM_iItem, i)
                VOID = w32Func(xSendMessage,{hWnd, LVM_SETITEM, 0, LV_ITEM})
            end for
            w32release_mem(LV_ITEM)
        end if
        return

    elsif ctrl_Family[id] = COMBO
       or ctrl_Type[id] = ComboBoxEx then
        msg = CB_SETCURSEL

    elsif find(ctrl_Type[id],{Window,VScroll,HScroll,VTrackBar,HTrackBar,ProgressBar,UpDown}) then
        call_proc(r_setScrollPos,{id, index})
        return

    elsif ctrl_Type[id] = RichEdit then
        if atom(index) then
            index = repeat(index, 2)
        end if

--/**/  index = sq_sub(index,1)     --/* Pve
        index -= 1                  --  RDS */
        lCR = w32to_memory(0,ID_CHARRANGE,index)
        VOID = sendMessage(id, EM_EXSETSEL, 0, lCR)
        w32release_mem(lCR)

        return

    elsif ctrl_Family[id] = EDIT then

        if atom(index) then
            index = repeat(index, 2)
        end if

-- PL 29/4/09
--/**/  index = sq_sub(index,1)     --/* Pve
        index -= 1                  --   RDS */

        VOID = sendMessage(id, EM_SETSEL, index[1], index[2])
        return
    else
        -- has no effect on any other type of control.
        return
    end if

    -- Don't report an error if index is *supposed* to be -1

    VOID = sendMessage(id, msg, wParam, lParam)
end procedure
r_setIndex = routine_id("setIndex")

--/topic List Control
--/proc setSelection(atom list, object index)
--/desc An alias for /setIndex


--/topic RichEdit controls
--/proc setSelection(atom list, object index)
--/desc An alias for /setIndex

global procedure setSelection(atom id, object index)
    setIndex(id, index)
end procedure

--/topic RichEdit controls
--/func getRichText(id, range)
--/desc Get text from a /RichEdit control
--/ret Text in the given range.
-- If /i range is an atom, any selected text is returned. However
-- if there is no selected text and /i range is -1 then all the text is returned. /n
-- If /i range is a sequence, /i range should be a 2-element sequence with the
-- first element the starting index to be retrieved, and the
-- second element the last index. /n To always retrieve all the text
-- in the control, set the range to {0, 0}.

global function getRichText(integer pID, object pRange)
sequence
     lText
atom
   lStruct_TR,
--   lStruct_GTL,   -- PL 29/4/09
--   lStruct_GT,    -- PL 29/4/09
   lTextLength,
   lBuffer,
   lBufferLen

    if atom(pRange) then
        -- return selection
        lText = getText(pID)
        if length(lText) = 0
        and pRange = -1 then
            return getRichText(pID, {0,0})
        else
            return lText
        end if
    end if

    lText = ""
    lBufferLen = #1000

    if pRange[1] = 0 and pRange[2] = 0 then
        lStruct_TR = w32acquire_mem(0, SIZEOF_TEXTRANGE+lBufferLen+1)
        lBuffer  = lStruct_TR+SIZEOF_TEXTRANGE
        w32store(lStruct_TR, TEXTRANGE_lpstrText, lBuffer)

        pRange[2] = lBufferLen
        while 1 do
            w32store(lStruct_TR, TEXTRANGE_chrgcpMin, pRange[1])
            w32store(lStruct_TR, TEXTRANGE_chrgcpMax, pRange[2])

            lTextLength = sendMessage(pID, EM_GETTEXTRANGE, 0, lStruct_TR)
            if lTextLength = 0 then
                exit
            end if

            lText &= w32fetch(lStruct_TR, TEXTRANGE_lpstrText)
            pRange[1] = pRange[2]
            pRange[2] += lBufferLen

            if lTextLength < lBufferLen then
                exit
            end if
        end while

    else  -- return specified range
        -- translate to zero base
-- PL 29/4/09
--/**/  pRange = sq_sub(pRange,1)   --/* Pve
        pRange -= 1                 --   RDS */
        if pRange[1] < 0 then
            pRange[1] = 0
        end if
        if pRange[2] < 0 then
            pRange[2] = #FFFF
        end if

        lStruct_TR = w32to_memory(0,ID_TEXTRANGE, pRange)

        VOID = sendMessage(pID, EM_GETTEXTRANGE, 0, lStruct_TR)

        lText = w32fetch(lStruct_TR, TEXTRANGE_lpstrText)
    end if

    w32release_mem(lStruct_TR)
    return lText

end function

--/topic Edit Controls
--/func getCharacterAt(integer id,integer x,integer y)
--/desc Determines the line and column a screen position maps to.
--/ret (SEQUENCE) A {line number, character number, line length, character value} sequence, or {}.
-- /i x and /i y are client screen coordinates relative to /i id.
-- If a position refers to past end of line whitespace, the information returned 
--  is relative to the last character of that line. If it is past the last character 
--  in the control, the returned information is relative to that character.
-- You can check for this condition by calling /getCharacterPosition() and 
--  comparing the result to the initial position.
global function getCharacterAt(integer id,object x,object y)
object s
atom a
integer n,p,uRE

        s=convPctToPixel(id,x,y,0,0)
        x=s[1]
        y=s[2]
        if ctrl_Family[id]=EDIT then
            s = sendMessage(id,EM_CHARFROMPOS,0,w32pack_word(x,y))
            s = {w32hi_word(s),w32lo_word(s)}
            uRE = 0
        elsif ctrl_Type[id]=RichEdit then
            a = w32acquire_mem(0,8)
            poke4(a,{x,y})
            s = sendMessage(id,EM_CHARFROMPOS,0,a)
            w32release_mem(a)
            s = {sendMessage(id,EM_EXLINEFROMCHAR,0,s),s}
            uRE = equal(WC_RICHEDIT,WC_RICHEDIT50)
        else
            return {}
        end if
        s[2] -= sendMessage(id,EM_LINEINDEX,s[1],0)
        n = sendMessage(id,EM_LINELENGTH,s[1],0)
        p = s[2]
        s += 1
        s &= n
        if uRE then
            a = w32acquire_mem(0,2*n)
            p *= 2
        else
            a = w32acquire_mem(0,n)
        end if
        poke4(a,n)
        VOID=sendMessage(id,EM_GETLINE,s[1],a)
        if not uRE then
            s&=peek(a+p)
        else
            s&=(peek(a+p)+256*peek(a+p+1))
        end if
        w32release_mem(a)
        return s
end function

--/topic Edit Controls
--/func getLine(id,number,flag)
--/desc Fetches the text of the request line.
--/ret (SEQUENCE) The (length of) requested line in the control, -1 on error.
-- /i id must refer to an edit or rich edit control; otherwise, the function returns 0.
-- If /i number is 0 or less, the text of current line in the control is returned. The
-- current line is the one where the selection starts, if any, or the one where the insertion point currently is.
-- If flag is w32False, the length is returned; otherwise, the text of the line is returned.

global function getLine(integer id,integer number,integer flag)
atom a
integer n,uRE
sequence s

    if ctrl_Family[id]=EDIT then
        uRE = 0
    elsif ctrl_Type[id]=RichEdit then
        uRE = equal(WC_RICHEDIT,WC_RICHEDIT50)
    else
        return -1
    end if
    n = sendMessage(id,EM_LINELENGTH,number-1,0)
    if not flag then
        return n
    elsif n=0 then
        return ""
    end if
    if uRE then
        a = w32acquire_mem(0,2*n)
    else
        a = w32acquire_mem(0,n)
    end if
    poke4(a,n)
    VOID = sendMessage(id,EM_GETLINE,number-1,a)
    if not uRE then
        s = peek({a,n})
    else
        s = w32peek2({a,n})
    end if
    w32release_mem(a)
    return s
end function

--/topic Edit controls
--/func getCharacterPosition(integer id,integer line,integer col)
--/desc Determines the screen position of the designated character relative to the upper left corner of the client area of the control.
--/ret (SEQUENCE) A {x,y} coordinate pair in client coordinates, or 0 if character doesn't exist.
global function getCharacterPosition(integer id,integer line,integer col)
object s
atom a

    line=sendMessage(id,EM_LINEINDEX,line-1,0)+col-1
    if ctrl_Family[id]=EDIT
    or (ctrl_Type[id]=RichEdit and equal(WC_RICHEDIT,WC_RICHEDIT20)) then
    -- use compatibility mode for RichEdit v3.0
        s = sendMessage(id,EM_POSFROMCHAR,line,0)
        return {w32lo_word(s),w32hi_word(s)}
    else -- RichEdit v1.0 and 4.1
        a = w32acquire_mem(0,8)
        VOID = sendMessage(id,EM_POSFROMCHAR,a,line)
        s = peek4s({a,2})
        w32release_mem(a)
        return s
    end if
end function

--/topic Edit Controls
--/func getVisibleLines(id)
--/desc Determines the numbers of first and last lines displayed on screen.
--/ret (SEQUENCE) {number of first line, number of last line}.
global function getVisibleLines(integer id)
sequence s

        s=getCtlSize(id)
        s=getCharacterAt(id,s[1]-2,s[2]-2)
        return {sendMessage(id,EM_GETFIRSTVISIBLELINE,0,0)+1,s[1]}
end function

--/topic Edit Controls
--/proc insertTextAt(integer id,sequence text,object pos)
--/desc Inesrts /i text in the text of /i at a defined point.
-- If /i pos is an atom, /i text will be appended to the control's text. Otherwise,
-- it specifis the insertion point as {line,column}.
-- If the insertion point is inside the selection, the selection will be enlarged 
--  and contain the inserted text as well. Otherwise, selection is preserved.

global procedure insertTextAt(integer id,sequence text,object pos)
sequence index
integer char_pos

        index = getSelection(id)
        if atom(pos) then
            setIndex(id,0)
            appendText(id,text)
        else
            char_pos = pos[2]+sendMessage(id,EM_LINEINDEX,pos[1]-1,0)
            setIndex(id,char_pos)
            insertText(id,text)
            if index[1]<=char_pos and char_pos<=index[2] then
                index[2] += length(text)
            elsif index[1]>=char_pos then
-- PL 29/4/09
--/**/          index = sq_add(index,length(text))  --/* Pve
                index += length(text)               --   RDS */
            end if
        end if
        setIndex(id,index)
end procedure

--/topic Edit Controls
--/proc deleteLine(integer id,object line)
--/desc Removes the line with supplied number.
-- /i line is either a single line or a {lower,upper} range of lines to delete.
-- No action is taken if the line number is invalid.
-- If the deleted line overlaps the selection, the latter will be shortened accordingly.

global procedure deleteLine(integer id,object line)
integer p,q
sequence s

    s = getSelection(id)
    if atom(line) then
        line = {line,line}
    end if
    p = sendMessage(id,EM_GETLINECOUNT,0,0)
    if line[1]>p then
        return
    elsif line[2]>p then
        line[2] = p
    end if
    p = sendMessage(id,EM_LINEINDEX,line[1]-1,0)
    if line[2]<p then -- not deleting last line
        q = sendMessage(id,EM_LINEINDEX,line[2],0)
        setIndex(id,{p+1,q})
        setSelectedText(id,"")
        if s[1]>q then
-- PL 29/4/09
--/**/      s = sq_sub(s,(q-p)) --/* Pve
            s -= (q-p)          --   RDS */
        elsif s[1]>=p and s[2]>q then
            s[1] = p
        elsif s[1]>=p and s[2]<q then
            s = {p,p-1}
        elsif s[1]<p and s[2]>=q then
            s[2] -= (q-p)
        elsif s[1]<p and s[2]>=p then
            s[2] = p
        end if
    else
        setIndex(id,{p,0})
        setSelectedText(id,"")
        if s[2]>p then
            s[2] = p+1
            if s[1]>p then
                s[1] = p+1
            end if
        end if
    end if
    setIndex(id,s)
end procedure



--------------------------------------------------------------
function setFindSel(integer id, atom flag, atom fr)
object index, range

        index = getIndex(id)-1
        range = w32fetch(fr, FINDREPLACE_lpstrFindWhat)

        if and_bits(flag, FR_DOWN) then
            index = {index, #FFFF}
        else
            index = {0, index}
        end if

        range = {findText(id, range, index, flag), length(range)}
        range[2] += range[1]

        setIndex(id, range)
        return range[1]
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func getItem(integer list, integer index)
--/desc Return the text of item at /i index in /i list.
--/ret Text of item, or "" if fails.
-- /b Note, getItem() will return the text from all columns of a /ListView.
--
--If /i index is zero, the currently selected item is used.
--
-- Example:
--/code
--          -- get the text of the third item in TheList
--          sequence text
--
--          -- get the text of the third item.
--          text = /getItem(TheList, 3)
--          -- get the text of the current item.
--          text = /getItem(TheList, 0)
--/endcode
constant kLenMsg = {CB_GETLBTEXTLEN, -- Combo
                    CB_GETLBTEXTLEN, -- SortedCombo
                    CB_GETLBTEXTLEN, -- SimpleCombo
                    CB_GETLBTEXTLEN, -- DropDownList
                    CB_GETLBTEXTLEN, -- ComboBoxEx
                    LB_GETTEXTLEN,   -- SortedList
                    LB_GETTEXTLEN    -- List
                   }

constant kTxtMsg = {CB_GETLBTEXT, -- Combo
                    CB_GETLBTEXT, -- SortedCombo
                    CB_GETLBTEXT, -- SimpleCombo
                    CB_GETLBTEXT, -- DropDownList
                    CB_GETLBTEXT, -- ComboBoxEx
                    LB_GETTEXT,   -- SortedList
                    LB_GETTEXT    -- List
                   }

global function getItem(atom id, object item)
-- get text of requested item
integer iLength
atom buffer
sequence text
integer ctype

         -- correct class?
        ctype = find(ctrl_Type[id], {Combo, SortedCombo, SimpleCombo,
                                     DropDownList, ComboBoxEx,
                                     SortedList, List,
                                     ListView})
        if ctype = 0 then
            return ""
        end if

        if item = 0 then
            item = getIndex(id)
        end if

        -- ListView returns all columns.
        if ctrl_Type[id] = ListView then
            return getLVItemText(id, item, -1)
        end if

        -- get the text size; add 1 for /0
        iLength = sendMessage(id, kLenMsg[ctype], item-1, 0)+1

        -- no item?
        if iLength = 0 then
            return ""
        end if

        buffer = w32acquire_mem(0, iLength)

        -- move the text to a buffer
        -- value returned is length without 0 terminator
        iLength = sendMessage(id, kTxtMsg[ctype], item-1, buffer)

        text = peek({buffer, iLength})

        w32release_mem(buffer)

        return text

end function
r_getItem = routine_id("getItem")

--/topic Events
--/func getLastMsg(object option)
--/desc Gets information about the Windows message(s) being processed.
--/ret SEQUENCE: The message data sent by Windows. INTEGER: Depth
--This is used by advanced users. It can be used to determine the triggering event for
-- the current event handler. For example, you can use this to find out if a w32HClick
-- event was triggered by a keypress or a mousepress. Or if a paint event was triggered
-- by a scroll action or not.
--
--What this returns depends on the /i option value.
--/li "" Returns the most recent message as {/i Msg}, where /i Msg is a sequence laid out 
--      as {pSource, hWnd, iMsg, wParam, lParam, time_stamp}
--/li "all" Returns all the messages being processed. {/i Msg_1,/i Msg_2, ... } where each /i Msg_n has the form above.
--/li "depth" Returns the current number of messages being processed.
--/li "maxdepth" Returns the maximum number of simultaneous messages processed so far.
--
--This returns an empty list if there are no windows messages being processed. /n
-- time_stamp specifies the elapsed time, in milliseconds, from the time the system was started to 
--  the time the message was created (that is, placed in the thread's message queue)
--
--Example:
--/code
--      -- gets last received message
--      sequence msg
--      msg = getLastMsg("")
--/endcode
global function getLastMsg(object option)

        if equal(option, "depth") then
            return vWMI
        end if

        if equal(option, "maxdepth") then
            return find(0, vWinMsg)-1
        end if

        if vWMI > 0 then
            if equal(option, "all") then
                return vWinMsg[1..vWMI]
            else
                return {vWinMsg[vWMI]}
            end if
        else
            return {}
        end if
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func findItem(integer list, sequence text, integer startpos)
--/desc Locates /i text in the /i list, starting from index /i startpos
--/ret integer: The index in the /i list where /i text was found. Zero if not found.
-- /b Note, findItem will only check the first column of a /ListView.  /n
--If /istartpos is negative, the list is scanned from the last item such that -1 means
-- start at the last item, -2 from the second last item etc... A value of 0 means
-- that all occurances are returned in a sequence.
-- Example:
--/code
--
--          integer ipos
--          sequence allpos
--
--          -- See if new value already exists.
--          ipos = /findItem(TheList, NewValue, 1)
--          -- Get all occurances of "cat"
--          allpos = findItem(TheList, "cat", 0)
--          -- Get last occurance of "dog"
--          ipos = findItem(TheList, "dog", -1)
--/endcode
global function findItem(atom id, sequence ptext, integer item)
-- find the requested text
integer iLength
atom buffer, buflen
sequence text
object lResult
integer ctype
integer lStart, lEnd, lIncr

        if item = 0 then
            lResult = {}
        else
            lResult = 0
        end if

        -- correct class?
        ctype = find(ctrl_Type[id], {Combo, SortedCombo, SimpleCombo,
                                     DropDownList, ComboBoxEx,
                                     SortedList, List,
                                     ListView})
        if ctype = 0 then
            return lResult
        end if

        if item < 0 then
            lIncr = -1
            lEnd = 0
            lStart = getCount(id)+item
        else
            lIncr = 1
            if item = 0 then
                lStart = 0
            else
                lStart = item-1
            end if
            lEnd = getCount(id)-1
        end if

        buflen = 1000
        buffer = w32acquire_mem(0, buflen)

        for i = lStart to lEnd by lIncr do

            if ctrl_Type[id] = ListView then
                -- Get the text from column #1
                text = getLVItemText(id, i+1, 1)
            else

                -- get the text size
                iLength = sendMessage(id, kLenMsg[ctype], i, 0)

                -- no item?
                if iLength = -1 then
                    exit
                end if

                -- Only bother getting the actual text if the lengths are the same.
                if iLength = length(ptext) then
                    if iLength >= buflen then
                        w32release_mem(buffer)
                        buflen = iLength+1  -- account for string terminator
                        buffer = w32acquire_mem(0, buflen)
                    end if
                    -- move the text to a buffer
                    -- value returned is length without 0 terminator
                    VOID = sendMessage(id, kTxtMsg[ctype], i, buffer)

                    text = peek({buffer, iLength})
                else
                    text = ""
                end if
            end if

            if equal(text, ptext) then
                if item = 0 then
                    lResult &= i+1
                else
                    lResult = i+1
                    exit
                end if
            end if
        end for

        w32release_mem(buffer)
        return lResult
end function


--/topic List Control
--/func getMultIndices(id)
--/desc Get indices of multiple selections in a multi-selection list
--/ret Sequence of indices. {} is returned if there are none selected.
global function getMultIndices(atom id)
atom buffer, items
sequence selections
        selections = {}

        items = sendMessage(id, LB_GETSELCOUNT, 0, 0)
        if items > 0 then
            buffer = w32acquire_mem(0, items*4)
            items = sendMessage(id, LB_GETSELITEMS, items, buffer)

            selections = peek4u({buffer, items})+1
            w32release_mem(buffer)
        end if

        return selections
end function

--/topic List Control
--/func getMultItems(id)
--/desc Get text of multiple selections in a multi-selection list
--/ret Sequence of strings. {} is return if nothing is selected.
global function getMultItems(atom id)
sequence selections
        selections = getMultIndices(id)

        for i=1 to length(selections) do
            selections[i] = getItem(id, selections[i])
        end for

        return selections
end function

-----------------------------------------------------------------------------
--/topic List Control
--/proc eraseItems(list)
--/desc Remove all items from /i list.
-- Example:
--/code
--          -- erase items from TheList
--          /eraseItems(TheList)
--/endcode
-- Also works with /ComboBox  /ListView and /TreeView controls.
global procedure eraseItems(atom id)

    -- clear a list
    VOID = deleteItem(id, w32AllItems)

end procedure




-----------------------------------------------------------------------------
-- SCROLL BARS
--
-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setScrollChange(id, linesize, pagesize)
--/desc Adjust the amount that a scroll control will change.
-- The /i linesize is the amount that the /i id will adjust
-- when the up/down arrow is selected, and the /i pagesize is
-- used when the page up/page down is selected.
--
-- For trackbars, the /i pagesize is used to determine the distance
-- between the tick marks.
--
-- The default values are {1,10}.
--
-- Example:
--/code
--          -- set change amount for TheScroll
--          /setScrollChange(TheScroll, 1, 10)
--/endcode

global procedure setScrollChange(object id, atom low, atom high)
-- set the "line" and "page" change amount
atom result
atom lWhich

        if sequence(id) then
            if id[2] = SB_HORZ then
                lWhich = 2
            else
                lWhich = 1
            end if
            id = id[1]
        else
            lWhich = 1
        end if

        -- save value
        ctrl_Scroll[id][lWhich] = {low, high}

-- NEW! 0.45f trackbar support
        if ctrl_Type[id] = HTrackBar
        or ctrl_Type[id] = VTrackBar then

            -- new page size
            result = sendMessage(id, TBM_SETPAGESIZE, low, high)

            -- set tick frequency
            result = sendMessage(id, TBM_SETTICFREQ, high, 0)

        end if

end procedure
r_setScrollChange = routine_id("setScrollChange")

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollChange(scroll)
--/desc Returns the amount that /i scroll will change.
--/ret {line change, page change}
-- This value is set by /setScrollChange. The default value is {1,10},
-- indicating the small change and large change amounts.
--
-- Example:
--/code
--          -- get change amount for TheScroll
--          sequence change
--          change = /getScrollChange(TheScroll)
--/endcode

global function getScrollChange(object id)
atom lWhich

        if sequence(id) then
            if id[2] = SB_HORZ then
                lWhich = 2
            else
                lWhich = 1
            end if
            id = id[1]
        else
            lWhich = 1
        end if

        return ctrl_Scroll[id][lWhich]

end function


--/topic Scroll Control
--/proc setWindowScrollRange(id, typeScroll, min, max, pageSize)
--/desc Set range of window scrollbar or normal scrollbar .
--/li /b id: specifies either the scrollbar or /Window with scrollbar
--/li /b typeScroll : specifies type of the scrollbar
--/li /b pageSize : specifies size of one page (allows to set size of proportional scrollbar)
-- If this is less than 1, it is ignored.
--
--typeScroll can be one of the following :
-- /li /b SB_HORZ : window's (specified by /i id) horizontal scrollbar
-- /li /b SB_VERT : window's (specified by /i id) vertical scrollbar
-- /li /b SB_CTL  : control (specified by /i id), either /HScroll or /VScroll
global procedure setWindowScrollRange(integer id, integer typeScroll, atom min, atom max, atom pageSize)
-- Martin : sets scroll range for window scrolbar
atom sif
atom lMask
sequence lChangeSize

    if ctrl_Type[id] != Window then
        typeScroll = SB_CTL
    elsif typeScroll != SB_HORZ then
        typeScroll = SB_VERT
    end if

    if typeScroll = SB_HORZ then
        ctrl_Range[id][2] = {min,max}
    else
        ctrl_Range[id][1] = {min,max}
    end if

    if pageSize < 1 then
        lMask = SIF_RANGE
    else
        lMask = w32or_all({SIF_RANGE,SIF_PAGE})
        lChangeSize = getScrollChange({id, typeScroll})
        setScrollChange({id, typeScroll}, lChangeSize[1], pageSize)
    end if

    sif = w32to_memory(0,ID_SCROLLINFO, {lMask, min, max, pageSize})
    VOID = w32Func(xSetScrollInfo,
                   {getHandle(id),           -- handle
                    typeScroll,                  --
                    sif,                         -- pointer to structure
                    1})                      -- redraw flag

    w32release_mem(sif)
end procedure
r_setWindowScrollRange = routine_id("setWindowScrollRange")

--/topic Scroll Control
--/proc setScrollRange(id, low, high)
--/desc Sets the range of values of a control.
-- /i id is the Id of the control to be affected. This must be either a... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li UpDown
--/li ProgressBar
--</ul>
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
-- The /i low value must be greater than zero.
--
-- The initial values when a control is created are low=0, high=100.
--
-- Example:
--/code
--          -- set range for TheScroll
--          /setScrollRange(TheScroll, 1, 100)
--          -- set the horizontal scrollbar on a window.
--          /setScrollRange({myWindow, SB_HORZ}, 1, 289)
--/endcode

global procedure setScrollRange(object id, atom min, atom max)
-- set the allowable range for a scroll bar
integer lMsgCode

        if sequence(id) then
            lMsgCode = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
            id = id[1]
        else
            lMsgCode = SB_VERT
        end if


        -- what type of control?
        if find(ctrl_Type[id], {HScroll, VScroll, Window}) then

            if ctrl_Type[id] != Window then
                lMsgCode = SB_CTL   -- scroll bar control
            end if

            setWindowScrollRange(id, lMsgCode, min, max, 0)


        elsif find(ctrl_Type[id], {HTrackBar,VTrackBar}) then

            ctrl_Range[id][1] = {min, max}
            -- set the range and selection range
            VOID = sendMessage(id, TBM_SETRANGEMIN, w32False, min)
            VOID = sendMessage(id, TBM_SETRANGEMAX, w32True, max)
            VOID = sendMessage(id, TBM_SETSELSTART, w32False, min)
            VOID = sendMessage(id, TBM_SETSELEND, w32False, max)


        elsif ctrl_Type[id] = ProgressBar then

            if max > #7FFF or min < -#7FFF then
                VOID = sendMessage(id, PBM_SETRANGE32, min, max )
            else
                VOID = sendMessage(id, PBM_SETRANGE, 0, w32pack_word(min, max) )
            end if
            ctrl_Range[id][1] = {min, max}

        elsif ctrl_Type[id] = UpDown then
            if max > #7FFF or min < -#7FFF then
                VOID = sendMessage(id, UDM_SETRANGE32,  min, max)
            else
                VOID = sendMessage(id, UDM_SETRANGE,  0, w32pack_word(max,min))
            end if

            ctrl_Range[id][1] = {min, max}
        end if


end procedure
r_setScrollRange = routine_id("setScrollRange")

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollRange(id)
--/desc Returns /i id's range of values.
--/ret {low, high}
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
--
--
-- This value is set by /setScrollRange.
--
-- Example:
--/code
--          -- get range of TheScroll
--          sequence range
--          range = /getScrollRange(TheScroll)
--/endcode

global function getScrollRange(object id)
-- Get the allowable range for a scroll bar
atom lWhichBar

        if sequence(id) then
            lWhichBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
            id = id[1]
        else
            lWhichBar = SB_VERT
        end if

        if lWhichBar = SB_HORZ then
            return ctrl_Range[id][2]
        else
            return ctrl_Range[id][1]
        end if

end function


-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setScrollPos(id, position)
--/desc Sets the value of /i id.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
--
--The value must be greater than zero.
--
--This routine will trigger an /w32HScroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setScrollPos(TheScroll, 20)
--          -- set the horizontal scrollbar
--          /setScrollPos({myWindow, SB_HORZ}, 17)
--/endcode

global procedure setScrollPos(object id, object pAction)
-- return the value of the scroll bar
object result
atom min, max
atom lWhichBar
atom pos

        result = {}
        if sequence(id) then
            lWhichBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
            id = id[1]
        else
            lWhichBar = SB_VERT
        end if

        if sequence(pAction) then
            pos = floor(pAction[1])
            pAction = pAction[2]
            if sequence(pAction) or not integer(pAction) or pAction < SB_LINEUP or pAction > SB_ENDSCROLL then
                pAction = SB_UserDefined
            end if
        else
            pos = floor(pAction)
            pAction = SB_UserDefined
        end if

        if lWhichBar = SB_HORZ then
            min = ctrl_Range[id][2][1]
            max = ctrl_Range[id][2][2]
        else
            min = ctrl_Range[id][1][1]
            max = ctrl_Range[id][1][2]
        end if

        if pos < min then
            -- clip to minimum
            pos = min

        elsif pos > max then
            -- clip to maximum
            pos = max

        end if


        -- scrollbar?
        if ctrl_Type[id] = HScroll
        or ctrl_Type[id] = VScroll then

            -- call the function
            result =  w32Func(xSetScrollPos, {
                                              getHandle(id),    -- handle
                                              SB_CTL,           -- scroll bar specific
                                              pos,              -- new scroll bar position
                                              w32True})         -- redraw flag

        elsif ctrl_Type[id] = Window then
            -- call the function
            result =  w32Func(xSetScrollPos, {
                                              getHandle(id),    -- handle
                                              lWhichBar,        -- scroll bar specific
                                              pos,              -- new scroll bar position
                                              w32True})         -- redraw flag

        elsif ctrl_Type[id] = HTrackBar
           or ctrl_Type[id] = VTrackBar then

            -- send message
            result = sendMessage(id, TBM_SETPOS, w32True, pos)

        elsif ctrl_Type[id] = ProgressBar then

            -- send message
            result = sendMessage(id, PBM_SETPOS, pos, 0)

        elsif ctrl_Type[id] = UpDown then

            -- send message
            result = sendMessage(id, UDM_SETPOS, pos, 0)

        end if

        if atom(result) then
            -- run the event code, if any
            VOID = invokeHandler(id, w32HScroll, {pos, pAction, lWhichBar})
        end if

end procedure
r_setScrollPos = routine_id("setScrollPos")

-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setVScrollPos(window, position)
--/desc Sets the value of a window's vertical /i scroll.
-- The value must be greater than zero. This will trigger an
-- /Scroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setVScrollPos(myWindow, 20)
--/endcode

global procedure setVScrollPos(integer id, atom pos)

    setScrollPos({id, SB_VERT}, pos)

end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setHScrollPos(window, position)
--/desc Sets the value of a window's horizontal /i scroll.
-- The value must be greater than zero. This will trigger an
-- /Scroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setHScrollPos(myWindow, 20)
--/endcode

global procedure setHScrollPos(integer id, atom pos)

    setScrollPos({id, SB_HORZ}, pos)


end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollPos(object id)
--/desc Gets the value of a scroll control.
--/ret Position of the thumb on the scroll control.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- For /b Window controls, the /i id parameter can also specify which of
-- the vertical or horizontal scrollbars you are referring to. To do this,
-- the form of /i id is {ctrl, bartype} where /i bartype is either
-- /b SB_VERT or /b SB_HORZ.
--
-- Note that this function returns the last position of the thumb while it was resting. 
--  Use /getThumbPos() instead to track the thumb position while it is being dragged.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos,vpos,hpos
--          pos = /getScrollPos(TheScroll)
--          vpos = /getScrollPos({MainWin, SB_VERT})
--          hpos = /getScrollPos({MainWin, SB_HORZ})
--/endcode

global function getScrollPos(object id)
-- return the value of the scroll bar
integer lSBar

        if sequence(id) then
            lSBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
            id = id[1]
        else
            lSBar = SB_VERT
        end if

        if ctrl_Type[id] = Window then

            return w32Func(xGetScrollPos, {getHandle(id), lSBar})

        elsif ctrl_Type[id] = HScroll
           or ctrl_Type[id] = VScroll then
            -- call the function
            return w32Func(xGetScrollPos, {
                                           getHandle(id),       -- handle
                                           SB_CTL})             -- scroll bar specific

        elsif ctrl_Type[id] = HTrackBar
           or ctrl_Type[id] = VTrackBar then

            return sendMessage(id, TBM_GETPOS, 0, 0)

        elsif ctrl_Type[id] = ProgressBar then

            return sendMessage(id, PBM_GETPOS, 0, 0)

        elsif ctrl_Type[id] = UpDown then

            return w32shortInt(sendMessage(id, UDM_GETPOS, 0, 0))
        else
            return 0
        end if

end function
r_getScrollPos = routine_id("getScrollPos")
-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getThumbPos(object id)
--/desc Gets the position of the scroll thumb while being dragged.
--/ret Position of the thumb on the scroll control.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- For /b Window controls, the /i id parameter can also specify which of
-- the vertical or horizontal scrollbars you are referring to. To do this,
-- the form of /i id is {ctrl, bartype} where /i bartype is either
-- /b SB_VERT, /b SB_HORZ or /b SB_CTL (for /HScroll or VScroll controls).
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos,vpos,hpos
--          pos = /getThumbPos(TheScroll)
--          vpos = /getThumbPos({MainWin, SB_VERT})
--          hpos = /getThumbPos({MainWin, SB_HORZ})
--/endcode

-- 2/19/04 mwl: added this to get the thumb position when dragged by the mouse
global function getThumbPos(object id)
-- return the value of the scroll bar
atom lSif, lPos
integer lSBar

        if sequence(id) then
            lSBar = w32iff(find(id[2], {SB_VERT,SB_HORZ,SB_CTL}), id[2], SB_VERT)
            id = id[1]
        else
            lSBar = SB_CTL
        end if

        if find(ctrl_Type[id], {HTrackBar, VTrackBar}) then
            return sendMessage(id, TBM_GETPOS, 0, 0)
        end if

        lSif = w32acquire_mem(0, SIZEOF_SCROLLINFO)

        w32store(lSif, sifSize, SIZEOF_SCROLLINFO)
        w32store(lSif, sifMask, SIF_TRACKPOS + SIF_POS)
        VOID = w32Func(xGetScrollInfo, {getHandle(id), lSBar, lSif})
        lPos = w32fetch(lSif, sifTrackPos)
        w32release_mem(lSif)

        return lPos

end function


-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getVScrollPos(window)
--/desc Gets the value of a window's vertical scroll bar.
--/ret Position of the thumb on the scroll control.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos
--          pos = getVScrollPos(myWindow)
--/endcode

global function getVScrollPos(integer id)
-- return the value of the scroll bar
        return getScrollPos({id, SB_VERT})
end function

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getHScrollPos(window)
--/desc Gets the value of a window's horizontal scroll bar.
--/ret Position of the thumb on the scroll control.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos
--          pos = getHScrollPos(myWindow)
--/endcode

global function getHScrollPos(integer id)

    -- return the value of the scroll bar
    return getScrollPos({id, SB_HORZ})
end function

-----------------------------------------------------------------------------
--/topic UpDown Control
--/proc setAcceleration(integer id, sequence Times)
--/desc Set the rate of change for an UpDown control
--The UpDown control specified by /i id will change it's values while the user holds
-- down the mouse button. You can alter the rate of the change by using this routine. /n
-- The /i Times parameter is a list of /b pairs of values, in which the first of a pair
-- is the number of seconds to elapse (from the time the button was pressed) before changing,
-- and the second is the (positive) increment to change the current value by.
--
--Example:
--/code
--      setAcceleration(myUpDown, {{1,2}, {3,4}, {5, 8}, {7,16}})
--/endcode

global procedure setAcceleration(integer id,  sequence pTimes)
atom lAccel
atom lAddr

-- PL 29/4/09:
--/**/  pTimes = sort(w32abs(sq_floor(pTimes))) --/* Pve
        pTimes = sort(w32abs(floor(pTimes)))    --   RDS */
        lAddr  = w32acquire_mem(0, length(pTimes) * 8)
        lAccel = lAddr

        for i=1 to length(pTimes) do
            poke4(lAccel, pTimes[i])
            lAccel += 8
        end for
        VOID = sendMessage(id, UDM_SETACCEL, length(pTimes), lAddr)

        w32release_mem(lAddr)
end procedure



-----------------------------------------------------------------------------
-- GRAPHICS
--

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setBackColor(integer id, object color)
--/desc Set the color for used for the pen fill color in /i id.
-- When the pen mode is set to /b OPAQUE, this specifies the color
-- used to fill the 'gaps'.
--
-- When used on a MonthCalendar control, it changes the background color
-- imediately.
--
-- When used on a Pixmap control, it clears the entire Pixmap to the
-- specified color.
--
-- Example:
--/code
--      -- set pen opaque color
--      setPenBkMode(TheWindow, OPAQUE)
--      setBackColor(TheWindow, Red)
--      /wPuts(TheWindow, "This text is on red")
--
--      -- Clear a pixmap
--      setBackColor(pixmap1, BrightWhite)
--/endcode

global procedure setBackColor(integer id, object color)
-- set the background color for the window
atom hdc
sequence lRect
object lSavedColor

    if equal(color, w32WinDefColor) then
        return
    end if

    if ctrl_Type[id] = MonthCalendar then
        setMonthColor(id, MCSC_BACKGROUND, color)
        return

    elsif ctrl_Type[id] = Pixmap then
        lRect = getRect(id)
        lSavedColor = ctrl_Pen[id][PenColor]
        ctrl_Pen[id][PenColor] = color
        call_proc(r_drawRectangle,{id, w32True, 0, 0, lRect[3], lRect[4]})
        ctrl_Pen[id][PenColor] = lSavedColor
        return

    end if

    hdc = getDC(id)
    if w32Func(xSetBkColor, {hdc, colorValue(color)}) = CLR_INVALID then
        warnErr("SetBkColor in setBackColor failed.")
    end if
    releaseDC(id)
end procedure
r_setBackColor = routine_id("setBackColor")





-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenColor(window, color)
--/desc Set the the pen color used in /i window.
-- This is the color that is used by other graphics routines.
--
-- To set the color of text, use /setTextColor.
--
-- Example:
--/code
--          -- set pen color to red
--          /setPenColor(TheWindow, /Red)
--          -- draw a red line
--          /drawLine(TheWindow, 10, 10, 40, 40)
--/endcode

global procedure setPenColor(integer id, object color)

    -- set a new pen color for the window

    -- save the color
    ctrl_Pen[id][PenColor] = color

end procedure
r_setPenColor = routine_id("setPenColor")

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenWidth(window, pixel width)
--/desc Set the the pen width used in /i window.
-- The default thickness of the pen is 1 pixel.
--
-- Example:
--/code
--          -- set pen thickness of 3
--          /setPenWidth(TheWindow, 3)
--          -- draw a thick line
--          /drawLine(TheWindow, 10, 10, 40, 40)
--/endcode

global procedure setPenWidth(integer id, integer pixels)

    -- set a new pen thickness for the window

    -- save the thickness
    ctrl_Pen[id][PenWidth] = pixels

end procedure



-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenStyle(window, style)
--/desc Set the style that lines are drawn in.
-- This allows the creation of various dotted line styles.
-- Use /setBackColor to define the background fill used on the line.
--
-- The following styles are defined:
--
-- /li /b Solid
-- /li /b Dash
-- /li /b Dot
-- /li /b DashDot
-- /li /b DashDotDot
--
-- /b Note: This routine will probably be dropped in later releases.
--
-- Example:
--/code
--          -- set pen style
--          /setPenStyle(TheWindow, Dot)
--
--          -- draw a line using that pen style
--          /drawLine(TheWindow, 10, 10, 100, 100)
--/endcode

global procedure setPenStyle(integer id, atom style)

    -- set a new pen style for the window

    -- save the style
    ctrl_Pen[id][PenStyle] = style

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenMode(integer id, integer mode)
--/desc Determines what mode graphics are drawn in.
-- The default value is /b R2_COPYPEN. The mode codes are:
--
-- /li /b R2_BLACK: Pixel is always 0.
-- /li /b R2_NOTMERGEPEN: Pixel is the inverse of the R2_MERGEPEN color.
-- /li /b R2_MASKNOTPEN: combination common screen and inverse of pen.
-- /li /b R2_NOTCOPYPEN: Pixel is the inverse of the pen color.
-- /li /b R2_MASKPENNOT: combination common to pen and inverse of screen.
-- /li /b R2_NOT: Pixel is the inverse of the screen color.
-- /li /b R2_XORPEN: Pixel is the inverse of the R2_XORPEN color.
-- /li /b R2_NOTMASKPEN: Pixel is the inverse of the R2_MASKPEN color.
-- /li /b R2_MASKPEN: combination common to pen and the screen.
-- /li /b R2_NOTXORPEN: combination of colors in pen and screen, but not in both.
-- /li /b R2_NOP: Pixel remains unchanged.
-- /li /b R2_MERGENOTPEN: combination of screen and inverse of pen.
-- /li /b R2_COPYPEN: Pixel is the pen color.
-- /li /b R2_MERGEPENNOT: combination of pen color and inverse of screen color.
-- /li /b R2_MERGEPEN: combination of pen color and the screen color.
-- /li /b R2_WHITE: Pixel is always 1.
--
-- Example:
--/code
--          -- draw an XOR line in TheWindow
--          /setPenMode(TheWindow, R2_XORPEN)
--          /drawLine(TheWindow, 10, 10, 100, 100)
--/endcode

global procedure setPenMode(integer id, atom rop2)
    -- sets the ROP2 mode for the window
    ctrl_Pen[id][PenROP2] = rop2
end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenBkMode(window, mode)
--/desc Determines if the background color for lines and text.
-- Modes are:
--
-- /li /b OPAQUE: Draws using background color.
-- /li /b TRANSPARENT: Draws without background color.
--
-- If /i mode is /b OPAQUE, the color set in /setBackColor is used.
-- The default mode is /b TRANSPARENT.
--
--
-- Example:
--/code
--          -- draw an XOR line in TheWindow
--          /setPenBkMode(TheWindow, OPAQUE)
--          /drawLine(TheWindow, 10, 10, 100, 100)
--/endcode

global procedure setPenBkMode(integer id, atom bkMode)
    -- sets the pen background mode
    -- default is transparent
    ctrl_Pen[id][PenBkMode] = bkMode
end procedure
r_setPenBkMode=routine_id("setPenBkMode")

--/topic Graphics
--/proc setPenBkColor(window, color)
--/desc Determines the background color for text.
--
-- Example:
--/code
--  setPenBkColor(Fld1, BrightCyan)
--/endcode

global procedure setPenBkColor(integer id, object color)
    ctrl_Pen[id][PenBkColor] = color
end procedure

--/topic Graphics
--/proc setPenBrushColor(window, color)
--/desc Determines the solid brush color for filled shapes.
--The current pen color is used until this is called for the first time.
--
-- Example:
--/code
--  setPenBrushColor(MyCanvas, Blue)
--/endcode

global procedure setPenBrushColor(integer id, object color)
    ctrl_Pen[id][PenBrushColor] = {color}
end procedure



-----------------------------------------------------------------------------
--/topic Attributes
--/proc setRect(control, left, top, width, height, repaint)
--/desc Move and resize /i control.
--
-- /i control is moved to /i x, /i y, and sized to /i cx, /i cy. If the
-- /i repaint flag is set, the window is repainted.
--
-- To find the current size and position of /i control, use /getRect.
--
-- Example:
--
--/code
--          -- move Button1 to 20x20
--          sequence size
--
--          -- get the current size
--          size = /getCtlSize(Button1)
--
--          -- change the size and repaint
--          /setRect(Button1, 20, 20, size[1], size[2], w32True)
--/endcode

global procedure setRect(integer id, object left, object top,
                object width, object height, integer repaint)
sequence BBox
integer lError

        -- move the given window

        if ctrl_Type[id] = Pixmap then
            call_proc(r_setCtlSize,{id, width,height})
            return
        end if
        BBox = convPctToPixel(id, left, top, width, height)
        left  = BBox[1]
        top  = BBox[2]
        width = BBox[3]
        height = BBox[4]

        if not w32Func(xMoveWindow, {getHandle(id), left, top, width, height, repaint}) then
            lError = w32Func(xGetLastError,{})
            warnErr(sprintf("setRect:Repositioning Control failed. %d",lError))
        end if

        if ctrl_Type[id] = Window then
            w32Proc(xUpdateWindow, {getHWND(id)})
        end if

end procedure
r_setRect = routine_id("setRect")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setCtlSize(integer control, object Width, object Height)
--/desc Resizes /i control to /i Width and /i Height.
--
--If either /i Width or /i Height has the value /b w32SameSize then
-- the dimension is unchanged.
--
-- Example:
--
--/code
--      -- size Button1 to 60 pixels wide by 32 pixels high
--      /setCtlSize(Button1, 60, 32)
--      -- size Button2 to 60 pixels wide, leaving the height unchanged.
--      /setCtlSize(Button2, 60, w32SameSize)
--      -- size Button3 to 25 pixels high, leaving the width unchanged.
--      /setCtlSize(Button3, w32SameSize, 25)
--
--/endcode

global procedure setCtlSize(integer id, object pWidth, object pHeight)
-- resize the given item
integer x, y
atom oldBmp
sequence size, BBox, posn

    if validId(id) = w32False then
        return
    end if

    if equal(pWidth, w32SameSize) or equal(pHeight, w32SameSize) then
        size = getRect(id)
        if equal(pWidth, w32SameSize) then
            pWidth = size[3]-size[1]
        end if

        if equal(pHeight, w32SameSize) then
            pHeight = size[4]-size[2]
        end if
    end if

    if not integer(pWidth) or not integer(pHeight) then
        BBox = convPctToPixel(id, 0, 0, pWidth, pHeight)
        pWidth = BBox[3]
        pHeight = BBox[4]
    end if

    if ctrl_Family[id] = PIXMAP then

        -- get the bitmap, replace it with null
        oldBmp = ctrl_Handle[id]
        ctrl_Handle[id] = -1

        -- create a pixmap of the new size
        createPixmap(id, pWidth, pHeight)

        -- was there a prior bitmap?
        if oldBmp > 0 then

            -- is there a current bitmap to draw into?
            if ctrl_Handle[id] != 0 then

                -- get size of old bitmap
                size = getCtlSize(oldBmp)
                pWidth = size[1]
                pHeight = size[2]

                -- copy the old bitmap onto the new one
                bitBlt(ctrl_Handle[id], 0, 0,
                       oldBmp, 0, 0, pWidth, pHeight, SRCCOPY)

            end if

            deleteObject(oldBmp)

        end if

    else

        -- get the current location of the window
        posn = getPosition(id)
        x = posn[1]
        y = posn[2]

        -- normal window class, send MoveWindow to resize
        if not w32Func(xMoveWindow, {getHandle(id), x, y, pWidth, pHeight, 1}) then
            warnErr("setCtlSize:MoveWindow failed.")
        end if

    end if


end procedure
r_setCtlSize = routine_id("setCtlSize")

--/topic Attributes
--/proc setCtlPosition(integer id, object x, object y)
--/desc Sets the location of the control. x and y can have any format /create() supports.
--
--Example
--/code
--      setCtlPosition(myBtn, 100, 200)
--/endcode
global procedure setCtlPosition(integer id, object x, object y)
sequence lRect

        lRect = getRect(id)
        setRect(id, x, y, lRect[3]-lRect[1], lRect[4]-lRect[2], 1)

end procedure
r_setCtlPosition=routine_id("setCtlPosition")
--/topic Attributes
--/proc setClientRect(integer id, object width, object height)
--/desc Sets the size of the client area in a window.
--The client area is the area used by the application. It excludes toolbar,
-- statusbar, menu area, etc... /n
--After using this routine, the window will be larger than the dimensions
-- specified here. Use /getRect() to retrive to total window area.
--
--Example
--/code
--       --Set the client area to exactly 300 by 200 pixels
--       setClientRect(myWindow, 300, 200)
--/endcode
------------------------------
global procedure setClientRect(integer id, object width, object height)
sequence client, diff, BBox

        -- Only work with valid IDs
        if validId(id) = w32False then return end if

        if not integer(width) or not integer(height) then
            BBox = convPctToPixel(id, 0, 0, width, height)
            width  = BBox[3]
            height = BBox[4]
        end if

        -- get current client size

        client = getClientRect(id)

        -- get current window size and subtract client size
--/**/  diff = sq_sub(getCtlSize(id),sq_sub(client[3..4],client[1..2]))     --/* Pve
        diff = getCtlSize(id) - (client[3..4] - client[1..2])               -- RDS */

        -- add difference to specified window size
        setCtlSize(id, width+diff[1], height+diff[2])

end procedure
r_setClientRect = routine_id("setClientRect")

--/topic Attributes
--/proc moveZOrder(integer id, atom ztype)
--/desc Move /i id to up or down the of Z order of windows.
--
--/i ztype can be one of HWND_TOP, HWND_BOTTOM, HWND_TOPMOST or
-- HWND_NOTOPMOST, or another control id. In the latter case, /i id will appear in front of /i ztype.
--
-- Example:
--
--/code
--          -- change the order of this window.
--          moveZOrder(msgWindow,   HWND_TOPMOST)
--
--          -- move id in front of id2
--          moveZOrder(id,  id2)
--/endcode

global procedure moveZOrder(integer id, atom ztype)

    if not validId(id) then
        return
    end if

    if not find(ztype, {HWND_TOP,HWND_BOTTOM,HWND_TOPMOST,HWND_NOTOPMOST})
    and validId(ztype) then
        ztype = getHandle(ztype)
    end if

    VOID = w32Func(xSetWindowPos, {getHandle(id),
                                   ztype, 0, 0, 0, 0,
                                   SWP_NOSIZE + SWP_NOMOVE})

end procedure
r_moveZOrder = routine_id("moveZOrder")

--/topic Attributes
--/proc refreshWindow(object ids)
--/desc Forces the control(s) to be refreshed.
-- /i ids can be either a single control id or a sequence of ids.
--
--Example:
--/code
--      refreshWindow({btn1, btn2})
--/endcode
global procedure refreshWindow(object ids)

    if atom(ids) then
        ids = {ids}
    end if

    for i=1 to length(ids) do
        if validId(ids[i]) then
            VOID = w32Func(xSetWindowPos, {getHandle(ids[i]),
                                           0, 0, 0, 0, 0,
                                           SWP_NOSIZE + SWP_NOMOVE + SWP_NOZORDER +
                                           SWP_DRAWFRAME + SWP_SHOWWINDOW})
        end if
    end for

end procedure

--/topic Attributes
--/proc distributeControls(sequence ids, integer disttype, object pValue)
--/desc Evenly distributes a set of controls.
--/i ids is the set of controls to distribute. There must be at least two ids
-- in the sequence. /n
--/i disttype is the type of distribution required. It can be one of... /n
--/li /b w32HorzCentre : The /i left edges are distributed evenly.
--/li /b w32HorzGap : The /i gap between right & left edges are equally.
--/li /b w32VertCentre : The /i top edges are distributed evenly.
--/li /b w32VertGap : The /i gap between bottom & top edges are equally.
--/i pValue is maximum distance that can span the controls. If this is 0
-- it is ignored. Otherwise it can be a pixel measurement, or a single control
-- id inside a sequence. See examples for details. If /i pValue is zero,
-- then the maximum distance is the largest distance between the controls in
-- /i ids.
--
--Examples
--/code
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, fld1 and fld3 remain
--      -- still while fld2 is centered between them.
--      distributeControls({fld1, fld2, fld3}, w32HorzGap, 0)
--
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, only fld1 remains
--      -- still while fld2 and fld3 are moved such that the distance
--      -- between fld1 and fld3 is 200 pixels.
--      distributeControls({fld1, fld2, fld3}, w32HorzGap, 200)
--
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, only fld1 remains
--      -- still while fld2 and fld3 are moved such that the distance
--      -- between fld1 and fld3 is the width of fld4.
--      distributeControls({fld1, fld2, fld3}, w32HorzGap, {fld4})
--
--/endcode
global procedure distributeControls(sequence ids, integer disttype, object pValue)
sequence lRect, lDim
integer lHigh, lCur
atom lIncr, lLow

        -- Minimum of 2 ids.
        if length(ids) <= 1 then
            return
        end if

        -- Make space all the new locations
        lDim = repeat({0, 0, 0, 0}, length(ids))

        lRect = getRect(ids[1])
        if disttype = w32HorzCentre then
            -- left edges are evenly distributed
            lLow = lRect[1]
            lHigh = lRect[3]
            lDim[1][1] = lRect[1]
            lDim[1][2] = lRect[2]
            lDim[1][3] = lRect[3]-lRect[1]
            lDim[1][4] = lRect[4]-lRect[2]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                lDim[i][1] = lRect[1]
                lDim[i][2] = lRect[2]
                lDim[i][3] = lRect[3]-lRect[1]
                lDim[i][4] = lRect[4]-lRect[2]
                if lLow > lRect[1] then
                    lLow = lRect[1]
                end if
                if lHigh < lRect[3] then
                    lHigh = lRect[3]
                end if
            end for

            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[3]-lRect[1]
            end if
            if pValue != 0 then
                lHigh = lLow+pValue
            end if

            lHigh -= lDim[length(ids)][3]

            lIncr = (lHigh-lLow)

            lIncr /= (length(ids)-1)
            for i=1 to length(ids) do
                setRect(ids[i], floor(lLow), lDim[i][2], lDim[i][3], lDim[i][4], 0)
                lLow += lIncr
            end for

        elsif disttype = w32HorzGap then
            -- gap b/n right & left edges are equal
            lLow = lRect[1]
            lHigh = lRect[3]
            lCur = lRect[3]-lRect[1]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                if lLow > lRect[1] then
                    lLow = lRect[1]
                end if
                if lHigh < lRect[1]+lRect[3] then
                    lHigh = lRect[3]
                end if
                lCur += (lRect[3]-lRect[1])
            end for

            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[3]-lRect[1]
            end if

            if pValue != 0 then
                lIncr = pValue
            else
                lIncr = floor((lHigh-lLow-lCur) / (length(ids)-1))
            end if

            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                setRect(ids[i], lLow, lRect[2],
                        lRect[3]-lRect[1], lRect[4]-lRect[2], 0)
                lLow +=  (lRect[3]-lRect[1])+lIncr
            end for

        elsif disttype = w32VertCentre then
            -- top edges are evenly distributed
            lLow = lRect[2]
            lHigh = lRect[4]
            lDim[1][1] = lRect[1]
            lDim[1][2] = lRect[2]
            lDim[1][3] = lRect[3]-lRect[1]
            lDim[1][4] = lRect[4]-lRect[2]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                lDim[i][1] = lRect[1]
                lDim[i][2] = lRect[2]
                lDim[i][3] = lRect[3]-lRect[1]
                lDim[i][4] = lRect[4]-lRect[2]
                if lLow > lRect[2] then
                    lLow = lRect[2]
                end if
                if lHigh < lRect[4] then
                    lHigh = lRect[4]
                end if
            end for

            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[4]-lRect[2]
            end if
            if pValue != 0 then
                lHigh = lLow+pValue
            end if

            lHigh -= lDim[length(ids)][4]

            lIncr = (lHigh-lLow)

            lIncr /= (length(ids)-1)
            for i=1 to length(ids) do
                setRect(ids[i], lDim[i][1], floor(lLow),  lDim[i][3], lDim[i][4],0)
                lLow += lIncr
            end for

        elsif disttype = w32VertGap then
            -- gap b/n bottom & top edges are equal
            lLow = lRect[2]
            lHigh = lRect[4]
            lCur = lRect[4]-lRect[2]
            for i = 2 to length(ids) do
                lRect = getRect(ids[i])
                if lLow > lRect[2] then
                    lLow = lRect[2]
                end if
                if lHigh < lRect[4] then
                    lHigh = lRect[4]
                end if
                lCur += (lRect[4]-lRect[2])
            end for

            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[4]-lRect[2]
            end if
            if pValue != 0 then
                lIncr = pValue
            else
                lIncr = floor((lHigh-lLow-lCur)/(length(ids)-1))
            end if

            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                setRect(ids[i], lRect[1], lLow,
                        lRect[3]-lRect[1], lRect[4]-lRect[2], 0)
                lLow += (lRect[4]-lRect[2])+lIncr
            end for

        end if

        repaintWindow(0)

end procedure

--/topic Attributes
--/proc sizeControls(object ids, object disttype, object pValue)
--/desc Set the size for a set of controls.
--/i ids is a sequence of ids to change /n
--/i sizetype is one of, or a list of ... /n
--/li w32Height
--/li w32Width
--/li w32Widest
--/li w32Narrowest
--/li w32Tallest
--/li w32Shortest
--
--/i pValue, if used, is the minimum size. It can be a pixel value or an
-- id value in a sequence.
--
--Example /n
--/code
--      sizeControls({fld1,fld3,fld4,fld7}, w32Widest, 200)
--      sizeControls({fld2,fld0,fld9,fld5}, w32Tallest, {lblXYZ})
--      -- fld3 and fld2 to the same dimensions as btnOne
--      sizeControls({fld3,fld2}, {w32Height,w32Width}, {btnOne})
--/endcode
global procedure sizeControls(object ids, object pSizetype, object pValue)
sequence lRect
object lValue
integer sizetype

        if atom(ids) then
            ids= {ids}
        end if
        if length(ids) = 0 then
            return
        end if

        if atom(pSizetype) then
            pSizetype = {pSizetype}
        end if
        lValue = pValue
        for k=1 to length(pSizetype) do
            sizetype = pSizetype[k]
            pValue = lValue
            if sizetype = w32Width then
                -- all are set to the same width

                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[3]-lRect[1]
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    setRect(ids[i], lRect[1], lRect[2], pValue, lRect[4]-lRect[2], 0)
                end for

            elsif sizetype = w32Height then
                -- all are set to the same height
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[4]-lRect[2]
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    setRect(ids[i], lRect[1], lRect[2], lRect[3]-lRect[1], pValue, 0)
                end for

            elsif sizetype = w32Widest then
                -- all are set to the widest width
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                else
                    lRect = getRect(ids[1])
                end if
                pValue = lRect[3]-lRect[1]
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue < (lRect[3]-lRect[1]) then
                        pValue = lRect[3]-lRect[1]
                    end if
                end for

                sizeControls(ids, w32Width, pValue)

            elsif sizetype = w32Narrowest then
                -- all are set to the narrowest width
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                else
                    lRect = getRect(ids[1])
                end if
                pValue = lRect[3]-lRect[1]
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue > (lRect[3]-lRect[1]) then
                        pValue = lRect[3]-lRect[1]
                    end if
                end for

                sizeControls(ids, w32Width, pValue)

            elsif sizetype = w32Tallest then
                -- all are set to the tallest height
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                else
                    lRect = getRect(ids[1])
                end if
                pValue = lRect[4]-lRect[2]
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue < (lRect[4]-lRect[2]) then
                        pValue = lRect[4]-lRect[2]
                    end if
                end for

                sizeControls(ids, w32Height, pValue)

            elsif sizetype = w32Shortest then
                -- all are set to the shortest height.
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                else
                    lRect = getRect(ids[1])
                end if
                pValue = lRect[4]-lRect[2]
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue > (lRect[4]-lRect[2]) then
                        pValue = lRect[4]-lRect[2]
                    end if
                end for

                sizeControls(ids, w32Height, pValue)

            end if
        end for

        repaintWindow(0)
end procedure

--/topic Attributes
--/proc alignControls(object ids, integer disttype, object pValue)
--/desc Set the edge position for a set of controls.
--/i ids is a sequence of ids to change /n
--/i disttype is one of, or a list of ... /n
--/li w32LeftEdge
--/li w32RightEdge
--/li w32TopEdge
--/li w32BottomEdge
--/li w32VertCentre
--/li w32HorzCentre
--/li w32LeftMost
--/li w32RightMost
--/li w32TopMost
--/li w32BottomMost
--
--/i pValue, if used with the ...Most options, is the minimum position. When
-- used with the other options it is the exact position to use.
--It can be a pixel value or an id value in a sequence.
--
--Example /n
--/code
--      -- Align them all to fld3's left edge.
--      alignControls({fld1,fld3,fld4,fld7}, w32LeftEdge, {fld3})
--
--      -- Move these up to whatever among them is the topmost fld.
--      alignControls({fld2,fld0,fld9,fld5}, w32TopMost, 0)
--
--      -- Center fld9 with respect to the screen
--      alignControls(fld9, {w32VertCentre,w32HorzCentre}, {Screen})
--/endcode

global procedure alignControls(object ids, object pAligntype, object pValue)

sequence lRect
integer lWidth, lHeight, lNewValue
integer aligntype
object lValue

        if atom(ids) then
            ids = {ids}
        end if
        if length(ids) = 0 then
            return
        end if
        if atom(pAligntype) then
            pAligntype = {pAligntype}
        end if

        lValue = pValue
        for k=1 to length(pAligntype) do
            aligntype = pAligntype[k]
            pValue = lValue
            if aligntype = w32LeftEdge then
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[1]
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    lWidth = lRect[3]-lRect[1]
                    lHeight = lRect[4]-lRect[2]
                    setRect(ids[i], pValue, lRect[2], lWidth, lHeight, 0)
                end for

            elsif aligntype = w32RightEdge then
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[3]
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    lWidth = lRect[3]-lRect[1]
                    lHeight = lRect[4]-lRect[2]
                    lNewValue = pValue-lWidth
                    setRect(ids[i], lNewValue, lRect[2], lWidth, lHeight, 0)
                end for

            elsif aligntype = w32TopEdge then
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[2]
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    lWidth = lRect[3]-lRect[1]
                    lHeight = lRect[4]-lRect[2]
                    setRect(ids[i], lRect[1], pValue, lWidth, lHeight, 0)
                end for

            elsif aligntype = w32BottomEdge then
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[4]
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    lWidth = lRect[3]-lRect[1]
                    lHeight = lRect[4]-lRect[2]
                    lNewValue = pValue-lHeight
                    setRect(ids[i], lRect[1], lNewValue, lWidth, lHeight, 0)
                end for

            elsif aligntype = w32VertCentre then
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[1]+floor((lRect[3]-lRect[1])/2)
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    lWidth = lRect[3]-lRect[1]
                    lHeight = lRect[4]-lRect[2]
                    lNewValue = pValue-floor(lWidth/2)
                    setRect(ids[i], lNewValue, lRect[2], lWidth, lHeight, 0)
                end for

            elsif aligntype = w32HorzCentre then
                if sequence(pValue) then
                    lRect = getRect(pValue[1])
                    pValue = lRect[2]+floor((lRect[4]-lRect[2])/2)
                end if
                for i=1 to length(ids) do
                    lRect = getRect(ids[i])
                    lWidth = lRect[3]-lRect[1]
                    lHeight = lRect[4]-lRect[2]
                    lNewValue = pValue-floor(lHeight/2)
                    setRect(ids[i], lRect[1], lNewValue, lWidth, lHeight, 0)
                end for

            elsif aligntype = w32Leftmost then
                lRect = getRect(ids[1])
                pValue = lRect[1]
                for i = 2 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue > lRect[1] then
                        pValue = lRect[1]
                    end if
                end for
                alignControls(ids, w32LeftEdge, pValue)

            elsif aligntype = w32Rightmost then
                lRect = getRect(ids[1])
                pValue = lRect[3]
                for i = 2 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue < lRect[3] then
                        pValue = lRect[3]
                    end if
                end for
                alignControls(ids, w32RightEdge, pValue)

            elsif aligntype = w32Topmost then
                lRect = getRect(ids[1])
                pValue = lRect[2]
                for i = 2 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue > lRect[2] then
                        pValue = lRect[2]
                    end if
                end for
                alignControls(ids, w32TopEdge, pValue)

            elsif aligntype = w32Bottommost then
                lRect = getRect(ids[1])
                pValue = lRect[4]
                for i = 2 to length(ids) do
                    lRect = getRect(ids[i])
                    if pValue < lRect[4] then
                        pValue = lRect[4]
                    end if
                end for
                alignControls(ids, w32BottomEdge, pValue)

            end if
        end for
        repaintWindow(0)
end procedure


-----------------------------------------------------------------------------
procedure pushModal(integer id, atom hWnd, integer style, integer depth)
    -- set window as modal

    -- Save any existing modal id
    modalStack = append(modalStack, {modalWindow, modalhWnd, modalStyle, modalDepth})

    -- set new modal window
    modalWindow = id
    modalhWnd = hWnd
    modalStyle = style
    modalDepth = depth

end procedure

-----------------------------------------------------------------------------
procedure popModal()
-- remove modal flag
-- if there was a prior modal window, unstack it
integer pending

        pending = length(modalStack)

        -- need to unstack?
        if pending > 0 then
            -- get previous modal window
            modalWindow = modalStack[pending][1]
            modalhWnd   = modalStack[pending][2]
            modalStyle  = modalStack[pending][3]
            modalDepth  = modalStack[pending][4]
            -- unstack
            modalStack = modalStack[1..pending-1]
        else
            warnErr("popModal: The Modal Window Stack is already empty.")
        end if

end procedure


-- NEW! 0.45
-----------------------------------------------------------------------------
--/topic Attributes
--/proc popup(popupMenu, x, y)
--/desc Display popupMenu at {/i x, /i y}.
--The coordinates /i x and /i y are relative to the parent window
--of the popup menu. If you are trapping the mouse position relative to
--some other control, you will need to pass both the id of the popup menu
--and the reference control for the coordiniates passed. This is done by
-- passing the first parameter as a 2-element sequence {popup, controlId}.
--
-- Example: Hard coded location relative to parent window.
--/code
--
--  -- create a popup for MyWindow
--  constant
--      MyPopup   = create(Popup, "", MyWindow, 0, 0, 0, 0, 0)
--
--  -- add four items into it
--  constant
--      Item1     = create(MenuItem, "Item 1", MyPopup, 0, 0, 0, 0, 0),
--      Item2     = create(MenuItem, "Item 2", MyPopup, 0, 0, 0, 0, 0),
--      Item3     = create(MenuItem, "Item 3", MyPopup, 0, 0, 0, 0, 0),
--      Item4     = create(MenuItem, "Item 4", MyPopup, 0, 0, 0, 0, 0)
--
--  -- popup the menu at {10,10} in MyWindow
--  popup(MyPopup, 10, 10)
--
--/endcode
--
-- Example: Location relative to some other control.
--/code
--    --------------------------------
--    procedure Mouse_TV(integer self, integer event, sequence parms)
--    --------------------------------
--        integer index
--
--        if parms[1] = WM_RBUTTONDOWN then
--            -- The coordinates are relative to self and
--            -- not the parent window.
--            popup({TVPopup, self}, parms[2], parms[3])
--        end if
--
--    end procedure
--
--/endcode


global procedure popup(object id, object x, object y)
integer parent
sequence pt, BBox
atom result
integer lPopupId
integer lRelId

    if atom(id) then
        lPopupId = id
        lRelId = 0
    else
        lPopupId = id[1]
        lRelId = id[2]
    end if

    if validId(lPopupId) = w32False
      or find(ctrl_Type[lPopupId],{Popup, Menu}) = 0
      or ((lRelId != 0) and (validId(lRelId) = w32False)) then
        return
    end if

    parent = findParentWindow(lPopupId)

    if lRelId != 0 and  parent != lRelId then
        -- Convert the mouse positions from Relative to the Treeview
        -- to relative to the screen.
        BBox = ClientToScreen(lRelId, x, y)

        -- Now convert them relative to the parent window.
        BBox = ScreenToClient(parent, BBox[1], BBox[2])
        -- <parent> was previously findParent(lRelId),probably incorrect
        x = BBox[1]
        y = BBox[2]

    end if

    -- get parent

    -- convert the point to a screen point
    pt = getClientPoint(parent, x, y)

    -- popup the menu
    result = w32Func(xTrackPopupMenu, {getHandle(lPopupId), -- menu
                                       0,                   -- flags
                                       pt[1], pt[2],        -- position
                                       0,                   -- reserved, must be 0
                                       getHandle(parent),   -- owner window
                                       0})                  -- pointer to rect
end procedure

-----------------------------------------------------------------------------
-- MOUSE
--
-----------------------------------------------------------------------------
--/topic Mouse
--/proc captureMouse(window)
--/desc Send all mouse events to /i window.
-- All mouse coordinates become relative to /i window. To release the mouse, use /releaseMouse.
--
-- Example:
--
--/code
--          -- grab the mouse for TheWindow
--          /captureMouse(TheWindow)
--/endcode


global procedure captureMouse(integer id)

    -- captures the mouse so all events are sent to that window

    -- capture the mouse
    if w32Func(xSetCapture, {getHandle(id)}) then
        warnErr("captureMouse:SetCapture failed.")
    end if

end procedure


-----------------------------------------------------------------------------
--/topic Mouse
--/proc releaseMouse()
--/desc Return control of the mouse to Windows.
-- This is called after /captureMouse to put control of the mouse
-- back to normal.
--
-- Example:
--
--/code
--          -- release the mouse.
--          /releaseMouse()
--/endcode

global procedure releaseMouse()
    -- release the mouse from a /captureMouse
    w32Proc(xReleaseCapture, {})
end procedure

-- NEW! 0.48e
-----------------------------------------------------------------------------
--/topic Attributes
--/func isScreenPointIn(control, x, y)
--/ret /b w32True if point {/i x, /i y} is within /i control.
--/desc Return /b w32True if the screen point {/i x, /i y} is within /i control.
-- This is used for hit testing, to determine if a point lies on a control.
--
-- Example:
--
--/code
--          -- check if screen point {10,10} lies in MyWindow
--          if /isScreenPointIn(MyWindow, 10, 10) then
--              -- point is in MyWindow
--          end if
--/endcode

global function isScreenPointIn(integer id, integer pX, integer pY)
sequence lScreenRect

        if not validId(id) then return w32False end if

        lScreenRect = getRect(id)
-- PL 29/4/09
--/**/  lScreenRect[3..4] = sq_sub(lScreenRect[3..4],lScreenRect[1..2])             --/* Pve
        lScreenRect[3..4] -= lScreenRect[1..2]                                      -- RDS */
        lScreenRect[1..2] = ClientToScreen(id, 0, 0)
-- PL 29/4/09
--/**/  lScreenRect[3..4] = sq_add(lScreenRect[3..4],sq_sub(lScreenRect[1..2],1))   --/* Pve
        lScreenRect[3..4] += lScreenRect[1..2]-1                                    -- RDS */


        if pX >= lScreenRect[3]
        or pX < lScreenRect[1]
        or pY >= lScreenRect[4]
        or pY < lScreenRect[2] then
            return w32False
        else
            return w32True
        end if
end function

-----------------------------------------------------------------------------
-- TIMERS
--
-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc setTimer(window, timer, ticks)
--/desc Start a timer ticking in /i window.
-- Timers are clocks that are maintained by Windows, and trigger events
-- at a user-specified interval, measured in milliseconds.
--
-- The arguments are:
-- /li /i window: /Window the timer belongs to.
-- /li /i timer: Unique ID assigned to the timer.
-- /li /i milliseconds: How much time, in milliseconds, that must pass
--              before triggering an /Timer event.
--
-- To respond to timer events, set a handler for the /w32HTimer event. You can have more
-- than one timer per /window. If your window is too busy to receive the
-- timer messages, they will be discarded.
--
-- Example:
--
--/code
--          -- start a timer with id #12 in MyWindow
--          -- it will trigger every 3 seconds.
--          /setTimer(MyWindow, 12, 3000)
--/endcode

global procedure setTimer(integer id, integer timerId, atom ticks)

    -- set a timer to go off every ticks milliseconds
    w32Proc(xSetTimer, {getHandle(id), timerId, ticks, 0})

end procedure

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc killTimer(window, timer)
--/desc Stop a timer.
-- This deactivates /i timer that was set with /setTimer.
--
-- Example:
--
--/code
--          -- deactivate timer #12
--          /killTimer(MyWindow, 12)
--/endcode

global procedure killTimer(integer id, integer timerId)

    -- remove timer from window
    w32Proc(xKillTimer, {getHandle(id), timerId})

end procedure

-----------------------------------------------------------------------------
-- CURSORS
--
-----------------------------------------------------------------------------

--/topic Mouse
--/proc setDragPointer(object style)
--/desc Sets the mouse pointer shape to use when dragging.
-- Win32lib supports four cursor shapes for dragging. /n
-- /i style can be either an atom (handle) or a sequence of four handles. If it is an
-- atom then set all four drag pointers to the same value. /n
-- The sequence represents these shapes: /n
--<ul>
--/li[1] - Used when no keys pressed
--/li[2] - Used when the shift key is pressed
--/li[3] - Used when the control key is pressed
--/li[4] - Used when the Alt key is pressed.
--</ul>
-- If /i style is a sequence, if any element is /b 0 then the current value
-- for this position is not changed.
--
-- Initially all shapes are set to the CrossPointer.
--
-- /i Handles can be either one of the predefined system shapes, one created by
-- /createMousePointer() or one returned by /loadCursor().
--
-- Example:
--
--/code
--      setDragPointer(IconPointer)
--
--      setDragPointer({IconPointer, -- set the 'normal' shape
--                       0  -- leave exsting 'Shift' shape alone
--                       loadCursor(mycursor), -- load 'Ctrl' shape from a file.
--                    })
--
--/endcode

global procedure setDragPointer(object style)
    if atom(style) then
        style = repeat(style, 4)
    end if

    for i=1 to length(style) do
        if i > 4 then
            exit
        end if
        if style[i] != 0 then
            vDragPointer[i] = style[i]
        end if
    end for

end procedure


procedure IndicateDragging(integer id, integer flag)
atom lPointerType

--/**/  if id then end if -- suppress warnings -- PL 29/4/09
        if flag then
            lPointerType = call_func(r_getKeyMasks,{0})
            if and_bits(lPointerType, ShiftMask) then
                lPointerType = 2
            elsif and_bits(lPointerType, ControlMask) then
                lPointerType = 3
            elsif and_bits(lPointerType, AltMask) then
                lPointerType = 4
            else
                lPointerType = 1
            end if
            -- Set the pointer shape for each possible control
            -- that can receive dragged data
            for i=1 to length(ctrl_Handlers) do
                if (   atom(ctrl_Handlers[i])
                    or atom(ctrl_Handlers[i][w32HDragAndDrop])
                    or length(ctrl_Handlers[i][w32HDragAndDrop]) > 0)
                and ctrl_Destroyed[i] = 0 then
                    setMousePointer(i, vDragPointer[lPointerType])
                end if
            end for
        else
            -- Restore the pointer shape for each possible control
            -- that can receive dragged data
            for i=1 to length(ctrl_Handlers) do
                if (   atom(ctrl_Handlers[i])
                    or atom(ctrl_Handlers[i][w32HDragAndDrop])
                    or length(ctrl_Handlers[i][w32HDragAndDrop]) > 0)
                and ctrl_Destroyed[i] = 0 then
                    restoreMousePointer(i)
                end if
            end for

        end if


end procedure




-- NEW! 0.45k
-----------------------------------------------------------------------------
--/topic Dialogs
--/func getColorDialog(window, default color)
--/desc "Get Color" Dialog
--/ret Selected color, or default color if nothing selected.
-- Calling this function brings up the modal "Select Color" dialog, allowing
-- the user to select a color from the default color list, or add a color to
-- the custom color list.
--
-- The parameter passed in /b default /b color is an atom representing the
-- default color to select, in #RRGGBB format. Passing -1 specifies that
-- the color black (#000000) is the default color.
--
--
-- Example:
--
--/code
--          -- get a color; red (#FF0000) is the default
--          atom color
--          color = getColorDialog(Window, #FF0000)
--/endcode


atom customColors
    customColors = w32acquire_mem(0, 64)

for i=0 to 63 do
    poke(customColors+i,#FF)
end for

global function getColorDialog(atom id, object defaultColor)
atom mem, result, color

    mem = w32to_memory(0,ID_COLORDLG,
                       {getHandle(id),0, colorValue(defaultColor), customColors, CC_RGBINIT})

    result = w32Func(xColorDlg, {mem})
    if result then
        color = w32fetch(mem, COLORDLG_rgbResult)
    else
        color = colorValue(defaultColor)
    end if

    w32release_mem(mem)

    return color

end function



--/topic Attributes
--/func setTabStops(integer id, object flds)
--/desc This possibly establishes the controls in a containing control that get tabbing focus.
--/ret SEQUENCE: The list of controls that used to be the tabbing controls.
--/i id is the Id of a control that contains other controls. Usually a Window,
-- Group, or TabItem. /n
-- The /i flds parameter specifies a list of control ids. The order of the ids
-- is the new order of tabbing. Any control that is /b not in this list is
-- ignored by the tabbing process.
--
-- Passing an atom in /i flds will only return the current tabbing order sequence.
--Example:
--/code
--      sequence OldFlds
--      OldFlds = setTabStops(MainWin, {CustName, CustAddr, Telephone,
--                                     OKBtn, CancelBtn})
--/endcode
global function setTabStops(integer id, object flds)
sequence lOldTabs

        if validId(id) = 0 then
            return {}
        end if
        lOldTabs = ctrl_Focus_order[id]

        if sequence(flds) then
            ctrl_Focus_order[id] = flds
        end if

        return lOldTabs
end function

--/topic Controls
--/proc tab_direction(integer id, integer direction)
--/desc Moves focus ahead or back to next available focus item
--/i id is the control that is your reference point. /n
--/i direction is the number of items to 'tab' over to. Negative values
-- move backward while postive values move forward.
--
--Example:
--/code
--      -- Tab forward to the next item that can take focus.
--      tab_direction(Fld1, 1)
--/endcode
global procedure tab_direction(integer id, integer direction)

    -- tabs ahead or back to next available focus item
    -- if nothing is found, doesn't focus on anything

integer parent, focus, at
sequence tabs


    -- is the id a window?
    if isTopLevelWindow(id) or find(ctrl_Type[id],{TabItem}) then
        -- parent is self
        parent = id

    elsif ctrl_Family[ctrl_Parent[id]] = COMBO then

        -- This is a subclassed control, so use the parent (combo) as reference.

        id = ctrl_Parent[id]
        parent = ctrl_Parent[id]

    else
        -- parent is container
        parent = ctrl_Parent[id]

    end if

    -- get the parent's list of tabstop controls
    tabs = ctrl_Focus_order[parent]
    id = ctrl_Current_focus[parent]

    -- get the index of the item with focus
    at = find(id, tabs)
    if at = 0 then
        at = 1
    end if

    -- look through all the tab stops
    for i=1 to length(tabs) do

        -- move in correct direction
        at += direction

        -- wrap?
        if at > length(tabs) then
            at = 1
        elsif at < 1 then
            at = length(tabs)
        end if

        -- get proposed focus
        focus = tabs[at]

        -- can it take focus?
        if validId(focus) then
            if isEnabled(focus) then
                if isVisible(focus) then

                    -- tab direction
                    if ctrl_Type[focus] = TabItem then
                        call_proc(r_setFocus,{focus})
                    else
                        w32Proc(xSetFocus, {getHandle(focus)})
                    end if
                    ctrl_Current_focus[parent] = focus
                    -- leave
                    return
                end if
            end if
        end if
        if direction = 0 then
            direction = 1
        end if

    end for

end procedure

-- NEW! 0.54.5
sequence vTabKeyCodes
vTabKeyCodes = {VK_TAB}

----------------------------------------------------------------------------
--/topic Controls
--/func setTabCodes(object newcodes)
--/desc Sets the list of tabbing keys to /i newcodes /n if it is valid.
--/ret The former value of that list, whether it changed or not.
--
-- Initially, the tabbing list is {VK_TAB}. You can supply a single key code or a
-- sequence of key codes. The list of valid key codes appears in the w32Keys.e file.
--
-- User defined tab keys behave like the default Tab. In particular, you may combine
-- them with the Shift key to request tabbing in reverse, or with the Control key inside
-- MleText or RichEdit controls.
--
-- If {} or a negative atom, the current value of the list is returned. If invalid key
-- codes are supplied, they will be ignored, since no key will match.
--
-- Avoid using VK_SHIFT, VK_CONTROL or VK_MENU as tab keys; the effects are undefined.
-- Also, some keys have a usual meaning when combined with Shift or Control, like the F4
-- key. You will probably confuse the user if using this sort of keys.
--
-- Example:
--       -- Allows the F8 key to act as Tab
--       VOID = setTabCodes({VK_TAB,VK_F8})
global function setTabCodes(object newcodes)

sequence oldcodes

        oldcodes = vTabKeyCodes

        if atom(newcodes)
        and newcodes >= 0 then
            vTabKeyCodes = {newcodes}
        elsif sequence(newcodes)
        and length(newcodes) > 0 then
            vTabKeyCodes = newcodes
        end if

        return oldcodes
end function

--/topic Edit controls
--/topic RichEdit controls
--/func setTabEnabled(integer id, integer flag)
--/desc Possibly sets the flag which says whether a (Rich)Edit control uses Ctrl-Tab for tabbing
-- between controls..
-- Pass 0 as /i flag to disable need for the Ctrl key, /w32GetValue to just get the flag value, or anything else to enable it.
-- For (Rich)Edit controls, the need for the Ctrl key is turned on by default, and
-- disabled for other controls.
--/ret The previous value of the flag, or -1 if the /i id was invalid.
global function setTabEnabled(integer id, integer flag)
integer oldflag

        if validId(id) then
            oldflag = ctrl_TabKey_Used[id]
            if flag != w32GetValue then
                ctrl_TabKey_Used[id] = w32iff(flag != 0, 1, 0)
            end if
        else
            oldflag = -1
        end if

        return oldflag

end function

----------------------------------------------------------------------------
function isTabKey(integer id, atom key)

    -- returns true if it's a tab key
    -- MleText requires the Ctrl key be pressed as well

atom result
integer tabdir

    -- key event and tab?

    tabdir = 0
    if find(key, vTabKeyCodes) then
        -- Is raw tab key allowed for this control?
        if ctrl_TabKey_Used[id] = w32False then
            -- only respond if CTRL key is pressed as well
            result = call_func(r_getKeyState,{VK_CONTROL})
            tabdir = w32iff(result != 0, 1, 0)
        else
            -- it's a tab
            tabdir = 1
        end if

        if tabdir != 0 then
             -- Check for shift key, to reverse tabbing direction.
            result = call_func(r_getKeyState,{VK_SHIFT})
            if result != 0 then
                tabdir = -tabdir
            end if
        end if
    end if

    return tabdir

end function

-- Rewritten CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: tab item visibility uses the same group visibility routine as showControlSet()
-- thys respecting individual visibility of controls.

procedure activateTabItems(integer id)
integer parent
integer old_focus

        parent = ctrl_Parent[id]
        old_focus = ctrl_Current_focus[parent]
        if old_focus != id then
            ctrl_Current_focus[parent] = id
            if old_focus then
                setControlVisible(ctrl_Group[old_focus],w32False)
            else
                for i=1 to length(ctrl_Specific[parent]) do
                    if ctrl_Specific[parent][i]!=id then
                        setControlVisible(ctrl_Group[ctrl_Specific[parent][i]],w32False)
                    end if
                end for
            end if
        end if
        setControlVisible(ctrl_Group[id],w32True)

end procedure
r_activateTabItems = routine_id("activateTabItems")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setFocus(id)
--/desc Set the focus to the specified window or control.
-- This will cause the window or control that currently has focus
-- to lose it.
--
-- The window or control losing focus will get an /LostFocus event,
-- and the window or control that is getting focus will get an /GotFocus
-- event.
--
-- Controls that are not visible or not enabled, will never receive focus. Neither will 
--  the controls whose ability to get focus was disabled using /canFocus().
-- If you try to, nothing will actually happen.

global procedure setFocus(object id)
-- set the focus
atom parent, item, hWnd, subitem

        if sequence(id) then
            item = id[2]
            id = id[1]
        else
            item = -1
        end if

        if not isEnabled(id) then return end if
        if not isVisible(id) then return end if

        if ctrl_Type[id] = TabItem then

            parent = ctrl_Parent[id]
            item = find(id, ctrl_Specific[parent])-1
            VOID = sendMessage(parent, TCM_SETCURSEL, item, 0)
            activateTabItems(id)
            return
        end if

        focus_current = id

        hWnd = getHandle(id)
        w32Proc(xSetFocus, {hWnd})

        if item > 0 then
            if ctrl_Type[id] = TreeView then
                subitem = tvitem_handle[item]
                VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, subitem})
                VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, subitem})

            elsif ctrl_Type[id] = ListView then
                subitem = item-1
                VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, subitem,0})
                VOID = w32Func(xSendMessage, {hWnd, LVM_ENSUREVISIBLE, subitem,0})
                setLVItem(id, LVIF_STATE, item, 0, or_bits(LVIS_SELECTED,LVIS_FOCUSED),
                          or_bits(LVIS_SELECTED,LVIS_FOCUSED), 0, 0, 0)

            end if
        end if
end procedure
r_setFocus = routine_id("setFocus")

--/topic Attributes
--/func getFocus()
--/desc Gets the id of the control that has focus.
--/ret INTEGER: The id of the control that has focus.
global function getFocus()
    return getId(w32Func(xGetFocus, {}))
end function


-----------------------------------------------------------------------------
-- NEW! 0.45a
-- Allow user to select tooltip font
--integer
--  hintFontSize,
--  hintFontAttrib
--sequence
--  hintFontName
--
--
---- set defaults
--  hintFontName   = "MS Sans Serif"
--  hintFontSize   = 8
--  hintFontAttrib = Normal


-- NEW! 0.45a
-----------------------------------------------------------------------------
--/topic Fonts
--/proc setHintFont(font, point size, attributes)
--/desc Set font type and size for the control's hints.
--
-- Default values are {"MS Sans Serif", 8 points, Normal}.
--
-- Example:
--
--/code
--   /setHintFont("Times New Roman", 10, /Bold)
--/endcode
-- You can also call /setFont(/i tooltipControl)

global procedure setHintFont(sequence w32FontName, integer points, integer attrib)

    setFont(tooltipControl, w32FontName, points, attrib)

end procedure


-- NEW! 0.45b

-----------------------------------------------------------------------------
--/topic Mouse
--/func getPointerRelPos(integer id)
--/desc Retrieves relative position of the mouse.
--/ret SEQUENCE: Mouse {x,y} position, relative to the control specified by /i id.
--
-- Example:
--
--/code
-- sequence pos
--
--  pos = getPointerRelPos(myWindow)
--  if pos[1] > 200 then
--      -- code goes here...
--  end if
--/endcode

global function getPointerRelPos(integer pId)

    if validId(pId) then
-- PL 29/4/09
--/**/  return sq_sub(getPointerPos(),ClientToScreen(pId, 0, 0))    --/*
        return getPointerPos() - ClientToScreen(pId, 0, 0)          --*/
    else
        return {0,0}
    end if

end function
r_getPointerRelPos =  routine_id("getPointerRelPos")

-- Changed CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: When a control set becomes visible, controls made manually invisible would display again

--/topic Controls
--/proc showControlSet(integer id)
--/desc Makes visible all the controls in the identified set, and hides the previously shown set.
--
--/i id is the id of a ControlSet created by /setControlSet
--
--Example:
--/code
--      sequence FuncGroup
--      sequence TriggerGroup
--      constant CustomerGrp=1, OrderGrp=2, InventGrp=5, AdminGrp=7
--
--      setControlSet(CustomerGrp, w32True, {Fld1, Fld2, Fld3})
--      setControlSet(OrderGrp, w32True, {Fld11, Fld12, Fld13, Fld14})
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(AdminGrp, w32True, {Fld31, Fld32, Fld33})
--      TriggerGroup = {Btn1,        Btn2,     Btn3,      Btn4}
--      FuncGroup    = {CustomerGrp, OrderGrp, InventGrp, AdminGrp}
--
--      procedure Click_Buttons(integer self, integer event, sequence parms)
--          showControlSet(FuncGroup[find(self, TriggerGroup)])
--      end procedure
--      setHandler(TriggerGroup, w32HClick, routine_id("Click_Buttons"))
--/endcode
integer r_hideControlSet
global procedure showControlSet(integer id)
    if not equal(id, vCurrentControlSet)
    and id > 0 and id <= length(vControlSets) then
        setControlVisible(vControlSets[id], w32True)
        if integer(vCurrentControlSet) then
            call_proc(r_hideControlSet,{vCurrentControlSet})
        end if
        vCurrentControlSet = id
    end if
end procedure

--/topic Controls
--/proc hideControlSet(object set)
--/desc Hides all the controls in the identified set(s).
--/i set is either a single ControlSet id, or a list of ControlSet ids.
--
--If /i set is zero, then all known ControlSets are hidden.
--
--Example:
--/code
--      -- Hide all sets
--      hideControlSet(0)
--      -- Hide one set
--      hideControlSet(2)
--      -- Hide a few sets
--      hideControlSets({1,3,2,5})
--/endcode

global procedure hideControlSet(object id)
    if atom(id) then
        if id = 0 then
            for i=1 to length(vControlSets) do
                setControlVisible(vControlSets[i], w32False)
            end for
            return
        else
            id = {id}
        end if
    end if
    for i=1 to length(id) do
        if id[i] > 0 and id[i] <= length(vControlSets) then
            setControlVisible(vControlSets[id[i]], w32False)
        end if
    end for

end procedure
r_hideControlSet=routine_id("hideControlSet")

--/topic Controls
--/proc enableControlSet(integer id)
--/desc Enables all the controls in the identified set, and disables the previously enabled set.
--
--/i id is the id of a ControlSet created by /setControlSet
--
--Example:
--/code
--      sequence FuncGroup
--      sequence TriggerGroup
--      constant CustomerGrp=1, OrderGrp=2, InventGrp=5, AdminGrp=7
--
--      setControlSet(CustomerGrp, w32True, {Fld1, Fld2, Fld3})
--      setControlSet(OrderGrp, w32True, {Fld11, Fld12, Fld13, Fld14})
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(AdminGrp, w32True, {Fld31, Fld32, Fld33})
--      TriggerGroup = {Btn1,        Btn2,     Btn3,      Btn4}
--      FuncGroup    = {CustomerGrp, OrderGrp, InventGrp, AdminGrp}
--
--      procedure Click_Buttons(integer self, integer event, sequence parms)
--          enableControlSet(FuncGroup[find(self, TriggerGroup)])
--      end procedure
--      setHandler(TriggerGroup, w32HClick, routine_id("Click_Buttons"))
--/endcode
global procedure enableControlSet(integer id)
    if not equal(id, vCurrentControlSet)
    and id > 0 and id <= length(vControlSets) then
        setEnable(vControlSets[id], w32True)
        if integer(vCurrentControlSet) then
            setEnable(vControlSets[vCurrentControlSet], w32False)
        end if
        vCurrentControlSet = id
    end if
end procedure

--/topic Controls
--/proc disableControlSet(object set)
--/desc Disables all the controls in the identified set(s).
--/i set is either a single ControlSet id, or a list of ControlSet ids.
--
--If /i set is zero, then all known ControlSets are disabled.
--
--Example:
--/code
--      -- Disable all sets
--      disableControlSet(0)
--      -- Disable one set
--      disableControlSet(2)
--      -- Disable a few sets
--      disableControlSets({1,3,2,5})
--/endcode

global procedure disableControlSet(object id)
    if atom(id) then
        if id = 0 then
            for i=1 to length(vControlSets) do
                setEnable(vControlSets[i], w32False)
            end for
            id = {}
        else
            id = {id}
        end if
    end if

    for i=1 to length(id) do
        if id[i] > 0 and id[i] <= length(vControlSets) then
            setEnable(vControlSets[id[i]], w32False)
        end if
    end for
end procedure

--/topic Controls
--/proc setControlSet(integer Set, integer Add, object id)
--/desc Create and maintains the entries in a control set.
--ControlSets are used to easily manipulate a set of related controls.
--
--/i Set is the id of the control set. If it doesn't exist, it is created. /n
--/i Add is a True/False flag. If w32True then the /id is added to the set,
-- otherwise it is removed from the set. /n
--/i id is either a single control id or a list of control ids.
--
-- If any control set exists at the time WinMain() is called, all control sets other
-- than the first are hidden and the one with index 1 is shown. You may choose to start
-- indexing at 2.
--
--Example:
--/code
--      -- Add some controls to a set.
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(InventGrp, w32True, {Fld23, Fld25})
--      -- The control set 'InventGrp' now has 4 ids in it.
--      -- Remove one.
--      setControlSet(InventGrp, Fld22)
--      -- The control set 'InventGrp' now has 3 ids in it.
--/endcode
--
--See also: /showControlSet, /hideControlSet, /enableControlSet, /disableControlSet

global procedure setControlSet(integer pSet, integer pAdd, object id)

        if pSet <= 0 then
            return
        end if
        if pSet > length(vControlSets) then
            vControlSets &= repeat({}, pSet-length(vControlSets))
        end if

        if not sequence(id) then
            id = {id}
        end if

        if pAdd = w32True then
            for i=1 to length(id) do
                if not find(id[i], vControlSets[pSet]) then
                    vControlSets[pSet] &= id[i]
                end if
            end for
        else
            for i=1 to length(id) do
                vControlSets[pSet] = w32removeItem(id[i], vControlSets[pSet])
            end for
        end if

end procedure
r_setControlSet = routine_id("setControlSet")

--/topic TreeView Control
--/func hitTestTV(id)
--/desc Check to see if mouse is over a /TreeView item
--/ret Index of /TreeView item under mouse, or zero, if none
global function hitTestTV(integer id)
atom ht, iItem, flags
sequence pt

        pt = getPointerRelPos(id)

        -- need to calculate offset due to control position
        ht = w32to_memory(0,ID_TVHITTESTINFO, {pt[1], pt[2], 0, 0})

        iItem = sendMessage(id, TVM_HITTEST, getHandle(id), ht)

        flags = w32fetch(ht, TVHITTESTINFO_flags)

        if and_bits(flags, TVHT_ONITEM) then
            iItem = find(iItem, tvitem_handle)
        else
            iItem = 0
        end if

        w32release_mem(ht)

        return iItem
end function


-- Begin Tone Skoda --
--[Created on 6. June 2002, 14:23]

--/topic TreeView Control
--/func expandTV(object TVID, object ItemID, integer Action)
--/desc Expands or Collapses all child tree items.
--/ret INTEGER: The inverse of /i pAction
-- /i TVID is the id of a TreeView control /n
-- /i ItemID is the id of a TreeView item as returned by /addTVItem /n
-- /i Action is either TVE_EXPAND or TVE_COLLAPSE. The default is TVE_EXPAND. /n
-- This routine expands or collapses all the items, starting with /i ItemId, and
-- continuing down the hierarchy. /n
-- /b Returning the opposite of /i Action. Thus if /i Action was /b TVE_EXPAND then
-- this would return /b TVE_COLLAPSE, and visa versa.
--
--Example:  /i<See demo /b<ListTreeView.exw>>
--/code
--      integer nextAction
--      nextAction = TVE_EXPAND
--      nextAction = expandTV(myTV, rootItem, nextAction)
--/endcode
constant tvActions = {TVE_EXPAND, TVE_COLLAPSE}
function Internal_expandTV(object treewnd, object item_handle, integer pAction, integer pLock)
atom hChild
atom hTV

        if sequence(treewnd) then
            hTV = treewnd[1]
        else
            hTV = getHandle(treewnd)
        end if

        if sequence(item_handle) then
            item_handle = item_handle[1]
        elsif item_handle then
            item_handle = tvitem_handle[item_handle]
        end if

        if not find(pAction, tvActions) then
            pAction = TVE_EXPAND
        end if

        if pLock = w32True then
            VOID = w32Func(xLockWindowUpdate, {hTV})
        end if

        VOID = w32Func(xSendMessage,{hTV, TVM_EXPAND, pAction, item_handle})
        hChild = w32Func(xSendMessage,{hTV, TVM_GETNEXTITEM, TVGN_CHILD, item_handle})
        while hChild do
            VOID = Internal_expandTV({hTV}, {hChild}, pAction, w32False)
            hChild = w32Func(xSendMessage,{hTV, TVM_GETNEXTITEM, TVGN_NEXT, hChild})
        end while
        if pLock = w32True then
            VOID = w32Func(xLockWindowUpdate,{0})
        end if
        return tvActions[w32iff(find(pAction, tvActions)=1,2,1)]
end function
global function expandTV(object treewnd, object item_handle, integer pAction)
    return Internal_expandTV(treewnd, item_handle, pAction, w32True)
end function

-- End Tone Skoda

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getLEDs()
--/desc Returns or'ed flags representing the state of the keyboard LEDs.
--/ret INTEGER: A sum of zero or more LED flags.
-- Known flags are:
--/li NumLockFlag
--/li CapsLockFlag
--/li ScrollLockFlag

global constant NumLockFlag=1, CapsLockFlag=2, ScrollLockFlag=4

global function getLEDs()
integer result
        result = and_bits(w32Func(xGetKeyState,{VK_NUMLOCK}),1)* NumLockFlag
        if and_bits(w32Func(xGetKeyState,{VK_CAPITAL}),1) then
            result += CapsLockFlag
        end if
        if and_bits(w32Func(xGetKeyState,{VK_SCROLL}),1) then
            result += ScrollLockFlag
        end if
        return result
end function

--/topic System Attributes
--/func getKeyState(atom key)
--/desc Gets the depressed stats of the /i key.
--/ret INTEGER: w32True if the /i key is pressed otherwise w32False
--
--Example:
--/code
--      if getKeyState(VK_NUMPAD0) then
--          cmd = kStop
--      elsif getKeyState(VK_NUMPAD2) then
--          cmd = kDown
--      elsif getKeyState(VK_NUMPAD4) then
--          cmd = kLeft
--      elsif getKeyState(VK_NUMPAD6) then
--          cmd = kRight
--      elsif getKeyState(VK_NUMPAD8) then
--          cmd = kUp
--      else
--          cmd = 0
--      end if
--      processCmd(cmd)
--/endcode

global function getKeyState(atom key)
-- return the state Shift, Control, or Menu keys
atom result

        -- get key
        result = w32Func(xGetKeyState, {key})

        -- check the high bit. (low bit is toggle state)
        return (floor(result / 2) != 0)

end function
r_getKeyState = routine_id("getKeyState")

integer shifts shifts = 0

-----------------------------------------------------------------------------
function getKeyMasks(atom wParam)
-- return the state Shift, Control, and Menu keys
integer flags

        -- report keyboard shifts
        flags = shifts

        if and_bits(wParam, LEFT_BUTTON) then
            flags += LeftBtnMask
        end if

        if and_bits(wParam, RIGHT_BUTTON) then
            flags += RightBtnMask
        end if

        if and_bits(wParam, MIDDLE_BUTTON) then
            flags += MiddleBtnMask
        end if

        return flags

end function
r_getKeyMasks = routine_id("getKeyMasks")



-----------------------------------------------------------------------------

procedure resizeWidgets(integer id, integer cx, integer cy)
-- this is called when a window has been resized.
integer lMoveId, lRepaint

--/**/  if cx or cy then end if -- suppress warnings -- PL 29/4/09
        -- Special handling for rebars.
        for i=1 to length(ctrl_Init_Posns[id][1]) do
            lMoveId = ctrl_Init_Posns[id][1][i]
            lRepaint = w32iff(ctrl_Type[lMoveId] = Window,1,0)
            setRect(lMoveId,
                    ctrl_Init_Posns[id][2][i][1],
                    ctrl_Init_Posns[id][2][i][2],
                    ctrl_Init_Posns[id][2][i][3],
                    ctrl_Init_Posns[id][2][i][4], lRepaint)
        end for

end procedure


integer vSkipF10 vSkipF10 = w32False

--/topic Menus
--/func skipF10(integer NewValue)
--/desc Possibly sets whether or not F10 sets focus on the menubar
--/ret Returns INTEGER: The current value of the flag.
--By default, the F10 key sets focus on the menubar. If /i NewValue
-- is w32True, then the behaviour is changed so that the F10 key does not
-- set focus on the menubar. Passing /w32GetValue will just return the current value of the flag.
--
--Example:
--/code
--      integer PrevF10Flag
--      PrevF10Flag = skipF10(w32True)
--/endcode

-----------------------------------------------------------------------------
global function skipF10(integer pNewValue)
-----------------------------------------------------------------------------
integer lOldValue

        lOldValue = vSkipF10
        if pNewValue != w32GetValue then
            vSkipF10 = (pNewValue != 0)
        end if
        return lOldValue

end function

-----------------------------------------------------------------------------
function isHotKey(integer id, atom hWnd, atom event, atom key, atom lParam, atom pReturn)
-----------------------------------------------------------------------------

integer window, focus, i
--integer parent, j -- PL 29/4/09
sequence hotkeys, hotids

--/**/  if hWnd or lParam or pReturn then end if -- suppress warnings -- PL 29/4/09

    -- if there is a control in the hotkey list associated with the
    -- toplevel parent window, set focus to that control and return
    -- true.
    --
    -- note that some controls (like TabControl) can have several items
    -- with the same hotkey, since only one group of controls are enabled
    -- at a time.

    -- find the top level window

    window = findParentWindow(id)
    if window = 0 then
        return {kSubclassedMsg} -- control is not in a window!
    end if

    -- get the hotkey list
    hotkeys = upper(ctrl_Hotkey_Keys[window]) & lower(ctrl_Hotkey_Keys[window])
    hotids  = ctrl_Hotkey_Ids[window] & ctrl_Hotkey_Ids[window]
    -- any controls with same parent have this hotkey?
    while 1 do
        i = find(key, hotkeys)
        if i = 0 then
            exit
        end if

        -- get item with hotkey
        focus = hotids[i]

        -- is the control enabled and visible?
-- PL 29/4/09:
        if isEnabled(focus) then
            if isVisible(focus) then
                -- change focus
                if ctrl_Type[focus] = TabItem then
                    setFocus(focus)
                else
                    w32Proc(xSetFocus, {getHandle(focus)})
                end if
                if event=WM_KEYDOWN
                or event=WM_SYSCHAR then
                    if ctrl_Family[focus] = BUTTON then
                        VOID = sendMessage(focus, BM_CLICK, 0, 0)
                    elsif ctrl_Type[focus] = Window then
                        VOID = sendMessage(focus, WM_LBUTTONDOWN, 0, 0)
                        VOID = sendMessage(focus, WM_LBUTTONUP, 0, 0)
                    end if
                end if

                -- return true; hotkey handled
                return {kMainMsg,-1}
            end if
        end if
        hotkeys = hotkeys[i+1..length(hotkeys)]
        hotids  = hotids[i+1..length(hotids)]
    end while

    -- hotkey not handled
    return {kSubclassedMsg}
end function

constant kMsgCommandCode = {
                            {BUTTON,BN_CLICKED},     -- Button click
                            {STATIC,STN_CLICKED},    -- Label(static) click
                            {LISTBOX,LBN_SELCHANGE}, -- combo/list box selection change
                            {EDIT,EN_CHANGE},        -- editbox notify change
                            {COMBO,CBN_EDITCHANGE},  -- combo notify change has occured
                            {COMBO,CBN_SELCHANGE},   -- combo/list box notify change
                            {COMBO,CBN_DROPDOWN},    -- The combobox is about to dropdown.
                            {COMBO,CBN_CLOSEUP}      -- The combobox dropdown has just been closed
                           }

constant kW32EventCode = {
                          {w32HClick,   0},  -- Button
                          {w32HClick,   0},  -- Label Click
                          {w32HChange,  w32CHG_Sel},     -- list box notify change
                          {w32HChange,  w32CHG_Chg},     -- editbox notify change
                          {w32HChange,  w32CHG_Chg},     -- combo data changed
                          {w32HChange,  w32CHG_Sel},     -- combo selection changed
                          {w32HDropDown,0}, -- combo is about to dropdown.
                          {w32HCloseUp, 0}   -- combo dropdown has just been closed
                         }

-----------------------------------------------------------------------------
procedure wmCommand(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
-- this handles notification (WM_COMMAND) messages
-- this is used by WINDOW and TabControls.
integer event, w32event
integer lPos
sequence parms
object lExtra
sequence lObjEvent

--/**/  if hWnd or iMsg or lParam then end if -- suppress warnings -- PL 29/4/09

        -- determine which window sent the message
        -- update with new id

        if ctrl_Type[id] = FlatToolBar then
            id = w32lo_word(wParam)
        end if

        -- clear parms

        parms = {}
        lExtra = {}
        event = w32hi_word(wParam)

        lObjEvent = {ctrl_Family[id],event}
        lPos = find(lObjEvent, kMsgCommandCode)
        if lPos != 0 then
            lExtra &= kW32EventCode[lPos][2]
            w32event = kW32EventCode[lPos][1]
            -- Special handling for Radio buttons that get focus via tabbing.
            if w32event=w32HClick and ctrl_Type[id]=Radio then
                if sendMessage(id,BM_GETCHECK,0,0)=0 then return end if
            end if
            -- Special handling for COMBO and LISTBOX
            if lObjEvent[1] = COMBO then
                lExtra &= sendMessage(id, CB_GETCURSEL, 0, 0)+1
            elsif lObjEvent[1] = LISTBOX then
                lExtra &= sendMessage(id, LB_GETCURSEL, 0, 0)+1
            end if
            VOID  = invokeHandler(id, w32event, lExtra)
        end if

end procedure

--/topic ListView control
--/proc setLVStyle(integer ID, object StyleFlags)
--/desc Sets the extended style flags on a listview
--
--/i StyleFlags can either be an atom containing all then
-- flag bits set to a sequence of flag names. The valid names are... \n
--/li LVS_EX_GRIDLINES
--/li LVS_EX_SUBITEMIMAGES
--/li LVS_EX_CHECKBOXES
--/li LVS_EX_TRACKSELECT
--/li LVS_EX_HEADERDRAGDROP
--/li LVS_EX_FULLROWSELECT
--/li LVS_EX_ONECLICKACTIVATE
--/li LVS_EX_TWOCLICKACTIVATE
--/li LVS_EX_FLATSB
--/li LVS_EX_REGIONAL
--/li LVS_EX_NFOTIP
--/li LVS_EX_UNDERLINEHOT
--/li LVS_EX_UNDERLINECOLD
--/li LVS_EX_MULTIWORKAREAS
--
--Example
--/code
--      setLVStyle(myListView, {LVS_EX_FULLROWSELECT,
--                              LVS_EX_GRIDLINES,
--                              LVS_EX_HEADERDRAGDROP})
--/endcode
global procedure setLVStyle(integer pId, object pStyleFlags)
atom lMask

        if sequence(pStyleFlags) then
            lMask = w32or_all(pStyleFlags)
        else
            lMask = pStyleFlags
        end if

        VOID = sendMessage(pId, LVM_SETEXTENDEDLISTVIEWSTYLE, lMask, lMask)
end procedure
r_setLVStyle = routine_id("setLVStyle")

--/topic ListView control
--/func setLVAttr(integer id, sequence pNewData)
--/desc Set (some) attributes of a ListView control
--/ret SEQUENCE: The current attributes.
-- /i id is the ListView's id /n
-- /i pNewData is a list of two-element sequences. The first
-- element is the code name for the attribute being changed,
-- and the second is the new value for it.
--
--<ul>
--/li /i kLVColTypes The data types per column for sorting. /n
-- The data is a sequence, one element per column. /n
-- The values can be one of: /n
--<ul>
--/li 'i' = Case Insensitive sorting
--/li 'n' = Numeric Sorting
--/li 'a' = Case sensitive
--</ul>
--/li /i kLVSortSeq The sorting direction, per column, to use. /n
-- The values for the kLVSortSeq attribute can be: /n
--<ul>
--/li -2 = swaps between ascending and descending for each column click.
--/li -1 = descending
--/li  1 = ascending
--/li  2 = swaps between descending and ascending for each column click.
--</ul>
--/li /i kLVSortRtn The routine_id, per column, of the user-defined sorting routine.
-- If any column value is set to -2, then the default routine is used. If set
-- to -1 then no sorting is done on that column.
--
-- When a user clicks on a column heading on a listview, Win32lib tries to sort
-- the ListView based on the contents of the row data. You are able to specify
-- your own sorting method if the built-in ones are not sufficient.
--
-- The user-defined sorting routine is called whenever Windows needs to know which
-- of two items goes before, goes after, or are equivalent. The exact number of times
-- that this is called depends on the number of items in the listview, however you can
-- expect it to be called many times for each sort request.
--
-- The user-defined routine is passed four parameters: /n
--/code
--    integer ID    -- The control id of the listview
--    integer ItemA -- The row number of one of the items to compare
--    integer ItemB -- The row number of the other item to compare
--    integer Column-- The column number that was clicked on.
--/endcode
--
-- The user-defined routine is also called just before the sorting starts and just
-- after it finishes. In these cases, ItemA and ItemB are both -1 and the Column
-- value is either w32LV_StartSorting or w32LV_EndSorting, respectively. /n
-- When called at the start of sorting, your routine is expected to return w32True
-- if the sort can commence, otherwise the sort request is rejected.
--
-- /b Note that the cursor is changed to the 'hourglass' shape during the sorting
-- process.
--</ul>
--
--Example:
--/code
--    sequence ov
--    -- Indicate that col 1 is case-insensitive, and col 2 is numeric.
--    -- Indicate that col 1 swaps directions, and col 2 is always ascending.
--    ov = setLVAttr(myLV, {{kLVColTypes, {'i','n'}},
--                           {kLVSortSeq, {-2, 1}},
--                           {kLVSortRtn, {-2, routine_id("lvsort")}}
--                       })
--/endcode
global function setLVAttr(integer id, sequence pNewData)
sequence lOldData
integer lv

        lv = find(id, lv_id)
        if lv = 0 then
            return {}
        end if

        lOldData = lv_properties[lv]

        for i=1 to length(pNewData) do
            if pNewData[i][1] = kLVColTypes then
                lv_properties[lv][kLVColTypes] = pNewData[i][2]

            elsif pNewData[i][1] = kLVSortSeq then
                lv_properties[lv][kLVSortSeq] = pNewData[i][2]

            elsif pNewData[i][1] = kLVSortRtn then
                lv_properties[lv][kLVSortRtn] = pNewData[i][2]
                if sequence(lv_properties[lv][kLVSortRtn]) then
                    for j=1 to length(lv_properties[lv][kLVSortRtn]) do
                        if lv_properties[lv][kLVSortRtn][j] = -2 then
                            lv_properties[lv][kLVSortRtn][j] = r_lvSortitems
                        end if
                    end for
                else
                    if lv_properties[lv][kLVSortRtn] = -2 then
                        lv_properties[lv][kLVSortRtn] = r_lvSortitems
                    end if
                end if
            end if
        end for

        return lOldData
end function


function lvSortitems(integer id, integer lItem1, integer lItem2, integer column)
object text1, text2, textnum
sequence lProps

        lProps = lv_properties[find(id, lv_id)]
        text1 = getLVItemText(id, lItem1, column)
        if sequence(lProps[kLVColTypes]) and length(lProps[kLVColTypes]) >= column then
            if equal(lProps[kLVColTypes][column], 'i') then
                text1 = upper(text1)
            elsif equal(lProps[kLVColTypes][column], 'n') then
                textnum =  w32TextToNumber({text1, w32True})
                if textnum[2] = 0 then
                    text1 = textnum[1]
                end if
            end if
        end if

        text2 = getLVItemText(id, lItem2, column)
        if sequence(lProps[kLVColTypes]) and length(lProps[kLVColTypes]) >= column then
            if equal(lProps[kLVColTypes][column], 'i') then
                text2 = upper(text2)
            elsif equal(lProps[kLVColTypes][column], 'n') then
                textnum =  w32TextToNumber({text2, w32True})
                if textnum[2] = 0 then
                    text2 = textnum[1]
                end if
            end if
        end if

        return compare(text1, text2)

end function
r_lvSortitems = routine_id("lvSortitems")

function PrepareLVSort(atom lParam1, atom lParam2, atom id)
integer lItem1, lItem2
integer rtn, column
atom LV_FINDINFO
integer sign
sequence lProps

        -- Allow something else to happen too.
        call_proc(r_doEvents,{0})

        lProps = lv_properties[find(id, lv_id)]
        column = lProps[kLVSortCol]

        rtn = r_lvSortitems
        if sequence(lProps[kLVSortRtn]) then
            if length(lProps[kLVSortRtn]) >= column then
                rtn = lProps[kLVSortRtn][column]
            end if
        end if

        if rtn = -1 then
            -- No sorting done.
            return 0
        end if

        LV_FINDINFO = w32to_memory(0,ID_LVFINDINFO, {LVFI_PARAM, "", lParam1, 0, 0, 0})
        lItem1 = sendMessage(id, LVM_FINDITEM, -1, LV_FINDINFO)+1

        w32store(LV_FINDINFO, LVFINDINFO_lParam, lParam2)
        lItem2 = sendMessage(id, LVM_FINDITEM, -1, LV_FINDINFO)+1

        w32release_mem(LV_FINDINFO)

        if lItem1 = 0 or lItem2 = 0 then
            -- Nothing to sort.
            return 0
        end if

        sign = 1
        if sequence(lProps[kLVSortSeq]) then
            if length(lProps[kLVSortSeq]) >= column then
                if lProps[kLVSortSeq][column] < 0 then
                    sign = -1
                end if
            end if
        else
            if lProps[kLVSortSeq] < 0 then
                sign = -1
            end if
        end if

        return sign * call_func(rtn,{id, lItem1, lItem2, column})

end function

atom pfnCompare
pfnCompare = call_back(routine_id("PrepareLVSort"))


--/topic ListView control
--/proc loadLVInfo(integer id, sequence pNewData)
--/desc Used to bulk load data into a list view control
-- /i id is the ID of the /ListView control /n
-- /i pNewData is a list of row data and optional image ids.
-- Each element is either a list of column data or an image id
-- as returned from /addIcon(). An image id applies to all
-- the row data that follows until the next image id.
--
--Example:
--/code
--      sequence theData
--      integer iconMale, iconFemale
--      iconMale = addIcon(loadBitmapFromFile("male.ico"))
--      iconFemale = addIcon(loadBitmapFromFile("female.ico"))
--      theData = {}
--      theData &= iconMale
--      theData = append(theData, {"George", 95.4, "Judo"})
--      theData = append(theData, {"Harry", 97.2, "Karate"})
--      theData &= iconFemale
--      theData = append(theData, {"Wendy", 65.1, "Kendo"})
--      theData = append(theData, {"Jill", 75.8, "Ice Hockey"})
--      theData &= iconMale
--      theData = append(theData, {"Horatio", 105.1, "Chess"})
--      theData = append(theData, {"Felix", 87.0, "Butterflies"})
--      loadLVInfo(myLV, theData)
--/endcode
global procedure loadLVInfo(atom id, sequence alldata)
atom hWnd
atom LV_ITEM
object data
integer msg
integer lImageIdx
atom lNewRow

        hWnd = getHandle(id)
        VOID = w32Func(xSendMessage, {hWnd, LVM_DELETEALLITEMS, 0, 0})
        LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM)
        lImageIdx = -1
        for i=1 to length(alldata) do
            data = alldata[i]
            if sequence(data) then
                w32store(LV_ITEM, LVITEM_iItem, i-1)
                w32store(LV_ITEM, LVITEM_lParam, vNextLVItemID+i)
                w32store(LV_ITEM, LVITEM_iImage, lImageIdx)

                for j=1 to length(data) do
                    w32store(LV_ITEM, LVITEM_iSubItem, j-1)
                    if not sequence(data[j]) then
                        data[j] = sprintf("%g", data[j])
                    end if

                    w32store(LV_ITEM, LVITEM_pszText, data[j])
                    if j = 1 then
                        msg = LVM_INSERTITEM
                        w32store(LV_ITEM, LVITEM_mask, w32or_all({LVIF_TEXT,LVIF_IMAGE,LVIF_PARAM}))
                        lNewRow = w32Func(xSendMessage, {hWnd, msg, i-1, LV_ITEM})
                    else
                        msg = LVM_SETITEMTEXT
                        w32store(LV_ITEM, LVITEM_mask, LVIF_TEXT)
                        VOID = w32Func(xSendMessage, {hWnd, msg, lNewRow, LV_ITEM})
                    end if
                end for
            else
                if ctrl_Menu[id]=hILsmall then
                    lImageIdx = data-1
                else
                    lImageIdx=w32Func(ImageList_AddIcon,{ctrl_Menu[id],ilicon_list[data]})
                    VOID=w32Func(ImageList_AddIcon,{ctrl_Previous_focus[id],ilicon_list[data]})
                end if
            end if
        end for

        w32release_mem(LV_ITEM)
        vNextLVItemID += getLVCount(id)
end procedure

--/topic ListView Control
--/func hitTestLV(id)
--/desc Check to see if mouse is over a /ListView item
--/ret {item,subitem} pair of /ListView item under mouse, or {}, if none
global function hitTestLV(integer id)
atom ht,  flags
sequence pt
sequence lItem

        pt = getPointerRelPos(id)

        -- need to calculate offset due to control position
        ht = w32acquire_mem(0, SIZEOF_LVHITTESTINFO)
        w32store(ht, LVHITTESTINFO_ptX, pt[1])
        w32store(ht, LVHITTESTINFO_ptY, pt[2])

        VOID = sendMessage(id, LVM_HITTEST, 0, ht)

        flags = w32fetch(ht, LVHITTESTINFO_flags)

        if and_bits(flags, LVHT_ONITEM) then
            --find(iItem, tvitem_handle)
            lItem = {w32fetch(ht,LVHITTESTINFO_iItem)+1,
                     w32fetch(ht,LVHITTESTINFO_iSubItem)+1}
        else
            lItem = {}
        end if

        w32release_mem(ht)

        return lItem
end function




-- DEBUG IMPLEMENT API SCROLLWINDOWEX

-----------------------------------------------------------------------------
function fDoScroll(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
-----------------------------------------------------------------------------
-- scroll event handler
integer
        request,
        origpos,
        lChildId,
--      lnChg, pgChg,   -- PL 29/4/09
        lWhich, lSBar,
        inc
atom
        pos
sequence
        range,
        chgs,
        lRC,
        lDir,
        lScope

--/**/  if hWnd or pReturn then end if -- suppress warnings -- PL 29/4/09

        -- determine if this is from the parent window's scroll
        -- bar, or a child scroll bar

        if ctrl_Parent[id] != 0 then
            lRC = {kSubclassedMsg}
        else
            lRC = {kMainMsg}
        end if

        if lParam != 0 then -- I have children
            -- find the control
            lChildId = getId(lParam)
            if lChildId = 0  or ctrl_Parent[lChildId] != id then -- Not one of mine
                return lRC
            end if

            id = lChildId
        end if

        -- get the request
        request = w32lo_word(wParam)

        -- get the value of the scroll bar
        if find(ctrl_Type[id], {HScroll, VScroll}) then
            lWhich = 1
            lSBar = SB_CTL

        elsif find(ctrl_Type[id], {Window, HTrackBar, VTrackBar, UpDown}) then
            if iMsg = WM_VSCROLL then
                lWhich = 1
                lSBar = SB_VERT
            else
                lWhich = 2
                lSBar = SB_HORZ
            end if
        else

            lWhich = 1
            lSBar = SB_VERT
        end if

        -- UpDown's handle scroll events themselves
        if ctrl_Type[id] = UpDown then
            pos = getScrollPos(id)
            VOID = invokeHandler(id, w32HScroll, {pos, request, lSBar})
            return {kMainMsg}
        end if

        if request != SB_THUMBTRACK then
            pos = getScrollPos({id, lSBar})

        else
            pos = getThumbPos({id, lSBar})

        end if

        if find(ctrl_Type[id], {HTrackBar, VTrackBar}) then
            origpos = 0
        else
            origpos = pos
        end if

        -- get the range
        range = getScrollRange({id, lSBar})

        -- scrollbars need special handling to adjust small/large change
        inc = find(request, {SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN})
        if inc != 0 then
            if find(ctrl_Type[id], {HScroll, VScroll, Window}) then
                lDir = {-1, 1, -1, 1}
                lScope = {MY_SMALLCHANGE, MY_SMALLCHANGE, MY_LARGECHANGE, MY_LARGECHANGE}
                if ctrl_Type[id] = Window then
                    chgs = ctrl_Scroll[id][lWhich]
                else
                    chgs = ctrl_Scroll[id][1]
                end if

                pos += (chgs[lScope[inc]] * lDir[inc])
            end if

        elsif request = SB_ENDSCROLL then
            VOID = invokeHandler(id, w32HScroll, {pos, request, lSBar})
            return lRC

        elsif request = SB_TOP then
            -- to top of page
            pos = range[1]

        elsif request = SB_BOTTOM then
            -- to bottom of page
            pos = range[2]

        elsif find(request, {SB_THUMBPOSITION, SB_THUMBTRACK}) then
            -- track thumb position
            origpos = -1 -- Force the event to kick in.
            pos = getThumbPos({id, lSBar})

        end if

        -- clip to range
        if pos < range[1] then
            pos = range[1]
        elsif pos > range[2] then
            pos = range[2]
        end if

        -- call global routine to do the work
        if pos != origpos then
            setScrollPos({id, lSBar}, {pos, request})
        end if

        return lRC
end function

-----------------------------------------------------------------------------
function fDoDropFiles(integer id, atom hWnd, atom iMsg, atom hDrop, atom lParam, atom pReturn)
-----------------------------------------------------------------------------
-- processes a WM_DROPFILES event.
integer bufferSize, namesize, itemCount
atom buffer
sequence fileName
object lUserResponse

--/**/  if hWnd or iMsg or lParam or pReturn then end if -- suppress warnings -- PL 29/4/09

        -- does this control support drag and drop?

        if length(ctrl_Handlers[id][w32HDragAndDrop]) > 0
        or length(ctrl_Handlers[Screen][w32HDragAndDrop]) > 0 then

            bufferSize = 4000
            buffer = w32acquire_mem(0, bufferSize)

            -- get the count of files
            itemCount = w32Func(xDragQueryFile,{hDrop, #FFFFFFFF, buffer, bufferSize})

            if itemCount > 0 then

                -- Indicate number of files in list.
                lUserResponse = invokeHandler(id, w32HDragAndDrop, {0, {itemCount}})

                -- DragQueryFileA uses zero based indexing
                for i=0 to itemCount-1 do
                    -- Check to see if user has aborted callbacks.
                    if sequence(lUserResponse) then
                        exit
                    end if

                    -- checking for buffer overflow.
                    namesize = w32Func(xDragQueryFile,{hDrop, i, 0, bufferSize})
                    if (namesize+1) > bufferSize then
                        w32release_mem(buffer)
                        bufferSize = namesize+1
                        buffer = w32acquire_mem(0, bufferSize)
                    end if
                    namesize = w32Func(xDragQueryFile,{hDrop, i, buffer, bufferSize})

                    -- get the next file name
                    fileName = peek({buffer, namesize})

                    -- user trap
                    lUserResponse = invokeHandler(id, w32HDragAndDrop, {0, fileName})
                end for

                -- Indicate end of file list.
                VOID = invokeHandler(id, w32HDragAndDrop, {0, ""})
            end if

            w32release_mem(buffer)

        end if

        return {kSubclassedMsg}

end function

sequence vLMB_id
vLMB_id = {-1, -1, -1, -1}

atom
      vMaxClickTime
integer
    vMaxClickXDelta,
    vMaxClickYDelta

vMaxClickTime   = (w32Func(xGetDoubleClickTime,{}) / 1000)
vMaxClickXDelta = 3
vMaxClickYDelta = 3

--/topic Events
--/func setMouseClick(object pTimeDelta, object pXDelta, object pYDelta)
--/desc Sets/gets the mouse click detection parameters.
--/ret The current settings for these parameters.
-- There are three parameters used to detect a mouse click event. These are /n
--/li Time: Number of seconds difference between left mouse down and up events.
--/li XDelta: Number of pixels allowance in the X (horizontal) direction.
--/li YDelta: Number of pixels allowance in the Y (vertical) direction.
--
-- By using this function, you can set any, all, or none of these parameters. To /b not
-- set a parameter, you must use an empty sequence in its place.
--
-- example:
--/code
--      -- Set the time to 1.5 seconds, and the Y tolerance to 5 pixels.
--      -- Leave the X tolerance as it is.
--      curval1 = setMouseClick(1.5, {}, 5)
--      -- Double the X tolerance, leaving the others alone.
--      curval2 = setMouseClick({}, curval1[2] * 2, {})
--/endcode

----------------------------------------------------
global function setMouseClick(object pTimeDelta, object pXDelta, object pYDelta)
----------------------------------------------------
sequence
     lCurrentValues

    lCurrentValues = {vMaxClickTime, vMaxClickXDelta, vMaxClickYDelta}

    if atom(pTimeDelta) then
        vMaxClickTime   = pTimeDelta
    end if

    if atom(pXDelta) then
        vMaxClickXDelta = pXDelta
    end if

    if atom(pYDelta) then
        vMaxClickYDelta = pYDelta
    end if

    return lCurrentValues
end function

----------------------------------------------------
function fDoMouse(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
integer
        mouseX,
        mouseY,
--      action,     -- PL 29/4/09
        doActions,
        lWheelPosn,
        lParent
sequence
        lRC,
        lEventParms,
--      cmp,    -- PL 29/4/09
        lRgns,
        lRelXY

--/**/  if hWnd then end if -- suppress warnings -- PL 29/4/09

        lRC = {pReturn}
        if and_bits(classAttr[ctrl_Type[id]], w32Clickable)!=0
        or ctrl_Family[id]=BUTTON
        or find(iMsg,{WM_RBUTTONDOWN,WM_MOUSEWHEEL})
        or (classType[ctrl_Type[id]]=STATIC and
            and_bits(SS_NOTIFY,w32Func(xGetWindowLong,{ctrl_Handle[id],GWL_STYLE}))!=0) then
            doActions = w32True
        else
            doActions = w32False
        end if
        lParent = findParentWindow(id)

        -- decode parameters
        mouseX = w32shortInt(w32lo_word(lParam))
        mouseY = w32shortInt(w32hi_word(lParam))
        if iMsg = WM_MOUSEWHEEL then
            -- This 'fixes' a bug in Windows in which the incorrect x/y is being reported.
            lRgns = getPointerRelPos(id)
            mouseX = lRgns[1]
            mouseY = lRgns[2]
            -- Get the movement and direction data
            lWheelPosn = w32hi_word(wParam)
            if lWheelPosn > #7FFF then
                lWheelPosn -= #10000
            end if
            lWheelPosn = floor(lWheelPosn/120)
        else
            lWheelPosn = 0
        end if

        if lParent=0 then
            lParent=Screen
        end if

        if sequence(ctrl_Mousetrap[lParent]) then
            -- Check the mousetrap areas set for this control.
            lRelXY = getPointerRelPos(lParent)
            lRgns = hitMouseTrap(lParent, iMsg, lRelXY[1], lRelXY[2])
            if length(lRgns) > 0 then
                VOID = invokeHandler(lParent, w32HMouseTrap, {iMsg, lRelXY[1], lRelXY[2],  lWheelPosn, lRgns, id, shifts})
                if sequence(VOID) then
                    -- If the user returns anything, eat the event.
                    lRC = {kMainMsg}
                    iMsg = 0
                    doActions = w32False
                end if
            end if
        end if

        -- get command

        if iMsg = WM_LBUTTONUP then
            -- test for a "click" gesture.
            if vLMB_id[1] = id
            and time()-vLMB_id[4] < vMaxClickTime
            and w32abs(mouseX-vLMB_id[2]) < vMaxClickXDelta
            and w32abs(mouseY-vLMB_id[3]) < vMaxClickYDelta then
                -- Clicking! Any handler for this?
                if doActions and ctrl_Family[id]!=BUTTON then
                    -- Note. Buttons are notified via the BN_CLICKED msg.
                    VOID = invokeHandler(id, w32HClick, {})
                end if
            else -- not a click.

                if length(vDragData) > 0 then  -- sz: add 1 before 1 and 0 before 2
                    -- I'm dragging something.
                    -- First, tell the destination control.
                    VOID = invokeHandler(id,          w32HDragAndDrop, vDragData)
                    -- Secondly, tell the source control
                    VOID = invokeHandler(vDragData[1], w32HDragAndDrop, vDragData)
                    -- Reset the cursor shape.
                    IndicateDragging(vDragData[1], w32False) -- Reset drag cursor shape.
                end if
            end if

            vDragData = {} -- Clear any drag operation data.

        end if

        if iMsg != WM_MOUSEMOVE then
            vLMB_id[1] = -1
        end if

        -- set the mouse cursor
        VOID = w32Func(xSetCursor, {ctrl_Cursor[id][1]})

        -- generate an event?
        if doActions then
            lEventParms = {iMsg, mouseX, mouseY, getKeyMasks(wParam), 0}
            if iMsg = WM_MOUSEWHEEL then
                lEventParms[5] = lWheelPosn
            end if
            VOID = invokeHandler(id, w32HMouse,  lEventParms)
            if sequence(VOID) then
                -- If the user returns anything, eat the event.
                lRC = {kMainMsg}
            end if
        end if
        -- Save mouse position and time for click detection.
        if iMsg = WM_LBUTTONDOWN then
            vLMB_id = {id, mouseX, mouseY, time()}
            if ctrl_Type[id] = TabControl then
                call_proc(r_setFocus,{id})
            end if
        end if

        return lRC
end function


----------------------------------------------------
function fDoSize(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
integer cx
integer cy
sequence lRC
integer lEraseBG

--/**/  if hWnd or iMsg then end if -- suppress warnings -- PL 29/4/09

        lRC = {pReturn}
        -- Sometimes this is received for 'destroyed' controls.
        if validId(id) then
            -- decode parameters
            cx = w32lo_word(lParam)
            cy = w32hi_word(lParam)
            -- resize behavior?
            VOID = invokeHandler(id, w32HResize, {wParam, cx, cy})
            if sequence(VOID) then
                if length(VOID)!=1 or not integer(VOID[1]) then
                    lEraseBG = 1
                elsif VOID[1] = 0 then
                    lEraseBG = 0
                else
                    lEraseBG = 1
                end if
                VOID = w32Func(xInvalidateRect, {getHandle(id), NULL, lEraseBG})
            end if

            resizeWidgets(id, cx, cy) -- resize the toolbar and statusbar, if any

        end if
        return lRC
end function

----------------------------------------------------
function fDoBkGndErase(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
sequence lRC

--/**/  if hWnd or iMsg or wParam or lParam or pReturn then end if -- suppress warnings -- PL 29/4/09
        lRC = {kSubclassedMsg}

        if ctrl_Erase[id] != 0 then
            lRC = {kMainMsg}
        end if
        return lRC
end function

----------------------------------------------------
function fDoSetFocus(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
sequence lRC
integer lParent
integer lParentWindow
integer lTempId

--/**/  if hWnd or iMsg or wParam or lParam or pReturn then end if -- suppress warnings -- PL 29/4/09
    lRC = {kSubclassedMsg}
    lParent = findParent(id)

    lParentWindow = findParentWindow(id)

    -- Don't bother setting focus to a window that's going down.
    if ctrl_Destroyed[id]!=0
    or (lParentWindow and ctrl_Destroyed[lParentWindow]!=0) then
        return lRC
    end if

    -- Check for special case of a control in a closed window that
    -- gets focus again!
    if (lParentWindow and ctrl_Closed[lParentWindow]=1)
    or (lParent!=0 and ctrl_Closed[lParent]=1) then
        if focus_current>0 and focus_current!=id then
            -- Reset focus on the last control that had an explicit set focus.
            setFocus(focus_current)
            return lRC
        end if
    end if

    if and_bits(classAttr[ctrl_Type[id]], w32HasChildren) then
        -- eg. A 'group' type of control. If somebody explictly
        -- sets focus to the group, then set focus to the first
        -- tabbable control in that group.
        if length(ctrl_Focus_order[id]) > 0 then
            setFocus(ctrl_Focus_order[id][1])
            return lRC
        end if

    end if

    -- item to focus on?
    if id!=lParentWindow and length(ctrl_Focus_order[id])>0 then
        -- no focus?

        if ctrl_Previous_focus[id]!=0 and ctrl_Previous_focus[id]!=id then
            lTempId = ctrl_Previous_focus[id]
            ctrl_Previous_focus[id] = 0
            if lTempId > 0 then
                id = lTempId
                lParent = findParent(id)
                lParentWindow = findParentWindow(id)
            end if
        end if
        tab_direction(id, 0) -- try to focus on item again
        -- supposedly useful (sz)
        focus_current = -1
        return lRC
    else

        if id=lParentWindow
        and ctrl_CanFocus[id] then
            if ctrl_Previous_focus[id] != 0 and ctrl_Family[ctrl_Previous_focus[id]] != WINDOW then
                setFocus(ctrl_Previous_focus[id])
            end if
        elsif ctrl_CanFocus[id]=2 then
            if ctrl_Previous_focus[id] != 0 then
                setFocus(ctrl_Previous_focus[id])
            else
                tab_direction(id,2)
            end if
            focus_current = -1
            return lRC
        end if
    end if

    -- is there a window with modal focus?
    if modalWindow!=0 and modalWindow!=lParentWindow then
        -- force focus back to the modal one
        w32Proc(xSetFocus, {modalhWnd})
    else
        if lParent != 0 then
            if ctrl_Family[lParent] = COMBO then

                ctrl_Current_focus[ctrl_Parent[lParent]] = id-1
            else
                ctrl_Current_focus[lParent] = id
            end if
        else
            lRC = {kMainMsg}
        end if

        -- Check for autoselect behaviour.
        if find(ctrl_Type[id], {EditText, MleText, RichEdit}) then
            if ctrl_Specific[id] = w32True then
                setIndex(id, {1,0})
            else
                setIndex(id, getIndex(id))
            end if
        end if

        -- call proc?
        VOID = invokeHandler(id, w32HGotFocus, {})

    end if

    focus_current = -1
    return lRC
end function



function fDoChar(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
-- processes WM_CHAR, WM_SYSCHAR
object lUserReturn
sequence lRC

--/**/  if pReturn then end if -- suppress warnings -- PL 29/4/09
        lUserReturn = invokeHandler(id, w32HKeyPress,{wParam, shifts, lParam<0})
        if sequence(lUserReturn) then
            if lUserReturn[1] = -1 then
                -- Ignore this keystroke
                lRC = {kMainMsg}
            else -- Replace entered key with new one.
                lRC = {kSubclassedMsg,{hWnd, iMsg, lUserReturn[1],lParam}}
            end if
        else
            lRC = {kSubclassedMsg}
        end if
        if wParam = VK_RETURN and shifts = 0 and ctrl_Type[id] = EditText then
            -- Tab to next field if a ReturnKey pressed in an edit field.
            lRC = {kMainMsg}
            tab_direction(id,1)
        end if
        return lRC

end function

constant shiftKeys = {VK_SHIFT,VK_CONTROL,VK_MENU,VK_LWIN},
         addShift = {ShiftMask,ControlMask,AltMask,WinMask},
-- PL 29/4/09
--/**/   removeShift = sq_not_bits(addShift),   --/* Pve
         removeShift = not_bits(addShift),      --   RDS */
         altPos = find(AltMask,addShift),
         shiftPos = find(ShiftMask,addShift)

sequence numShifts
         numShifts = repeat(0,length(shiftKeys))

procedure arShift(integer shNum,integer isUp)
    if isUp then
        numShifts[shNum] -= 1
        if numShifts[shNum]=0 then
            shifts = and_bits(shifts,removeShift[shNum])
        end if
    else
        if numShifts[shNum]=0 then
            shifts = or_bits(shifts,addShift[shNum])
        end if
        numShifts[shNum] += 1
    end if
end procedure

integer keyIndex
        keyIndex = 0

procedure resetKeyboard()
        keyIndex = 0
-- PL 29/4/09
--/**/  numShifts = sq_sub(numShifts,numShifts)     --/* Pve
        numShifts -= numShifts                      --   RDS */
        shifts = 0
end procedure

function adjustShift(integer keyCode,integer isUp,integer isSys)
integer shNum

--/**/  if isSys then end if -- suppress warnings -- PL 29/4/09
        if keyCode = VK_RWIN then
            keyCode = VK_LWIN
        end if
        shNum = find(keyCode,shiftKeys)
        if shNum then
            arShift(shNum,isUp)
        end if
        if isUp then
            return 0
        else
            return shNum
        end if
end function

integer maxKeyIndex maxKeyIndex = 4
integer emittedKey emittedKey = 0

constant CONTEXT=8192,REPEATING=16384,EXTENDED=256

sequence keyCodes,extFlags,scanCodes,keyParams,rptCounts
keyCodes=repeat(0,maxKeyIndex)
extFlags=keyCodes
scanCodes=keyCodes
keyParams=keyCodes
rptCounts=keyCodes

function fDoKeys(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
-- processes WM_NULL, WM_[SYS]KEY(DOWN|UP)
integer isDown,isSys,xcode
sequence lRC
object lUserReturn
integer lEmitKey,flags,extCode
integer lTabDir
sequence lHotKey

        flags=w32hi_word(lParam)
        -- some extended keys don't have an extended flag set accordingly
        if and_bits(flags,#FF)=#5B then -- left win key
            flags -= EXTENDED
        elsif and_bits(flags,#FF)=#36 then -- right shift
            flags = or_bits(flags,EXTENDED)
        end if

        extCode = wParam
        if wParam = VK_PACKET then -- Unicode 16-bit char held in flags
            extCode = flags + 65536
            xcode = find(extCode,keyCodes) -- position in keyboard buffer
            if xcode > keyIndex then -- spurious match
                xcode = 0
            end if
            if xcode>0 then -- repetition means the key is in the buffer, synthesize flags
                flags = REPEATING
            else
                flags = 0
            end if
        else
            if and_bits(flags,EXTENDED) then
                extCode += 256
            end if
            -- position in keyboard buffer
-- PL 29/4/09
--/**/      xcode = find(extCode,sq_add(keyCodes,sq_mul(256,extFlags))) --/* Pve
            xcode = find(extCode,keyCodes + 256*extFlags)               --   RDS */
            if xcode > keyIndex then -- spurious match
                xcode = 0
            elsif keyIndex and keyCodes[keyIndex]=VK_PROCESSKEY and xcode = 0 and not isDown then
                -- Far Eastern IME processed a key in Roman mode and reemitted this: restore message pairing
                xcode = keyIndex
                keyCodes[keyIndex] = wParam
            end if
        end if

        if iMsg=WM_NULL then -- on some systems, WM_SYSKEYUP is not sent

            if keyIndex and xcode then
                iMsg = WM_SYSKEYUP
            else
                return {kSubclassedMsg} -- an actual WM_NULL, not a translation
            end if
        end if

        isDown = iMsg = WM_KEYDOWN or iMsg = WM_SYSKEYDOWN
        isSys = iMsg = WM_SYSKEYDOWN or iMsg = WM_SYSKEYUP
        if xcode=0 and isDown and and_bits(flags,REPEATING) then -- OS merged extended and non extended keys
            flags -= REPEATING
        end if

        if not isDown and keyIndex=0 then -- spurious WM_[SYS]KEYUP, don't process
            return {kSubclassedMsg}
        end if

        if isSys and isDown then -- in some cases, WM_SYSKEYDOWN must translate to WM_KEYDOWN
            if not and_bits(flags,CONTEXT) then
    -- no window had focus; assume the keystroke was for the active window
    -- Windows sends WM_SYSKEYDOWN in that case, so translation to WM_KEYDOWN is needed
                isSys = 0
            elsif wParam = VK_F10 and not vSkipF10 then -- special processing for F10
                isSys = 0
            end if
        end if

        if not isDown then  -- up message
            lEmitKey = adjustShift(wParam,1,isSys)
            if not emittedKey then -- some combination of shifts, emit key
                lEmitKey = 1
            end if
        elsif not and_bits(flags,REPEATING) then -- OS says this doesn't repeat previous key
            emittedKey = 0 -- will set it later if needed
            if xcode=0 or xcode>keyIndex then -- truly new key, record it
                keyIndex += 1
                if keyIndex > maxKeyIndex then -- extend buffers
                    maxKeyIndex += 1
                    keyCodes &= 0
                    extFlags &= 0
                    scanCodes &= 0
                    keyParams &= 0
                    rptCounts &= 0
                end if
                -- acquire information
                keyCodes[keyIndex] = wParam
                extFlags[keyIndex] = (and_bits(flags,EXTENDED)!=0)
                scanCodes[keyIndex] = and_bits(flags,255)
                keyParams[keyIndex] = wParam
                rptCounts[keyIndex] = 1
                lEmitKey = not adjustShift(wParam,0,isSys)
            else -- this key is still depressed, treat as repeated
                rptCounts[xcode] += w32lo_word(lParam)
                lEmitKey = 0
            end if
            lEmitKey = 0
        else -- repeated key
            if xcode > 0 and xcode <= keyIndex then
                rptCounts[xcode] += w32lo_word(lParam)
            end if
            lEmitKey = 0
        end if

        -- which event?
        xcode = w32HKeyDown
        if isDown then
            if wParam = VK_PAUSE or wParam = VK_CANCEL then
                if not shifts then
                    xcode = w32HPause
                elsif shifts = ControlMask then
                    xcode = w32HBreak
                end if
            end if
        else
            xcode = w32HKeyUp
        end if

        lRC = {kSubclassedMsg}

        -- reasons not to emit the event?
        if isDown and not isSys then
            if not shifts
            and (wParam=VK_RETURN or wParam=VK_ESCAPE) then
                -- trap default keys for buttons etc
                lHotKey = isHotKey(id, hWnd, iMsg, wParam, lParam, pReturn)
                if lHotKey[1] = kMainMsg then -- hotkey detected
                    lRC = {kMainMsg}
                end if
            elsif not shifts
            and wParam=VK_DOWN
            and ctrl_Type[id]=TabControl then
                -- down arrow has a special meaning in tab controls
                if ctrl_Current_focus[id] != 0 then
                    tab_direction(ctrl_Current_focus[id],0)
                    lRC = {kMainMsg}
                elsif length(ctrl_Specific[id]) > 1 then
                    tab_direction(ctrl_Specific[id][1],0)
                    lRC = {kMainMsg}
                end if
            else
                -- main tabbing management
                lTabDir = isTabKey(id, wParam)
                if lTabDir then
                    tab_direction(id, lTabDir)
                    lRC = {kMainMsg} -- Skip default windows processing.
                end if
            end if
        end if

        if lRC[1] != kMainMsg then -- fire event
            lUserReturn = invokeHandler(id,xcode,{wParam,shifts})
            if sequence(lUserReturn) and isDown then
                -- special actions
                if length(lUserReturn) >= 2 then
                    if equal(lUserReturn[1], w32KH_SetFocus) then
                        tab_direction(lUserReturn[2],0)
                    end if
                elsif lUserReturn[1] = -1 then
                    -- Ignore this keystroke
                    lRC = {kMainMsg}
                else -- Replace entered key with new one.
                    lRC = {kSubclassedMsg,{hWnd, iMsg, lUserReturn[1],lParam}}
                end if
            end if
        end if

        -- see if w32HKeyboard is to be fired
        if lEmitKey then
            VOID = invokeHandler(id,w32HKeyboard,{keyCodes[1..keyIndex],
                                                  extFlags[1..keyIndex],
                                                  scanCodes[1..keyIndex],
                                                  rptCounts[1..keyIndex]})
            emittedKey = 1
        end if
        keyIndex -= not isDown

        if isDown and isSys and not shifts and wParam = VK_F10 and vSkipF10 then
            lRC = {kMainMsg} -- don't let Windows do its default action
        end if
    
        if wParam=VK_CONTROL and not isDown and isSys then -- releasing AltGr on non US keyboards
        -- also release the Alt part
            keyIndex -=1
            arShift(altPos,1)
        end if

        if wParam = VK_SHIFT and not isDown then
-- PL 29/4/09
--/**/      xcode = find(xor_bits(extCode,EXTENDED),sq_add(keyCodes,sq_mul(256,extFlags)))  --/* Pve
            xcode = find(xor_bits(extCode,EXTENDED),keyCodes+256*extFlags)                  --   RDS */
            if xcode>keyIndex then
            -- also release the other shift
                keyIndex -=1
                arShift(shiftPos,1)
            end if
        end if

        return lRC
end function

----------------------------------------------------
function fDoKillFocus(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
-- Remember the id that just lost focus.
integer lParentWindow

--/**/  if hWnd or iMsg or wParam or lParam or pReturn then end if -- suppress warnings -- PL 29/4/09
        lParentWindow = findParentWindow(id)
        if ctrl_Destroyed[id]=0
        and lParentWindow
        and ctrl_Closed[lParentWindow]!= 1 then
            ctrl_Previous_focus[id] = ctrl_Current_focus[lParentWindow]
            if id != lParentWindow then
                ctrl_Previous_focus[lParentWindow] = id
            end if
            resetKeyboard() -- in case current process changes because of a hotkey being pressed
            VOID = invokeHandler(id, w32HLostFocus, {ctrl_Previous_focus[id]})
        end if

        return {kSubclassedMsg} -- Continue with default windows processing.
end function


----------------------------------------------------
function fDoCommand(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
sequence lRC
atom lChildId
integer lParent

--/**/  if pReturn then end if -- suppress warnings -- PL 29/4/09
    lRC = {kSubclassedMsg}
    if lParam=NULL then
        -- menu or accelerator?
        if w32hi_word(wParam) = 1 then
        -- from accelerator;
        -- this should not happen

        -- menu click
        else
            -- get the menu id
            id = w32lo_word(wParam)
            -- update with new id

            VOID = invokeHandler(id, w32HClick, {})
        end if
    else

        lChildId = getId(lParam)
        if lChildId != 0 then
            lParent = findParent(lChildId)
            if lParent and ctrl_Type[lParent] = TabItem then
                -- Windows actually believes that the parent of a control
                -- in a TabItem is really the TabControl, so we have to
                -- make that adjustment here.
                lParent = findParent(lParent)
            end if
            if lParent = id then
                -- notification from control
                wmCommand(lChildId, hWnd, iMsg, wParam, lParam)
                -- Only parent windows stop processing at this point.
                if findParent(id) = 0 then
                    lRC = {kMainMsg}
                end if
            end if
        end if
    end if
    return lRC
end function

--/topic Graphics
--/func setPaintPolicy(integer id,integer pFlag)
--/desc Possibly sets the paint policy flag.
--/ret (INTEGER) The previous flag value.
-- By default, the library prevents w32HPaint events to reach controls which are already in the process of painting.
-- Pass a positive value in /i pFlag to enable recursion during paint events, w32False to disable it or a negative 
--  value to just get the current value.

global function setPaintPolicy(integer id,integer pFlag)
integer oldVal
        oldVal=ctrl_RecursivePaint[id]
        if pFlag>=0 then
            ctrl_RecursivePaint[id] = pFlag
        end if
        return oldVal
end function

----------------------------------------------------
function fDoPaint(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
atom
    ps,
    hdc
integer has_handler
sequence
    lUpdateRect,
    lRC

--/**/  if iMsg or wParam or lParam or pReturn then end if -- suppress warnings -- PL 29/4/09
    lRC = {kSubclassedMsg}

    if length(ctrl_Handlers[id][w32HPaint]) > 0
    or length(ctrl_Handlers[Screen][w32HPaint]) > 0 then
        has_handler=1
    else
        has_handler=0
    end if
    if has_handler or ctrl_Hatch[id] then -- there is something to do
        if find(id, vDuringPaint) then
         -- Already in a paint handler.
         -- So avoid some recursion.
            return lRC
        end if
        if not ctrl_RecursivePaint[id] then
            vDuringPaint=prepend(vDuringPaint,id)
        end if
        ps = w32acquire_mem(0, SIZEOF_PAINTSTRUCT)

        hdc = w32Func(xBeginPaint, {hWnd, ps})

        updateHDCInternal(id,hdc)

        if ctrl_Hatch[id] then
            w32Proc(xSetBkMode,{hdc,TRANSPARENT})
            VOID=w32Func(xSetBkColor,{hdc,ctrl_Bg_Color[id][2]})
            VOID=w32Func(xFillRect,{hdc,w32address(ps, psPaintRect),ctrl_Hatch[id]})
        end if
        if has_handler then
            lUpdateRect = w32fetch(ps, psPaintRect)
            VOID = invokeHandler(id, w32HPaint, lUpdateRect)
        end if

        -- Free up any resources used with this DC
        releaseDC(id)

        w32Proc(xEndPaint, {hWnd, ps})

        w32release_mem(ps)

        if not ctrl_RecursivePaint[id] then
            vDuringPaint = vDuringPaint[2..length(vDuringPaint)]
        end if

        lRC = {kMainMsg}
    end if

    return lRC

end function


----------------------------------------------------
function fDoTimer(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
--/**/  if hWnd or iMsg or lParam then end if -- suppress warnings  -- PL 29/4/09
    VOID = invokeHandler(id, w32HTimer,{wParam})
    return {pReturn}
end function


----------------------------------------------------
function fDoSysColorChange(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
-- system color changed. force a redraw of the window
object color

--/**/  if id or iMsg or wParam or lParam then end if -- suppress warnings  -- PL 29/4/09
        for i=1 to length(ctrl_Handle) do
            if validId(i) then
                color = ctrl_Bg_Color[i]
                if sequence(color) and length(color)=1 then
                    color=color[1]
                end if
                setBackground(i, sequence(ctrl_Bg_Color[i]), color)
                setTextColor(i, ctrl_Font[i][w32FontColor])
            end if
        end for

        if not w32Func(xInvalidateRect, {hWnd, NULL, -1}) then
            warnErr("InvalidateRect in DoSysColorChange failed.")
        end if

        return {pReturn}
end function

----------------------------------------------------
function fDoCtlColor(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
integer lControl,lColor

--/**/  if id or hWnd or iMsg or pReturn then end if -- suppress warnings   -- PL 29/4/09
        -- system is about to draw the colors for a control.
        -- this intercepts the command, and returns the brush we want
        lControl = getId(lParam)
        if lControl = 0 then
            -- A Windows managed control, so ignore it.
            return {kMainMsg, -1}
        end if
--    lParent = getParent(lControl)

        VOID = w32Func(xSetTextColor, {wParam, colorValue(ctrl_Font[lControl][w32FontColor])})
        if not equal(ctrl_Bg_Color[lControl], w32WinDefColor) then
            -- wParam contains the device context of the control
            lColor = colorValue(ctrl_Bg_Color[lControl])
            VOID = w32Func(xSetBkColor, {wParam, lColor})
            -- get the background color brush
            return {kMainMsg, ctrl_Bg_Brush[lControl]}
        else
            if and_bits(classAttr[ctrl_Type[lControl]], w32UseSubProc) then
                return {kSubclassedMsg}
            else
                return {kMainMsg,-1}
            end if
        end if
end function


sequence ActiveEL ActiveEL = {}
----------------------------------------------------
procedure quitWindow(integer id)
----------------------------------------------------
    if validId(id) = w32False then
        return
    end if

    if length(ActiveEL) > 0 then
        ActiveEL[length(ActiveEL)] = 1
    end if
    return

end procedure

constant
    Dialog          = -2


----------------------------------------------------
function fDoClose(integer id, atom hWnd, atom iMsg, atom wParam,
          atom lParam, atom pReturn)
----------------------------------------------------
integer idStyle, idDepth
object lUserReturn

--/**/  if iMsg or wParam or lParam or pReturn then end if -- suppress warnings -- PL 29/4/09
        -- Ignore this call if a bad ID supplied.
        if validId(id) = w32False
        or ctrl_Closed[id] != 0 then
            return {kMainMsg}
        end if

        -- Do not close this window if there is a modal one active,
        -- unless this window is the modal one.
        if modalWindow != 0
        and modalWindow != id then
            -- In case the window has been programmatically minimized,
            -- restore it to show the user why the requested window
            -- is not closing.
            if isMinimized(modalWindow) then
                VOID = w32Func(xShowWindow, {modalhWnd, SW_RESTORE})
            end if
            w32Proc(xSetFocus, {modalhWnd})
            return {kMainMsg}
        end if

        ctrl_Closed[id] = 2 -- Closing down

        -- Any user defined action?
        if length(ctrl_Handlers[id][w32HClose]) > 0
        or length(ctrl_Handlers[Screen][w32HClose]) > 0 then
            lUserReturn = invokeHandler(id, w32HClose, {})
            -- If the user routine returned a non-zero value
            -- do not close this window.
            if sequence(lUserReturn)
            and lUserReturn[1]!=0 then
                -- undo the closing flag
                ctrl_Closed[id] = 0
                -- Ignore the close request
                return {kMainMsg}
            end if
        end if

        -- close modal grab?
        if modalWindow = id then
            idStyle = modalStyle
            idDepth = modalDepth
            popModal()
        else
            idStyle = Normal
        end if

        -- hide the window if not the primary
        if id != mainWindow then
            VOID = w32Func(xShowWindow, {hWnd, SW_HIDE})
            ctrl_Closed[id] = 1
            if idStyle = Dialog then
                if length(ActiveEL) > idDepth then
                    quitWindow(id)
                end if
            end if
            return {kMainMsg}
        else

            destroy(id)
            VOID = setMainWindow(0)
            ctrl_Closed[id] = 1

            if vEndAction >= 0 then
                abort(vEndAction)
            end if

        end if

        return {kSubclassedMsg}
end function

----------------------------------------------------
function fDoDestroy(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------

--/**/  if hWnd or iMsg or lParam or pReturn then end if -- suppress warnings   -- PL 29/4/09
        if mainWindow = id then
            -- close the app
            w32Proc(xPostQuitMessage, {wParam})
        end if

        return {kSubclassedMsg}
end function

----------------------------------------------------
function fDoTCN_SELCHANGING(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
integer newItem
object lRC
        -- get handle

--/**/  if wParam then end if -- suppress warnings  -- PL 29/4/09
        hWnd = w32fetch(lParam, NMHDR_hwndFrom)
        -- find the tab control id
        id = getId(hWnd)
        if id != 0 then
            -- get id of selected tab
            newItem = ctrl_Specific[id][w32Func(xSendMessage, {hWnd, TCM_GETCURSEL, 0, 0})+1]
            lRC = invokeHandler(id,w32HChange,{newItem,getTabItem(id)})
            if sequence(lRC) and length(lRC)>=2 then
                if lRC[1]=-1 then
                    return {kMainMsg,w32True} -- block the change
                elsif integer(lRC[1]) then
                    lRC = sendMessage(id,TCM_SETCURSEL,lRC[1],0)
                end if
            end if
        end if

        return {kMainMsg}
end function

----------------------------------------------------
function fDoTCN_SELCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
        -- get handle

--/**/  if wParam then end if -- suppress warnings  -- PL 29/4/09
        hWnd = w32fetch(lParam, NMHDR_hwndFrom)
        -- find the tab control id
        id = getId(hWnd)
        if id != 0 then
            -- get id of selected tab
            id = ctrl_Specific[id][w32Func(xSendMessage, {hWnd, TCM_GETCURSEL, 0, 0})+1]
            -- activate the tab items for the control
            activateTabItems(id)

            -- is there a click behavior?
            VOID = invokeHandler(id, w32HClick, {})

        end if

        return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_COLUMNCLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
integer lColumn
integer lOwner
integer lDoSort
integer rtn

--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
        id = getId(w32fetch(lParam, NMHDR_hwndFrom))
        if id != 0 then
            lColumn = w32fetch(lParam, NMLISTVIEW_iSubItem)+1
            lOwner = find(id, lv_id)
            if lOwner != 0 then
                if sequence(lv_properties[lOwner][kLVSortSeq]) then
                    if length(lv_properties[lOwner][kLVSortSeq]) >= lColumn then
                        if lv_properties[lOwner][kLVSortSeq][lColumn] = 2 then
                            lv_properties[lOwner][kLVSortSeq][lColumn] = -2
                        elsif lv_properties[lOwner][kLVSortSeq][lColumn] = -2 then
                            lv_properties[lOwner][kLVSortSeq][lColumn] = 2
                        end if
                    end if
                else
                    if lv_properties[lOwner][kLVSortSeq] = 2 then
                        lv_properties[lOwner][kLVSortSeq] = -2
                    elsif lv_properties[lOwner][kLVSortSeq] = -2 then
                        lv_properties[lOwner][kLVSortSeq] = 2
                    end if
                end if
            end if

            lv_properties[lOwner][kLVSortCol] = lColumn


            rtn = -1
            if sequence(lv_properties[lOwner][kLVSortRtn]) then
                if length(lv_properties[lOwner][kLVSortRtn]) >= lColumn then
                    rtn = lv_properties[lOwner][kLVSortRtn][lColumn]
                end if
            end if

            lDoSort = w32True
            if rtn >= 0 then
                -- Indicate that we are about to start sorting.
                if rtn != r_lvSortitems then
                    lDoSort = call_func(rtn, {id, -1, -1, w32LV_StartSorting})
                end if
            end if

            if lDoSort then
                releaseMouse()
                setMousePointer(id, "HOURGLASS")
                VOID = sendMessage(id, LVM_SORTITEMS, id, pfnCompare)
                -- Signal that sorting has stopped.
                if rtn != -1 and rtn != r_lvSortitems then
                    VOID = call_func(rtn, {id, -1, -1,  w32LV_EndSorting})
                end if
                setMousePointer(id, "NULL")
            end if
        end if

        return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
atom lMask
-- integer
--      lSubItem,
--      lItem
--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
        id = getId(w32fetch(lParam, NMHDR_hwndFrom))

        if id != 0 then
            lMask    = w32fetch(lParam, {LVDISPINFO_item,LVITEM_mask})
--          lSubItem = w32fetch(lParam, {LVDISPINFO_item,LVITEM_iSubItem})+1
--          lItem   = w32fetch(lParam, {LVDISPINFO_item,LVITEM_iItem})

            if and_bits(lMask, LVIF_TEXT) then
                -- Indicate that somebody is looking for non-existant text.
                w32store(lParam, {LVDISPINFO_item,LVITEM_pszText},{{},{-1, -1}})
            end if
        end if

        return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_BEGINDRAG(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
        id = getId(w32fetch(lParam, NMHDR_hwndFrom))
        if id != 0 then
            vDragData = {id, getLVSelected(id)}
        end if

        IndicateDragging(id, w32True) -- Change cursor to show drap in progress.

        return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_BEGINDRAG(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id != 0 then
        vDragData = {id, {getTVIndex(id)}}
    end if
    IndicateDragging(id, w32True) -- Change cursor to show drap in progress.

    return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
atom
     lMask

integer
     lItem

--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
    id    = w32fetch(lParam, {TVDISPINFO_item,TVITEM_hItem})
    lItem = find(id, tvitem_handle)

    -- This is called before we get the handle, so if
    -- we haven't filled it in yet, we'll just grab
    -- the first one.
    if lItem = 0 then
        lItem = find(0, tvitem_handle)
        if lItem = 0 then
            lItem = 1
        end if
    end if

    if lItem <= length(tvitem_data) then
        lMask = w32fetch(lParam, {TVDISPINFO_item,TVITEM_mask})


        if and_bits(lMask, TVIF_IMAGE) then
            w32store(lParam, {TVDISPINFO_item,TVITEM_iImage},
                     tvitem_data[lItem][ktv_NormImage])
        end if

        if and_bits(lMask, TVIF_SELECTEDIMAGE) then
            w32store(lParam, {TVDISPINFO_item,TVITEM_iSelectedImage},
                     tvitem_data[lItem][ktv_SelectImage])
        end if

        if and_bits(lMask, TVIF_TEXT) then
            w32store(lParam, {TVDISPINFO_item,TVITEM_pszText},
                     {{},tvitem_data[lItem][ktv_TextAddr..ktv_TextSize]})
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_SELCHANGED(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
    id = getId(w32fetch(lParam, {NMTREEVIEW_hdr,NMHDR_hwndFrom}))
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, {w32CHG_Sel, getIndex(id)})
    end if
    return {kMainMsg}
end function


-- Try to keep from GPF'ing when TreeView is child to something
-- other than a window (ie, TabControl).  This seems to
-- work, but I'm not sure why...
----------------------------------------------------
function fDoTVN_DELETEITEM(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if id or hWnd or wParam or lParam then end if -- suppress warnings  -- PL 29/4/09
    return {kMainMsg}
end function

----------------------------------------------------
function fDoTTN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
sequence lText
atom lTextLen

--/**/  if hWnd then end if -- suppress warnings    -- PL 29/4/09
        id = getId(wParam)
        if id = 0 then
            id = w32fetch(lParam, NMHDR_idFrom)
        end if

        if id > 0 and id <= length(ctrl_Hint_Text) then
            if atom(ctrl_Hint_Text[id]) then
                if integer(ctrl_Hint_Text[id]) and ctrl_Hint_Text[id] >= 0 then
                    -- The user routine returns either a string or a sequence in
                    -- the form of {string, width}, eg. {"Sample text", 120}
                    lText = call_func(ctrl_Hint_Text[id], {id, ctrl_Hint_Width[id]})
                    if length(lText) = 2 and sequence(lText[1]) and integer(lText[2]) then
                        ctrl_Hint_Width[id] = lText[2]
                        lTextLen = lText[2]
                        lText = lText[1]
                    elsif length(lText) = 0 then
                        lTextLen = 0
                    else
                        lTextLen = ctrl_Hint_Width[id]
                    end if
                else
                    lText = sprintf("Invalid routine_id %g", ctrl_Hint_Text[id])
                    lTextLen = ctrl_Hint_Width[id]
                end if
            else
                lText = ctrl_Hint_Text[id]
                lTextLen = ctrl_Hint_Width[id]
            end if

            w32store(lParam, NMTTDISPINFO_szText, lText)
            VOID = w32Func(xSendMessage,{w32fetch(lParam, NMHDR_hwndFrom),
                                         TTM_SETMAXTIPWIDTH, 0,
                                         lTextLen})

        end if

        return {kMainMsg}
end function

----------------------------------------------------
function fDoMCN_SELCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, {})
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoMCN_SELECT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, getSelectedDateRange(id))
    end if
    return {kMainMsg}
end function

----------------------------------------------------
function fDoTBN_GETBUTTONINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if id then end if -- suppress warnings  -- PL 29/4/09
    return {kSubclassedMsg, {hWnd, TBN_GETBUTTONINFO, wParam, lParam}}
end function

----------------------------------------------------
function fDoTBN_QUERYINSERT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if id or hWnd or wParam or lParam then end if -- suppress warnings  -- PL 29/4/09
    return {kMainMsg, 1}
end function

----------------------------------------------------
function fDoTBN_QUERYDELETE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if id or hWnd or wParam or lParam then end if -- suppress warnings  -- PL 29/4/09
    return {kMainMsg, 1}
end function

----------------------------------------------------
function fDoLVN_ITEMCHANGED(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id != 0 then
        VOID = invokeHandler(id, w32HChange, {w32fetch(lParam, NMLISTVIEW_iItem)+1,
                                              w32fetch(lParam, NMLISTVIEW_iSubItem)+1,
                                              w32fetch(lParam, NMLISTVIEW_uNewState),
                                              w32fetch(lParam, NMLISTVIEW_uChanged),
                                              w32fetch(lParam, NMLISTVIEW_ptActionX),
                                              w32fetch(lParam, NMLISTVIEW_ptActionY),
                                              w32fetch(lParam, NMLISTVIEW_lParam)

                                             })
    end if
    return {kMainMsg}
end function


----------------------------------------------------
function fDoNM_CLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
sequence xy
atom keys
integer lRealId
atom lCode

--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
        lRealId = w32fetch(lParam, NMHDR_idFrom)
        if lRealId != 0 then
            lRealId = getId(w32fetch(lParam, NMHDR_hwndFrom))
        else
            lRealId = id
        end if
        lCode = w32fetch(lParam, NMHDR_code)
        xy = getPointerRelPos(lRealId)
        keys = getKeyMasks(0)

        VOID = invokeHandler(lRealId, w32HClick, {lCode})
        VOID = invokeHandler(lRealId, w32HMouse, {WM_LBUTTONUP, xy[1],xy[2], keys})
        return {kMainMsg}
end function

----------------------------------------------------
function fDoNM_RCLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
sequence xy
atom keys
integer lRealId

--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
        lRealId = w32fetch(lParam, NMHDR_idFrom)
        if lRealId != 0 then
            lRealId = getId(w32fetch(lParam, NMHDR_hwndFrom))
        else
            lRealId = id
        end if
        xy = getPointerRelPos(lRealId)

        keys = getKeyMasks(0)
        VOID = invokeHandler(lRealId, w32HMouse, {WM_RBUTTONUP, xy[1],xy[2], keys})
        return {kMainMsg}
end function

----------------------------------------------------
function fDoRBN_HEIGHTCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    --integer rebarid

--/**/  if hWnd or wParam or lParam then end if -- suppress warnings    -- PL 29/4/09
    --rebarid = getId(w32fetch(lParam, NMTREEVIEW_NMHDRhwndFrom))
    --VOID = getCtlSize(rebarid)
    --VOID = invokeHandler(Screen, w32HResize, {rebarid, VOID[1], VOID[2]})

    VOID = w32Func(xInvalidateRect, {getHandle(id), NULL, w32True})
    return {kMainMsg}
end function

global constant
    CBENF_KILLFOCUS=1,
    CBENF_RETURN=2,
    CBENF_ESCAPE=3,
    CBENF_DROPDOWN=4

----------------------------------------------------
function fDoCBEN_ENDEDIT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
object lRC
integer why

--/**/  if hWnd or wParam then end if -- suppress warnings  -- PL 29/4/09
        -- get length of embedded string (text in the child edit field) storage in TCHARS
        -- on Unicode versions, this will fail (bad length and add 2)
        why=w32Func(xlstrlen,{lParam+20})+1
        -- pass the info (reason of edit end) along
        lRC=invokeHandler(id,w32HChange,{w32CHG_Sel,peek4u(lParam+20+why)})
        return {kMainMsg,sequence(lRC)}
end function


sequence vNotifications
vNotifications =
     {
      TCN_SELCHANGE,
      LVN_COLUMNCLICK,
      LVN_GETDISPINFO,
      LVN_BEGINDRAG,
      TVN_BEGINDRAG,
      TVN_GETDISPINFO,
      TVN_SELCHANGED,
      TVN_DELETEITEM,
      TTN_GETDISPINFO,
      MCN_SELCHANGE,
      MCN_SELECT,
      TBN_GETBUTTONINFO,
      TBN_QUERYINSERT,
      TBN_QUERYDELETE,
      LVN_ITEMCHANGED,
      NM_CLICK,
      NM_RCLICK,
      RBN_HEIGHTCHANGE,
      TCN_SELCHANGING,
      CBEN_ENDEDIT
     }

sequence vNotifyHandlers
vNotifyHandlers =
     {
      routine_id("fDoTCN_SELCHANGE"),
      routine_id("fDoLVN_COLUMNCLICK"),
      routine_id("fDoLVN_GETDISPINFO"),
      routine_id("fDoLVN_BEGINDRAG"),
      routine_id("fDoTVN_BEGINDRAG"),
      routine_id("fDoTVN_GETDISPINFO"),
      routine_id("fDoTVN_SELCHANGED"),
      routine_id("fDoTVN_DELETEITEM"),
      routine_id("fDoTTN_GETDISPINFO"),
      routine_id("fDoMCN_SELCHANGE"),
      routine_id("fDoMCN_SELECT"),
      routine_id("fDoTBN_GETBUTTONINFO"),
      routine_id("fDoTBN_QUERYINSERT"),
      routine_id("fDoTBN_QUERYDELETE"),
      routine_id("fDoLVN_ITEMCHANGED"),
      routine_id("fDoNM_CLICK"),
      routine_id("fDoNM_RCLICK"),
      routine_id("fDoRBN_HEIGHTCHANGE"),
      routine_id("fDoTCN_SELCHANGING"),
      routine_id("fDoCBEN_ENDEDIT")
     }

----------------------------------------------------
function fDoNotify(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
integer lNotify, nid
atom lNewMsg
object lResult

--/**/  if iMsg then end if -- suppress warnings    -- PL 29/4/09
        -- lParam contains the notification message header
        lNewMsg = w32fetch(lParam, NMHDR_code)
        lNotify = find(lNewMsg, vNotifications)
        if lNotify = 0 then
            lResult = {kSubclassedMsg} -- Not one of the ones I'm interested in.
            nid = getId(w32fetch(lParam, NMHDR_hwndFrom))
            VOID = invokeHandler(nid, w32HEvent, {lNotify, wParam, lParam})
        else
            if vNotifyHandlers[lNotify] != -1 then
                lResult = call_func(vNotifyHandlers[lNotify], {id, hWnd, wParam, lParam})
                if atom(lResult) then
                    lResult = {lResult}
                end if
            else
                lResult = {pReturn}
            end if
        end if

        return lResult

end function

--/topic Events
--/func setNotifyHandler(integer pMsg, integer pRtnId)
--/ret INTEGER: The current Routine ID for this notification message.
--/desc Sets a handler for WM_NOTIFY type of messages.
-- /i pMsg is the Notification Message code for which you are setting the
-- handler. /n
-- /i pRtnId is the routine_id() of your function that handles the message. Passing a negative value will remove the handler.
--
-- Your routine is passed four parameters: /n
--</ul>
--/li /b integer /i id" = The ID of the control that is sending the notification.
--/li /b atom /i hWnd" = a copy of the hWnd parameter sent by Windows.
--/li /b atom /i wParam" = a copy of the wParam parameter sent by Windows.
--/li /b atom /i lParam" = a copy of the lParam parameter sent by Windows.
--</ul>
-- and must return either /kSubclassedMsg or /kMainMsg /n
-- /i kSubclassedMsg means that you want the windows processing specific to this class of control to occur for
-- this notification, after your code has finished. A variation is to return {kSubclassedMsg,
-- {hWnd,iMsg,wParam,lParam}} that contain replacement values for the ones originally
-- send through by Windows. kProcessMsg is an alias for kSubclassedMsg./n
-- /i kMainMsg means that you want the Windows default processing to occur, skipping any
-- class specific behaviour. This will
-- send a zero return code back to the Windows from the WM_NOTIFY message. Sometimes
-- however, you may need to specifies a specific return value. In this case you need
-- to return {kMainMsg, retval} in which /i retval must be an integer. kReturnNow is an
-- alias for kMainMsg.
--Example:
--/code
--  sequence alldata
--  integer oldval
--  integer SORT_BY
--  SORT_BY=0
--  alldata = getDataItems()
--
--  function CS_byElement(sequence s1,sequence s2)
--    return compare(s1[SORT_BY],s2[SORT_BY])
--  end function
--
--  constant ByElement=routine_id("CS_byElement")
--
--  function mylvclick(integer id, atom hWnd, atom wParam, atom lParam)
--  integer
--    lColumn,
--    lOwner
--
--    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
--    if id != 0 then
--        lColumn = w32fetch(lParam, NMLISTVIEW_iSubItem)+1
--        SORT_BY=lColumn
--        alldata=custom_sort(ByElement,alldata)
--        VOID = sendMessage(id,WM_SETREDRAW,0,0)
--        loadLVInfo(id, alldata)
--        VOID = sendMessage(id,WM_SETREDRAW,1,0)
--    end if
--
--    return kMainMsg
--  end function
--  oldval = setNotifyHandler(LVN_COLUMNCLICK, routine_id("mylvclick"))
--/endcode

global function setNotifyHandler(integer pMsg, integer pRtnId)
integer lOldRid
integer lMsgIndx

        lMsgIndx = find(pMsg, vNotifications)
        if lMsgIndx = 0 then
            if pRtnId >= 0 then
                vNotifications &= pMsg
                vNotifyHandlers &= pRtnId
            end if
            lOldRid = -1
        elsif pRtnId >= 0 then
            lOldRid = vNotifyHandlers[lMsgIndx]
            vNotifyHandlers[lMsgIndx] = pRtnId
        else -- removal
            vNotifications = w32removeIndex(lMsgIndx,vNotifications)
            vNotifyHandlers = w32removeIndex(lMsgIndx,vNotifyHandlers)
        end if

        return lOldRid
end function

----------------------------------------------------
function fDoDLGCODE(integer id, atom hWnd, integer iMsg,atom wParam, atom lParam,atom pReturn)
----------------------------------------------------
object policy
integer retVal

--/**/  if hWnd or iMsg or pReturn then end if -- suppress warnings -- PL 29/4/09
        if not validId(id) then
            return {kSubclassedMsg}
        end if

        policy = ctrl_KbdInput[id]
        if sequence(policy) then
            retVal = call_func(policy[1],{wParam,lParam})
        else
            retVal = policy
            if retVal = -1 then
                retVal = classKbdInput[ctrl_ActualClass[id]]
            end if
        end if
        return {kMainMsg,retVal}

end function

sequence menu_dropped menu_dropped={}
sequence hilitems hilitems={}
integer menubar menubar=0

----------------------------------------------------
function fDoMENUSELECT(integer id, atom hWnd, integer iMsg,atom wParam, atom lParam,atom pReturn)
----------------------------------------------------
integer itemId,pos,spawnsMenu,itemPos
atom test

--/**/  if hWnd or iMsg or pReturn then end if -- suppress warnings -- PL 29/4/09
        if lParam=0 and w32hi_word(wParam)=#FFFF then
            -- menu clicked shut
            for i=1+menubar to length(menu_dropped) do
                VOID = invokeHandler(menu_dropped[i],w32HCloseUp,{})
            end for
            menu_dropped = {}
            hilitems = {}
            menubar=0
        else
            pos = find(lParam,menu_handles)
            if not pos then -- not mine
                return {kSubclassedMsg}
            end if
            id = menu_ids[pos]
            if ctrl_Family[ctrl_Parent[id]]=WINDOW then
                menubar=1
            end if
            itemId = w32lo_word(wParam)
            spawnsMenu = and_bits(w32hi_word(wParam),MF_POPUP)
            if spawnsMenu then
                itemPos = itemId
                itemId = ctrl_Group[id][itemId+1]
            else
                itemPos=getMenuPosn(itemId)
            end if
            VOID = invokeHandler(id,w32HChange,{itemId,w32hi_word(wParam)})
            pos = find(id,menu_dropped)
            if not find(itemId,hilitems) then
                if not pos then
                    hilitems &= itemId
                    menu_dropped &= id
                else
        -- selecting an item up in the hierarchy of those already opened, back up on tree
                    hilitems = hilitems[1..pos-1] & itemId
                    for i=pos+1 to length(menu_dropped) do
                        VOID = invokeHandler(menu_dropped[i],w32HCloseUp,{})
                    end for
                    menu_dropped = menu_dropped[1..pos]
                end if
            end if
            if spawnsMenu then
                test = w32Func(xGetSubMenu,{lParam,itemPos})
                itemId = w32lookup(test,menu_handles,menu_ids)
                if not find(itemId,menu_dropped) then
                    VOID = invokeHandler(itemId,w32HDropDown,{})
                end if
            end if
        end if
        return {kMainMsg}
end function

----------------------------------------------------
function fDoFindReplace(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
object
   flag,
   range

atom
   lReplacing,
   lRepeating,
   lMustRepeat,
   lNewText

--/**/  if hWnd or iMsg or wParam or pReturn then end if -- suppress warnings -- PL 29/4/09
    if ctrl_Type[id] = RichEdit or ctrl_Family[id] = EDIT then
        flag          = w32fetch(lParam, FINDREPLACE_Flags)
        if and_bits(flag, FR_REPLACE + FR_REPLACEALL + FR_FINDNEXT)!=0 then
            range        = setFindSel(id, flag, lParam)
            lReplacing  = (and_bits(flag, FR_REPLACE + FR_REPLACEALL) != 0)
            lMustRepeat = (and_bits(flag, FR_REPLACEALL) != 0)
            lRepeating  = lReplacing
            if lReplacing then
                lNewText = peek4u(lParam + FINDREPLACE_lpstrReplaceWith[1])
            end if

            while range and lRepeating do
                lRepeating = lMustRepeat
                VOID = sendMessage(id, EM_REPLACESEL, 1, lNewText)
                if lMustRepeat then
                    range = setFindSel(id, flag, lParam)
                end if
            end while
        end if
    end if

    return {kSubclassedMsg}
end function

----------------------------------------------------
----------------------------------------------------
sequence vEventsHandled
vEventsHandled = {
                  WM_MOUSEMOVE,
                  WM_SETFOCUS,
                  WM_KILLFOCUS,
                  WM_KEYDOWN,
                  WM_CHAR,
                  WM_KEYUP,
                  WM_LBUTTONDOWN,
                  WM_RBUTTONDOWN,
                  WM_LBUTTONUP,
                  WM_RBUTTONUP,
                  WM_LBUTTONDBLCLK,
                  WM_RBUTTONDBLCLK,
                  WM_MOUSEWHEEL,
                  WM_SIZE,
                  WM_COMMAND,
                  WM_DROPFILES,
                  WM_PAINT,
                  WM_VSCROLL,
                  WM_HSCROLL,
                  WM_TIMER,
                  WM_SYSCOLORCHANGE,
                  WM_CTLCOLORBTN,
                  WM_CTLCOLORSTATIC,
                  WM_CTLCOLOREDIT,
                  WM_CTLCOLORLISTBOX,
                  WM_CTLCOLORSCROLLBAR,
                  WM_CLOSE,
                  WM_DESTROY,
                  WM_NOTIFY,
                  WM_SYSKEYDOWN,
                  WM_SYSKEYUP,
                  WM_NULL,
                  WM_SYSCHAR,
                  WM_ERASEBKGND,
                  w32FindReplaceMsg,
                  WM_GETDLGCODE,
                  WM_MENUSELECT

}
sequence vHandler

vHandler = {
            routine_id("fDoMouse"),
            routine_id("fDoSetFocus"),
            routine_id("fDoKillFocus"),
            routine_id("fDoKeys"),
            routine_id("fDoChar"),
            routine_id("fDoKeys"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoSize"),
            routine_id("fDoCommand"),
            routine_id("fDoDropFiles"),
            routine_id("fDoPaint"),
            routine_id("fDoScroll"),
            routine_id("fDoScroll"),
            routine_id("fDoTimer"),
            routine_id("fDoSysColorChange"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoClose"),
            routine_id("fDoDestroy"),
            routine_id("fDoNotify"),
            routine_id("fDoKeys"),
            routine_id("fDoKeys"),
            routine_id("fDoKeys"),
            routine_id("isHotKey"),
            routine_id("fDoBkGndErase"),
            routine_id("fDoFindReplace"),
            routine_id("fDoDLGCODE"),
            routine_id("fDoMENUSELECT")
           }

sequence vEventCnt
vEventCnt = repeat(0, length(vHandler))

sequence vUserEventsHandled,
         vUserEventHandlers
vUserEventsHandled = {}
vUserEventHandlers = {}


--/topic Events
--/proc setWinMsgHandler(object id, object pMsg, integer pRtnId)
--/desc Sets a user defined (raw) windows message handler.
--Use this to set up a handler to directly deal with a
--Windows message prior to win32lib processing it.
-- This is really only used by experienced Windows coders as it
-- must deal with all the low-level detail itself. /n
--
-- /i id can be either a single control Id or a list of them. /n
-- /i pMsg can be either a single Windows message code or a list of them.
-- The /i pRtnId is a routine_id of some code of yours which must
-- be a function that receives these parameters ... /n
--<ol>
--/li integer pSource
--/li atom hWnd
--/li atom iMsg
--/li atom wParam
--/li atom lParam
--</ol>
-- The /i pSource parameter is either kSubclassedMsg if this is a subclassed
--control, or kMainMsg if this is a window or non-subclassed control. /n
--If your handler routine returns a sequence then win32lib does not process
-- the message and the first element in the sequence is returned to Windows.
--
-- Note that if /i pRtnId is /b "-1" then this removes a previously set
-- message handler.
--
--
--Example:
--/code
--  function myhandler(integer pSource, atom hWnd, atom iMsg, atom wParam, atom lParam)
--      if wParam = VK_ENTER then
--       if iMsg = WM_KEYDOWN then
--              ...
--       else -- WM_KEYUP
--              ...
--       end if
--      end if
--      return {0}
--  end function
--  setWinMsgHandler(myFld, {WM_KEYDOWN, WM_KEYUP}, routine_id(myhandler))
--/endcode

global procedure setWinMsgHandler(object pId, object pMsg, integer pRoutine)
integer lPosn
integer id
atom lMsg

        if not sequence(pId) then
            pId = {pId}
        end if
        if not sequence(pMsg) then
            pMsg = {pMsg}
        end if

        for i=1 to length(pId) do
            id = pId[i]
            for j=1 to length(pMsg) do
                lMsg = pMsg[j]
                lPosn = find({id, lMsg}, vUserEventsHandled)
                if lPosn = 0 then
                    vUserEventsHandled &= {{id, lMsg}}
                    vUserEventHandlers &= -1
                    lPosn = length(vUserEventsHandled)
                end if

                if pRoutine >= 0 then
                    vUserEventHandlers[lPosn] = pRoutine
                else
                    vUserEventHandlers = w32removeIndex(lPosn, vUserEventHandlers)
                    vUserEventsHandled = w32removeIndex(lPosn, vUserEventsHandled)
                end if
            end for
        end for
end procedure
r_setWinMsgHandler=routine_id("setWinMsgHandler")

--/topic Events
--/func setDefaultProcessing(integer NewId)
--/desc This establishes a replacement routine to handle the Windows default processing,
-- or just returns its current value.
--/ret INTEGER: The previous routine_id for this.
--The Windows Default Processing routine is called whenever a message is received for a control
--that Win32lib does not explicitly handle. Win32lib will pass a number of parameters to
-- this routine. /n
--/li /i "integer id": The win32lib ID for the control. It will be zero if it is not a control
--that was created with win32lib.
--/li /i "integer pSource": A code that indicates the source of the message. It is either kMainMsg or
-- kSubclassedMsg depending on whether it comes from a top-level window or a control within a window
-- respectively.
--/li /i "atom hWnd": The handle to the control.
--/li /i "atom iMsg": The Windows message code.
--/li /i "atom wParam": The first data item for the message code.
--/li /i "atom lParam": The second data item for the message code.
--
-- Pass /w32GetValue to just get the routine_id without setting it.
--
--Example:
--/code
--  function MyDefaultProc(integer id, integer pSource, atom hWnd,
--                         atom iMsg, atom wParam, atom lParam)
--      atom lResult
--
--      if id=0 or pSource=kMainMsg then
--          lResult = w32Func(xDefWindowProc, {hWnd, iMsg, wParam, lParam})
--      else
--          lResult = w32Func(xCallWindowProc, {mySubProc, hWnd, iMsg, wParam, lParam})
--      end if
--
--      return lResult
--  end function
--  VOID = setDefaultProcessing(routine_id("MyDefaultProc"))
--/endcode

global function setDefaultProcessing(integer pNewValue)
integer vOldVal

    vOldVal = r_defaultProcessing
    if pNewValue >= 0 then
        r_defaultProcessing = pNewValue
    end if
    return vOldVal
end function

-----------------------------------------------------------------------------
function DefProcessing(integer id, integer pSource, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
atom lResult

        if id=0 or pSource=kMainMsg then
            lResult = w32Func(xDefWindowProc, {hWnd, iMsg, wParam, lParam})
        else
            lResult = w32Func(xCallWindowProc, {ctrl_Function[id], hWnd, iMsg, wParam, lParam})
        end if

        return lResult
end function
r_defaultProcessing = routine_id("DefProcessing")

-----------------------------------------------------------------------------
function MessageProcessor(integer pSource, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
-- callback routine to handle Window class
-- This routine processes messages sent by Windows
integer
    id,
    lHandledEvent,
    lTemp

object
      result,
      lUserReturn


    -- find the control
    id = getId(hWnd)

    -- not one of mine?
    if id = 0 then
        -- default processing
        return call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam})
    end if

    -- Store current message data on stack.
    vWMI += 1
    if vWMI > length(vWinMsg) then
        vWinMsg &= repeat(0, 16)
    end if
    vWinMsg[vWMI] = {pSource, hWnd, iMsg, wParam, lParam, w32Func(xGetMessageTime,{})}

--  lTemp = ctrl_Type[id]
    lTemp = ctrl_ActualClass[id]
    if sequence(vControlRID[lTemp])
    and vControlRID[lTemp][kCRID_Process]!=-1 then
        lUserReturn = call_func(vControlRID[lTemp][kCRID_Process], {id, pSource, hWnd, iMsg, wParam, lParam})
        if sequence(lUserReturn) then
            -- Remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn) > 0, lUserReturn[1], 0)
        end if
    end if

    -- user can process events that Win32Lib doesn't have handlers for.
    if length(ctrl_Handlers[id][w32HEvent]) > 0
    or length(ctrl_Handlers[Screen][w32HEvent]) > 0 then
        lUserReturn = invokeHandler(id, w32HEvent, {iMsg, wParam, lParam, pSource})
        if sequence(lUserReturn) then
            -- Remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn) > 0, lUserReturn[1], 0)
        end if

    end if

    lHandledEvent = find({id, iMsg}, vUserEventsHandled)
    if lHandledEvent = 0 then
        lHandledEvent = find({Screen, iMsg}, vUserEventsHandled)
    end if
    if lHandledEvent != 0 then
        lUserReturn = call_func(vUserEventHandlers[lHandledEvent],
                                {pSource, hWnd, iMsg, wParam, lParam})
        if sequence(lUserReturn) then
            -- remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn) > 0, lUserReturn[1], 0)
        end if
    end if

    lHandledEvent = find(iMsg, vEventsHandled)
    if lHandledEvent = 0
    or vHandler[lHandledEvent] < 0 then

        ---- Matt Lewis says this fixes some weird bug in windows. ----
        --if ctrl_Type[id] = TabControl and iMsg = WM_NOTIFY then
        --    if w32fetch(lParam, NMHDR_code) = LVN_DELETEALLITEMS then
        --        vWMI -= 1
        --        return 0
        --    end if
        --end if
        -------------------

        -- Let Windows do the default processing
        result = call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam})

    else
        result = call_func(vHandler[lHandledEvent], {id, hWnd, iMsg, wParam, lParam, pSource})
        if result[1] = kSubclassedMsg then
            if length(result) = 2 then
            -- the handler has altered the input parameters
                hWnd   = result[2][1]
                iMsg   = result[2][2]
                wParam = result[2][3]
                lParam = result[2][4]
            end if
            result = call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam})
        else
            if length(result) > 1 then
                result = result[2]
            else
                result = 0
            end if
        end if

        -- Heuristic Optimisation --
        -- Move frequently used events closer to the start of the list.
        vEventCnt[lHandledEvent] += 1
        if lHandledEvent > 1
        and vEventCnt[lHandledEvent-1]+3 < vEventCnt[lHandledEvent] then

            lTemp = vEventsHandled[lHandledEvent-1]
            vEventsHandled[lHandledEvent-1] = vEventsHandled[lHandledEvent]
            vEventsHandled[lHandledEvent] = lTemp

            lTemp = vHandler[lHandledEvent-1]
            vHandler[lHandledEvent-1] = vHandler[lHandledEvent]
            vHandler[lHandledEvent] = lTemp

            lTemp = vEventCnt[lHandledEvent-1]
            vEventCnt[lHandledEvent-1] = vEventCnt[lHandledEvent]
            vEventCnt[lHandledEvent] = lTemp
        end if
    end if

    lUserReturn = invokeHandler(id, w32HAfterEvent, {iMsg, wParam, lParam, result})
    if sequence(lUserReturn) and atom(lUserReturn[1]) then
        result = lUserReturn[1]
    end if
    -- remove last message from stack
    vWMI -= 1
    return result

end function


-----------------------------------------------------------------------------
function WndProc(atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
    return MessageProcessor(kMainMsg, hWnd, iMsg, wParam, lParam)
end function

-----------------------------------------------------------------------------
function SubProc(atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
    return MessageProcessor(kSubclassedMsg, hWnd, iMsg, wParam, lParam)
end function

-----------------------------------------------------------------------------
-- store routine id
procedure get_proc_w32address()
atom id

        -- set WndProcAddress callback
        id = routine_id("WndProc")
        if id = -1 then
            abortErr(Err_WNDPROCNOID)
        end if
        WndProcAddress = call_back(id) -- get 32-bit address for callback

-- NEW! 0.45l
        -- set SubProcAddress callback
        id = routine_id("SubProc")
        if id = -1 then
            abortErr(Err_SUBPROCNOID)
        end if
        SubProcAddress = call_back(id) -- get 32-bit address for callback

end procedure

constant vSHOWWORDS = {
                       "HIDE",
                       "SHOWNORMAL",
                       "NORMAL",
                       "SHOWMINIMIZED",
                       "SHOWMAXIMIZED",
                       "MAXIMIZE",
                       "SHOWNOACTIVATE",
                       "SHOW",
                       "MINIMIZE",
                       "SHOWMINNOACTIVE",
                       "SHOWNA",
                       "RESTORE",
                       "SHOWDEFAULT",
                       "MAX",
                       "FULLSCREEN",
                       "MODAL",
                       "DIALOG"
                      }

constant vSHOWCODES = {
                       SW_HIDE,
                       SW_SHOWNORMAL,
                       SW_NORMAL,
                       SW_SHOWMINIMIZED,
                       SW_SHOWMAXIMIZED,
                       SW_MAXIMIZE,
                       SW_SHOWNOACTIVATE,
                       SW_SHOW,
                       SW_MINIMIZE,
                       SW_SHOWMINNOACTIVE,
                       SW_SHOWNA,
                       SW_RESTORE,
                       SW_SHOWDEFAULT,
                       SW_MAX,
                       w32FullScreen,
                       Modal,
                       Dialog
                      }

-----------------------------------------------------------------------------
--/topic Attributes
--/proc showWindow(window, style)
--/desc Shows a window according to the /i style
--/i window is either a control id or the name of a Window control.
--
-- The /i style flag is one of the following:
--/li SW_HIDE = Hides the window and activates another
--/li SW_NORMAL = Restores the window and activates it
--/li SW_SHOWMINIMIZED = Minimizes the window and activates it
--/li SW_SHOWMAXIMIZED = Maximizes the window and activates it
--/li SW_SHOWNOACTIVATE = Displays the window and doesn't activate it
--/li SW_SHOW = Displays the window and activates it
--/li SW_MINIMIZE = Minimizes the window and activates the next window
--/li SW_SHOWMINNOACTIVE = Minimizes the window and doesn't activate it
--/li SW_SHOWNA = Displays the window and doesn't activate it
--/li SW_RESTORE = Restores the window and activates it
--/li SW_MAX = Maximizes the window and doesn't activate it
--/li w32FullScreen = Makes the window appear without title bar and
-- without borders, and the client area fills the entire screen.
--
--Example:
--/code
--      showWindow(formErrors, SW_HIDE)
--      showWindow("Message List", SW_RESTORE)
--/endcode
global procedure showWindow(object id, object style)
atom hWnd
sequence lProp
integer lPosn

        if sequence(id) then
            id = getNameId(id)
        end if

        if validId(id) = w32False then
            return
        end if

        lPosn = find(upper(style), vSHOWWORDS)
        if lPosn > 0 then
            style = vSHOWCODES[lPosn]
        end if

        hWnd = getHandle(id)
        -- display the window
        if equal(style, w32FullScreen) then
            if atom(ctrl_Specific[id]) then
                ctrl_Specific[id] = w32Func(xGetWindowLong, {hWnd, GWL_STYLE}) & getRect(id)
                VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, WS_POPUP})
            end if
            VOID = w32Func(xShowWindow, {hWnd, SW_MAXIMIZE})

        elsif atom(style) then
            if sequence(ctrl_Specific[id]) then
                lProp = ctrl_Specific[id]
                VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, lProp[1]})
                setRect(id, lProp[2], lProp[3],
                        lProp[4]-lProp[2]-1,
                        lProp[5]-lProp[3]-1, w32True)
                ctrl_Specific[id] = 0
            end if
            VOID = w32Func(xShowWindow, {hWnd, style})
        end if
        if ctrl_Type[id] = Window then
            w32Proc(xUpdateWindow, {hWnd})
        end if

end procedure

global procedure setSWStyle(integer id,integer flag)
    ctrl_Specific[id] = flag
end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc openWindow(window, style)
--/desc Opens a window
--/i window is either a control id, a two-element sequence containing
-- {control id, focus id}, or the name of a Window control.
--
-- If /i window is a /b Window then
-- the /i style flag is one of the following:
--
-- /li /b Normal: Original size.
-- /li /b Minimize: Minimized into the task bar.
-- /li /b Maximize: Fills screen.
-- /li /b Modal: Original size, but no other application window can get
--          focus until this window is closed. Use to emulate modal
--          dialogs.
-- /li Win32 Flag: For example, /b SW_SHOWMINNOACTIVE.
--
-- The openWindow function will trigger an /w32HOpen event before it is opened
-- and a /w32HActivate event after it is opened. /n
-- If the w32HOpen event calls /returnValue(-1), the window is not opened.
--
-- It it possible to specify the control that will get the initial
-- focus when the window opens. To do this, the /i window parameter
-- must be specified in the form {window_id, focus_id}. If the /i focus_id
-- is zero, then the first Edit type control is given focus. If there are
-- no edit boxes, then the first button type control is given focus. If
-- you don't specify the initial focus control, then the control that
-- last had focus in the window is used.
--
--Example:
--/code
--      -- Open the Login window, giving focus to the User ID field.
--      openWindow({formLogin txtUserId}, Normal)
--
--      -- Open the Messages window.
--      openWindow("Message List", Normal)
--
--      -- Open an input form
--      openWindow(vPromptCust,
--               {"Name","~<unknown>"}
--              )
--/endcode

global procedure openWindow(object id, object style)
atom hWnd
object styleFlag
object lFocus
sequence lRBSize
sequence lRect
sequence lID
object lRC
integer lPosn
integer bar

        -- Avoid using this routine if app has ended.
        if vWinMainState = kFinished then
            return
        end if

        if sequence(id) then
            if length(id) = 2 then
                lFocus = id[2]
                id = id[1]
            else
                id = getNameId(id)
                if length(ctrl_Focus_order[id]) > 0 then
                    lFocus = ctrl_Focus_order[id][1]
                else
                    lFocus = -1
                end if
            end if
        else
            lFocus = -1
        end if

        if validId(id) = w32False then
            return
        end if

        if ctrl_Type[id] = Window then

            -- action?
            lRC = invokeHandler(id, w32HOpen, {})
            if equal(lRC, {-1}) then
                -- Ignore this open request.
                return
            end if

            if ctrl_Specific[id] > 0 then
                style = ctrl_Specific[id]
                ctrl_Specific[id] = 0
            end if

            lPosn = find(upper(style), vSHOWWORDS)
            if lPosn > 0 then
                style = vSHOWCODES[lPosn]
            end if
            if equal(style, Modal)
            or equal(style, Dialog) then
                -- Make sure we can't minimize a modal window.
                removeStyle(id, WS_MINIMIZEBOX)
            end if

            -- get the handle
            hWnd = getHandle(id)

            -- convert the parameter to a Win32 flag
            if integer(style) then
                if style > 0 then
                    -- real flag
                    styleFlag = style
                else
                    -- Normal or Modal
                    if isMinimized(id) then
                        styleFlag = SW_RESTORE
                    else
                        styleFlag = SW_SHOWNORMAL
                    end if
                end if
            else
                styleFlag = style
            end if

            -- need to show menubar?
            if ctrl_Menu[id] then
                VOID = w32Func(xDrawMenuBar, {hWnd})
            end if

            -- displaying any tab controls, which may be inside groups or other tabs?
            checkContainersForTabs(id)

            -- display the window
            if atom(styleFlag) then
                VOID = w32Func(xShowWindow, {hWnd, styleFlag})
            else
                showWindow(id, styleFlag)
            end if

            ctrl_Closed[id] = 0

            -- update the window
            VOID = w32Func(xInvalidateRect, {hWnd, NULL, w32True})
            w32Proc(xUpdateWindow, {hWnd})


            -- If this is a "modal" style open, and the window is not already
            -- on the modal stack, save previous modal windows and set this one
            -- as the current modal window.
            if (equal(style, Modal) or equal(style, Dialog))
            and modalWindow != id
            and w32findKey(id, modalStack) = 0 then
                pushModal(id, hWnd, style, length(ActiveEL))
            end if

            -- set focus to the window.
            w32Proc(xSetFocus, {hWnd})
            -- Check if I'm supposed to set focus to a particular control.
            if lFocus >= 0 then

                if lFocus = 0 then
                    for i=1 to length(ctrl_Focus_order[id]) do
                        if find(ctrl_Type[ctrl_Focus_order[id][i]], {EditBox, MleText}) then
                            lFocus = ctrl_Focus_order[id][i]
                            exit
                        end if
                    end for
                    if lFocus = 0 then
                        for i=1 to length(ctrl_Focus_order[id]) do
                            if ctrl_Family[ctrl_Focus_order[id][i]] = BUTTON then
                                lFocus = ctrl_Focus_order[id][i]
                                exit
                            end if
                        end for
                    end if
                    if lFocus = 0 then
                        for i=1 to length(ctrl_Focus_order[id]) do
                            if ctrl_Family[ctrl_Focus_order[id][i]] = COMBO then
                                lFocus = ctrl_Focus_order[id][i]
                                exit
                            end if
                        end for
                    end if
                end if
                if lFocus > 0 then
                    setFocus(lFocus)
                end if
            end if

            -- Save initial control positions if there is any toolbars.
            if AutoReBarSizing then
                for j=1 to length(ctrl_Toolbar[id]) do
                    bar = ctrl_Toolbar[id][j]
                    if ctrl_Type[bar] = ReBar then
                        lRBSize = getCtlSize(bar)

                        lID = findChildren(id)
                        for i=1 to length(lID) do
                            if not find(lID[i][1],ctrl_Toolbar[id])
                            and not find(lID[i][2],{ReBar,ReBarBand,StatusBar,Menu,Popup,MenuItem,MenuSpacer,Pixmap}) then
                                lRect = getRect(lID[i][1])
                                lRect[3] -= lRect[1]
                                lRect[4] -= lRect[2]
                                lRect[2] -= lRBSize[2]
                                ctrl_Init_Posns[bar][1] &= lID[i][1]
                                ctrl_Init_Posns[bar][2] &= {lRect}
                            end if
                        end for
                    end if
                end for
            end if

            -- Now tell the app that we are ready for business.
            VOID = invokeHandler(id, w32HActivate, {})

        end if
end procedure
r_openWindow = routine_id("openWindow")



--/topic Attributes
--/proc centerControl(integer Id, integer RefId)
--/desc Centers /i Id with respect to /i RefId
--
--Example:
--/code
--      centerControl(CustDialog, Screen)
--      centerControl(BtnX, CustDialog)
--/endcode

global procedure centerControl(integer pId, integer pRefId)
    alignControls(pId, {w32VertCentre,w32HorzCentre}, {pRefId})
end procedure

integer vIdleCheck
vIdleCheck = 0

---------------------------------------
--/topic Events
--/func setIdle(integer newvalue)
--/ret INTEGER: CurrentValue
--/desc Possibly sets whether or not the library implements w32HIdle
--/i newvalue is either w32True or w32False /n
--The initial setting is w32False, meaning that w32HIdle is not invoked
-- when the application is idling. To start having this handler invoked,
-- you need to setIdle(w32True). Pass /w32GetValue to return the current status.
--
--example
--/code
--  integer x
--  x = setIdle(w32True)
--/endcode
global function setIdle(integer pNewValue)
integer vOldVal

        vOldVal = vIdleCheck
        if pNewValue != w32GetValue then
            vIdleCheck = (pNewValue != 0)
        end if
        return vOldVal
end function

--/topic Events
--/func setEventLoop(integer NewId, object UserData)
--/desc This establishes an replacement event loop.
--/ret SEQUENCE: The previously set values = {message handler routine id, user data}
--There may be situations in which the Windows Message handler loop, built into Win32lib,
--is not adequate for your needs. If so, you can call this function to supply an alternative
--message handler.
--
--/i NewId is the routine_id of your routine that will be called by Win32lib to process
-- Windows Messages.
--
--/i UserData can be anything. It is passed back to your routine by Win32lib on each call.
--Win32lib does not alter it at anytime.
--
--Win32lib calls the message handler from within the /MainWin() routine to begin processing
-- messages received from Windows. It also calls it when you use /openDialog(). The replacement
--message handler will receive the /i UserData value every time it is called by Win32lib. /n
--
--Example:
--/code
--  integer OldHandler
--  procedure myMsgHandler(sequence Parms)
--      . . . your code goes here . . .
--  end procedure
--  OldHandler = setEventLoop(routine_id("myMsgHandler"), {})
--/endcode
object vELUserData vELUserData = {} -- Used internally as parameters when calling eventLoop.

global function setEventLoop(integer pNewValue, object pUserData)
sequence vOldVal

        vOldVal = {r_eventLoop, vELUserData}
        r_eventLoop = pNewValue
        vELUserData = pUserData

        return vOldVal
end function

integer vWmQuit vWmQuit=0 -- Matt Lewis, Jul 8, 2005
    -- this var enables doEvents() to tell the event loop that a WM_QUIT message was posted
include version.e   -- added CChris, June 15, 2007, on a tip by Jonas Temple
--/* -- PL 29/4/09
constant euVersion = getEuVersion()
constant has_tasking = (euVersion[1]>2 or euVersion[3]>=5)
--*/

procedure eventLoop(object pData)
atom msg
atom getRC
integer el
integer lTock

--/**/  if object(pData) then end if -- PL 29/4/09
        ActiveEL &= 0
        el = length(ActiveEL)

        -- Allocate a message buffer
        msg = w32acquire_mem(0, SIZEOF_MSG)
        lTock = 0
        -- message loop
        while ActiveEL[el] = 0
        and vWinMainState = kStarted
        and vWmQuit=0 do

            if vIdleCheck then
                while w32Func(xGetQueueStatus, {QS_ALLEVENTS}) = 0 do
                    lTock += 1
                    if sequence(invokeHandler(Screen, w32HIdle, {lTock, msg})) then
                        -- The user wishes to stop being idle and instead
                        -- use the data they have loaded into the msg structure.
                        lTock = -2
                        exit
                    end if
                end while

                if lTock >= 0 then

                    getRC = w32Func(xPeekMessage, {msg, 0, 0, 0, PM_REMOVE})
                    if getRC > 0 and peek4u(msg+4) = WM_QUIT then
                        exit
                    end if
                    -- I've decided to ignore the undocumented windows message WM_SYSTIMER ('280')
                    -- so it won't stop the idling tock counting.
                    if lTock > 0 and peek4u(msg+4) != WM_SYSTIMER then
                        -- Signal end of idleness period.
                        VOID = invokeHandler(Screen, w32HIdle, {-1, msg})
                        lTock = 0
                    end if
                else
                    lTock = 0
                end if

            else
                getRC = w32Func(xGetMessage, {msg, 0, 0, 0})
                if getRC = 0
                or getRC = -1 then
                    exit
                end if
            end if

            -- Gather some entropy for the random integer routine
            w32Seed = remainder((w32Seed * peek4u(msg+16))
                                + 1 + peek4u(msg+20) * peek4u(msg+24),
                                #FFFFFFFF)

            w32Proc(xTranslateMessage, {msg})
            w32Proc(xDispatchMessage, {msg})
--PL 29/4/09::
----/*
--          if has_tasking then
--              task_yield()
--          end if
----*/
        end while

        w32release_mem(msg)
        ActiveEL = ActiveEL[1..length(ActiveEL)-1]

end procedure
r_eventLoop = routine_id("eventLoop")

--/topic Events
--/proc doEvents(integer id)
--/desc Gives control back to windows until there are no pending events to process.
-- /i id is usually zero, meaning that events for all controls are processed,
-- however you can limit this to a particular control by supplying it id.
--
-- Typically this is used inside user written event handlers when they know
-- that they might take a long time to complete. For example, if by clicking
-- a button the application must scan through all the files on a disk, it
-- would be appropriate to include a doEvents() call inside the inner loop
-- so that other windows events can be processed during the file search. If
-- this isn't done, no control or window belonging to the application will
-- respond until the disk scan is conpleted. For example, there might be
-- another button that the user can click to abort the disk scan. Without
-- doEvents() this would only respond after the disk scan is completed!
global procedure doEvents(integer id)
atom msg, hWnd

        if vWinMainState != kStarted then
            return
        end if

        if id = 0 then
            hWnd = 0
        else
            if validId(id) = w32False then
                return
            end if
            hWnd = getHandle(id)
        end if

        -- Allocate a message buffer
        msg = w32acquire_mem(0, SIZEOF_MSG)

        if w32Func(xPeekMessage, {msg, hWnd, 0, 0, PM_REMOVE}) then
            if peek4u(msg+4) = WM_QUIT then
                -- tell event loop to quit
                vWmQuit = 1
            end if
            w32Proc(xTranslateMessage, {msg})
            w32Proc(xDispatchMessage, {msg})
--PL 29/4/09::
--/*
--          if has_tasking then
--              task_yield()
--          end if
--*/
        end if
        w32release_mem(msg)

end procedure
r_doEvents = routine_id("doEvents")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc openDialog(object id)
--/desc Opens a window, /i id, as a modal dialog.
--The /i id is either a control id, a two-element sequence containing
-- {control id, focus id}.
--
---There is a difference between this and /openWindow(..., Modal).
-- Here's some examples.... /n
--
--/code
--    while length(filename) = 0 do
--        openWindow(myFileDialog, Modal)
--    end for
--/endcode
--and /n
--/code
--    while length(filename) = 0 do
--        openDialog(myFileDialog)
--    end for
--/endcode
--
--In the first snippet, this would start a very tight loop in which the user
--could not enter data. This is because the /openWindow() would execute
--and /b not wait for the user to enter any data into the new window before
--executing the /i while test again. Whereas the openDialog() routine opens
-- a modal window then /b waits for that window to close before executing
--the line after the openDialog() statement. During this time, any event
--handlers set up for the dialog window would still fire correctly.

global procedure openDialog(object id)

integer lFocus

        lFocus = -1
        if sequence(id) then
            lFocus = id[2]
            id = id[1]
        end if

        if validId(id) = w32False or ctrl_Type[id] != Window then
            return
        end if

        if lFocus != -1 then
            openWindow({id,lFocus}, Dialog)
        else
            openWindow(id, Dialog)
        end if

        if ctrl_Closed[id] then
            return
        end if

        call_proc(r_eventLoop,{vELUserData})
        closeWindow(id)

end procedure
r_openDialog = routine_id("openDialog")

function DetermineMainWindow()
integer id

        if ctrl_Type[3] = Window then
            -- If its a window, then this becomes the main window.
            id = 3
        else
            -- otherwise search for the first created window.
            id = 0
            for i = length(ctrl_Type) to 4 by -1 do
                if ctrl_Type[i] = Window then
                    id = i
                    exit
                end if
            end for

            -- Don't do anything if there is no window.
        end if
        return id
end function

integer r_ResolveDeferredHandlers
-----------------------------------------------------------------------------
--/topic System Attributes
--/proc WinMain(window, style)
--/desc Run event loop.
-- This is the main processing loop for Win32Lib. Call WinMain after
-- all the controls and their handlers have been defined for the initial
-- running of the application.
--
-- The main window is set to /i window. When /i window is closed,
-- the application is shut down. /b Note that if /i window is -1 then
-- the first window defined is used as the primary window.
--
-- If you wish to have an application that has /b no window under the
-- control of win32lib, but still wish to use its Windows Message loop,
-- then set /i window as 0.
--
-- The /i style flag is one of the following:
--
-- /li /b Normal: Original size.
-- /li /b Minimized: Minimized into the task bar.
-- /li /b Maximized: Fills the client area of the screen.
--
-- The WinMain function will open the application's main window.
--
-- It it possible to specify the control that will get the initial
-- focus when the window opens. See /openWIndow for details.
--
-- For example:
--/code
--      -- set MyWindow as main window, open normally
--      -- with the initial focus on the Login button.
--      /WinMain({MyWindow, btnLogin}, Normal)
--/endcode

global procedure WinMain(object id, integer style)
integer lInitFocus

        -- Don't rerun this once it has finished.
        if vWinMainState != kNotStarted then
            return
        end if
        vWinMainState = kStarted

        if sequence(id) then
            lInitFocus = id[2]
            id = id[1]
        else
            lInitFocus = -1
        end if
        -- create the default window
        if id = -1 then
            id = DetermineMainWindow()
        end if

        VOID = setMainWindow(id)
        pushSelf(id)

        -- Time to resolve any deferred event handler references.
        if r_AppCallback >= 0 then
            call_proc(r_ResolveDeferredHandlers,{})
        end if

        -- Automatically initialize all control sets as hidden.
        if length(vControlSets) > 0 then
            hideControlSet(0)
            showControlSet(1)
        end if

        openWindow({id,lInitFocus}, style)

        -- Start processing the message events.
        call_proc(r_eventLoop, {vELUserData})

        if id != 0 then
            releaseAllResources(0)
        end if
end procedure

global constant w32NoCallBack = -1

--/topic Events
--/proc startApp(object CallbackRtns)
--/desc Start the application running.
--This opens the main window, setting focus on the first 'focusable' control
-- and then handles over control to Windows.
--
--The /i CallbackRtn parameter is either a single routine_id or a list of three routine_ids. /n
-- If it is a single routine_id is can be either /w32NoCallBack or the routine id
-- of a callback routine inside your application. See /setCallback for more
-- details.
--
-- If /i CallbackRtns is a list of three routine_ids, it takes the format of ... /n
-- /li integer AppCallback: Same as the single routine_id version above.
-- /li integer AlternateCAllback: If /i AppCallback is -1 then this is used instead.
-- /li integer AppMain: Either -1, or a routine_id of a routine that is called prior
-- to the library start up. The /i AppMain routine is passed a single sequence, which
-- is the command_line() parameters. If /i AppMain returns a zero then the library
-- continues executing otherwise the library stops immediately.
--
--Example:
--/code
--  startApp({routine_id("AppCallback"), routine_id("LocalCallback"), routine_id("AppMain")})
--/endcode

global procedure startApp(object pCallBack_rid)
integer id
integer lCallBack_rid
integer lAltCallBack_rid
integer lMain_rid

        if atom(pCallBack_rid) then
            lCallBack_rid = pCallBack_rid
            lAltCallBack_rid = -1
            lMain_rid = -1
        else
            lCallBack_rid = pCallBack_rid[1]
            lAltCallBack_rid = pCallBack_rid[2]
            lMain_rid = pCallBack_rid[3]
        end if

        if lMain_rid >= 0 then
            if call_func(lMain_rid, {command_line()}) != 0 then
                return
            end if
        end if

        if length(ctrl_Type) < 3 then
            -- There is no Main Window defined,
            return
        end if

        if lCallBack_rid >= 0 then
            VOID = setCallback(lCallBack_rid)
        else
            VOID = setCallback(lAltCallBack_rid)
        end if

        -- Check the first Control created after the Screen and Printer.
        if mainWindow = 0 then
            id = DetermineMainWindow()
            if id = 0 then
                return
            end if

        else
            id = mainWindow
        end if

        -- If the window has any focusable children, select the first one.

        if length(ctrl_Focus_order[id]) > 0 then
            WinMain({id, ctrl_Focus_order[id][1]}, Normal)

        else
            WinMain(id, Normal)

        end if
end procedure

--/topic Events
--/proc closeApp()
--/desc Closes the application down.
-- You can set a handler to trap the close of the main window if you
-- have any last minute activites to do, such as closing databases, etc...
--
--Example:
--/code
--      procedure Click_CloseBtn(integer self, integer event, sequence parms)
--          if message_box("Is it okay to stop now?", "Close", MB_YESNO) = IDYES
--              closeApp()
--          end if
--      end procedure
--      setHandler(CloseBtn, w32HClick, routine_id("Click_CloseBtn"))
--
--/endcode
global procedure closeApp()
    if mainWindow != 0 then
        closeWindow(mainWindow)
    end if
end procedure


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setHintEx(object control, object text, atom exflags)
--/desc Set the tooltip text for a control.
-- This is identical to /setHint() except that you can use extra flags
-- when creating the tooltip for a control. These flags are those whose names starts with TTF_.
--
-- Example:
--/code
--      -- set hint for CloseButton
--      /setHintEx(CloseButton, "Closes the window", TTF_CENTERTIP)
--/endcode

global procedure setHintEx(object id, object text, atom exflags)
atom ti, lTTflags, lTTmsg
integer parentId
integer lPart

        lPart = 0
        if sequence(id) then
            if length(id) = 2 then
                lPart = id[2]
                id = id[1]
                if not validId(id) then
                    return
                end if
                if ctrl_Type[id] != StatusBar then
                    return
                end if
                if atom(text) then
                    text = sprintf("routine_id %g not supported.", text)
                end if
                VOID = sendMessage(id, SB_SETTIPTEXT, lPart, text)
            end if
            return
        end if

        -- Doesn't hurt to check.
        if not validId(id) then
            return
        end if

        -- Special code to set replicate the hint in a Combo's edit area.
        ti = getEdit(id)
        if ti then -- I own an edit area.
            setHintEx(ti, text, exflags)
        end if

        parentId = findParent(id)
        if parentId = 0 then -- Use myself if I'm the top-level window.
            parentId = id
        end if

        ctrl_Hint_Text[id] = text

        -- First time thru, create the tooltip control to manage hints.
        if not tooltipControl then
            tooltipControl = createEx(ToolTip, "", 0, 0, 0, 0, 0, 0, 0)
        end if


        if atom(text) or length(text) then
            -- adding a tip
            lTTflags = w32or_all({TTF_SUBCLASS, TTF_IDISHWND, exflags})
            lTTmsg   = TTM_ADDTOOL

        else
            -- deleting a tip
            lTTflags = 0
            lTTmsg   = TTM_DELTOOL

        end if

        ti = w32to_memory(0,ID_TOOLINFO, {
                                          lTTflags,
                                          ctrl_Handle[parentId],
                                          ctrl_Handle[id],
                                          {0,0,0,0},0,
                                          LPSTR_TEXTCALLBACK -- text
                                         })

        VOID = sendMessage(tooltipControl, lTTmsg, 0, ti)
        VOID = sendMessage(tooltipControl, TTM_SETMAXTIPWIDTH, 0,
                           ctrl_Hint_Width[id])
        w32release_mem(ti)
end procedure
r_setHintEx = routine_id("setHintEx")

constant TTDT={TTDT_INITIAL,TTDT_AUTOPOP,TTDT_RESHOW}

--/topic System Attributes
--/func setTooltipTiming(integer id,object timings)
--/desc Possibly sets the timings for all the tooltips the tooltip conrol /i id manages.
--/ret The previous or current values.
-- Three durations are associated to a tooltip. If /i timings is a sequence, its elements are:
--/li the initial delay (in miliseconds) during which the mouse must hover for the tooltip window to pop up;
--/li the autopop duration, in miliseconds: this is the time during which the tooltip window remeinas visible;
--/li the reshow delay, in milliseconds: delay from a change of hovered upon control and
-- and the next popping up of a tooltip window for the new target control.
-- For each of these, use w32False to set to default and w32GetValue to return without setting.
-- If /i timings is a positive integer, the initial delay is set to the supplied value, the autopop duration 
--  to ten times the initial delay, and the reshow delay to a fifth of the initial delay. Using w32False will
--  return the values to default - 500, 5000 and 100ms respetivelly. Using w32GetValue will skip any setting.
-- At any rate, the three timings are returned.

global function setTooltipTimings(integer id,object timings)
sequence result

        if ctrl_Type[id]!=ToolTip then
            return {}
        end if
        result={sendMessage(id,TTM_GETDELAYTIME,TTDT_INITIAL,0),
                sendMessage(id,TTM_GETDELAYTIME,TTDT_AUTOPOP,0),
                sendMessage(id,TTM_GETDELAYTIME,TTDT_RESHOW,0)}
        if atom(timings) then
            if timings>0 then
                VOID=sendMessage(id,TTM_SETDELAYTIME,TTDT_AUTOMATIC,timings)
            elsif timings!=w32GetValue then
                VOID=sendMessage(id,TTM_SETDELAYTIME,TTDT_AUTOMATIC,-1)
            end if
        else
            for i=1 to 3 do
                if timings[i]>0 then
                    VOID=sendMessage(id,TTM_SETDELAYTIME,TTDT[i],timings[i])
                elsif timings[i]!=w32GetValue then
                    VOID=sendMessage(id,TTM_SETDELAYTIME,TTDT[i],-1)
                end if
            end for
        end if
        return result
end function

--/topic System Attributes
--/func manageToolTip(integer pAction, integer pNewControl)
--/desc Helps manage the ToolTip controls.
--/ret The current tooltip control id.
-- Use this to activate or deactivate the current tooltip control, or
-- to just get the id of the current tooltip control.
--
-- Set /i pAction to /b 1 to activate tooltips or /b 0 to deactivate them.
-- Any other value has no effect. /n
-- In all cases, the id of the current tooltip control is returned.
global function manageToolTip(integer pAction, integer pNewControl)
integer lOldToolTip

        lOldToolTip = tooltipControl

        -- See if a new control needs to be installed.
        if pNewControl > 0
        and ctrl_Family[pNewControl] = ToolTip then
            VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 0, 0)
            tooltipControl = pNewControl
            VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 1, 0)
        end if

        -- Activate/Deactivate the current tooltip control.
        if pAction = 1 then
            VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 1, 0)
        elsif pAction = 0 then
            VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 0, 0)
        end if

        return lOldToolTip

end function

--/topic Attributes
--/proc setHint(object control, object text)
--/desc Set the tooltip text for a control.
-- If the mouse stays still over a control that has tooltip text
-- associated with it, a small window displaying the tooltip text will
-- appear.
--
-- Any control that can get mouse events can have tooltips associated with
-- it, although it tends to work best with /PictureButtons, typically
-- in the /ToolBar.
--
-- Setting the text to "" effectively removes the tooltip.
--
-- /b Note: When setting tooltips for multipanelled StatusBar controls,
-- you need to specify which panel the tip applies to. You do this by
-- setting the /i control parameter as a sequence in the form {id, panel}
-- where /i id is the StatusBar control and /i panel is the panel number.
--
-- It is possible to dynamically set the text of a tooltip so that each time
-- the control needs to display a tip, it first calls a routine of your own
-- that must supply the text to display. To do this, set the /i text parameter
-- to the routine_id of your function. Your /b function will receive two parameters:
-- (id, width) where /i id is the control that needs a tip, and /i width is the
-- width of the tooltip box that will be used (in pixels). Your function must
-- return a /b sequence. That sequence can simply be the tip text, or a 2-element
-- sequence in the form {tiptext, newwidth}.
--
-- Example:
--/code
--      -- set hint for CloseButton
--      setHint(CloseButton, "Closes the window")
--
--      function gettip(integer id, integer width)
--      sequence newtext
--      sequence AccountRecord
--
--          AccountRecord = getAccountFromName(getText(id))
--          if length(AccountRecord) > 0 then
--              newtext = sprintf("Account %d has a balance of %12.2f",
--                                {AccountRecord[fAcctNo],
--                                 AccountRecord[fCurBal]})
--          else
--              newtext = "No account found for this name."
--          end if
--          return newtext
--      end function
--      setHint(txtAccountName, routine_id("gettip"))
--/endcode


global procedure setHint(object id, object text)
        setHintEx(id, text, 0)
end procedure

--/topic Attributes
--/func getHint(integer id)
--/desc Find the hint text for a control, or the caption for a flattoolbar button
--/ret Any Tool Tip text associated with this /i id
global function getHint(integer id)
        return ctrl_Hint_Text[id]
end function


--/topic Attributes
--/func setHintWidth(integer id, integer width)
--/desc Possibly sets the maximum width, in pixels, of the control's tooltip box.
--/ret INTEGER: Current width setting.
-- Pass a negative value to just return the current maximum width.
global function setHintWidth(integer id, integer width)
integer lWidth

        lWidth = ctrl_Hint_Width[id]
        if width >= 0 then
            ctrl_Hint_Width[id] = w32iff(width > 0, width, 0)
        end if
        return lWidth
end function

--/topic Utilities
--/func hitTestTT()
--/desc Tests to see if the mouse is currently over a control that has a tooltip.
--/ret w32False or the id of a control.
global function hitTestTT()
atom ht, ok, tools
integer id,parentId
sequence pt, op, mouse

        ht = w32acquire_mem(0, SIZEOF_TTHITTESTINFO)

        mouse = getPointerPos()

        tools = sendMessage(tooltipControl, TTM_GETTOOLCOUNT, 0, 0)

        id = 1
        ok = 0
        for i=1 to tools do
            -- only look at Ids that have some tooltip text.
            while not length(ctrl_Hint_Text[id]) do
                id += 1
            end while

            -- get its parent. NB, Top-level controls are their own parent.
            parentId = ctrl_Parent[id]
            if parentId = 0 then
                parentId = id
            end if

            w32store(ht, TTHITTESTINFO_hwnd, ctrl_Handle[parentId])

            op = getClientPoint(parentId, 0, 0)
--/**/      pt = sq_sub(mouse,op)                   --/* Pve
            pt = mouse - op                         -- RDS */

            w32store(ht, TTHITTESTINFO_pt, pt)

            ok = sendMessage(tooltipControl, TTM_HITTEST, 0, ht)

            if ok then
                ok = w32fetch(ht, {TTHITTESTINFO_ti, TOOLINFO_uId})
                exit
            end if

            id += 1
        end for


        w32release_mem(ht)

        return ok

end function


------------------------------------------------------------------------------
--/topic Utilities
--/func shellExecuteEx(object verb, sequence file, object params, object defdir, object style, atom struct)
--/desc Launch a Windows application
--/ret ATOM: Success code. 0 to 32 are errors; successful invocation returns a process handle.
--
-- This is a wrapper around the Win32 /b ShellExecute command.
--
-- The /i verb parameter is the action you are trying to execute. In nearly
-- all cases this is "open". The actions possible are defined in your Windows
-- File Associations definitions. If this parameter is not a sequence then
-- the default action for the /i file is used.
--
-- The /i file parameter is the file to perform the action upon. This is
-- usually a .EXE file but can be any file type that has a defined action in
-- the Window File Associations.
--
-- The /i params is a list of zero or more parameters passed to the file.
-- Usually when opening an EXE file, this is the parameters for that program.
--
-- The /i defdir is the default directory to change to before openning the
-- file. If this is not a sequence the the current directory is used.
--
-- The /i style parameter is a window style flag.
-- These can be ... /n
--/li SW_HIDE
--/li SW_SHOWNORMAL
--/li SW_NORMAL
--/li SW_SHOWMINIMIZED
--/li SW_SHOWMAXIMIZED
--/li SW_MAXIMIZE
--/li SW_SHOWNOACTIVATE
--/li SW_SHOW
--/li SW_MINIMIZE
--/li SW_SHOWMINNOACTIVE
--/li SW_SHOWNA
--/li SW_RESTORE
--/li SW_SHOWDEFAULT
--/li SW_MAX
--
-- The /i struct parameter is not used yet.
--
-- The return codes for this function are... /n
--/li SE_ERR_FNF                    -- file not found
--/li SE_ERR_PNF                    -- path not found
--/li SE_ERR_ACCESSDENIED           -- access denied
--/li SE_ERR_OOM                    -- out of memory
--/li SE_ERR_SHARE
--/li SE_ERR_ASSOCINCOMPLETE
--/li SE_ERR_DDETIMEOUT
--/li SE_ERR_DDEFAIL
--/li SE_ERR_DDEBUSY
--/li SE_ERR_NOASSOC
--/li SE_ERR_DLLNOTFOUND

global function shellExecuteEx(object verb, sequence file, object parms,
                  object defdir, atom style, atom struct)
-- call ShellExecuteEx to display a file
atom mset, parms_p, file_p, verb_p, defdir_p
atom hWnd
integer rc

--/**/  if struct then end if -- suppress warnings (PL 29/4/09)
        if validId(mainWindow) then
            hWnd = getHandle(mainWindow)
        else
            warnErr("shellExecute requires a WinMain()")
            return 0
        end if

        -- convert to strings
        mset = w32new_memset()
        if atom(verb) or length(verb) = 0 then
            verb_p = 0
        else
            verb_p = w32acquire_mem(mset, verb)
        end if

        if atom(parms) or length(parms) = 0 then
            parms_p = 0
        else
            parms_p = w32acquire_mem(mset, parms)
        end if

        file_p  = w32acquire_mem(mset, file)

        if atom(defdir) or length(defdir) = 0 then
            defdir_p = 0
        else
            defdir_p = w32acquire_mem(mset, defdir)
        end if

        -- call ShellExecute
        rc = w32Func(xShellExecute, {hWnd, verb_p, file_p, parms_p, defdir_p, style})

        w32release_mem(mset)

        return rc
end function

------------------------------------------------------------------------------
--/topic Utilities
--/proc shellExecute(command, file, style)
--/desc Launch a Windows application
--
-- This is a wrapper around the Win32 /b ShellExecute command.
-- /i command is usually "open". /n
-- /i file is the file or directory to open or run. /n
-- /i style is usually SW_SHOWNORMAL, but can be SW_SHOWMINIMIZED or
-- SW_SHOWMAXIMIZED
--
--/code
--       -- Start up MSAcess on the database.
--       shellExecute("open", "myDB.mdb", SW_SHOWNORMAL)
--/endcode
global procedure shellExecute(object verb, sequence file, atom style)

        VOID = shellExecuteEx(verb, file, "", "", style, 0)

end procedure

-----------------------------------------------------------------------------
------------------------------------------------------------------------------
--/topic Utilities
--/func playSound(sequence FileParm)
--/desc Play the .WAV file.
--/ret /b w32True if succeeds, /b w32False if fails.
-- This is a wrapper around the Win32 /b PlaySound command. /n
-- /i FileName can take one of four forms. /n
-- /li The value 0 or an empty sequence. Use this to immediately stop playing
-- any sound.
-- /li A simple filename, such as a ".WAV" file to play. This sets up the
-- flags as SND_FILENAME and SND_ASYNC. /n
-- /li The form {FileName, Flags} which gives you more control over the flag settings.
-- The /i Flags can be either a single atom or a sequence of sound flags.
--/li The form  {FileName, Flags, ResourceId} is available the sound you need to
-- play is contained in the resources of an executable file. In this case /i FileName
-- is is a sequence with one element in it; a handle to an executable file. /i ResourceId
-- is the id of the resource to play.
--
--Example:
--/code
--      -- Play a sound file and return before it ends.
--      VOID = playSound("announce.wav")
--
--      -- Play a sound file and wait until it ends.
--      VOID = playSound({"announce.wav",{SND_FILENAME,SND_SYNC})
--
--      -- Play a sound file continuously in the background
--      VOID = playSound({"background.wav", {SND_FILENAME,SND_ASYNC,SND_LOOP})
--
--      -- Play a sound file but only if no other sound is already playing.
--      VOID = playSound({"hit.wav",{SND_FILENAME,SND_ASYNC,SND_NOSTOP})
--
--      -- Play a sound named in the system registry.
--      VOID = playSound({"MailBeep",{SND_ALIAS})
--
--      -- Stop playing any sound.
--      VOID = playSound({"",SND_PURGE})
--      -- or
--      VOID = playSound(0)
--
--/endcode
global function playSound(object pFileParms)
atom lFlags
atom lResource
object lFileName

        lResource = 0
        if atom(pFileParms) or length(pFileParms) = 0 then
            lFlags = SND_PURGE
            lFileName = ""

        else
            if sequence(pFileParms[1]) then
                lFileName = pFileParms[1]
                if length(pFileParms) >= 2 then
                    if sequence(pFileParms[2]) then
                        lFlags = w32or_all(pFileParms[2])
                    else
                        lFlags = pFileParms[2]
                    end if
                end if

                if length(pFileParms) >= 3 then
                    lResource = pFileParms[3]
                    lFlags = or_bits(lFlags, SND_RESOURCE)
                    lFileName = pFileParms[1][1]
                end if

            else
                lFileName = pFileParms
                lFlags = or_bits(SND_FILENAME, SND_ASYNC)

            end if
        end if

        -- play the sound
        return w32Func(xPlaySound, {lFileName, lResource, lFlags})

end function

--/topic Miscellaneous
--/proc Beep(atom style)
--/desc Sounds one of the standard beeps.
--
--/i style can be one of ... /n
--/li -1  Standard beep using the computer speaker
--/li MB_ICONASTERISK SystemAsterisk
--/li MB_ICONEXCLAMATION SystemExclamation
--/li MB_ICONHAND SystemHand
--/li MB_ICONQUESTION SystemQuestion
--/li MB_OK
--
--Example
--/code
--  Beep(MB_ICONEXCLAMATION)
--/endcode

global procedure Beep(atom pStyle)
        VOID = w32Func(xBeep, {pStyle})
end procedure



-----------------------------------------------------------------------------
function libCleanUp(integer pErrCode, sequence pDispMsg, integer pN, integer pLast)
-----------------------------------------------------------------------------
--/**/  if pErrCode or sequence(pDispMsg) or pN or pLast then end if -- suppress warnings (PL 29/4/09)
        releaseAllResources(1)
        return 0
end function
r_libCleanUp = routine_id("libCleanUp")

-----------------------------------------------------------------------------
procedure initialize()
-----------------------------------------------------------------------------
-- various housekeeping tasks

        setStartupFont(ANSI_VAR_FONT)  -- sets usual 'tiny' default font
        -- Create the screen and printer controls
        setControlBlocks(2)
        Screen  = createEx(Screen_, "", 0, 0, 0, 0, 0, 0, 0)
        Printer = createEx(Printer_, "", 0, 0, 0, 0, 0, 0, 0)
        setControlBlocks(16)

        -- get the proc address
        get_proc_w32address()

        -- set the 'clean up' behavior
        VOID = attachCleanUp(r_libCleanUp)

end procedure


---------------------------
procedure checkPopup(integer self, integer event, sequence parms)
---------------------------
atom shifts
object lMenu
integer lOffsetX
integer lOffsetY

--/**/  if event then end if -- suppress warning (PL 29/4/09)
        shifts = parms[4]
        lOffsetX = -6
        lOffsetY = -6

        if parms[1] = WM_RBUTTONDOWN then

            if and_bits(shifts, ShiftMask + ControlMask) = (ShiftMask + ControlMask) then
                lMenu = ctrl_Popup[self][4]

            elsif and_bits(shifts, ShiftMask) = ShiftMask then
                lMenu = ctrl_Popup[self][2]

            elsif and_bits(shifts, ControlMask) = ControlMask then
                lMenu = ctrl_Popup[self][3]

            else
                lMenu = ctrl_Popup[self][1]
            end if

            if sequence(lMenu) then
                if length(lMenu) >= 3 then
                    lOffsetY = lMenu[3]
                end if
                if length(lMenu) >= 2 then
                    lOffsetX = lMenu[2]
                end if

                lMenu = lMenu[1]
            end if

            if not equal(lMenu,-1) then
                popup({lMenu,self}, parms[2]+lOffsetX, parms[3]+lOffsetY)
            end if
        end if

end procedure


--/topic Menus
--/func attachPopup(integer pId, object pMenus)
--/desc Associates one or more menus to a control as popup or context menus.
--/ret SEQUENCE: Previously attached menus.
--This will cause the menu(s) supplied in /i pMenu to be linked to
-- the control /i pId such that when the righthand mouse button is pressed,
-- the menu will pop up next to the mouse pointer. /n
-- You can have different menus popup depending on the combination of
-- Ctrl and Shift keys you have pressed. You do this by supplying up to four
-- menu ids in /i pMenu, one for no keys pressed, one for shift key, one for
-- control key, and another for both shift and control keys pressed.
--
-- Each value in /i pMenu is either a Menu id, 0, -1, or a sequence
-- of the form {MenuId, XOffset, YOffset}. /n
-- If a simple menu id, then this is the popup menu that will display when
-- the user right-clicks in the control. /n
-- If -1, then the corresponding current value is retained. Use this to
-- skip over setting previous values of menu ids. /n
-- If 0, then the corresponding menu id is cleared and the popup will /b
-- not display. /n
-- If a sequence, then the /i XOffset and /i YOffset are used to position
-- the menu relative to the mouse pointer. The default values are -6 and -6
-- respectively. Use this when you need the menu to be shown is different
-- position.
--
--First you need to define the menus and any handlers for them, then you
-- can attach them to one or more controls.
--
--Example
--/code
--      -- Define two menus.
--      MenuOne = create(Menu, "One", MainWindow, 0, 0, 0,0, 0)
--        M1_Item1 = create(MenuItem, "Item 1.1", MenuOne, 0, 0, 0,0, 0)
--        M1_Item2 = create(MenuItem, "Item 1.2", MenuOne, 0, 0, 0,0, 0)
--        M1_Item3 = create(MenuItem, "Item 1.3", MenuOne, 0, 0, 0,0, 0)
--      MenuTwo = create(Menu, "Two", MainWindow, 0, 0, 0,0, 0)
--        M2_Item1 = create(MenuItem, "Item 2.1", MenuTwo, 0, 0, 0,0, 0)
--        M2_Item2 = create(MenuItem, "Item 2.2", MenuTwo, 0, 0, 0,0, 0)
--        M2_Item3 = create(MenuItem, "Item 2.3", MenuTwo, 0, 0, 0,0, 0)
--      setHandler(M1_Item1, w32HClick, routine_id("Click_Item11"))
--      setHandler(M1_Item2, w32HClick, routine_id("Click_Item12"))
--      setHandler(M1_Item3, w32HClick, routine_id("Click_Item13"))
--      setHandler(M2_Item1, w32HClick, routine_id("Click_Item21"))
--      setHandler(M2_Item2, w32HClick, routine_id("Click_Item22"))
--      setHandler(M2_Item3, w32HClick, routine_id("Click_Item23"))
--
--  -- Now attach popups for normal and ctrl keys
--  prevMenus = attachPopup(SomeFld,
--                {MenuOne, -- Normal (no keys)
--                  -1,      -- ignore Shift
--                  -- Note the changed X-Y offsets.
--                  {MenuTwo,-20,-10}  -- Ctrl key
--                 })
--
--/endcode
global function attachPopup(integer pId, object pMenus)
sequence lOldValues
integer  lCount

        -- Save current values
        lOldValues = ctrl_Popup[pId]

        -- fixup the case when only one menu id is supplied.
        if atom(pMenus) then
            pMenus = {pMenus}
        end if

        -- only process up to the 4th menu id.
        lCount = length(pMenus)
        if lCount > 4 then
            lCount = 4
        end if

        -- Update the control's popup values
        for i=1 to lCount do
            if pMenus[i] = -1 then
                -- Retain previous value

                pMenus[i] = lOldValues[i]

            elsif pMenus[i] = 0 then
                -- Detach this specific combination.
                pMenus[i] = -1
            end if
            ctrl_Popup[pId][i] = pMenus[i]
        end for

        -- Add a handler to trap right-mouse presses for this control.
        setHandler(pId, w32HMouse, {-2,  routine_id("checkPopup")})

        return lOldValues
end function
r_attachPopup = routine_id("attachPopup")


integer fn_debug fn_debug = 1
global constant w32DebugLog = -1772
global procedure wDebug(sequence pData)

        if length(pData) = 2 then
            if sequence(pData[1]) then
                printf(fn_debug, pData[1], pData[2])
            else
                if pData[1] = w32DebugLog then
                    if fn_debug > 2 then
                        close(fn_debug)
                    end if
                    fn_debug = w32FileOpen(pData[2], "w")
                    if fn_debug < 0 then
                        fn_debug = 1
                    end if
                end if
            end if
        else
            puts(fn_debug, w32ToString(pData))
            if not equal(pData[length(pData)], '\n') then
                puts(fn_debug, '\n')
            end if
        end if
end procedure
r_wDebug = routine_id("wDebug")


--include w32forms.ew
--------------------NOTICE-------------------------------*
-- Software ID: w32forms.ew
-- Version:     0.60
-- Copyright:   (c) 2000 David Cuny and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*



--include w32support.e

sequence vRecentNewUI vRecentNewUI = {}

constant vWinIconNames = {
    "APPLICATION",
    "ERROR",
    "QUESTION",
    "WARNING",
    "ASTERISK",
    "WINLOGO"
    }


constant vWinFlagValues = {
    WS_OVERLAPPED,
    WS_POPUP,
    WS_CHILD,
    WS_MINIMIZE,
    WS_VISIBLE,
    WS_DISABLED,
    WS_CLIPPINGCHILD,
    WS_CLIPSIBLINGS,
    WS_CLIPCHILDREN,
    WS_MAXIMIZE,
    WS_CAPTION,
    WS_BORDER,
    WS_DLGFRAME,
    WS_HSCROLL,
    WS_VSCROLL,
    WS_SYSMENU,
    WS_THICKFRAME,
    WS_GROUP,
    WS_TABSTOP,
    WS_SCROLLBARS,
    WS_MINIMIZEBOX,
    WS_MAXIMIZEBOX,
    WS_TILED,
    WS_ICONIC,
    WS_SIZEBOX,
    WS_OVERLAPPEDWINDOW,
    WS_TILEDWINDOW,
    WS_POPUPWINDOW,
    WS_CHILDWINDOW,
    BS_3STATE,
    BS_AUTO3STATE,
    BS_AUTOCHECKBOX,
    BS_AUTORADIOBUTTON,
    BS_BITMAP,
    BS_BOTTOM,
    BS_CENTER,
    BS_CHECKBOX,
    BS_DEFPUSHBUTTON,
    BS_GROUPBOX,
    BS_ICON,
    BS_LEFT,
    BS_LEFTTEXT,
    BS_MULTILINE,
    BS_NOTIFY,
    BS_OWNERDRAW,
    BS_PUSHBUTTON,
    BS_PUSHLIKE,
    BS_RADIOBUTTON,
    BS_RIGHT,
    BS_RIGHTBUTTON,
    BS_TEXT,
    BS_TOP,
    BS_USERBUTTON,
    BS_VCENTER,
    ES_LEFT,
    ES_CENTER,
    ES_RIGHT,
    ES_MULTILINE,
    ES_AUTOHSCROLL,
    ES_AUTOVSCROLL,
    ES_DISABLENOSCROLL,
    ES_LOWERCASE,
    ES_NUMBER,
    ES_NUMERIC,
    ES_OEMCONVERT,
    ES_PASSWORD,
    ES_READONLY,
    ES_UPPERCASE,
    ES_WANTRETURN,
    ES_AUTOSCROLL,
    ES_SAVESEL,
    ES_NOHIDESEL,
    LBS_NOTIFY,
    LBS_SORT,
    LBS_NOREDRAW,
    LBS_MULTIPLESEL,
    LBS_OWNERDRAWFIXED,
    LBS_OWNERDRAWVARIABLE,
    LBS_HASSTRINGS,
    LBS_USETABSTOPS,
    LBS_NOINTEGRALHEIGHT,
    LBS_MULTICOLUMN,
    LBS_WANTKEYBOARDINPUT,
    LBS_EXTENDEDSEL,
    LBS_DISABLENOSCROLL,
    LBS_NODATA,
    LBS_NOSEL,
    LBS_STANDARD,
    LVS_ICON,
    LVS_REPORT,
    LVS_SMALLICON,
    LVS_LIST,
    LVS_TYPEMASK,
    LVS_SINGLESEL,
    LVS_SHOWSELALWAYS,
    LVS_SORTASCENDING,
    LVS_SORTDESCENDING,
    LVS_SHAREIMAGELISTS,
    LVS_NOLABELWRAP,
    LVS_AUTOARRANGE,
    LVS_EDITLABELS,
    LVS_OWNERDATA,
    LVS_NOSCROLL,
    LVS_TYPESTYLEMASK,
    LVS_ALIGNTOP,
    LVS_ALIGNLEFT,
    LVS_ALIGNMASK,
    LVS_OWNERDRAWFIXED,
    LVS_NOCOLUMNHEADER,
    LVS_NOSORTHEADER,
    RBS_TOOLTIPS,
    RBS_VARHEIGHT,
    RBS_BANDBORDERS,
    RBS_FIXEDORDER,
    RBS_REGISTERDROP,
    RBS_AUTOSIZE,
    RBS_VERTICALGRIPPER,
    RBS_DBLCLKTOGGLE,
    RBBS_BREAK,
    RBBS_FIXEDSIZE,
    RBBS_CHILDEDGE,
    RBBS_HIDDEN,
    RBBS_NOVERT,
    RBBS_FIXEDBMP,
    RBBS_VARIABLEHEIGHT,
    RBBS_GRIPPERALWAYS,
    RBBS_NOGRIPPER,
    TVS_HASBUTTONS,
    TVS_HASLINES,
    TVS_LINESATROOT,
    TVS_EDITLABELS,
    TVS_DISABLEDRAGDROP,
    TVS_SHOWSELALWAYS,
    TVS_RTLREADING,
    TVS_NOTOOLTIPS,
    TVS_CHECKBOXES,
    TVS_TRACKSELECT,
    TVS_SINGLEEXPAND,
    TVS_INFOTIP,
    TVS_FULLROWSELECT,
    TVS_NOSCROLL,
    TVS_NONEVENHEIGHT,
    UDS_ALIGNLEFT,
    UDS_ALIGNRIGHT,
    UDS_ARROWKEYS,
    UDS_AUTOBUDDY,
    UDS_HORZ,
    UDS_NOTHOUSANDS,
    UDS_SETBUDDYINT,
    UDS_WRAP,
    SS_NOPREFIX,
    SS_NOTIFY,
    SS_CENTERIMAGE,
    SS_RIGHTJUST,
    SS_REALSIZEIMAGE,
    SS_SUNKEN,
    SS_ENDELLIPSIS,
    SS_PATHELLIPSIS

        }

constant vWinExFlagNames = {
    "WS_EX_ACCEPTFILES",
    "WS_EX_APPWINDOW",
    "WS_EX_CLIENTEDGE",
    "WS_EX_CONTEXTHELP",
    "WS_EX_CONTROLPARENT",
    "WS_EX_DLGMODALFRAME",
    "WS_EX_LEFT",
    "WS_EX_LEFTSCROLLBAR",
    "WS_EX_LTRREADING",
    "WS_EX_MDICHILD",
    "WS_EX_NOPARENTNOTIFY",
    "WS_EX_OVERLAPPEDWINDOW",
    "WS_EX_PALETTEWINDOW",
    "WS_EX_RIGHT",
    "WS_EX_RIGHTSCROLLBAR",
    "WS_EX_RTLREADING",
    "WS_EX_STATICEDGE",
    "WS_EX_TOOLWINDOW",
    "WS_EX_TOPMOST",
    "WS_EX_TRANSPARENT",
    "WS_EX_WINDOWEDGE",
    "WS_EX_LAYERED",
    "WS_EX_NOINHERITLAYOUT",
    "WS_EX_LAYOUTRTL",
    "WS_EX_NOACTIVATE"
    }

constant vLVExFlagNames = {
    "LVS_EX_GRIDLINES",
    "LVS_EX_SUBITEMIMAGES",
    "LVS_EX_CHECKBOXES",
    "LVS_EX_TRACKSELECT",
    "LVS_EX_HEADERDRAGDROP",
    "LVS_EX_FULLROWSELECT",
    "LVS_EX_ONECLICKACTIVATE",
    "LVS_EX_TWOCLICKACTIVATE",
    "LVS_EX_FLATSB",
    "LVS_EX_REGIONAL",
    "LVS_EX_NFOTIP",
    "LVS_EX_UNDERLINEHOT",
    "LVS_EX_UNDERLINECOLD",
    "LVS_EX_MULTIWORKAREAS"
    }

constant vLVExFlagValues = {
    LVS_EX_GRIDLINES,
    LVS_EX_SUBITEMIMAGES,
    LVS_EX_CHECKBOXES,
    LVS_EX_TRACKSELECT,
    LVS_EX_HEADERDRAGDROP,
    LVS_EX_FULLROWSELECT,
    LVS_EX_ONECLICKACTIVATE,
    LVS_EX_TWOCLICKACTIVATE,
    LVS_EX_FLATSB,
    LVS_EX_REGIONAL,
    LVS_EX_NFOTIP,
    LVS_EX_UNDERLINEHOT,
    LVS_EX_UNDERLINECOLD,
    LVS_EX_MULTIWORKAREAS
    }


constant vWinExFlagValues = {
    WS_EX_ACCEPTFILES,
    WS_EX_APPWINDOW,
    WS_EX_CLIENTEDGE,
    WS_EX_CONTEXTHELP,
    WS_EX_CONTROLPARENT,
    WS_EX_DLGMODALFRAME,
    WS_EX_LEFT,
    WS_EX_LEFTSCROLLBAR,
    WS_EX_LTRREADING,
    WS_EX_MDICHILD,
    WS_EX_NOPARENTNOTIFY,
    WS_EX_OVERLAPPEDWINDOW,
    WS_EX_PALETTEWINDOW,
    WS_EX_RIGHT,
    WS_EX_RIGHTSCROLLBAR,
    WS_EX_RTLREADING,
    WS_EX_STATICEDGE,
    WS_EX_TOOLWINDOW,
    WS_EX_TOPMOST,
    WS_EX_TRANSPARENT,
    WS_EX_WINDOWEDGE,
    WS_EX_LAYERED,
    WS_EX_NOINHERITLAYOUT,
    WS_EX_LAYOUTRTL,
    WS_EX_NOACTIVATE
    }


constant vWinFlagNames = {
    "WS_OVERLAPPED",
    "WS_POPUP",
    "WS_CHILD",
    "WS_MINIMIZE",
    "WS_VISIBLE",
    "WS_DISABLED",
    "WS_CLIPPINGCHILD",
    "WS_CLIPSIBLINGS",
    "WS_CLIPCHILDREN",
    "WS_MAXIMIZE",
    "WS_CAPTION",
    "WS_BORDER",
    "WS_DLGFRAME",
    "WS_HSCROLL",
    "WS_VSCROLL",
    "WS_SYSMENU",
    "WS_THICKFRAME",
    "WS_GROUP",
    "WS_TABSTOP",
    "WS_SCROLLBARS",
    "WS_MINIMIZEBOX",
    "WS_MAXIMIZEBOX",
    "WS_TILED",
    "WS_ICONIC",
    "WS_SIZEBOX",
    "WS_OVERLAPPEDWINDOW",
    "WS_TILEDWINDOW",
    "WS_POPUPWINDOW",
    "WS_CHILDWINDOW",
    "BS_3STATE",
    "BS_AUTO3STATE",
    "BS_AUTOCHECKBOX",
    "BS_AUTORADIOBUTTON",
    "BS_BITMAP",
    "BS_BOTTOM",
    "BS_CENTER",
    "BS_CHECKBOX",
    "BS_DEFPUSHBUTTON",
    "BS_GROUPBOX",
    "BS_ICON",
    "BS_LEFT",
    "BS_LEFTTEXT",
    "BS_MULTILINE",
    "BS_NOTIFY",
    "BS_OWNERDRAW",
    "BS_PUSHBUTTON",
    "BS_PUSHLIKE",
    "BS_RADIOBUTTON",
    "BS_RIGHT",
    "BS_RIGHTBUTTON",
    "BS_TEXT",
    "BS_TOP",
    "BS_USERBUTTON",
    "BS_VCENTER",
    "ES_LEFT",
    "ES_CENTER",
    "ES_RIGHT",
    "ES_MULTILINE",
    "ES_AUTOHSCROLL",
    "ES_AUTOVSCROLL",
    "ES_DISABLENOSCROLL",
    "ES_LOWERCASE",
    "ES_NUMBER",
    "ES_NUMERIC",
    "ES_OEMCONVERT",
    "ES_PASSWORD",
    "ES_READONLY",
    "ES_UPPERCASE",
    "ES_WANTRETURN",
    "ES_AUTOSCROLL",
    "ES_SAVESEL",
    "ES_NOHIDESEL",
    "LBS_NOTIFY",
    "LBS_SORT",
    "LBS_NOREDRAW",
    "LBS_MULTIPLESEL",
    "LBS_OWNERDRAWFIXED",
    "LBS_OWNERDRAWVARIABLE",
    "LBS_HASSTRINGS",
    "LBS_USETABSTOPS",
    "LBS_NOINTEGRALHEIGHT",
    "LBS_MULTICOLUMN",
    "LBS_WANTKEYBOARDINPUT",
    "LBS_EXTENDEDSEL",
    "LBS_DISABLENOSCROLL",
    "LBS_NODATA",
    "LBS_NOSEL",
    "LBS_STANDARD",
    "LVS_ICON",
    "LVS_REPORT",
    "LVS_SMALLICON",
    "LVS_LIST",
    "LVS_TYPEMASK",
    "LVS_SINGLESEL",
    "LVS_SHOWSELALWAYS",
    "LVS_SORTASCENDING",
    "LVS_SORTDESCENDING",
    "LVS_SHAREIMAGELISTS",
    "LVS_NOLABELWRAP",
    "LVS_AUTOARRANGE",
    "LVS_EDITLABELS",
    "LVS_OWNERDATA",
    "LVS_NOSCROLL",
    "LVS_TYPESTYLEMASK",
    "LVS_ALIGNTOP",
    "LVS_ALIGNLEFT",
    "LVS_ALIGNMASK",
    "LVS_OWNERDRAWFIXED",
    "LVS_NOCOLUMNHEADER",
    "LVS_NOSORTHEADER",
    "RBS_TOOLTIPS",
    "RBS_VARHEIGHT",
    "RBS_BANDBORDERS",
    "RBS_FIXEDORDER",
    "RBS_REGISTERDROP",
    "RBS_AUTOSIZE",
    "RBS_VERTICALGRIPPER",
    "RBS_DBLCLKTOGGLE",
    "RBBS_BREAK",
    "RBBS_FIXEDSIZE",
    "RBBS_CHILDEDGE",
    "RBBS_HIDDEN",
    "RBBS_NOVERT",
    "RBBS_FIXEDBMP",
    "RBBS_VARIABLEHEIGHT",
    "RBBS_GRIPPERALWAYS",
    "RBBS_NOGRIPPER",
    "TVS_HASBUTTONS",
    "TVS_HASLINES",
    "TVS_LINESATROOT",
    "TVS_EDITLABELS",
    "TVS_DISABLEDRAGDROP",
    "TVS_SHOWSELALWAYS",
    "TVS_RTLREADING",
    "TVS_NOTOOLTIPS",
    "TVS_CHECKBOXES",
    "TVS_TRACKSELECT",
    "TVS_SINGLEEXPAND",
    "TVS_INFOTIP",
    "TVS_FULLROWSELECT",
    "TVS_NOSCROLL",
    "TVS_NONEVENHEIGHT",
    "UDS_ALIGNLEFT",
    "UDS_ALIGNRIGHT",
    "UDS_ARROWKEYS",
    "UDS_AUTOBUDDY",
    "UDS_HORZ",
    "UDS_NOTHOUSANDS",
    "UDS_SETBUDDYINT",
    "UDS_WRAP",
    "SS_NOPREFIX",
    "SS_NOTIFY",
    "SS_CENTERIMAGE",
    "SS_RIGHTJUST",
    "SS_REALSIZEIMAGE",
    "SS_SUNKEN",
    "SS_ENDELLIPSIS",
    "SS_PATHELLIPSIS"

        }

constant vEventNamesUpper = {
    "BREAK",
    "PAUSE",
    "MOUSE",
    "CLICK",
    "KEYPRESS",
    "KEYUP",
    "KEYDOWN",
    "RESIZE",
    "CHANGE",
    "GOTFOCUS",
    "LOSTFOCUS",
    "SCROLL",
    "OPEN",
    "CLOSE",
    "DESTROY",
    "TIMER",
    "PAINT",
    "DRAGANDDROP",
    "EVENT",
    "ACTIVATE",
    "AFTEREVENT",
    "DROPDOWN",
    "CLOSEUP",
    "IDLE",
    "KEYBOARD",
    "REGION",
    "DATACHANGE",
    "GETHANDLER"
}

sequence hasDeferredHandlers
hasDeferredHandlers = {}
integer haveDeferredHandlers
haveDeferredHandlers = 0
sequence ctrl_Deferred_HandlerS
ctrl_Deferred_HandlerS = {}

------------------------------------------------------------------
procedure ResolveDeferredHandler(integer id)
------------------------------------------------------------------
    sequence lEventName
    object lRtnId
    sequence lRoutineName
    integer lPos
    integer lEvent
    sequence lTemp
    integer skip

    if r_AppCallback < 0 then
        return
    end if

    lPos = find(id,hasDeferredHandlers)
    if lPos = 0 or lPos > haveDeferredHandlers then
        return
    end if

    lTemp = ctrl_Deferred_HandlerS[lPos]
    skip = 0

    for i=1 to length(lTemp) do
        if skip then
            skip = 0
        else
            lEvent = lTemp[i]
            lEventName = w32lookup(lEvent, w32EventCodes, w32EventNames)
            if length(lEventName) > 0 then
                if i != length(lTemp) and sequence(lTemp[i+1]) then
                    skip = 1
                    lRoutineName = lTemp[i+1]
                else
                    lRoutineName = lEventName & '_' & getIdName(id)
                end if
                if not find(r_autoclose,getHandler(id, lEvent)) then
                    lRtnId = invokeHandler(id, w32HGetHandler, {
                                    lRoutineName,
                                    lEvent,
                                    getIdName(id)})
                    if sequence(lRtnId) then
                        setHandler(id, lEvent, lRtnId[1])
                    end if
                end if
            end if
        end if
    end for

    -- Clear the list of events to resolve.
    ctrl_Deferred_HandlerS[lPos] = ctrl_Deferred_HandlerS[haveDeferredHandlers]
    hasDeferredHandlers[lPos] = hasDeferredHandlers[haveDeferredHandlers]
    haveDeferredHandlers -= 1
end procedure

sequence autoSizes,autoFlags
autoSizes={}
autoFlags={}

global function getDeferredHandlers(integer id)
    integer p
    p=find(id,hasDeferredHandlers)
    if p>0 and p<=haveDeferredHandlers then
        return ctrl_Deferred_HandlerS[p]
    else
        return {}
    end if
end function

procedure setDeferredHandlers(integer id,object events)
    integer p
    p=find(id,hasDeferredHandlers)
    if p <= haveDeferredHandlers then
        if p > 0 then
            if atom(events) then
                ctrl_Deferred_HandlerS[p] &= events
            else
                ctrl_Deferred_HandlerS[p] = events
            end if
        else
            if atom(events) then
                events = {events}
            end if
            haveDeferredHandlers += 1
            if haveDeferredHandlers > length(hasDeferredHandlers) then
                hasDeferredHandlers &= id
                ctrl_Deferred_HandlerS = append(ctrl_Deferred_HandlerS,events)
            else
                hasDeferredHandlers[haveDeferredHandlers] = id
                ctrl_Deferred_HandlerS[haveDeferredHandlers] = events
            end if
        end if
    else
        if atom(events) then
            events = {events}
        end if
        haveDeferredHandlers += 1
        hasDeferredHandlers[haveDeferredHandlers] = id
        ctrl_Deferred_HandlerS[haveDeferredHandlers] = events
    end if
end procedure

global procedure ResolveDeferredHandlers()
    for i = 1 to haveDeferredHandlers do
        ResolveDeferredHandler(hasDeferredHandlers[i])
    end for
end procedure

constant --dataUnknown = 0, -- PL 29/4/09
         dataAtom = 1,
         dataString = 2,
         dataMultiple=3,
         dataSequence=4

function getArgValue(sequence s)
-- returns a pair {data type,value}
    integer lDataType
    object lData
    object action_code

    action_code=0
    if s[w32NumValues]>1 then
        lDataType = dataMultiple
        lData=s[w32PartialText]
    elsif s[w32ConvCode]=0 then
        if w32string(s[w32CompleteText]) then
            lDataType = dataString
        else
            lDataType = dataSequence
        end if
        lData=s[w32CompleteText]
    else
        lData=s[w32NumValue]
        lDataType=dataAtom
        if s[w32ConvCode]=1 then -- some partial text
            action_code=s[w32PartialText]
            if not w32string(action_code) then
                action_code =action_code[w32PartialText]
            end if
        end if
    end if
    return {lDataType,lData,action_code}
end function

function extractArgs(sequence s)
    for i=1 to length(s) do
        s[i]=getArgValue(s[i])
        s[i]=s[i][w32AValue]
    end for
    return s
end function

--include rttext.e as rt

---------------------------
--/topic Defining Controls
--/info
--This section describes how to create windows and the various elements that can appear in them.

--/topic Defining Controls
--/proc newUIObj(sequence Definition)
--/desc Defines a User Interface Object, a.k.a. a Control
--This is a high-level method of defining the attributes of a control
--to be used by your program. It is an interface to the /create() routine.
--
-- /setCallback() is usually used in conjunction with applications that use newUIObj()
--
-- The /i Definition parameter is used to specify a specific type of control
-- to create and its attributes. It consists of one or more parameters that
-- can be expressed in a variety of formats, depending on your preferred
-- way of doing things. However they are all variations on a set of /i "keyword=value"
-- pairs, where the /b key is expresses the type of parameter and the /b value
-- is the parameter's information. /n
--
-- The parameters inside /i Definition can be formed as a 2-element sequence
-- where the first element is the keyword and the second is the information. For
-- example /b'("width", 200)'. The alternative to this is to have the
-- parameter as a string, /b'"width=200"'. In fact, when using the string form
-- you can have multiple parmeters in the same string, eg.
-- /b'"width=200, height=300, left=20, top=35"' with each parmeter delimited
-- by a comma. /n
--So to summarize this, the /i Definition sequence consists of one or more
-- elements, and each element can /b either be a 2-element sequence of
-- (keyword,value) or a string that contains one or more comma delimited
-- 'keyword=value' entries.
--
--All the parameters have a keyword name, which is not case sensitive, meaning
-- that "width=200" and "WIDTH=200" are both acceptable. However, certain
-- parameters can have assumed keyword names if not supplied. The first unnamed
-- parameter is assumed to be the "TYPE" parameter, the second unnamed
-- is assumed to be "CAPTION", and so on for "NAME", "LEFT", "TOP", "WIDTH",
-- "HEIGHT", "FLAGS", and "EXFLAGS" parameters, in that order. If there
-- are still unnamed parameters after all the assumed ones have been
-- allocated, an error message is issued.
--
-- /b"Reference Control"
-- Some of the commands deal with a 'reference control'. By default, this is the previously
-- defined control, but can be explictly named in some cases too.
--
--The keywords supported are ... /n
--/b AT ** This is a shorthand for LEFT=n,TOP=n. It specifies both the left and top position
-- of the control. The format is AT=(leftpos,toppos) where both /i leftpos and /i toppos have the
-- same formats as allowed for /i LEFT= and /i TOP= parameters respectively. /n
--Additionally, if either /i leftpos or /i toppos is omitted, then /i () is assumed
-- for them, meaning that they use the same position as the previous control, respectively.
--Also, if /i leftpos or /i toppos are in the form /i /b"x"nnn where /i x is either '>' or '~<'
-- and /i nnn is a number. The '>' means that the control is positioned /i nnn pixels after
-- the previous control's /i other edge and '~<' means it is positioned /i nnn pixels before
-- the previous control's /i other edge. By " /i other" edge
-- the same as LEFT=(+/-nnn) and TOP=(+/-nnn) respectively. /n
--~s~seg.~s /b "at=(20,10)" --> The control's is positioned at 20 pixels from the left,
--and 10 pixels from the top. /n
--~s~seg.~s /b "at=((3),(0,OtherControl))" --> The control's is positioned at 3 pixels to the left
-- of the previously defined control, and 0 pixels from the bottom a control called "OtherControl". /n
--~s~seg.~s /b "at=(,+4)" --> The control is positioned with the same /i left position as the
-- previous control and 4 pixels below the previous control.
--
--/b BARS or /b BAR ** This only applies to a Window control. It is used to specify any toolbar,
-- scrollbar, and statusbar that the window has.  /n
-- For statusbars, the form is either /i "BAR=status", which will cause a simple statusbar to be defined for
-- the window, or /i "BAR=status=(re1,re2,...)" which specifies the set of /b righthand edge
-- locations for a multi-panel statusbar. /n
-- /i "BAR=(vert,horz)" can be used to specify vertical and horizontal scrollbars for the window /n
-- /i "BAR=toolbar" will define a toolbar, 34 pixels high. /n
-- /i "BAR=flattoolbar" will define a FlatToolbar, high enough for a 32x32 button and text underneath.
-- /b Note that the name assigned to the statusbar, toolbar and flattoolbar will be the name of the Window
-- with "SB", "TB", and "FB" appended respectively.
--
--/b BGCOLOR or /b BGCOLOUR ** This specifies the background color for the control. Note that
-- some types of controls, for example Buttons, cannot have their background changed by this method.
--
-- It can take one of three forms: A single RGB value, the name of one of the predefined colors, or
-- a list of three color values from 0 - 255.
--
--Example:
--   BGCOLOR=1188733
--   BGCOLOR=Purple
--   BGCOLOR=(#70,#80,#FF)
--
--/b BOTTOM ** This specifies the bottom edge position of the control. You
-- would only specify either TOP or BOTTOM, but if you did use both, then the
-- BOTTOM specification takes precedence. /n
--~s~seg.~s /b "bottom=20" --> The control's bottom edge is 20 pixels above it's
-- container's bottom edge.
--
--/b BUDDY ** This only applies to an UpDown control. It specifies the 'buddy' control that
-- is linked to the UpDown control being defined.
--
--/b CAPTION or /b TEXT ** Specifies the control's initial display value. If
-- the value is not enclosed in () then it is trimmed of leading and
--trailing spaces. And note that if the value has any commas, it must be
--enclosed in (). /n
--~s~s~seg.~s /b <"caption= Customer's Name: "> --> The spaces are trimmed to
-- produce a value of "Customer's Name:". /n
--~s~s~seg.~s /b <"caption=( Customer's Name: )"> --> The spaces are not trimmed to
-- produce a value of " Customer's Name: ". /n
--~s~s~seg.~s /b <"caption=(Hello, world!)"> --> The text value has an embedded
-- comma so is enclosed in (). /n
--~s~s~seg.~s /b <"caption=Hello, world!"> --> This example shows why the ()
-- are needed for text that as commas. Without the enclosing () this would
-- produce the value "Hello" and the "world!" would be interpreted as an
-- unknown keyword. /n
--
--It is also possible to look up caption text from an external file. If the
-- caption parameter has the form /b'"caption=~<HW>"', the library looks
-- for the "HW" key in the messages text file. Unless changed by /setMsgFile
--this is "msgs.ini" in the current folder. Also, unless changed by
-- /setUserLanguage, this looks in the [english] section of the messages file. /n
--Thus if the messages file looked like ...
--
--/code
--    [english]
--    HW = Hello World
--    [francais]
--    HW = Bonjour Monde
--/endcode
--
-- and the user's language was 'francais' then the above caption example
-- would be equivalent to /b<"caption=Bonjour Monde">
--
-- A special format is available to load a combo or list control with its
--initial set of list items. To do this, the keyword and value must use the
-- 2-element sequence form rather than the simple string form. /n
--~s~seg.~s /b <("text", ("item1","item2","item3"))> --> causes the three
-- items to be loaded as the initial list values. /b Note that this only applies
-- to /i combo and /i list type of controls. /n
--
--/b CHECK or /b CHECKED ** This specifies whether or not the control is initially checked. It
-- has the form of check=~<setting>, where ~<setting> can be one of Yes, w32True, 1, or On
-- to set it to checked, or anything else to uncheck it. /n
--~s~seg.~scheck=no
--
--/b COLUMNS or /b COLUMN ** This specifies the column headings, widths, and alignment for
-- ListView controls. This takes the form of a list of column definitions enclosed in braces. Each
-- column definition is a set of one, two, or three elements enclosed in braces. The elements
-- are a column header (text), a column width (integer) and an alignment keyword - /b left,
-- /b center, and /b right. You can also use the characters ~<, ^, >, for left, center and right
-- respectively. /n
-- Example: columns=((First Name, 80, ~<), (Surname, 110, ~<), (Age, 30, >), (Status, 40, ^)) /n
-- Note that if you specify ListView columns, the flag LVS_REPORT is automatically added.
--
--/b DELTA ** This specifies the increments for scrollbars. It takes the form of
-- delta=(small,large). /n
--~s~seg.~sdelta=(1,15) /n
--
--/b ENABLE or /b ENABLED ** This specifies whether or not the control is initially enabled. It
-- has the form of enable=~<setting>, where ~<setting> can be one of Yes, w32True, 1, or On
-- to set it to enabled, or anything else to disable it. /n
--~s~seg.~senable=no
--
--/b EVENTS or /b EVENT ** This specifies one or more events that the control expects your application
-- to provide handlers for. It takes the form of a list of event names or 2-element sets of the
-- form (eventname, eventhandler_name). /n
--Example:
--
--  event=((click,ShowCustomer)) /n
--  event=(mouse,keypress)
--
--Some controls always assume certain events even if you don't specify them here. /n
--/li Button-type controls, Statusbar and MenuItems always assume a w32HClick event.
--/li HScroll, VScroll, HTrackBar, VTrackBar, ProgressBar, and UpDown
--controls always assume a w32HScroll event.
--/li Window controls always assume w32HScroll, w32HPaint, w32HOpen, w32HActivate, w32HResize, and
-- w32HClose events.
--
-- All this means is that for these control types, you do not have to explicitly add these event
-- types as they will be automatically assumed.
--
-- The suggested naming convention for event handlers is ~<eventname>_~<controlname>, for example
-- a control called "Go Button" that invokes the w32HClick event, the suggested handler name
-- would be "Click_GoButton"
--
-- When the application starts and if an event resolution callback routine has been supplied,
-- Win32lib calls the event resolution callback routine for each event specified in this parameter.
-- This callback routine is expected to return a routine_id that will handle any events for the
-- control. /n
--/code
--  procedure AppCallback(integer self, integer event, sequence parms)
--      -- self is the control's id value
--      -- event can be w32HGetHandler, in which case ...
--          -- parms[1] is the routine handler name
--          -- if a handler name is not supplied then this
--          -- is in the form ~<eventname>_~<controlname>
--          -- eg. "Click_PushBtn"
--          -- parms[2] is the event code to be handled
--          -- eg. w32HClick
--          -- parms[3] is the control's name
--          -- eg. "PushBtn"
--
--      if event = w32HGetHandler then
--          returnValue(routine_id(parms[1]))
--      end if
--  end procedure
--  startApp(routine_id("AppCallback"))
--/endcode
--
--/b EXFLAGS or /b EXFLAG ** This is similar to the FLAGS keyword but /i only
-- applies to the extended flag values. Its primary usage is for when you need to
-- replace the default extended flags with the ones you enter with this keyword.
--
--~s~seg.~sflags=(NEW, WS_EX_CLIENTEDGE) -- Replaces the default extended flags /n
--~s~s~s~s~s~s~sflags=WS_EX_CLIENTEDGE -- combined with default flags.
--
--/b FGCOLOR or /b FGCOLOUR ** This specifies the text (foreground) color for the control. Note that
-- some types of controls, for example Buttons, cannot have their text color changed by this method.
--
-- It can take one of three forms: A single RGB value, the name of one of the predefined colors, or
-- a list of three color values from 0 - 255.
--
--Example:
--   FGCOLOR=1188733
--   FGCOLOR=Purple
--   FGCOLOR=(#70,#80,#FF)
--
--/b FLAGS or /b FLAG ** This specifies one or more flag values used to
-- create the control. If you need more than one flag value, you must enclose
-- all the values in matching () and separate the values with commas. Normally
-- the values are combined with a control's default flags but if you need to
-- replace the default flags, include the special value 'NEW' in the list
-- of flag values. Note that you can freely intermix normal flags with extended
-- flags. /n
--~s~seg.~sflags=(NEW, WS_VISIBLE, WS_POPUP, WS_BORDER, WS_EX_CLIENTEDGE) /n
--~s~s~s~s~s~s~sflags=SS_NOTIFY /n
-- If you specify WS_CHILD and do not specify a parent control, the most recent
-- Window is used as the parent control.
--/b POSITION ** This specifies the initial position of the thumb in scrollbars. /n
--~s~seg.~sposition=10
--
--/b FONT ** This specifies the font to use for the control. It takes the form
-- FONT=(w32FontName, size, style)
--
--/b FROM ** The specifies the reference control to use with subsequent commands for
-- the current control definition. This is a control that is the basis for the
-- relative values in any LEFT, TOP, WIDTH, and HEIGHT parameters for this control.
-- Normally, these values are relative to the previously defined control, but
-- sometimes you may need to override that.
--
-- Example: FROM=Go Button, left=(5), top=() /n
-- which means that the control being defined starts 5 pixels to the left of the Go Button
-- and has the same 'top' value as the go button.
--
-- This is really a shorthand because the same effect could be achieved by doing ... /n
-- left=(5,Go Button), top=(0,Go Button,) /n
--
--/b HEIGHT ** This specifies the height of the control. It has three basic forms, a simple
-- value that is the absolute height, a percentage value that is relative to the control's
-- container, and a specification that is relative to another control. /n
-- Some examples... /n
--~s~seg.~s /b"height=400" --> Exactly 400 pixels high. /n
--~s~seg.~s /b"height=400pxl" --> Just an alternative to above, exactly 400 pixels high. /n
--~s~seg.~s /b"height=100char" --> Exactly 100 characters high. The exact pixel value depends on the font
-- set for the control. /n
--~s~seg.~s /b"height=40%" --> 40 percent of the container's height. /n
--~s~seg.~s /b"height=CustName+10" --> The height is calculated as 'CustName' height + 10 pixels /n
--~s~seg.~s /b"height=CustName*2" --> The height is calculated as 'CustName' height * 2 /n
--~s~seg.~s /b"height=CustName" --> The height is calculated as the same as 'CustName' height /n
--~s~seg.~s /b"height=CustName*90%" --> The height is calculated as 'CustName' height * 0.9 /n
--~s~seg.~s /b"height=*" --> The height is the same the current reference control's height. /n
--~s~seg.~s /b"height=*-5" --> The height is calculated as the current reference control's height less 5 pixels/n
--~s~seg.~s /b"height=**0.5" --> The height is calculated as half the current reference control's height. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, HEIGHT, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify /b more than one height parameter in a control's definition,
-- the values accumulate. Thus if you need a control to be half the height of another control
-- plus 3 pixels you would specify "height=OtherControl*0.5,height=3", or if you need the
-- sum of two other controls, "height=CTRL1,height=CTRL2"
--
--/b IMAGE ** This specifies an image to be used with Window, Icon, and Bitmap controls. For
-- Bitmaps it must be the name of a ".BMP" file and for Windows and Icon controls, it can be either
-- an ".ICO" file or a predefined MS-Windows name "APPLICATION", "ERROR", "QUESTION", "WARNING",
-- "ASTERISK", or "WINLOGO". For TabItems, it can be either a filename or a string
-- <filename>,<icon index>.
--
-- /b INDEX: this is used as the 1 based insertion point for TabItems.
--
--/b INITIALFOCUS ** This indicates that the control is the one that has the initial focus
-- when the form is opened.  It has the form of initialfocus=~<setting>, where ~<setting> can be
-- one of Yes, 1, or On to set it, or anything else to unset it. /n
--
--/b LEFT ** This specifies the left edge position of the control. It has four forms, a simple
-- value that is the absolute position, a percentage value that is relative to the control's
-- container's width, the word 'Center', and one that is relative to another control. /n
-- Some examples... /n
--~s~seg.~s /b"left=400" --> Exactly 400 pixels. /n
--~s~seg.~s /b"left=400pxl" --> Just an alternative to above, exactly 400 pixels. /n
--~s~seg.~s /b"left=100char" --> Exactly 100 characters. The exact pixel value depends on the font
-- set for the container control. /n
--~s~seg.~s /b"left=40%" --> 40 percent of the container's width. /n
--~s~seg.~s /b"left=center" --> The control is centered horizontally in its container. /n
--~s~seg.~s /b"left=CustName" --> The left is calculated as the same as 'CustName' right. /n
--~s~seg.~s /b"left=CustName+10" --> The left is calculated as 'CustName' right + 10 pixels. /n
--~s~seg.~s /b"left=CustName*" --> The left is calculated as 'CustName' left. /n
--~s~seg.~s /b"left=CustName*+10" --> The left is calculated as 'CustName' left + 10. /n
--~s~seg.~s /b"left=*" --> The left is calculated as the current reference control's right /n
--~s~seg.~s /b"left=*+5" --> The left is calculated as the current reference control's right + 5 /n
--~s~seg.~s /b"left=**" --> The left is the same the current reference control's left. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, HEIGHT, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify more than one left parameter in a control's definition,
-- the values /b "do not" accumulate. Instead, the last /i "left=" parameter is used.
--
--/b MEMBER ** This specifies the ControlSet that the new control will belong to. Its value
-- must be a positive integer. See /showControlSet and /setControlSet for details about
-- control sets. /n
-- Example: MEMBER=2
--
--Example:
--/code
--      procedure Click_AcceptForm(integer self, integer event, sequence parms)
--          -- code to handle the user pressing the Accept Form button.
--          . . .
--      end procedure
--
--      procedure AppCallback(integer self, integer event, sequence parms)
--          if event = w32HGetHandler then
--              returnValue(routine_id(parms[1]))
--          end if
--      end procedure
--
--      newUIObj(("Window,Main Window", "width=400,height=50%"))
--      newUIObj("LText, at=(5,5),caption=Name:")
--      newUIObj(("EditText, UserName", "left=(),top=(0),width=20char"))
--      newUIObj(("Button,AcceptForm", "left=5,bottom=5,height=40",
--                                     "caption=&Accept"))
--      newUIObj(("List,Devices,left=100, top=5, height=4char",
--                ("text", ("Tape","DVD","Disk","Printer")),
--                "events=(Click,change)")
--      prevValue = setCallback(routine_id("AppCallback"))
--      . . .
--/endcode
--
--/b NAME ** Each control created by newUIObj should have a unique name. The name can
--have any character in it however all but alphabetic characters, digits and the
--underscore character are stripped out of the supplied name. Also, any leading
--digits are stripped out. For example, if you had used /b"NAME=(Customer's Name)"
--then the actual stored name would be /b"CustomersName"
--
--If no /i name parameter is supplied, the control's caption, if supplied is used. And
--if neither /i name or /i caption is supplied, the control's name is set to /b NoName~<id>,
--where ~<id> is the control's Id number.
--
--You can always change a control's name with the /setIdName() routine, and fetch a control's
--name with /getIdName()
--
--/b OWNER or /b PARENT ** This specifies the parent control, also known as 'owner', of the control
-- being defined. It can be either the name of a control or the actual control id value.
-- Most of the time this is not required as the default parent is sufficient. /n
-- The default parent is determined as ... /n
-- If the control is a MenuItem or MenuSpacer then the most recently defined menu, otherwise if the control
-- is a TabItem, the most recently defined TabControl, otherwise if the control is a ReBarBand then
-- the toolbar attached to the most recently defined window, otherwise if the control is /b not
-- a Window and not a Pixmap then the most recently defined Window, TabItem or Group, otherwise
-- the main window.
--
-- /b See the keyword '*' for details about how to change the default parent id.
--
--/b POINTER ** This specifies the shape of the mouse pointer when it is over this control. It
-- can specify either a cursor file (.CUR or .ANI) or one of the system predefined shapes. See
-- /setMousePointer for more details. /n
-- Example:   POINTER=SizeWE
--
--/b POPUP ** This specifies the menu(s) that will popup when the user presses the
-- righthand mouse button in this control. It takes the form of
-- POPUP=(normal,shift,control,shift-control) where 'normal','shift', 'control', and
-- 'shift-control' are the names of menus that will popup in combination of the Righthand mouse
-- button being pressed and No-Control-Shift, Shift, Control, and Shift-Control keys
-- being held down respectively. /n
-- If any of these names are omitted, the corresponding combination is not set. Thus to
-- set popup menus for only the Normal and Control key combinations, use /n
-- something like POPUP=(NormalPopup,,ControlPopup)
--
--/b PRAGMA ** This is a /i directive type command and does not actually create a control. It can
-- only have the value 'PARENT' for now. This will cause the named control to become the
-- default parent for subsequent controls being created in the form. /n
-- This is typically used after the last control in a Group control has been defined, or
-- after the last menu item in a sub-menu has been defined. /n
-- Example:  "Window,name=MainWin,pragma=PARENT" says that 'MainWin' is the new default Window. /n
-- Example:  "Menu,name=FileMenu,pragma=PARENT" says that 'FileMenu' is the new default Menu. /n
--
--/b RANGE ** This specifies the minimum and maximum values for scrollbars,
--progressbars and UpDown controls. It takes the form of range=(lower,upper). /n
--~s~seg.~srange=(4,1200)
--
--/b RIGHT ** This specifies the right edge position of the control. You
-- would only specify either LEFT or RIGHT, but if you did use both, then the
-- RIGHT specification takes precedence. /n
--~s~seg.~s /b "right=20" --> The control's right edge is 20 pixels to the left
-- of it's container's right edge.
--
--/b SIZE ** This is a shorthand for WIDTH=n,HEIGHT=n. It specifies both the width and height
-- of the control. The format is SIZE=(width,height) where both /i width and /i height have the
-- same formats as allowed for /i WIDTH= and /i HEIGHT= parameters respectively. /n
--Additionally, if either /i width or /i height is omitted, then /i () is assumed
-- for them, meaning that they use the same dimensions as the reference control, respectively.
--Also, if /i width or /i height are in the form ?+nnn or ?-nnn this is taken to be
-- the same as WIDTH=(+/-nnn) and HEIGHT=(+/-nnn) respectively. /n
--~s~seg.~s /b "size=(100,200)" --> The control's is 100 pixels wide, and 200 pixels high. /n
--~s~seg.~s /b "size=(,?-15)" --> The control is the same /i width as the
-- reference control and 15 pixels shorter the reference control.
--
--There are some special forms of /b size. /n
-- /b "size=()" means that the width and height of this control is
-- the same as the respective values of the reference control (usually the previously defined
-- control). /n
--/b "size=maximum" means that when this window is first opened, it will be maximized. /n
--/b "size=minimum" means that when this window is first opened, it will be minimized. /n
--/b "size=~<cntrl>" where ~<cntl> is the name of a control previously defined in this form./n
--/b "size=*" which makes this new control the same size as the reference control./n
--
--/b TAG ** This is a general purpose value that can be attached to any control.
-- Win32lib does not use this in any way at all. It is in fact a shorthand for
-- adding a User Defined Property called "Tag" to the control. You would get and
-- set the Tag value using the /getUserProperty(cntrl, "Tag") and
-- /setUserProperty(cntrl, "Tag", newvalue). /n
--~s~seg.~stag=Special
--
--/b TOOLTIP or /b HINT ** This specifies the hint text for a control. If the text has an embedded
-- comma, it must be enclosed in braces eg. HINT=(This has a, comma in it)
--
--/b TOP ** This specifies the top edge position of the control. It has four forms, a simple
-- value that is the absolute position, a percentage value that is relative to the control's
-- container's height, the word 'Center', and one that is relative to another control. /n
-- Some examples... /n
--~s~seg.~s /b"top=400" --> Exactly 400 pixels. /n
--~s~seg.~s /b"top=400pxl" --> Just an alternative to above, exactly 400 pixels. /n
--~s~seg.~s /b"top=100char" --> Exactly 100 characters. The exact pixel value depends on the font
-- set for the container control. /n
--~s~seg.~s /b"top=40%" --> 40 percent of the container's height. /n
--~s~seg.~s /b"top=center" --> The control is centered vertically in its container. /n
--~s~seg.~s /b"top=CustName" --> The top is calculated as the same as 'CustName' bottom. /n
--~s~seg.~s /b"top=CustName+10" --> The top is calculated as 'CustName' bottom + 10 pixels. /n
--~s~seg.~s /b"top=CustName*" --> The top is calculated as 'CustName' top. /n
--~s~seg.~s /b"top=CustName*+10" --> The top is calculated as 'CustName' top + 10. /n
--~s~seg.~s /b"top=*" --> The top is the same the current reference control's bottom. /n
--~s~seg.~s /b"top=*+5" --> The top is calculated as the current reference control's bottom + 5 /n
--~s~seg.~s /b"top=**" --> The top is the same the current reference control's top. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, top, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify more than one top parameter in a control's definition,
-- the values /b "do not" accumulate. Instead, the last /i "top=" parameter is used.
--
--/b TYPE ** This specifies the type of control you are defining. If omitted, and
-- there are no 'unnamed' parameters, the default type is LText. If you specify an
-- unknown type, an error is generated.
--If you are using the /i "/b events" /i Parameter, you will also have to
-- use either the /setCallback or /startApp routine in your program. /n
-- If the /i type is a Window and a window has already been defined, then this new
-- window will be forced into being a child window.
--
--/b USER ** This is similar to TAG but can be used to add any user defined property
-- to the control. It takes the form of user=(PropertyName, PropertyValue). /n
--~s~seg.~suser=(DefaultColor, #308817) /n
--
--/b VISIBLE ** This specifies whether or not the control is initially visible. It
-- has the form of visible=~<setting>, where ~<setting> can be one of Yes, w32True, 1, or On
-- to set it to visible, or anything else to hide it. /n
--~s~seg.~svisible=off
--
--/b WIDTH ** This specifies the width of the control. It has three basic forms, a simple
-- value that is the absolute width, a percentage value that is relative to the control's
-- container, and a specification that is relative to another control.
-- Some examples... /n
--~s~seg.~s /b"width=400" --> Exactly 400 pixels wide. /n
--~s~seg.~s /b"width=400pxl" --> Just an alternative to above, exactly 400 pixels wide. /n
--~s~seg.~s /b"width=100char" --> Exactly 100 characters wide. The exact pixel value depends on the font
-- set for the control. /n
--~s~seg.~s /b"width=40%" --> 40 percent of the container's width. /n
--~s~seg.~s /b"width=CustName+10" --> The width is calculated as 'CustName' width + 10 pixels /n
--~s~seg.~s /b"width=CustName*2" --> The width is calculated as 'CustName' width * 2 /n
--~s~seg.~s /b"width=CustName" --> The width is calculated as the same as 'CustName' width /n
--~s~seg.~s /b"width=CustName*90%" --> The width is calculated as 'CustName' width * 0.9 /n
--~s~seg.~s /b"width=*-5" --> The width is calculated as the current reference control's width less 5 pixels /n
--~s~seg.~s /b"width=**0.5" --> The width is calculated as half the current reference control's width. /n
--~s~seg.~s /b"width=*" --> The width is the same the current reference control's width. /n
--The examples above talk about a /i "current reference control". This is the control used
-- as a reference point in WIDTH, HEIGHT, TOP and LEFT parameters when no explicit control
-- is named in those parameters. You can set the current reference control by using the FROM
-- parameter, otherwise it is the control that was most recently defined before the current one.
--
--/b "Note:" If you specify more than one WIDTH parameter in a control's definition,
-- the values accumulate. Thus if you need a control to be half the width of another control
-- plus 3 pixels you would specify "width=OtherControl*0.5,width=3", or if you need the
-- sum of two other controls, "width=CTRL1,width=CTRL2"
--

global procedure newUIObj(object pParms)
    integer i
    integer incr
    integer lType
    integer lID
    sequence lCaption
    object lOwner
    object lLeft, lTop, lWidth, lHeight
    object lDefLeft, lDefTop, lDefWidth, lDefHeight
    object lFlags, lExFlags, lLVExFlags
    sequence lKey
    sequence lKeyValue
    integer lPos
    object lData
    integer lDataType
    object lTemp
    atom lSizeInc
    object lUpperData
    object lNumData
    object lTooltip
    integer lAutoClose
    sequence lChar
    integer lCharSize
    sequence lTE
    sequence lParentRect
    sequence lFont
    sequence lFormattedFont
    integer lResize
    sequence lEnable
    sequence lVisible
    sequence lCheck
    sequence lEventList
    integer lParent
    sequence lName
    sequence lRefControl
    sequence lUserProp
    sequence lScrollRange
    sequence lScrollChange
    object lScrollPosition
    object lImage
    object lBGColor
    object lFGColor
    object lStatusBar
    object lToolbar
    object lFlatToolbar
    integer lNewFlag
    integer lNewExFlag
    object lRight
    object lBottom
    object lReBarBand
    sequence lAssumedKeys
    integer lAKPosn
    sequence lText
    object lPointer
    integer lBuddy
    object lDirective
    integer lBarId
    object lAttachPopup
    integer lSetMember
    sequence lLVColumns
    sequence lCTitle
    atom  lCWidth
    atom  lCAlign
    sequence lFlds
    sequence lButtons
    integer lInitView
    sequence lIFOptions
    integer lInitFocus
    integer lTabIndex
    object bgcolor
    sequence lValue
    object iTemp

    if sequence(pParms) and length(pParms) = 0 then
        return
    end if

    lType = 0
    lTooltip = ""
    lCaption = ""
    lOwner = {}
    lWidth = {}
    lHeight = {}
    lLeft = {}
    lTop = {}
    lFlags = 0
    lExFlags = 0
    lLVExFlags = 0
    lAutoClose = w32False
    lFont = ""
    lResize = w32False
    lCheck = {w32False,0}
    lEnable = {w32False,0}
    lVisible = {w32False,0}
    lEventList = {}
    lName = ""
    lReBarBand = {}
    lRefControl = {}
    lUserProp = {{},{}}
    lScrollRange ={}
    lScrollChange = {}
    lScrollPosition = {}
    lImage = {}
    lBGColor = {}
    lFGColor = {}
    lStatusBar = {}
    lToolbar = {}
    lFlatToolbar = {}
    lNewFlag = w32False
    lNewExFlag = w32False
    lRight = {}
    lBottom = {}
    lAssumedKeys = {"TYPE","CAPTION","NAME","LEFT","TOP","WIDTH","HEIGHT","FLAGS","EXFLAGS"}
    lText = {}
    lPointer = {}
    lBuddy=0
    lDirective=0
    lBarId = 0
    lAttachPopup = 0
    lSetMember = 0
    lLVColumns = ""
    lButtons = {}
    lInitView = 0
    lChar = repeat(w32False, 2)
    lIFOptions = {}
    lAKPosn = 0
    lInitFocus = 0
    lTabIndex = 0

    -- Extract the key/value pairs from the parms.
    if w32string(pParms) then
        if length(pParms) > 0 and find(pParms[1], ";`~|#/\\-_^*@,") then
            lTemp = pParms[1]
            pParms = pParms[2..length(pParms)]
        else
            lTemp = ','
        end if
        pParms = w32MakeArgs(pParms,lTemp, '=')
    -- Check for string fragments
    elsif sequence(pParms) then
        lPos = 1
        while lPos <= length(pParms) do
            if w32string(pParms[lPos]) then
                if length(pParms[lPos]) > 0 and find(pParms[lPos][1], ";`~|#/\\-_^*@,") then
                    lTemp = pParms[lPos][1]
                    pParms[lPos] = pParms[lPos][2..length(pParms[lPos])]
                else
                    lTemp = ','
                end if
                lTE = w32MakeArgs(pParms[lPos], lTemp, 0)
                if length(lTE) > 0 then
                    pParms = pParms[1..lPos-1] & lTE & pParms[lPos+1..length(pParms)]
                    lPos += length(lTE) - 1
                end if
            end if
            lPos += 1
        end while
    else
        warnErr(sprintf("Bad newUIObj() parameter %d\n" &
                        "Last good one was '%s'\n" &
                        "Parameter was not a sequence/string.",{pParms,vRecentNewUI}))
        return
    end if

    -- Start processing the parms.
    i = 1
    incr = 1
    while i <= length(pParms) do
-- modified CChris <oedoc@free.fr> Dec 2, 2006
-- now that w32MakeArgs returns the litteral string associated with a converted number,
-- names and captions are no longer treated as number if they happen to represent some.
        lKeyValue = pParms[i]
        incr = 1
        lCharSize = w32False
        lTE = ""

-- PL 29/4/09 (perhaps lKeyValue should instead be declared as object)
--      if sequence(lKeyValue) and length(lKeyValue) = 6 then
        if length(lKeyValue) = 6 then
            if w32string(lKeyValue[1]) then
                lKey = upper(w32trim(lKeyValue[w32AKey]))
                lValue=getArgValue(lKeyValue)
                lDataType=lValue[1]
                lData=lValue[2]
                if sequence(lValue[3]) then
                    lTE=lValue[3]
                    if equal(lTE, "%") then  -- no longer hapens, as w32TextToNumber takes care of it
                        lData /= 100
                    elsif match("CH", upper(lTE)) = 1 then
                        lCharSize = w32True
                    end if
                end if
                if length(lKey) = 0 then
                    -- No keyword, so get the next assumed one.
                    lAKPosn += 1
                    if lAKPosn <= length(lAssumedKeys) then
                        lKey = lAssumedKeys[lAKPosn]
                        if equal("TYPE", lKey) then
                            if lDataType=dataString then
                                lType = w32lookup(upper(w32trim(lData)), w32ControlNames, w32ControlTypes)
                            elsif lDataType=dataAtom then
                                lType = lData
                            end if

                            if lType < 1 or lType > length(w32ControlTypes) then
                                lType = Label
                                lAKPosn += 1
                                lKey = lAssumedKeys[lAKPosn]
                            end if
                            lData = {lType} -- ???
                        end if


                    else
                        -- Too many assumed keys used, so ignore it.
                        warnErr(sprintf("Bad newUIObj() parameter %d\n" &
                                        "Last good one was '%s'\n" &
                                        "Too many assumed keys used.",{i,vRecentNewUI}))
                        return
                    end if
                end if
            else
                -- Badly formed parm so ignore it.
                warnErr(sprintf("Bad newUIObj parameter %d\n" &
                             "Last good one was '%s'\n" &
                       "The key name in a 2-element key/value is not a string.",
                        {i,vRecentNewUI}))
                return
            end if
        else
            -- Wrongly formatted parameter, so ignore it.
            warnErr(sprintf("Bad newUIObj parameter %d\n" &
                             "Last good one was '%s'\n" &
                       "Wrongly formatted parameter.",
                        {i,vRecentNewUI}))
            return
        end if

        if find(lKey, {"CAPTION","TEXT","NAME","TOOLTIP"} ) then
            lData=lKeyValue[w32CompleteText]
        end if

        if equal(lKey, "FLAGS") or equal(lKey, "FLAG") then
            lKey = "FLAGS" -- Standardize
            if lDataType=dataAtom then
                lFlags = or_bits(lFlags,lData)
            else
                if w32string(lData) then
                    lData = {{dataString,lData}}
                else -- multiple
                    for j=1 to length(lData) do
                        lData[j]=getArgValue(lData[j])
                    end for
                end if
                for j = 1 to length(lData) do
                    if lData[j][1]=dataString then
                        lUpperData = upper(w32trim(lData[j][2]))
                        if equal(lUpperData,"NEW") then
                            lNewFlag = w32True
                        else
                            if equal(lUpperData,"AUTOCLOSE") or equal(lUpperData,"W32AUTOCLOSE") then
                                lAutoClose = w32True
                            else
                                lFlags = or_bits(lFlags, w32lookup(lUpperData, vWinFlagNames, vWinFlagValues))
                                lExFlags = or_bits(lExFlags, w32lookup(lUpperData, vWinExFlagNames, vWinExFlagValues))
                                lLVExFlags = or_bits(lLVExFlags, w32lookup(lUpperData, vLVExFlagNames, vLVExFlagValues))
                            end if
                        end if
                    elsif lData[j][1]=dataAtom then
                        lFlags=or_bits(lFlags,lData[j][2])
                    end if
                end for
            end if

        elsif equal(lKey, "EXFLAGS") or equal(lKey, "EXFLAG") then
            lKey = "EXFLAGS" -- Standardize
            if lDataType=dataAtom then
                lFlags = or_bits(lFlags,lData)
            else
                if lDataType=dataString then
                    lData = {lData}
                else -- multiple
                    for j=1 to length(lData) do
                        lData[j]=getArgValue(lData[j])
                    end for
                end if
                for j = 1 to length(lData) do
                    if lData[j][1]=dataString then
                        lUpperData = upper(w32trim(lData[j][2]))
                        if equal(lUpperData,"NEW") then
                            lNewFlag = w32True
                        else
                            lExFlags = or_bits(lExFlags, w32lookup(lUpperData, vWinExFlagNames, vWinExFlagValues))
                            lLVExFlags = or_bits(lLVExFlags, w32lookup(lUpperData, vLVExFlagNames, vLVExFlagValues))
                        end if
                    end if
                end for
            end if

        elsif equal(lKey, "TAG") then
            lPos = find("Tag", lUserProp[1])
            if lPos = 0 then
                lUserProp[1] = append(lUserProp[1], "Tag")
                lUserProp[2] = append(lUserProp[2], 0)
                lPos = length(lUserProp[1])
            end if

            lUserProp[2][lPos] = lData

        elsif equal(lKey, "USER") then
            -- grab the property name and value
            if lDataType=dataMultiple then
                lData[1] = getArgValue(lData[1])
                lData[2] = getArgValue(lData[2])
                lData={lData[1][2],lData[2][2]}
            else
                lData = {lData, ""}
            end if
            lPos = find(lData[1], lUserProp[1])
            if lPos = 0 then
                lUserProp[1] = append(lUserProp[1], lData[1])
                lUserProp[2] = append(lUserProp[2], 0)
                lPos = length(lUserProp[1])
            end if
            lUserProp[2][lPos] = lData[2]

        elsif equal(lKey, "RANGE") then
            if length(lData) >= 2 and length(lData) <= 3 then
                lScrollRange = extractArgs(lData)
            end if


        elsif equal(lKey, "DELTA") then
            if length(lData) = 2 then
                lScrollChange = extractArgs(lData)
            end if

        elsif equal(lKey, "POSITION") then
            lScrollPosition = lData

        elsif equal(lKey, "TYPE") then
            if lType=0 then
                if lDataType=dataString then
                    lType = w32lookup(upper(w32trim(lData)), w32ControlNames, w32ControlTypes)
                elsif lDataType=dataAtom then
                    lType = lData
                end if
            end if

            if lType < 1 or lType > length(w32ControlTypes) then
                warnErr(sprintf("Bad newUIObj() parameter %d\n" &
                                "Last good one was '%s'\n" &
                                "Unknown control TYPE specified.",{i,vRecentNewUI}))

                return
            end if

            if lType = Window then
                lDefLeft = Default
                lDefTop = Default
                lDefWidth = lWidth
                lDefHeight = lHeight
            else
                lDefLeft = 5
                lDefTop  = 5
                lDefWidth = lWidth
                lDefHeight = lHeight
            end if

            if find(lType, {Menu,MenuItem,MenuSpacer,Popup,TabItem,StatusBar}) then
                lDefWidth = 0
                lDefHeight = 0
                lDefLeft = 0
                lDefTop = 0
            elsif find(lType, {ReBar,ReBarBand,Pixmap}) then
                lDefWidth = 1
                lDefHeight = 1
                lDefLeft = 0
                lDefTop = 0
            end if

            if equal(lLeft,"") then
                lLeft = lDefLeft
            end if
            if equal(lTop,"") then
                lTop = lDefTop
            end if
            if equal(lWidth,"") then
                lWidth = lDefWidth
            end if
            if equal(lHeight,"") then
                lHeight = lDefHeight
            end if

        elsif equal(lKey, "CHECK") or equal(lKey, "CHECKED") then
            if atom(lData) then
                lCheck = {w32True,(lData != 0)}
            elsif length(lData) = 0 then
                lCheck = {w32True,w32True}
            elsif equal(upper(lData), "ON") then
                lCheck = {w32True,w32True}
            else
                lCheck = {w32True, (find(lData[1],"YT1yt"))}  -- Yes True 1
            end if

        elsif equal(lKey, "ENABLE") or equal(lKey, "ENABLED") then
            if atom(lData) then
                lEnable = {w32True,(lData != 0)}
            elsif length(lData) = 0 then
                lEnable = {w32True,w32True}
            elsif equal(upper(lData), "ON") then
                lEnable = {w32True,w32True}
            else
                lEnable = {w32True, (find(lData[1],"YT1yt"))}  -- Yes True 1
            end if

        elsif equal(lKey, "VISIBLE") then
            if atom(lData) then
                lVisible = {w32True,(lData != 0)}
            elsif length(lData) = 0 then
                lVisible = {w32True,w32True}
            elsif equal(upper(lData), "ON") then
                lVisible = {w32True,w32True}
            else
                lVisible = {w32True, (find(lData[1],"YT1yt"))}  -- Yes True 1
            end if

        elsif equal(lKey, "WIDTH") then
            -- =num      {num}
            -- =*        {"*"}
            -- =*-num    {"*-num"}
            -- =fld      {"fld"}
            -- =fld-num  {"fld-num"}
            -- =fld-fld  {"fld-fld"}
            -- =-fld     {"-fld"}
            lChar[1] = lCharSize
            lSizeInc = 0
            if equal(lWidth,"") then
                lWidth = 0
            end if
            if lDataType = dataAtom then
                lSizeInc = lData
            else
                lPos = 0 -- zero means add, 1 means multiply, -1 means subtract.
                -- Relative to another control.
                if length(lData) = 0 then
                    lData = "*"
                end if
                if equal(lData[1], '*') then
                    if length(lRefControl) = 0 then
                        lData = vRecentNewUI & lData[2..length(lData)]
                    else
                        lData = lRefControl & lData[2..length(lData)]
                    end if
                end if
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                elsif find('*', lData) then
                    lData = w32split(lData,'*')
                    lPos = 1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                -- lData[1] should be control name
                -- lData[2] should be offset, but can be omitted
                if length(lData) = 1 then
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lData &= 0
                    lPos = 0 -- Force 'add' operation
                else
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lNumData = w32TextToNumber({lData[2],w32True})
                    if lNumData[2] != 0 then
                        lTE = getRecent(w32RecentForms)
                        lData[2] = getNameIdInContext(w32trim(lData[2]), lTE[length(lTE)])
                        if lData[2] > 0 then
                            lTE = getRect(lData[2])
                            lData[2] = lTE[3] - lTE[1]
                        else
                            lData[2] = 0
                            lPos = 0
                        end if
                    else
                        lData[2] = lNumData[1]
                    end if
                end if
                if sequence(lData[1]) then
                    lTE = getRecent(w32RecentForms)
                    lData[1] = getNameIdInContext(w32trim(lData[1]), lTE[length(lTE)])
                end if
                if lData[1] > 0 then
                    lTE = getRect(lData[1])
                    lSizeInc = lTE[3] - lTE[1]
                    if lPos = 0 then
                        lSizeInc += lData[2]
                    elsif lPos = -1 then
                        lSizeInc -= lData[2]
                    else
                        lSizeInc *= lData[2]
                    end if
                end if

            end if

            lWidth += lSizeInc
            if lWidth > 1 then
                lWidth = floor(lWidth)
            end if


        elsif equal(lKey, "HEIGHT") then
            -- =num      {num}
            -- =*        {"*"}
            -- =*-num    {"*-num"}
            -- =fld      {"fld"}
            -- =fld-num  {"fld-num"}
            -- =fld-fld  {"fld-fld"}
            -- =-fld     {"-fld"}

            lChar[2] = lCharSize
            lSizeInc = 0
            if equal(lHeight,"") then
                lHeight = 0
            end if
            if lDataType = dataAtom then
                lSizeInc = lData
            else
                if length(lData) = 0 then
                    lData = "*"
                end if
                if equal(lData[1], '*') then
                    if length(lRefControl) = 0 then
                        lData = vRecentNewUI & lData[2..length(lData)]
                    else
                        lData = lRefControl & lData[2..length(lData)]
                    end if
                end if
                lPos = 0 -- zero means add, 1 means multiply, -1 means subtract.
                -- Relative to another control.
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                elsif find('*', lData) then
                    lData = w32split(lData,'*')
                    lPos = 1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                -- lData[1] should be control name
                -- lData[2] should be offset, but can be omitted
                if length(lData) = 1 then
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    else
                        lData &= 0
                    end if
                    lData &= 0
                    lPos = 0 -- Force 'add' operation
                else
                    if length(lData[1]) = 0 or equal(lData[1], "*") then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lNumData = w32TextToNumber({lData[2],w32True})
                    if lNumData[2] != 0 then
                        lTE = getRecent(w32RecentForms)
                        lData[2] = getNameIdInContext(w32trim(lData[2]), lTE[length(lTE)])
                        if lData[2] > 0 then
                            lTE = getRect(lData[2])
                            lData[2] = lTE[4] - lTE[2]
                        else
                            lData[2] = 0
                            lPos = 0
                        end if
                    else
                        lData[2] = lNumData[1]
                    end if
                end if
                if sequence(lData[1]) then
                    lTE = getRecent(w32RecentForms)
                    lData[1] = getNameIdInContext(w32trim(lData[1]), lTE[length(lTE)])
                end if
                if lData[1] > 0 then
                    lTE = getRect(lData[1])
                    lSizeInc = lTE[4] - lTE[2]
                    if lPos = 0 then
                        lSizeInc += lData[2]
                    elsif lPos = -1 then
                        lSizeInc -= lData[2]
                    else
                        lSizeInc *= lData[2]
                    end if
                end if

            end if

            lHeight += lSizeInc
            if lHeight > 1 then
                lHeight = floor(lHeight)
            end if

        elsif equal(lKey, "TOP") then
            if atom(lData) then
                lTop = lData
            else
                lPos = 0 -- zero means add, -1 means subtract.
                -- Relative to another control.
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                while length(lData) < 3 do
                    lData = append(lData, 0)
                end while

                -- lData[1] should be control name
                -- lData[2] should be offset
                -- lData[3] indicates which edge is relative
                if atom(lData[1]) or length(lData[1]) = 0 then
                    lData[1] = "*"
                end if

                lUpperData = upper(lData[1])
                if equal(lUpperData,"CENTER") or equal(lUpperData,"CENTRE") then
                    lTop = Center
                elsif equal(lUpperData,"DEFAULT") then
                    lTop = Default
                else
                    if length(lData[1]) > 1 and lData[1][length(lData[1])] = '*' then
                        lData[3] = 1
                        lData[1] = lData[1][1..length(lData[1])-1]
                    end if

                    if length(lData[1]) = 0 or equal(lData[1],"*")  then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lTE = getRecent(w32RecentForms)
                    lData[1] = getNameIdInContext(w32trim(lData[1]), lTE[length(lTE)])
                    if lData[1] > 0 then
                        if sequence(lData[2]) then
                            lNumData = w32TextToNumber({lData[2],1})
                            if lNumData[2] = 0 then
                                lData[2] = lNumData[1]
                            else
                                lData[2] = 0
                            end if
                        end if
                        lTE = getRect(lData[1])
                        if lPos < 0 then
                            lData[2] = -lData[2]
                        end if
                        if sequence(lData[3]) or lData[3] != 0 then
                            lTop = lData[2] + lTE[2]
                        else
                            lTop = lData[2] + lTE[4]
                        end if
                    end if
                end if
            end if

        elsif equal(lKey, "LEFT") then
            if atom(lData) then
                lLeft = lData
            else
                lPos = 0 -- zero means add, -1 means subtract.
                -- Relative to another control.
                if find('-', lData) then
                    lData = w32split(lData,'-')
                    lPos = -1
                else
                    lData = w32split(lData,'+')
                    lPos = 0
                end if
                while length(lData) < 3 do
                    lData = append(lData, 0)
                end while

                -- lData[1] should be control name
                -- lData[2] should be offset
                -- lData[3] indicates which edge is relative
                if atom(lData[1]) or length(lData[1]) = 0 then
                    lData[1] = "*"
                end if

                lUpperData = upper(lData[1])
                if equal(lUpperData,"CENTER") or equal(lUpperData,"CENTRE") then
                    lLeft = Center
                elsif equal(lUpperData,"DEFAULT") then
                    lLeft = Default
                else
                    if length(lData[1]) > 1 and lData[1][length(lData[1])] = '*' then
                        lData[3] = 1
                        lData[1] = lData[1][1..length(lData[1])-1]
                    end if

                    if length(lData[1]) = 0 or equal(lData[1],"*")  then
                        if length(lRefControl) = 0 then
                            lData[1] = vRecentNewUI
                        else
                            lData[1] = lRefControl
                        end if
                    end if
                    lTE = getRecent(w32RecentForms)
                    lData[1] = getNameIdInContext(w32trim(lData[1]), lTE[length(lTE)])
                    if lData[1] > 0 then
                        if sequence(lData[2]) then
                            lNumData = w32TextToNumber({lData[2],1})
                            if lNumData[2] = 0 then
                                lData[2] = lNumData[1]
                            else
                                lData[2] = 0
                            end if
                        end if
                        lTE = getRect(lData[1])
                        if lPos < 0 then
                            lData[2] = -lData[2]
                        end if
                        if sequence(lData[3]) or lData[3] != 0 then
                            lLeft = lData[2] + lTE[1]
                        else
                            lLeft = lData[2] + lTE[3]
                        end if
                    end if
                end if
            end if

        elsif equal(lKey, "BOTTOM") then
            lBottom = lData

        elsif equal(lKey, "RIGHT") then
            lRight = lData

        elsif equal(lKey, "AT") then
            -- This must have either zero, or two sub-values, or 'center'.
            if lDataType=dataMultiple then
                lData[1][1]="LEFT"
                lData[2][1]="TOP"
                pParms[i] = lData[1]
                pParms = w32insertElement(pParms, i+1, lData[2])
                incr = 0
            elsif lDataType=dataString then
                if length(lData) = 0 then
                    lData="*"
                else
                    lUpperData = upper(w32trim(lData))
                    if find(lUpperData, {"CENTER","CENTRE"}) then
                        lData="CENTER"
                    end if
                end if
                pParms[i] = {"LEFT",1,0,0,"",lData}
                pParms = w32insertElement(pParms, i+1, {"TOP",1,0,0,"",lData})
                incr = 0
            end if

        elsif equal(lKey, "SIZE") then
            -- This must have either zero, or two sub-values, or 'center'.
            if lDataType=dataMultiple then
                lData[1][1]="WIDTH"
                lData[2][1]="HEIGHT"
                pParms[i] = lData[1]
                pParms = w32insertElement(pParms, i+1, lData[2])
                incr = 0
            elsif lDataType=dataString then
                if length(lData) = 0 then
                    lData="*"
                else
                    lUpperData = upper(w32trim(lData))
                    if find(lUpperData, {"CENTER","CENTRE"}) then
                        lData="CENTER"
                    elsif equal(lUpperData, "MAXIMUM") then
                        lInitView = 1
                        lData = ""
                    elsif equal(lUpperData, "MINIMUM") then
                        lInitView = 2
                        lData = ""
                    end if
                end if
                if length(lData) then
                    pParms[i] = {"WIDTH",1,0,0,"",lData}
                    pParms = w32insertElement(pParms, i+1, {"HEIGHT",1,0,0,"",lData})
                    incr = 0
                end if
            end if

        elsif equal(lKey, "CAPTION") or equal(lKey, "TEXT") then
            if length(lData) and lData[1] = '<' and lData[length(lData)] = '>' then
               lData = rt:UseText(lData[2..length(lData)-1],"")
            end if
            lCaption = w32trim(lData)

        elsif equal(lKey, "VALUE") then
            if atom(lData) then
                lText=sprintf("%d",lData)
            elsif not w32string(lData) then
                lText=extractArgs(lData)
            else
                lText = w32trim(lData)
            end if

        elsif equal(lKey, "NAME") then
            lName = w32trim(lData)

        elsif equal(lKey, "IMAGE") then
            lImage = w32lookup(upper(lData), vWinIconNames, WinIcons)
            if lImage = 0 then
                lImage = lData
            end if

        elsif equal(lKey, "OWNER") or equal(lKey, "PARENT") then
            lKey = "OWNER" -- Standardize
            if atom(lData) then
                lOwner = lData
            else
                lOwner = getNameId(w32trim(lData))
            end if
            if lOwner > 0 and getControlInfo(lOwner,CONTROLINFO_type) = ReBarBand then
                lReBarBand = lOwner
                lOwner = getControlInfo(lOwner,CONTROLINFO_owner)
            end if

        elsif equal(lKey, "TOOLTIP") or equal(lKey, "HINT") then
            lKey = "TOOLTIP" -- Standardize
            lTooltip = lData

        elsif equal(lKey, "EVENT") or equal(lKey, "EVENTS") then
            lKey = "EVENTS" -- Standardize
            if atom(lData) then
                lEventList &= lData
            elsif w32string(lData) then
                lEventList &= w32lookup(upper(w32trim(lData)), vEventNamesUpper,w32EventCodes)
-- PL 29/4/09
--          elsif sequence(lData) then
            else
                while length(lData)=1 do
                    lData=lData[1]
                end while
                if w32string(lData[1]) then
                    lData={lData}
                end if
                for j = 1 to length(lData) do
                    lUpperData = lData[j]
                    if w32string(lUpperData) then
                        lEventList &= w32lookup(upper(w32trim(lUpperData)), vEventNamesUpper,w32EventCodes)
                    elsif not length(lUpperData[1]) then
                        lEventList &= w32lookup(upper(w32trim(lUpperData[w32CompleteText])), vEventNamesUpper,w32EventCodes)
                    else
                    -- 2-element: code plus event handler name
                        lEventList &= w32lookup(upper(w32trim(lUpperData[w32AKey])), vEventNamesUpper,w32EventCodes)
                        lEventList = append(lEventList ,lUpperData[w32PartialText][w32CompleteText])
                    end if
                end for
            end if

        elsif equal(lKey, "BAR") or equal(lKey, "BARS") then
            lKey = "BARS" -- Standardize
            if w32string(lData) then
                lData={lData}
            else
                lData = extractArgs(lData)
            end if
            for j = 1 to length(lData) do
                if w32string(lData[j]) then
                    lData[j] = upper(w32trim(lData[j]))
                    -- Only support statusbar so far.
                    if find(lData[j], {"TOOLBAR","TOOL"})  then
                        lToolbar = w32True

                    elsif find(lData[j], {"FLATTOOLBAR","FLAT", "FLATTOOL"}) then
                        lFlatToolbar = w32True

                    elsif find(lData[j], {"VERT","VERTICAL"}) then
                        lFlags = or_bits(lFlags, WS_VSCROLL)

                    elsif find(lData[j], {"HORZ","HORIZONTAL"}) then
                        lFlags = or_bits(lFlags, WS_HSCROLL)

                    elsif find(lData[j], {"STATUS","STATUSBAR"}) then
                         lStatusBar = w32True
                    end if
                elsif length(lData[j]) >= w32AValue then
                    lData[j] = extractArgs(lData[j])
                    if find(upper(lData[j][w32AKey]), {"STATUS","STATUSBAR"}) then
                        lStatusBar = repeat(-1, length(upper(lData[j][w32AValue])))
                        for k = 1 to length(upper(lData[j][w32AValue])) do
                            if length(lData[j][w32AValue][k]) >= w32AValue then
                                lStatusBar[k] = lData[j][w32AValue][k][w32AValue]
                            end if
                        end for
                    end if
                end if

            end for

        elsif equal(lKey, "FONT") then
            lFont = lData

        elsif equal(lKey, "INITIAL") or equal(lKey, "INITIALFOCUS") then
            lKey = "INITIALFOCUS"

            if atom(lData) then
                lInitFocus = (lData != 0)
            elsif equal(upper(lData), "ON") then
                lInitFocus = w32True
            else
                lInitFocus = (find(lData[1],"YT1yt"))  -- Yes True 1
            end if

        elsif equal(lKey, "COLUMNS") or equal(lKey, "COLUMN") then
            lKey = "COLUMNS"
            lLVColumns = ""
            lData=extractArgs(lData)

            -- It must be enclosed in braces.
            for k = 1 to length(lData) do
                lFlds = w32trim(lData[k])
                if length(lFlds) > 0 and lFlds[1] = '(' and lFlds[length(lFlds)] = ')' then
                    lFlds = w32split(lFlds[2..length(lFlds)-1],',')
                    lCTitle = ""
                    lCWidth = 100
                    lCAlign = -1

                    for j = 1 to length(lFlds) do
                        lFlds[j] = w32trim(lFlds[j])
                        if equal(lFlds[j], ">") and lCAlign = -1 then
                            lCAlign = LVCFMT_RIGHT
                        elsif equal(lFlds[j], "^") and lCAlign = -1 then
                            lCAlign = LVCFMT_CENTER
                        elsif equal(lFlds[j], "<") and lCAlign = -1 then
                            lCAlign = LVCFMT_LEFT
                        elsif equal(upper(lFlds[j]), "LEFT") and lCAlign = -1 then
                            lCAlign = LVCFMT_LEFT
                        elsif equal(upper(lFlds[j]), "RIGHT") and lCAlign = -1 then
                            lCAlign = LVCFMT_RIGHT
                        elsif equal(upper(lFlds[j]), "CENTER") and lCAlign = -1 then
                            lCAlign = LVCFMT_CENTER
                        else
                            lNumData = w32TextToNumber({lFlds[j],w32True})
                            if sequence(lNumData) and lNumData[2] = 0 then
                                -- Yes, it converts nicely.
                                lCWidth = w32abs(floor(lNumData[1]))
                            else
                                lCTitle = lFlds[j]
                            end if
                        end if
                    end for
                    lLVColumns = append(lLVColumns, {lCTitle, lCWidth, lCAlign})
                end if
            end for

        elsif equal(lKey, "FROM") then

            if compare(lData,"")=1 then
                lRefControl = w32trim(lData)
                if equal(lRefControl,"{}") then
                    lRefControl = vRecentNewUI
                end if
            else
                lRefControl = vRecentNewUI
            end if

        elsif equal(lKey, "BGCOLOR") or equal(lKey, "BGCOLOUR") or equal(lKey, "BG") then
            lKey = "BGCOLOR" -- Standardize
            if lDataType = dataAtom then
                lBGColor = lData
            elsif lDataType = dataString then
                lBGColor = w32lookup(upper(w32trim(lData)), w32ColorNames, w32ColorValues)
            else
                lData = {lData[1][w32NumValue],lData[2][w32NumValue],lData[3][w32NumValue]}
                lBGColor = rgb(lData[1], lData[2], lData[3])
                w32ColorValues[length(w32ColorValues)] = lBGColor
            end if

        elsif equal(lKey, "FGCOLOR") or equal(lKey, "FGCOLOUR") or equal(lKey, "FG") then
            lKey = "FGCOLOR" -- Standardize
            if lDataType = dataAtom then
                lFGColor = lData
            elsif lDataType = dataString then
                lFGColor = w32lookup(upper(w32trim(lData)), w32ColorNames, w32ColorValues)
            else
                lData = extractArgs(lData)
                lFGColor = rgb(lData[1], lData[2], lData[3])
                w32ColorValues[length(w32ColorValues)] = lFGColor
            end if

        elsif equal(lKey, "POINTER") then
            lPointer = w32trim(lData)

        elsif equal(lKey,"INDEX") then
            if lType = TabItem then
                lTabIndex = lData
            end if

        elsif equal(lKey, "MEMBER") then
            if integer(lData) and lData > 0 then
                lSetMember = lData
            end if

        elsif equal(lKey, "BUDDY") then
            if atom(lData) then
                lBuddy = floor(lData)
            else
                lBuddy = getNameId(w32trim(lData))
            end if

        elsif equal(lKey, "PRAGMA") then
            lDirective = upper(w32trim(lData))

        elsif equal(lKey, "POPUP") then

            if length(lData) > 0 then

                lData=extractArgs(lData)
                for j = 1 to length(lData) do
                    lData[j] = w32trim(lData[j])
                    if length(lData[j]) = 0 then
                        lData[j] = -1
                    else
                        lData[j] = getNameId(lData[j])
                    end if
                end for

                lAttachPopup = lData
            end if


        end if

        lPos = find(lKey, lAssumedKeys)
        if lPos then
            lAssumedKeys = w32removeIndex(lPos, lAssumedKeys)
            if lPos <= lAKPosn then
                lAKPosn -= 1
            end if
        end if

        i += incr
    end while

    -- All parameters have been processed.

    -- so now we check for missing values etc...
    if equal(lCaption, {{}}) then
        lCaption = ""
        if length(lName) = 0 then
            lName = {{}}
        end if

    elsif length(lCaption) = 0 then
        if length(lName) = 0 then
            -- This is fixed up after the control is created.
        else
            -- Do not set a default caption for certain control types.
            if find(lType, {StatusBar, EditText, MleText, ToolBar, FlatToolBar,
                            Pixmap, Bitmap,Group}) = 0 then
                lCaption = lName
            end if
        end if
    else
        if lCaption[1] = '<' and lCaption[length(lCaption)] = '>' then
            lCaption = rt:UseText(lCaption[2..length(lCaption)-1],"")
        end if
    end if

    if length(lName) = 0 then
        if w32string(lCaption) then
            lName = lCaption
        else
            lName = {{}}
        end if
    end if

    if sequence(lOwner) then
        -- No parent was specified.
        if lType = MenuItem or lType = MenuSpacer then
            lOwner = getRecent(w32RecentMenu)

        elsif lType = TabItem then
            lOwner = getRecent(w32RecentTabControl)

        elsif lType = ReBarBand then
            lOwner = 0

        elsif find(lType, {Window, Pixmap} ) = 0 then
            lOwner = getRecent(w32RecentWindow)

        else
            if (lType = Window) and getRecent(w32RecentWindow) != 0 then
                -- Make this a child window.
                if sequence(lFlags) then
                    lFlags = lFlags[1]
                end if
                lFlags = w32or_all({lFlags, WS_CHILD, WS_VISIBLE, WS_CLIPSIBLINGS})
                lFlags = {and_bits(lFlags,#FF30FFFF)}
                lOwner = getRecent(w32RecentWindow)
            else
                lOwner = 0
            end if
        end if
    end if

    -- Both top and left must either be 'Default' or 'not Default'.
    -- We can't have a mixture.
    if equal(lTop,Default) and not equal(lLeft, Default) then
        lTop = 0
    elsif equal(lLeft,Default) and not equal(lTop, Default) then
        lLeft = 0
    end if

    if lType = ListView then
        if length(lLVColumns) > 0 then
            lCaption = lLVColumns
            lFlags = or_bits(lFlags, LVS_REPORT)
        end if
    end if

    if lTabIndex then
        lLeft = lTabIndex
    end if

    if lNewFlag then
        lFlags = {lFlags}
    end if
    if lNewExFlag then
        lExFlags = {lExFlags}
    end if

    ------------------------------------------
    -- Finally we get to create the control.

    lID = createEx(lType, lCaption, lOwner,
                   lLeft, lTop, lWidth, lHeight,
                   lFlags, lExFlags)
    ------------------------------------------

    -- Test for user defined properties.
    for j = 1 to length(lUserProp[1]) do
        defineUserProperty(lID, lUserProp[1][j], lUserProp[2][j])
    end for

    if equal(lName, {{}}) then
        lName = sprintf("NoName%d", lID)

    elsif length(lName) = 0 then
        lName = sprintf("NoName%d", lID)
--        if find(lType, {StatusBar, EditText, MleText, ToolBar, FlatToolBar,
--                            Pixmap, Bitmap,Combo,ComboBoxEx,Group}) = 0 then
--            lCaption = lName
--        end if
--        call_proc(r_setText,{lID, lCaption})
    end if

    setIdName(lID, lName )
    vRecentNewUI = getIdName(lID)

    if lType = ListView then
        if lLVExFlags != 0 then
            setLVStyle(lID, lLVExFlags)
        end if
    end if

    if lType = Window then
        if atom(lStatusBar) then
            lBarId = create(StatusBar, "", lID, 0, 0, 0, 0, 0)
            setIdName(lBarId, lName & "SB" )
            setDeferredHandlers(lBarId, w32HClick)
        elsif length(lStatusBar) > 0 then
            lBarId = create(StatusBar, "", lID, 0, lStatusBar, 0, 0, 0)
            setIdName(lBarId, lName & "SB" )
            setDeferredHandlers(lBarId, w32HClick)
        end if

        if atom(lToolbar) then
            lBarId = create(ToolBar, "", lID, 0, 0, 0, 34, 0)
            setIdName(lBarId, lName & "TB" )

        elsif atom(lFlatToolbar) then
            lTemp = getTextExtent(Screen, "|")
            lTemp = (32 + 12 + lTemp[2])
            lBarId = create(FlatToolBar, "", lID, 0, 0, 0, lTemp, 0)
            setIdName(lBarId, lName & "FB" )
        end if

        if lInitView = 1 then
            setSWStyle(lID, SW_MAXIMIZE)
        elsif lInitView = 2 then
            setSWStyle(lID, SW_MINIMIZE)
        end if
    end if

    if lInitFocus != 0 then
        lTE = getControlInfo(lOwner,CONTROLINFO_focus_order)
        lInitFocus = find(lID,lTE)
        if lInitFocus>1 then
            lTE[1..lInitFocus] = lID & lTE[1..lInitFocus-1]
            lTE = setTabStops(lOwner,lTE)
        end if
    end if

    -- See if a list needs initial data
    if length(lText) > 0 then
        lTE = getControlInfo(lID, CONTROLINFO_classinfo)
        if find(lTE[2], {COMBO,LISTBOX}) then
            addItem(lID, lText)
        end if
    end if

    -- See if we need to add this to a rebar band
    if atom(lReBarBand) then
        addToBand(lID,  lReBarBand )
    end if

    -- See if this has a special mouse pointer
    if atom(lPointer) or length(lPointer) > 0 then
        setMousePointer(lID, lPointer)
    end if


    if length(lFont) > 0 then
        lFormattedFont = getControlInfo(lID,CONTROLINFO_font)
        if w32string(lFont) then
            lFormattedFont[w32FontName] = lFont
        else
            for j = 1 to length(lFont) do
                if lFont[j][w32ConvCode] = 2 then
                    lFormattedFont[w32FontSize] = lFont[j][w32NumValue]
                else
                    lUpperData = upper(w32trim(lFont[j][w32CompleteText]))
                    if equal(lUpperData,"NEW") then
                        lFormattedFont[w32FontAttrib] = 0
                    elsif equal(lUpperData,"BOLD") then
                        lFormattedFont[w32FontAttrib] = or_bits(Bold, lFormattedFont[w32FontAttrib])
                    elsif equal(lUpperData, "ITALIC") then
                        lFormattedFont[w32FontAttrib] = or_bits(Italic, lFormattedFont[w32FontAttrib])
                    elsif equal(lUpperData, "UNDERLINE") then
                        lFormattedFont[w32FontAttrib] = or_bits(Underline, lFormattedFont[w32FontAttrib])
                    elsif equal(lUpperData, "STRIKEOUT") then
                        lFormattedFont[w32FontAttrib] = or_bits(Strikeout, lFormattedFont[w32FontAttrib])
                    elsif equal(lUpperData, "NORMAL") then
                        -- do nothing.
                    else
                        lFormattedFont[w32FontName] = lFont[j][w32CompleteText]
                    end if
                end if
            end for
        end if

        call_proc(r_setFont, lID & lFormattedFont[1..3])
    end if

     if equal(lWidth,"") then
        if lType = Window then
            iTemp=find(lID,autoSizes)
            if iTemp then
                autoFlags[iTemp]=or_bits(autoFlags[iTemp],2)
            else
                autoSizes &= lID
                autoFlags &= 2
            end if
        end if
        if length(lCaption) > 0 then
            lWidth = getTextWidth(lID, lCaption)
            lTE = getControlInfo(lID, CONTROLINFO_classinfo)
            if lTE[2] = BUTTON then
                lWidth += 12
            elsif lType = Window then
                lWidth += getSystemMetrics(SM_CXICON) * 4
            end if

            if lType = CheckBox then
                lWidth += 12
            elsif lType = Radio then
                lWidth += 12
            end if
        else
            lWidth = 1
            lChar[1] = w32True
        end if
        lResize = w32True
    end if

    if equal(lHeight,"") then
        if lType = Window then
            iTemp=find(lID,autoSizes)
            if iTemp then
                autoFlags[iTemp]=or_bits(autoFlags[iTemp],1)
            else
                autoSizes &= lID
                autoFlags &= 1
            end if
            lHeight = 50
        elsif length(lCaption) > 0 then
            lHeight = 10 + getTextHeight(lID, lCaption)
            lTE = getControlInfo(lID, CONTROLINFO_classinfo)
            if lTE[2] = BUTTON then
                lHeight += 6
            end if
        else
            lHeight = 1
            lChar[2] = w32True
        end if
        lResize = w32True
    end if

    if find(w32True, lChar) then
        lTE = getTextExtent(lID, "M")
        if lChar[1] then
            lWidth = lWidth * lTE[1] + 6
            iTemp = getControlInfo(lID, CONTROLINFO_classinfo)
            if iTemp[2] = BUTTON then
                lWidth += 6
            end if
        end if

        if lChar[2] then
            lHeight = lHeight * lTE[2] + 10
            lTE = getControlInfo(lID, CONTROLINFO_classinfo)
            if lTE[2] = BUTTON then
                lHeight += 6
            end if
        end if

        lResize = w32True
    end if

    if atom(lRight) then
        lTE = getRect(lID)
        if lTE[3]-lTE[1] > lWidth then
            lWidth = lTE[3]-lTE[1]
        end if
        lOwner = findParent(lID)
        if lOwner = 0 then
            lOwner = Screen
        end if
        lParentRect = getClientRect(lOwner)
        lLeft = lParentRect[3]-lRight-lWidth-lParentRect[1]

        setRect(lID, lLeft, lTE[2], lWidth, lTE[4]-lTE[2], w32True )


    end if

    if atom(lBottom) then
        lTE = getRect(lID)
        if lTE[4]-lTE[2] > lHeight then
            lHeight = lTE[4]-lTE[2]
        end if
        lOwner = findParent(lID)
        if lOwner = 0 then
            lOwner = Screen
        end if
        lParentRect = getClientRect(lOwner)
        lTop = lParentRect[4]-lBottom-lHeight-lParentRect[2]

        setRect(lID, lTE[1], lTop, lTE[3]-lTE[1], lHeight, w32True)

    end if

    if lResize then
        lTE = getRect(lID)
        if not equal(lLeft, Center) then
            lLeft = lTE[1]
        end if
        if not equal(lTop, Center) then
            lTop = lTE[2]
        end if
        setRect(lID, lLeft, lTop, lWidth, lHeight, w32True)
    end if

    if atom(lTooltip) or length(lTooltip) > 0 then
        setHintEx(lID, lTooltip,0)
    end if

    if lCheck[1] then
        setCheck(lID, lCheck[2])
    end if
    if lEnable[1] then
        setEnable(lID, lEnable[2])
    end if
    if lVisible[1] then
        if lVisible[2] = 0 and lType = Window then
            setSWStyle(lID,SW_HIDE)
        else
            setVisible(lID, lVisible[2])
        end if
    end if

    if lAutoClose then
        setHandler(lID, w32HClick, r_autoclose)
    end if

    if lSetMember > 0 then
        setControlSet(lSetMember, w32True, lID)
    end if

    if (getControlInfo(lID,CONTROLINFO_class) = BUTTON or find(lType,{MenuItem, StatusBar,Bitmap,Icon,LText,RText,CText} )) and find(w32HClick, lEventList) = 0 then
        lEventList &= w32HClick

    elsif find(lType,{HScroll,VScroll,HTrackBar,VTrackBar,ProgressBar,UpDown}) and find(w32HScroll, lEventList) = 0 then
        lEventList &= w32HScroll

    elsif find(lType,{EditText,MleText,RichEdit}) then
        if find(w32HKeyPress, lEventList) = 0 then
            lEventList &= w32HKeyPress
        end if

        if find(w32HKeyDown, lEventList) = 0 then
            lEventList &= w32HKeyDown
        end if

        if find(w32HKeyUp, lEventList) = 0 then
            lEventList &= w32HKeyUp
        end if

    elsif lType = Window then
        if find(w32HScroll, lEventList) = 0 then
            lEventList &= w32HScroll
        end if
        if find(w32HPaint, lEventList) = 0 then
            lEventList &= w32HPaint
        end if
        if find(w32HOpen, lEventList) = 0 then
            lEventList &= w32HOpen
        end if
        if find(w32HActivate, lEventList) = 0 then
            lEventList &= w32HActivate
        end if
        if find(w32HResize, lEventList) = 0 then
            lEventList &= w32HResize
        end if
        if find(w32HClose, lEventList) = 0 then
            lEventList &= w32HClose
        end if
    end if
    setDeferredHandlers(lID, lEventList)

    -- Check if this has been added since the application started running.
    if getAppState() = kStarted then
        ResolveDeferredHandler(lID)
        if lBarId != 0 then
            ResolveDeferredHandler(lBarId)
        end if
    end if

    -- Test for special scrollbar values
    if length(lScrollRange) != 0 then
        if length(lScrollRange) = 2 then
            setScrollRange(lID, lScrollRange[1], lScrollRange[2])
        elsif length(lScrollRange) = 3 then
            setWindowScrollRange(lID, 0, lScrollRange[1], lScrollRange[2], lScrollRange[3])
        end if
    end if
    if length(lScrollChange) != 0 then
        setScrollChange(lID, lScrollChange[1], lScrollChange[2])
    end if
    if atom(lScrollPosition) then
        setScrollPos(lID, lScrollPosition)
    end if
    if lBuddy > 0 then
        setBuddy(lID, lBuddy)
    end if

    -- Test for image setting
    if sequence(lImage) then
        if length(lImage) > 0 then
            if find(lType, {Window, Icon}) != 0 then
                setIcon(lID, lImage)
            elsif lType = Bitmap then
                setBitmap(lID, lImage)
            elsif lType=TabItem then
                w32VOID = setTabImage(lID,lImage)
            end if
        end if
    else
        setIcon(lID, lImage)
    end if
    lParent = getControlInfo(lID,CONTROLINFO_owner)

    -- Test for background color change
    if equal(lBGColor, "PARENT") then
        bgcolor = getControlInfo(lParent,CONTROLINFO_bcolor)
        setBackground(lID,sequence(bgcolor), bgcolor)
    elsif not sequence(lBGColor) then
        setWindowBackColor(lID, lBGColor)
    end if
    if not sequence(lFGColor) then
        setTextColor(lID, lFGColor)
    end if

    -- Test for parent auto sizing.
    if lParent != 0 and not find(lType,{Popup,Menu,MenuItem,MenuSpacer,Pixmap}) then
        iTemp = find(lParent,autoSizes)
        if iTemp and and_bits(autoFlags[iTemp],1) then
            lTE = getRect(lID)
            lParentRect = call_func(r_getClientRect,{lParent})
            if lTE[4] + 5 > lParentRect[4]-lParentRect[2] then
                setClientRect(lParent,lParentRect[3]-lParentRect[1],lTE[4] + 5)
            end if

        end if

        if iTemp and and_bits(autoFlags[iTemp],2) then
            lTE = call_func(r_getRect,{lID})
            lParentRect = call_func(r_getClientRect,{lParent})
            if lTE[3] + 5 > lParentRect[3]-lParentRect[1] then
                setClientRect(lParent,lTE[3] + 5,lParentRect[4]-lParentRect[2])
            end if

        end if
    end if

    if sequence(lAttachPopup) then
        w32VOID = attachPopup(lID, lAttachPopup)
    end if

    if sequence(lDirective) then
        if equal(lDirective, "PARENT") or equal(lDirective, "*") then
            lType=getControlInfo(lID,CONTROLINFO_type)
            if lType = Menu then
                setRecent(w32RecentMenu, getNameId(lName))
            elsif lType = Window then
                setRecent(w32RecentWindow, getNameId(lName))
            elsif lType = TabControl then
                setRecent(w32RecentTabControl, getNameId(lName))
            end if
        end if

        return
    end if

end procedure

--/topic Forms
--/proc createForm(sequence pFormDefinition )
--/desc This creates a Window and its controls.
--/i pFormDefinition is a list of Control definitions, the first is assumed to be
-- a Window definition and the rest are the controls that the window is to contain.
--Each control definition is passed on to /newUIObj to create the actual control in
-- the order they are defined in /i pFormDefinition.
--
--The elements in /i pFormDefinition as strings that each define a single control. The
-- string is a comma separated list of parameters in the form KEY=VALUE, but note
-- that some key names can be defaulted if omitted.
-- All the parameters have a keyword name, which is not case sensitive, meaning
-- that "width=200" and "WIDTH=200" are both acceptable. However, certain
-- parameters can have assumed keyword names if not supplied. The first unnamed
-- parameter is assumed to be the "TYPE" parameter, the second unnamed
-- is assumed to be "CAPTION", and so on for "NAME", "LEFT", "TOP", "WIDTH",
-- "HEIGHT", "FLAGS", and "EXFLAGS" parameters, in that order. If there
-- are still unnamed parameters after all the assumed ones have been
-- allocated, an error message is issued.
--
-- Also note that /b "include w32Start.ew" is usually used in conjunction with
-- applications that use createForm()
--
--Example:
--/code
--      createForm({"Window, Login,height=200,bar=status, left=10, top=Center",
--                  "RText,   User Name:, left=10,top=10",
--                  "EditText,User Name Text,caption=(), from=UserName" &
--                            ", left=(2),top=(-2,,), width=25chars",
--                  "RText,   Password:, from=UserName,left=(),top=(15),width=()",
--                  "EditText,Password Text,caption=(), from=Password" &
--                            ", left=(2),top=(-2,,), width=(),flag=es_password",
--                  "DefPushButton,&Submit, right=75, width=70,bottom=5, height=25",
--                  "CancelButton,&Cancel,  from=Submit, left=(5),top=()" &
--                  ", height=(), width=(), flag=autoclose",
--                  "TabOrder=(UserName,PasswordText,Submit)"
--                  })
--/endcode

global procedure createForm(sequence pForm)
    object lCtlDefn
    integer lPos
    object lTemp
--  integer lNewId  -- PL 29/4/09
    integer lDelim
    sequence lKeyValue
object XXX

    if length(pForm) = 0 then
        return
    end if


    -- Pass 1: Standardize the control definitions.
    if w32string(pForm) then
        pForm = {pForm}
    end if

    for i = 1 to length(pForm) do
        if not w32string(pForm[i]) then
            lPos = 0
            while lPos < length(pForm[i]) do
                lPos += 1
                if sequence(pForm[i][lPos]) then
                    -- Convert an embedded sequence to a string.
                    lTemp = w32ToString(pForm[i][lPos])
                    if not find(',', lTemp) then
                        -- Strip off enclosing parens if not a list of items.
                        lTemp = lTemp[2..length(lTemp)-1]
                    end if
                    pForm[i] = pForm[i][1..lPos-1] &
                               lTemp &
                               pForm[i][lPos+1..length(pForm[i])]
                    lPos -= 1
                end if
            end while
        end if
    end for

    lPos = 1
    while lPos <= length(pForm) do
        lCtlDefn = pForm[lPos]

        -- Only deal with non-empty definitions!
        if length(lCtlDefn) != 0 then
            -- Split it up delimited by commas
            if length(lCtlDefn) > 0 and find(lCtlDefn[1], ";`~|#/\\-_^*@,") then
                lDelim = lCtlDefn[1]
                lCtlDefn = lCtlDefn[2..length(lCtlDefn)]
            else
                lDelim = ','
            end if
            pForm[lPos] = w32MakeArgs(lCtlDefn, lDelim, '=')

        else
            -- delete the empty string.
            pForm = pForm[1..lPos-1] & pForm[lPos+1 .. length(pForm)]
            lPos -= 1
        end if

        lPos += 1
    end while

    -- Pass 2: Make sure a 'window' definition is the first one.
    lPos = 0
    for i = 1 to length(pForm) do
        lCtlDefn = pForm[i]
        for j = 1 to length(lCtlDefn) do
            lKeyValue = lCtlDefn[j]

            if j = 1 and equal(upper(lKeyValue[w32CompleteText]), "WINDOW") then
                lPos = i
                exit
            end if
        end for
        if lPos != 0 then
            exit
        end if
    end for
    if lPos = 0 then
        -- No Window explictly defined, so I assume one.
        pForm[1] = prepend(pForm[1], {"TYPE",1,2,Window,"",""})
    end if

    -- Ensure form type is first element.
    if lPos > 1 then
        lCtlDefn = pForm[lPos]
        pForm = prepend(w32removeIndex(lPos, pForm), lCtlDefn)
    end if

    clearRecents()

    -- Pass 3: Define each control in order.
    for i3 = 1 to length(pForm) do
--      newUIObj(pForm[i3])
XXX = pForm[i3]
newUIObj(XXX)
        if i3 = 1 then
            setRecent(w32RecentForms,getRecent(w32RecentWindow))
        end if
    end for

end procedure
r_createForm = routine_id("createForm")

--/topic Forms
--/func getFormIds(integer Action)
--/desc Returns the most recently created form(s)
--/ret SEQUENCE: A list of window ids created by the /createForm routine.
--If /i Action = 1 then only the most recent form id is returned,
--otherwise all the form ids are returned as a list ordered from
--oldest to most recently created.
--
--Example:
--/code
--      sequence fid
--      -- Create a form
--      createForm(FormDefn)
--      -- Get its form (window) id.
--      fid = getFormIds(1)
--/endcode
global function getFormIds(integer pAction)
    sequence s

    s = getRecent(w32RecentForms)
    -- N.B. The first entry is a dummy one and should never be used.
    if length(s) <= 1 then
        return {}
    end if

    if pAction = 1 then
        return {s[length(s)]}
    end if

    return s[2..length(s)]
end function
r_getFormIds = routine_id("getFormIds")

--/topic Forms
--/func loadForms(sequence FileName)
--/desc Builds a form definition from a text file.
--/ret SEQUENCE: A form definition suitable to give to /createForm()
--/i FileName is the pathname of a file that contains form definition
--statements. These are almost identical to the ones used by /newUIObject
--but there are a few differences to help laying out the text file.
--
--The form definition file consists of one or more lines of text. Any
--text following the /b"comment string" are stripped off. Initially
-- the comment string is two semi-colons, eg. ";;". /n
--The lines are grouped into UI Object definitions. Each definition
-- starts in column 1. If you need to extend a definition over
-- multiple lines, offset the second and subsequent lines by at least
-- one space (or tab) character.
--
--You can change the default comment string by inserting a comment
-- in the form "comment=~<xxx>" where "~<xxx>" is one or more characters
--that become the new comment lead-in string from that point onwards.
--
--Example of a form definition file:
--/code
-- ;;comment=---
-- --- Customer.form
-- --- This defines the customer input screen.
--
-- Window, Customer Input
--         at={20, 20}
--         bar=status
--
--
-- Label, Number ------------------ Customer Number
--      at={5,10}
-- EditText
--      left={}, top={0}, width=20ch
--
-- Label, Name ------------------ Customer Name
--      left={}, top={4}
-- EditText
--      left={}, top={0}, width=50char
--
-- Button, Accept
--      left={}, top={10}
-- Button, Cancel
--      left={4}, top={}
--/endcode
--
--Example for calling loadForm:
--/code
--      sequence lFormDefn
--      lFormDefn = loadForm("customer.form")
--      createForm(lFormDefn)
--      lFormId = getFormIds(1)
--      setText(lFormId[1], sprintf("%s (%d)",{getText(lFormId[1]), lFormId[1]}))
--/endcode

-----------------------------
global function loadForm(sequence pName)
-----------------------------
    integer lFH
    sequence lForm
    object lLine
    sequence lDefn
    integer lCont
    integer lPos
    sequence lCommentLead
    sequence lComment


    lCommentLead = ";;"
    lForm = {}
    lFH = w32FileOpen(pName, "r")
    if lFH = -1 then
        return {}
    end if

    lDefn = ""
    lLine = gets(lFH)
    while sequence(lLine) do
        lCont = lLine[1]
        lLine = w32trim(lLine)
        lPos = match(lCommentLead, lLine)
        if lPos != 0 then
            lComment = lLine[lPos+length(lCommentLead)..length(lLine)]
            lLine = w32trim(lLine[1..lPos-1])
            if match("comment=", lComment) = 1 and length(lComment) > 8 then
                lCommentLead = lComment[9..length(lComment)]
            end if
        end if
        if length(lLine) > 0 then
            if lCont = ' ' or lCont = '\t' then
                if length(lDefn) > 0 and lDefn[length(lDefn)] != ',' then
                    lDefn &= ','
                end if
                lDefn &= lLine
            else
                if length(lDefn) > 0 then
                    lForm = append(lForm, lDefn)
                end if
                lDefn = lLine
            end if
        end if

        lLine = gets(lFH)
    end while
    if length(lDefn) > 0 then
        lForm = append(lForm, lDefn)
    end if

    close(lFH)

    return lForm
end function


ctrl_Deferred_Handlers = routine_id("getDeferredHandlers")
r_getAutoSize = routine_id("getAutoSize")
r_ResolveDeferredHandlers = routine_id("ResolveDeferredHandlers")

sequence vRegisteredNames
sequence vRegisteredRID
vRegisteredNames = {}
vRegisteredRID = {}

--/topic Support Routines
--/func w32routine_id(sequence pRoutineName)
--/desc Returns the routine id for the registered routine /i pRoutineName
--/ret INTEGER: The routine id or -1 if /i pRoutineName is not registered.
--This can only find routines that have been registered via /registerRoutine()
-- and is used by /w32Start.ew to automatically set handlers based on the
-- standard naming convention for even handlers.
--
--Example:
--/code
--  integer id
--  id = w32routine_id(EventType & "_" & ControlName)
--/endcode

global function w32routine_id(sequence pRoutineName)
integer lPos

        lPos = find(pRoutineName, vRegisteredNames)
        if lPos > 0 then
            return vRegisteredRID[lPos]
        else
            return -1
        end if
end function

--/topic Support Routines
--/proc registerRoutine(sequence pRoutineName, integer pRoutineId)
--/desc Registers a text string with an associated routine_id.
--This is primarily used to add routines to an internal list so that /w32start.ew
-- can automatically find event handlers. However it can be used to link and text string to
-- a routine_id, and later you can use /w32routine_id() to retrieve the routine_id given the
-- text string.
--
--Example:
--/code
--  registerRoutine("Click_BigButton", routine_id("Click_BigButton"))
--  registerRoutine("MainAction", routine_id("Click_BigButton"))
--
--  rid = w32routine_id("MainAction")
--  if rid != -1 then
--      call_proc(rid, { . . . }) -- This calls Click_BigButton procedure.
--  end if
--/endcode
global procedure registerRoutine(sequence pRoutineName, integer pRoutineId)
        vRegisteredNames = append(vRegisteredNames, pRoutineName)
        vRegisteredRID = append(vRegisteredRID, pRoutineId)
end procedure

--/topic Controls
--/func registerControl(sequence pControlName, sequence pRID)
--/desc Enables you to define new control types.
--/ret A control type identifier, which you can use as the first argument of create[Ex]().
--       -1 is returned if the class is registered already.
--
-- pControlName is a string that identifies the control, like "ListView". /n
-- pRID is a sequence of four routine ids: the control, create, process and destroy routines.
--
-- The control routine is passed two parameters: a command name and a default value. Its
-- routine id must always be valid.
-- At class registration time, the routine will be called in sequence with the following arguments:
--/define
--/term "className"
-- supply a string, or -1 (default) if this is not to be a Windows class
--/term "classType"
-- return the control type the library should consider your control to belong to. Default is -1. 
--  For instance, return RichEdit if your contol is to be sent RichEdit-specific messages.
--/term "classStyle"
-- return the sum of the class style flags the new class must have. Default is 0.
--/term "classStyleEx"
-- return the sum of the class extended style flags the new class must have. Default is 0.
--/term "classAttr"
-- return the sum of win32lib class attributes the new class must have. Default is 0.
-- "classDefPointer"
-- return an identifier for the mouse pointer shape to use over this kind of control. 
--  Default is IDC_ARROW (the standard pointer carrow).
--/term "classBGColor"
-- return a 24-bit integer representing the background color for all controls of that class, 
--  or a system color identifier. Default is w32Color_BTNFACE.
--/term "classFGColor"
-- return a 24-bit integer representing the foreground color for all controls of that class, 
--  or a system color identifier. Default is w32Color_WINDOWTEXT.
--/term "classKbdInput"
-- return the sort of keyboard input controls of the new class should handle, a sum of zero or more flags among the following:
--/li DLGC_BUTTON   Button.
--/li DLGC_DEFPUSHBUTTON    Default push button.
--/li DLGC_HASSETSEL    EM_SETSEL messages.
--/li DLGC_RADIOBUTTON  Radio button.
--/li DLGC_STATIC   Static control.
--/li DLGC_UNDEFPUSHBUTTON  Nondefault push button.
--/li DLGC_WANTALLKEYS  All keyboard input.
--/li DLGC_WANTARROWS   Direction keys.
--/li DLGC_WANTCHARS    WM_CHAR messages.
--/li DLGC_WANTMESSAGE  All keyboard input (the application passes this message on to a control).
--/li DLGC_WANTTAB          TAB key.
-- Default is the corresponding value for the alias class.
--/li DLGC_3STATE
--/enddefine
-- At control creation time, this is called to request the real parent of the control. 
--  It is passed the string "NewOwner" and the parent supplied to create(). 
--  It must return the actual owner of the control being created.
--
-- The create routine will be called at creation time with a string, which is a command word, 
--  and a sequence. If the routine id for it is -1, the routine is not called at all.
-- When called with the command word "Pre", the other sequence contains:
--/item the new control id
--/item the caption
--/item the owner
--/item the x-position
--/item the y-position
--/item the width
--/item the height
--/item the style flags
--/item the extended style flags
-- The routine must return something. If the returned value is a sequence of length 9 whose first 
--  element is the supplied id, the returned values are substituted for the ones that were passed.
--
-- When creation occurred, and instead of setting fonts or loading bitmaps, the library calls the 
--  create routine again with a command word of "Post" and {id} as arguments.
-- The routine may then perform the same kind of tasks on the newly created control.
-- If the function returns {id,constant}, where the constant is any of /b w32RecentMenu,
-- /b w32RecentTabControl or /b w32RecentWindow, then the control is to be considered the most 
--  recent of the expected kind, which will help parenting further controls to it. If the routine
--  handles actual control creation itself, it must return an atom.
--
-- The process routine  is called before the w32HEvent event is invoked with
--/item The control id
--/item an integer, either kMainMsg or kSubclassedMsg;
--/item The original handle;
--/item The original message;
--/item The original wParam of the message;
--/item The original lParam of the message.
--
-- If it returns a sequence, its first element is returned to Windows (it must be an integer). 
--  If the sequence is empty, 0 is returned.
--
-- The destroy routine is called with the string "Destroy" and a sequence containing the id 
--  of the control to be destroyed. If it returns 0, specific messages are sent.

global function registerControl(sequence pControlName, sequence pRID)
integer lControl,lClass

        -- Is this already registered?

        pControlName = w32trim(pControlName)
        lControl = find(upper(pControlName), w32ControlNames)
        if lControl != 0 then
            return -1
        end if

        w32ControlNames = append(w32ControlNames, upper(pControlName))
        lControl = length(w32ControlNames)
        w32ControlTypes = append(w32ControlTypes, lControl)

        vControlRID = w32MinSequenceSize(vControlRID, lControl, 0)
        vControlRID[lControl] = pRID

        className = w32MinSequenceSize(className, lControl, 0)
        className[lControl] = call_func(pRID[kCRID_Control], {"className", -1})
        classType = w32MinSequenceSize(classType, lControl, 0)
        classAlias = w32MinSequenceSize(classAlias, lControl, 0)
        lClass = call_func(pRID[kCRID_Control], {"classType", -1})
        classAlias[lControl] = lClass
        classType[lControl] = classType[lClass]
        classStyle = w32MinSequenceSize(classStyle, lControl, 0)
        classStyle[lControl] = call_func(pRID[kCRID_Control], {"classStyle", 0})
        classStyleEx = w32MinSequenceSize(classStyleEx, lControl, 0)
        classStyleEx[lControl] = call_func(pRID[kCRID_Control], {"classStyleEx", 0})
        classAttr = w32MinSequenceSize(classAttr, lControl, 0)
        classAttr[lControl] =  call_func(pRID[kCRID_Control], {"classAttr", 0})
        classDefPointer = w32MinSequenceSize(classDefPointer, lControl, 0)
        classDefPointer[lControl] = call_func(pRID[kCRID_Control], {"classDefPointer", IDC_ARROW})
        classBGColor = w32MinSequenceSize(classBGColor, lControl, 0)
        classBGColor[lControl] = call_func(pRID[kCRID_Control], {"classBGColor", WindowColor})
        classFGColor = w32MinSequenceSize(classFGColor, lControl, 0)
        classFGColor[lControl] = call_func(pRID[kCRID_Control], {"classFGColor", w32Color_WINDOWTEXT})
        classKbdInput = w32MinSequenceSize(classKbdInput, lControl, 0)
        classKbdInput[lControl] = call_func(pRID[kCRID_Control], {"classKbdInput", classKbdInput[lClass]})

        return lControl

end function

--/topic Events
--/proc registerNotification(integer pSender, integer pAction, integer pEvent, integer pReceiver, object pUserData)
--/desc Defines, modifies or removes an event forwrding.
-- This procedure instructs the library to forward /i pEvent to /i pReceiver when /i pSender receives it, or to 
--  perform some actions on an existing forwarding./n
-- When a control must notify another, it does so by firing a /w32HNotify event on the receiver. The parameter 
--  sequence for this event is {/i sender,/i event, /i user data,parameter sequence of the triggering event}.
-- /i pAction is any of:
--/li /b w32notifyCreate: creates a new event notification, or change user data associated to an existing one. 
--          The new notification is enabled;
--/li /b w32notifyDefer: creates a new event notification, or change user data associated to an existing one. 
--          The new notification is disabled;
--/li /b w32notifyRemove: the existing notification will no longer exist. Supplied user data is ignored, 
--          current user data is discarded;
--/li /b w32notifyEnable: enables an existing notification.
--/li /b w32notifyDisable: disables an existing notification./n
-- To change the state of a notification, use the /setNotificationState() function./n
--
-- Some user data is associated to every notification. Use the /i pUserData parameter to set or change 
--  this value, which the library doesn't use in any way: it only passes it along. You can retrieve 
--  the data using the /getNotificationData() function.

global constant
w32notifyCreate = 1,w32notifyRemove = 2,w32notifyEnable =3, w32notifyDisable = 4, w32notifyDefer = 5

global procedure registerNotification(integer pSender, integer pAction, integer pEvent, integer pReceiver, object pUserData)
sequence lCurrentIds
sequence lCurrentEvents
sequence lCurrentUP
sequence lCurrentStates
integer lPosR
integer lPosE

        lCurrentIds = ctrl_Notify_List[pSender][1]

        if pAction = 1 or pAction = 5 then
            -- Add, or change user data
            lPosR = find(pReceiver, lCurrentIds)

            if lPosR then
                lCurrentEvents = ctrl_Notify_List[pSender][2][lPosR]
                lCurrentUP  = ctrl_Notify_List[pSender][3][lPosR]
                lCurrentStates  = ctrl_Notify_List[pSender][4][lPosR]
            else
                lCurrentEvents = {}
                lCurrentUP = {}
                lCurrentStates = {}
            end if
            lPosE =  find(pEvent, lCurrentEvents)
            if lPosE = 0 then
                lCurrentEvents &= 0
                lCurrentUP &= 0
                lCurrentStates &= 0
                lPosE = length(lCurrentEvents)
            end if
            lCurrentEvents[lPosE] = pEvent
            lCurrentUP[lPosE] = pUserData
            lCurrentStates[lPosE] = (pAction = w32notifyCreate)

            if lPosR = 0 then
                lCurrentIds &= pReceiver
                ctrl_Notify_List[pSender][2] &= 0
                ctrl_Notify_List[pSender][3] &= 0
                ctrl_Notify_List[pSender][4] &= 0
                lPosR = length(lCurrentIds)
            end if

            ctrl_Notify_List[pSender][1] = lCurrentIds
            ctrl_Notify_List[pSender][2][lPosR] = lCurrentEvents
            ctrl_Notify_List[pSender][3][lPosR] = lCurrentUP
            ctrl_Notify_List[pSender][4][lPosR] = lCurrentStates

            -- added CChris <oedoc@free.fr> Oct 26, 2006
            -- implemented remove notification, enable it, disable it
        elsif pAction=2 then
            -- Remove
            lPosR = find(pReceiver, lCurrentIds)
            if lPosR then
                lCurrentEvents = ctrl_Notify_List[pSender][2][lPosR]
                lCurrentUP  = ctrl_Notify_List[pSender][3][lPosR]
                lCurrentStates  = ctrl_Notify_List[pSender][4][lPosR]
                lPosE =  find(pEvent, lCurrentEvents)
                if lPosE then
                    lCurrentEvents = w32removeIndex(lPosE,lCurrentEvents)
                    lCurrentUP = w32removeIndex(lPosE,lCurrentUP)
                    lCurrentStates = w32removeIndex(lPosE,lCurrentStates)
                    if length(lCurrentEvents) then
                        ctrl_Notify_List[pSender][2][lPosR] = lCurrentEvents
                        ctrl_Notify_List[pSender][3][lPosR] = lCurrentUP
                        ctrl_Notify_List[pSender][4][lPosR] = lCurrentStates
                    else
                        ctrl_Notify_List[pSender] = w32removeItem(lPosR,ctrl_Notify_List[pSender])
                    end if
                end if
            end if
        elsif pAction=3 or pAction=4 then
            -- Enable/disable
            lPosR = find(pReceiver, lCurrentIds)
            if lPosR then
                lCurrentEvents = ctrl_Notify_List[pSender][2][lPosR]
                lPosE =  find(pEvent, lCurrentEvents)
                if lPosE then
                    ctrl_Notify_List[pSender][4][lPosR][lPosE] = (pAction=3)
                end if
            end if
        else
        -- ??????? NOT IMPLEMENTED YET ????????????
        end if

end procedure
r_registerNotification = routine_id("registerNotification")

-- added CChris <oedoc@free.fr> Oct 26, 2006
-- retrieve user data/state for a notification

--/topic Events
--/func getNotificationData(integer pSender,integer pReceiver,integer pEvent)
--/desc Returns the user data associated with the notification.
-- If the notification doesn't exist, returns {}. Otherwise, returns a sequence of length 1, 
--  whose only element is the associated user data, like /getUserProperty() does.
global function getNotificationData(integer pSender,integer pReceiver,integer pEvent)
sequence lTemp
integer lPosR,lPosE

        lTemp = ctrl_Notify_List[pSender][1]
        lPosR = find(pReceiver, lTemp)
        if lPosR then
            lTemp = ctrl_Notify_List[pSender][2][lPosR]
            lPosE =  find(pEvent, lTemp)
            if lPosE then
                return {ctrl_Notify_List[pSender][3][lPosR][lPosE]}
            end if
        end if
        -- not found
        return {}
end function

-- added CChris <oedoc@free.fr> Oct 26, 2006
-- retrieves and sets current state for a notification

--/topic Events
--/func setNotificationState(integer pSender,integer pReceiver,integer pEvent,integer pFlag)
--/desc Possibly sets the state for the designated notification, and returns the former value of the state.
--/ret 1 if enabled, 0 if disabled, -1 if unknown.
-- Set /i pFlag to a positive value to enable a notification, to 0 to disable it and to a negative value to 
--  just return the current state.
global function setNotificationState(integer pSender,integer pReceiver,integer pEvent,integer pFlag)
sequence lTemp,oldState
integer lPosR,lPosE

        lTemp = ctrl_Notify_List[pSender][1]
        lPosR = find(pReceiver, lTemp)
        if lPosR then
            lTemp = ctrl_Notify_List[pSender][2][lPosR]
            lPosE =  find(pEvent, lTemp)
            if lPosE then
                oldState = ctrl_Notify_List[pSender][4][lPosR][lPosE]
                pFlag = compare(pFlag,0)
                if pFlag >= 0 then
                    ctrl_Notify_List[pSender][4][lPosR][lPosE] = pFlag
                end if
                return oldState
            end if
        end if
        -- not found
        return -1
end function

initialize()


-----------------------
--/topic Degraded Routines and Constants
--/info
--These are identifiers that will be removed in future releases.
--There is nearly always an alternative routine or constant to use.

--/topic Degraded Routines and Constants
--/proc setPosition()
--/desc See /setPenPos

--/topic Degraded Routines and Constants
--/proc moveWindow()
--/desc See /setRect

--/topic Degraded Routines and Constants
--/func getExtent()
--/desc See /getCtlSize

--/topic Degraded Routines and Constants
--/proc getSize()
--/desc See /getRect

--/topic Degraded Routines and Constants
--/proc SetPointerPosn()
--/desc See /setPointerPos

--/topic Degraded Routines and Constants
--/proc GetPointerPosn()
--/desc See /getPointerPos

--/topic Degraded Routines and Constants
--/proc ClickPointerLeft()
--/desc See /clickPointerLeft

--/topic Degraded Routines and Constants
--/proc DragPointerTo()
--/desc See /dragPointerTo

--/topic Degraded Routines and Constants
--/proc setPenPosition()
--/desc See /setPenPos

--/topic Degraded Routines and Constants
--/proc insertListViewColumn()
--/desc See /insertLVColumn

--/topic Degraded Routines and Constants
--/func getMousePos()
--/desc See /getPointerPos

--/topic Degraded Routines and Constants
--/func getMouseRelPos()
--/desc See /getPointerRelPos

--/topic Degraded Routines and Constants
--/func setPenROP2()
--/desc See /setPenMode

--/topic Degraded Routines and Constants


--include compat01.ew
-- compat01.ew
-- This file enables old programs to uses some routines due to be removed
-- from Win32Lib v1.0
include w32tk.e

global procedure setPosition(integer win, object x, object y)
    setPenPos(win,x,y)
end procedure

global procedure moveWindow(integer win, object x, object y,
                            object w, object h, integer flag)
    setRect(win, x, y, w, h, flag)
end procedure

global function getExtent(atom o)
    return getCtlSize(o)
end function

global function getSize(atom o)
    return getRect(o)
end function

global procedure setSize(integer win, object w, object h)
    setCtlSize(win, w, h)
end procedure

global procedure SetPointerPosn(sequence pos)
    setPointerPos(pos)
end procedure

global function GetPointerPosn()
    return getPointerPos()
end function

global procedure ClickPointerLeft()
    clickPointerLeft()
end procedure

global procedure DragPointerTo(sequence pos)
    dragPointerTo(pos)
end procedure

global procedure setPenPosition( integer id, object x, object y )
    setPenPos(id, x, y)
end procedure

global procedure insertListViewColumn( atom id, integer index,
                atom mask, atom fmt, atom cx, object text, atom iSubItem )
    insertLVColumn(id,index,mask,fmt,cx,text,iSubItem )
end procedure

global function getMousePos()
    return getPointerPos()
end function

global function getMouseRelPos(integer id)
    return getPointerRelPos(id)
end function

global procedure setPenROP2( integer id, atom rop2 )
    setPenMode(id, rop2)
end procedure

global procedure LimitText(integer id, integer pSize )
    limitText(id,pSize)
end procedure

global function Current_Directory()
    return getCurrentDirectory()
end function

global procedure Set_Directory(sequence x)
    setCurrentDirectory(x)
end procedure

--/topic Degraded Routines and Constants
--/func fetch_SYSTEMTIME(atom SYSTEMTIME)
--/desc See /w32from_memory()

--/topic Degraded Routines and Constants
--/func fetch_CHARFORMAT(atom CHARFORMAT)
--/desc See /w32from_memory()

--/topic Degraded Routines and Constants
--/func struct_TOOLINFO(uFlags, hwnd, uId, rect, text)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_GETTEXTEX(atom buffer_size,atom flags,atom codepage,atom pDefChar,atom pUseChar)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_MENUITEMINFO()
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_LVFINDINFO(atom flags, sequence text, atom lparam,atom x, atom y, atom direction)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_TVINSERTSTRUCT(atom hParent,atom pWhere,atom tvitem)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_FINDTEXTEX(min1, max1, text,min2,max2)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_CHARRANGE(min, max)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_EDITSTREAM(dwCookie, dwError, pfnCallback)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/funcstruct_PARAFORMAT(dwMask, wNumbering,dxStartIndent, dxRightIndent, dxOffset,wAlignment,rgxTabs)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_CHARFORMAT(dwMask,dwEffects,yHeight,yOffset,crTextColor,bCharSet,bPitchAndFamily,szFaceName)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_LVBKIMAGE(atom hBitmap,atom pFlags,sequence url,integer xOffset,integer yOffset)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_REBARBANDINFO(fMask,fStyle,clrFore,clrBack,lpText,iImage,hwndChild,cxMinChild,
--      cyMinChild,cx,hbmBack,wID,cyChild,cyMaxChild,cyIntegral,cxIdeal,lParam,cxHeader)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_LVITEM(mask,item,iSubItem,state,stateMask,text,image,lparam)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_FINDREPLACE(owner, flags, fwhat,rwhat)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_TEXTRANGE(min, max)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_TVITEM(hParent, hInsertAfter, hItem)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/proc w32ElemAddr(atom structure, sequence field)
--/desc See /w32address()


include compat02.ew
