--include file to manage emulated colored buttons
--Judith Evans
--Version 0.1.17 build date 07-04-2008

--This project has evolved over the past several years as people who tested found new features
--they would like added.

--CREDITS:
--  Developed with Euphoria language, Win32lib and IDE developmental tools
--  Andy Drummond supplied many tips for drawing buttons as well as ideas to enhance colored buttons
--      and a trick to prevent w32HClick on real M$ button being handled twice.
--  Rajesh Deshpande suggested placing Graphic on colored button, reminded me I can use getHint to
--      retrieve from createEx button, suggested centering Caption+Graphic as a unit making sure graphic 
--      stays on button (might overlay portion of caption), pushed caption color, assistence using
--      bitmap and ico from Bernie Ryan win32eru package. Rajesh provided a file of several icons and
--      bitmaps for use with the demo.
--  Bernie Ryan for reminding me about and_bits to get BS_MULTILINE style
--  Roland Stowasser informed me that getWindowInfo does not work with Win95; that I should use
--      getStyleFlags
--  Gregory Haberek suggested adding text rotation
--  Thomas Parslow for the irregular.ew lib
--  Chris Cuvier gave me assistence removing a stray pixel near non-rectangular buttons.
--------------------------------------------------------------------------------
--ToDo:
--  capability to rotate graphic as option when caption is rotated; may be restricted to 90 degree rotations
--  capability to rotate rectangular button as option when caption is rotated   
--------------------------------------------------------------------------------
--Problems:
--  presently can not have colored buttons on other buttons or RebarBand
--  drawing arc around corners of RoundedRectangle and the arc around Elliptical buttons is not smooth and there may be gaps.
--      I looked at API FrameRgn but can not get it to work. If anyone has experience using FrameRgn, please give me a tip.
---------------------------------------------------------------------------------
--Notes:
--  I took particular care to react with CancelButton font just as Win32lib does.
--      If user has assigned a font then the caption will appear with the attribute
--      entered. If there is no font (meaning default font or user had never entered
--      a font) then the caption will appear with Italic attribute.
--      With other classes the font attribute, either entered by user or the default font,
--      uses the input or default attribute.
--
--  Colored buttons may be placed on any control that already accepts button controls with
--      the exception of ReBarBand.

--  Beginning with Version 0.1.17 buttons may also be circular,eliptic or rounded rectangular governed
--      by Thomas Parslow's irregular.ew.
--  Caption may be slanted based upon the number of degrees. This feature does not play well 
--      with multiple line Captions however but neither does it on a M$ button.

--------------------------------------------------------------------------------
constant PI=3.141592653589793238

include Irregular.ew
atom Region
sequence args
global constant xFrameRgn = registerw32Function(gdi32,"FrameRgn",repeat(C_PTR,5),C_INT)
--
integer Pixmap1 = createEx(Pixmap,"",0, -1000,-1000,0,0,0,0),
        Pixmap2 = createEx(Pixmap,"",0, -1010,-1000,0,0,0,0)

--array of colored buttons information which gets filled in via translateToColoredButton(...)
global sequence ColoredButtonInformation = {}

global constant
    ColoredButtonName=1,            --this is the M$ button actual id
    ColoredButtonCWName=2,          --this is the emulated button actual id
    ColoredButtonClass=3,
    ColoredButtonWidth=4,
    ColoredButtonHeight=5,
    ColoredButtonColor=6,
    ColoredButtonPressColor=7,          
    ColoredButtonCaption=8,
    ColoredButtonCaptionPos=9,      -- 1 = left justified; 2 = right justified 0 = centered
    ColoredButtonThickness=10,      -- thickness of the border around button
    ColoredButtonGraphic=11,        -- PictureButton of TogglePicture graphic
    ColoredButtonPressedTimes=12,   -- TogglePicture pressed times; controls presentation
    ColoredButtonCaptionColor=13,
    ColoredButtonMultiline=14,      -- break caption at \n or parse lines
    ColoredButtonGraphicPos=15,     -- 1 = left justified; 2 = right justified 0 = centered
    ColoredButtonShowCaption=16,    -- 0 = don't show; 1 = show
    ColoredButtonFont=17,           -- {facename, pts, attribute, rotation angle} sequence
    ColoredButtonHint=18,
    ColoredButtonParentColor=19,    -- setWindowBackColor of ParentId. Needed when resize button
                                    -- to a smaller size, move to a new x,y or setVisible w32False
    ColoredButtonToggleStatus=20,   -- indicates when Toggle is in idle state or not                                    
    ColoredButtonParentId=21,       -- parent, used when moving/resizing the button to clear away
                                    -- prior button drawing
    ColoredButtonState=22,          -- one of CB_leftDown, CB_leftUp or CB_normal                                   
    ColoredButtonCenterVert=23,     -- when true, the default, center caption vertically otherwise
                                    -- caption sits at top of button and user must use \n to position
    ColoredButtonDownCaptionColor=24,   --color to draw caption when button pushed;default is black
    ColoredButtonDisableGraphic=25,
    ColoredButtonXpmmer=26,         -- the graphic is an xpmmer handle or dib from other graphics without filename
    ColoredButtonNonGrayDisable=27, -- freezes button in non grayed out disabled state                              
    ColoredButtonPushed=28,         -- button is pushed; used in onLostFocus; drawButton
    --added in 0.1.17
    ColoredButtonRotateAngle=29,    -- button text angle
    ColoredButtonEnhancedType=30,   -- specifies Ellipse or RoundedRectangle; when blank is rectangular
                                    -- note when Ellipse the cx, cy determines Circle or Ellipse
    ColoredButtonCornerSize=31      -- Corner Size for RoundedRectangle buttons
    
global constant
    CB_leftDown         = 1,
    CB_leftUp           = 2,
    CB_normal           = 3,
    CB_focused          = 4,
    CB_leftDownNoDots   = 5,
    CB_lostFocusDownNoDots=6
    
integer CB_startIdleColor, CB_adjVertical, 
        haveCB_startIdleColor = 0,
        CGposX = 0,
        usePushed = w32True,
        pushedNoSlide = w32False

atom hMask, hColor  
--------------------------------------------------------------------------------
--function by Andy Drummond
function makeColorLighter(object color, atom factor)
object C

    if factor > 1 then
        return 0
    end if

    C = split_rgb(color)
    C = {255,255,255} - C -- Luminance level becomes pigmentation level
    if factor > 0  then -- IE you are lightening the color      
        C = floor(C * factor) -- Pigmentation level is reduced pro-rata
        C = {255,255,255} - C -- Pigmentation level becomes luminance again
    else -- IE you are darkening the color
        factor = -factor -- Make it positive again
        C = floor(C * factor) -- Luminance level is reduced pro-rata
    end if

    return rgb(C[1],C[2],C[3]) -- Return the atom color value
end function
--------------------------------------------------------------------------------
sequence FontDefaults
procedure GetDefaults()
    object lDefaults

    -- Hardcoded defaults.
    FontDefaults    = { "ms sans serif", 8, 0, Black }

    FontDefaults = setCreateFont("Times New Roman", 10, Normal, 0)
    lDefaults = setCreateFont(FontDefaults[1],FontDefaults[2],FontDefaults[3],FontDefaults[4])
end procedure
--------------------------------------------------------------------------------
--this is a class number vs class alpha name xref
sequence ClassNumberToName
ClassNumberToName= {{PushButton,"PushButton"},{PictureButton,"PictureButton"},
                    {ToggleButton,"ToggleButton"},{TogglePicture,"TogglePicture"},
                    {DefPushButton,"DefPushButton"},{CancelButton,"CancelButton"}}
--------------------------------------------------------------------------------
integer idCW
sequence idList idList={}--user reports he can translate a button multiple times and have problems.
                         --so I will trap each id used and check before continuing the routine.

global procedure translateToColoredButton(integer id, object graphic, object disableGraphic )
--this routine creates the actual emulated colored button
--when graphics are atom/integer, the handle from win32eru has been provided
--when using a graphic handle, use addCBXpmmerGraphic routine and use the dib in the param
sequence coloredbutton, size, pos, title, class, lValues, wValues, hint, font
integer parentId,multi

    --see if id has already been used; we don't want to create a colored button more than once
    for i=1 to length(idList) do
        if id = idList[i] then      
            return              
        end if
    end for
    idList &= id
    
    multi=0
    
    lValues = getControlInfo(id,{CONTROLINFO_type,CONTROLINFO_owner,CONTROLINFO_classinfo,CONTROLINFO_font})

    size=getCtlSize(id)
    pos=getPosition(id)
    title=getText(id)
    parentId=lValues[2]
    font=lValues[4]
    
    --Roland Stowasser
    --wValues will not work with Win95
    --wValues = getWindowInfo(id,{WINDOWINFO_Style})    
    wValues = getStyleFlags(id)
    --end Roland

    for i=1 to length(ClassNumberToName) do
        if lValues[1] = ClassNumberToName[i][1] then
            class = ClassNumberToName[i][2]
            -------------------------------------------------------------------------------------------
            --wValues does not include BS_MULTILINE or #8000 for class PictureButton and TogglePicture
            --so user must provide multilineCBCaption and changeCBClass
            --if the exw is written via IDE these are automatically provided when necessary
            -------------------------------------------------------------------------------------------
            --need to check Style for multiline and flat                
            if and_bits(BS_MULTILINE,wValues[1]) then           
                multi=w32True
            end if          
            if and_bits(#8000,wValues[1]) then
                class="FlatButton"
            end if
            if and_bits(BS_MULTILINE,wValues[1]) and and_bits(#8000,wValues[1]) then                
                class="FlatButton"
                multi=w32True
            end if          
            exit
        end if
    end for
    
    if not haveCB_startIdleColor then
        CB_startIdleColor=makeColorLighter(getSysColor(COLOR_3DFACE),.50)
        haveCB_startIdleColor=w32True
    end if
    
    coloredbutton={0,0,{},0,0,0,0,{},0,1,{},0,0,0,0,1,{},{},getSysColor(COLOR_BTNFACE),{},parentId,3,1,0,{},0,0,0,0,{},0}
    
    --see if parentId has background color
    lValues = getControlInfo(parentId,{CONTROLINFO_bcolor})
--would be nice if parentId is a group control and does not have color to look at its parent
--for color and if not color and is group to backup the chain until find Window1 or a parent
--control with color. This will save user needing to use routine to set the color.
    
    coloredbutton[ColoredButtonParentColor]=lValues[1]

    --assign multiline if was indicated from button's style
    if multi then
        coloredbutton[ColoredButtonMultiline]=w32True
    end if  
    
    idCW = createEx(Window,title,parentId,pos[1],pos[2],size[1],size[2],{WS_CHILD},0)
    
    coloredbutton[ColoredButtonName]=id
    coloredbutton[ColoredButtonCWName]=idCW
    coloredbutton[ColoredButtonClass]=class
    coloredbutton[ColoredButtonWidth]=size[1]
    coloredbutton[ColoredButtonHeight]=size[2]
    coloredbutton[ColoredButtonCaption]=title
    coloredbutton[ColoredButtonColor]=getSysColor(COLOR_BTNFACE)
    coloredbutton[ColoredButtonPressColor]=getSysColor(COLOR_BTNFACE)
    coloredbutton[ColoredButtonGraphic]=graphic
    coloredbutton[ColoredButtonDisableGraphic]=disableGraphic
    coloredbutton[ColoredButtonFont]={font[1],font[2],font[3]}
    if find(coloredbutton[ColoredButtonClass],{"TogglePicture","ToggleButton"}) then
        coloredbutton[ColoredButtonPressColor]=CB_startIdleColor    
    end if
    
    if length(getHint(id)) then
        coloredbutton[ColoredButtonHint]=getHint(id)
    end if
    
    ColoredButtonInformation &= {coloredbutton} 

end procedure
--------------------------------------------------------------------------------
--offered by Don Cole:
global procedure translateToColoredButton2(object id, object graphic, object disableGraphic)
    if integer(id) then
        translateToColoredButton(id,graphic,disableGraphic)
    elsif sequence(id) then
        for x=1 to length(id) do
            translateToColoredButton(id[x],graphic,disableGraphic)  
        end for
    end if
end procedure
--------------------------------------------------------------------------------
procedure convertChildWindowToRegion(integer i, sequence style, integer corner) 
    
    if equal(style,"Ellipse") then
        Region = CreateEllipticRgn(0,0,ColoredButtonInformation[i][ColoredButtonWidth]+1,
                ColoredButtonInformation[i][ColoredButtonHeight]+1)--x,y,width,height
    else
        Region = CreateRoundRectRgn(0,0,ColoredButtonInformation[i][ColoredButtonWidth]+1,
                ColoredButtonInformation[i][ColoredButtonHeight]+1,corner)
    end if
--this doesnt work here or after SetWindowRgn
--args={getDC(ColoredButtonInformation[i][ColoredButtonName]),Region,w32Func(xCreateSolidBrush,{colorValue(Magenta)}),1,1}
--VOID = w32Func(xFrameRgn,args)            
    --Now all that needs to be done is associating the created region with the window
    SetWindowRgn(getHandle(ColoredButtonInformation[i][ColoredButtonCWName]),Region)
    
end procedure
----------------------------------------------------------------------------------
function checkIfValidXPM(object hBitmap,sequence graphic)
integer fh,ch
object res,theBmp
atom hXpm
sequence xpm
                
    if atom(hBitmap) then
        --can't draw it
        --this may be an Andy Drummond style xpm                    
        --try alternate read from IDE_xpmmer
        fh = open(graphic, "r")
        res = ""
        ch = getc(fh)   
        while ch != '{' do
            res &= ch
            ch = getc(fh)        
            if ch = -1 then                                                          
                return 0
            end if
        end while    
        if match("XPM", res) = 0 then              
            return 0
        end if
        res = ""
        while True do
            if ch >= ' ' then
                res &= ch            
            end if  
            ch = getc(fh)           
            if ch = -1 then
                close(fh)
                exit
            end if
        end while    
        res = value(res)
        if res[1] != GET_SUCCESS then                       
            return 0
        end if    
        close(fh)
        xpm = res[2]                    
        --see if get resource now
        theBmp=xpmToEuBmp(xpm)
        if atom(theBmp) then
            --still can't draw			
            return 0                                                                      
         else                           
            -- create to dib
            hXpm = createDIB({theBmp[1],theBmp[2]})
            return hXpm                     
         end if                                        
     else               
         --this is a David Cuny style xpm
         -- create to dib         
         hXpm = createDIB( hBitmap )
         return hXpm
     end if 
end function        
--------------------------------------------------------------------------------
function getGraphicSize(object graphic,integer xpmmergraphic)
integer hit, wbmp, hbmp, graphicType
sequence size
object hBitmap
atom bmp, ico
    
    if sequence( graphic ) then 
        if length(graphic) then --needed if graphic is {}       
            hit=w32False    
            --if bitmap         
            if match(".bmp",lower(graphic)) then
                hBitmap=loadBitmapFromFile(graphic)
                hit=w32True             
            elsif match(".xpm",lower(graphic)) then     
                hBitmap=readXpm(graphic)
                hBitmap=checkIfValidXPM(hBitmap,graphic)
                if hBitmap then
                    hit=w32True 
                end if      
            end if
            
            if hit then
                size=getCtlSize(hBitmap)                
                return {1,floor(size[1]/2),floor(size[2]/2)}    --was size[2]/1??
            else                
                return {1,0,0}
            end if
        else
            return {1,0,0}
        end if
    else        
        -- bitmap handle provided
        if xpmmergraphic then
            size=getCtlSize(graphic)
            return {1,floor(size[1]/2),floor(size[2]/2)}    --was size[2]/1 
        end if
        -- allocate structure memory for bitmap information.
        bmp = w32acquire_mem( 0, SIZEOF_BITMAP )

        -- fill the structure with the bitmap information.
        VOID = w32Func( xGetObject, { graphic, SIZEOF_BITMAP, bmp } )

        -- fetch the info that you want
        wbmp  = w32fetch( bmp, bmWidth )
        hbmp = w32fetch( bmp, bmHeight )
        
        w32release_mem(bmp)
        graphicType=1
    
        if VOID=0 then  
            graphicType=2
              
            --use Rad's method
            --icon handle provided
            ico = w32acquire_mem( 0, SIZEOF_ICONINFO )
            VOID = w32Func( xGetIconInfo, { graphic, ico } )
            hMask  = w32fetch( ico, iconinfo_hbmMask )
            hColor = w32fetch( ico, iconinfo_hbmColor )
            
            w32release_mem( ico )
    
            bmp = w32acquire_mem( 0, SIZEOF_BITMAP )
            -- fill the structure with the bitmap information.
            if hColor then
                VOID = w32Func( xGetObject, { hColor, SIZEOF_BITMAP, bmp } )
            else
                VOID = w32Func( xGetObject, { hMask, SIZEOF_BITMAP, bmp } )
            end if
    
            -- fetch the info that you want
            wbmp = w32fetch( bmp, bmWidth )
            hbmp = w32fetch( bmp, bmHeight )
            
            w32release_mem( bmp )
        end if
        return {graphicType,floor(wbmp/2),floor(hbmp/2)}
    end if

end function
--------------------------------------------------------------------------------
function placeCaption(sequence class, sequence font, integer pAngle, sequence title)
--contributed by Andy Drummond
    integer w, h
    atom rad, sr, cr, x, y, dx, dy, newX, newY
    seq text, size

    rad = pAngle*PI/180     -- Angle in radians
    sr = sin(rad)       -- Sin & Cos of angle
    cr = cos(rad)
    if equal(class,"CancelButton") then 
        setFont(Pixmap1, font[1], font[2], {Italic,0,pAngle*10,pAngle*10,ANSI_CHARSET,0,0,0,0}) 
    else
        setFont(Pixmap1, font[1], font[2], {font[3],0,pAngle*10,pAngle*10,ANSI_CHARSET,0,0,0,0})
    end if
    w = getTextWidth(Pixmap1,title)
    h = getTextHeight(Pixmap1,title)
    w = floor(w/2)      -- width & height of text block to its centre ...
    h = floor(h/2)      -- ... disregarding any rotation

    --Now work out where the text start must be so that the centre comes out
    --where it is wanted! Maybe!

    size=getCtlSize(Pixmap1)    -- Size of "button"
    x = floor(size[1]/2)        -- Where we want the text center to be
    y = floor(size[2]/2)

    dx = h*sr + w*cr    -- Odd calculation to give text
    dy = h*cr - w*sr    -- origin give its size, angle & rquired pos
    newX=floor(x-dx)
    newY=floor(y-dy)
    
    return {newX,newY}
end function
--------------------------------------------------------------------------------
procedure drawCaption (sequence title,integer thicknessX,integer textColor,integer CB_Enabled,
                        integer wantsMultiline,integer showCaption,integer x1,integer y1,
                        integer cx,integer cy,integer titlePos,integer pushed,sequence font,
                        integer centVert, integer textDownColor, object graphic, integer graphicPos,
                        sequence status,sequence class,integer xpmmergraphic, integer pAngle)
sequence textLen,text,textArray,size2, letterLen,captiondxdy
integer x,y,whereIs,cnt,maxcolumns,size, hasAmpCaption
integer w, h
--atom dx, dy
                
    if not showCaption then
        title={}
    end if
    
    if length(title) then                           
        if length(font) then
            setFont(Pixmap1,font[1],font[2],font[3])
            if equal(class,"CancelButton") then
                setFont(Pixmap1,font[1],font[2],Italic) 
            end if
        end if
        
        hasAmpCaption=w32False              
        setTextColor( Pixmap1, getSysColor( COLOR_BTNTEXT ) )
        if textColor != getSysColor( COLOR_BTNTEXT ) then
            setTextColor( Pixmap1, textColor )
        end if
        if pushed then
            setTextColor(Pixmap1,textDownColor) 
        end if
        if equal(status,"upidlecolor") then
            setTextColor(Pixmap1,textDownColor) 
        end if
        if not CB_Enabled then      
            setTextColor( Pixmap1, getSysColor( COLOR_GRAYTEXT  ) ) 
        end if
        
        --check for hotkey button
        if title[1]='&' then
            title=title[2..length(title)]
            hasAmpCaption=w32True   
        end if
                    
        textArray={}        
        size2=getGraphicSize(graphic,xpmmergraphic)--returns graphic type, width/2, height/2        
        if not find(class,{"TogglePicture","PictureButton"}) then
            size2={1,0,0}   
        end if
        
        size=size2[2]--width/2
                        
        if wantsMultiline then
            cnt=w32False
            text=title
                                    
            --find if there are \n in title and build an array of the lines
            while w32True do
                whereIs=match("\n", text)
                if whereIs then
                    cnt=w32True
                    textArray&={text[1..whereIs-1]} 
                    text=text[whereIs+1..length(text)]                          
                else
                    if length(text) then
                        textArray&={text}   
                    end if
                    exit
                end if  
            end while       
                    
            if not cnt then         
                --I must parse looking at length of caption. If there is not a space at max
                --caption length or the next I must backup until I find a space to break the line.
                --Then the "next" line begins at the break to the end of the caption.... until
                --all the caption is broken into lines.     
                text=title
                textLen=getTextExtent( Pixmap1, title )             
                maxcolumns=cx-(2*(thicknessX+2)+(2*size)+thicknessX+2) -- 2*size because I want the full width                              
                textArray={}
                                
                if length(text) then
                    if getTextWidth(Pixmap1,text) < maxcolumns
                    or getTextWidth(Pixmap1,text) = maxcolumns then
                        textArray&={text}                       
                    else                       
                         --chop the title down until it breaks at a space                                               
                        while w32True do
                            cnt=w32False                           
                            for c=length(text) to 1 by -1 do                            
                                if equal(text[c],32) then
                                    cnt=w32True                                 
                                    if getTextWidth(Pixmap1, text[1..c-1]) < maxcolumns
                                    or getTextWidth(Pixmap1, text[1..c-1]) = maxcolumns then                                    
                                        textArray&={text[1..c-1]}
                                        text=text[c+1..length(text)]
                                        exit --the for loop 
                                    end if
                                end if  
                            end for
                            if not cnt
                            or length(text) then
                                textArray&={text}
                                text={}
                                exit    --the while loop
                            end if
                            if not length(text) then                                                        
                                exit --the while loop   
                            end if                          
                        end while
                    end if
                end if              
            end if
            
            textLen=getTextExtent( Pixmap1, title )
            if length(textArray) = 1 then               
                -- center text on x and y axis              
                x = x1 + floor( (cx/2) - (textLen[1]/2) )         
                y = y1 + floor( (cy/2) - (textLen[2]/2) )             
                if not centVert then    --no vertical centering
                    y=y1+thicknessX+2   
                end if
                if titlePos = 1 then
                    --left justify
                    x=x1+2+thicknessX       
                    if graphicPos=1 then                    
                        x+=(2*size)                     
                    end if                          
                elsif titlePos = 2 then
                    --right justify
                    x=x1+cx-(thicknessX+2)-textLen[1]-1                                     
                    if graphicPos=2 then
                        x-=(2*size)
                        x-=1
                    end if
                elsif titlePos = 3 then                 
                    x = x1 + floor( (cx/2) - (textLen[1]/2) )               
                    if graphicPos=1 then
                        --find the leftmost position                        
                        x+=size
                        CGposX=x
                        x+=1 --gap
                    elsif graphicPos=2 then
                        --find the rightmost position
                        x-=size             
                        CGposX=x+textLen[1]             
                        x-=1 --gap
                    end if                  
                end if
                
                if pushed
                and not pushedNoSlide then
                    x+=thicknessX+2
                    y+=1                    
                end if              
                
                if length(font)
                and pAngle then                             
                    captiondxdy=placeCaption(class,font,pAngle,title)
                    x=captiondxdy[1]
                    y=captiondxdy[2]                    
                    if pushed
                    and not pushedNoSlide then
                        x+=thicknessX+2
                        y+=1                    
                    end if
                    setPenPos(Pixmap1,x,y)
                    wPuts(Pixmap1, title)
                else                            
                    setPenPos( Pixmap1,x, y)
                    wPuts( Pixmap1, title )
                end if              
                --if is a hotkey then
                if hasAmpCaption then
                    letterLen=getCharExtent(Pixmap1)
                    setPenColor(Pixmap1,textColor)                  
                    drawLine(Pixmap1,x,y+textLen[2]-2,x+floor(letterLen[1]-1),y+textLen[2]-2)
                end if              
            else--multiple lines 
                while w32True do                    
                    if length(textArray*textLen[2]) < cy-(2*thicknessX+1) then
                        --find first y pos of title                     
                        y = y1 + floor( (cy/2) - (textLen[2]/2))
                        y-=floor((textLen[2]/2)*(length(textArray)/2))                  
                        exit
                    else
                        textArray=textArray[1..length(textArray)-1] 
                    end if
                end while
                
                if not centVert then    --center caption vertically or not
                    y=y1+thicknessX+2
                end if
                
                for i=1 to length(textArray) do
                    textLen=getTextExtent( Pixmap1, textArray[i] )
                    x = x1 + floor( (cx/2) - (textLen[1]/2))                    
                    if titlePos = 1 then
                        x=x1+2+thicknessX   
                        if graphicPos=1 then
                            --left justify                      
                            x=x1+2+thicknessX+(2*size)
                        end if
                    end if      
                    if titlePos = 2 then
                        x=x1+cx-(thicknessX+2)-textLen[1]
                        if graphicPos=2 then
                            --right justify                         
                            x=x1+cx-(thicknessX+2)-textLen[1]-(2*size)-1                            
                        end if
                    end if
                    if titlePos = 3 then
                        x = x1 + floor( (cx/2) - (textLen[1]/2))                        
                        if graphicPos=1 then
                            --move x to right to accommodate graphic
                            x+=size
                            --find the leftmost line position
                            if i=1 then
                                CGposX=x                        
                            elsif x<CGposX then
                                CGposX=x    
                            end if
                        elsif graphicPos=2 then                         
                            --move x to left to accommodate graphic
                            x-=size                 
                            --find the rightmost position
                            if i=1 then                             
                                CGposX=x+textLen[1]                                 
                            elsif x+textLen[1]>CGposX then                      
                                CGposX=x+textLen[1]                                 
                            end if
                        end if                  
                    end if
                    if pushed
                    and not pushedNoSlide then
                        x+=thicknessX+2
                        y+=1
                    end if
                    while y < thicknessX do
                        y+=1
                    end while
                    
                    if length(font)
                    and pAngle then                             
                        captiondxdy=placeCaption(class,font,pAngle,textArray[i])                                                
                        x=captiondxdy[1]                                                                            
                        y=captiondxdy[2]
                        if pushed then
                            x+=thicknessX+2
                            y+=1
                        end if
                        if i>1 then
                            y+=(textLen[2]*(i-1))
                        end if                                                  
                        setPenPos(Pixmap1,x,y)
                        wPuts(Pixmap1,textArray[i])
                    else                        
                        setPenPos( Pixmap1, x, y)
                        wPuts( Pixmap1,textArray[i] )
                    end if                                                    
                    
                    if i=1 then
                        --if is a hotkey then
                        if hasAmpCaption then
                            letterLen=getCharExtent(Pixmap1)
                            setPenColor(Pixmap1,textColor)                              
                            drawLine(Pixmap1,x,y+textLen[2]-2,x+floor(letterLen[1]-1),y+textLen[2]-2)
                        end if  
                    end if
                    
                    y+=textLen[2]
                    if pushed
                    and not pushedNoSlide then
                        y-=1
                    end if
                end for
            end if  
        else--no multiline requested
            --NOTE if there are \n in the caption but user doesn't specify multiline
            --  the textLen will be off by 1 character per \n
            textLen=getTextExtent( Pixmap1, title )
            x = x1 + floor( (cx/2) - (textLen[1]/2) )
            y = y1 + floor( (cy/2) - (textLen[2]/2) )
            if not centVert then
                y=y1+thicknessX+2
            end if  
            if titlePos = 1 then
                --left justify                                                  
                x=x1+2+thicknessX
                if graphicPos=1 then
                    x+=(2*size)
                end if      
            elsif titlePos = 2 then
                --right justify                                             
                x=x1+cx-(thicknessX+2)-textLen[1]-1             
                if graphicPos=2 then
                    x-=(2*size)
                    x-=1                
                end if
            elsif titlePos = 3 then
                x = x1 + floor( (cx/2) - (textLen[1]/2))                
                if graphicPos=1 then
                    --find the leftmost position    
                    x+=size
                    CGposX=x
                elsif graphicPos=2 then                 
                    --find the rightmost position
                    x-=size
                    CGposX=x+textLen[1] 
                end if              
            end if
            if pushed
            and not pushedNoSlide then
                x+=thicknessX+2
                y+=1
            end if
            if length(font)
            and pAngle then     
                captiondxdy=placeCaption(class,font,pAngle,title)
                x=captiondxdy[1]
                y=captiondxdy[2]
                if pushed
                and not pushedNoSlide then              
                    x+=thicknessX+1
                    y+=1        
                end if
                setPenPos(Pixmap1,x,y)
                wPuts(Pixmap1, title)
            else        
                setPenPos( Pixmap1,x,y)               
                wPuts( Pixmap1, title )
            end if
            
            --if is a hotkey then
            if hasAmpCaption then
                letterLen=getCharExtent(Pixmap1)
                setPenColor(Pixmap1,textColor)                  
                drawLine(Pixmap1,x,y+textLen[2]-2,x+floor(letterLen[1]-1),y+textLen[2]-2)
            end if
        end if      
    end if
end procedure
--------------------------------------------------------------------------------
procedure drawButton(integer id, integer x1, integer y1, integer cx,
            integer cy, integer pushed, atom color, atom linecolor)
                             
    --routine to draw emulated button   
    atom x2, y2, x, y, dib, hit
    seq textLen, rect, size2, title, class, text, convertTitle, data, textArray, font,
        hint, status, useEllipse
    integer thicknessX,buttoncenter,bitmapcenter,offsetX,offsetY,titlePos,pressedTimes,
            CB_Enabled,CB_Visible,textColor,maxcolumns,adjmaxcolumns,whereIs,cnt,
            wantsMultiline,graphicPos,showCaption,currentIndex,cb_idleColor,centVert,textDownColor,
            xpmmergraphic,adj,xx,yy,size,bitmapGraphic,useTextColor,pAngle,pCorner
               
    object theBmp,hBitmap,graphic,disableGraphic            

    currentIndex=0
    
    for i=1 to length(ColoredButtonInformation) do
        if ColoredButtonInformation[i][ColoredButtonCWName] = id then
            title=ColoredButtonInformation[i][ColoredButtonCaption]
            titlePos=ColoredButtonInformation[i][ColoredButtonCaptionPos]
            graphic=ColoredButtonInformation[i][ColoredButtonGraphic]           
            title=ColoredButtonInformation[i][ColoredButtonCaption]
            pressedTimes=ColoredButtonInformation[i][ColoredButtonPressedTimes]
            thicknessX=ColoredButtonInformation[i][ColoredButtonThickness]
            class=ColoredButtonInformation[i][ColoredButtonClass]
            textColor=ColoredButtonInformation[i][ColoredButtonCaptionColor]
            wantsMultiline=ColoredButtonInformation[i][ColoredButtonMultiline]
            graphicPos=ColoredButtonInformation[i][ColoredButtonGraphicPos]
            showCaption=ColoredButtonInformation[i][ColoredButtonShowCaption]
            font=ColoredButtonInformation[i][ColoredButtonFont]
            hint=ColoredButtonInformation[i][ColoredButtonHint]
            cb_idleColor=ColoredButtonInformation[i][ColoredButtonPressColor]
            centVert=ColoredButtonInformation[i][ColoredButtonCenterVert]
            textDownColor=ColoredButtonInformation[i][ColoredButtonDownCaptionColor]
            disableGraphic=ColoredButtonInformation[i][ColoredButtonDisableGraphic]
            status=ColoredButtonInformation[i][ColoredButtonToggleStatus]
            xpmmergraphic=ColoredButtonInformation[i][ColoredButtonXpmmer]
            useEllipse=ColoredButtonInformation[i][ColoredButtonEnhancedType]           
            pAngle=ColoredButtonInformation[i][ColoredButtonRotateAngle]
            pCorner=ColoredButtonInformation[i][ColoredButtonCornerSize]
                    
            currentIndex=i
        
            clearWindow(Pixmap1)
            clearWindow(ColoredButtonInformation[i][ColoredButtonCWName])
            
            if isVisible(ColoredButtonInformation[i][ColoredButtonName]) then       
                CB_Visible=w32True
            else            
                CB_Visible=w32False
                return
            end if
            if isEnabled(ColoredButtonInformation[i][ColoredButtonName]) then
                CB_Enabled=w32True
            else
                CB_Enabled=w32False
            end if
            exit
        end if  
    end for
    xx=0 yy=0
    x2=cx-1
    y2=cy-1
    
    --Pixmap needs to be sized to fit each button being drawn
    setCtlSize(Pixmap1, cx, cy)

    setPenMode(Pixmap1, R2_COPYPEN)
    setPenStyle(Pixmap1, Solid)
    setWindowBackColor(Pixmap1, color)
    
    --clear region's rectangle ghost from other buttons
    for j=1 to length(ColoredButtonInformation) do
        --if find(ColoredButtonInformation[j][ColoredButtonEnhancedType],{"Ellipse","RoundedRectangle"}) then                                       
            setPenColor(Pixmap1, color)
            drawRectangle(Pixmap1,w32False,0,0,ColoredButtonInformation[j][ColoredButtonWidth],
                ColoredButtonInformation[j][ColoredButtonHeight])
        --end if    
    end for
       
    -- apply text
    if equal(class,"CancelButton") then
        if not length(font) then
            GetDefaults()
            font={FontDefaults[1],FontDefaults[2],Italic}
        else
            font={font[1],font[2],Italic}
        end if          
    end if
    
    if length(hint) then
        setHint(id,hint)
    end if
    
    if not CB_Enabled then
        if sequence(disableGraphic) then    
            if length(disableGraphic) then
                graphic=disableGraphic
            end if
        else
            graphic=disableGraphic
        end if
    end if
        
    if titlePos=3
    and not find(class,{"TogglePicture","PictureButton"}) then
        titlePos=0  
    end if
    
    if titlePos=3
    and graphicPos=0 then
        titlePos=0
    end if
    
    if find(class, {"ToggleButton","TogglePicture"}) then
        --drawing caption happens later
    else
        drawCaption(title,thicknessX,textColor,CB_Enabled,wantsMultiline,showCaption,x1,y1,cx,cy,
                titlePos,pushed,font,centVert,textDownColor,graphic,graphicPos,{},class,xpmmergraphic,pAngle)               
        if equal(class,"PictureButton") then
            usePushed=pushed    
        end if
    end if
        
    setTransparentColor(color)
    if find(class,{"PushButton","PictureButton", "CancelButton"}) then
        setPenWidth(Pixmap1, 1) 
        if pushed then              
            if equal("Ellipse",useEllipse) then                         
                drawEllipse(Pixmap1,w32False,x1,y1,cx,cy)
--this isn't working				
--args={getDC(id),Region,w32Func(xCreateSolidBrush,{colorValue(Magenta)}),1,1}
--VOID = w32Func(xFrameRegion,args)
--

                --draw inner top
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))                                               
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))           
                --draw top
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))              
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))                           
                                                
                --draw inner bottom
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))             
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                --draw bottom
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))                                            
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))                                           
            else
                --draw bottom
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))        
                drawLine(Pixmap1,x1,y2,cx,y2)
                --draw right side
                drawLine(Pixmap1,x2,y1,x2,cy)
            
                --draw inner shadow bottom and right side
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))     
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y2-t,cx-t,y2-t)
                    drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
                end for
            
                --draw top
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                drawLine(Pixmap1,x1,y1,x2,y1)
                --draw left side
                drawLine(Pixmap1,x1,y1,x1,y2)           
                --draw inner shadow top and left side
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                    drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
                end for
            
                --draw corners
                if thicknessX > 1 then
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    --draw bottom diagonal
                    drawLine(Pixmap1,x2,y2,x2-thicknessX-1,y2-thicknessX-1)
                    --draw top diagonal
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawLine(Pixmap1,x1,y1,x1+thicknessX+1,y1+thicknessX+1)
                end if
                if equal("RoundedRectangle",useEllipse) then
                    --draw top left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))                 
                    --draw bottom left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                    --draw outer shadow
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                    
                    --draw top right corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    --draw right top corner
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    
                    --draw bottom right corner                  
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))            
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                         
                end if
            end if  
        else    --Up        
            if equal("Ellipse",useEllipse) then
                drawEllipse(Pixmap1,w32False,x1,y1,cx,cy)
                --draw inner top            
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))
                --draw top
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))                
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))
                                    
                --draw inner bottom
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                --draw bottom
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))              
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))                                                               
            else    
                --draw bottom
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                drawLine(Pixmap1,x1,y2,cx,y2)
                --draw right side
                drawLine(Pixmap1,x2,y1,x2,cy)
                --draw inner shadow bottom and right side
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y2-t,cx-t,y2-t)
                    drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
                end for
        
                --draw top
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawLine(Pixmap1,x1,y1,x2,y1)
                --draw left side
                drawLine(Pixmap1,x1,y1,x1,y2)
                --draw inner shadow top and left side
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                    drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
                end for
            
                --draw corner
                if thicknessX > 1 then
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    --draw bottom diagonal
                    drawLine(Pixmap1,x2,y2,x2-thicknessX-1,y2-thicknessX-1)
                    --draw top diagonal
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawLine(Pixmap1,x1,y1,x1+thicknessX+1,y1+thicknessX+1)
                end if
                
                if equal("RoundedRectangle",useEllipse) then                                                                                                        
                    --draw top left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))             
                    
                    --draw bottom left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                    --draw outer shadow
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                    
                    --draw top right corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    --draw right top corner
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    
                    --draw bottom right corner                  
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))          
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                         
                end if
            end if
        end if
    elsif equal(class,"DefPushButton") then
        setPenWidth(Pixmap1, 1)
        if pushed then
            if equal("Ellipse",useEllipse) then
                --draw top and bottom shadow
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                drawEllipse(Pixmap1,w32False,x1,y1,cx,cy)
                setPenWidth(Pixmap1,1)  
                setPenColor(Pixmap1,Black)      
                drawEllipse(Pixmap1,w32False,x1,y1,cx,cy)                               
            else
                --draw bottom
                setPenColor(Pixmap1,Black)  
                drawLine(Pixmap1,x1,y2,cx,y2)
                --draw right side
                drawLine(Pixmap1,x2,y1,x2,cy)
                --draw inner shadow bottom and right side
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))       
                for t=1 to thicknessX+1 do
                    drawLine(Pixmap1,x1+t,y2-t,cx-t,y2-t)
                    drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
                end for     
    
                --draw top
                setPenColor(Pixmap1,Black)
                drawLine(Pixmap1, x1,y1,x2,y1)
                --draw left side
                drawLine(Pixmap1, x1,y1,x1,y2)
                --draw inner shadow top and left side
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                for t=1 to thicknessX+1 do
                    drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                    drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
                end for
            
                --draw corners
                if thicknessX > 1 then
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    --draw bottom diagonal right
                    drawLine(Pixmap1,x2-1,y2-1,x2-(thicknessX+1),y2-(thicknessX+1))
                    --draw bottom diagonal left
                    drawLine(Pixmap1,x1+1,y2-1,x1+(thicknessX+1),y2-(thicknessX+1))
                    --draw top diagonal left
                    drawLine(Pixmap1,x1+1,y1+1,x1+thicknessX+1,y1+thicknessX+1)
                    --draw top diagonal right
                    drawLine(Pixmap1,x2-1,y1+1,x2-(thicknessX+1),y1+(thicknessX+1))
                end if
                if equal("RoundedRectangle",useEllipse) then
                    --draw top left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)--getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))                 
                    --draw bottom left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                    --draw outer shadow
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)--getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                    
                    --draw top right corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    --draw right top corner
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)--getSysColor(COLOR_BTNHIGHLIGHT))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    
                    --draw bottom right corner                  
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)--getSysColor(COLOR_BTNHIGHLIGHT))            
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                         
                end if
            end if  
        else --up
            if equal("Ellipse",useEllipse) then
                setPenColor(Pixmap1,Black)                              
                drawEllipse(Pixmap1,w32False,x1,y1,cx,cy)
                --draw bottom inner (shadow
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                --draw bottom shadow
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,Black)--getSysColor(COLOR_3DDKSHADOW))                                  
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                
                --draw top inner shadow
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))
                --draw top shadow
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,Black)--getSysColor(COLOR_BTNHIGHLIGHT))                
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))
            else
                --draw bottom
                setPenColor(Pixmap1,Black)
                drawLine(Pixmap1,x1,y2,cx,y2)
                --draw right side
                drawLine(Pixmap1,x2,y1,x2,cy)
                --draw shadow
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))          
                drawLine(Pixmap1, x1+1,y2-1,cx-1,y2-1)
                drawLine(Pixmap1,x2-1,y1+1,x2-1,y2-1)
                --draw inner shadow bottom and right side
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))           
                for t=2 to thicknessX+1 do
                    drawLine(Pixmap1, x1+t,y2-t,cx-t,y2-t)
                    drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
                end for
        
                --draw top
                setPenColor(Pixmap1,Black)
                drawLine(Pixmap1, x1,y1,x2,y1)
                --draw left side
                drawLine(Pixmap1, x1,y1,x1,y2)
                --draw shadow
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawLine(Pixmap1,x1+1,y1+1,x2-1,y1+1)
                drawLine(Pixmap1,x1+1,y1+1,x1+1,y2-1)
                --draw inner shadow top and left side
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                for t=2 to thicknessX+1 do
                    drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                    drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
                end for
            
                if thicknessX > 1 then
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    --draw bottom diagonal
                    drawLine(Pixmap1,x2-1,y2-1,x2-(thicknessX+1),y2-(thicknessX+1))
                    --draw top diagonal
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawLine(Pixmap1,x1+2,y1+2,x1+thicknessX+2,y1+thicknessX+2)
                end if
                if equal("RoundedRectangle",useEllipse) then                                                                                                        
                    --draw top left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))             
                    
                    --draw bottom left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                    --draw outer shadow
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                    
                    --draw top right corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    --draw right top corner
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    
                    --draw bottom right corner                  
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,Black)          
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                         
                end if
            end if      
        end if

    elsif find(class, {"ToggleButton","TogglePicture"}) then
        setPenWidth(Pixmap1, 1)
        usePushed=pushed
        useTextColor=textDownColor
        if pushed then  
            if pressedTimes=0
            or pressedTimes=1 then          
                status="pushedcolor"                                    
                setWindowBackColor(Pixmap1, color)                  
            else                
                status="pushedidlecolor"                
                setWindowBackColor(Pixmap1, cb_idleColor)                           
            end if                      
            
            drawCaption(title,thicknessX,useTextColor,CB_Enabled,wantsMultiline,showCaption,x1,y1,
                cx,cy,titlePos,usePushed,font,centVert,textDownColor,graphic,graphicPos,status,class,
                xpmmergraphic,pAngle)
                
            if equal(useEllipse,"Ellipse") then             
                --draw inner bottom
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                --draw bottom
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))                
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                
                --draw inner shadow
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))
                --draw top
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))               
            else                        
                --draw bottom
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))        
                drawLine(Pixmap1,x1,y2,cx,y2)
                --draw right side
                drawLine(Pixmap1,x2,y1,x2,cy)
                --draw inner shadow bottom and right side
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))     
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y2-t,cx-t,y2-t)
                    drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
                end for
        
                --draw top
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                drawLine(Pixmap1,x1,y1,x2,y1)
                --draw left side
                drawLine(Pixmap1,x1,y1,x1,y2)
                --draw inner shadow top and left side
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                    drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
                end for
                if thicknessX > 1 then
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    --draw bottom diagonal
                    drawLine(Pixmap1,x2,y2,x2-thicknessX-1,y2-thicknessX-1)
                    --draw top diagonal
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawLine(Pixmap1,x1,y1,x1+thicknessX+1,y1+thicknessX+1)
                end if
                if equal("RoundedRectangle",useEllipse) then                
                    --draw top left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))                 
                    --draw bottom left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                    --draw outer shadow
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                    
                    --draw top right corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    --draw right top corner
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    
                    --draw bottom right corner                  
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))            
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                         
                end if
            end if      
        else            
            ColoredButtonInformation[currentIndex][ColoredButtonPushed] = w32False

            if pressedTimes = 1 then
                status="upidlecolor"                
                setWindowBackColor(Pixmap1, cb_idleColor)
                ColoredButtonInformation[currentIndex][ColoredButtonPushed] = w32True           
            else                
                status="upcolor"
                setWindowBackColor(Pixmap1, color)                                      
            end if
                        
            drawCaption(title,thicknessX,textColor,CB_Enabled,wantsMultiline,showCaption,x1,y1,
                cx,cy,titlePos,pushed,font,centVert,textDownColor,graphic,graphicPos,status,class,
                xpmmergraphic,pAngle)
                
            if equal(useEllipse, "Ellipse") then            
                --draw inner shadow
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                --draw bottom
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))              
                drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                
                --draw top inner shadow
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))
                --draw top
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))                           
            else    
                --draw bottom
                setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                drawLine(Pixmap1,x1,y2,cx,y2)
                --draw right side
                drawLine(Pixmap1,x2,y1,x2,cy)
                --draw inner shadow bottom and right side
                setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y2-t,cx-t,y2-t)
                    drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
                end for
            
                --draw top
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawLine(Pixmap1,x1,y1,x2,y1)
                --draw left side
                drawLine(Pixmap1,x1,y1,x1,y2)
                --draw inner shadow top and left side
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                for t=1 to thicknessX do
                    drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                    drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
                end for
                if thicknessX > 1 then
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    --draw bottom diagonal
                    drawLine(Pixmap1,x2,y2,x2-thicknessX-1,y2-thicknessX-1)
                    --draw top diagonal
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawLine(Pixmap1,x1,y1,x1+thicknessX+1,y1+thicknessX+1)
                end if
                if equal("RoundedRectangle",useEllipse) then                                                                                                        
                    --draw top left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))             
                    
                    --draw bottom left corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                    --draw outer shadow
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                    
                    --draw top right corner
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    --draw right top corner
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                    
                    --draw bottom right corner                  
                    --draw inner shadow
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                    --draw outer border
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))          
                    drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                         
                end if
            end if  
            if equal(status,"upcolor") then
            else                
                if equal(useEllipse,"Ellipse") then                 
                    --draw inner shadow
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                    --draw bottom
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))                
                    drawArc(Pixmap1,w32True,0,0,cx,cy,0,floor(cy*.8),cx,floor(cy*.2))
                    
                    --draw inner shadow
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    setPenWidth(Pixmap1,(thicknessX*2)+1)
                    drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))
                    --draw top
                    setPenWidth(Pixmap1,1)
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawArc(Pixmap1,w32True,0,0,cx,cy,cx,floor(cy*.2),0,floor(cy*.8))                       
                else                    
                    --draw bottom
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                    drawLine(Pixmap1,x1,y2,cx,y2)
                    --draw right side 
                    drawLine(Pixmap1,x2,y1,x2,cy)
                    --draw inner shadow bottom and right side
                    setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                    for t=1 to thicknessX do
                        drawLine(Pixmap1,x1+t,y2-t,cx-t,y2-t)
                        drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
                    end for
                
                    --draw top              
                    setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                    drawLine(Pixmap1,x1,y1,x2,y1)
                    --draw left side
                    drawLine(Pixmap1,x1,y1,x1,y2)
                    --draw inner shadow top and left side
                    setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                    for t=1 to thicknessX do
                        drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                        drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
                    end for
                    if thicknessX > 1 then
                        setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                        --draw bottom diagonal
                        drawLine(Pixmap1,x2,y2,x2-thicknessX-1,y2-thicknessX-1)
                        --draw top diagonal
                        setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                        drawLine(Pixmap1,x1,y1,x1+thicknessX+1,y1+thicknessX+1)
                    end if
                    if equal("RoundedRectangle",useEllipse) then
                        --draw top left corner
                        --draw inner shadow
                        setPenWidth(Pixmap1,(thicknessX*2)+1)
                        setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                        drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                        --draw outer border
                        setPenWidth(Pixmap1,1)
                        setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                        drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))                 
                        
                        --draw bottom left corner
                        --draw inner shadow
                        setPenWidth(Pixmap1,(thicknessX*2)+1)
                        setPenColor(Pixmap1,getSysColor(COLOR_BTNSHADOW))
                        drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                        --draw outer shadow
                        setPenWidth(Pixmap1,1)
                        setPenColor(Pixmap1,getSysColor(COLOR_3DDKSHADOW))
                        drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                        
                        --draw top right corner
                        --draw inner shadow
                        setPenWidth(Pixmap1,(thicknessX*2)+1)
                        setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                        drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                        --draw right top corner
                        setPenWidth(Pixmap1,1)
                        setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                        drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                        
                        --draw bottom right corner                  
                        --draw inner shadow
                        setPenWidth(Pixmap1,(thicknessX*2)+1)
                        setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                        drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                        --draw outer border
                        setPenWidth(Pixmap1,1)
                        setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))            
                        drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                                                                                                         
                    end if
                end if
            end if
            if currentIndex then
                ColoredButtonInformation[currentIndex][ColoredButtonToggleStatus]=status
            end if
        end if
    elsif equal(class,"FlatButton") then
        setPenWidth(Pixmap1,1)
        --a flat pushbutton looks the same pushed and unpushed
        if equal("Ellipse",useEllipse) then
            setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
            setPenWidth(Pixmap1,(thicknessX*2)+1)
            drawEllipse(Pixmap1,w32False,x1,y1,cx,cy)
            setPenWidth(Pixmap1,1)
            setPenColor(Pixmap1,Black)
            drawEllipse(Pixmap1,w32False,x1,y1,cx,cy)           
        else        
            --draw bottom
            setPenColor(Pixmap1,Black)
            drawLine(Pixmap1,x1,y2,cx,y2)
            --draw right side
            drawLine(Pixmap1,x2,y1,x2,cy)
            --draw inner shadow bottom and right side
            setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))        
            for t=1 to thicknessX do
                drawLine(Pixmap1,x1+t,y2-t,cx-t,y2-t)
                drawLine(Pixmap1,x2-t,y1+t,x2-t,y2-t)   
            end for     
    
            --draw top
            setPenColor(Pixmap1, Black)
            drawLine(Pixmap1, x1,y1,x2,y1)
            --draw left side
            drawLine(Pixmap1, x1,y1,x1,cy)
            --draw top shaddow
            setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
            drawLine(Pixmap1,x1+1,y1+1,x2-1,y1+1)
            drawLine(Pixmap1,x1+1,y1+1,x1+1,y2-1)
            for t=1 to thicknessX do
                drawLine(Pixmap1,x1+t,y1+t,x2-t,y1+t)
                drawLine(Pixmap1,x1+t,y1+t,x1+t,y2-t)   
            end for
            
            --draw corners          
            if thicknessX > 1 then
                setPenColor(Pixmap1,getSysColor(COLOR_3DLIGHT))
                --draw bottom diagonal right
                drawLine(Pixmap1,x2-1,y2-1,x2-(thicknessX+1),y2-(thicknessX+1))
                --draw bottom diagonal left
                drawLine(Pixmap1,x1+1,y2-1,x1+(thicknessX+1),y2-(thicknessX+1))
                --draw top diagonal left
                drawLine(Pixmap1,x1+1,y1+1,x1+thicknessX+1,y1+thicknessX+1)
                --draw top diagonal right
                drawLine(Pixmap1,x2-1,y1+1,x2-(thicknessX+1),y1+(thicknessX+1))
            end if
            if equal("RoundedRectangle",useEllipse) then
                --draw top left corner
                --draw inner shadow
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2)) 
                --draw outer border
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,Black)
                drawArc(Pixmap1,w32False,0,0,pCorner,pCorner,floor(pCorner/2),0,0,floor(pCorner/2))             
                    
                --draw bottom left corner
                --draw inner shadow
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy)                                     
                --draw outer shadow
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,Black)
                drawArc(Pixmap1,w32False,0,cy-pCorner,pCorner,cy,0,cy-floor(pCorner/2),floor(pCorner/2),cy) 
                
                --draw top right corner
                --draw inner shadow
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                --draw right top corner
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,Black)
                drawArc(Pixmap1,w32False,cx-pCorner,0,cx,pCorner,cx,floor(pCorner/2),cx-floor(pCorner/2),0) 
                        
                --draw bottom right corner                  
                --draw inner shadow
                setPenWidth(Pixmap1,(thicknessX*2)+1)
                setPenColor(Pixmap1,getSysColor(COLOR_BTNHIGHLIGHT))
                drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2)) 
                --draw outer border
                setPenWidth(Pixmap1,1)
                setPenColor(Pixmap1,Black)          
                drawArc(Pixmap1,w32False,cx-pCorner,cy-pCorner,cx,cy,cx-floor(pCorner/2),cy,cx,cy-floor(pCorner/2))                                                                                                                                     
            end if
        end if
    end if
    
    if linecolor then
        setPenColor( Pixmap1, Black )
        --all are inset by 1 pixel from button border
        --except top left and bottom right corner which are not drawn
        if equal(class, "DefPushButton") then
            if equal("Ellipse",useEllipse) then
                setPenStyle(Pixmap1, Dot)
                setPenWidth(Pixmap1,1)
                drawEllipse(Pixmap1, w32False, x1+3+thicknessX, y1+3+thicknessX, cx-(3+thicknessX), cy-(3+thicknessX))
                --setup for next drawing
                setPenStyle(Pixmap1, Solid)
            elsif equal("RoundedRectangle",useEllipse) then         
                setPenStyle(Pixmap1, Dot)
                setPenWidth(Pixmap1,1)
                --starting from top left corner:
                drawPolygon(Pixmap1,w32False,{floor(pCorner/2),2+thicknessX,
                                            cx-floor(pCorner/2),2+thicknessX,
                                            cx-(3+thicknessX),floor(pCorner/2),
                                            cx-(3+thicknessX),cy-(floor(pCorner/2)),
                                            cx-floor(pCorner/2),cy-(3+thicknessX),
                                            floor(pCorner/2),cy-(3+thicknessX),
                                            2+thicknessX,cy-floor(pCorner/2),
                                            2+thicknessX,floor(pCorner/2)})
                setPenStyle(Pixmap1,Solid)  
            else    
                --top dots
                for i=4+thicknessX to x2-(3+thicknessX) by 2 do
                    setPixel(Pixmap1, i, 3+thicknessX, Black)               
                end for
        
                --bottom
                for i=3+thicknessX to x2-(4+thicknessX) by 2 do
                    setPixel(Pixmap1, i, y2-(3+thicknessX), Black)              
                end for
        
                --left side
                for i=4+thicknessX to y2-(3+thicknessX) by 2 do
                    setPixel(Pixmap1, 3+thicknessX, i, Black)               
                end for
    
                --right side
                for i=5+thicknessX to y2-(4+thicknessX) by 2 do
                    setPixel(Pixmap1, x2-(3+thicknessX), i, Black)              
                end for 
            end if                  
        else
            if equal("Ellipse",useEllipse) then
                setPenStyle(Pixmap1, Dot)
                setPenWidth(Pixmap1,1)              
                drawEllipse(Pixmap1, w32False, x1+2+thicknessX, y1+2+thicknessX, cx-(2+thicknessX), cy-(2+thicknessX))
                --setup for next
                setPenStyle(Pixmap1, Solid)
            elsif equal("RoundedRectangle",useEllipse) then         
                setPenStyle(Pixmap1, Dot)
                setPenWidth(Pixmap1,1)
                --starting from top left corner:
                drawPolygon(Pixmap1,w32False,{floor(pCorner/2),2+thicknessX,
                                            cx-floor(pCorner/2),2+thicknessX,
                                            cx-(3+thicknessX),floor(pCorner/2),
                                            cx-(3+thicknessX),cy-(floor(pCorner/2)),
                                            cx-floor(pCorner/2),cy-(3+thicknessX),
                                            floor(pCorner/2),cy-(3+thicknessX),
                                            2+thicknessX,cy-floor(pCorner/2),
                                            2+thicknessX,floor(pCorner/2)})
                setPenStyle(Pixmap1,Solid)              
            else    
                --top dots
                for i=3+thicknessX to x2-(2+thicknessX) by 2 do
                    setPixel(Pixmap1, i, 2+thicknessX, Black)               
                end for
        
                --bottom
                for i=2+thicknessX to x2-(3+thicknessX) by 2 do
                    setPixel(Pixmap1, i, y2-(2+thicknessX), Black)              
                end for
        
                --left side
                for i=3+thicknessX to y2-(2+thicknessX) by 2 do
                    setPixel(Pixmap1, 2+thicknessX, i, Black)               
                end for
        
                --right side
                for i=4+thicknessX to y2-(3+thicknessX) by 2 do
                    setPixel(Pixmap1, x2-(2+thicknessX), i, Black)              
                end for
            end if
        end if
    end if
    
    --draw graphic onto pixmap          
    if equal(status,"upidlecolor") then             
        setTransparentColor(cb_idleColor)               
    end if
        
    if sequence( graphic )
    and length(graphic) then--needed if grahic is {}    
        --get graphic from a filename
        if find(class, {"TogglePicture","PictureButton"}) then  
            --if bitmap, xpm
            hit=w32False
            if match(".bmp",lower(graphic)) then            
                hBitmap=loadBitmapFromFile(graphic)
                hit=w32True
            elsif match(".xpm",lower(graphic)) then         
                hBitmap=readXpm(graphic)
                hBitmap=checkIfValidXPM(hBitmap,graphic)
                if hBitmap then
                    hit=w32True 
                end if              
            end if
            if hit then
                size2=getCtlSize(hBitmap)           
                ---what is width and center of button?
                buttoncenter=floor(cx/2)
                --what is width and center of bitmap?
                bitmapcenter=floor(size2[1]/2)
                --what is offset of bitmap respective to button?
                offsetX=buttoncenter-bitmapcenter
                --do same thing for height
                buttoncenter=floor(cy/2)
                --what is width and center of bitmap?
                bitmapcenter=floor(size2[2]/2)
                offsetY=buttoncenter-bitmapcenter

                if pushedNoSlide then   --when button has toggled and then checked or lost focus
                    usePushed=w32False
                end if
            
                if titlePos = 3 then
                    adj=size2[1]
                    if graphicPos = 1 then
                        if usePushed then
                            xx=CGposX-adj+thicknessX+1
                            xx-=1   
                            drawBitmap( Pixmap1, hBitmap, xx, y1+offsetY+1) 
                        else                    
                            xx=CGposX-adj
                            xx-=1   
                            drawBitmap( Pixmap1, hBitmap, xx, y1+offsetY )
                        end if
                    elsif graphicPos=2 then             
                        if usePushed then
                            xx=CGposX+thicknessX+2
                            xx+=1   
                            drawBitmap( Pixmap1, hBitmap, xx, y1+offsetY )
                        else
                            xx=CGposX
                            xx+=1
                            drawBitmap( Pixmap1, hBitmap, xx, y1+offsetY )
                        end if  
                    end if
                elsif graphicPos = 2 then
                    if usePushed then                       
                            bitBlt( Pixmap1, 
                                    x2-(size2[1]), y1+offsetY+2,    
                                    hBitmap,       
                                    0, 0,        
                                    size2[1]-(thicknessX+1), size2[2],    
                                    SRCCOPY )                                                                                       
                    else
                        drawBitmap( Pixmap1, hBitmap, x2-(size2[1]+thicknessX+1), y1+offsetY )                      
                    end if      
                else
                    if graphicPos = 1 then
                        if usePushed then
                            drawBitmap( Pixmap1, hBitmap, x1+2+thicknessX+thicknessX+2, y1+offsetY+2 )  
                        else                    
                            drawBitmap( Pixmap1, hBitmap, x1+2+thicknessX, y1+offsetY )
                        end if
                    elsif graphicPos = 2 then
                        if usePushed then
                            bitBlt( Pixmap1, 
                                    x2-(size2[1]), y1+offsetY+2,    
                                    hBitmap,       
                                    0, 0,        
                                    size2[1]-(thicknessX+1), size2[2],    
                                    SRCCOPY )                                                   
                        else
                            drawBitmap( Pixmap1, hBitmap, x2-(size2[1]+thicknessX+1+thicknessX), y1+offsetY )
                        end if  
                    else                            
                        if usePushed then
                            drawBitmap( Pixmap1, hBitmap, x1+offsetX+thicknessX+1, y1+offsetY+1 )   
                        else
                            drawBitmap( Pixmap1, hBitmap, x1+offsetX, y1+offsetY )
                        end if
                    end if
                end if
            end if      
        end if
    
    elsif not sequence(graphic) then    
        --graphic may be from output of win32eru by Bernie Ryan 
        size2=getGraphicSize(graphic,xpmmergraphic)--returns graphic type, width/2, height/2
        if size2[1]=2 then  --icon          
            if hColor then
                setPixmap(Pixmap2,hColor)
            else
                setPixmap(Pixmap2,hMask)                
            end if          
        end if
        --need to use full size of graphic
        size2[2]+=size2[2]
        size2[3]+=size2[3]
        
        ---what is width and center of button?
        buttoncenter=floor(cx/2)
        --what is width and center of bitmap?
        bitmapcenter=floor(size2[2]/2)--width
        --what is offset of bitmap respective to button?
        offsetX=buttoncenter-bitmapcenter
        --do same thing for height
        buttoncenter=floor(cy/2)
        --what is height and center of bitmap?
        bitmapcenter=floor(size2[3]/2)--height
        offsetY=buttoncenter-bitmapcenter
        yy=y1+offsetY+1
        
        if pushedNoSlide then   --when button has toggled and then checked or lost focus
            usePushed=w32False
        end if
            
        if titlePos = 3 then
            adj=size2[2]            
            if graphicPos = 1 then
                if usePushed then
                    xx=CGposX-adj+thicknessX+2
                    xx-=1
                    yy=y1+offsetY+1                                 
                else                    
                    xx=CGposX-adj
                    xx-=1
                    yy=y1+offsetY           
                end if
            elsif graphicPos=2 then
                if usePushed then
                    xx=CGposX+thicknessX+2
                    xx+=1
                    yy=y1+offsetY+1                         
                else
                    xx=CGposX
                    xx+=1
                    yy=y1+offsetY
                end if      
            end if          
        elsif titlePos = 2 then         
            if graphicPos = 1 then
                if usePushed then
                    xx=x1+2+thicknessX+thicknessX+2
                    yy=y1+offsetY+2 
                else                    
                    xx=x1+2+thicknessX
                    yy=y1+offsetY 
                end if
            elsif graphicPos = 2 then
                if usePushed then               
                    xx=x2-(size2[2])
                    yy=y1+offsetY+2 
                else
                    xx=x2-(size2[2]+thicknessX+1)
                    yy=y1+offsetY 
                end if  
            else                            
                if usePushed then
                    xx=x1+offsetX+thicknessX+1
                    yy=y1+offsetY+1
                else
                    xx=x1+offsetX
                    yy=y1+offsetY
                end if
            end if      
        else            
            if graphicPos = 1 then
                if usePushed then
                    xx=x1+2+thicknessX+thicknessX+2
                    yy=y1+offsetY+2 
                else                    
                    xx=x1+2+thicknessX
                    yy=y1+offsetY 
                end if
            elsif graphicPos = 2 then
                if usePushed then
                    xx=x2-(size2[2])
                    yy=y1+offsetY+2 
                else
                    xx=x2-(size2[2]+thicknessX+1)
                    yy=y1+offsetY 
                end if  
            else                            
                if usePushed then
                    xx=x1+offsetX+thicknessX+1
                    yy=y1+offsetY+1
                else
                    xx=x1+offsetX
                    yy=y1+offsetY
                end if
            end if      
        end if
        
        bitmapGraphic=w32False
        if find(class, {"TogglePicture","PictureButton"})
        and size2[1]=1 then --bmp
            if titlePos != 3
            and graphicPos=2
            and usePushed then          
                bitBlt( Pixmap1, 
                    xx,yy,    
                    graphic,       
                    0, 0,        
                    size2[2]-(thicknessX+1), size2[3],    
                    SRCCOPY )                                           
            else    
                drawBitmap( Pixmap1, graphic, xx, yy )
            end if
            bitmapGraphic=w32True                           
        end if                   
    end if                             
    
    --now blt to id 
    copyBlt(id,0,0,Pixmap1)
    
    if not sequence(graphic)
    and not xpmmergraphic then
        if not bitmapGraphic then
            --copy graphic from win32eru                
            if find(class, {"TogglePicture","PictureButton"}) then

                if pushedNoSlide then   --when button has toggled and then checked or lost focus
                    usePushed=w32False
                end if
            
                if graphicPos=2
                and usePushed then
                    if titlePos != 3 then
                        setCtlSize(Pixmap2, cx-(xx+thicknessX+1),size2[3])
                    end if
                end if      
                copyBlt(id,xx,yy,Pixmap2)
            end if
        end if
    end if              
    
    --reset fonts in case next button doesn't use one
    GetDefaults()
    setFont(Pixmap1,FontDefaults[1],FontDefaults[2],FontDefaults[3])

end procedure
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--THE FOLLOWING ARE USER ROUTINES; IN ALL CASES I'VE ALLOWED FOR MULTIPLE id EVEN
--THOUGH IN SOME CASES IT IS NOT APPROPRIATE
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
global procedure addCBGraphic( integer id, integer which, object graphic)
    for i=1 to length(ColoredButtonInformation) do
        if id = ColoredButtonInformation[i][ColoredButtonName] then
            if which=1 then                         
                ColoredButtonInformation[i][ColoredButtonGraphic]=graphic           
            else
                ColoredButtonInformation[i][ColoredButtonDisableGraphic]=graphic            
            end if
            ColoredButtonInformation[i][ColoredButtonXpmmer]=w32False
            exit
        end if
    end for 
end procedure
--------------------------------------------------------------------------------
global procedure addCBXpmmerGraphic( integer id, integer which, object graphic)
    --graphic is a dib
    for i=1 to length(ColoredButtonInformation) do
        if id = ColoredButtonInformation[i][ColoredButtonName] then
            if which=1 then                         
                ColoredButtonInformation[i][ColoredButtonGraphic]=graphic
            else
                ColoredButtonInformation[i][ColoredButtonDisableGraphic]=graphic
            end if
            ColoredButtonInformation[i][ColoredButtonXpmmer]=w32True
            exit
        end if
    end for 
end procedure
--------------------------------------------------------------------------------
global procedure changeAllCBColor(integer which, integer color)
    for i=1 to length(ColoredButtonInformation) do              
        if which = 1 then
            ColoredButtonInformation[i][ColoredButtonColor] = color     
        else
            ColoredButtonInformation[i][ColoredButtonPressColor] = color                    
        end if
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
    end for
end procedure
--------------------------------------------------------------------------------
global procedure changeCBColor(object ids, integer which, integer color)
    if integer(ids) then    
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then                                    
                if which = 1 then
                    ColoredButtonInformation[i][ColoredButtonColor] = color                     
                else
                    ColoredButtonInformation[i][ColoredButtonPressColor] = color                    
                end if
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit    
            end if
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do
                for i=1 to length(ColoredButtonInformation) do
                    if ids[j] = ColoredButtonInformation[i][ColoredButtonName] then                                             
                        if which = 1 then
                            ColoredButtonInformation[i][ColoredButtonColor] = color                         
                        else
                            ColoredButtonInformation[i][ColoredButtonPressColor] = color                            
                        end if
                        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                        exit    
                    end if
                end for 
            end for
        else
            --make emulated button look normal with new color           
            for i=1 to length(ColoredButtonInformation) do              
                if which = 1 then
                    ColoredButtonInformation[i][ColoredButtonColor] = color     
                else
                    ColoredButtonInformation[i][ColoredButtonPressColor] = color                    
                end if
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
            end for
        end if      
    end if  
end procedure
--------------------------------------------------------------------------------
global procedure centerAllVerticallyCBText(integer how)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonCenterVert]=how
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                       
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure centerVerticallyCBText(object ids, integer how)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                ColoredButtonInformation[i][ColoredButtonCenterVert] = how
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                       
                exit    
            end if
        end for
    elsif sequence(ids) then        
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then                             
                        ColoredButtonInformation[j][ColoredButtonCenterVert]=how
                        VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})   
                        exit                        
                    end if
                end for     
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonCenterVert]=how
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                               
            end for 
        end if      
    end if  
end procedure
--------------------------------------------------------------------------------
global procedure changeAllCBTextColor(integer which, integer color)
    for i=1 to length(ColoredButtonInformation) do
        if which=1 then
            ColoredButtonInformation[i][ColoredButtonCaptionColor]=color
        else
            ColoredButtonInformation[i][ColoredButtonDownCaptionColor]=color    
        end if                  
        
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                       
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure changeCBTextColor(object ids, integer which, integer color)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                --make emulated button look normal with new color
                if which=1 then
                    ColoredButtonInformation[i][ColoredButtonCaptionColor] = color
                else
                    ColoredButtonInformation[i][ColoredButtonDownCaptionColor] = color  
                end if
                
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                       
                exit    
            end if
        end for
    elsif sequence(ids) then        
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then
                        if which=1 then
                            ColoredButtonInformation[j][ColoredButtonCaptionColor]=color
                        else
                            ColoredButtonInformation[j][ColoredButtonDownCaptionColor]=color
                        end if          
                        
                        VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})   
                        exit                        
                    end if
                end for     
            end for
        else
            for i=1 to length(ColoredButtonInformation) do
                if which=1 then
                    ColoredButtonInformation[i][ColoredButtonCaptionColor]=color
                else
                    ColoredButtonInformation[i][ColoredButtonDownCaptionColor]=color
                end if          
                
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                               
            end for 
        end if      
    end if
end procedure
--------------------------------------------------------------------------------
global procedure changeAllBorderThickness(integer thicknessX)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonThickness]=thicknessX
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
    end for 
end procedure
--------------------------------------------------------------------------------
global procedure changeBorderThickness(object ids,integer thicknessX)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                ColoredButtonInformation[i][ColoredButtonThickness]=thicknessX
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit
            end if  
        end for
    elsif sequence(ids) then        
        if length(ids) then
                for i=1 to length(ids) do
                    for j=1 to length(ColoredButtonInformation) do
                        if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then     
                            ColoredButtonInformation[j][ColoredButtonThickness]=thicknessX
                            VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})
                            exit                        
                        end if
                    end for     
                end for
        else
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonThickness]=thicknessX
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
            end for         
        end if
    end if  
end procedure
--------------------------------------------------------------------------------
global procedure moveAllCBCaption(integer whereIs)
    for i=1 to length(ColoredButtonInformation) do              
        ColoredButtonInformation[i][ColoredButtonCaptionPos]=whereIs
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                       
    end for         
end procedure
--------------------------------------------------------------------------------
global procedure moveCBCaption(object ids, integer whereIs)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                ColoredButtonInformation[i][ColoredButtonCaptionPos]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit
            end if  
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do
                for i=1 to length(ColoredButtonInformation) do
                    if ids[j] = ColoredButtonInformation[i][ColoredButtonName] then 
                        ColoredButtonInformation[i][ColoredButtonCaptionPos]=whereIs
                        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                        exit
                    end if  
                end for 
            end for
        else
            for i=1 to length(ColoredButtonInformation) do              
                ColoredButtonInformation[i][ColoredButtonCaptionPos]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                       
            end for     
        end if
    end if  
end procedure
--------------------------------------------------------------------------------
global procedure changeAllCBCaption(sequence newCaption)
sequence cleanedText
integer at

    cleanedText={}
    while w32True do
        at = match("\\n", newCaption)   
        if at then
            cleanedText&=newCaption[1..at-1] & 10 
            newCaption=newCaption[at+2..length(newCaption)] 
        else
            exit    
        end if
    end while
    if length(newCaption) then
        cleanedText&=newCaption 
    end if
    
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonCaption]=cleanedText
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure changeCBCaption(object ids, sequence newCaption)
sequence cleanedText
integer at

    cleanedText={}
    while w32True do
        at = match("\\n", newCaption)   
        if at then
            cleanedText&=newCaption[1..at-1] & 10 
            newCaption=newCaption[at+2..length(newCaption)] 
        else
            exit    
        end if
    end while
    if length(newCaption) then
        cleanedText&=newCaption 
    end if  
    
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                ColoredButtonInformation[i][ColoredButtonCaption]=cleanedText
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit
            end if  
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do
                for i=1 to length(ColoredButtonInformation) do
                    if ids[j] = ColoredButtonInformation[i][ColoredButtonName] then 
                        ColoredButtonInformation[i][ColoredButtonCaption]=cleanedText
                        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                        exit
                    end if  
                end for 
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonCaption]=cleanedText
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
            end for 
        end if
    end if
end procedure
--------------------------------------------------------------------------------
global procedure showAllCBCaption(integer whereIs)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonShowCaption]=whereIs
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure showCBCaption(object ids, integer whereIs)
    if integer(ids) then    
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                ColoredButtonInformation[i][ColoredButtonShowCaption]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit
            end if
        end for
    elsif sequence(ids) then        
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then     
                        ColoredButtonInformation[j][ColoredButtonShowCaption]=whereIs
                        VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})
                        exit                        
                    end if
                end for     
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonShowCaption]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
            end for 
        end if      
    end if      
end procedure
--------------------------------------------------------------------------------
global procedure multilineAllCBCaption(integer whereIs)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonMultiline]=whereIs
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})       
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure multilineCBCaption(object ids, integer whereIs)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                ColoredButtonInformation[i][ColoredButtonMultiline]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit
            end if  
        end for
    elsif sequence(ids) then        
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then     
                        ColoredButtonInformation[j][ColoredButtonMultiline]=whereIs
                        VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})
                        exit                        
                    end if
                end for     
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonMultiline]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
            end for 
        end if
    end if  
end procedure
--------------------------------------------------------------------------------
global procedure moveAllCBGraphic(integer whereIs)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonGraphicPos]=whereIs
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                       
    end for
end procedure
--------------------------------------------------------------------------------
global procedure moveCBGraphic(object ids, integer whereIs)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then    
                ColoredButtonInformation[i][ColoredButtonGraphicPos]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit
            end if  
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do
                for i=1 to length(ColoredButtonInformation) do
                    if ids[j] = ColoredButtonInformation[i][ColoredButtonName] then 
                        ColoredButtonInformation[i][ColoredButtonGraphicPos]=whereIs
                        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                        exit
                    end if  
                end for 
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonGraphicPos]=whereIs
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                       
            end for 
        end if
    end if
end procedure
--------------------------------------------------------------------------------
global procedure setAllCBHint(sequence hint)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonHint]=hint                     
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure setCBHint(object ids, sequence hint)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then        
                ColoredButtonInformation[i][ColoredButtonHint]=hint
                exit                        
            end if
        end for         
    elsif sequence(ids) then
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then     
                        ColoredButtonInformation[j][ColoredButtonHint]=hint
                        exit                        
                    end if
                end for             
            end for 
        else            
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonHint]=hint                     
            end for         
        end if  
    end if  
end procedure   
--------------------------------------------------------------------------------
global procedure setAllCBFont(sequence facename, integer pts, integer attribute)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonFont]={facename, pts, attribute}
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})               
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure setCBFont(object ids, sequence facename, integer pts, integer attribute)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then        
                ColoredButtonInformation[i][ColoredButtonFont]={facename, pts, attribute}
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})   
                exit                        
            end if
        end for         
    elsif sequence(ids) then
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then     
                        ColoredButtonInformation[j][ColoredButtonFont]={facename, pts, attribute}
                        VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})   
                        exit                        
                    end if
                end for             
            end for 
        else            
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonFont]={facename, pts, attribute}
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})       
            end for         
        end if  
    end if  
end procedure
----------------------------------------------------------------------------------
global procedure setAllCBFontAngle(integer pAngle)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonRotateAngle]=pAngle
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})               
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure setCBFontAngle(object ids, integer pAngle)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then        
                ColoredButtonInformation[i][ColoredButtonRotateAngle]=pAngle
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})   
                exit                        
            end if
        end for         
    elsif sequence(ids) then
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then     
                        ColoredButtonInformation[j][ColoredButtonRotateAngle]=pAngle
                        VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})   
                        exit                        
                    end if
                end for             
            end for 
        else            
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonRotateAngle]=pAngle
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})       
            end for         
        end if  
    end if  
end procedure
--------------------------------------------------------------------------------
global procedure setAllCBDefaultCBFont()
    GetDefaults()
    for i=1 to length(ColoredButtonInformation) do
        if equal(ColoredButtonInformation[i][ColoredButtonClass],"CancelButton") then
            ColoredButtonInformation[i][ColoredButtonFont]={}   
        else                    
            ColoredButtonInformation[i][ColoredButtonFont]={}                       
        end if
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure setCBDefaultFont(object ids)
    GetDefaults()
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then
                if equal(ColoredButtonInformation[i][ColoredButtonClass],"CancelButton") then
                    ColoredButtonInformation[i][ColoredButtonFont]={}   
                else        
                    ColoredButtonInformation[i][ColoredButtonFont]={}
                end if
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit                        
            end if
        end for         
    elsif sequence(ids) then
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ids[i] = ColoredButtonInformation[j][ColoredButtonName] then
                        if equal(ColoredButtonInformation[j][ColoredButtonClass],"CancelButton") then
                            ColoredButtonInformation[j][ColoredButtonFont]={}
                        else
                            ColoredButtonInformation[j][ColoredButtonFont]={}
                        end if
                        VOID=invokeHandler(ColoredButtonInformation[j][ColoredButtonCWName],w32HPaint,{})
                        exit                        
                    end if
                end for             
            end for 
        else            
            for i=1 to length(ColoredButtonInformation) do
                if equal(ColoredButtonInformation[i][ColoredButtonClass],"CancelButton") then
                    ColoredButtonInformation[i][ColoredButtonFont]={}   
                else            
                    ColoredButtonInformation[i][ColoredButtonFont]={}                       
                end if
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
            end for         
        end if  
    end if  
end procedure
--------------------------------------------------------------------------------
global procedure changeAllCBClass(sequence newclass)
    for i=1 to length(ColoredButtonInformation) do                      
        ColoredButtonInformation[i][ColoredButtonClass] = newclass
        --when changing class always reset the pressed times switch
        ColoredButtonInformation[i][ColoredButtonPressedTimes]=0
        --when changing need to change the pressed color
        if find(newclass,{"TogglePicture","ToggleButton"}) then
            if ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE) then
                ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor    
            end if
        else
            if ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor then
                ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE)   
            end if  
        end if
        if equal(newclass,"CancelButton") then
            if length(ColoredButtonInformation[i][ColoredButtonFont]) then
                setCBFont({},ColoredButtonInformation[i][ColoredButtonFont][1],
                    ColoredButtonInformation[i][ColoredButtonFont][2],
                    ColoredButtonInformation[i][ColoredButtonFont][3])
            else
                setCBFont({},ColoredButtonInformation[i][ColoredButtonFont][1],
                    ColoredButtonInformation[i][ColoredButtonFont][2],Italic)
            end if                  
        end if
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure changeCBClass(object ids, sequence newclass)
    if integer(ids) then    
        for i=1 to length(ColoredButtonInformation) do
            if ids = ColoredButtonInformation[i][ColoredButtonName] then        
                ColoredButtonInformation[i][ColoredButtonClass] = newclass      
                --when changing class always reset the pressed times switch
                ColoredButtonInformation[i][ColoredButtonPressedTimes]=0
                --when changing need to change the pressed color
                if find(newclass,{"TogglePicture","ToggleButton"}) then         
                    if ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE) then
                        ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor                        
                    end if
                else
                    if ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor then
                        ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE)   
                    end if  
                end if
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                exit
            end if  
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do                           
                for i=1 to length(ColoredButtonInformation) do
                    if ids[j] = ColoredButtonInformation[i][ColoredButtonName] then     
                        ColoredButtonInformation[i][ColoredButtonClass] = newclass
                        --when changing class always reset the pressed times switch
                        ColoredButtonInformation[i][ColoredButtonPressedTimes]=0
                        --when changing need to change the pressed color
                        if find(newclass,{"TogglePicture","ToggleButton"}) then
                            if ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE) then
                                ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor    
                            end if
                        else
                            if ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor then
                                ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE)   
                            end if  
                        end if
                        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})
                        exit
                    end if  
                end for
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                      
                ColoredButtonInformation[i][ColoredButtonClass] = newclass
                --when changing class always reset the pressed times switch
                ColoredButtonInformation[i][ColoredButtonPressedTimes]=0
                --when changing need to change the pressed color
                if find(newclass,{"TogglePicture","ToggleButton"}) then
                    if ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE) then
                        ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor    
                    end if
                else
                    if ColoredButtonInformation[i][ColoredButtonPressColor] = CB_startIdleColor then
                        ColoredButtonInformation[i][ColoredButtonPressColor] = getSysColor(COLOR_BTNFACE)
                    end if  
                end if
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                   
            end for                             
        end if
    end if
end procedure
--------------------------------------------------------------------------------
global procedure assignAllParentBackColor(integer color)
    for i=1 to length(ColoredButtonInformation) do                  
        ColoredButtonInformation[i][ColoredButtonParentColor]=color             
    end for     
end procedure
--------------------------------------------------------------------------------
global procedure assignParentBackColor(object ids, integer color)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ColoredButtonInformation[i][ColoredButtonName]=ids then
                ColoredButtonInformation[i][ColoredButtonParentColor]=color
                exit
            end if
        end for
    elsif sequence(ids) then
        if length(ids) then
            for i=1 to length(ids) do
                for j=1 to length(ColoredButtonInformation) do
                    if ColoredButtonInformation[j][ColoredButtonName]=ids[i] then
                        ColoredButtonInformation[j][ColoredButtonParentColor]=color
                        exit
                    end if
                end for 
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                  
                ColoredButtonInformation[i][ColoredButtonParentColor]=color             
            end for 
        end if
    end if
end procedure
--------------------------------------------------------------------------------
global procedure setNonGrayDisable(object ids, integer state)
    if integer(ids) then    
        for i=1 to length(ColoredButtonInformation) do
            if ColoredButtonInformation[i][ColoredButtonName] = ids then        
                ColoredButtonInformation[i][ColoredButtonNonGrayDisable]=state              
            end if
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do
                for i=1 to length(ColoredButtonInformation) do
                    if ColoredButtonInformation[i][ColoredButtonName] = ids[j] then                     
                        ColoredButtonInformation[i][ColoredButtonNonGrayDisable]=state                          
                        exit
                    end if
                end for 
            end for
        else
            for i=1 to length(ColoredButtonInformation) do
                ColoredButtonInformation[i][ColoredButtonNonGrayDisable]=state                                                          
            end for 
        end if
    end if
end procedure
--------------------------------------------------------------------------------
global procedure setCBFocus(integer ids)        
    for i=1 to length(ColoredButtonInformation) do
        if ColoredButtonInformation[i][ColoredButtonName] = ids then        
            ColoredButtonInformation[i][ColoredButtonState]=CB_focused
            setFocus(ColoredButtonInformation[i][ColoredButtonName])
            VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})   
        end if
    end for 
end procedure
--------------------------------------------------------------------------------
global procedure forceCBPaint(object ids)
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ColoredButtonInformation[i][ColoredButtonName] = ids then            
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})   
                exit
            end if
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do
                for i=1 to length(ColoredButtonInformation) do
                    if ColoredButtonInformation[i][ColoredButtonName] = ids[j] then
                        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})   
                        exit
                    end if
                end for 
            end for
        else
            for i=1 to length(ColoredButtonInformation) do                  
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                           
            end for 
        end if
    end if
end procedure
--------------------------------------------------------------------------------
global procedure changeAllCBButtonType(sequence style,integer corner)
    if equal(style,"RoundedRectangle")
    and corner<10 then
        corner=10   
    end if

    for i=1 to length(ColoredButtonInformation) do  
        if equal(style,"Ellipse") then
            ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
            ColoredButtonInformation[i][ColoredButtonCornerSize]=0
            convertChildWindowToRegion(i, style, 0)
        elsif equal(style,"RoundedRectangle") then
            ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
            ColoredButtonInformation[i][ColoredButtonCornerSize]=corner         
            convertChildWindowToRegion(i, style, corner)                        
        else
            ColoredButtonInformation[i][ColoredButtonEnhancedType] = {}
            ColoredButtonInformation[i][ColoredButtonCornerSize]=0  
        end if          
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})       
    end for
end procedure
--------------------------------------------------------------------------------
global procedure changeCBButtonType(object ids, sequence style, integer corner)
    if equal(style,"RoundedRectangle")
    and corner<10 then
        corner=10   
    end if
    
    if integer(ids) then
        for i=1 to length(ColoredButtonInformation) do
            if ColoredButtonInformation[i][ColoredButtonName] = ids then                
                if equal(style,"Ellipse") then
                    ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
                    ColoredButtonInformation[i][ColoredButtonCornerSize]=0
                    convertChildWindowToRegion(i, style, 0)
                elsif equal(style,"RoundedRectangle") then              
                    ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
                    ColoredButtonInformation[i][ColoredButtonCornerSize]=corner
                    convertChildWindowToRegion(i, style, corner)
                else
                    ColoredButtonInformation[i][ColoredButtonEnhancedType] = {}
                    ColoredButtonInformation[i][ColoredButtonCornerSize]=0
                end if
                
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})   
                exit
            end if
        end for
    elsif sequence(ids) then
        if length(ids) then
            for j=1 to length(ids) do
                for i=1 to length(ColoredButtonInformation) do
                    if ColoredButtonInformation[i][ColoredButtonName] = ids[j] then
                        if equal(style,"Ellipse") then
                            ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
                            ColoredButtonInformation[i][ColoredButtonCornerSize]=0
                            convertChildWindowToRegion(i, style, 0)
                        elsif equal(style,"RoundedRectangle") then                      
                            ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
                            ColoredButtonInformation[i][ColoredButtonCornerSize]=corner
                            convertChildWindowToRegion(i, style, corner)    
                        else
                            ColoredButtonInformation[i][ColoredButtonEnhancedType] = {}
                            ColoredButtonInformation[i][ColoredButtonCornerSize]=0
                        end if              
                        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})   
                    end if
                end for 
            end for
        else
            for i=1 to length(ColoredButtonInformation) do
                if equal(style,"Ellipse") then
                    ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
                    ColoredButtonInformation[i][ColoredButtonCornerSize]=0
                    convertChildWindowToRegion(i, style, 0)
                elsif equal(style,"RoundedRectangle") then
                    ColoredButtonInformation[i][ColoredButtonEnhancedType] = style
                    ColoredButtonInformation[i][ColoredButtonCornerSize]=corner
                    convertChildWindowToRegion(i, style, corner)    
                else
                    ColoredButtonInformation[i][ColoredButtonEnhancedType] = {}
                    ColoredButtonInformation[i][ColoredButtonCornerSize]=0
                end if              
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                           
            end for 
        end if
    end if
end procedure
--------------------------------------------------------------------------------
--the following are internal routines to manage colored buttons except for the last which is
--used in the setup process
--------------------------------------------------------------------------------
procedure self_onMouse (integer self, integer event, sequence params)--params is ( int event, int x, int y, int shift, int wheelmove )
    --emulate button behavior only if click inside the area owned by
    --the emulated button
integer which
    
    which=0
    for i=1 to length(ColoredButtonInformation) do
        if self=ColoredButtonInformation[i][ColoredButtonCWName] then
            which=i     
            exit
        end if
    end for
    
    if which=0 then
        return
    end if
    
    if ColoredButtonInformation[which][ColoredButtonNonGrayDisable] then
        --this will freeze button in last state
        return
    end if

    ColoredButtonInformation[which][ColoredButtonState]=CB_normal   
    
    if params[1]=LeftDown then
        if isChecked(ColoredButtonInformation[which][ColoredButtonName]) then
            setCheck(ColoredButtonInformation[which][ColoredButtonName], w32False)
        end if  
        if find(ColoredButtonInformation[which][ColoredButtonClass],{"ToggleButton","TogglePicture"}) then
            ColoredButtonInformation[which][ColoredButtonPressedTimes]+=1   
        end if
        --draw pushed emulation
        ColoredButtonInformation[which][ColoredButtonState]=CB_leftDown
        VOID=invokeHandler(self, w32HPaint, {})
        
        setFocus(ColoredButtonInformation[which][ColoredButtonName])    --to unfocus prior control
        captureMouse(ColoredButtonInformation[which][ColoredButtonCWName])
    elsif params[1]=LeftUp then
        ColoredButtonInformation[which][ColoredButtonState]=CB_leftUp
        
        --draw up button
        VOID=invokeHandler(self, w32HPaint, {})
        if find(ColoredButtonInformation[which][ColoredButtonClass],{"ToggleButton","TogglePicture"}) then
            if ColoredButtonInformation[which][ColoredButtonPressedTimes] = 2 then
                ColoredButtonInformation[which][ColoredButtonPressedTimes] = 0
            end if
        end if
        releaseMouse()
    end if      
    
end procedure                               
-------------------------------------------------------------------------------
integer CB_click_times CB_click_times=0
procedure self_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
integer which, cb_state, cnt        
           
    cnt=0
    which=0
    pushedNoSlide=w32False

    for i=1 to length(ColoredButtonInformation) do
        if ColoredButtonInformation[i][ColoredButtonCWName] = self then
            
            cb_state=ColoredButtonInformation[i][ColoredButtonState]            
            which=i
                
            clearWindow(ColoredButtonInformation[i][ColoredButtonCWName])
            clearWindow(Pixmap1)
                                
            if not isEnabled(ColoredButtonInformation[i][ColoredButtonName]) then
                setEnable(ColoredButtonInformation[i][ColoredButtonCWName],w32False)
            else
                setEnable(ColoredButtonInformation[i][ColoredButtonCWName],w32True)
            end if
        
            if isChecked(ColoredButtonInformation[i][ColoredButtonName]) then           
                cb_state=CB_leftDownNoDots
            else                
                if cb_state=CB_leftDownNoDots or cb_state=CB_normal then                
                    cb_state=CB_normal              
                    if find(ColoredButtonInformation[i][ColoredButtonClass],{"ToggleButton",
                            "TogglePicture"}) then                                      
                        ColoredButtonInformation[i][ColoredButtonPressedTimes]=0
                        ColoredButtonInformation[i][ColoredButtonToggleStatus]="upcolor"
                    end if
                end if
            end if
                                                
            if not isVisible(ColoredButtonInformation[i][ColoredButtonName]) then
                setPenColor(ColoredButtonInformation[i][ColoredButtonCWName],
                    ColoredButtonInformation[i][ColoredButtonParentColor])
                drawRectangle(ColoredButtonInformation[i][ColoredButtonCWName],w32True,
                    0,0,ColoredButtonInformation[i][ColoredButtonWidth],
                    ColoredButtonInformation[i][ColoredButtonHeight])
                return  
            end if  
            exit
        end if
    end for
    
    if cb_state=CB_leftDown then
        if which then
            drawButton(self, 0, 0, ColoredButtonInformation[which][ColoredButtonWidth],
                ColoredButtonInformation[which][ColoredButtonHeight], w32True, 
                ColoredButtonInformation[which][ColoredButtonPressColor], w32True)          
        end if
    elsif cb_state=CB_leftDownNoDots
    or cb_state=CB_lostFocusDownNoDots then
        if which then                   
            pushedNoSlide=w32True                       
            drawButton(self, 0, 0, ColoredButtonInformation[which][ColoredButtonWidth],
                ColoredButtonInformation[which][ColoredButtonHeight], w32True, 
                ColoredButtonInformation[which][ColoredButtonPressColor], w32False)             
        end if                          
    elsif cb_state=CB_leftUp then
        if which then                           
            drawButton(self, 0, 0, ColoredButtonInformation[which][ColoredButtonWidth],
                ColoredButtonInformation[which][ColoredButtonHeight], w32False, 
                ColoredButtonInformation[which][ColoredButtonColor], w32True)   
            ColoredButtonInformation[which][ColoredButtonState]=CB_normal
            if CB_click_times then
                CB_click_times=0                            
                VOID=invokeHandler(ColoredButtonInformation[which][ColoredButtonName], w32HClick, {})   
            else
                CB_click_times=1                
            end if  
        end if  
    elsif cb_state=CB_normal then   
        if which then       
            drawButton(self, 0, 0, ColoredButtonInformation[which][ColoredButtonWidth],
                ColoredButtonInformation[which][ColoredButtonHeight], w32False, 
                ColoredButtonInformation[which][ColoredButtonColor], w32False)                  
        end if
    elsif cb_state=CB_focused then
        if which then       
            drawButton(self, 0, 0, ColoredButtonInformation[which][ColoredButtonWidth],
                ColoredButtonInformation[which][ColoredButtonHeight], w32False, 
                ColoredButtonInformation[which][ColoredButtonColor], w32True)                   
        end if      
    end if
    
    --clear 0,0 of the real control
    if ColoredButtonInformation[which][ColoredButtonColor] != getSysColor(COLOR_BTNFACE) then
        setPixel(ColoredButtonInformation[which][ColoredButtonName],0,0,ColoredButtonInformation[which][ColoredButtonParentColor])      
    end if
    
end procedure
--------------------------------------------------------------------------------
procedure self_onEvent (integer self,integer event, sequence params)
sequence size, lValues

    for i=1 to length(ColoredButtonInformation) do
        if ColoredButtonInformation[i][ColoredButtonName] = self then
            if ColoredButtonInformation[i][ColoredButtonNonGrayDisable] then
                return  
            end if
            
            if length(getHint(ColoredButtonInformation[i][ColoredButtonName])) then
                if not length(ColoredButtonInformation[i][ColoredButtonHint]) then
                    ColoredButtonInformation[i][ColoredButtonHint]=getHint(ColoredButtonInformation[i][ColoredButtonName])
                end if
            end if
            
            if params[1]=WM_MOVE
            or params[1]=WM_SIZE then               
                
                --erase prior pixmap bitblt-ing             
                --there is an outline ghost where the CWindow was before move or resize
                clearWindow(ColoredButtonInformation[i][ColoredButtonCWName])
                
                --set new location, size
                if params[1]=WM_MOVE then
                    size=getPosition(ColoredButtonInformation[i][ColoredButtonName])
                    setCtlPosition(ColoredButtonInformation[i][ColoredButtonCWName],size[1],size[2])
                    --check parentId in case moved changed parent
                    lValues = getControlInfo(ColoredButtonInformation[i][ColoredButtonName],{CONTROLINFO_type,CONTROLINFO_owner,CONTROLINFO_classinfo,CONTROLINFO_font})
                    ColoredButtonInformation[i][ColoredButtonParentId]=lValues[2]                       
                    --check parent color
                    lValues = getControlInfo(ColoredButtonInformation[i][ColoredButtonParentId],
                                            {CONTROLINFO_bcolor})
                    ColoredButtonInformation[i][ColoredButtonParentColor]=lValues[1]
                    moveZOrder(ColoredButtonInformation[i][ColoredButtonCWName],HWND_TOP)
                else                                    
                    size=getCtlSize(ColoredButtonInformation[i][ColoredButtonName])
                    setCtlSize(ColoredButtonInformation[i][ColoredButtonCWName],size[1],size[2])                
                    ColoredButtonInformation[i][ColoredButtonWidth]=size[1]
                    ColoredButtonInformation[i][ColoredButtonHeight]=size[2]
                    moveZOrder(ColoredButtonInformation[i][ColoredButtonCWName],HWND_TOP)
                end if
            
                VOID=invokeHandler(self,w32HPaint,{})           
                VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})                                                       
            else
                return
            end if
        end if
    end for
end procedure
--------------------------------------------------------------------------------
procedure self_onLostFocus (integer self,integer event, sequence params)
    --make emulated button look normal
    for i=1 to length(ColoredButtonInformation) do
        if ColoredButtonInformation[i][ColoredButtonName] = self then
            if ColoredButtonInformation[i][ColoredButtonNonGrayDisable] then
                return  
            end if
            ColoredButtonInformation[i][ColoredButtonState]=CB_normal
            if ColoredButtonInformation[i][ColoredButtonPushed]
            and find(ColoredButtonInformation[i][ColoredButtonClass],
                    {"TogglePicture","ToggleButton"}) then           
                ColoredButtonInformation[i][ColoredButtonState]=CB_lostFocusDownNoDots  
            end if          
            VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName],w32HPaint,{})       
            exit
        end if
    end for 
end procedure

--------------------------------------------------------------------------------
procedure setTheHandlers()
    integer parent

    for i=1 to length(ColoredButtonInformation) do
        setHandler(ColoredButtonInformation[i][ColoredButtonCWName], w32HPaint,routine_id("self_onPaint"))
        setCtlSize(ColoredButtonInformation[i][ColoredButtonName],1,1)  --need so ESC works with CancelButton
        setHandler(ColoredButtonInformation[i][ColoredButtonName], w32HEvent,routine_id("self_onEvent"))
        setHandler(ColoredButtonInformation[i][ColoredButtonName], w32HLostFocus,routine_id("self_onLostFocus"))
        setHandler(ColoredButtonInformation[i][ColoredButtonCWName], w32HMouse,routine_id("self_onMouse"))
    end for
end procedure
--------------------------------------------------------------------------------
--this routine gets the ball rolling!
global procedure initiateColoredButtons()

    setTheHandlers()
    
    for i=1 to length(ColoredButtonInformation) do      
        --draw the button               
        openWindow(ColoredButtonInformation[i][ColoredButtonCWName], Normal)
        VOID=invokeHandler(ColoredButtonInformation[i][ColoredButtonCWName], w32HPaint, {})     
    end for
end procedure
862.10
