--
-- Edix.exw
-- ========
--  Port of Edita from arwen to pGUI

--global constant USEINI = true -- temp

with trace
--
-- **INCOMPLETE**
--
--  Obviously now that Phix is cross platform, it needs a cross platform editor.
--  While both wee and tee are fine, there are several things in the edita codebase
--  that I simply could not bear to throw away, especially:
--      * The dynamic syntax colouring and help lookup systems. [1]
--      * Cut/Copy append/prepend are very rarely found in other editors
--      * Column cut and paste (ditto)
--      * Control structure traversal via Ctrl [ and Ctrl ]
--      * Tools/File compare - admittedly I might be a bit biased about that one
--      * Tools/Find in Files (made standalone?)
--      * Tools/Htmlise eucode  ""
--      * Tools/Reindent source ""
--      * Tools/Quick jump (especially for builtins\VM)
--      * Macro record/playback (priceless)
--      * Tabs list (to be renamed as file list)
--  [1] In Edita I can just edit xxx.syn and phix.txt as I document things, and both the 
--      syntax colouring and F1 help lookup take effect immediately, without a restart.
--
--  My staring point is tee, with scintilla ripped out and replaced with a canvas.
--
--  One thing that won't be ported is FTP (I use http://www.net2ftp.com now anyway)
--  I have felt for a while that the message area should be some kind of separate window, and
--  project tree (which is currently broken), and recovery are better off as separate processes
--  anyway, the directory tree really wants merging with "tabs list" and extending to an "all
--  files" selector, plus it would probably work better to have an icon, count and the most
--  recent message from any errors/ex.err in the status bar (or routine list dropdown).
--  Also save on tab switch is going (now always = yes), and hence so too is "save all".
--  Directory compare would also benefit greatly from being made standalone (esp. the gui)
--  I suspect it is also time to wave bye-bye to options\reformat ex.err
--
-- Additions:
--  * Keyboard mapping (replaces F1/keyboard help)
--  * Close unused/unviewed tabs after N sessions/days [DONE]
--  * Periodic save of options and open file lists.
--  * Tabs list (rename as file list) to have "all" option, and possibly a directory tree
--  * Utilise multi-threading/multiple processes a bit more (esp find in files).
--
-- Deferred: (hey, something's gotta give! - lnx/64 are the priorities right now..)
--  * Folds (hopfully not for long)
--  * Wordwrap (maybe forever...)
--  * Unicode files (proof of concept was fine, but after writing some cross-platform utf 
--                   conversion routines, I realised I was on bit of a slippery slope.)
--  * Bookmarks (I never really used them)
--  * multi-line find (still need a find drop-down, and a clear history button)
--  * Replace (use a macro - I should offer several standard ones anyway)
--      [damn - I had plans for the replace dropdown to hold clipboard history...]
--
-- Dropped:
--  * ftp
--  * Tab bar visibility (now always on) [ditto menu,toolbar,statusbar]
--  * Find from start of file - it is easier to Ctrl Home before Ctrl F.
--  * replace -> paste/macro and a new clipboard manager instead?
--
-- SUG: flip routine list into error list (and change colour), until empty.
-- BUG: opening a recent file entry adds a duplicate tab!!
-- SUG: cannot open -> offer browse (and default any more in the same dir)
-- SUG: parameterised run should keep ~ten most recently run, in the config file.
-- SUG: on paste of utf8 into ansi, offer "save as utf8?" pop-up.
-- DEV: options: save macros Yes/Once/No.
-- BUG: closing when maximised forgets the "natural" (main) window size. [FIXED, albeit windows only]
--/*
filedlg [DONE, ish]
listview
--simple_notepad - not tabbed, IupText (stolen)
--simple_paint
--generica... (maybe I should port that to pGUI...) [nah]

menu, toobar, icon(s)   [DONE]
statusbar, scrollbars   [DONE]
loadfile [DONE]
sort out tab/index handling [DONE]
intellisense (ctrl space, autocompletion/dropdown, italics/tab) [GUI DONE]
intellitip (ctrl shift space, floating hint) [GUI DONE]
pop-up menus (canvas and tab) [GUI DONE]
pop-up windows:
zoom in/out [DONE]
keyboard settings (replacement for key help) [DONE]
synload/syncolour [DONE]
undo/redo [DONE]
recent files, and other IupConfig stuff [DONE]
--*/
/* (from simple_notepad, delete when done:) If instead of using IupText we use IupScintilla, then we can add:
   - more find/replace options
   - zoom
   - show white spaces
   - margins
   - word wrap
   - tab size
   - markers
   Hot keys for:
   - match braces
   - to lower case
   - to upper case

hit list 31/7/16:
tedb (or just rely on the arwen version for now)
Ctrl Q [DONE]
routine list dropdown [part done, but no click/cursor..]
colours
selectfont
help [inc. ext/chm]
background scan
project tree (needs background scan)
Ctrl T file list (needs "")
save the ini file (IupConfig) on a regular basis... [never done, use saveINI() now anyway, when/if you get round to this][DOESNOTWORK!]
`vedb
macros
autocompletion (if while etc)
replace[?]
window painter(!!)
print/print preview
report painter(!!)
wordwrap..
compare
directory compare
find in files [DONE]
htmlise eucode [DONE]
common code analysis
recovery
display options
edit options
check for upgrades
about
Ctrl [ ]
intellitip
intellisense
*get this working as-is on linux!!
run [DONE]
keyboard [DONE, with a todo marker!]
Ctrl W [DONE]
re-open [DONE]
save as [DONE]
file read/write [DONE]
save/restcursor [DONE]
SetMainText [DONE]
changeTo [DONE]
scrollbars [vertical DONE]
mouse (drag/move) MOTION_CB [DONE]
extensions: list, static area with dropdown, edit text, browse, help, save/cancel/ok [DONE]

--DEV doc:
Automatic Backups:
==================
Whenever a file is saved, a backup subdirectory is created if one does not already exist, and the contents of the file being 
overwritten saved to <i>&lt;file base&gt;.&lt;revision&gt;.&lt;file extension&gt;</i>, where revision is a sequential number, 
zero filled to four places, that should be unique across all files in the backup directory.

For example editing test.txt (and nothing else) should result in backup/test.0001.txt, backup/test.0002.txt, etc.

Should the revision number exceed 9999, then the backup directory is renamed as backup.000N where 000N is the next available number,
and then it (re-)creates a new backup subdirectory and resets the revision number for new files created within that to 0001.
Directories are scanned once per session to determine the two revision numbers, and a (non-fatal) error message is generated when 
creating backup.9999. The result of exceeding 99,980,001 files (9999^2) spread across 9,999 backup directories is undefined, but 
you should not be surprised if it decides to crash!

When a backup.NNNN directory is found that has not been modified for more than 3 months, a pop-up is shown when closing Edix to 
offer automatic purge and renumbering - which may affect file dates and therefore sometimes retain files for a full six months, 
although that would require you to average more than 111 saves per day (including the weekends) in some particular directory.
You can of course say no, and either squirrel them away somewhere else or re-date them to put that process off a bit longer.

You should be making manual "significant milestone" backups entirely independently of the automatic backup system anyway, perhaps 
as releases, perhaps as source code repository commits, and certainly rather than be wading through 10+ years of several-times-a-day 
backups, especially when looking for anything older than three months - ideally you will have mentioned whatever it is you seek
somewhere in your release/commit notes, making that whole process at least several thousand times easier.

The creation date of the backup file indicates when the backup was made, whereas the modified date is copied unaltered from the file 
being overwritten. Typically the creation date ordering will (/should, same-second aside) match the revision number ordering.
The restore mechanism of Edix makes no attempt whatsoever to restore the file dates when restoring the file contents.

Obviously, restoring a backup makes no changes to the backup file itself, but may well result in the creation of newer backups.

Session Management
==================
When you close Edix and re-open it, the same files are re-opened exactly as before. Each time, however, an "un-visited count" is
quietly incremented, and if a file has been pointlessly re-opened, without even being looked at, more than a specified number of
times (configurable, default 40), it is quietly excluded the next time Edix is re-opened. Each time Edix is started, a count is
incremented against each file, and zeroed each time a tab is left (including the current tab when Edix is closed), and finally 
when Edix is closed any files that breach the limit are omitted from the (next) Session list, unless the limit has been set to 
zero (aka "infinite").

It is not the intention to be quick about getting rid of un-visited files, but rather to keep things manageable in the longer
term. The limit of 40 is reasonably high so that other (non-Edix-related) issues do not cause all the files you are still working
on to be closed, just because you had to reboot a few times.

[DEV] A future possibility is to propagate un-visited count resets throughout the project tree, so for example while I am still
working on psym.e, it keeps p.exw and pglobals.e open as well.
 */

-- Known issues:
--  If you drag the vertical slider left over Project/Directory, they overlap the tabbar until very narrow, at which
--  point the radio boxes and the tree are auto-hidden. Ideally I'd clip. Using Ctrl L to show/hide is easier anyway.
--  DEV unicode is not yet supported/tested on linux??

--puts(1,"started\n") -- DEV (temp, helps with focus while debug displays are occuring)
puts(1,"WARNING: This program is not useable in its current state\n")

include builtins\pGUI.e

--#withtype bool
--#withtype Ihandle
--#withtype Ihandln
--#withtype cdCanvas
--#withtype nullable_string

constant RotateBackground = 0   -- development option (verify redraw is kept to a minimum)

constant UseNativeDialog = 01   -- DEV option (windows only[?])

include builtins\fileopenN.ew   --                  ""

--constant SLASH = iff(platform()=WINDOWS?'\\':'/')

global Ihandle dlg, sbmsg, tabs
global Ihandln config
Ihandle autosavetimer
Ihandle tbox, rtbox, tree, tcbox, canvas
Ihandle sbhbox, sbline, sbinfo, sbdate
Ihandln clipboard = NULL
--Ihandln sbtemp = NULL
cdCanvas cddbuffer, cdcanvas
integer tip_visible = 0
integer tabfile = 0 -- (if!=0, New/Open use dir from that tab [it's a FILEIDX])
--integer treewidth,treeheight
atom tboxv = 150    -- file panel width (/not/ the N/1000'ths of width thing)

-- The following sequences are managed as follows:              [DEV merge?] 
--  tab = IupGetAttributeHandle(tabs, "VALUE")  -- current tab
--  fidx = IupGetInt(tab,"FILEIDX")             -- seqs index
-- new tabs are always appended; when one is closed, we simply
--  move seqs[$] into the vacated slot and update one FILEIDX.

--DEV enum ,,,SESSION_UNVISITEDCOUNT=11

global sequence filenames,
                filepaths,
                filetext,   -- NOTE: filetext[file][line] should be either an
                            -- ****  ansi string, or a utf_32 dword_sequence;
                            --  **   it should //NEVER// be a utf_8 string,
                            --       otherwise pos/char counting goes to pot.
                            --       (and likewise it should never be utf_16)
                            --       There is NO harm in mixing ansi/utf_32 
                            --       lines, even within a single file, and
                            --  **   it is **NOT** a bug should you see such
                            -- ****  in ex.err files/diagnostics. [***NB***]
                unicodefile, filelinelengths,
                filecursel, bCfwds, filedt
                filenames = {}  filepaths = {}  filetext = {}   unicodefile = {}
                filelinelengths = {}  filecursel = {}   bCfwds = {}  filedt = {}

global -- for eacomp  DEV: possibly needed for eafif/eacca/eaxutil...
sequence unpacked       -- 0=just loaded, -1=fully unpacked, +ve=unpacked to line nnn
         unpacked = {}

global -- for eamenus.ew
sequence wrapped        -- 0=just loaded or isWordWrapON (aka filecursel[c][11])=0,
         wrapped = {}    -- -1=fully unpacked, +ve=unpacked to line nnn


global -- for eaedb, saveFolds/loadFolds, also checked by eaopts.ew.
sequence bookmarks      -- {{{type,start,end}}} sets. Also holds folds and wordwraps.
         bookmarks = {}

global constant MARK = #01, FOLD = #02, WRAP = #04

global constant bfType = 1,     -- bit #01 indicates a bookmark, 
                                -- bit #02 a fold,
                                -- bit #04 a wordwrap.
                                -- #03 (=MARK+FOLD), #05 (=MARK+WRAP) valid, but #06, #07 not.
                bfStart = 2,    -- start line (0-based)
                bfEnd = 3       -- end line (0-based) if #02 set,
                                -- {col} (0-based) if #04 set,
                                -- unused on mark-only lines.

global constant rtnNAMES = 1,  rtnSTART = 2,  rtnEND = 3
global sequence routines
                routines = {}

global  -- see undo.e
sequence actions,   -- {sequence}   -- (as above)
         actionptr, -- {integer}    -- undo/redo point
         actionsave -- value of actionptr at last save, or -1.
    actions = {}
    actionptr = {}
    actionsave = {}

include builtins/pfile.e

global
integer currfile = 0

--integer tabfile       -- tab if right clicked
--      tabfile = 0     -- (overrides currfile, reset on use)

--DEV IupConfig the lot:
global integer
                isDebug = 0,            -- see eanotes.txt
--              isWindowMaximised,      -- whether Window is[was] maximised [at shutdown]
--              isShowFullPath,         -- show full path or just filename in titlebar
--              isToolBarVIS,           -- toolbar visible      [deleteme]
--              isTabBarVIS = 1,        -- tabbar visible       [deleteme]
--              isSingleDir,            -- tabbar shows files from single dir
--              isMultiLineTab,         -- tab bar has TCS_MULTILINE style
--              isTabottom,             -- tab bar at bottom
--              isTabsOwnerDrawn,       -- owner drawn tabs (recommended)
--              isRaggedRight,          -- use ragged right tabs style
--              isFilePanelVIS,         -- Directory/Project panel visible
--              isFilePanelWidth,       -- file panel area width
--              isMessageVIS,           -- message area visible
--              isMessageHeight,        -- message box height
--              isHScrollVIS,           -- horizontal scroll bar
--              isVScrollVIS,           -- vertical scroll bar
--              isMoveCursorOnScroll,   -- (cancels selection)
--              isScrollPerm,           -- always show scrollbars (reduces flicker on tab switch)
                isFoldMarginPerm = 1,   -- always show fold margin (so mouse click always possible)
--              isStatusBar,            -- status bar
                isWordWrapON = 0,       -- wordwrap flag set/saved on a file-by-file basis.
--              isFormatErr,            -- reformat ex.err
--              isSingleInstance,       -- single instance handling
--              isRestoreOnOpen,        -- open previous files
--              isAutoSaveOnExit,       -- suppress any warnings, just save altered files
--              isAutoSaveOnTabSwitch,  -- save files on tab switch
                isAutoSaveTimer = 0,    -- save files every nnn seconds
                isAutoBackup = 1,       -- create backups
--              isLoadErrFileOnError,   -- now jumps to line with summary on statusbar
--DEV should now be "always on":
                isReplaceTabs = 1,      -- save file with no \t
--              isLegacyTabHandling,    -- Legacy Tab Character Handling
                isTabWidth = 4,         -- Tab Width (1..8)
                isHomeFirstNonBlank = 1,-- Home jumps to first non-blank character
                isLineNumbers = 1,      -- show line numbers?
                isMarginSpace = 1,      -- space after margin?
--              mouseWheelScroll,       -- wheelmouse multiplier
--              isCaretBlinkTime,       -- Caret Blink Time in milliseconds
----                isLineLengthError,      -- set to 0 to inhibit error messages
                isAutoComplete = 1,     -- 1 if autocompletion enabled
--              isBackGround,           -- 1 if background processing enabled
--              isCurrProject,          -- 0 if no project selected
--              isClearOverStrike = 0,      -- clear overstrike mode
                isClearOverStrike = #7F,        -- clear overstrike mode
                isUndoTime = 0,         -- retain undo actions for nn seconds
                isRetainBackupsFor = 5, -- retain automatic backups for nn days
--              isCloseLeft             -- close tabs to left?
                $

-- bits of isClearOverStrike:
--global 
constant cOVRup      = #01,
         cOVRdown    = #02,
         cOVRfile    = #04, -- default
         cOVRpage    = #08, -- default
         cOVRpaste   = #10,
         cOVRdupline = #20,
         cOVRhome    = #40

--global constant string initialcurrentdir = get_proper_dir(command_line()[2])

global object bCfwd -- bracket carry-forward info (see easynclr.e)

--global 
integer paintRqd    -- +ve=line [1..linesPerPage] next requiring display.
        paintRqd = 0 -- 0 when all lines have been properly displayed

global -- for synclr.e [DEV??]
integer paintLast           -- if non-zero, last line to be painted
        paintLast = 0

global -- for easynclr.e (shade in selX,Y to CursorX,Y)
integer CursorX = 0,    -- 0 for column 1 (ie insert before first character)
        CursorY = 0,    -- 0 for line 1 (in range 0..length(filetext[currfile])-1)
        TopLine = 0,    -- line no corresponding to top of screen (0-based)
        Column  = 0,    -- column (0-based)
        TopChunk = 0    -- start point for wordwrap of TopLine

--global integer isEu -- must be set before calls to ExpandTabs/PackTabs.
--             isEu = 0

global integer selON = 0, -- 1 if selection is active, 2 if column mode, else 0
               selX = 0,    -- selection anchor, if any (0-based)
               selY = 0 -- (in range 0..length(filetext[currfile])-1)

-- used (read-only) by easynclr.e, toggled by eaopts.ew, and/or setMarginRqd():
global integer marginRqd
--DEV:
    marginRqd = isFoldMarginPerm

--global -- for eaopts.ew --?? removed 27/3/10
integer linesPerPage
        linesPerPage = 0

--global -- used by eaerr.e
integer charsWide
        charsWide = 0

global function curb(integer low, integer val, integer high)
-- eg curb(0,y,11) returns y if y>=0 and y<=11, 0 if y<0, or 11 if y>11.
--  if val<=low then return low elsif val>=high then return high else return val end if
    return iff(val<=low?low:iff(val>=high?high:val))
end function

integer landingChunk    -- for showCaret() ONLY; iff CursorY,CursorX *is* on-screen
integer endChunk

--with trace
--global 
function distanceFromTopLine(integer cY, integer cX)
--
-- calculate the distance of cY,cX from TopLine,TopChunk in terms of screen lines,
-- accounting for any folds or wordwrapped lines betwixt (inclusive).
-- Returns a value in the range 0..linesPerPage-1 if cY,cX is on-screen.
-- As used by forceCursorOnscreen, if the result is -1, scroll up one line,
-- if the result is linesPerPage, scroll down one line.
-- The setting of landingChunk is quite specialised and should be used with caution.
-- (it is 0 or the wrap entry colno that cY,Cx lies on).
--
integer d,  -- result var
    wY, wX, -- working position
    tY, tX, -- target position
    dinc,   -- direction flag/increment
    getNiL, bmistart, nextImportantLine,
    FW  -- FOLD+WRAP, or just FOLD if isWordWrapON=0
sequence BookMarkSet
object SetEntry
integer prevWW,thisWW

    BookMarkSet = bookmarks[currfile]
    if cX<0 then  cX = 0  end if
    if cY<TopLine
    or (isWordWrapON and cY=TopLine and cX<TopChunk) then
        tY =  TopLine   tX = TopChunk   wY = cY  wX = cX   d = -1   dinc = -1
    else
        wY = TopLine   wX = TopChunk   tY = cY   tX = cX   d = 0    dinc = 1
    end if
    landingChunk = TopChunk
    endChunk = 0
    if isWordWrapON then
        FW = FOLD+WRAP
    else
        FW = FOLD
    end if
    getNiL = True
    bmistart = 0
    if wY<tY
    or (isWordWrapON and wY=tY and wX<tX) then
        while 1 do
            if getNiL then
                getNiL = False
                nextImportantLine = -1
                for i=bmistart+1 to length(BookMarkSet) do
                    SetEntry = BookMarkSet[i]
                    if sequence(SetEntry) then
                        if SetEntry[bfStart]>=wY
                        and and_bits(SetEntry[bfType],FW) then
                            nextImportantLine = SetEntry[bfStart]
                            bmistart = i
                            exit
                        end if
                    end if
                end for
            end if
            landingChunk = 0
            if wY=nextImportantLine then
                if and_bits(BookMarkSet[bmistart][bfType],FOLD) then
                    wY += BookMarkSet[bmistart][bfEnd]-nextImportantLine+1
                    getNiL = True
                else    -- a wrap
                    prevWW = 0
                    for i=1 to length(BookMarkSet[bmistart][bfEnd]) do
                        thisWW = BookMarkSet[bmistart][bfEnd][i]
                        if wX<thisWW then
                            wX += thisWW-prevWW
                            landingChunk = prevWW
                            endChunk = thisWW
                            prevWW = -1
                            exit
                        end if
                        prevWW = thisWW
                    end for
                    if prevWW!=-1 then  -- hit end w/o nudge
                        wY += 1
                        wX -= thisWW
                        landingChunk = thisWW
                        endChunk = 0
                        getNiL = True
                    end if
                end if
            else
                wY += 1
            end if
            if wY>tY then exit end if
            if isWordWrapON and wY=tY and wX>tX then exit end if
            d += dinc
        end while
    end if
    return d
end function

integer nacX    -- new adjusted cX, the 3rd param of adjustLine()
                -- note: nacX may be past EOL, callee should use
                --      pref. checkCursorX() after to fixup.


--DEV begone!
--include src/xlate.e
--include src/icd.e -- initialcurrentdir
--DEV fix rein:
--global constant string initialcurrentdir = get_proper_dir(command_line()[2])
constant cl = command_line()
global constant string initialcurrentdir = get_proper_dir(cl[2])

global function xl(sequence text)
    return text
end function

--DEV
global integer isFTP = 0            -- 1 if opened via "Edit with Edita" else 0
global integer checkProj = 0        -- repaint TVprjl when needed (if it is visible)

--global 
integer unicodeflag     -- ANSI/UTF8/UTF16LE/UTF16BE
--global 
constant ANSI    = 0,   -- (ie 8-bit chars)
         UTF8    = 1,   -- (some multibyte chars)
         UTF16LE = 2,   -- (some surrogate pairs) [used for M$.reg files]
         UTF16BE = 3    -- (         "          )
-- (Edix does not [yet] support UTF32 files; while I suspect it would be pretty
--  straightforward, the important question is whether there is any real need.)

include src/auto.e
--DEV after main/IupOpen...
include src/synld.e
include src/synclr.e as synclr
include src/dateadj.e
include src/eaedb.e
include src/tabs.e

function get_unicode_char(integer fn)
integer ch, ch2
    ch = getc(fn)
    if ch!=-1 then
        ch2 = getc(fn)
-- PL 10/09/2013 (spotted in passing: we cannot avoid the *#100 in UTF16BE!)
--      if ch2 then
--          if unicodeflag=UTF16LE then
--              ch = ch+ch2*#100
--          else
--              ch = ch2+ch*#100
--          end if
--      end if
        if unicodeflag=UTF16LE then
            if ch2 then
                ch += ch2*#100
            end if
        elsif unicodeflag=UTF16BE then
            ch = ch2+ch*#100
        else
            ?9/0
        end if
    end if
    return ch
end function

function get_unicode_line(integer fn)
-- returns a string or utf32 sequence, or -1 at eof
integer ch
object res
    if unicodeflag=UTF8 then
        res = gets(fn)
        if not atom(res) then
--23/7/17...
--          res = utf8_to_utf32(trim(gets(fn),"\r\n"))
            res = utf8_to_utf32(trim(res,"\r\n"))
            -- (note: res may be string, if pure-ascii, ie all chars<=#7F)
        end if
    else                            -- UTF16 (LE|BE)
        ch = get_unicode_char(fn)
        if ch= -1 then
            res = -1
        else
            res = {}
            while ch!=-1 do
                if ch!='\r' then
                    if ch='\n' then exit end if
                    res &= ch
                end if
                ch = get_unicode_char(fn)
            end while
            res = utf16_to_utf32(res)
        end if
    end if
    return res
end function

function readFile(sequence name, integer prompt=1)--, integer plth)
-- open and read contents of specified file.
-- if prompt!=0 then display messageBox on error (else keep schtum)
-- if plth then allow legacy tab character handling, if -1 force it.
-- returns: 0 on failure, {line[1..n]}, or {""} for empty file.
--  (ie The latter case is that a completely empty file is 
--   represented by one line of length 0, not 0 lines,
--   which is also the general case for open new;
--   {{"fred"}} represents a text file of four bytes,
--   {{"fred"},""} represents four bytes "plus \n",
--   likewise {"",""} represents a single line break.
--   Note that that \r\n conversion is inherent; if Edix opens
--   a file with Linux-style linebreaks, it will automatically
--   save it with Windows-style linebreaks, as determined by the
--   puts(fn,'\n') statement in saveFile().
-- Also sets unicodeflag (except on failure) [DEV]
sequence file
integer fn
--, filelen
--integer lineno
object line
sequence linelengths = repeat(0,80)
integer linelength
--object d
--atom t
--integer ch
integer uniskip

    fn = open(name,"r")
    if fn=-1 then
        if prompt then
--          void = messageBox(xl("Edita: Error opening file"),name,0)
            IupMessage(xl("Edix: Error opening file"),name)
        end if
        return 0
    end if
--  ltch = 0
--  ltch = plth
----    if isLegacyTabHandling then
--  if ltch = 1 then
--      d = dir(name)
--      if not sequence(d)
--      or length(d)!=1 
--      or not sequence(isLegacyTcod) 
--      or compare(d[1][4..9],isLegacyTcod)!=-1
--      or not isLegacyTabHandling then
----            plth? = -1
----            ltch = 1
----        else
--          ltch = 0
--      end if
--  end if
--  if ltch then
--      ltchcount += 1
--  end if
    --  file = repeat(0,200)
    file = {}
--  linelengths = repeat(0,80)
--  filelen = 200
--  lineno = 0

--DEV
--  setIsEu(name)

--t = time()+0.25
    unicodeflag = ANSI
    line = gets(fn)
    if not atom(line)
    and length(line)>=2 then
        if equal(line[1..2],{#FF,#FE}) then
            unicodeflag = UTF16LE
            uniskip = 2
        elsif equal(line[1..2],{#FE,#FF}) then
            unicodeflag = UTF16BE
            uniskip = 2
        elsif length(line)>=3
          and equal(line[1..3],{#EF,#BB,#BF}) then
            unicodeflag = UTF8
            uniskip = 3
        -- I suspect these two would be fairly easy, if there is any real need.
        elsif length(line)>=4
          and equal(line[1..3],{#00,#00,#FE,#FF}) then
--          unicodeflag = UTF32BE
--          uniskip = 4
            IupMessage("Sorry","UTF-32 (BE) is not supported")
            return 0
        elsif length(line)>=4
          and equal(line[1..3],{#FF,#FE,#00,#00}) then
--          unicodeflag = UTF32LE
--          uniskip = 4
            IupMessage("Sorry","UTF-32 (LE) is not supported")
            return 0
        -- NB as per the docs, think long and hard before attempting any of these...
        --        (for more details, start by reading the wikipedia UTF BOM page)
        elsif length(line)>=4
          and equal(line[1..3],{#2B,#2F,#76})
          and find(line[4],{#38,#39,#2B,#2F}) then
--          unicodeflag = UTF7 (plus 38|39|2B|2F|38 2D)
--          uniskip = 4 with 2 bits carried, or 5 plus empty string
            IupMessage("Sorry","UTF-7 is not supported")
            return 0
        elsif length(line)>=3
          and equal(line[1..3],{#F7,#64,#4C}) then
--          unicodeflag = UTF1
--          uniskip = 3
            IupMessage("Sorry","UTF-1 is not supported")
            return 0
        elsif length(line)>=4
          and equal(line[1..3],{#DD,#73,#66,#73}) then
--          unicodeflag = UTFEBCDIC
--          uniskip = 4
            IupMessage("Sorry","UTF-EBCDIC is not supported")
            return 0
        elsif length(line)>=3
          and equal(line[1..3],{#0E,#FE,#FF}) then
--          unicodeflag = SCSU
--          uniskip = 4
            IupMessage("Sorry","SCSU is not supported")
            return 0
        elsif length(line)>=3
          and equal(line[1..3],{#FB,#EE,#28}) then
--          unicodeflag = BOCU1
--          uniskip = 3
            IupMessage("Sorry","BOCU-1 is not supported")
            return 0
        elsif length(line)>=4
          and equal(line[1..3],{#84,#31,#95,#33}) then
--          unicodeflag = GB18030
--          uniskip = 4
            IupMessage("Sorry","GB-18030 is not supported")
            return 0
        end if
    end if
--  if unicodeflag=ANSI
--  and get_file_extension(name)="p6" then
--      unicodeflag = UTF8
--      uniskip = 0
--  end if
    if unicodeflag!=ANSI then
        -- gets() returns L"Hello" as "H\0e\0l\0l\0o\o" and makes a complete mess 
        -- of \r\0\n\0 handling, iyswim. So read it a (wide)char at a time.
        -- likewise getc() will not process "\r\0\n\0" as one might like, so close
        -- and re-open the file in binary mode.
        close(fn)
        fn = open(name,"rb")
        if seek(fn,uniskip) then
            puts(1,"error seeking in readFile")
        end if
        line = get_unicode_line(fn)
    end if
    while not atom(line) do
--      linelength = ExpLength(line)
--      if linelength!=0 then   -- added 8/6/2013
        line = trim(line,"\r\n")
        linelength = ExpLength(line)
--29/9/16: 
        line = ConvertTabs(line, isTabWidth, isTabWidth)
--                  DEV: allow override of ^ for reopen
--      end if
        file = append(file,line)
        if linelength>=length(linelengths) then
            linelengths &= repeat(0,linelength-length(linelengths)+1)
        end if
        linelengths[linelength+1] += 1
        if unicodeflag=ANSI then
            line = gets(fn)
        else
            line = get_unicode_line(fn)
        end if
    end while
--/*
    while not atom(line) do
--now done in IdleHandler:
--      if isEu then
--          if isReplaceTabs or Xtrans or isTabWidth!=8 then
--          line = PackTabs(line,0)
--          end if
--      end if
        linelength = length(line)
        if linelength!=0 then   -- added 8/6/2013
-- SUG/test speed:
--          line = trim(line,"\r\n")
            ch = line[linelength]
            while ch='\n' 
               or ch='\r' do
                linelength -= 1
                line = line[1..linelength]
                if linelength=0 then exit end if
                ch = line[linelength]
            end while
        end if
--      if prompt=-1 then       -- legacy handling
--      if ltch then            -- legacy tab handling
--          line = ConvertTabs(line,isTabWidth,isTabWidth)  --DEV wtf??!!
--          linelength = ExpLength(line)
--      else
--          linelength = ExpLength8(line)
            line = ExpandTabs(line)
            linelength = length(line)
--29/9/16:
            line = ConvertTabs(line, isTabWidth, isTabWidth)
--      end if
        --  file[lineno] = line
        file = append(file,line)
        if linelength>=length(linelengths) then
            linelengths &= repeat(0,linelength-length(linelengths)+1)
        end if
--      linelengths[linelength+1] = linelengths[linelength+1] + 1
        linelengths[linelength+1] += 1
--if t<time() then
--  t = time()+0.25
----    setText(SB6(->sbmsg),sprintf("loading, line:%d",lineno))
--  setText(SB6(->sbmsg),sprintf("loading, line:%d",length(file)))
--end if
        if unicodeflag then
            line = get_unicode_line(fn)
        else
            line = gets(fn)
        end if
    end while
--*/
    close(fn)
    if length(file) then
--      if usegpp then
--          if isFormatErr and match("ex.err",name)=length(name)-5 then
--              return preprocessErr(file)
--          end if
--      else
--          --      if isFormatErr and match(".err",LowerCase(name))=length(name)-3 then
--          if isFormatErr and match("ex.err",LowerCase(name))=length(name)-5 then
--              return preprocessErr(file)
--          end if
--      end if
--      return file
        return {file,linelengths}
    end if
    linelengths[1] = 1
    return {{""},linelengths}
end function


global integer insertMode = 1   -- insert(1)/overstrike(0) mode

integer maxlen
        maxlen = 0

procedure reCalcMaxLen()
    maxlen = 0
    for i=length(filelinelengths[currfile]) to 1 by -1 do
        if filelinelengths[currfile][i] then
            maxlen = i
            exit
        end if
    end for
end procedure

--procedure replaceLine(integer idx, string newline)
procedure replaceLine(integer idx, sequence newline)
-- maintain the linelengths array as lines are modified.
-- note that idx is 1-based (unlike CursorY etc)
integer len, c
    len = ExpLength(filetext[currfile][idx])+1
--DEV temp hack (load files as tab8?)
--  if len>length(filelinelengths[currfile]) then
--  if not rlle then
--      void = messageBox("replaceLine Error",
--              sprintf("replacing length %d, table length %d"&
--                  "\n\n(let me know if/when this happens)",
--                  {len,length(filelinelengths[currfile])}),
--              0)
--      if isDebug then ?9/0 end if
--      rlle = 1
--  end if
--  return
--  end if

    c = filelinelengths[currfile][len]-1
    filelinelengths[currfile][len] = c
    len = ExpLength(newline)+1
    if len>length(filelinelengths[currfile]) then
        filelinelengths[currfile] = filelinelengths[currfile] &
                                    repeat(0,len-length(filelinelengths[currfile])+1)
    end if
    filelinelengths[currfile][len] = filelinelengths[currfile][len]+1
    if len>maxlen or c=0 then
        reCalcMaxLen()
    end if
    filetext[currfile][idx] = newline
end procedure

procedure removeLineLength(integer idx)
-- remove a single line length
-- note that idx is 1-based (unlike CursorY etc)
integer len, c
sequence fci
    fci = filetext[currfile][idx]
    len = ExpLength(fci)+1
--DEV temp hack (load files as tab8?)
--  if len>length(filelinelengths[currfile]) then
--      IupMessage("removeLineLength Error",
--          sprintf("removing length %d, table length %d"&
--              "\n\n(let me know if/when this happens)",
--              {len,length(filelinelengths[currfile])}))
--  return
--  end if
    c = filelinelengths[currfile][len]-1
    filelinelengths[currfile][len] = c
--  for i = length(bookmarks[currfile]) to 1 by -1 do
--  if bookmarks[currfile][i][bfStart]=idx-1 then
--      bookmarks[currfile] = bookmarks[currfile][1..i-1]&
--              bookmarks[currfile][i+1..length(bookmarks[currfile])]
--      exit
--  end if
--  end for
    if c=0 then reCalcMaxLen() end if
end procedure

procedure removeLineLengths(integer ixFrom, integer ixTo)
-- remove line lengths for a block deletion
-- note that ixFrom and ixTo are 1-based (unlike CursorY etc)
integer len, c, recalc
sequence fci
    recalc = 0
    for idx=min(ixFrom,ixTo) to max(ixFrom,ixTo) do
        fci = filetext[currfile][idx]
        len = ExpLength(fci)+1
--DEV temp hack (load files as tab8?)
-- 5/5/08 put back in. Compared d.asm with p.asm, deleted first 100 or so lines...
--22/6/13 put back in..
        if len>length(filelinelengths[currfile]) then
            string msg = sprintf("removing length %d, table length %d",
                                 {len,length(filelinelengths[currfile])})
            IupMessage("removeLineLengths Error",msg)
            return
        end if
        c = filelinelengths[currfile][len]-1
        filelinelengths[currfile][len] = c
--  for i = length(bookmarks[currfile]) to 1 by -1 do
--      if bookmarks[currfile][i][bfStart]=idx-1 then
--      bookmarks[currfile] = bookmarks[currfile][1..i-1]&
--                  bookmarks[currfile][i+1..length(bookmarks[currfile])]
--      exit
--      end if
--  end for
        if c=0 then recalc = 1 end if
    end for
    if recalc then reCalcMaxLen() end if
end procedure

Ihandle toolb_rtns

--/"*
--global 
integer prevRtnIdx = 0

procedure setRtnIndex()
integer k
sequence r
    if currfile and sequence(routines[currfile]) then
        r = routines[currfile]
        k = 0
        for i=1 to length(r[rtnNAMES]) do
            if r[rtnSTART][i]>CursorY+1 then exit end if
            if r[rtnEND][i]>CursorY then  k = i  exit end if
        end for
        if prevRtnIdx!=k then
            prevRtnIdx = k
--          if rtnList and not F11mode then
--              if isEnabled(rtnList) then
--                  setIndex(rtnList,k)
                    IupSetInt(toolb_rtns,"VALUE",k)
--              end if
--          end if
        end if
    end if
end procedure
--*"/

integer srl_once = 1    -- (temp)
global procedure setRtnList()
    -- load the ComboDropDownList, rtnList and set the index
--  ?"setRtnList" --DEV
    IupSetAttribute(toolb_rtns,"REMOVEITEM","ALL")
    if currfile and sequence(routines[currfile]) then
        sequence rcn = routines[currfile][rtnNAMES]
        for i=1 to length(rcn) do
--          IupSetAttributeId(toolb_rtns, "", i, rcn[i])
--          string rcni = rcn[i]
--DEV (temp) [fix the bug in scanfor...]
            sequence rcni = rcn[i]
            if not string(rcni) then
                rcni = utf32_to_utf8(rcni)
                if srl_once then
                    srl_once = 0
                    ?"utf32, edix.exw line 984"
                end if
            end if
            IupSetAttributeId(toolb_rtns, "", i, rcni)
        end for
        IupSetInt(toolb_rtns,"VISIBLEITEMS",length(rcn)+1)  -- [no idea why it needs the +1]
        IupSetInt(toolb_rtns, "ACTIVE", 1)
        prevRtnIdx = 0
        setRtnIndex()
        IupRefresh(toolb_rtns)  -- (needed for "VISIBLEITEMS" to take effect)
    else
        IupSetInt(toolb_rtns, "ACTIVE", 0)
    end if
--/*
    if rtnList then
        deleteItem(rtnList,0)   -- empty list
        if currfile and sequence(routines[currfile]) then
--          void = insertItem(rtnList,routines[currfile][rtnNAMES],0)
            prevRtnIdx = 0
        end if
    end if
    setRtnIndex()
--*/
end procedure

global procedure paintCursorY()
integer line
--trace(1)
    line = distanceFromTopLine(CursorY,CursorX)+1
--?line
    if line>0 and line<=linesPerPage then
        if isWordWrapON and landingChunk then
            line = distanceFromTopLine(CursorY,0)+1
            if line<=0 then line = 1 end if
        end if
        if paintRqd then
            if paintRqd>line then
                paintRqd = line
            elsif paintLast!=0 and paintLast<line then
                paintLast = line
            end if
        else
            paintRqd = line
            paintLast = line
--?"edix line 531: startIdle(250)"
        end if
        IupUpdate(canvas)
    end if
end procedure

global procedure paintall()
-- Just set a flag and let idleHander do the work.
--?"paintall"
--  if not paintRqd then startIdle(250) end if
    IupUpdate(canvas)
    paintRqd = 1
    paintLast = 0
end procedure

--global 
procedure setMarginRqd()
-- sets marginRqd to 1 or 0.
-- Note that IdleHandler resets marginRqd = 1 to 
--  length(sprintf("%d",length(filetext[currfile])))
integer mr
sequence BookMarkSet
object bi
    mr = isLineNumbers or isFoldMarginPerm
    if not mr then
        BookMarkSet = bookmarks[currfile]
        for i=1 to length(BookMarkSet) do
            bi = BookMarkSet[i]
            if sequence(bi)
            and bi[bfType]!=WRAP then   -- not WRAP-only then
                mr = 1
                exit
            end if
        end for
    end if
    if (mr=0)!=(marginRqd=0) then
        marginRqd = mr
        paintall()
    end if
end procedure

--global 
integer lastFold = 0,
        lastFoldEnd = 0

procedure updateQJ(integer cY, integer adjust)--, integer fromwhere)
sequence BookMarkSet
object SetEntry
integer rStart, rEnd, thisStart, L
object thisEnd
integer BiT
    if sequence(routines[currfile]) then
        L = length(routines[currfile][rtnNAMES])
        for i=1 to L do
            rStart = routines[currfile][rtnSTART][i]
            if rStart>=cY then
                for j=length(routines[currfile][rtnNAMES]) to i by -1 do
                    rStart = routines[currfile][rtnSTART][j]
                    if adjust<0 and rStart<cY-adjust then
                        routines[currfile][rtnNAMES] = routines[currfile][rtnNAMES][1..j-1]&
                                                       routines[currfile][rtnNAMES][j+1..L]
                        routines[currfile][rtnSTART] = routines[currfile][rtnSTART][1..j-1]&
                                                       routines[currfile][rtnSTART][j+1..L]
                        routines[currfile][rtnEND] = routines[currfile][rtnEND][1..j-1]&
                                                     routines[currfile][rtnEND][j+1..L]
                        L -= 1
                        setRtnList()
                    else
                        routines[currfile][rtnSTART][j] = rStart+adjust
--DEV should not need this (length check), surely!
                        if length(routines[currfile][rtnEND]) then
                            rEnd = routines[currfile][rtnEND][j]
                            routines[currfile][rtnEND][j] = rEnd+adjust
                        end if
                    end if
                end for
                exit
--          elsif length(routines[currfile][rtnEND]) then   --DEV surely always?
            else
                rEnd = routines[currfile][rtnEND][i]
                if rEnd>cY then
                    routines[currfile][rtnEND][i] = rEnd+adjust
                end if
            end if
        end for
    end if

    if sequence(bCfwd) then
        L = length(bCfwd)
        for i=1 to L do
            rStart = bCfwd[i][1] -- bCfwd[i][1] is the line number
            if rStart>cY then
                --1: discard entries in [deleted] range
                while adjust<0 and rStart<cY-adjust do
                    bCfwd = bCfwd[1..i-1]&bCfwd[i+1..L]
                    L -= 1
                    if L<i then exit end if -- we trimmed rest of set
                    rStart = bCfwd[i][1]
                end while
                --2: apply adjust to remainder of set
                for j=i to L do
                    bCfwd[j][1] = bCfwd[j][1]+adjust
                end for
                exit
            end if
        end for
    end if
    BookMarkSet = bookmarks[currfile]
    bookmarks[currfile] = 0 -- reduce ref count
    --
    -- first, discard any bookmarks and folds lying within a deleted range
    --
    if adjust<0 then
        rStart = cY-1
        rEnd = rStart-adjust
        BookMarkSet = BookMarkSet[1..rStart+1]&BookMarkSet[rEnd+2..length(BookMarkSet)]
        --
        -- and the lastFold details if in range
        --
        if lastFold then
            if (lastFold>=rStart and lastFold<=rEnd)
            or (lastFoldEnd>=rStart and lastFoldEnd<=rEnd) then
                lastFold = 0
                ?"edix line 428: call_proc(r_enableMenuToolBar,{})"
            end if
        end if
    else -- adjust>0
        --  rStart = cY-1
        --  rEnd = rStart-adjust
        BookMarkSet = BookMarkSet[1..cY-1]&repeat(0,adjust)&BookMarkSet[cY..length(BookMarkSet)]
    end if
    for i=cY+1 to length(BookMarkSet) do
        SetEntry = BookMarkSet[i]
        if sequence(SetEntry) then
            thisStart = SetEntry[bfStart]
            thisEnd = SetEntry[bfEnd]
            BiT = SetEntry[bfType]
            SetEntry = {}
            BookMarkSet[i][bfStart] = thisStart+adjust
            if and_bits(BiT,FOLD) then
                BookMarkSet[i][bfEnd] = thisEnd+adjust
            end if
        end if
    end for
    bookmarks[currfile] = BookMarkSet
    setMarginRqd()
    --
    -- lastly, adjust the lastFold details, if any
    --
    if lastFold then
        if lastFold>=cY then
            lastFold += adjust
            lastFoldEnd += adjust
        elsif lastFoldEnd>=cY then  --DEV see "if rEnd>cY then" above...
            lastFoldEnd += adjust
        end if
    end if
end procedure

function adjustLine(integer lineno, integer adjust, integer cX)
-- 
-- lineno is 0-based, as per bookmarks, CursorY, and TopLine.
-- In fact the usual value passed as lineno is either CursorY or TopLine.
-- adjust is usually +1, -1, linesPerPage, or -linesPerPage.
-- cX is usually CursorX when lineno is CursorY, and TopChunk with TopLine.
--
-- Returns an integer in the range 0..length(filetext[currfile]) [NB over by 1] **DEV-1.
--
integer nextImportantLine, foldIdx, lenfiletxtcurrfile
integer getNIL
sequence BookMarkSet
object SetEntry
object BiE
integer FW
    BookMarkSet = bookmarks[currfile]
    lenfiletxtcurrfile = length(filetext[currfile]) ---1
    nacX = cX
    if isWordWrapON then
        FW = FOLD+WRAP
    else
        FW = FOLD
    end if
    if adjust>0 then
        while adjust>0 and lineno<lenfiletxtcurrfile do
            SetEntry = BookMarkSet[lineno+1]
            if sequence(SetEntry) then
                if and_bits(SetEntry[bfType],WRAP) and isWordWrapON then
                    BiE = SetEntry[bfEnd]
                    if selON!=2 then
                        if nacX<BiE[length(BiE)] then
                            for j=1 to length(BiE) do
                                if nacX<BiE[j] then
                                    nacX += BiE[j]
                                    if j>1 then
                                        nacX -= BiE[j-1]
                                    end if
                                    if j<length(BiE)
                                    and nacX>=BiE[j+1] then
                                        -- cursor down onto shorter line:
                                        nacX = BiE[j+1]-1
                                    end if
                                    exit
                                end if
                            end for
                        else
                            nacX -= BiE[length(BiE)]
                            lineno += 1
                        end if
                    else
                        adjust -= length(SetEntry[bfEnd])
                        lineno += 1
                    end if
                elsif and_bits(SetEntry[bfType],FOLD) then
                    lineno += SetEntry[bfEnd]-SetEntry[bfStart]+1
                else
                    lineno += 1
                end if
            else
                lineno += 1
            end if
            adjust -= 1
        end while

    elsif adjust<0 then
        -- since the array is sorted by start, and therefore not by end,
        -- when going back the full array must be scanned on each pass.
        getNIL = True
        while adjust<0 do
            if getNIL then
                nextImportantLine = -1
                for i=lineno+1 to 1 by -1 do
--maybe 10/7/16 (untested) [needed 14/11/17]
                    if i<=length(BookMarkSet) then
                        SetEntry = BookMarkSet[i]
                        if sequence(SetEntry) then
                            BiE = SetEntry[bfEnd]
                            if sequence(BiE) then
                                BiE = SetEntry[bfStart]
                            end if
                            if BiE<=lineno --+1
                            and BiE+1>nextImportantLine then
                                if and_bits(SetEntry[bfType],FOLD) then
                                    nextImportantLine = BiE+1
                                    foldIdx = i
                                elsif isWordWrapON and and_bits(SetEntry[bfType],WRAP) then
                                    nextImportantLine = BiE
                                    foldIdx = i
                                end if
                            end if
                        end if
                    end if
                end for
                getNIL = False
            end if
            if lineno=nextImportantLine then
                SetEntry = BookMarkSet[foldIdx]
                if and_bits(SetEntry[bfType],WRAP) then
                    if isWordWrapON then
                        BiE = SetEntry[bfEnd]
                        if selON!=2 then
                            if nacX>=BiE[1] then
                                for j=length(BiE) to 1 by -1 do
                                    if nacX>=BiE[j] then
                                        nacX -= BiE[j]
                                        if j>1 then
                                            nacX += BiE[j-1]
                                        end if
                                        if nacX>=BiE[j] then
                                            -- cursor up onto shorter line:
                                            nacX = BiE[j]-1
                                        end if
                                        exit
                                    end if
                                end for
                            else
                                if lineno=0 then exit end if
                                lineno -= 1
                                -- so force jump to lastChunk of prev line below:
                                nextImportantLine = -1
                            end if
                        else
--DEV this may need some more testing:
                            adjust += length(SetEntry[bfEnd])
                            if lineno=0 then exit end if
                            lineno -= 1
                        end if
                    else
                    -- skip any FOLD entries lying around:
                    -- (I think we normally get rid asap, but that may change)
                        if lineno=0 then exit end if
                        lineno -= 1
                    end if
                else
                        -- we're on the line immediately after a fold then:
                    lineno -= SetEntry[bfEnd]-SetEntry[bfStart]+1
                end if
                getNIL = True
--DEV not too sure about this "selON=2" here, but it seems to work so I am leaving it alone for now 
                if selON=2 or nextImportantLine=-1 then
                    nextImportantLine = -1
                    for i=lineno+1 to 1 by -1 do
                        SetEntry = BookMarkSet[i]
                        if sequence(SetEntry) then
                            BiE = SetEntry[bfEnd]
                            if sequence(BiE) then
                                BiE = SetEntry[bfStart]
                            end if
                            if BiE<=lineno
                            and BiE+1>nextImportantLine then
                                if and_bits(SetEntry[bfType],FOLD) then
                                    nextImportantLine = BiE+1
                                    foldIdx = i
                                elsif isWordWrapON and and_bits(SetEntry[bfType],WRAP) then
                                    nextImportantLine = BiE
                                    foldIdx = i
                                end if
                            end if
                        end if
                    end for
                    if selON!=2 and lineno=nextImportantLine
                    and and_bits(BookMarkSet[foldIdx][bfType],WRAP) then
                        SetEntry = BookMarkSet[foldIdx][bfEnd]
                        nacX += SetEntry[length(SetEntry)]
                    end if
                end if
            else
                if lineno=0 then exit end if
                lineno -= 1
                if selON!=2 and lineno=nextImportantLine
                and and_bits(BookMarkSet[foldIdx][bfType],WRAP) then
                    SetEntry = BookMarkSet[foldIdx][bfEnd]
                    nacX += SetEntry[length(SetEntry)]
                end if
            end if
            adjust += 1
        end while
    end if

    return lineno
end function

global procedure ensureVisible(integer eY, bool unfoldTop)
-- if eY is part of a fold, expand the fold, unless it
--  it is the first line and unfoldTop is False.
--  -- unfoldTop should be False for all use except fold
--     creation, which must avoid fold overlap.
sequence BookMarkSet
object SetEntry
integer bmI
    BookMarkSet = bookmarks[currfile]
    bookmarks[currfile] = 0 -- reduce ref count
    bmI = 1
    while bmI<=length(BookMarkSet) do
        SetEntry = BookMarkSet[bmI]
        if sequence(SetEntry) then
            if SetEntry[bfStart]>eY then exit end if
            if and_bits(SetEntry[bfType],FOLD)
            and SetEntry[bfEnd]>=eY
            and (unfoldTop or SetEntry[bfStart]!=eY) then
                if and_bits(SetEntry[bfType],MARK) then
                    BookMarkSet[bmI][bfType] = MARK -- leave the bookmark in place
                else                                -- else remove entry
                    BookMarkSet[bmI] = 0
                end if
                paintall()
            end if
        end if
        bmI += 1
    end while
    bookmarks[currfile] = BookMarkSet
    setMarginRqd()
end procedure

include builtins\timedate.e

--DEV/temp:
--function GetGuiResources()
--integer res
--  #ilASM{
--          mov [res],0
--      [PE32]
--          call "kernel32.dll","GetCurrentProcess"
--          push ebx                            -- DWORD uiFlags
--          push eax                            -- HANDLE hProcess
--          call "user32.dll","GetGuiResources"
--          mov [res],eax
--      []
--        }
--  return res
--end function

constant untitled = xl("[untitled]")

global -- for undo.e
constant SEL_COPY = 0,  SEL_DELETE = 1

integer cX -- for Clip()

forward procedure update_statusbar()

-- used by undo.e and eafind.ew:
global procedure forceCursorOnscreen()
integer d
    if not isWordWrapON then
--(26/3/10)
        if CursorX<Column then
--??    if CursorX<Column-marginRqd then
            Column = CursorX
            paintall()
        elsif CursorX>Column+charsWide-marginRqd then
--DEV (1/7/16): (charsWide is 0!) [undone 24/7]
            Column = CursorX-charsWide+marginRqd
            paintall()
        end if
    else
        if Column!=0 then
            Column = 0
            paintall()
        end if
    end if

    ensureVisible(CursorY,False)
    d = distanceFromTopLine(CursorY,CursorX)
--?d
    if d<0 or d>=linesPerPage then
        if d=linesPerPage then
--?1
            TopLine = adjustLine(TopLine,1,TopChunk)
            TopChunk = nacX
        elsif d=-1 then
-- BUGFIX: if on "while 1 do"; "a=1"; "end while" and TopLine=="end while", pressing
--     <Ctrl -> would create the Fold but leave TopLine=="a=1", & mangled display.
--      TopLine = adjustLine(TopLine,-1,TopChunk)
--      TopChunk = nacX
--?2
            TopLine = CursorY
            TopChunk = landingChunk
        else
            TopLine = 0   TopChunk = 0
            d = distanceFromTopLine(CursorY,CursorX)-floor(linesPerPage/4)
--?3
            TopLine = adjustLine(0,d,0)
            TopChunk = nacX
        end if
--?TopLine
        paintall()
    end if
    if selON then paintCursorY() end if
    update_statusbar()
end procedure

--with trace
global function getSelection(integer flag)
--
-- Returns the current selection, and deletes it if rqd.
-- returns 0 if no selection
-- Note: most calls to getSelection(SEL_DELETE) should be via
-- deleteSelection() which performs the required addAction.
-- This is used by UndoRedo() and thus cannot addAction() itself.
--
integer filelen, x1, x2
sequence oneline, twoline
sequence sel
object selend
--integer cX, cY, sX, sY
integer cY, sX, sY
    if not selON or (selX=CursorX and selY=CursorY) then return 0 end if
    filelen = length(filetext[currfile])
--5/5/18:
    if selY>=filelen then return 0 end if
--#without reformat
    --
    -- First make cX/Y top left & sX/Y lower right
    --
    if selON=2 then -- column mode
        if selX<CursorX then cX=selX sX=CursorX else cX=CursorX sX=selX end if
        if selY<CursorY then cY=selY sY=CursorY else cY=CursorY sY=selY end if
    elsif selY<CursorY or (selY=CursorY and selX<CursorX) then          --flip
                             cX=selX sX=CursorX
                             cY=selY sY=CursorY
    else                                                                --asis
                                                     cX=CursorX sX=selX
                                                     cY=CursorY sY=selY
    end if
--#with reformat

    oneline = filetext[currfile][cY+1]
    x1 = MapToByte(oneline,cX)
    if sY=cY or selON=2 then        -- single line/column Mode
        x2 = MapToByte(oneline,sX)
        if x1 then
            if x2 then
                sel = {oneline[x1..x2-1]}
                if flag=SEL_DELETE then
                    oneline = oneline[1..x1-1]&oneline[x2..length(oneline)]
                end if
            else
                sel = {oneline[x1..length(oneline)]}
                if flag=SEL_DELETE then
                    oneline = oneline[1..x1-1]
                end if
            end if
        else
            if x2 then
                sel = {oneline[1..x2-1]}
                if flag=SEL_DELETE then
                    oneline = oneline[x2..length(oneline)]
                end if
            else
--DEV should that be {""}??
                sel = {{}}
            end if
        end if
    else                    -- multi line
        twoline = filetext[currfile][sY+1]
        x2 = MapToByte(twoline,sX)
        selend = {}
        if x1 then
            sel = {oneline[x1..length(oneline)]}
            if x2 then
                if flag=SEL_DELETE then
                    oneline = oneline[1..x1-1]&twoline[x2..length(twoline)]
                end if
                selend = twoline[1..x2-1]
            else
                if flag=SEL_DELETE then
                    oneline = oneline[1..x1-1]
                end if
                selend = twoline
            end if
        else
--DEV should that be {""}??
            sel = {{}}
            if x2 then
                selend = twoline[1..x2-1]
                if flag=SEL_DELETE then
                    oneline &= twoline[x2..length(twoline)]
                end if
            else
                selend = twoline
            end if
        end if
        for i=cY+2 to sY do
            sel = append(sel,filetext[currfile][i])
        end for
        if flag=SEL_DELETE then
            removeLineLengths(cY+2,sY+1)
            updateQJ(cY+1,cY-sY)--,1)
            filetext[currfile] = filetext[currfile][1..cY+1]&
                                 filetext[currfile][sY+2..filelen]
            if length(bookmarks[currfile])!=length(filetext[currfile]) then ?92/(1-isDebug) end if
        end if
        if not atom(selend) then
            sel = append(sel,selend)
        end if
    end if
    --
    -- if deleting, move cursor to cX,cY (top left), and remove
    -- the selection and any highlighting.
    -- 
    if flag=SEL_DELETE then
        replaceLine(cY+1,oneline)
    end if
    if selON=2 then
        for i=cY+1 to sY do -- any remaining lines in column mode
            oneline = filetext[currfile][i+1]
            x1 = MapToByte(oneline,cX)
            x2 = MapToByte(oneline,sX)
            if x1 then
                if x2 then
                    selend = oneline[x1..x2-1]
                    if flag=SEL_DELETE then
                        oneline = oneline[1..x1-1]&oneline[x2..length(oneline)]
                    end if
                else
                    selend = oneline[x1..length(oneline)]
                    if flag=SEL_DELETE then
                        oneline = oneline[1..x1-1]
                    end if
                end if
            else
                if x2 then
                    selend = oneline[1..x2-1]
                    if flag=SEL_DELETE then
                        oneline = oneline[x2..length(oneline)]
                    end if
                else
                    selend = {}
                end if
            end if
            sel = append(sel,selend)
            if flag=SEL_DELETE then
                replaceLine(i+1,oneline)
            end if
        end for
    end if
    if flag=SEL_DELETE then
--?"getSelection"
        CursorX = cX
        CursorY = cY
        selON = 0
        forceCursorOnscreen()
        if cY=sY then
            paintCursorY()
        else
            paintall()
        end if
    end if
    return sel
end function

forward global procedure add_tab(integer opening, string path="", string title=untitled, sequence text={}, sequence linelengths={}, integer encoding=ENC_NONE)
forward global function openFile(integer opening, string filepath, integer encoding)
forward global procedure restcursel()
forward global procedure appUpdateRender()
forward global procedure save_extensions()

include src/ini.e
include src/ext.e as extns
include src/find.e as fdlg

include src/eaedb.e
include src/dir.e   -- DEV xExtractAssociatedIcon, getBackupSet
include src/qj.e    -- currProjFileSet("")

procedure update_statusbar()
integer k
--26/9/18...
--  if currfile then
    if currfile and currfile<=length(filetext) then
        IupSetStrAttribute(sbline,"TITLE","Line %d of %d, Column %d",{CursorY+1,length(filetext[currfile]),CursorX+1})
        string imode = iff(insertMode?"INS":"OVR")
        string chstr = "   "
        unicodeflag = unicodefile[currfile]
        if CursorY<length(filetext[currfile]) then
--          string oneline = filetext[currfile][CursorY+1]
            sequence oneline = filetext[currfile][CursorY+1]
            k = MapToByte(oneline,CursorX)
            if k then
                chstr = sprintf(iff(unicodeflag=ANSI?"#%02x":"#%04x"),oneline[k])
            end if
        end if
        k = unicodeflag+(unicodeflag<3)
        string fmode = {"ANSI ","UTF-8 ","UTF-16"}[k]
--DEV (temp)
        IupSetStrAttribute(sbinfo,"TITLE","%s  %s  %s",{fmode,imode,chstr})
--      IupSetStrAttribute(sbinfo,"TITLE","%s(%d)  %s  %s",{fmode,unicodeflag,imode,chstr})
--DEV[?]
--/!*
--              if atom(routines[currfile]) and isEu 
                if atom(routines[currfile]) 
                and match(untitled,filenames[currfile])!=1 then
--                  setText(SB6,"rebuilding routine list")
                    IupSetAttribute(sbmsg,"TITLE","rebuilding routine list")
                    setListOfAllRoutines(currfile,filetext[currfile],2,filenames[currfile])
                    --      setRtnIndex()   -- added 17/05 (no help!)
--                  setText(SB6,"")
                    IupSetAttribute(sbmsg,"TITLE","")
                end if
--*!/
--17/11/17: (definately helps!)
        setRtnIndex()
    else
        IupSetAttribute(sbline,"TITLE","")
        IupSetAttribute(sbinfo,"TITLE","")
    end if
    string datestr = format_timedate(date(),"dd Mmmm yyyy hh:mmpm")
    IupSetStrAttribute(sbdate,"TITLE",datestr)
--DEV/temp:
--  if sbtemp!=NULL and platform()=WINDOWS then
--      IupSetStrAttribute(sbtemp,"TITLE","%d",{GetGuiResources()})
--  end if
end procedure

atom cb_update_time
function update_time_cb(Ihandle time_update)
    update_statusbar()
    if IupGetInt(time_update,"TIME")!=60000 then
        -- (timer is initially created with (60-date()[DT_SECONDS])*1000,
        --  so it updates precisely on the next minute. So first time in,
        --  [and only once] recreate the timer with a 60 second period -
        --  I did try IupSetInt(time_update,"TIME",60000), but no joy.
        {} = IupDestroy(time_update)
        time_update = IupTimer(cb_update_time,60000,true)
    end if
    return IUP_DEFAULT
end function
cb_update_time = Icallback("update_time_cb")

--DEV not currently needed to be global
global procedure jumpTo(integer newX, integer newY)
--  paintCursorY()              -- remove old currentline highlight
--?"jumpTo"
    CursorX = newX
    CursorY = newY
--  ensureVisible(CursorY,      -- remove folds if required,
--                False)        -- but don't unfold top line.
    forceCursorOnscreen()
    paintCursorY()              -- set new currentline highlight.
end procedure

global procedure paintLines(integer linefrom, integer lineto)
--
-- Paint all lines between linefrom and lineto inclusive.
-- Handles linefrom > lineto properly (ie backward selections).
-- Allows block ops for large selections, partly or even completely off-screen.
--
    linefrom = curb(0,distanceFromTopLine(linefrom,0),linesPerPage)+1
    lineto = curb(0,distanceFromTopLine(lineto,0),linesPerPage)+1
    if paintRqd then
        paintRqd = min(paintRqd,min(linefrom,lineto))
        if paintLast then
            paintLast = max(paintLast,max(linefrom,lineto))
        end if
    else
        paintRqd = min(linefrom,lineto)
        paintLast = max(linefrom,lineto)
--?"edix: paintLines line 1117: startIdle(250)"
    end if
    IupUpdate(canvas)
end procedure

global procedure clearSelection()
--
-- Clear the highlit text
--
    if selON then
        if selY>TopLine     -- selection starts on screen
        and selY<=CursorY then  -- and a forward selection, therefore not off end of screen
            paintLines(selY,CursorY)
        else
            -- just repaint the lot if it might be running off 
            -- either the top or the bottom of the screen.
            paintall()
        end if
        selON = 0
    end if
end procedure

--DEV not yet set properly?
integer mouseDown
        mouseDown = 0

procedure startSelection(integer shift, integer alt)
integer newSelON
    if shift or mouseDown then
        --
        -- Set anchor at current cursor position
        --
        newSelON = 1+alt
        if not selON then
            selON = newSelON
            selY = CursorY
            selX = CursorX
        end if
        if selON!=newSelON then
            paintLines(selY,CursorY)
            selON = newSelON
        end if
    elsif selON then
        clearSelection()
    end if
end procedure

procedure checkCursorX()
-- called whenever CursorY changes.
    if selON!=2 then
        CursorX = CursorLeft(filetext[currfile][CursorY+1],CursorX+1)
--      string oneline = ConvertTabs(filetext[currfile][CursorY+1],8,isTabWidth)
--      CursorX = CursorLeft(oneline,CursorX+1)
    end if
    forceCursorOnscreen()
end procedure

function get_image(string image)
-- image should be IUP_xxx to use an image from the stock library (see IupImageLibOpen), [DEV no more]
--              or PNG_xxx to use an image from the icons subdirectory (icons/xxx.png).
--DEV see http://www.iconarchive.com/search?q=go&page=11
nullable_string res

    if length(image)=0 then
        res = NULL
    elsif image[1]='I' then -- (should be enough)
        res = image         -- stock image (see IupImageLibOpen)
    elsif platform()=WINDOWS
      and IupGetHandle(image)!=NULL then    -- (already loaded)
        res = image
    else
        string path = join_path({initialcurrentdir,"icons",image[5..$]&".png"})
        if platform()=WINDOWS then

            -- use IM library to load image
            Ihandln handle = IupLoadImage(path)
            if handle=NULL then
                res = NULL
            else
                -- store the image handle
                IupSetHandle(image, handle)
                return image
            end if
        else -- LINUX
            -- natively supports PNG images
            res = path
        end if
    end if
    return res
end function

--constant isCurrWhite = 0  --DEV (scrambles display when opening a new tab, sometimes)

--DEV reconsider these parameters: (tabfile-1 might work!!) [see also "DEV/SUG: (untried)" below]
global procedure setSaveIcon(integer pos=-1, Ihandln tab=NULL)--integer c, integer doMenu, integer doEvents0) -- also used by undo.e
    if pos=-1 then
        tab = IupGetAttributeHandle(tabs, "VALUE")
        pos = IupGetInt(tabs,"VALUEPOS")
--DEV/SUG: (untried)
--  elsif tab=NULL then
--      tab = IupGetChild(tabs, pos)
    end if
    if tab!=NULL then
        integer fidx = IupGetInt(tab,"FILEIDX")
--      if pos=-1 then
--          pos = IupGetInt(tabs,"VALUEPOS")
--      end if
        integer modified = (actionsave[fidx]!=actionptr[fidx])
        string tabimage = iff(modified?"PNG_FileSave":"PNG_FileSaved")
--DEV more complicated than this... (nb FileActive.png not yet in 7z.lst)
--      string tabimage = iff(modified?"PNG_FileSave":
--                        iff(fidx=currfile?"PNG_FileActive":"PNG_FileSaved"))
        IupSetAttributeId(tabs, "TABIMAGE", pos, get_image(tabimage))
    end if
end procedure

--DEV: (changeTo)
--integer isCurrLineColoured    -- set to (ColourTab[HighLine]!=ColourTab[Background]) on Tab switch.
integer isCurrLineColoured = 0  -- set to (ColourTab[HighLine]!=ColourTab[Background]) on Tab switch.

--DEV not yet used...
global integer rCompareTarget
               rCompareTarget = 0

sequence backdirs  = {},
         backrev   = {},
         backrevd  = {},
         backpurge = {}

constant threemonthsago = adjust_timedate(date(),timedelta(weeks:=-12))

--with trace
function revision_number(string s, integer firstdigit)
integer revision = 0
    for i=firstdigit to firstdigit+3 do
        integer ch = s[i]
        if ch<'0' or ch>'9' then return 0 end if
        revision = revision*10 + ch-'0'
    end for
    return revision
end function

procedure put_unicode_string(integer fn, sequence s)
integer l
--integer lastch
integer lowch, highch
--integer nLen
--atom pInBuff, pOutBuff
    l = length(s)
    if unicodeflag=UTF8 then
--DEV..
--      pInBuff = allocate(l*2)
--      poke2(pInBuff,s)
--      nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,NULL,0,NULL,NULL})
--      pOutBuff = allocate(nLen)
--      nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,pOutBuff,nLen,NULL,NULL})
--      puts(fn,peek({pOutBuff,nLen}))
--      free(pOutBuff)
--      free(pInBuff)
        puts(fn,s)
        puts(fn,"\r\n")
    elsif unicodeflag=UTF16LE then
--DEV poke2(addr,s)/peek({addr,l*2}) might be faster...
        for i=1 to l do
            highch = s[i]
            lowch = and_bits(highch,#FF)
            highch = floor(highch/#100)
            puts(fn,lowch)
            puts(fn,highch)
        end for
--/**/  puts(fn,"\r\0\n\0")
--/*
        puts(fn,{'\r',0,'\n',0})
--*/
    elsif unicodeflag=UTF16BE then
        for i=1 to l do
            highch = s[i]
            lowch = and_bits(highch,#FF)
            highch = floor(highch/#100)
            puts(fn,highch)
            puts(fn,lowch)
        end for
--/**/  puts(fn,"\0\r\0\n")
--/*
        puts(fn,{0,'\r',0,'\n'})
--*/
    else
        ?9/0
    end if
end procedure

procedure savecursel()
--printf(1,"savecursel(%d)\n",currfile)
    if currfile then
        filecursel[currfile] = {CursorX,CursorY,TopLine,Column,selON,selX,selY,
--                              lastFold,lastFoldEnd,TopChunk}--,isWordWrapON,isFTP}
                                lastFold,lastFoldEnd,TopChunk,0}--,isWordWrapON,isFTP}
        bCfwds[currfile] = bCfwd
    end if
end procedure

global
procedure restcursel()
sequence cursel
--DEV
--  if currfile then
    if currfile and currfile<=length(filecursel) then
        cursel = filecursel[currfile]
        {CursorX,CursorY,TopLine,Column,selON,selX,selY,
         lastFold,lastFoldEnd,TopChunk} = cursel
        -- erm, 15/11/17 (then decided to add the warning as well):
--      CursorY = min(length(filetext[currfile])-1,CursorY)
        integer maxcY = length(filetext[currfile])-1
        if CursorY>maxcY then
            CursorY = maxcY
            ?"warning: CursorY reset (edix.exw line 1910)"
        end if
--      CursorX     = cursel[1]
--      CursorY     = cursel[2]
--      TopLine     = cursel[3]
--      Column      = cursel[4]
--      selON       = cursel[5]
--      selX        = cursel[6]
--      selY        = cursel[7]
--      lastFold    = cursel[8]
--      lastFoldEnd = cursel[9]
--      TopChunk    = cursel[10]
--      UnVisited   = cursel[11] (Session Management)
        -- Note that cursel may have come from a pre-0.2.9 edita.ini:
--      if length(cursel)>=11 then
--          isWordWrapON = cursel[11]
--      else
--          isWordWrapON = False
--      end if
--      if length(cursel)>=12 then
--          isFTP = cursel[12]
--      else
--          isFTP = 0
--      end if
        bCfwd = bCfwds[currfile]
    end if
--DEV... (8/8/16 cannot think why this would help)
if 0 then
    colourTabs[newSyntax] = ColourTab
    styleTabs[newSyntax] = StyleTab
end if
--  charMaps[newSyntax] = charMap -- removed 17/7/(05?)
end procedure

procedure setMainText()
string name = filenames[currfile]
    if match(untitled,name)=1 then
        -- the "actual" name may be eg "[untitled].exw" for syntax colouring reasons,
        -- but always just show it as "[untitled]" on-screen.
        name = untitled
    end if
--  if isShowFullPath then
        name = filepaths[currfile]&name
--  end if
--  setText(Main, Edita & " - " & name)
    IupSetAttribute(dlg,"TITLE","Edix" & " - " & name)
end procedure

Ihandle toolb_new
Ihandle toolb_open
Ihandle toolb_save
Ihandle toolb_close
Ihandle toolb_prntp
Ihandle toolb_print
Ihandle toolb_cut
Ihandle toolb_copy
Ihandle toolb_paste
Ihandle toolb_undo
Ihandle toolb_redo
Ihandle toolb_find
Ihandle toolb_fnxt
Ihandle toolb_fprv
Ihandle toolb_zoomin
Ihandle toolb_zoomout
Ihandle toolb_back
Ihandle toolb_run

--DEV extension handling....
--sequence runnables = {"ex","exu","exw","exwc","htm","html","bat"}

procedure update_toolbar()
--  integer modified = (actionsave[fidx]!=actionptr[fidx])
--  string tabimage = iff(modified?"PNG_FileSave":"PNG_FileNew")
--  IupSetAttributeId(tabs, "TABIMAGE", pos, get_image(tabimage))
--DEV
    if currfile>length(actionsave) then
        ?"update_toolbar line 2027"
        return
    end if
    IupSetInt(toolb_save,"ACTIVE",currfile and actionsave[currfile]!=actionptr[currfile])
    integer sel = (currfile and selON and (selX!=CursorX or selY!=CursorY))
    IupSetInt({toolb_cut,toolb_copy},"ACTIVE",sel)
--  integer isclip = length(IupGetAttribute(clipboard,"TEXT"))!=0
    integer isclip = IupGetInt(clipboard, "TEXTAVAILABLE")
    IupSetInt(toolb_paste,"ACTIVE",currfile and isclip)
    IupSetInt(toolb_undo,"ACTIVE",currfile and (actionptr[currfile]>0))
    IupSetInt(toolb_redo,"ACTIVE",currfile and (actionptr[currfile]<length(actions[currfile])))
    IupSetInt({toolb_close,toolb_find},"ACTIVE",currfile!=0)
    IupSetInt({toolb_fnxt,toolb_fprv},"ACTIVE",currfile!=0 and fdlg:find_active())
    IupSetInt({toolb_prntp,toolb_print},"ACTIVE",currfile!=0)
    IupSetInt({toolb_zoomin,toolb_zoomout},"ACTIVE",currfile!=0)
    integer runnable = 0
    if currfile then
        string ext = get_file_extension(filenames[currfile])
--      runnable = find(ext,runnables)!=0
--DEV
--      runnable = find(ext,runnables) or getExtRunWith(ext)
        runnable = getExtRunWith(ext)!=""
    end if
    IupSetInt(toolb_run,"ACTIVE",runnable)
--  s = TB_off
--  if currfile then
--      ext = getFileExtension(filenames[currfile])
--      if find(ext,{"ex","exu","exw","exwc","htm","html","bat"})
--      or length(getExtRunWith(ext)) then
--          s = TB_on
--      end if
--  end if
--  setTBstatus(T_Run,s)
end procedure

--DEV change to filedt:
----Purpose: to force reload of *.err if it has been externally changed.
--sequence opensize -- save of dir() info (F12 only)
--       opensize = {} -- also updated by saveFile

include src/macro.e as macro

--global 
function saveFile(bool warnBackup=true)
-- the parameter should be 1, unless there is some special reason
-- why a backup might not be possible (eg save as, new file)
-- [should be invoked as saveFile(), or saveFile(warnBackup:=false)]
integer c
string filename
object d
--integer dt2
--sequence dt
string backname, backdir
integer fn
sequence name
sequence ftxt
integer f
integer k
integer revision
--integer wasTabWidth
--sequence oneline
    StopMacroLearn(1)
    if currfile then
        if tabfile then
            c = tabfile
            tabfile = 0
        else
            c = currfile
        end if
        filename = filenames[c]
        if match(untitled,filename)!=1 then
--          if isAutoBackup and not find(filename,{"ex.err","list.asm","ildump.txt"}) then
            if not find(filename,{"ex.err","list.asm","ildump.txt"}) then
--DEV somewhere else...
-- 1) once per session scans
                backdir = filepaths[c]&`backup\`
--              k = find(backdir,backdirs)
                k = find(backdir,filepaths[c])
                if k=0 then
-- trace(1)
                    revision = 0
                    d = dir(backdir)
                    if atom(d) then
--                      if not createDirectory(backdir) then
                        if not create_directory(backdir,make_parent:=0) then
--                          void = messageBox(xl("Unable to create backup directory"),backdir,0)
                            IupMessage(xl("Unable to create backup directory"),backdir)
                            return 0
                        end if
--                      d = {}
                    else
                        for i=1 to length(d) do
                            if not find('d',d[i][D_ATTRIBUTES]) then
                                backname = d[i][D_NAME]
                                for j=length(backname) to 1 by -1 do
                                    if backname[j]='.' then
                                        if j>=7 and backname[j-5]='.' then
                                            revision = max(revision,revision_number(backname,j-4))
                                        end if
--DEV exit? (spotted in passing)
                                    end if
                                end for
                            end if
                        end for
                    end if
--                  backdirs = append(backdirs,backdir)
                    backdirs = append(backdirs,filepaths[c])
                    backrev = append(backrev,revision)
                    backrevd = append(backrevd,-1)
                    backpurge = append(backpurge,0)
                    k = length(backdirs)
                else
                    revision = backrev[k]
                end if
                revision += 1
                if revision>9999 then
                    revision = backrevd[k]
                    if revision=-1 then
                        revision = 0
--DEV will this work on linux??
                        d = dir(filepaths[c]&"backup.????")
                        if sequence(d) then
                            for i=1 to length(d) do
                                if find('d',d[i][D_ATTRIBUTES]) then
                                    backname = d[i][D_NAME]
                                    if length(backname)=11
                                    and backname[1..7]="backup." then
                                        revision = max(revision,revision_number(backname,8))
                                        if d[i][D_YEAR..D_MONTH]<=threemonthsago then
                                            backpurge[k] = 1
                                        end if
                                    end if
                                end if
                            end for
                        end if
                    end if
                    revision += 1
                    string backdirN = sprintf("%sbackup.%04d",{filepaths[c],revision})
                    if not rename_file(backdir, backdirN) then
                        IupMessage(xl("Unable to rename backup directory"),backdir)
                        return 0
                    end if
                    if not create_directory(backdir,make_parent:=0) then
--                      void = messageBox(xl("Unable to create backup directory"),backdir,0)
                        IupMessage(xl("Unable to create backup directory"),backdir)
                        return 0
                    end if
                    if revision>=9999 then
                        IupMessage(xl("Warning"),backdir&" just created.\n\nTime for a bit of cleanup.")
                    end if
                    backrevd[k] = revision
                    revision = 1
                end if
                backrev[k] = revision
--              backname = sprintf(`backup\%s.%04d.%s`,{filebase(filename),revision,fileext(filename)})
                backname = join_path({"backup",sprintf("%s.%04d.%s",{filebase(filename),revision,fileext(filename)})})
                string src = filepaths[c]&filenames[c]
                if not file_exists(src)
                or not copy_file(src, filepaths[c]&backname, 0) then
--                          logBackup(dt2,filepaths[c],filenames[c])
                    if warnBackup then
--                      void = messageBox(xl("Error"),xl("Unable to create backup"),0)
--?{filepaths[c]&filenames[c], filepaths[c]&backname}
                        IupMessage(xl("Error"),xl("Unable to create backup"))
                    end if
                end if
            end if
            --
            -- now save the file...
            --
            name = filepaths[c]&filenames[c]
--DEV
--          setIsEu(name)

            ftxt = filetext[c]
--DEV (untested, more cases to consider...)
--      for i=1 to length(ftxt) do
--          ftxt[i] = UnPackTabs(ftxt[i])
--      end for
--      els
--24/1/07: Ding! if isTabWidth!=8 then always store as spaces!
--      if (isEu and (isReplaceTabs or Xtrans)) or isTabWidth!=8 then

--      if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
--          if isReplaceTabs then -- now always on...
                for i=1 to length(ftxt) do
                    ftxt[i] = ConvertTabs(ftxt[i],isTabWidth,0)
                end for
--          elsif isTabWidth!=8 or (isEu and Xtrans) then
--              for i=1 to length(ftxt) do
----                    ftxt[i] = UnPackTabs(ftxt[i])
--                  ftxt[i] = ConvertTabs(ftxt[i],isTabWidth,8)
--              end for
--          end if

            unicodeflag = unicodefile[c]
--if unicodeflag<ANSI then ?9/0 end if
            if unicodeflag=ANSI then
                fn = open(name,"w")
            else
                fn = open(name,"wb")
            end if
            if fn=-1 then
--              void = messageBox(xl("Error"),xl("Unable to save ")&name,0)
                IupMessage(xl("Error"),xl("Unable to save ")&name)
                return 0
            end if

            if unicodeflag=ANSI then
                for i=1 to length(ftxt) do
                    puts(fn,ftxt[i])
                    puts(fn,'\n')
                end for
            else
                -- write a BOM (Byte Order Mark)
                if unicodeflag=UTF8 then
--if get_file_extension(filename)!="p6" then
                    puts(fn,{#EF,#BB,#BF})
--end if
                elsif unicodeflag=UTF16LE then
                    puts(fn,{#FF,#FE})
                elsif unicodeflag=UTF16BE then
                    puts(fn,{#FE,#FF})
                else
-- 3/6/14
--                  ?9/0
-- 7/6/14
                    close(fn)
--                  void = messageBox(sprintf("unicode flag is %d - reset to ANSI, file not saved",unicodeflag),"oops",0)
                    IupMessage("oops",sprintf("unicode flag is %d - reset to ANSI, file not saved",unicodeflag))
                    unicodeflag = ANSI
                    return 0
                end if
--trace(1)
                for i=1 to length(ftxt) do
                    put_unicode_string(fn,ftxt[i])
                end for
            end if

            close(fn)

--DEV (31/7/16):
--          updateRecoveryTree = 1

--          if c>length(opensize) then
--              opensize &= repeat(0,c-length(opensize))
--          end if
--          opensize[c] = dir(name)
--          --DEV:
            filedt[c] = dir(name)

--DEV (31/7/16):
--          runBack = 1

            f = logFile(filepaths[c],filenames[c],0)
            actionsave[c] = actionptr[c]
--          if needsFTPing(f) then  -- check edita.edb flags [as set by markAsFTP() below]
--              call_proc(r_FTPupload,{filepaths[c]&filenames[c]})
--          end if
            savecursel()

--DEV:
if c!=currfile then ?9/0 end if
--          setSaveIcon(c,1,1)
            setSaveIcon()
--DEV/SUG: (untried, but it might work!)
--          setSaveIcon(tabfile-1)

            if equal(filenames[c],"edix.ini") then
                ?"edix.exw: saveFile() line 2308"
--              loadIniFile(??)
                loadINI()
                iniSetPrev({}, currfile)
                iniCreateTabs() -- (just the reload ext parts)
            elsif equal(filenames[c],"edix.cfg") then
--              iniHandModded = 1
                if IupConfigLoad(config)!=0 then
                    IupMessage(xl("Warning"),xl("IupConfigLoad failed"))
else
 ?"IupConfig succeeded!"
                end if
            else
                -- if we save a .syn file, reload them all.
                k = length(filenames[c])
                if k>4 then
                    k = find(filenames[c][k-3..k],{".syn",".txt"})
                    if k=1 then
--?"setText(SB6(->sbmsg).."
--                      setText(SB6(->sbmsg),"Reloading Syntax Files")
                        IupSetAttribute(sbmsg,"TITLE","Reloading Syntax Files")
                        initSyn()
--                      setText(SB6(->sbmsg),"")
                        IupSetAttribute(sbmsg,"TITLE","")
--DEV usegpp (kill LowerCase, not that using it here should matter)
--DEV Bugfix 3/6/7: There may be many similar cases...
                    elsif k=2 and equal(filepaths[c],initialcurrentdir&`help\`) then
--                  elsif k=2 and equal(lower(filepaths[c]),
--                                      lower(initialcurrentdir&`help\`)) then
--                      setText(SB6(->sbmsg),"Reloading Help Control Files")
                        IupSetAttribute(sbmsg,"TITLE","Reloading Help Control Files")
                        initHlp()
--                      call_proc(r_toggleMenus,{})
--                      call_proc(r_toggleMenus,{})
--                      setText(SB6(->sbmsg),"")
                        IupSetAttribute(sbmsg,"TITLE","")
                    end if
                end if
            end if
        end if
    end if
    if isAutoSaveTimer then
--?"AutoSaveTimer"
--      stopTimer(AutoSaveTimer)
--      startTimer(AutoSaveTimer,Main,isAutoSaveTimer*1000)
        IupSetInt(autosavetimer,"RUN",FALSE)
        IupSetInt(autosavetimer,"RUN",TRUE)
    end if
    update_toolbar()
    return 1
end function

procedure savecurr()
    StopMacroLearn(1)
--DEV
--  if currfile then
    if currfile and currfile<=length(filenames) then
        if actionsave[currfile]!=actionptr[currfile]
        and match(untitled,filenames[currfile])!=1 then
--DEV
--      void = saveFile(warnBackup:=true)
--?{"saveFile",currfile}
--trace(1)
            {} = saveFile()
--          setSaveIcon()   -- [just done]
        end if
        savecursel()
    end if
end procedure

--without trace
--with trace

--used by htmlise.e:
global procedure changeTo(integer i, integer npos)
-- switch to the specified file
--sequence fileExt
--integer lenExt
--integer prevfile
--DEV
    if i>length(filenames) then
        ?{"changeTo line 2363",i}
        return
    end if

    if and_bits(isClearOverStrike,cOVRfile) then
        insertMode = 1
    end if
--  changeToF11Rqd = 1

    if rCompareTarget then
        -- if compare open, set target and quit.
        if call_func(rCompareTarget,{i}) then return end if
    end if
--  if isAutoSaveOnTabSwitch and currfile
    savecurr()

--  if r_enableMenuToolBar and isCurrWhite then
--      prevfile = currfile
--      currfile = i
--      if prevfile then
--          setSaveIcon(prevfile,0,0)
--      end if
--      setSaveIcon(currfile,0,1)
--  else
        currfile = i
--  end if
    restcursel()
--?"restcursel"
--  newSyntax = 1 -- default
--DEV common code:
--  fileExt = filenames[currfile] 
--  lenExt = length(fileExt)
--  for l = lenExt to 1 by -1 do
--      if fileExt[l]='.' then
--          newSyntax = find(LowerCase(fileExt[l+1..lenExt]),Extensions)
            newSyntax = find(get_file_extension(filenames[currfile]),Extensions)
            if newSyntax then
                newSyntax = ExtensionNos[newSyntax]
            else
                newSyntax = 1
            end if
--          exit
--      end if
--  end for 

--DEV:
--  setIsEu(filepaths[currfile]&filenames[currfile])
--DEV rename as ColourTbl!
    ColourTab = colourTabs[newSyntax]
    isCurrLineColoured = (ColourTab[HighLine]!=ColourTab[Background])
--DEV??
--  sampleBrushClr = reBrush(sampleBrushClr,ColourTab)
    StyleTab = styleTabs[newSyntax]
    charMap = charMaps[newSyntax]   -- fixed hang 17/7
--  comment = LineComments[newSyntax]       -- moved here 19/7
    lineComments = LineComments[newSyntax]      -- moved here 19/7
    blockComment = BlockComments[newSyntax]
    autoComplete = AutoCompletes[newSyntax]

    setMarginRqd()
    forceCursorOnscreen()   --DEV??
    paintall()

    setMainText()
    update_toolbar()
--?"setMainText"

--  if isTabBarVIS then
--      if rRebuildTabBar and isSingleDir then
--          call_proc(rRebuildTabBar,{})
--      end if
--      setFocus(tabs[currfile])
--  end if
--?"setFocus"
    if npos!=-1 then
        IupSetInt(tabs,"VALUEPOS",npos)
    end if
    IupSetFocus(canvas)

    checkProj = 1
    if sequence(routines[currfile]) then
        setRtnList()
    end if
end procedure

function findtab(integer c, bool return_handle=false)
    for pos=0 to IupGetInt(tabs,"COUNT")-1 do
        Ihandle tab = IupGetChild(tabs, pos)
        if IupGetInt(tab,"FILEIDX")=c then
            if return_handle then
                return tab
            else
                return pos
            end if
        end if
    end for
    return 9/0
end function

function buildFileFilter2()
-- Build a file filter from the extension info loaded from the syntax files
-- Give priority to the current syntax/extension set by placing in slot 2
sequence res
integer k
sequence stardot
    res = {{xl("All Files"), "*.*"}}
    if newSyntax then
        res = append(res,{SynNames[newSyntax]&xl(" files"),""})
    end if
    for i=2 to length(SynNames) do
        if i!=newSyntax then
            res = append(res,{SynNames[i]&xl(" files"),""})
            k = length(res)
        else
            k = 2
        end if
        stardot = "*."
        for j=1 to length(Extensions) do
            if ExtensionNos[j]=i then
                res[k][2] &= stardot & Extensions[j]
                stardot = ";*."
            end if
        end for
        res[k][1] &= " (" & res[k][2] & ")"
    end for
    return res
end function

function move_last_to_vacated_spot(sequence s, integer idx)
    s[idx] = s[$]
    s = s[1..$-1]
    return s
end function

procedure removelast(integer delidx)
    integer fidx = length(filenames)
if fidx=0 then ?"removelast0?!" end if
    for pos=0 to IupGetInt(tabs,"COUNT")-1 do
        Ihandle mtab = IupGetChild(tabs, pos)
        if IupGetInt(mtab,"FILEIDX")=fidx then
--12/12/20:
--          if delidx!=fidx then
--("",untried)
--          if delidx=fidx then
--              filenames       = filenames[1..$-1]
--              filepaths       = filepaths[1..$-1]
--              filetext        = filetext[1..$-1]
--              unicodefile     = unicodefile[1..$-1]
--              actionptr       = actionptr[1..$-1]
--              actions         = actions[1..$-1]
--              actionsave      = actionsave[1..$-1]
--              bookmarks       = bookmarks[1..$-1]
--              filelinelengths = filelinelengths[1..$-1]
--              routines        = routines[1..$-1]
--              filedt          = filedt[1..$-1]
--              bCfwds          = bCfwds[1..$-1]
--          else
                -- move high FILEIDX into the just vacated slot
                -- (and update currfile if it is the one moved)
                IupSetInt(mtab,"FILEIDX",delidx)
                filenames       = move_last_to_vacated_spot(filenames,       delidx)
                filepaths       = move_last_to_vacated_spot(filepaths,       delidx)
                filetext        = move_last_to_vacated_spot(filetext,        delidx)
                unicodefile     = move_last_to_vacated_spot(unicodefile,     delidx)
                actionptr       = move_last_to_vacated_spot(actionptr,       delidx)
                actions         = move_last_to_vacated_spot(actions,         delidx)
                actionsave      = move_last_to_vacated_spot(actionsave,      delidx)
                bookmarks       = move_last_to_vacated_spot(bookmarks,       delidx)
                filelinelengths = move_last_to_vacated_spot(filelinelengths, delidx)
                routines        = move_last_to_vacated_spot(routines,        delidx)
                filedt          = move_last_to_vacated_spot(filedt,          delidx)
                bCfwds          = move_last_to_vacated_spot(bCfwds,          delidx)
                if currfile=fidx then
                    currfile = delidx
                end if
--          end if
fidx = 0
            exit
        end if
    end for
if fidx!=0 then ?"removelast!=0?!!!" end if
end procedure

function saveFileAs()
Ihandln filedlg
integer encoding = ENC_NONE
string filename = ""

    StopMacroLearn(1)
    if currfile then
        integer c = iff(tabfile?tabfile:currfile) -- (deliberately not zeroed here)
        if UseNativeDialog
        and platform()=WINDOWS then
            atom hWnd = IupGetAttributePtr(dlg,"HWND")
            object res
            sequence path = filepaths[c]
            string name = filenames[c]
            if not match(untitled,name) then
                path = {path,name}
            else
                path = {path}
            end if
            encoding = unicodefile[c]
--DEV??
if encoding=0 then encoding = 1 end if
            string ext = get_file_extension(name)
            res = newGetSaveFileName(hWnd,buildFileFilter2(),{2,ext},path,encoding)
            if sequence(res) then
                {encoding,filename} = res
--30/12/17:
                encoding -= 1
--?{"encoding (edix.exw line 2541)",encoding,filename}
            end if
        else
            IupSetGlobal("UTF8MODE_FILE","YES")
            filedlg = IupFileDlg()

--18/11/17:
--          IupSetAttributePtr(filedlg, "PARENTDIALOG", dlg)
            IupSetAttributeHandle(filedlg, "PARENTDIALOG", dlg)
            IupSetAttributes(filedlg, "DIALOGTYPE=SAVE, TITLE=Save")
            IupSetAttribute(filedlg, "EXTFILTER", "Text files|*.txt;*.exw|All Files|*.*|")
            IupSetInt(filedlg, "FILTERUSED", 2)
            IupSetAttribute(filedlg, "DIRECTORY", filepaths[c])
            if not match(untitled,filenames[c]) then
                IupSetAttribute(filedlg, "FILE", filenames[c])
            end if

            IupPopup(filedlg, IUP_CENTERPARENT, IUP_CENTERPARENT)

            integer status = IupGetInt(filedlg, "STATUS")
            if status!=-1 then  -- (not cancelled)
                filename = IupGetAttribute(filedlg, "VALUE")
                encoding = ANSI
            end if

            filedlg = IupDestroy(filedlg)
        end if
        if length(filename) then
            string waspath = filepaths[c],
                   wasfile = filenames[c]
            filepaths[c] = get_file_path(filename,dropslash:=false)
            filenames[c] = get_file_name(filename)
--23/7/17...
            unicodefile[c] = encoding
            if saveFile(warnBackup:=false) then
--DEV tryme:
if 0 then
                IupSetAttributeId(tabs, "TABTITLE", findtab(c), filenames[c])
else
                Ihandle tab
                for pos=0 to IupGetInt(tabs,"COUNT")-1 do
                    tab = IupGetChild(tabs, pos)
                    if IupGetInt(tab,"FILEIDX")=c then
                        -- nb does not work after tab added (as documented):
--                      IupSetAttribute(tab, "TABTITLE", filenames[c])
                        -- However the following works just fine here, and
                        --  updates the above child attribute as well:
                        IupSetAttributeId(tabs, "TABTITLE", pos, filenames[c])
                        exit
                    end if
                end for
end if
                IupConfigRecentUpdate(config, filename)
                for i=1 to length(filenames) do
                    if i!=c
                    and filepaths[i]=filepaths[c]
                    and filenames[i]=filenames[c] then
--DEV close without saving... (see tabclose_cb) [needs testing!]
--?{i,c}
--show_tab_info()
                        removelast(i)
--DEV tryme:
if 0 then
                        {} = IupDestroy(findtab(i,true))
else
                        for pos=0 to IupGetInt(tabs,"COUNT")-1 do
                            Ihandln dtab = IupGetChild(tabs, pos)
                            if IupGetInt(dtab,"FILEIDX")=i then
                                dtab = IupDestroy(dtab)
                                exit
                            end if
                        end for
end if
--show_tab_info()
                        exit
--?9/0
                    end if
                end for
--DEV/sug:
                changeTo(currfile,-1)       -- reset syntax
                return 1
            else
                filepaths[c] = waspath
                filenames[c] = wasfile
            end if
        end if
    end if
    return 0
end function

global function saveCurrAs()
integer c
    if tabfile then
        c = tabfile
        -- no reset of tabfile here
    else
        c = currfile
    end if
    if match(untitled,filenames[c])=1 then
        --2/6/10:
        changeTo(c,-1)
        return saveFileAs()
    end if
    if actionsave[c]!=actionptr[c] then
        --2/6/10:
        changeTo(c,-1)
        return saveFile(warnBackup:=true)
    end if
    return 1
end function
--global constant r_saveCurr=routine_id("saveCurr")

--/*
function savePrompt(integer c)
integer mbRes
    if c and actionsave[c]!=actionptr[c] 
    and not match(".err",LowerCase(filenames[c])) then
    and not find(get_file_extension(filenames[c]),{"err"}) then
        -- 2/6/10:
        changeTo(c)
--      mbRes = proemh(filepaths[c]&filenames[c],
--                     xl("Save file before closing?"),
--                     MB_YESNOCANCEL)
        mbRes = IupAlarm(xl("Save file before closing?"),
                         filepaths[c]&filenames[c],
                         "Yes","No","Cancel")
--      if mbRes = IDCANCEL then return 0 end if
        if mbRes = 3 then return 0 end if
--      if mbRes = IDYES then
        if mbRes = 1 then
            tabfile = c
            return saveCurrAs()
        end if
    end if
    return 1
end function

-- used by eaxutil.ew, etc
--global 
procedure closeFile()
integer c
    StopMacroLearn(1)
    if tabfile then
        c = tabfile
        tabfile = 0
    else
        c = currfile
    end if
    if savePrompt(c) then
        tabfile = c
        closeTab()
    end if
end procedure
--global constant r_closeFile = routine_id("closeFile")
--*/

procedure addLineLengths(sequence lines)
integer len, recalc
    recalc = 0
    for i = 1 to length(lines) do
        len = ExpLength(lines[i]) + 1
        if len>length(filelinelengths[currfile]) then
            filelinelengths[currfile] = filelinelengths[currfile] &
                                        repeat(0,len-length(filelinelengths[currfile])+1)
        end if
        filelinelengths[currfile][len] = filelinelengths[currfile][len] + 1
        if len > maxlen then recalc = 1 end if
    end for
    if recalc then reCalcMaxLen() end if
end procedure

--/*
function toString(sequence name)--, integer errcode)
-- Explicitly convert a dword-sequence to an 8-bit string
string res
integer nlen
object ch
    nlen = length(name)
    res = repeat(' ',nlen)
    for i=1 to nlen do
        ch = name[i]
        if atom(ch) then
            ch = and_bits(ch,#FF)
            res[i] = ch
        else
--          fatal(errcode)
            ?9/0
        end if
    end for
    return res
end function
--*/

global procedure InsertBlock(sequence lines)
-- Note: all calls to InsertBlock should addAction.
-- This is used by UndoRedo() so cannot addAction() itself.
-- (this should only be called by Paste and UndoRedo)
integer k, lengthlines
--DEV fixme: [DONE] [UNDONE 23/10/16]
--string oneline, twoline
sequence oneline, twoline

    lengthlines = length(lines)
    if lengthlines then
        oneline = filetext[currfile][CursorY+1]
        k = MapToByte(oneline,CursorX)
        if lengthlines=1 then           -- no crlf insertion
            if k then
                oneline = oneline[1..k-1] & lines[1] & oneline[k..length(oneline)]
                CursorX = ExpLength(oneline[1..k-1+length(lines[1])])
            else    -- at end of line
                oneline &= lines[1]
                CursorX = ExpLength(oneline)
            end if
            replaceLine(CursorY+1,oneline)
--void = syntaxColour(oneline,CursorY+1,0,0)
            paintCursorY()  
        else                            -- multi lines
            if k then
                twoline = oneline[k..length(oneline)]
                oneline = oneline[1..k-1] & lines[1]
            else
--              twoline = {}
                twoline = ""
                oneline = oneline & lines[1]
            end if
--/*
--DEV: (now fixed, I hope)
if not string(oneline) then
?"oops: toString() rqd InsertBlock line 2318"
    oneline = toString(oneline)
end if
--*/
            replaceLine(CursorY+1,oneline)
            addLineLengths(lines[2..lengthlines])
            updateQJ(CursorY+1,lengthlines-1)--,2)
            filetext[currfile] = filetext[currfile][1..CursorY+1]&
                                 lines[2..lengthlines]&
                                 filetext[currfile][CursorY+2..length(filetext[currfile])]
--DEV why?? [is it for bcFwd?]
            for i=CursorY+1 to CursorY+lengthlines do
                {} = syntaxColour(filetext[currfile][i],i,0,0)
            end for
            if length(bookmarks[currfile])!=length(filetext[currfile]) then ?93/(1-isDebug) end if

            oneline = lines[lengthlines]
            CursorX = ExpLength(oneline)
            CursorY += lengthlines-1
            replaceLine(CursorY+1,oneline&twoline)
            paintall()
        end if
        forceCursorOnscreen()
    end if
end procedure

procedure InsertChar(integer ch, integer InsertMode)
-- Note: all calls to InsertChar (except the inner ones in indentWith/unindent) 
-- should addAction. This is used by UndoRedo() (or at least indirectly by
-- indentWith/unindent) so cannot addAction() itself.
-- InsertMode is either insertMode (toggled via Ins), or 0 for indentWith/unindent)
sequence oneline
integer k
    selON = 0
    oneline = filetext[currfile][CursorY+1]
    k = MapToByte(oneline,CursorX)
    if k then
        if InsertMode then
            oneline = oneline[1..k-1] & ch & oneline[k..length(oneline)]
        else
            oneline[k] = ch
        end if
    else    -- at end of line
        oneline = append(oneline,ch)
    end if
    CursorX = CursorRight(oneline,CursorX)
    replaceLine(CursorY+1,oneline)
    paintCursorY()
end procedure

-- used by undo.e
global function indentoneline(object what)
sequence thisline
    if and_bits(isClearOverStrike,cOVRpaste) then
        insertMode = 1
    end if
    CursorX = 0
    forceCursorOnscreen()
    if atom(what) then      -- VK_TAB
        thisline = filetext[currfile][CursorY+1]
        if length(thisline) = 0 then
            return 0
        elsif match("--/**/",thisline)=1 then
            CursorX = 6
        end if
        InsertChar(what,1)
    else                    -- comment
        for j=1 to length(what) do
            InsertChar(what[j],1)
        end for
    end if
    return 1
end function

global function indentWith(object what)
-- insert tab or comment seq at start of line
-- result is an array of 1's, indicating it was 
-- possible to indent each line (which it always is).
-- This is needed to keep undo/redo symetrical, since
-- it is not always possible to unindent.
integer k
sequence res
    if selON then
        if selY<CursorY then
            k = selY
            selY = CursorY
            CursorY = k
        end if
        selON = 0
        k = CursorY --save
        res = repeat(1,selY-CursorY+1)
        for i=CursorY to selY do
            CursorY = i
            res[i-k+1] = indentoneline(what)
        end for
        selON = 1
        selY = k
        selX = 0
        CursorX = ExpLength(filetext[currfile][CursorY+1])
--      paintall() -- done via charInput
--      return res
    else
        res = {indentoneline(what)}
    end if
    return {what,res}
end function

--used by undo.e
global function unindentoneline(object what)
sequence oneline
integer lw, leadcomment
    if and_bits(isClearOverStrike,cOVRpaste) then
        insertMode = 1
    end if
    CursorX = 0
    oneline = filetext[currfile][CursorY+1]
    lw = 0
    leadcomment = 0
    if atom(what) then      -- a tab (or other char)
        if length(oneline) and oneline[1]=what then
            lw = 1
        elsif match("--/**/",oneline) and oneline[7]=what then
            leadcomment = 1
            lw = 7
        end if
    else                -- comment seq
        if match(what,oneline)=1 then
            lw = length(what)
        end if
    end if
    if lw then
        if leadcomment then
            replaceLine(CursorY+1,oneline[1..6]&oneline[lw+1..length(oneline)])
        else
            replaceLine(CursorY+1,oneline[lw+1..length(oneline)])
        end if
        paintCursorY()
        forceCursorOnscreen()
    end if
    return lw
end function

--with trace
--global object uWith
global function unindent(object what)
-- remove tab or comment seq from start of line
-- result is set of flags indicating which lines could be done.
integer k
sequence res
    if selON then
        if selY<CursorY then
            k = selY   selY = CursorY   CursorY = k
--DEV (untried)
--          {selY,CursorY} = {CursorY,selY}
        end if
    end if
    if equal(what,"--") 
    and length(filetext[currfile][CursorY+1])
    and find(filetext[currfile][CursorY+1][1],"<>") then
        what = filetext[currfile][CursorY+1][1..1]
    end if
--  uWith = what
    if selON then
        selON = 0
        k = CursorY --save
        res = repeat(0,selY-CursorY+1)
        for i=1 to length(res) do
            CursorY = k+i-1
            res[i] = unindentoneline(what)
        end for
        selON = 1
        selY = k
        selX = 0
        CursorX = ExpLength(filetext[currfile][CursorY+1])
    else
        res = {unindentoneline(what)}
    end if
    return {what,res}
end function

include src/undo.e
--DEV (there also be create()...)
--addAction(INSERTBLOCK,res)

-- used by eafind.ew (replace) and earein.ew (reindent)
--with trace
global function deleteSelection()
object d
sequence pos
    pos = DeleteBlockPos()  -- save co-ords
    d = getSelection(SEL_DELETE)
    if sequence(d) and not equal(d,{""}) then
        addAction(pos,d)
--      selON = 0 -- cleared by getSelection(SEL_DELETE)
        return 1
    end if
    return 0
end function

--with trace
constant COPY = 1,   CUT = 2
procedure Clip(integer mode, integer appnd)
object clipText
sequence pos, c1
integer wasSelON, outTabWidth, p1End, p2Start, p2End
--integer fmt
--trace(1)
    wasSelON = selON
    if mode = COPY then
        clipText = getSelection(SEL_COPY)
    else -- mode = CUT
        pos = DeleteBlockPos()
        clipText = getSelection(SEL_DELETE)
    end if
    if sequence(clipText) then
        if mode = CUT then
            addAction(pos,clipText)
        end if
--DEV
--  if (isEu and (isReplaceTabs or Xtrans)) or isTabWidth!=8 then
--  if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
        if isReplaceTabs
--      or isTabWidth!=8 or (isEu and Xtrans) then
        or isTabWidth!=8 then
            p2Start = 1
            p2End = length(clipText)
            if isReplaceTabs then
                outTabWidth = 0
            else
                outTabWidth = 8
            end if
--          cX = remainder(cX,isTabWidth)
            cX = remainder(cX,8)    --??
            if cX then
                if wasSelON=2 then
                    p1End = p2End
                    p2End = 0               -- do it all here (in the top loop)
                else
                    p1End = 1               -- Only the first line gets special treatment
                    p2Start = 2
                end if
                for i=1 to p1End do
                    c1 = ConvertTabs(repeat(' ',cX)&clipText[i],isTabWidth,0)   -- all spaces
                    c1 = c1[cX+1..length(c1)]
                    if outTabWidth then
                        clipText[i] = ConvertTabs(c1,isTabWidth,outTabWidth)
                    else
                        clipText[i] = c1
                    end if
                end for
            end if
            for i=p2Start to p2End do
                clipText[i] = ConvertTabs(clipText[i],isTabWidth,outTabWidth)
            end for
        end if

--      if unicodefile[currfile]=0 then
--          fmt = CF_TEXT
--      else
----DEV (convert everything to utf8)
--          fmt = CF_UNICODETEXT
--      end if
        clipText = join(clipText,'\n')
--23/7/17:
        if not string(clipText) then
            clipText = utf32_to_utf8(clipText)
        end if
        if appnd=-1 then
--          clipText = clipText&getTextFromClipboard(fmt)
            clipText = clipText&IupGetAttribute(clipboard,"TEXT")
        elsif appnd then
--          clipText = getTextFromClipboard(fmt)&clipText
            clipText = IupGetAttribute(clipboard,"TEXT")&clipText
        end if
--      void = copyTextToClipboard(clipText,fmt)
        IupSetAttribute(clipboard, "TEXT", NULL)    -- (as per docs)
        IupSetAttribute(clipboard, "TEXT", clipText)
    end if
end procedure

--with trace

--used by htmlise.e:
global procedure Paste(object clipText=0)
object padding
integer cX, cY, sX, absY, rCx
integer newCursorY, newcX
sequence ci
--integer fmt
--trace(1)
    if currfile then
        if and_bits(isClearOverStrike,cOVRpaste) then
            insertMode = 1
        end if
--DEV
--      if unicodefile[currfile]=0 then
--          fmt = CF_TEXT
--      else
--          fmt = CF_UNICODETEXT
--      end if
--      clipText = getTextFromClipboard(fmt)
        if atom(clipText) then
            clipText = IupGetAttribute(clipboard, "TEXT")
            if length(clipText) then
                clipText = split(clipText,'\n')
            end if
        end if
        if length(clipText) then
--          clipText = split(clipText,'\n')
            if selON=2 then -- column mode
--              absY = Abs(CursorY-selY)+1
                absY = sq_abs(CursorY-selY)+1
                if equal(clipText,repeat(clipText[1],length(clipText))) then
                    clipText = repeat(clipText[1],absY)
                else
                    if length(clipText)!=absY then
                        if length(clipText)=absY+1
                        and equal(clipText[length(clipText)],"") then
                            clipText = clipText[1..absY] -- drop trailing \n
                        else
--                          IupMessage(xl("Error"),
--                                     xl("incorrect length for non-uniform column paste"))
--                          return
                            newCursorY = min(selY,CursorY)
                            newcX = min(selX,CursorX)
                            padding = xl("incorrect length for non-uniform column paste")
                            if newcX=ExpLength(filetext[currfile][newCursorY+1]) then
                                for i=2 to length(clipText) do
                                    if newcX<ExpLength(filetext[currfile][newCursorY+i]) then
                                        padding &= '\n'&xl("(NB some lines are longer than current)")
                                        exit
                                    end if
                                end for
                            end if
                            -- Note: first button is DEFAULTENTER
                            if IupAlarm(xl("Warning"),padding,"CANCEL","OK")=1 then
                                return
                            end if
                            CursorY = newCursorY
                            cX = newcX
                            selY = CursorY+length(clipText)
                        end if
                    end if
                end if
                cY = min(selY,CursorY)
                cX = min(selX,CursorX)
                sX = max(selX,CursorX)
                for i=1 to length(clipText) do
                    CursorY = cY
                    CursorX = ExpLength(filetext[currfile][CursorY+1])
                    ci = clipText[i]
                    if CursorX<cX then      -- line too short - pad
                        if length(ci) then
                            padding = {repeat(' ',cX-CursorX)}
--DEV 16/8/16 this looks wrong! (but might be fine)
                            selON = 0
                            addAction(INSERTBLOCK,padding)
                            InsertBlock(padding)
                        end if
                    elsif CursorX>cX and sX>cX then
                        if CursorX>sX then
                            CursorX = sX
                        end if
                        selX = CursorX
                        CursorX = cX
                        selY = cY -- one line at a time
                        selON = 1
                        if not deleteSelection() then
                            ?1
                        end if
                    end if
                    if length(ci) then
                        CursorX = cX
                        selON = 0
                        rCx = remainder(cX,8)
--                      if rCx or isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
                        if rCx or isTabWidth!=8 or isReplaceTabs then
--                          ci = ConvertTabs(repeat(' ',rCx)&ci,8,0)        -- 10/1/08
                            ci = ConvertTabs(ci,8,0)
                            ci = ConvertTabs(repeat('X',rCx)&ci,8,isTabWidth)
                            ci = ci[rCx+1..length(ci)]
--                          ci = ConvertTabs(ci,0,isTabWidth)
                        end if
                        addAction(INSERTBLOCK,{ci})
                        InsertBlock({ci})
                    end if
                    cY += 1
                end for
            else -- not column mode
                if deleteSelection() then end if
                rCx = remainder(CursorX,8)
--              if rCx or isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
                if rCx or isTabWidth!=8 or isReplaceTabs then
                    ci = ConvertTabs(clipText[1],8,0)
                    ci = ConvertTabs(repeat('X',rCx)&ci,8,isTabWidth)
                    ci = ci[rCx+1..length(ci)]
                    clipText[1] = ci
                    for i=2 to length(clipText) do
                        clipText[i] = ConvertTabs(clipText[i],8,isTabWidth)
                    end for
                end if
                addAction(INSERTBLOCK,clipText)
                InsertBlock(clipText)
            end if
            forceCursorOnscreen()
        end if
    end if
end procedure

-- used by reinh.e:
global procedure selectAll()
    if currfile then
        selON = 1   selX = 0   selY = 0
        CursorY = length(filetext[currfile])-1
        CursorX = ExpLength(filetext[currfile][CursorY+1])
        paintall()
    end if
end procedure

--(used by eaisense... [DEV])
--global 
procedure selectWord(integer SelectWord)
--
-- Select the word under the cursor, if any.
-- In all cases, selX and CursorX are set, but if the parameter SelectWord is 0, 
--  it is being called from intellisense and hence selON should /not/ be set.
--
sequence oneline
integer ch, dotfound, isnumber, validhex, lch
    if currfile then
--29/01/2011
        if selON or isCurrLineColoured then
            -- remove old currentline highlight
            clearSelection()
        end if
        dotfound = 0
        isnumber = 1
        validhex = 1
        oneline = ExpandTabs(filetext[currfile][CursorY+1])
        lch = 0
        while CursorX>0 do
--bugfix 25/6/15:
            if CursorX>length(oneline) then exit end if
            ch = oneline[CursorX]
            if ch<=128 and wordChar[ch+1]!=TokenChar then
                lch = ch
                exit
            end if
            if ch='.' then
                if CursorX>1 and oneline[CursorX-1]='.' then exit end if
                if not isnumber then exit end if
                dotfound = 1
                if CursorX<length(oneline) then
                    ch = oneline[CursorX+1]
--                  if ch = '.' then exit end if
                    if ch <'0' or ch>'9' then exit end if
                end if
            elsif ch<'0' or ch>'9' then
                if isnumber=1 and (ch='e' or ch='E') then
                    isnumber = 2
                else
                    isnumber = 0
                end if
                if ch<'A'
                or (ch>'F' and ch<'a')
                or (ch>'f') then
                    validhex = 0
                end if
            end if
            CursorX -= 1
        end while
        forceCursorOnscreen()
        selX = CursorX
        while CursorX<length(oneline) do
            ch = oneline[CursorX+1]
            if ch<=128 and wordChar[ch+1]!=TokenChar then exit end if
            if ch='.' then
                if CursorX<length(oneline)-1 and oneline[CursorX+2]='.' then exit end if
                if not isnumber then exit end if
                dotfound = 1
                if CursorX>0 then
                    ch = oneline[CursorX]
--                  if ch = '.' then exit end if
                    if ch <'0' or ch>'9' then exit end if
                end if
            elsif ch<'0' or ch>'9' then
                if isnumber=1 and (ch='e' or ch='E') then
                    isnumber = 2
                else
                    isnumber = 0
                end if
                if ch<'A'
                or (ch>'F' and ch<'a')
                or (ch>'f') then
                    validhex = 0
                end if
            end if
            CursorX += 1
        end while
        selON = (selX!=CursorX) and SelectWord
        if selON and dotfound=0 and validhex=1 and lch='#' then
            selX -= 1
        end if
--catchSelChg = 1
        selY = CursorY
        paintCursorY()
        forceCursorOnscreen()
    end if
end procedure

function cmap(integer n)
    if n='\t' then return `\t` end if
    if n='\n' then return `\n` end if
    if n='\r' then return `\r` end if
    if n='\"' then return `\"` end if
    if n='\'' then return `\'` end if
    if n='\\' then return `\\` end if
--  setText(SB6,sprintf("invalid character:%d",n))
    IupSetStrAttribute(sbmsg,"TITLE","invalid character:%c(#%02x)",{n,n})
    return ""   
end function

procedure show_as_base(integer base)
--sequence pos, c, hexchar
sequence pos, hexchar
string c
object d
integer ld, ch, k, leadin, signed, skip
atom n
--trace(1)
    pos = DeleteBlockPos()  -- save co-ords
    d = getSelection(SEL_COPY)
    if sequence(d) and length(d)=1 then     -- (ie {"1234"} is text on one line, length 1)
        d = d[1]
        ld = length(d)
        if ld then
--28/1/18:
            if not string(d) then d = utf32_to_utf8(d) end if
            c = d
            n = 0
            signed = 0
            
            if base>0 then

                if length(d)>1 and d[1]='-' then
                    signed = 1
                    d = d[2..length(d)]
                end if
                if d[1]='#' then
                    for i=2 to length(d) do
                        ch = d[i]
                        if ch>='0' and ch<='9' then
                            n = n*16+ch-'0'
                        elsif ch>='A' and ch<='F' then
                            n = n*16+ch-'A'+10
                        elsif ch>='a' and ch<='f' then
                            n = n*16+ch-'a'+10
                        else
                            return
                        end if
                    end for

                elsif length(d)>2 and equal(d[1..2],"0b") then
                    for i=3 to length(d) do
                        ch = d[i]
                        if ch>='0' and ch<='1' then
                            n = n*2+ch-'0'
                        else
                            return
                        end if
                    end for

                elsif length(d)>2 and equal(d[1..2],"0o") then
                    for i=3 to length(d) do
                        ch = d[i]
                        if ch>='0' and ch<='7' then
                            n = n*8+ch-'0'
                        else
                            return
                        end if
                    end for

                elsif length(d)>2 and equal(d[1..2],"0x") then
                    for i=3 to length(d) do
                        ch = d[i]
                        if ch>='0' and ch<='9' then
                            n = n*16+ch-'0'
                        elsif ch>='A' and ch<='F' then
                            n = n*16+ch-'A'+10
                        elsif ch>='a' and ch<='f' then
                            n = n*16+ch-'a'+10
                        else
                            return
                        end if
                    end for

                else
                    for i=1 to length(d) do
                        ch = d[i]
                        if ch>='0' and ch<='9' then
                            n = n*10+ch-'0'
                        else
--added 23/12/15 (allow/ignore a trailing ".0" now that we dump said many times in ex.err):
                            if ch='.' and i=length(d)-1 and d[$]='0' then exit end if
                            return
                        end if
                    end for
                end if
                if signed
                and base!=10 
                and n<#100000000 then
                    n = #100000000-n
                    signed = 0
                end if
                if base=16 then     -- show as hex

--Bugfix: number is too big for %x or %o format 
--                  c = sprintf("#%x",n)
                    hexchar = "0123456789ABCDEF"
                    c = ""
--                  while n do
                    while 1 do
                        k = floor(remainder(n,16)+1)
                        c = prepend(c,hexchar[k])
                        n = floor(n/16)
                        if n=0 then exit end if
                    end while
                    c = prepend(c,'#')

                elsif base=10 then  -- show as decimal

                    if signed then
                        n = -n
                        signed = 0
                    end if
                    c = sprintf("%d",n)

                elsif base=8 then   -- show as octal
                    c = ""
--                  while n do
                    while 1 do
                        k = remainder(n,8)
                        c = prepend(c,k+'0')
                        n = floor(n/8)
                        if n=0 then exit end if
                    end while
                    c = "0o"&c

                elsif base=2 then   -- show as binary
                    c = ""
--                  while n do
                    while 1 do
                        k = remainder(n,2)
                        c = prepend(c,k+'0')
                        n = floor(n/2)
                        if n=0 then exit end if
                    end while
                    c = "0b"&c
                else
                    ?9/0    -- unknown base
                end if
                if signed then
                    c = "-"&c
                end if
            elsif base=-1 then  -- show as sequence/string
                c = d
                if ld>1 then
                    ch = d[1]
                    k = d[ld]
                    if ch='"' and k='"' then
--                      c = sprint(d[2..ld-1])
                        c = "{"
                        leadin = 0
                        for i=2 to ld-1 do
                            ch = d[i]
                            if leadin then
                                leadin = 0
                                if not find(ch,`"'\`) then
                                    if ch='t' then
                                        ch = '\t'
                                    elsif ch='n' then
                                        ch = '\n'
                                    elsif ch='r' then
                                        ch = '\r'
                                    else
--                                      setText(SB6,"unrecognised escape character:"&ch)
                                        IupSetStrAttribute(sbmsg,"TITLE","unrecognised escape character:%c(#%02x)",{ch,ch})
                                        return
                                    end if
                                end if
                                c &= sprintf("%d,",ch)
                            elsif ch='\\' then
                                leadin = 1
                            else
                                c &= sprintf("%d,",ch)
                            end if
                        end for
                        if leadin then
--                          setText(SB6,"leadin error")
                            IupSetStrAttribute(sbmsg,"TITLE","leadin error")
                            return
                        end if
                        ld = length(c)
                        if ld>1 then
                            c[ld] = '}'
                        else
                            c &= '}'
                        end if
                    elsif ch='{' and k='}' then
                        c = `"`
                        skip = 0
                        for i=2 to ld-1 do
                            if skip then
                                skip -= 1
                            else
                                ch = d[i]
                                if ch>='0' and ch<='9' then
                                    n = n*10+ch-'0'
                                elsif ch=',' then
                                    if n<' ' or n>255 or find(n,`"'\`) then
                                        hexchar = cmap(n)
                                        if length(hexchar)=0 then return end if
                                        c &= hexchar
                                    else
                                        c = append(c,n)
                                    end if
                                    n = 0
                                elsif ch='\'' then
                                    if d[i+1]='\\' then
                                        skip = 3
                                    else
                                        skip = 2
                                    end if
                                else
--                                  setText(SB6,"unrecognised character:"&ch)
                                    IupSetStrAttribute(sbmsg,"TITLE","unrecognised character:%c(#%02x)",{ch,ch})
                                    return
                                end if
                            end if
                        end for
                        if n<' ' or n>255 or find(n,`"'\`) then
                            hexchar = cmap(n)
                            if length(hexchar)=0 then return end if
                            c &= hexchar
                        else
                            c = append(c,n)
                        end if
                        c = append(c,'"')
                    end if
                end if
            else
                ?9/0    -- base=0??
            end if

            if not equal(c,d) then
--              Paste(c)
                Paste({c})
                k = length(c)-length(d)
                if k then
                    if pos[2]<pos[4] then   -- CursorX<selX
                        pos[4] = pos[4]+k
                    else
                        pos[2] = pos[2]+k
                    end if
                end if
                restoreBlockPos(pos)
            end if
        end if
    end if
end procedure

constant LOWER = 1, UPPER = 2, CAPITALISE = 3, SENTENCE = 4, INVERT = 5

function convertCase(sequence strings, integer method)
--
-- strings is a collection of text, eg
--      {"this is some text, which might be several",
--       "lines long. Matches getSelection/Paste, etc."}
--
-- Note that strings[i] is ansi or utf32 (should not be utf8 or utf16)
--
-- method may be LOWER, UPPER, CAPITALISE, SENTENCE, or INVERT.
--
integer c,      -- a character
        pc,     -- previous character
        eos,    -- end of sentence flag
        inQuote -- within double quotes flag

    pc = ' '
    eos = True
    inQuote = False
    for i=1 to length(strings) do
        for j=1 to length(strings[i]) do
            c = strings[i][j]
            if method = LOWER then
                if c>='A' and c<='Z' then
                    strings[i][j] = c+32
                end if
            elsif method = UPPER then
                if c>='a' and c<='z' then
                    strings[i][j] = c-32
                end if
            elsif method = INVERT then
                if c>='A' and c<='Z' then
                    strings[i][j] = c+32
                elsif c>='a' and c<='z' then
                    strings[i][j] = c-32
                end if
            elsif method = CAPITALISE then
--              if find(pc," \"/") then
                if find(pc,` "/`) then
                    if c>='a' and c<='z' then
                        strings[i][j] = c-32
                    end if
                else
                    if c>='A' and c<='Z' then
                        strings[i][j] = c+32
                    end if
                end if  
            elsif method = SENTENCE then
                if pc = ' ' then
                    if eos then
                        if c>='a' and c<='z' then
                            strings[i][j] = c-32
                        end if
                        eos = False
                    else
                        if c>='A' and c<='Z' then
                            strings[i][j] = c+32
                        end if
                    end if
                else
                    if c>='A' and c<='Z' then
                        strings[i][j] = c+32
                    end if
                end if
                if find(c,".!?") then
                    eos = True
                elsif c!=' ' then
                    eos = False
                end if
                if c = '\"' then
                    c = ' '
                    inQuote = not inQuote
                    eos = inQuote
                end if
            end if
            pc = c
        end for
        if eos then
            pc = ' '
        end if
    end for
    return strings
end function

procedure caseOp(integer method)
sequence pos
object c,d
--integer fmt
    pos = DeleteBlockPos()  -- save co-ords
    d = getSelection(SEL_COPY)
    if sequence(d) and not equal(d,{""}) then   -- something to play with
        c = convertCase(d,method)
        if not equal(c,d) then
--/*
--          if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
            if isReplaceTabs then
                for i=1 to length(c) do
                    c[i] = ConvertTabs(c[i],isTabWidth,0)
                end for
            elsif isTabWidth!=8 or (isEu and Xtrans) then
                -- This also performs translation:
                for i=1 to length(c) do
--                      c[i] = UnPackTabs(c[i])
                    c[i] = ConvertTabs(c[i],isTabWidth,8)
                end for
            end if

            if unicodefile[currfile]=0 then
                fmt = CF_TEXT
            else
                fmt = CF_UNICODETEXT
            end if
--*/
--          void = copyTextToClipboard(c,fmt)
--          Paste()
            Paste(c)
            restoreBlockPos(pos)
        end if
    end if
end procedure

procedure duplicate_line()
sequence oneline
    if and_bits(isClearOverStrike,cOVRdupline) then
        insertMode = 1
    end if
    selON = 0
    integer k = CursorX         -- Save
    CursorX = 0                 -- move to start of line
    oneline = {filetext[currfile][CursorY+1],""}    -- with trailing CR
    addAction(INSERTBLOCK,oneline)
    InsertBlock(oneline)
    CursorX = k                 -- restore
end procedure


procedure toggle_line_numbers()
-- aside: this toggle should be temporary, whereas edit options should be permanent [DEV]
    isLineNumbers = not isLineNumbers
    setMarginRqd()
    forceCursorOnscreen()
    paintall()
end procedure

Ihandle main_help_menu

procedure DragLine(integer direction)
-- swap current line with line+direction, move the cursor with it, and redisplay both
integer SaveCursorX, SaveCursorY
integer newY
sequence line
sequence block

--DEV/test (does not work...)
--IupSetAttribute(main_help_menu,"KEY",'B')

    if currfile then
        newY = adjustLine(CursorY,direction,CursorX)
        if newY!=CursorY
        and newY<length(filetext[currfile]) then
            if and_bits(isClearOverStrike,cOVRup+cOVRdown+cOVRdupline) then
                insertMode = 1
            end if
            SaveCursorX = CursorX                   -- Save
            SaveCursorY = CursorY                   -- Save
            line = filetext[currfile][CursorY+1]
            selON = 1
            if direction=+1 then
--DEV... (now in key_cb)
--/!*
--string Yelp = "&Yelp"
--  Yelp[2] = 'D'--iup_XkeyBase(c)
--  IupSetStrAttribute(main_help_menu,"TITLE",Yelp)
--  reset_help = true
--*!/
                -- Suppose we are on one, and moving it down:
                --  one     -- (CursorY)
                --  two     -- (newY)
                -- first delete {one,\n}, ie {0,CursorY} to {0,newY}:
                selX    = 0
                selY    = CursorY
                CursorX = 0
                CursorY = newY
                {} = deleteSelection()
                -- then insert {\n,one} at the end of two (which is  
                --  now where one/CursorY was before we deleted it):
                CursorX = ExpLength(filetext[currfile][SaveCursorY+1])
                CursorY = SaveCursorY
                block = {"",line}
            else
                -- Suppose we are on two, and moving it up:
                --  one     -- (newY)
                --  two     -- (CursorY)
                -- first delete {\n,two}, ie {$,newY} to {$,CursorY}:
                selX = ExpLength(filetext[currfile][newY+1])
                selY = newY
                CursorX = ExpLength(line)
        --      CursorY = CursorY -- (already set!)
                {} = deleteSelection()
                -- then insert {two,\n} at the start of one (which
                --  was not moved at all by the above deletion):
                CursorX = 0
                CursorY = newY
                block = {line,""}
            end if
            addAction(INSERTBLOCK,block)
            InsertBlock(block)
            selON = 0
            CursorX = SaveCursorX                   -- Restore
            CursorY = newY
        end if
    end if
end procedure

include src/rein.e as rein

--constant backgrounds = {CD_GRAY, CD_WHITE, CD_YELLOW}
constant backgrounds = {CD_RED, CD_ORANGE, CD_YELLOW, CD_GREEN, CD_BLUE}
--  CD_RED          = #FF0000,
--  CD_DARK_RED     = #800000,
--  CD_ORANGE       = #FFA500,
--  CD_DARK_ORANGE  = #FF8C00,
--  CD_GREEN        = #00FF00,
--  CD_DARK_GREEN   = #008000,
--  CD_BLUE         = #0000FF,
--  CD_DARK_BLUE    = #000080,
--  CD_YELLOW       = #FFFF00,
--  CD_DARK_YELLOW  = #808000,
--  CD_MAGENTA      = #FF00FF,
--  CD_DARK_MAGENTA = #800080,
--  CD_CYAN         = #00FFFF,
--  CD_DARK_CYAN    = #008080,
--  CD_WHITE        = #FFFFFF,
--  CD_BLACK        = #000000,
--  CD_DARK_GRAY    = #808080,
--  CD_GRAY         = #C0C0C0,
--  CD_PARCHMENT    = #FFFFE0,

integer backgroundidx = length(backgrounds)-1


--temp/inline?
--function putx(atom x, atom y, string txt, integer colour, integer drawBackground=0)   -- untried
function putx(atom x, atom y, string txt, integer colour)
--DEV temp: (will need something similar for highlighting)
    if RotateBackground then
--  if RotateBackground or drawBackground then -- untried
        cdCanvasSetForeground(cddbuffer, backgrounds[backgroundidx])
        atom {xmin, xmax, ymin, ymax} = cdCanvasGetTextBox(cddbuffer, x, y, txt)
        cdCanvasBox(cddbuffer, xmin, xmax, ymin, ymax)
    end if
    cdCanvasSetForeground(cddbuffer, colour)
    cdCanvasText(cddbuffer,x,y,txt)
    {x} = cdCanvasGetTextSize(cddbuffer,txt)
    return x
end function

integer charheight,
        charwidth   -- (for cursor I)

string fontname = iff(platform()=LINUX?"Courier":"Consolas")
integer fontstyle = CD_PLAIN
integer fontsize = 12

Ihandle cursorblink

atom cursorx = 0,
     cursory = 0,
     cursorc = 0

--integer catchme = 0

function cursorblink_cb(Ihandle /*ih*/)
--if catchme then ?9/0 end if
--  if cursorx=-1 then 
--  end if
    cdCanvasActivate(cddbuffer)
--DEV replace CD_GRAY with background colour..
--  cursorc = iff(cursorc=CD_BLACK?CD_GRAY:CD_BLACK)
    cursorc = iff(cursorc=CD_BLACK?ColourTab[HighLine]:CD_BLACK)
    cdCanvasSetForeground(cddbuffer, cursorc)
--  cdCanvasSetForeground(cddbuffer, CD_GRAY)
    cdCanvasLine(cddbuffer, cursorx, cursory-charheight*0.2, cursorx, cursory+charheight*0.8)
    cdCanvasFlush(cddbuffer)
    update_toolbar()
    return IUP_DEFAULT
end function
constant cb_cursorblink = Icallback("cursorblink_cb")

procedure clearcursor()
    if cursorc=CD_BLACK then
        {} = cursorblink_cb(cursorblink)
    end if
--?{cursorx,cursory}
    integer {width, height} = cdCanvasGetSize(cddbuffer)
    cursorx = charwidth*(marginRqd+CursorX-Column)+1
    cursory = height-(CursorY-TopLine+0.875)*charheight
--?{cursorx,cursory}
    if cursorc!=CD_BLACK then
        {} = cursorblink_cb(cursorblink)
    end if
--
--      for i=charheight-1 to floor(height+charheight/2) by charheight do
--          y = height-i+3
--          if line=CursorY+1 then
--
--      line = TopLine+1
--
end procedure

--/*
--NO: bad thinking: either cdCanvasClear the whole lot, or every line has to have background redrawn...
sequence lineback = {}
    if length(lineback)!=linesPerPage then  -- (or lines to show?)
        lineback = repeat(0,linesPerPage)
        paintRqd = 1
        paintLast = 0
    end if
--*/

global
procedure appUpdateRender()
integer width, height, x, y, w
Ihandln tab
integer fidx, line, screenline
sequence text,
         oneline,
         chunk
string acrest
sequence txt
integer isCY
integer offset, chunklen
--, zeroDrawn
--integer conti
integer marginColour
integer charsLeft
integer bkColour
integer thisFont
--DEV unneccesary?
integer rebuildbCfwdAtEnd = 0
--?"appUpdateRender"

    cdCanvasActivate(cddbuffer)

--DEV if paintall...
--  if paintRqd=1 and paintLast=0 then
--      cdCanvasSetBackground(cddbuffer, ColourTab[Background])
        cdCanvasSetBackground(cddbuffer, CD_GRAY)
        cdCanvasClear(cddbuffer)
--  end if

--?"appUpdateRender"
    if RotateBackground then
        backgroundidx += 1
        if backgroundidx>length(backgrounds) then
            backgroundidx = 1
        end if
--DEV this only affects cdCanvasClear!
--      cdCanvasSetBackground(cddbuffer, backgrounds[backgroundidx])
    end if

--  {width, height} = IupGetIntInt(dlg, "RASTERSIZE")
    {width, height} = cdCanvasGetSize(cddbuffer)
--?{width,height}
--  linesPerPage = ceil(height/charheight)
    linesPerPage = floor(height/charheight)
--  charsWide = floor((ClipRect[3]-ClipRect[1])/CharWidth)
--  charsWide = ceil(width/charwidth)
    charsWide = floor(width/charwidth)
--  linesPerPage = floor((ClipRect[4]-ClipRect[2])/CharHeight)

--?{height,charheight,linesPerPage}
--forceCursorOnscreen() -- NO!
--  cdCanvasLine(cddbuffer, 0, 0, width-1, height-1)
--  cdCanvasLine(cddbuffer, 0, height-1, width-1, 0)
--cdCanvasText(cddbuffer,1,1,"ABCDEF")
--cdCanvasText(cddbuffer,1,1,sprint(cdCanvasGetTextBox(cddbuffer,1,1,"ABCDEFG")))   -- {1,64,-2,13}
--cdCanvasText(cddbuffer,15,16,sprint(cdCanvasGetTextSize(cddbuffer,"ABCDEFG"))) -- {64,16}
--cdCanvasText(cddbuffer,15,1,sprint(cdCanvasGetSize(cddbuffer)&charheight))
--cdCanvasText(cddbuffer,15,1,sprint(cdCanvasGetFont(cddbuffer)))

    cursorx = -1
    tab = IupGetAttributeHandle(tabs, "VALUE")
    -- (obviously tab!=NULL does not require much in the way of explanation, 
    --  however note that VISIBLE is a fudge: we need to redisplay, from
    --  tabclose_cb, /before/ the tab is actually removed (IUP_CONTINUE),
    --  and, importantly, blank when there was no new VALUEPOS setting.)
    if tab!=NULL and IupGetInt(tab,"VISIBLE") then
        fidx = IupGetInt(tab,"FILEIDX")
--DEV?? (needed 23/7/17...) [misbehaved...]
--currfile = fidx
--if currfile!=fidx then ?9/0 end if
if currfile!=fidx then ?"currfile!=fidx" end if
currfile = fidx
        text = filetext[fidx]
        line = TopLine+1

        if atom(bCfwd) then
            integer unpacklineend = adjustLine(TopLine,linesPerPage,TopChunk)
            rebuildbCfwd(unpacklineend)
            rebuildbCfwdAtEnd = 1
        end if

--DEV:
--/*
linesPerPage = 0
        for i=charheight-1 to floor(height+charheight/2) by charheight do
            linesPerPage += 1
        end for
--*/
--/* --Next Step:   (nah)
        integer lpp = 0
        for i=charheight-1 to floor(height+charheight/2) by charheight do
            lpp += 1
        end for
        if lpp!=linesPerPage then ?9/0 end if
--*/
        screenline = 1

--      for ?=1 to linesPerPage do
--      for i=charheight-1 to height+charheight/2-0*charheight*4 by charheight do
        for i=charheight-1 to floor(height+charheight/2) by charheight do
--      for y=height-charheight+1 to floor(height-charheight/2) by -charheight do
--      for y=height-charheight+1 to height-floor(charheight/2) by -charheight do
            if line>length(text) then exit end if
            x = 1
            y = height-i+3
--          if i>charheight then
--              x += putx(x, y, "The ", CD_BLACK)
--              x += putx(x, y, "quick", CD_BLUE)
--              x += putx(x, y, " brown fox jumped over the lazy dog", CD_BLACK)
--          else
----                x += putx(x, y, "The quick brown fox jumped over the lazy dog", CD_BLACK)
--              x += putx(x, y, "12345678901234567890123456789012345678901345", CD_BLACK)
--          end if
--(not tried)
--          if not string(oneline) then
--              oneline = utf32_to_utf8(oneline)
--          end if
if 0 then
            oneline = ExpandTabs(text[line])
            x += putx(x, y, oneline, CD_BLACK)
else
            oneline = text[line]
            if CursorY=synclr:getcY() 
            and MapToByte(oneline,CursorX)=0 then
                acrest = synclr:getacrest()
            else
                acrest = ""
            end if
if showSpecials then
--          oneline = ConvertTabs(oneline, isTabWidth, isTabWidth)
            oneline = ExpandTabSpecials(oneline)
--NO:: (need to do individual blocks)
--          if unicodeflag!=ANSI then -- no!
--          oneline = utf32_to_utf8(oneline,1)
--          end if
else
            oneline = ExpandTabs(oneline)
end if

--DEV [30/9/16] this may now be necessary:
--          if not string(oneline) then
--              oneline = utf32_to_utf8(oneline)
--          end if

--?{marginRqd,isLineNumbers}
            if marginRqd or isLineNumbers then
                if isLineNumbers then
                    marginRqd = length(sprint(length(filetext[currfile])))+isMarginSpace
                    if isMarginSpace then
--                      oneline = sprintf(sprintf("%%%dd ",marginRqd-1),lineno) & oneline
                        oneline = sprintf(sprintf("%%%dd ",marginRqd-1),line) & oneline
                    else
--                      oneline = sprintf(sprintf("%%%dd",marginRqd),lineno) & oneline
                        oneline = sprintf(sprintf("%%%dd",marginRqd),line) & oneline
                    end if
                else
                    marginRqd = 1+isMarginSpace
                    oneline = repeat(' ',marginRqd) & oneline
                end if
                marginColour = ColourTab[Linenos]
            else
                marginColour = 0
            end if
            chunk = {}  -- (I think this improves matters)
--          chunk = syntaxColour(oneline,lineno,marginRqd,marginColour)
--DEV
--comment="--"
--blockComment = ""
            chunk = syntaxColour(oneline,line,marginRqd,marginColour)
--?chunk[1..chunkMax]
            -- chunk is now {length,txtclr,bkclr,font,length,txtclr...}
            oneline &= acrest
            charsLeft = charsWide
--          isCY = (lineno=CursorY+1)
            isCY = (line=CursorY+1)

--          conti = 1
            offset = 0

--          zeroDrawn = True
--          bkColour = ColourTab[Background]

--              for i=conti to chunkMax by 4 do
            for c=1 to chunkMax by 4 do
--                  conti = 0
                -- chunk is {len, textcolour, backcolour, font,
                --       len, textcolour, backcolour, font,
                --       ...}
                chunklen = chunk[c]
--?chunklen
--              if isWordWrapON then
--                  if sequence(BookMarkSet[lineno])
--                  and not and_bits(BookMarkSet[lineno][bfType],FOLD) then
--                      if nWrapIdx<=length(nWrap)
--                      and offset+chunklen>=nWrap[nWrapIdx]+marginRqd then
--                          chunklen = nWrap[nWrapIdx]-offset+marginRqd
--                          nWrapIdx += 1
--                          if chunklen = chunk[c] then
--                              conti = i+4
--                          else
--                              chunk[c] = chunk[c]-chunklen
--                              conti = i
--                          end if
--                      end if
--                  end if
--              end if
--?{offset,chunklen,Column}
                if offset+chunklen>=Column then -- skip blocks wholly left of view
                    if offset<Column then
                        chunklen -= Column-offset
                        offset = Column
                    end if
                    if chunklen>charsLeft then
                        chunklen = charsLeft+1
                    end if
--                      void = c_func(xSetTextColor, {mDC, chunk[c+1]})
--                  cdCanvasSetForeground(cddbuffer, chunk[c+1])
                    txt = oneline[offset+1..offset+chunklen]

                    if showSpecials or not string(txt) then
                        txt = utf32_to_utf8(txt,1)
                    end if

                    bkColour = chunk[c+2]
                    --
                    -- modify/narrow down that isCY to one chunk of a wordwrapped line:
                    --
--                  if isCY=1 and isWordWrapON then
--                      isCY = 2    -- Still True, but do this once per screenline only.
--                                  -- (the tests below only work for offset as at display
--                                  --  of the very first chunk and/or margin aka line nos)
--                                  -- isCY will (may) be reset to 1 when resuming from conti.
--                      if sequence(BookMarkSet[line])
--                      and not and_bits(BookMarkSet[line][bfType],FOLD) then
--                          -- is CursorX in the same chunk as offset?
--                          for wi=length(nWrap) to 0 by -1 do
----                                if wi=0 or offset-marginRqd>=nWrap[wi] then
--                              if wi=0 or offset>=nWrap[wi] then
--                                  if (wi!=0 and CursorX<nWrap[wi])
--                                  or (wi<length(nWrap) and CursorX>=nWrap[wi+1]) then
--                                      isCY = 0    -- Nope! (so display this chunk with normal bg)
--                                  end if
--                                  exit
--                              end if
--                          end for
--                      end if
--                  end if
                    if isCY 
                    and bkColour = ColourTab[Background] then
                        bkColour = ColourTab[HighLine]
                    end if
                    if bkColour!=ColourTab[Background] then
--                      cdCanvasSetBackground(cddbuffer, bkColour)
--?bkColour
                        cdCanvasSetForeground(cddbuffer, bkColour)
                        atom {xmin, xmax, ymin, ymax} = cdCanvasGetTextBox(cddbuffer, x, y, txt)
--?{xmin, xmax, ymin, ymax}
                        cdCanvasBox(cddbuffer, xmin, xmax, ymin, ymax)
--DEV
--                      cdCanvasSetBackground(cddbuffer, ColourTab[Background])
--                      cdCanvasSetBackground(cddbuffer, CD_GRAY)
                    end if
--?chunk[c+1]
                    cdCanvasSetForeground(cddbuffer, chunk[c+1])
                    thisFont = chunk[c+3]
                    if fontstyle!=thisFont then
                        cdCanvasFont(cddbuffer, fontname, thisFont, fontsize)
--DEV tryme (and get rid of the reset below)
                        fontstyle = thisFont
                    end if
--                      void = c_func(xSetBkColor, {mDC, bkColour})
--                      if lastFont!=chunk[c+3] then
--                          lastFont = chunk[c+3]
--                          if sequence(hFont) then
--                              void = selectObject(mDC, hFont[lastFont])
--                          end if
--                      end if
--                      c_proc(xTextOut, {mDC,x,y,mem+offset,chunklen})
--                      oRect = allocate_Rect()
--if unicodeflag=0 then
--                      if (c+4<chunkMax and not conti)
--                      or bkColour != ColourTab[Background] then
--                          poke4(oRect,{x,y,x+chunklen*CharWidth,y+CharHeight})
--                      else
--                          poke4(oRect,{x,y,ClipRect[3],y+CharHeight})
--                      end if
--                      void = c_func(xExtTextOut, {mDC,x,y,ETO_OPAQUE,oRect,mem+offset,chunklen,NULL})
--?{x,y,txt,chunklen}
                    cdCanvasText(cddbuffer,x,y,txt)
                    {w} = cdCanvasGetTextSize(cddbuffer,txt)
--                  x += chunklen*CharWidth
                    x += w
--                  if fontstyle!=thisFont then
--                      cdCanvasFont(cddbuffer, fontname, fontstyle, fontsize)
--                  end if
--else
----                        void = c_func(xGetTextExtentPoint32,{mDC,mem+offset*2,chunklen,pSize})
--                      pSize = allocate_Point()    -- (same size as SIZE)
--                      void = c_func(xGetTextExtentPoint32W,{mDC,mem+offset*2,chunklen,pSize})
--                      newx = x + peek4u(pSize+SIZE_cx)
--                      if (c+4<chunkMax and not conti)
--                      or bkColour != ColourTab[Background] then
--                          poke4(oRect,{x,y,newx,y+CharHeight})
--                      else
--                          poke4(oRect,{x,y,ClipRect[3],y+CharHeight})
--                      end if
--                      void = c_func(xExtTextOutW,{mDC,x,y,ETO_OPAQUE,oRect,mem+offset*2,chunklen,NULL})
--                      x = newx
--end if
--                      zeroDrawn = False
                        if not isWordWrapON then
--                          if x>ClipRect[3] then exit end if
                            if x>width then exit end if
                        end if
                        charsLeft -= chunklen
                    end if
                    offset += chunklen
--                  if isWordWrapON and conti then exit end if (no need to test isWordWrapON)
--                  if conti then exit end if   -- (only set if isWordWrapON)
--                  paintRqd += 1 -- NO, this endfor is more chunks same screen line...
                end for
--              if zeroDrawn or bkColour != ColourTab[Background] then
--                  void = c_func(xSetTextColor, {mDC, ColourTab[Background]})      -- removed 25/8.
--                  if isCY then
--                      bkColour = ColourTab[HighLine]
--                  else
--                      bkColour = ColourTab[Background]
--                  end if
--                  void = c_func(xSetBkColor, {mDC, bkColour})
----                    void = selectObject(mDC, hFont[lastFont])       -- no help for clipping problem
--                  chunklen = floor((ClipRect[3]-x)/CharWidth)+1
--                  if chunklen>0 then
----DEV use a permanent allocation of spaces? (clearly TextOut does not need a terminating null)
--                      mem2 = allocate_StringZ(repeat(' ',chunklen))
----                        c_proc(xTextOut, {mDC,x,y,mem,chunklen})
--                      oRect = allocate_Rect()
--                      poke4(oRect,{x,y,ClipRect[3],y+CharHeight})
--                      void = c_func(xExtTextOut, {mDC,x,y,ETO_OPAQUE,oRect,mem2,chunklen,NULL})
--                  end if
--              end if

--DEV make this an edit option? (Highlight whole line)
                if isCY 
                and charsLeft>0
                and ColourTab[Background]!=ColourTab[HighLine] then
                    chunklen = charsWide+Column-length(oneline)+1
                    if chunklen>0 then
                        bkColour = ColourTab[HighLine]
                        txt = repeat(' ',chunklen)
                        cdCanvasSetForeground(cddbuffer, bkColour)
                        atom {xmin, xmax, ymin, ymax} = cdCanvasGetTextBox(cddbuffer, x, y, txt)
                        cdCanvasBox(cddbuffer, xmin, xmax, ymin, ymax)
                    end if
                end if

                paintRqd += 1
--              y += CharHeight
end if
            if line=CursorY+1 then
                -- set blinking cursor info
--              if unicode then
--              {cursorx} = cdCanvasGetTextSize(cddbuffer,txt)
--              else
                cursorx = charwidth*(marginRqd+CursorX-Column)+1
--              end if
--              cursory = y-charheight/8
                cursory = height-(CursorY-TopLine+0.875)*charheight
                if cursorc=0 then
                    IupSetAttribute(cursorblink,"RUN","YES")
                end if
                cdCanvasSetForeground(cddbuffer, CD_BLACK)
                cdCanvasLine(cddbuffer, cursorx, cursory-charheight*0.2, cursorx, cursory+charheight*0.8)
--              cursorc = CD_BLACK
                cursorc = CD_GRAY
--              tipline = line
            end if
            line += 1
    if RotateBackground then
        backgroundidx += 1
        if backgroundidx>length(backgrounds) then
            backgroundidx = 1
        end if
--      cdCanvasSetBackground(cddbuffer, backgrounds[backgroundidx])
    end if

        end for

        if tip_visible then
--/*
    CD_RED          = #FF0000,
    CD_DARK_RED     = #800000,
    CD_GREEN        = #00FF00,
    CD_DARK_GREEN   = #008000,
    CD_BLUE         = #0000FF,
    CD_DARK_BLUE    = #000080,
    CD_YELLOW       = #FFFF00,
    CD_DARK_YELLOW  = #808000,
    CD_MAGENTA      = #FF00FF,
    CD_DARK_MAGENTA = #800080,
    CD_CYAN         = #00FFFF,
    CD_DARK_CYAN    = #008080,
    CD_WHITE        = #FFFFFF,
    CD_BLACK        = #000000,
    CD_DARK_GRAY    = #808080,
    CD_GRAY         = #C0C0C0,
    CD_PARCHMENT    = #FFFFE0,

--*/
--          cdCanvasFont(cddbuffer, "Consolas", CD_PLAIN, floor(fontsize*0.75))
--          cdCanvasFont(cddbuffer, "Consolas", CD_ITALIC, floor(fontsize*0.75))
            cdCanvasFont(cddbuffer, fontname, CD_ITALIC, floor(fontsize*0.75))

--          cdCanvasSetForeground(cddbuffer, CD_PARCHMENT)
--          cdCanvasSetForeground(cddbuffer, CD_DARK_GRAY)
--          cdCanvasSetForeground(cddbuffer, #E0E0E0)
            x = cursorx
            y = floor(cursory-charheight*0.75*7/8)
            integer cmc8 = floor(cursory-charheight/8)
            if (CursorY-TopLine)>linesPerPage/2 then
                y += floor(charheight*1.75)+2
                cmc8 += floor(charheight*1.75)+2
            end if
            {width, height} = cdCanvasGetTextSize(cddbuffer,"this is a tip")
--?{x,y,width,height}
--DEV it is xmin,xmax, ymin,ymax!!
--          cdCanvasBox(cddbuffer, x, y, x+width, y+height) 
--DEV rounded rect...
            cdCanvasSetForeground(cddbuffer, #A0A0A0)
            cdCanvasBox(cddbuffer, x+2, x+width+2, cmc8-2, cmc8-height-2)
            cdCanvasSetForeground(cddbuffer, #E0E0E0)
            cdCanvasBox(cddbuffer, x, x+width, cmc8, cmc8-height)
            cdCanvasSetForeground(cddbuffer, CD_DARK_BLUE)
            cdCanvasText(cddbuffer,x,y,"this is a tip")
--          cdCanvasText(cddbuffer,cursorx,cursory-charheight,"this is a tip")
--          cdCanvasSetBackground(cddbuffer, CD_GRAY)
--          cdCanvasFont(cddbuffer, "Consolas", CD_PLAIN, fontsize)
            cdCanvasFont(cddbuffer, fontname, CD_PLAIN, fontsize)
        end if

        if rebuildbCfwdAtEnd then
            --DEV see IDLE_ACTION
--          setText(SB6(->sbmsg),"rebuilding bCfwd")
            IupSetStrAttribute(sbmsg,"TITLE","rebuilding bCfwd")
            rebuildbCfwd(length(filetext[currfile]))
--          setText(SB6(->sbmsg),"")
            IupSetStrAttribute(sbmsg,"TITLE","")
        end if

        -- set scrollbar info
--/*
YMIN
--set DY to linesPerPage (or crash if not)
--set YMAX to file length, YMIN to 1  ""
--*/
--?{linesPerPage,length(text),TopLine}
--?{{IupGetInt(canvas,"YMIN"),IupGetInt(canvas,"YMAX"),IupGetInt(canvas,"DY"),IupGetInt(canvas,"POSY")},{0,length(text)+1,linesPerPage,TopLine}}

--DEV/UGH. (esp IupRedraw) Triggers 5 calls to appUpdateRender() on startup, 3 on tab switch. But at least it works...
        IupSetInt(canvas,"POSY",TopLine)

if IupGetInt(canvas,"YMIN")!=0
or IupGetInt(canvas,"YMAX")!=length(text)+1
or IupGetInt(canvas,"DY")!=linesPerPage then
--or IupGetInt(canvas,"POSY")!=TopLine then
        IupSetInt(canvas,"YMIN",0)
        IupSetInt(canvas,"YMAX",length(text)+1)
        IupSetInt(canvas,"DY",linesPerPage)
--      IupSetInt(canvas,"POSY",TopLine)
--      IupUpdate(dlg)
-- removed (on a whim) 1/9/16... seems fine...
-- 1/10/16: needed if the above changes scrollbar visibility
        IupRedraw(dlg,1)
end if
--      if linesPerPage>=length(text) then
----            IupUpdate(dlg)
----            IupHide(dlg)
----            IupShow(dlg)
--trace(1)
--      end if

--  else
--      --DEV clear scrollbar info?
    end if
    if cursorx=-1 then
        if cursorc!=0 then
            -- disable cursor when last tab closed
            cursorc = 0
            IupSetAttribute(cursorblink,"RUN","NO")
        end if
    end if

    cdCanvasFlush(cddbuffer)
    paintRqd = 0
--added 30/12/17...
    update_statusbar()
end procedure

--function redraw_cb(Ihandle /*ih*/, integer /*x*/, integer /*y*/)
function redraw_cb(Ihandle /*ih*/, atom /*x*/, atom /*y*/)
    appUpdateRender()
    return IUP_DEFAULT
end function

--without trace
function resize_cb(Ihandle /*ih*/, integer width, integer height)
--?"resize_cb"
    if IupGetInt(tbox,"VALUE")!=0 then
        -- maintain file panel width (as best we can)
        IupSetInt(tbox,"VALUE", floor(tboxv*1000/width))
    end if
--?linesPerPage
--?IupGetAttribute(dlg,"SIZE")
--  appUpdateRender()
--DEV
--  integer {width, height} = cdCanvasGetSize(cddbuffer) -- (nb post-cdCanvasActivate)
--  linesPerPage = ceil(height/charheight)
--?{height,charheight,linesPerPage}
--  appUpdateRender()
--/*
--?{width, height}
    linesPerPage = 0
    for i=charheight-1 to floor(height+charheight/2) by charheight do
        linesPerPage += 1
    end for
--*/
    return IUP_DEFAULT
end function
--with trace

function map_cb(Ihandle ih)
    cdcanvas = cdCreateCanvas(CD_IUP, ih)
    cddbuffer = cdCreateCanvas(CD_DBUFFER, cdcanvas)
    --DEV from settings:
    cdCanvasSetBackground(cddbuffer, CD_GRAY)   -- (affects cdCanvasClear() only)
    paintall()
--  cdCanvasActivate(cddbuffer)
--  cdCanvasClear(cddbuffer)
--  cdCanvasFlush(cddbuffer)

    cdCanvasSetForeground(cddbuffer, CD_BLACK)
--  cdCanvasFont(cddbuffer, "Courier", CD_PLAIN, fontsize)
--  cdCanvasFont(cddbuffer, "Consolas", CD_PLAIN, fontsize)
    cdCanvasFont(cddbuffer, fontname, CD_PLAIN, fontsize)
    fontstyle = CD_PLAIN
--  cdCanvasFont(cddbuffer, fontname, fontstyle, fontsize)
    {charwidth,charheight} = cdCanvasGetTextSize(cddbuffer,"I")
--?{charwidth,charheight}
    cdCanvasSetLineWidth(cddbuffer, 2) 
    return IUP_DEFAULT
end function

function unmap_cb(Ihandle /*ih*/)
    cdKillCanvas(cddbuffer)
    cdKillCanvas(cdcanvas)
    return IUP_DEFAULT
end function

--function tabfocus_cb(Ihandle /*ih*/)
----    appUpdateRender()
------  return IUP_CONTINUE
--?"tabfocus_cb"
--  IupSetFocus(canvas)
----    return IUP_DEFAULT
----    return IUP_CONTINUE
--  return IUP_IGNORE
--end function

global
procedure add_tab(integer opening, string path="", string title=untitled, sequence text={}, sequence linelengths={}, integer encoding=ENC_NONE)

--Ihandle fill = 
--  IupSetAttribute(fill, "EXPAND", "HORIZONTAL")

Ihandle tab = IupHbox({IupFill()})
--Ihandle tab = IupHbox({}) -- (nope)
--Ihandle tab = IupFill()   -- (nope)
--Ihandle tab = IupLabel("")    -- (nope)

    IupSetAttributes(tab, "TABSIZE=4, EXPAND=YES, VISIBLE=YES")
    IupSetAttribute(tab, "TABTITLE", title)
--  IupSetStrAttribute(tab, "TABIMAGE", get_image("PNG_FileNew"))
    IupSetStrAttribute(tab, "TABIMAGE", get_image("PNG_FileSaved"))
--  IupSetCallback(tab, "GETFOCUS_CB", Icallback("tabfocus_cb"))

    IupAppend(tabs, tab)
    IupMap(tab)
--VALUE_HANDLE??
    IupSetAttributeHandle(tabs, "VALUE", tab)
--?tab
    if length(text)=0 then
--DEV (temp)
--      if length(filenames)=0 then
--          text = {"one","two","three"}
--          linelengths = {0,0,0,2,0,1}
--      else
--          text = {"four","five","six"}
--          linelengths = {0,0,0,1,2}
--      end if
        linelengths = {1}
--      text = {{}}
        text = {""}
    end if
    filenames = append(filenames,title)
--DEV if length(path)=0 then get from currfile/tabfile/current_dir
    if length(path)=0 then
        if tabfile then
            path = filepaths[tabfile]
        elsif currfile then
            path = filepaths[currfile]
        else
--          path = current_dir()
            path = get_proper_dir(".")
        end if
    end if
    if find(path[$],`\/`)=0 then ?9/0 end if
    filepaths = append(filepaths,path)
    filetext = append(filetext,text)
    unicodefile = append(unicodefile,encoding)
    actionptr = append(actionptr,0)
    actions = append(actions,{})
    actionsave = append(actionsave,0)
    bookmarks = append(bookmarks,repeat(0,length(text)))
    filelinelengths = append(filelinelengths,linelengths)
    routines = append(routines,0)
--?filecursel
    filecursel = append(filecursel,{0,0,0,0,0,0,0,0,0,0,0})
--?filecursel
    filedt = append(filedt,0)
    bCfwds = append(bCfwds,0)
--/* (readFile)
C:\Program Files (x86)\Phix\demo\edix\crud.exw:5230 sequence linelengths
C:\Program Files (x86)\Phix\demo\edix\crud.exw:5352     linelengths = repeat(0,80)
C:\Program Files (x86)\Phix\demo\edix\crud.exw:5421         if linelength>=length(linelengths) then
C:\Program Files (x86)\Phix\demo\edix\crud.exw:5422             linelengths &= repeat(0,linelength-length(linelengths)+1)
C:\Program Files (x86)\Phix\demo\edix\crud.exw:5424         linelengths[linelength+1] = linelengths[linelength+1] + 1
    linelengths[1] = 1
    return {""}
--*/
    integer fidx = length(filenames)
    IupSetInt(tab,"FILEIDX",fidx)
    if not opening then
        changeTo(fidx,-1)   -- (tab pos already set - by IupSetAttributeHandle(tabs, "VALUE", tab) above)
        IupRefresh(tabs)
        appUpdateRender()
--  end if

--  IupSetAttribute(tab, "INSERT0", text)
--  IupSetAttribute(tab, "UNDO", NULL)
--  IupSetAttribute(tab, "SAVEDSTATE", NULL)
--  IupSetCallback(tab, "MARGINCLICK_CB", Icallback("marginclick_cb"))
--  IupSetCallback(tab, "SAVEPOINT_CB", Icallback("savepoint_cb"))

--X IupSetCallback(tab, "K_cS", Icallback("save_cb"))

--  return tab

        if match(untitled,title)!=1
        and path!="" then
            IupConfigRecentUpdate(config, path&title);
        end if
    end if
end procedure

global function openFile(integer opening, string filepath, integer encoding)
    string title = get_file_name(filepath)
--  string path = filename[1..length(filename)-length(title)]
--  string path = get_file_path(filepath,0)
    string path = get_file_path(filepath,dropslash:=false)
    StopMacroLearn(1)
    integer fdx = 0
    for i=1 to length(filepaths) do
        if filepaths[i]=path
        and filenames[i]=title then
            if opening then
                fdx = i
                exit
            end if
            if i!=currfile then
                changeTo(i,findtab(i))
            end if
            return 3    -- signal a "switch".
        end if
    end for
    object res = readFile(filepath)
    if sequence(res) then
        sequence {text,linelengths} = res
        if encoding=-1 then
            encoding = unicodeflag
--?{"encoding (edix.exw line 4528)",encoding}
        end if
        if opening then
            filetext[fdx] = text
            bookmarks[fdx] = repeat(0,length(text))
            filelinelengths[fdx] = linelengths
            unicodefile[fdx] = encoding
--disney help...
            if fdx==currfile then
--?{"changeto",fdx,currfile} -- 1,1
                changeTo(fdx,findtab(fdx))
            end if
        else
            add_tab(opening, path, title, text, linelengths, encoding)
--          add_tab(opening, path, title, text, linelengths, unicodeflag)
        end if
        return true
    end if
    return false
end function

--function item_new_action_cb(Ihandle /*item_new*/)
function new_cb(Ihandle /*item_new*/)
--?"new_cb"
--  if save_check(item_new) then
--      newFile("",{""},{1},0)
--DEV:
--  if tabfile!=0 then  -- (if!=0, New/Open use dir from that tab [it's a FILEIDX])
----?tabfile
--  end if
    savecurr()
    add_tab(0)
--  end if
    return IUP_DEFAULT;
end function
constant cb_new = Icallback("new_cb")

--function item_open_action_cb(Ihandle /*item_open*/)
function open_cb(Ihandle /*item_open*/)
--?"open"
--Ihandln filedlg;
--string d
--
--  if save_check(item_open) then
--      d = IupConfigGetVariableStr(config, "MainWindow", "LastDirectory");
--
--      filedlg = IupFileDlg();
--      IupSetAttribute(filedlg, "DIALOGTYPE", "OPEN");
--      IupSetAttribute(filedlg, "EXTFILTER", "Text Files|*.txt|All Files|*.*|");
--      IupSetAttributeHandle(filedlg, "PARENTDIALOG", IupGetDialog(item_open));
--      IupSetStrAttribute(filedlg, "DIRECTORY", d);
--
--      IupPopup(filedlg, IUP_CENTERPARENT, IUP_CENTERPARENT);
--      if IupGetInt(filedlg, "STATUS")!= -1 then
--          string filename = IupGetAttribute(filedlg, "VALUE");
--          open_file(item_open, filename);
--
--          d = IupGetAttribute(filedlg, "DIRECTORY");
--          IupConfigSetVariableStr(config, "MainWindow", "LastDirectory", d);
--      end if
--
--      filedlg = IupDestroy(filedlg);
--  end if

Ihandln filedlg
--integer encoding = ENC_NONE
integer encoding = -1
--ENC_NONE  = 0,
--ENC_ANSI  = 1,    --DEV should be 0??
--ENC_UTF8  = 2,
--ENC_UTF16LE = 3,
--ENC_UTF16BE = 4   -- (rare case)
string filename = ""
--sequence text, linelengths

    integer c = iff(tabfile?tabfile:currfile) -- (deliberately not zeroed here)
    if UseNativeDialog
    and platform()=WINDOWS then
        atom hWnd = IupGetAttributePtr(dlg,"HWND")
        object res
--      if 0 then
--          res = newGetOpenFileName(hWnd,filters,{2,"exw"})
--      else
--          res = newGetOpenFileName(hWnd,buildFileFilter2(),{2,"exw"},{filepaths[c]})
            object fpc = iff(c?{filepaths[c]}:NULL)
            res = newGetOpenFileName(hWnd,buildFileFilter2(),NULL,fpc)
--      end if
        if sequence(res) then
            {encoding,filename} = res
--30/12/17:
            encoding -= 1
--?{"encoding (edix.exw line 4602)",encoding}
--/*

            integer r1 = res[1]
--global constant ENC_NONE  = 0,
--              ENC_ANSI    = 1,
--              ENC_UTF8    = 2,
--              ENC_UTF16LE = 3,
--              ENC_UTF16BE = 4     -- (rare case)
--
--global constant Encodings = {"ANSI","UTF8","UTF16LE","UTF16BE"}
            if r1=ENC_NONE then
                res[1] = "0 (ENC_NONE)"
            else
                res[1] = sprintf("%d (%s)",{r1,Encodings[r1]})
            end if
--*/
        end if
--/*

--global function newGetOpenFileName(atom hWnd=NULL, object filters=NULL, object extension=NULL, object default_folder=NULL, integer encoding=1)
--
-- hWnd is, obviously enough, the [optional] handle of a window you would like to act as the parent of the open/save dialog.
-- filters can be NULL or something like { {"Text Document (*.txt)", "*.txt"}, 
--                                         {"All Documents (*.*)", "*.*"} }
-- extension can be NULL or {idx,"doc"[,flags]} or {idx,NULL[,flags]}:
--  idx is an index to filters, to set the default type index. If filters is NULL then idx is ignored, conversely if extension is 
--  NULL then an idx of 1 is assumed. The second "doc" part specifies a default file extension, ie/eg "fred" is actually saved as 
--  "fred.doc" (and is not worth setting during file open). Note that manually changing the filter drop-down (if present) will
--  automatically override this. The third "flags" part, if present, allows additional options such as FOS_ALLOWMULTISELECT.
-- Specifying a default folder of say "C:\temp" causes the standard behaviour of setting the folder to use if there is not a
--  recently used folder value available. Specifying a default folder of {"C:\temp"} overrides any recently used folder value.
--  Edita, for example, uses the latter to force open/save in the directory associated with the current file tab, however most
--  applications would not benefit from such brutally forceful behaviour.
-- Specifying an encoding of 0 suppresses the encoding drop-down, otherwise specify 1..4 for default(ansi)/utf8/utf16le/utf16be.
--  eg .reg files should [as opposed to must] always be stored as utf16le; so removing the option avoids potential mishap,
--  or .avi/mp3/jpg files: anything selected would have to be completely ignored anyway. Note that when encoding is set 0,
--  the result is a single string, whereas when left as the default or explicitly specified this returns {encoding,name},
--  or 0 if the user cancels the operation. Note that FOS_ALLOWMULTISELECT can only be specified on open (not save), and 
--  both automatically suppresses the custom encoding drop-down, and returns an array of strings, with no encoding flags.
--
-- Returns: 0                        - if user cancels the operation
--          {"name","name","name"}   - if (not cancelled and) FOS_ALLOWMULTISELECT is specified
--          "name"                   - if (not cancelled and not FOS_ALLOWMULTISELECT and) encoding is set to 0
--          {encoding(=1..4),"name"} - if none of the above are true
--
    return filedialog(OPEN,hWnd,filters,extension,default_folder,encoding)
end function

--pp(newGetOpenFileName(NULL,NULL,{0,0,FOS_ALLOWMULTISELECT}))
--pp(newGetOpenFileName(NULL,NULL,{0,0,0}))
--pp(newGetOpenFileName(getHwnd(id),NULL,{0,0,0}))
--pp(newGetOpenFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}}))
--pp(newGetOpenFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{1,"txt"}))
--pp(newGetOpenFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{2,NULL}))  -- fine
--pp(newGetSaveFileName(NULL))
--pp(newGetSaveFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{1,"txt"}))
--pp(newGetSaveFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{2,NULL}))
--pp(newGetSaveFileName(NULL,NULL,NULL,`C:\Windows`,2))
--pp(newGetSaveFileName(NULL,NULL,NULL,`C:\Windows`,0))
--trace(1)
--  res = newGetSaveFileName(NULL,NULL,NULL,`C:\Program Files (x86)\Phix\demo\win32dibademo`,0)
--  res = newGetSaveFileName(NULL,NULL,NULL,`C:\Program Files (x86)\Phix\demo\win32dibademo`)
        pp(res)
        {} = wait_key()
--*/
    else
        filedlg = IupFileDlg()

--18/11/17:
--      IupSetAttributePtr(filedlg, "PARENTDIALOG", dlg)
        IupSetAttributeHandle(filedlg, "PARENTDIALOG", dlg)
--      IupSetAttributes(filedlg, `DIALOGTYPE = SAVE, TITLE = "File Save"`)
        IupSetAttribute(filedlg, "TITLE", "Open")
--      IupSetAttributes(filedlg, `FILTER = " .bmp", FILTERINFO = "Bitmap Files"`)
--      IupSetAttributes(filedlg, `FILTER = "*.bmp", FILTERINFO = "Bitmap Files"`)
        IupSetAttribute(filedlg, "EXTFILTER", "Text files|*.txt;*.exw|All Files|*.*|")
        IupSetInt(filedlg, "FILTERUSED", 2)

        IupPopup(filedlg, IUP_CENTER, IUP_CENTER)

        integer status = IupGetInt(filedlg, "STATUS")
        if status=0 then    -- normal, existing file
            filename = IupGetAttribute(filedlg, "VALUE")
        end if
--      switch status do
--
--          case 1 then
--              IupMessage("New file",IupGetAttribute(filedlg, "VALUE"))
--
--          case 0 then
--              IupMessage("File already exists",IupGetAttribute(filedlg, "VALUE"))
--
--          case -1 then
--              IupMessage("IupFileDlg","Operation Canceled")
--      end switch

        filedlg = IupDestroy(filedlg)
    end if
    if length(filename) then
        {} = openFile(0,filename,encoding)
--/*
--      {text,linelengths} = read_file(filename)
        {text,linelengths} = readFile(filename)
        string title = get_file_name(filename)
--      string path = filename[1..length(filename)-length(title)]
--      string path = get_file_path(filename,0)
        string path = get_file_path(filename,dropslash:=false)
        for i=1 to length(filepaths) do
            if filepaths[i]=path
            and filenames[i]=title then
                if i!=currfile then changeTo(i) end if
--              return 3    -- let eacons.ew know it is a "switch".
                return IUP_DEFAULT
            end if
        end for
        add_tab(0,path, title, text, linelengths, encoding)
--*/
    end if
    return IUP_DEFAULT;
end function
constant cb_open = Icallback("open_cb")

Ihandle file_new, file_open, file_reopen, file_save, file_saveas, file_list, 
        file_close, file_prntp, file_print, recent_menu, file_recent, file_exit

function reopen_cb(Ihandle /*file_reopen*/)
--  integer c = iff(tabfile?tabfile:currfile) -- (no need to zero here)
    integer c = currfile -- (there is no reopen on the tab menu [DEV?])
    object res = readFile(filepaths[c]&filenames[c])
    if sequence(res) then
        sequence {text,linelengths} = res
        filetext[c] = text
        unicodefile[c] = unicodeflag
        actionptr[c] = 0
        actions[c] = {}
        actionsave[c] = 0
        bookmarks[c] = repeat(0,length(text))
        filelinelengths[c] = linelengths
        routines[c] = 0
        filecursel[c] = {0,0,0,0,0,0,0,0,0,0,0}
        filedt[c] = 0
        bCfwds[c] = 0
--      if c=currfile then
            restcursel()
--      else
--          changeTo(c)
--      end if
--DEV test:
--      if c=currfile then
            setSaveIcon()
--      else
--          for pos=0 to IupGetInt(tabs,"COUNT")-1 do
--              Ihandle tab = IupGetChild(tabs, pos)
--              if IupGetInt(tab,"FILEIDX")=c then
--                  setSaveIcon(pos,tab)
--                  exit
--              end if
--          end for
--      end if
        appUpdateRender()
    else
        IupMessage("Error","cannot read file")
    end if
--DEV tab/diuscard changes popup dialog, action on "OK" is:
--sequence text, linelengths
--      {text,linelengths} = readFile(filename)
--  filetext[] = text
--  unicodefile[] = encoding
--  actionptr[] = 0
--  actions[] = {}
--  actionsave[] = 0
--  filelinelengths[] = linelengths
--  bookmarks = repeat(0,length(text))
--  routines = 0
--  filedt = 0 [??]
-- topline=1, cx=1, cy=1
--  appUpdateRender() [or changeTo()]

    return IUP_DEFAULT;
end function
constant cb_reopen = Icallback("reopen_cb")

--procedure show_tab_info()
--  sequence mtabs = {}, fidx = {}, names = {}, names2 = {}
--  for pos=0 to IupGetInt(tabs,"COUNT")-1 do
--      Ihandle mtab = IupGetChild(tabs, pos)
--      mtabs = append(mtabs,mtab)
--      fidx = append(fidx,IupGetInt(mtab,"FILEIDX"))
--      names = append(names,IupGetAttribute(mtab, "TABTITLE"))
--      names2 = append(names2,IupGetAttributeId(tabs, "TABTITLE", pos))
--  end for
--  ?{mtabs,fidx,names,names2}
--end procedure

function saveas_cb(Ihandle /*item_saveas*/)
    {} = saveFileAs()
    return IUP_DEFAULT
end function
constant cb_saveas = Icallback("saveas_cb")

--DEV
--include src\filelist.e
--function filelist_cb(Ihandle /*item_filelist*/)
--?"filelist_cb"
--  return IUP_DEFAULT;
--end function
--constant cb_filelist = Icallback("filelist_cb")

function save_cb(Ihandle item_save)
integer c = iff(tabfile?tabfile:currfile) -- (deliberately not zeroed here)
    if c!=0 then
        if match(untitled,filenames[c]) then
            return saveas_cb(item_save)
        end if
        if actionsave[c]!=actionptr[c] then
            {} = saveFile()
        end if
    end if
    return IUP_DEFAULT;
end function
constant cb_save = Icallback("save_cb")

function tabclose_cb(Ihandle ih, integer pos)
-- (NB: you can right-click close on any tab, not just currfile)
Ihandle tab = IupGetChild(ih, pos)
Ihandln ntab = IupGetChild(ih, pos+1)
    if ih!=tabs then ?9/0 end if -- sanity check
    tip_visible = 0
    if ntab=NULL and pos>0 then
        ntab = IupGetChild(ih, pos-1)
        pos -= 2 -- (as we use pos+1 below)
    end if
    integer delidx = IupGetInt(tab,"FILEIDX")
    if delidx=currfile
    and actionsave[currfile]!=actionptr[currfile] then
        --DEV save ...
--      saveFile(?)
--DEV we do want to be able to close without saving the file... (maybe we need a prompt here)       [***DEV/YES, THIS IS BROKEN***]
        if not saveFile() then return IUP_IGNORE end if
    end if

    removelast(delidx)

    IupHide(tab)    -- (in case it is the last one, see appUpdateRender)

    if ntab=NULL then
        IupSetAttribute(dlg,"TITLE","Edix")
    else
--      IupSetInt(tabs,"VALUEPOS",pos+1)
        integer nidx = IupGetInt(ntab,"FILEIDX")
        changeTo(nidx,pos+1)
    end if
--DEV necessary? or ...?
    appUpdateRender()
--  IupUpdate(dlg)
--  IupUpdate(tabs)
--  IupUpdate(canvas)
    -- finally, let the tab close
    return IUP_CONTINUE
end function

function close_cb(atom /*self*/)
integer c
    if currfile then
        if tabfile then -- (from tab_rightclick_cb, via IupPopup)
            c = tabfile
        else
            c = currfile        
        end if
        -- (Aside: if you right-click on the current tab, you will get
        --         a non-zero tabfile here that happens to be currfile)
        if c=currfile then
            -- save? [DEV, yes/no/cancel]
?"save??"
        end if
    
--DEV tryme/findtab()...
        for pos=0 to IupGetInt(tabs,"COUNT")-1 do
            Ihandln tab = IupGetChild(tabs, pos)
            if IupGetInt(tab,"FILEIDX")=currfile then
                {} = tabclose_cb(tabs, pos)
                tab = IupDestroy(tab)
                exit
            end if
        end for
    end if
--      IupAlarm( "Action", "Close", "OK" )

--  if skip_next_event() then
--      return IUP_IGNORE
--  end if
--
--  atom pos = IupGetInt(tabs, "VALUEPOS")
--  if pos=IUP_INVALID then
--      -- nothing selected
--      return IUP_IGNORE
--  end if
--
--  atom sci = IupGetAttributeHandle(tabs, "VALUE")
--  atom modified = IupGetInt(sci, "SAVEDSTATE")
--
--  if modified then
--      -- ask the user to save
--
--      sequence name = "Untitled"
--      sequence path = IupGetAttribute(sci, "PATH")
--
--      if length(path) then
--          name = get_file_name(path)
--      end if
--
--      atom response = confirm_close(name)
--
--      if response=1 then
--          -- user wants to save
--
--          {} = save_cb(self)
--          modified = IupGetInt(sci, "SAVEDSTATE")
--          if modified then
--              -- user cancelled save
--              return IUP_IGNORE
--          end if
--
--      elsif response=3 then
--          -- user cancelled prompt
--          return IUP_IGNORE
--
--      end if
--
--  end if
--
--  -- remove the tab
--  sci = IupDestroy(sci)
--  IupRefreshChildren(tabs)
--
--  atom count = IupGetChildCount(tabs)
--  if count!=0 then
--      -- update the tab selection
--
----        while pos>=count do
--      if pos>=count then
--          -- pos is out of bounds
----            pos -= 1
--          pos = count-1
----        end while
--      end if
--
--      sci = IupGetChild(tabs, pos)
--      IupSetAttributeHandle(tabs, "VALUE", sci)
--
--      IupRefresh(tabs)
--      IupSetFocus(sci)
--
--  end if
--
    return IUP_IGNORE
end function
constant cb_close = Icallback("close_cb")

function preview_cb(atom /*self*/)
--(Printing should be done as one function with page setup/preview/print buttons, and 
-- all the rest, such as ->pdf, ->html, ->file, change printer, copies, duplex, ...)
?"preview_cb" --DEV
    return IUP_IGNORE
end function
constant cb_preview = Icallback("preview_cb")

function print_cb(atom /*self*/)
--(Printing should be done as one function with page setup/preview/print buttons, and 
-- all the rest, such as ->pdf, ->html, ->file, change printer, copies, duplex, ...)
?"print_cb" --DEV
    return IUP_IGNORE
end function
constant cb_print = Icallback("print_cb")

--DEV make the 40 configurable
--constant SessionLimit = 40
constant SessionLimit = 0   -- while developing!

function exit_cb(Ihandle /*item_exit*/)
--  if not save_check(item_exit) then
--      return IUP_IGNORE;  /* to abort the CLOSE_CB callback */
--  end if

    if find(1,backpurge) then
        for c=1 to length(backpurge) do
            if backpurge[c] then
                string backdir = backdirs[c]
                backpurge[c] = 0
                --DEV prompt: "Purge Backups?", backdir&"backup.NNNN", 
                --              [X] Repeat this action for sum(backpurge) other directories, 
                --              [ ] In future perform this action silently, 
                --              Yes?No?Cancel?Help
                object d = dir(backdir&"backup.????")
                if sequence(d) then
                    integer used = 0
                    for i=1 to length(d) do
                        if find('d',d[i][D_ATTRIBUTES]) then
                            string backname = d[i][D_NAME]
                            if length(backname)=11
                            and backname[1..7]="backup." then
                                if d[i][D_YEAR..D_MONTH]<=threemonthsago then
                                    if not remove_directory(backdir&backname,1) then
                                        --DEV retry?
                                        IupMessage("Backup Purge","Error removing "&backdir&backname)
                                        used = 0
                                        exit
                                    end if
                                else
                                    used += 1
                                    d[used] = d[i]
                                end if
                            end if
                        end if
                    end for
                    d = d[1..used]
                    d = sort(d)
                    for i=1 to length(d) do
                        string backname = d[i][D_NAME]
                        string newname = sprintf("backup.%04d",i)
                        if backname!=newname
                        and not rename_file(backdir&backname,backdir&newname) then
                            IupMessage("Backup Purge","Error renaming "&backdir&backname&" as "&newname)
                            exit
                        end if
                    end for
                end if
            end if
        end for
    end if

    savecursel()

--if USEINI then
    sequence fdii = {}
    integer newcurr = 0
--else
--  integer wasmax = IupConfigGetVariableInt(config,"Session","Max")
--  integer newmax = 0
--  integer newcur = 0  -- (note: this is a perfectly valid setting, for Max==0!)
--end if
--DEV NO: do this in tab order. Also, if >30 tabs, close any that have not been modified/inspected/erm...
--  for i=1 to length(filenames) do
    for t=0 to IupGetInt(tabs,"COUNT")-1 do
        Ihandle tab = IupGetChild(tabs, t)
        integer fidx = IupGetInt(tab,"FILEIDX")
        if SessionLimit=0 
        or filecursel[fidx][11]<SessionLimit then
            string filename = filenames[fidx]
            if match(untitled,filename)!=1 then
--if USEINI then
                fdii &= fidx
--              if fidx=currfile then newcur = length(fdii) end if
                if fidx=currfile then newcurr = length(fdii) end if
--else
--              newmax += 1
--              IupConfigSetVariableStrId(config,"Session","filepath",newmax,filepaths[fidx]&filename)
--              string curselstr = sprintf("{%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d}",filecursel[fidx])
--              IupConfigSetVariableStrId(config,"Session","cursel",newmax,curselstr)
--              if fidx=currfile then newcur = newmax end if
--end if
            end if
        end if
    end for
--if USEINI then
    saveINI(fdii,newcurr)
--else
--  IupConfigSetVariableInt(config,"Session","Max",newmax)
--  IupConfigSetVariableInt(config,"Session","current",newcur)
--  for i=newmax+1 to wasmax do
--      IupConfigSetVariableStrId(config,"Session","filepath",i,NULL)
--      IupConfigSetVariableStrId(config,"Session","cursel",i,NULL)
--  end for
--end if
    IupConfigDialogClosed(config, dlg, "MainWindow");
    integer errcode = IupConfigSave(config);
    if errcode!=0 then
        ?{"IupConfigSave",errcode}
        ?9/0
    end if
    config = IupDestroy(config);
    closeChm()
    return IUP_CLOSE;
end function
constant cb_exit = Icallback("exit_cb")

procedure F4key(integer ctrl, shift, alt)
    if ctrl then
        {} = close_cb(file_close)
    elsif alt then
        {} = exit_cb(file_exit)
        IupHide(dlg)
    else
        clearSelection()
        if isCurrLineColoured then paintCursorY() end if
        fdlg:F4diff(shift)
    end if
end procedure

function cut_cb(atom /*self*/)
    Clip(CUT,0)
    return IUP_IGNORE
end function
constant cb_cut = Icallback("cut_cb")

function cuta_cb(atom /*self*/)
    Clip(CUT,1)
    return IUP_IGNORE
end function
constant cb_cuta = Icallback("cuta_cb")

function cutp_cb(atom /*self*/)
    Clip(CUT,-1)
    return IUP_IGNORE
end function
constant cb_cutp = Icallback("cutp_cb")

function copy_cb(atom /*self*/)
    Clip(COPY,0)
    return IUP_IGNORE
end function
constant cb_copy = Icallback("copy_cb")

function copya_cb(atom /*self*/)
    Clip(COPY,1)
    return IUP_IGNORE
end function
constant cb_copya = Icallback("copya_cb")

function copyp_cb(atom /*self*/)
    Clip(COPY,-1)
    return IUP_IGNORE
end function
constant cb_copyp = Icallback("copyp_cb")

function paste_cb(atom /*self*/)
    Paste()
    return IUP_IGNORE
end function
constant cb_paste = Icallback("paste_cb")

function fname_cb(atom /*self*/)
    if currfile then
        string filename = filepaths[currfile] & filenames[currfile]
        IupSetAttribute(clipboard, "TEXT", NULL)    -- (as per docs)
        IupSetAttribute(clipboard, "TEXT", filename)
    end if
    return IUP_IGNORE
end function
constant cb_fname = Icallback("fname_cb")

function delete_cb(Ihandle /*item_delete*/)
    if selON then
--      backdel(K_DEL,0,0,0)
        {} = deleteSelection()
    end if
    return IUP_DEFAULT;
end function
constant cb_delete = Icallback("delete_cb")

function undo_cb(atom /*self*/)
    UndoRedo(UNDO)
    return IUP_IGNORE
end function
constant cb_undo = Icallback("undo_cb")

function redo_cb(atom /*self*/)
    UndoRedo(REDO)
    return IUP_IGNORE
end function
constant cb_redo = Icallback("redo_cb")

include src\cflow.e

procedure bracket(integer base, /*ctrl*/, shift, alt)
--DEV needs routines[currfile] to be set...
--?"bracket"
--trace(1)
    if selON then
        if selY = CursorY then
            CursorX = 0
            clearSelection()
        end if
    end if
--  startSelection(shift,menu)
    startSelection(shift,alt)
    integer d = iff(base='['?-1:+1)
    ctrlBracket(d)
    if cbY = CursorY
    and cbX = CursorX
    and CursorX then
        integer wasCursorX = CursorX
        CursorX = 0
        ctrlBracket(d)
        if cbY=CursorY then  cbX = wasCursorX  end if
    end if
    jumpTo(cbX,cbY)
end procedure

function nextcs_cb(Ihandle /*edit_nextcs*/)
    bracket(']',0,0,0)
    return IUP_DEFAULT;
end function
constant cb_nextcs = Icallback("nextcs_cb")

function prevcs_cb(Ihandle /*edit_prevcs*/)
    bracket('[',0,0,0)
    return IUP_DEFAULT;
end function
constant cb_prevcs = Icallback("prevcs_cb")

procedure zoom(integer adj)
    if adj>0 or fontsize>1 then
        fontsize += adj
        cdCanvasFont(cddbuffer, fontname, CD_PLAIN, fontsize)
        fontstyle = CD_PLAIN
--      cdCanvasFont(cddbuffer, fontname, fontstyle, fontsize)
        {charwidth,charheight} = cdCanvasGetTextSize(cddbuffer,"I")
        appUpdateRender()
    end if
end procedure

function zoomin_cb(atom /*self*/)
    zoom(+1)
    return IUP_IGNORE
end function
constant cb_zoomin = Icallback("zoomin_cb")

function zoomout_cb(atom /*self*/)
    zoom(-1)
    return IUP_IGNORE
end function
constant cb_zoomout = Icallback("zoomout_cb")

Ihandln backtimer   -- (NULL if disabled)
sequence rotate_images
integer rot_idx = 0

function backtimer_cb(Ihandle /*ih*/)
    rot_idx += 1
    if rot_idx>length(rotate_images) then
        rot_idx = 1
    end if
    IupSetStrAttribute(toolb_back, "IMAGE", rotate_images[rot_idx])
    return IUP_DEFAULT
end function
constant cb_backtimer = Icallback("backtimer_cb")

--  IupSetAttribute(backtimer,"RUN","YES")

function backoff_cb(atom /*self*/)
    if IupAlarm("Disable background processing?",
                "Background processing should not normally affect performance.\n"&
                "It scans source files, saving details for project trees, help lookups, etc.\n"&
                "If you disable background processing it remains off until Edix is restarted.",
                "Disable","Cancel")=1 then
        IupSetInt(toolb_back,"ACTIVE",0)
        IupSetAttribute(backtimer,"RUN","NO")
        backtimer = IupDestroy(backtimer)
    end if
    return IUP_IGNORE
end function
constant cb_backoff = Icallback("backoff_cb")

include src/run.e as run

procedure F5key(integer ctrl, shift)
    if actionsave[currfile]!=actionptr[currfile] then
        if not saveCurrAs() then return end if
    end if
    run:F5run(ctrl,shift)
end procedure

function run_cb(atom self)
integer ctrl = IupGetInt(self,"ID"), 
--      shift = IupGetGlobal("SHIFTKEY")
        shift = IupGetInt(NULL,"SHIFTKEY")
    F5key(ctrl,shift)
    return IUP_IGNORE
end function
constant cb_run = Icallback("run_cb")

global function jumpToErrorInFile(sequence oneline, integer prompt)
-- prompt can take three values. 1: yes, 0: no, -1: return {file,line} if you can
integer k,l,cY
--5/1/18:
--...included by C:\Program Files (x86)\Phix\demo\libcurl\test.exw, line 4
    if not string(oneline) then oneline = utf32_to_utf8(oneline) end if
    if match("... called from ",oneline)=1 then
        oneline = oneline[17..length(oneline)]
    elsif match("...included by ",oneline)=1 then
        oneline = oneline[16..length(oneline)]
        k = match(", line ",oneline)
        if k then
            oneline[k..k+6] = ":"
        end if
    end if
    if match("Warning: ",oneline)=1 then
        if length(oneline)>=11 
        and oneline[11]=':' then
            oneline = oneline[10..length(oneline)]
        else
            oneline = filepaths[currfile]&oneline[10..length(oneline)]
        end if
--  elsif usegpp then
    else
        if equal(filenames[currfile],"ctrace.out")
        and match(filepaths[currfile],oneline)!=1 then
            oneline = filepaths[currfile]&oneline
        end if
--  elsif equal(LowerCase(filenames[currfile]),"ctrace.out")
--    and match(LowerCase(filepaths[currfile]),LowerCase(oneline))!=1 then
--      oneline = filepaths[currfile]&oneline
    end if
    while length(oneline) and oneline[1]=' ' do
        oneline = oneline[2..length(oneline)]
    end while
    if length(oneline)>2 and oneline[2]=':' then
        k = 3
    else
        k = 1
    end if
    while k<length(oneline) do
        if oneline[k]=':' then
            if k>=4 and equal(lower(oneline[k-3..k-1]),"exe") then
--DEV see if .exw is in same directory?
                if prompt=1 then
                    IupMessage(xl("Error occurred in executable"),
                               xl("To jump to the error line, the program being executed\n"&
                                  " must be source code, not bound/compiled."))
                end if
                return 0
            end if
            cY = 0
            l = k
            while l<length(oneline) and find(oneline[l+1],"0123456789") do
                l += 1
                cY = cY*10+oneline[l]-'0'
            end while
            if cY then
                if prompt=-1 then
                    return {oneline[1..k-1],cY}
                end if
--              if openFile(oneline[1..k-1],-1,isLegacyTabHandling) then
                if openFile(0,oneline[1..k-1],-1) then
                    if selON or isCurrLineColoured then
                        -- remove old currentline highlight
--28/12/2010
                        paintCursorY()
                        clearSelection()
                    end if
                    if cY>length(filetext[currfile]) then
                        if prompt<=0 then return 0 end if
                        IupMessage(xl("Warning"),xl("Error line past end of file"))
                        CursorY = 0
                    else
                        CursorY = cY-1
                    end if
                    CursorX = 0
                    selON = 0
                    forceCursorOnscreen()
--06/03/2010 (and above paintCursorY, which had been /replaced/ with clearSelection, resurrected)
                    if isCurrLineColoured then
                        paintCursorY()
                    end if
                    return 1
                end if
            end if
            exit
        end if
        k += 1
    end while
    if k=length(oneline) and oneline[k]=':' and prompt!=-1 then
--      if openFile(oneline[1..k-1],-1,isLegacyTabHandling) then
        if openFile(0,oneline[1..k-1],-1) then
            return 0
        end if
    end if
    if prompt=1 then
        IupMessage(xl("Couldn't capture error vectors"),
                   xl("Move cursor to cursor to correct line \n and then double click or press F12"))
    end if
    return 0
end function

procedure F12()
--?"F12"
    if currfile then
        string ext = get_file_extension(filenames[currfile])
        if find(ext,{"err","out"}) then
--          crashpath = filepaths[currfile]     -- added 18/01/2008
            {} = jumpToErrorInFile(filetext[currfile][CursorY+1],1)
        else
--?         string filepath = join_path({crashpath,"ex.err"})
            string filepath = join_path({filepaths[currfile],"ex.err"})
            if openFile(0,filepath,-1)=3 then
                {} = reopen_cb(file_reopen)
            end if
        end if
    end if
end procedure

function jerr_cb(atom /*self*/)
--?"jerr_cb" --DEV
    F12()
    return IUP_IGNORE
end function
constant cb_jerr = Icallback("jerr_cb")

include src/compare.e as comp

function comp_cb(atom /*self*/)
?"comp_cb" --DEV
--  comp:Compare()
    return IUP_IGNORE
end function
constant cb_comp = Icallback("comp_cb")

--/*
function dcmp_cb(atom /*self*/)
?"dcmp_cb" --DEV
    return IUP_IGNORE
end function
constant cb_dcmp = Icallback("dcmp_cb")
--*/

--/*
function fif_cb(atom /*self*/)
?"fif_cb" --DEV
--  atom pos = IupGetInt(tabs, "VALUEPOS")
--  if pos=IUP_INVALID then
--      -- nothing selected
--      return IUP_IGNORE
--  end if
--
--  atom sci = IupGetChild(tabs, pos)
--  sequence path = IupGetAttribute(sci, "PATH")
--  sequence name = get_file_name(path)
--
--  ? = get_file_path(path)
-- ...
    return IUP_IGNORE
end function
constant cb_fif = Icallback("fif_cb")
--*/

include src\htmlise.e as html

function html_cb(atom /*self*/)
--?"html_cb" --DEV
    html:htmliseEucode()
    return IUP_IGNORE
end function
constant cb_html = Icallback("html_cb")

function rein_cb(atom /*self*/)
--?"rein_cb" --DEV
    rein:ReIndent()
    return IUP_IGNORE
end function
constant cb_rein = Icallback("rein_cb")

function cca_cb(atom /*self*/)
?"cca_cb" --DEV
    return IUP_IGNORE
end function
constant cb_cca = Icallback("cca_cb")

function qjmp_cb(atom /*self*/)
    onClickToolQjmp()
    return IUP_IGNORE
end function
constant cb_qjmp = Icallback("qjmp_cb")

function rcvr_cb(atom /*self*/)
?"rcvr_cb" --DEV
    return IUP_IGNORE
end function
constant cb_rcvr = Icallback("rcvr_cb")

function design_cb(atom /*self*/)
?"design_cb" --DEV
    return IUP_IGNORE
end function
constant cb_design = Icallback("design_cb")

function dvwr_cb(atom /*self*/)
?"dvwr_cb" --DEV
    return IUP_IGNORE
end function
constant cb_dvwr = Icallback("dvwr_cb")

function dvfy_cb(atom /*self*/)
?"dvfy_cb" --DEV
    return IUP_IGNORE
end function
constant cb_dvfy = Icallback("dvfy_cb")

function crash_cb(atom /*ih*/)
--integer wasmax = IupGetInt(dlg,"MAXIMIZED")
--  IupSetAttribute(dlg,"PLACEMENT","NORMAL")
--  IupShow(dlg) -- un-maximise the main window first
    if IupAlarm("Crash?","All edits will be lost!","OK","CANCEL")=1 then
        IupHide(dlg) -- (ensures any existing console gets focus)
        ?9/0
    end if
--  if wasmax then
--      IupSetAttribute(dlg,"PLACEMENT","MAXIMIZED")
--      IupShow(dlg)
--  end if
    return IUP_IGNORE
end function
constant cb_crash = Icallback("crash_cb")

function showfmt_cb(atom /*self*/)
--?"showfmt_cb" --DEV
--broken (cursor movement on utf8 really)
-- better, "" ok, but delete not...
-- better, "" "" OK, but block select is off...
-- fixed 30/9/16 (utf32_to_utf8 at the chunk (not line) level in appUpdateRender)
    showSpecials = 1-showSpecials
    appUpdateRender()
    return IUP_IGNORE
end function
constant cb_showfmt = Icallback("showfmt_cb")

--/*
constant bind_fmt="""
Bind     %t
Input:   %f[OPEN|*.e;*.ew;*.ex;*.exw|CURRENT|NO|NO]
Output:  %f[SAVE|*.exe|CURRENT|NO|YES]
Backend: %f[OPEN|*.exe|CURRENT|NO|NO]
Options  %t
Icon:    %f[OPEN|*.ico|CURRENT|NO|NO]
         %b[Include debug symbols,Include debug symbols]
         %b[Create console application,Create console application]
"""  

--**
-- Run the bind utility.
--
function bind_cb(atom self)
--      IupAlarm( "Action", "Bind", "OK" )
    if self then end if
    if skip_next_event() then
        return IUP_IGNORE
    end if

    atom pos = IupGetInt(tabs, "VALUEPOS")
    if pos=IUP_INVALID then
        -- nothing selected
        return IUP_IGNORE
    end if

    atom sci = IupGetChild(tabs, pos)
    sequence path = IupGetAttribute(sci, "PATH")
?path

ifdef WINDOWS then
    sequence eubind = "eubind.exe"
--              sequence backend = locate_file( "eub.exe" )
    sequence backend = "{9/0}"
elsedef
    sequence eubind = "eubind"
--              sequence backend = locate_file( "eub" )
    sequence backend = {9/0}
end ifdef

    -- build the input and output files from the original path
--DEV?
--  sequence input  = join_path({get_file_path(path),get_file_name(path)})
    sequence input  = get_file_path(path) & SLASH & get_file_name(path)
    sequence output = get_file_path(path) & SLASH & get_file_base(path)
ifdef WINDOWS then output &= ".exe" end ifdef
?{input,output}

--DEV not that this does for Phix..
--/*
    -- an empty string to pad memory
    sequence empty = repeat(0, 255)

    sequence fields = {
                       "Bind     %t",
                       "Input:   %f[OPEN|*.e;*.ew;*.ex;*.exw|CURRENT|NO|NO]",
                       "Output:  %f[SAVE|*.exe|CURRENT|NO|YES]",
                       "Backend: %f[OPEN|*.exe|CURRENT|NO|NO]",
                       "Options  %t",
                       "Icon:    %f[OPEN|*.ico|CURRENT|NO|NO]",
                       "         %b[Include debug symbols,Include debug symbols]",
                       "         %b[Create console application,Create console application]"
                      }

    sequence params = {
                       allocate_string(empty, 1), -- Input
                       allocate_string(empty, 1), -- Output
                       allocate_string(empty, 1), -- Backend
                       allocate_string(empty, 1), -- Icon
                       allocate_data(4, 1),       -- Include debug symbols
                       allocate_data(4, 1)        -- Use current console
                      }

    poke(params[1], input)
    poke(params[2], output)
    poke(params[3], backend)
    poke4(params[5], 0) -- debug = 0
    poke4(params[6], 0) -- console = 0

    atom result = IupGetParam("Bind", NULL, NULL, join(fields, "\n"), length(fields), 0, params)

    if result=0 then
        -- user cancelled
        return IUP_IGNORE
    end if

    atom debug, console
    sequence icon
    input   = peek_string(params[1])
    output  = peek_string(params[2])
    backend = peek_string(params[3])
    icon    = peek_string(params[4])
    debug   = peek4u(params[5])
    console = peek4u(params[6])
--*/
    sequence res = IupGetParam("Bind", NULL, 0, bind_fmt,
                               {input, output, backend, "", 0, 0})
    if res[$]=0 then
        return IUP_IGNORE
    end if
    atom debug, console
    sequence icon
    {input,output,backend,icon,debug,console} = res

    -- build the command line
    sequence cmd = {eubind, "-batch"}
    if console!=0    then cmd &= {"-con"}        end if
    if length(backend) then cmd &= {"-eub", backend} end if
    if debug!=0      then cmd &= {"-full_debug"}     end if
    if length(icon)  then cmd &= {"-icon", icon}     end if
    if length(output)  then cmd &= {"-out", output}  end if
    cmd &= {get_file_name(input)}
--      cmd = build_commandline( cmd )

    {} = chdir(get_file_path(input))
    ?9/0
--  pipeio:exec( cmd, pipeio:create() )

    return IUP_IGNORE
end function
--*/

include src/goto.e as gdlg

function selectall_cb(atom /*self*/)
    selectAll()
    return IUP_IGNORE
end function
constant cb_selectall = Icallback("selectall_cb")


function file_menu_open_cb(Ihandle /*ih*/)
    IupSetInt(file_reopen,"ACTIVE",currfile!=0)
    IupSetInt(file_save,"ACTIVE",currfile!=0 and actionsave[currfile]!=actionptr[currfile])
    IupSetInt(file_saveas,"ACTIVE",currfile!=0)
    IupSetInt(file_close,"ACTIVE",currfile!=0)
--DEV:
--  IupSetInt(file_prntp,"ACTIVE",currfile!=0)
--  IupSetInt(file_print,"ACTIVE",currfile!=0)

--string filename = filenames[currfile]
--integer dirty = (actionsave[currfile]!=actionptr[currfile])
--
--  if dirty then
--      IupSetAttribute(item_save, "ACTIVE", "YES");
--  else
--      IupSetAttribute(item_save, "ACTIVE", "NO");
--  end if
--? IupSetInt(item_save,"ACTIVE",dirty)
--  if dirty and length(filename)!=0 then
--      IupSetAttribute(item_revert, "ACTIVE", "YES");
--  else
--      IupSetAttribute(item_revert, "ACTIVE", "NO");
--  end if
    return IUP_DEFAULT;
end function

Ihandle edit_undo, edit_redo, 
        edit_cut, edit_cuta, edit_cutp, 
        edit_copy, edit_copya, edit_copyp, 
        edit_paste, copy_fname, edit_clip, edit_clips, 
        edit_delete, edit_find, find_next, find_prev, 
        edit_nextcs, edit_prevcs, 
        edit_goto, edit_selall

function edit_menu_open_cb(Ihandle /*ih*/)
-- (enable/disable depending on selection, contents of the clipboard, etc)
integer isclip = IupGetInt(clipboard, "TEXTAVAILABLE")
integer sel = (currfile and selON and (selX!=CursorX or selY!=CursorY))
    IupSetInt(edit_undo,"ACTIVE",currfile and (actionptr[currfile]>0))
    IupSetInt(edit_redo,"ACTIVE",currfile and (actionptr[currfile]<length(actions[currfile])))
    IupSetInt({edit_cut,edit_copy,edit_delete},"ACTIVE",sel)
    IupSetInt({edit_cuta,edit_cutp,edit_copya,edit_copyp},"ACTIVE",sel and isclip)
    IupSetInt(edit_paste,"ACTIVE",currfile and isclip)
    IupSetInt(edit_clips,"ACTIVE",sel or (currfile and isclip))
    integer findnp = fdlg:find_active()
    IupSetInt({find_next,find_prev},"ACTIVE",currfile!=0 and findnp)
    IupSetInt({edit_goto,edit_selall},"ACTIVE",currfile!=0)
    return IUP_DEFAULT;
end function

Ihandle toolm_run
Ihandle toolm_prun
Ihandle toolm_jerr
Ihandle toolm_comp
--Ihandle toolm_dcmp
Ihandle toolm_fif
Ihandle toolm_html
Ihandle toolm_rein
Ihandle toolm_cca
Ihandle toolm_qjmp
Ihandle toolm_recvr
Ihandle toolm_desgn
Ihandle toolm_dbvwr
Ihandle toolm_dbvfy
Ihandle toolm_showf
Ihandle toolm_crash

function tool_menu_open_cb(Ihandle /*ih*/)
-- (enable/disable depending on selection, contents of the clipboard, etc)
--?"tool_menu_open_cb" --DEV
    integer runnable = 0
    if currfile then
        string ext = get_file_extension(filenames[currfile])
        runnable = getExtRunWith(ext)!=""
    end if
    IupSetInt({toolm_run,toolm_prun},"ACTIVE",runnable)
    IupSetInt(toolm_fif,"ACTIVE",currfile!=0)
    return IUP_DEFAULT;
end function
constant cb_tool_menu_open = Icallback("tool_menu_open_cb")

Ihandle macro_rec6
Ihandle macro_rec7
Ihandle macro_rec8
Ihandle macro_rec9
Ihandle macro_play6
Ihandle macro_play7
Ihandle macro_play8
Ihandle macro_play9
--Ihandle macro_mngmt

function macro_menu_open_cb(Ihandle /*ih*/)
-- (enable/disable depending on selection, contents of the clipboard, etc)
--integer isclip = IupGetInt(clipboard, "TEXTAVAILABLE")
--integer sel = (currfile and selON and (selX!=CursorX or selY!=CursorY))
--  IupSetInt(edit_undo,"ACTIVE",currfile and (actionptr[currfile]>0))
--  IupSetInt(edit_redo,"ACTIVE",currfile and (actionptr[currfile]<length(actions[currfile])))
--  IupSetInt({edit_cut,edit_copy,edit_delete},"ACTIVE",sel)
--  IupSetInt({edit_cuta,edit_cutp,edit_copya,edit_copyp},"ACTIVE",sel and isclip)
--  IupSetInt(edit_paste,"ACTIVE",currfile and isclip)
--  integer findnp = fdlg:find_active()
--  IupSetInt({find_next,find_prev},"ACTIVE",findnp)
--  IupSetInt({edit_goto,edit_selall},"ACTIVE",currfile!=0)
--?"tool_menu_open_cb" --DEV
--  bool recordable = not MacroPlaying
--  integer runnable = 0
--DEV iff(recording?"Stop":"Record") and disable other records and empty playbacks:
    IupSetInt({macro_rec6,macro_rec7,macro_rec8,macro_rec9},"ACTIVE",not MacroPlaying)
--  IupSetInt(macro_rec7,"ACTIVE",recordable)
--  IupSetInt(macro_rec8,"ACTIVE",runnable)
--  IupSetInt(macro_rec9,"ACTIVE",runnable)
    IupSetInt(macro_play6,"ACTIVE",MacroPlaying<1 and MacroKeys[1]!={})
    IupSetInt(macro_play7,"ACTIVE",MacroPlaying<2 and MacroKeys[2]!={})
    IupSetInt(macro_play8,"ACTIVE",MacroPlaying<3 and MacroKeys[3]!={})
    IupSetInt(macro_play9,"ACTIVE",MacroPlaying<4 and MacroKeys[4]!={})
--  IupSetInt(macro_mngmt,"ACTIVE",runnable)
    return IUP_DEFAULT;
end function
constant cb_macro_menu_open = Icallback("macro_menu_open_cb")

Ihandle reset_help_timer
bool reset_help = false
Ihandln dumwin = NULL

--, menu
--, fake_menu

--not menus...
--function help_get_focus_cb(Ihandle ih)
--?"help_get_focus_cb"
--  IupSetFocus(tabs)
--  return IUP_IGNORE
--end function
--constant cb_help_get_focus = Icallback("help_get_focus_cb")

--DEV return once new version installed... [DONE]

--/*
Silence Alt keys
I have finally figured out a solution:
In key_cb:
    if alt and find(base,"BCDILUX<>") then
        string Yelp = "&Yelp"
        Yelp[2] = base
        IupSetStrAttribute(main_help_menu,"TITLE",Yelp)
        reset_help = true
    end if
    <plus code to do what those alt-keys should>
In main_help_menu_open_cb:
    if reset_help then
        reset_help = false
        IupSetAttribute(main_help_menu,"TITLE","&Help")
        IupSetInt(main_help_menu,"ACTIVE",false)
        IupSetInt(reset_help_timer,"RUN",true)
    end if
In reset_help_cb (via reset_help_timer):
    IupSetInt(main_help_menu,"ACTIVE",true)
    IupSetInt(reset_help_timer,"RUN",false)
--  IupSetFocus(canvas)         -- does not work
--  IupSetGlobal("KEY",K_ESC)   -- does not work
    if dumwin=NULL then dumwin=IupDialog(NULL) end if
    IupShow(dumwin)
    IupHide(dumwin)

The last two lines do produce a minor blip, but I can live with that.

My question is whether IupSetFocus and/or IupSetGlobal("KEY") should work 
in these circumstances (instead of dumwin)?

Pete
--*/

function reset_help_cb(Ihandle ih)
--  if not IupGetInt(main_help_menu,"ACTIVE") then
--?"active"
    IupSetInt(reset_help_timer,"RUN",false)
    IupSetInt(main_help_menu,"ACTIVE",true)
--?"erm, edix.exw line 5825 (alt-D tests)"
    if dumwin=NULL then dumwin = IupDialog() end if
    IupShow(dumwin)
    IupHide(dumwin)
--  IupSetFocus(canvas)
--      IupMessage("Uh","Oh")
--      IupSetGlobal("KEY",K_ESC)   -- no help...
--      IupSetGlobal("KEY",K_ESC)   -- no help...
--      IupSetGlobal("KEY",#1B) -- no help...
--      IupSetGlobal("KEY","K_ESC") -- no help...
--      IupSetGlobal("MOUSEBUTTON","0x0 IUP_BUTTON2 0")
--  elsif IupGetFocus()!=canvas then
--  elsif IupGetFocus()=main_help_menu then
--  elsif IupGetFocus()!=tabs then
--?"focus"
--      fake_menu = IupMenu()
--      IupSetAttributeHandle(dlg, "MENU", fake_menu)
--      IupSetAttributeHandle(dlg, "MENU", NULL)
--      fake_menu = IupDestroy(fake_menu)
--      IupSetFocus(canvas)
--      IupSetFocus(tabs)
--      IupSetGlobal("KEY",#1B) -- no help...
--      IupFlush()  -- no help
--  elsif IupGetInt(reset_help_timer,"RUN") then
--?{"reset_help_cb",ih,"main_help_menu",main_help_menu,"canvas",canvas}
--      IupSetGlobal("KEY",K_ESC)   -- loops!!
--      IupSetAttribute(main_help_menu,"TITLE","&Help")
--      IupSetAttributeHandle(dlg, "MENU", menu)
--      IupSetGlobal("KEY",K_ESC)   -- no help...
--      IupSetGlobal("KEY",#1B) -- no help...
--      IupSetGlobal("KEY","K_ESC") -- no help...
--      IupFlush()
--      IupSetFocus(canvas)
--      IupFlush()
--      IupSetInt(main_help_menu,"ACTIVE",true)
--      IupFlush()
--      IupSetFocus(canvas)
--      IupSetAttributeHandle(dlg, "MENU", NULL)
--      fake_menu = IupMenu()
--      IupSetAttributeHandle(dlg, "MENU", fake_menu)
--      IupSetAttributeHandle(dlg, "MENU", NULL)
--      IupSetAttributeHandle(dlg, "MENU", menu)
--      fake_menu = IupDestroy(fake_menu)
--      IupFlush()
--      IupSetFocus(canvas)
--  end if
--  IupSetGlobal("KEYPRESS",K_ESC)
--  IupSetGlobal("KEYRELEASE",K_ESC)
--  IupSetGlobal("KEY",K_ESC)
--  IupFlush()
--  {} = IupLoopStep()
--  IupSetGlobal("KEYPRESS",K_ESC)
--  IupSetGlobal("KEYRELEASE",K_ESC)
    return IUP_DEFAULT
--  return IUP_IGNORE
end function

function help_menu_open_cb(Ihandle /*ih*/)
--?{"help_menu_open_cb",reset_help_timer}
--  IupSetGlobal("KEY",K_ESC)   -- hangs
--?"only if triggered from..."
    if reset_help then
        reset_help = false
        IupSetAttribute(main_help_menu,"TITLE","&Help")
        IupSetInt(main_help_menu,"ACTIVE",false)
        IupSetInt(reset_help_timer,"RUN",true)
--      return IUP_DEFAULT
        return IUP_IGNORE
--      return IUP_CONTINUE
--      return IUP_CLOSE
    end if
    return IUP_DEFAULT
end function
constant cb_help_menu_open = Icallback("help_menu_open_cb")
--*!/

include src/keyboard.e as keybd

Ihandle options_file_panel

function file_panel_cb(Ihandln /*ih*/)
atom v = IupGetInt(tbox,"VALUE")
integer {x,y} = IupGetIntInt(tbox, "RASTERSIZE")
--?{v,x,y,tboxv,v/1000*x,floor(tboxv*1000/x)}
--integer v = IupGetInt(rtbox,"VALUE")
    if v!=0 then
--      tboxv = v
--      tboxv = v*1000/x
        tboxv = v/1000*x
--?{"tboxv:=",tboxv}
--      tboxv = tboxv*1000/x
        IupSetInt(tbox,"VALUE", 0)
    else
--      if tboxv=0 then
--      end if
--      IupSetInt(tbox,"VALUE", tboxv)
        IupSetInt(tbox,"VALUE", floor(tboxv*1000/x))
--      IupSetInt(tbox,"VALUE", tboxv*1000/x)
--      IupSetInt(rtbox,"VALUE", tboxv)
--      IupSetAttribute(rtbox,"SIZE", "100x")
    end if
    IupSetAttribute(options_file_panel,"VALUE",iff(v=0?"ON":"OFF"))
    return IUP_DEFAULT;
end function
constant cb_file_panel = Icallback("file_panel_cb")

function menu_item(string text, string image, atom action_cb, integer active=1, integer id=0)
    integer k = rfind('\t',text)
    if k then
        text[k+1..$] = keybd:mapkeytext(text[k+1..$])
    end if
    Ihandle ih = IupMenuItem(text, action_cb)
    if length(image) then
        IupSetStrAttribute(ih, "IMAGE", get_image(image))
    end if
    IupSetInt(ih, "ACTIVE", active)
    if id then
        IupSetInt(ih, "ID", id)
    end if
    return ih
end function

function config_recent_cb(Ihandle ih)
--DEV:
--  if save_check(ih) then
    string filename = IupGetAttribute(ih, "TITLE");
--      open_file(ih, filename);
--  if length(filename) then
--      sequence text,linelengths
--DEV/SUG:
--      integer encoding
--      {text,linelengths} = read_file(filename)
--?currfile
    {} = openFile(0,filename,-1)
--?currfile
--DEV (copied/factor out??)
integer c = currfile
                for pos=0 to IupGetInt(tabs,"COUNT")-1 do
                    Ihandle tab = IupGetChild(tabs, pos)
                    if IupGetInt(tab,"FILEIDX")=c then
                        -- nb does not work after tab added (as documented):
--                      IupSetAttribute(tab, "TABTITLE", filenames[c])
                        -- However the following works just fine here, and
                        --  updates the above child attribute as well:
--                      IupSetAttributeId(tabs, "TABTITLE", pos, filenames[c])
--?pos
--                      IupSetAttribute(tab, "VALUEPOS", pos)
                        IupSetAttributeHandle(tabs, "VALUE", tab)
                        appUpdateRender()
                        exit
                    end if
                end for

--/*
    object res = readFile(filename)
    if sequence(res) then
        sequence {text,linelengths} = res
--      {text,linelengths,encoding} = read_file(filename,encoding)
        string title = get_file_name(filename)
--      string path = filename[1..length(filename)-length(title)]
--      string path = get_file_path(filename,0)
        string path = get_file_path(filename,dropslash:=false)
        add_tab(0,path, title, text, linelengths)
    end if
--      add_tab(0,path, title, text, linelengths, encoding)
--  end if
--*/
--  end if
    return IUP_DEFAULT;
end function

function filelist_cb(Ihandle /*cb_filelist*/)
--  fileList()
    IupFileList(filenames, filepaths, openFile, dlg, config)
    return IUP_DEFAULT
end function
constant cb_filelist = Icallback("filelist_cb")

function create_file_menu()
    file_new    = menu_item("&New\t\tCtrl N",           "PNG_FileNew",      cb_new,         1)
    file_open   = menu_item("&Open\tCtrl O",            "PNG_FileOpen",     cb_open,        1)
    file_reopen = menu_item("&ReOpen\tCtrl Shift O",    "PNG_FileReOpen",   cb_reopen,      0)
    file_save   = menu_item("&Save\t\tCtrl S",          "PNG_FileSave",     cb_save,        0)
    file_saveas = menu_item("Save &As..",               "PNG_FileSaveAs",   cb_saveas,      0)
--  file_list   = menu_item("File Lis&t\tCtrl T",       "PNG_FileList",     cb_filelist,    1)
    file_list   = menu_item("File Lis&t\tCtrl T",       "",                 cb_filelist,    1)
    file_close  = menu_item("C&lose\t\tCtrl F4",        "PNG_FileClose",    cb_close,       0)
    file_print  = menu_item("&Print\t\tCtrl Shift P",   "PNG_FilePrint",    cb_print,       0)
    file_prntp  = menu_item("Print Pre&view\t\tCtrl P", "PNG_FilePreview",  cb_preview,     0)
--DEV: Report painter, Code Publisher
    recent_menu = IupMenu({})
    file_recent = IupSubmenu("Recent &Files", recent_menu)
    IupConfigRecentInit(config, recent_menu, Icallback("config_recent_cb"), 9)
--  IupSetStrAttribute(file_recent, "IMAGE", get_image("PNG_FileRecent"))
    file_exit   = menu_item("E&xit\t\tAlt F4",  "PNG_FileExit",   cb_exit,   1)
    Ihandle file_menu = IupMenu({file_new,
                                 file_open,
                                 file_reopen,
                                 file_save,
                                 file_saveas,
                                 file_list,
                                 file_close,
                                 IupSeparator(),
                                 file_prntp,
                                 file_print,
                                 IupSeparator(),
                                 file_recent,
                                 file_exit})
--DEV?
--  IupSetHandle("file_menu", file_menu)
    IupSetCallback(file_menu, "OPEN_CB", Icallback("file_menu_open_cb"));
    return file_menu
end function

function create_edit_menu()
    edit_undo   = menu_item("Undo\tCtrl Z",                     "PNG_EditUndo",     cb_undo,            1)
    edit_redo   = menu_item("Redo\tCtrl Y",                     "PNG_EditRedo",     cb_redo,            1)
--DEV edit_case sub-menu
--edit_case = create_edit_case_submenu()
--DEV clipboard sub-menu; Clipboard History (updated by ctrl c/s/v, max clip entries=NN or -1)
--    also filename/fullpath, and strip html.
    edit_cut    = menu_item("Cu&t\tCtrl X",                     "PNG_EditCut",      cb_cut,             1)
    edit_cuta   = menu_item("Cut Append\tCtrl Shift X",         "PNG_EditCuta",     cb_cuta,            1)
    edit_cutp   = menu_item("Cut Prepend\tAlt Shift X",         "PNG_EditCutp",     cb_cutp,            1)
    edit_copy   = menu_item("&Copy\tCtrl C",                    "PNG_EditCopy",     cb_copy,            1)
    edit_copya  = menu_item("Copy Append\tCtrl Shift C",        "PNG_EditCopya",    cb_copya,           1)
    edit_copyp  = menu_item("Copy Prepend\tAlt Shift C",        "PNG_EditCopyp",    cb_copyp,           1)
    edit_paste  = menu_item("&Paste\tCtrl V",                   "PNG_EditPaste",    cb_paste,           1)
    copy_fname  = menu_item("Copy Filename",                    "",                 cb_fname,           1)
    edit_clip = IupMenu({edit_cut,edit_cuta,edit_cutp,
                         edit_copy,edit_copya,edit_copyp,
                         edit_paste,copy_fname})
    edit_delete = menu_item("&Delete\tDelete",                  "PNG_EditErase",    cb_delete,          0)
    edit_find   = menu_item("&Find...\tCtrl F",                 "PNG_EditFind",     fdlg:cb_find,       1)
--  find_next   = menu_item("Find Next\tF3",                    "PNG_FindNext",     fdlg:cb_findnext,   0)
    find_next   = menu_item("Find Next\tF3",                    "",                 fdlg:cb_findnext,   0)
--  find_prev   = menu_item("Find Prev\tShift F3",              "PNG_FindPrev",     fdlg:cb_findprev,   0)
    find_prev   = menu_item("Find Prev\tShift F3",              "",                 fdlg:cb_findprev,   0)
--DEV Next/prior diff, Ctrl [ ]
--  edit_nextcs = menu_item("Next Control Structure\tCtrl ]",   "PNG_EditNextCS",   cb_nextcs,          1)
    edit_nextcs = menu_item("Next Control Structure\tCtrl ]",   "",                 cb_nextcs,          1)
--  edit_prevcs = menu_item("Prev Control Structure\tCtrl [",   "PNG_EditPrevCS",   cb_prevcs,          1)
    edit_prevcs = menu_item("Prev Control Structure\tCtrl [",   "",                 cb_prevcs,          1)
    edit_goto   = menu_item("&Goto...\tCtrl G",                 "PNG_EditGoto",     gdlg:cb_goto,       1)
--  edit_selall = menu_item("Select &All\tCtrl A",              "PNG_EditSelectAll",cb_selectall,       1)
    edit_selall = menu_item("Select &All\tCtrl A",              "",                 cb_selectall,       1)
--edit_selwrd = menu_item("Select &Word\tCtrl W",               "PNG_EditSelectWrd",cb_selectwrd,       1)

--  item_goto = IupMenuItem("&Go To...\tCtrl G");
--  IupSetCallback(item_goto, "ACTION", Icallback("item_goto_action_cb"));


--  Ihandle tool_undo    = toolbar_item(cb_undo,    "PNG_EditUndo",   "Undo (Ctrl Z)",     0)
--  Ihandle tool_redo    = toolbar_item(cb_redo,    "PNG_EditRedo",   "Redo (Ctrl Y)",     0)
--  Ihandle tool_zoomin  = toolbar_item(cb_zoomin,  "PNG_ZoomIn",     "Zoom In (Ctrl +)",  0)
--  Ihandle tool_zoomout = toolbar_item(cb_zoomout, "PNG_ZoomOut",    "Zoom Out (Ctrl -)", 0)

    edit_clips = IupSubmenu("Clipboard",edit_clip)
    Ihandle edit_menu = IupMenu({edit_undo,
                                 edit_redo,
                                 IupSeparator(),
--                               edit_cut,
--                               edit_cuta,
--                               edit_cutp,
--                               edit_copy,
--                               edit_copya,
--                               edit_copyp,
--                               edit_paste,
                                 edit_clips,
                                 edit_delete,
                                 IupSeparator(),
                                 edit_find,
                                 find_next,
                                 find_prev,
--                               edit_replace,
                                 IupSeparator(),
                                 edit_nextcs,
                                 edit_prevcs,
                                 IupSeparator(),
                                 edit_goto,
                                 IupSeparator(),
--                               edit_select_all})
                                 edit_selall})
    IupSetCallback(edit_menu, "OPEN_CB", Icallback("edit_menu_open_cb"))
    return edit_menu
end function

include src/fif.e as fif

function create_tool_menu()
--DEV shortcut keys from keyboard.e
    toolm_run   = menu_item("Run\tF5",                      "PNG_ToolRun",          cb_run,      1)
    toolm_prun  = menu_item("Parameterised Run\tCtrl F5",   "PNG_ToolParamRun",     cb_run,      1,1)
    toolm_jerr  = menu_item("Jump to error\tF12",           "PNG_error",            cb_jerr,     1)
    toolm_comp  = menu_item("&Compare",                     "PNG_Compare",          cb_comp,     0)
--  toolm_dcmp  = menu_item("&Directory Compare",           "PNG_DirComp",          cb_dcmp,     0)
    toolm_fif   = menu_item("&Find In Files\tCtrl Shift F", "PNG_FindInFiles",      fif:cb_fif,  1)
    toolm_html  = menu_item("&Htmlise eucode",              "PNG_ToolsHtmlise",     cb_html,     1)
    toolm_rein  = menu_item("Re-&Indent source",            "PNG_Reindent",         cb_rein,     1)
    toolm_cca   = menu_item("Co&mmon Code Analysis",        "PNG_CommonCode",       cb_cca,      0)
    toolm_qjmp  = menu_item("&Quick Jump\tCtrl Q",          "PNG_QuickJump",        cb_qjmp,     1)
    toolm_recvr = menu_item("&Recovery",                    "PNG_Recovery",         cb_rcvr,     0)
--  toolm_paint = menu_item("&Window Painter",              "PNG_WindowPaint",      cb_wpnt,     0)
--  toolm_paint = menu_item("&Layout Designer",             "PNG_Designer",     cb_wpnt,     0)
    toolm_desgn = menu_item("&Layout Designer",             "PNG_Designer",         cb_design,   01)
    toolm_dbvwr = menu_item("Database &Viewer",             "PNG_DatabaseViewer",   cb_dvwr,     0)
    toolm_dbvfy = menu_item("Verif&y Database",             "PNG_DatabaseVerify",   cb_dvfy,     0)
    toolm_showf = menu_item("Show Formatting\tCtrl Shift H","PNG_pilcrow",          cb_showfmt,  1)
    toolm_crash = menu_item("Crash",                        "PNG_Crash",            cb_crash,    1)

    Ihandle tool_menu = IupMenu({toolm_run,
                                 toolm_prun,
                                 toolm_jerr,
                                 toolm_comp,
--                               toolm_dcmp,
                                 toolm_fif,
                                 toolm_html,
                                 toolm_rein,
                                 toolm_cca,
                                 toolm_qjmp,
                                 toolm_recvr,
                                 toolm_desgn,
                                 toolm_dbvwr,
                                 toolm_dbvfy,
                                 toolm_showf,
                                 IupSeparator(),
                                 toolm_crash})
    IupSetCallback(tool_menu, "OPEN_CB", cb_tool_menu_open)
    return tool_menu
end function

function create_macro_menu()
--DEV shortcut keys from keyboard.e[??]
    macro_rec6  = menu_item("Record F6\tCtrl F6",           "PNG_MacroRecord",  macro:cb_macro, 0,1)
    macro_rec7  = menu_item("Record F7\tCtrl F7",           "PNG_MacroRecord",  macro:cb_macro, 0,2)
    macro_rec8  = menu_item("Record F8\tCtrl F8",           "PNG_MacroRecord",  macro:cb_macro, 0,3)
    macro_rec9  = menu_item("Record F9\tCtrl F9",           "PNG_MacroRecord",  macro:cb_macro, 0,4)
    macro_play6 = menu_item("Play F6\tF6",                  "PNG_MacroPlay",    macro:cb_macro, 0,11)
    macro_play7 = menu_item("Play F7\tF7",                  "PNG_MacroPlay",    macro:cb_macro, 0,12)
    macro_play8 = menu_item("Play F8\tF8",                  "PNG_MacroPlay",    macro:cb_macro, 0,13)
    macro_play9 = menu_item("Play F9\tF9",                  "PNG_MacroPlay",    macro:cb_macro, 0,14)
--  macro_mngmt = menu_item("Macro Management\tShift F8",   "PNG_MacroClap",    cb_mngmt, 0)

    Ihandle macro_menu = IupMenu({macro_rec6,
                                  macro_rec7,
                                  macro_rec8,
                                  macro_rec9,
                                  macro_play6,
                                  macro_play7,
                                  macro_play8,
                                  macro_play9})
--                                macro_play9,
--                                macro_mngmt})
    IupSetCallback(macro_menu, "OPEN_CB", cb_macro_menu_open)
    return macro_menu
end function

function create_options_menu()
--DEV should zoom in/out be here?
--DEV move AutoComplete to Edit options!
--Ihandle options_autocomplete  = menu_item("&Auto Complete",               "PNG_MacroRecord",  gdlg:cb_goto,       0)
Ihandle options_colours     = menu_item("&Colours",                         "PNG_Colours",      gdlg:cb_goto,       0)
--Ihandle options_fonts     = menu_item("&Fonts",                           "PNG_Fonts",        gdlg:cb_goto,       0)
--SUG put edit/diplay/keyboard/extensions on a tabbed dialog
Ihandle options_display     = menu_item("&Display Options",                 "PNG_DisplayOpt",   gdlg:cb_goto,       0)
Ihandle options_edit        = menu_item("&Edit Options",                    "PNG_EditOpt",      gdlg:cb_goto,       0)
Ihandle options_keyboard    = menu_item("&Keyboard Settings\t(Ctrl F1)",    "PNG_KeyboardOpt",  keybd:cb_keybd, 1)
Ihandle options_file_extns  = menu_item("File E&xtensions",                 "PNG_ExtOpt",       extns:cb_ext,   1)
        options_file_panel  = menu_item("File Pane&l\t(Ctrl L)",            "PNG_PanelOn",      cb_file_panel,  1)
    IupSetStrAttribute(options_file_panel, "IMPRESS", get_image("PNG_PanelOff"))
    IupSetAttribute(options_file_panel,"VALUE","OFF")

    --DEV move Wordwrap to Display options!
    --Ihandle options_wordwrap  = menu_item("&Wordwrap",            "PNG_MacroPlay",    gdlg:cb_goto, 0)
    --SUG: Edit config file (use the FILENAME attribute, see IupConfigLoad)
    --Ihandle options_config    = menu_item("Edit Confi&g File",    "PNG_EditOpt",      cb_edit_config?, 0)

    Ihandle options_menu = IupMenu({options_colours,
--                                  options_fonts,
                                    options_display,
                                    options_edit,
                                    options_keyboard,
                                    options_file_extns,
                                    options_file_panel})
--  IupSetCallback(options_menu, "OPEN_CB", Icallback("options_menu_open_cb")); [probably not rqd]
    return options_menu
end function

--/*
--function HelpMenus()
sequence res
    res = {}
    for i=1 to length(helpfiles) do
        if sequence(menuTxts[i]) then
            if length(res)=0 then
                res = {{"-",        M_Help,0,0,0,0}}
            end if
            res = append(res,{menuTxts[i],M_Help,-1,0,helpfiles[i],PROC,r_MHelp,{i}})
        end if
    end for
    if length(res) then
        res = append(res,{"-",      M_Help,0,0,0,0})
    end if
    return res
--end function

--procedure MHelp(integer i)
--14/9/15:
--  openChm(helpfiles[i],0)
sequence helpfile
    helpfile = helpfiles[i]
    if helpfile[2]!=':' then
--      helpfile = initialcurrentdir&helpfile
        helpfile = get_proper_path(initialcurrentdir&helpfile)
--          f2 = open(helpfile,"r")
    end if
    openChm(helpfile,0)
--end procedure
constant r_MHelp=routine_id("MHelp")

include src/qj.e
--*/

constant H_F1 = 101, 
         H_HOME = 102, 
         H_MANUAL = 103,
         H_LICENCE = 104,
         H_FORUM = 105,
         H_UPGRADE = 107,
         H_ABOUT = 108

Ihandle F1menuitem

procedure F1key(integer ctrl)
--?"F1!"
--      openChm("phix.chm",0)
--DEV get path dynamically, word under the cursor... and esc to close
--      openChm(`C:\Program Files (x86)\Phix\docs\phix\phix.chm`,"")
    if ctrl then
        keybd:keyboard_dialog()
    else
        if currfile then
            rcX = CursorX
            rcY = CursorY
        end if
        F1help(0)
    end if
end procedure

global function help_cb(Ihandle self)
integer id = IupGetInt(self,"ID")
--?"help_cb"
    if id<=100 then
--DEV eaqj.ew...
--      openChm(helpfiles[id],0)
        openChm(helpfiles[id],"")
--      ?helpfiles[id]
    elsif id=H_F1 then
        F1key(0)
    elsif id=H_HOME then
?"F1-home"
    elsif id=H_MANUAL then
?"F1-manual"
    elsif id=H_LICENCE then
?"F1-licence"
    elsif id=H_FORUM then
?"F1-forum"
    elsif id=H_UPGRADE then
?"F1-upgrade"
    elsif id=H_ABOUT then
?"F1-about"
    else
        ?9/0
    end if
    return IUP_DEFAULT
end function
constant cb_help = Icallback("help_cb")

function create_help_menu()
--trace(3)
--?helpfiles
--{`..\..\docs\phix\phix.chm`,`help\mini.chm`}
Ihandle help_context    = menu_item("&Context Help\tF1",    "PNG_Help",         cb_help,  1, H_F1)
--Ihandle help_phix     = menu_item("Phix.chm",             "PNG_HelpPhixCHM",  cb_help,  1, 0)
--Ihandle help_msdn     = menu_item("mini.chm",             "PNG_HelpCHM",      cb_help,  1, 0)
Ihandle help_home       = menu_item("Phix Home Page",       "PNG_helpHome",     cb_help,  1, H_HOME)
Ihandle help_manual     = menu_item("manual",               "PNG_HelpPhixCHM",  cb_help,  1, H_MANUAL)
Ihandle help_licence    = menu_item("licence",              "PNG_HelpPhixCHM",  cb_help,  1, H_LICENCE)
Ihandle help_forum      = menu_item("OpenEuphoria Forum",   "PNG_UserGroup",    cb_help,  1, H_FORUM)
Ihandle help_upgrades   = menu_item("Check for &Upgrades",  "PNG_AppUpgrade",   cb_help,  1, H_UPGRADE)
Ihandle help_about      = menu_item("&About",               "PNG_HelpAbout",    cb_help,  1, H_ABOUT)

F1menuitem = help_context
Ihandles children = {help_context,
                     IupSeparator()}
--Ihandles from_helpfiles = {}
    for i=1 to length(helpfiles) do
        string help_name = get_file_name(helpfiles[i])
--      string help_name = "chm"
        string help_icon = iff(lower(help_name)="phix.chm"?"PNG_HelpPhixCHM":"PNG_HelpCHM")
--      string help_icon = "PNG_HelpCHM"
--      from_helpfiles &= menu_item(help_name,help_icon,cb_help,1,i)
        children &= menu_item(help_name,help_icon,cb_help,1,i)
    end for
    children &= {IupSeparator(),
--DEV for some reason this is however ok, unlike below...
                 help_home,
                 help_manual,
                 help_licence,
                 help_forum,
                 help_upgrades,
                 help_about}

Ihandle help_menu = IupMenu(children)
--                          {help_context,
--                           IupSeparator()}&
--                           help_phix,
--                           help_msdn,
--                          from_helpfiles&
--                          {IupSeparator(),
--DEV [HELP!!] any and all of these crash, w/o a proper ex.err
--                           help_home,
--                           help_manual,
--                           help_licence,
--                           help_forum,
--                           help_upgrades,
--                           help_about})
--})
    IupSetCallback(help_menu, "OPEN_CB", cb_help_menu_open)
--  IupSetCallback(help_menu, "GETFOCUS_CB", cb_help_get_focus)
    reset_help_timer = IupTimer(Icallback("reset_help_cb"),40,false)
--trace(0)
--?{"help_menu",help_menu}
    return help_menu
end function


function create_menu()
main_help_menu = IupSubmenu("&Help",    create_help_menu())
Ihandle menu = IupMenu({IupSubmenu("&File",    create_file_menu()),
                        IupSubmenu("&Edit",    create_edit_menu()),
                        IupSubmenu("&Tools",   create_tool_menu()),
                        IupSubmenu("&Macro",   create_macro_menu()),
                        IupSubmenu("&Options", create_options_menu()),
--                      IupSubmenu("&Help",    create_help_menu()),
                        main_help_menu
--                          sub_menu_format,
--                          sub_menu_view,
--                          sub_menu_help});
                       })
    return menu
end function

function toolbar_item(atom action, string image, string tip, integer active=1)
Ihandle item = IupButton(NULL, action, "CANFOCUS=NO, FLAT=YES")
    IupSetStrAttribute(item, "IMAGE", get_image(image))
    integer k = find('(',tip)
    if k!=0 then
        k += 1
        integer l = find(')',tip,k)-1
        tip[k..l] = keybd:mapkeytext(tip[k..l])
    end if
    IupSetStrAttribute(item, "TIP", tip)
    IupSetInt(item, "ACTIVE", active)
    return item
end function

--DEV (temp, dummy routine names)
constant actset = {"create",
                   "edit",
                   "reload",
                   "merge",
                   "create",
                   "edit",
                   "merge",
                   "apply"}


function create_toolbar()
--DEV content from ini file?
    toolb_new     = toolbar_item(cb_new,            "PNG_FileNew",    "New (Ctrl N)",                   1)
    toolb_open    = toolbar_item(cb_open,           "PNG_FileOpen",   "Open (Ctrl O)",                  1)
    toolb_save    = toolbar_item(cb_save,           "PNG_FileSave",   "Save (Ctrl S)",                  1)
--  toolb_saveas  = toolbar_item(cb_saveas,         "PNG_FileSaveAs", "Save As",                        1)
    toolb_close   = toolbar_item(cb_close,          "PNG_FileClose",  "Close (Ctrl F4)",                0)
    toolb_prntp   = toolbar_item(cb_preview,        "PNG_FilePreview","Print Preview (Ctrl P)",         0)
    toolb_print   = toolbar_item(cb_print,          "PNG_FilePrint",  "Print (Ctrl Shift P)",           0)
    toolb_cut     = toolbar_item(cb_cut,            "PNG_EditCut",    "Cut (Ctrl X)",                   1)
    toolb_copy    = toolbar_item(cb_copy,           "PNG_EditCopy",   "Copy (Ctrl C)",                  1)
    toolb_paste   = toolbar_item(cb_paste,          "PNG_EditPaste",  "Paste (Ctrl V)",                 1)
    toolb_undo    = toolbar_item(cb_undo,           "PNG_EditUndo",   "Undo (Ctrl Z)",                  1)
    toolb_redo    = toolbar_item(cb_redo,           "PNG_EditRedo",   "Redo (Ctrl Y)",                  1)
    toolb_find    = toolbar_item(fdlg:cb_find,      "PNG_EditFind",   "Find (Ctrl F)",                  0)
    toolb_fnxt    = toolbar_item(fdlg:cb_findnext,  "PNG_FindNext",   "Find Next (F3)",                 0)
    toolb_fprv    = toolbar_item(fdlg:cb_findprev,  "PNG_FindPrev",   "Find Prev (Shift F3)",           0)
    toolb_zoomin  = toolbar_item(cb_zoomin,         "PNG_ZoomIn",     "Zoom In (Ctrl +)",               0)
    toolb_zoomout = toolbar_item(cb_zoomout,        "PNG_ZoomOut",    "Zoom Out (Ctrl -)",              0)
    toolb_back    = toolbar_item(cb_backoff,        "PNG_rotate1",    "Background Processing",          0)
    toolb_run     = toolbar_item(cb_run,            "PNG_ToolRun",    "Run (F5)",                       0)
--  toolb_run     = toolbar_item(cb_run,            "IUP_ActionOk",   "Run (F5)",                       0)

--DEV in windows the control will still get the focus when clicked [the DEV part being that we need some extra code to re-focus]
--Ihandle
--htlbl = IupLabel("&D")

    toolb_rtns = IupList("CANFOCUS=NO, DROPDOWN=YES, EXPAND=HORIZONTAL")
    --DEV this will be more dynamically set:
    if 01 then
        IupSetInt(toolb_rtns, "ACTIVE", 0)
    else
--      IupSetAttributeId(toolb_rtns, "", length(actset), NULL)
        IupSetInt(toolb_rtns,"VISIBLEITEMS",length(actset)+1)   -- [no idea why it needs the +1]
--      IupSetInt(toolb_rtns,"VISIBLEITEMS",length(actset))
        for i=1 to length(actset) do
            IupSetAttributeId(toolb_rtns, "", i, actset[i])
        end for
        IupSetInt(toolb_rtns,"VALUE",length(actset))
--      IupSetInt(toolb_rtns,"SIZE",length(actset))
    end if

    Ihandle toolbar = IupHbox({toolb_new,
                               toolb_open,
                               toolb_save,
--                             toolb_saveas,
                               toolb_close,
                               IupLabel(NULL, "SEPARATOR=VERTICAL"),
-- print/page setup
                               toolb_prntp,
                               toolb_print,
                               IupLabel(NULL, "SEPARATOR=VERTICAL"),
                               toolb_cut,
                               toolb_copy,
                               toolb_paste,
                               IupLabel(NULL, "SEPARATOR=VERTICAL"),
                               toolb_undo,
                               toolb_redo,
                               toolb_find,
                               toolb_fnxt,
                               toolb_fprv,
                               IupLabel(NULL, "SEPARATOR=VERTICAL"),
                               toolb_zoomin,
                               toolb_zoomout,
                               IupLabel(NULL, "SEPARATOR=VERTICAL"),
                               toolb_back,
                               toolb_run,
--htlbl,
                               toolb_rtns})
--/*
atom toolbar = IupHbox({
                        IupLabel(NULL, "SEPARATOR=VERTICAL"),
                        toolbar_item("tool_run",  "Run (F5)",  "PNG_ActionRun",  cb_run,  0),
                        toolbar_item("tool_bind", "Bind (F7)", "PNG_ActionBind", Icallback("bind_cb"), 0),
                        IupLabel(NULL, "SEPARATOR=VERTICAL"),
                        toolbar_item("tool_about", "About (F12)", "PNG_MessageInfo", Icallback("about_cb"))
                       })
    IupSetHandle("toolbar", toolbar)

--*/
    IupSetAttributes(toolbar, "GAP=2, MARGIN=2x2")
--  IupSetAttribute(toolbar, "MARGIN", "5x5");
--  IupSetAttribute(toolbar, "GAP", "2");
    return toolbar
end function

--function info_cb(Ihandle /*item_info*/)
--?"info"
--  return IUP_DEFAULT;
--end function
--constant cb_info = Icallback("info_cb")

Ihandln tmenu = NULL, t_new, t_open, t_reopen, t_save, t_saveas, t_close
--t_reopen, 

procedure show_tmenu(integer pos)
-- pos is >=0 for a mouse right click, -1 for keyboard
integer x, y
Ihandle tab
    tip_visible = 0
    if tmenu=NULL then
--      tmenu = IupMenu({IupMenuItem("New",cb_new),
--                       IupMenuItem("Open",cb_open),
--                       IupMenuItem("ReOpen"),
--                       IupMenuItem("Save",cb_save),
--                       IupMenuItem("Close")})
--      tmenu = IupMenu({menu_item("New\t\tCtrl N",         "PNG_FileNew",    cb_new,    1),
--                       menu_item("Open\tCtrl O",          "PNG_FileOpen",   cb_open,   1),
--                       menu_item("ReOpen\tCtrl Shift O",  "PNG_FileReOpen", cb_reopen, 1),
--                       menu_item("Save\t\tCtrl S",        "PNG_FileSave",   cb_save,   1),
--                       menu_item("Close\t\tCtrl F4",      "PNG_FileClose",  cb_close,  1)})
        --DEV/DOC/TEST:
        --  When you right click on a file tab a small menu appears.
        --  The Close option is self explanatory. The New and Open options use the 
        --  directory from the file tab, which may be different to that of the
        --  current open file (if one of the "background" tabs is clicked on).
        --  The Save option is only active when the file actually needs to be
        --  saved, which means only "[untitled]" for any background tabs, in
        --  which case it is effectively a "Save as" operation anyway.
--DEV BLUFF: (save as should really be here, reopen why not!)
        --  (Edita also had reopen/save as, which have been deemed to be
        --   of no use now that files are always saved on tab switch.)
        t_new    = menu_item("New\t\tCtrl N",           "PNG_FileNew",    cb_new,    1)
        t_open   = menu_item("Open\tCtrl O",            "PNG_FileOpen",   cb_open,   1)
        t_reopen = menu_item("ReOpen\tCtrl Shift O",    "PNG_FileReOpen", cb_reopen, 0)
        t_save   = menu_item("Save\t\tCtrl S",          "PNG_FileSave",   cb_save,   1)
        t_saveas = menu_item("Save &As..",              "PNG_FileSaveAs", cb_saveas, 1)
        t_close  = menu_item("Close\t\tCtrl F4",        "PNG_FileClose",  cb_close,  1)
        tmenu = IupMenu({t_new,
                         t_open,
                         t_reopen,
                         t_save,
                         t_saveas,
                         t_close})
    end if
    if pos>=0 then
        tab = IupGetChild(tabs,pos)
        {x,y} = IupGetIntInt(NULL,"CURSORPOS")
    else
        tab = IupGetAttributeHandle(tabs, "VALUE")
        -- unfortunately there is no easy way to obtain the tab title position,
        -- so this just plants it with top left in the middle of the tab bar.
        {x,y} = sq_add({0,10},
                sq_add(IupGetIntInt(tabs,"SCREENPOSITION"),
                sq_floor_div(IupGetIntInt(tabs,"CLIENTSIZE"),2)))
    end if
    tabfile = IupGetInt(tab,"FILEIDX")  -- (for New,Open,etc)
    -- (Now that autosaveontabswitch is now permanently on, "save" is only valid
    --  for right clicks on the current tab, and of course if that needs saving.
--ERM??
    --  However, [untitled] tabs, for which "save" is really "save_as" anyway,
    --  must also have the option enabled even when not the current open tab.)
    integer unnamed = match(untitled,filenames[tabfile])=1
    integer active = (tabfile=currfile and actionsave[currfile]!=actionptr[currfile])
    IupSetInt(t_reopen,"ACTIVE",not unnamed and tabfile=currfile)
    IupSetInt(t_save,"ACTIVE",active or unnamed)
    IupSetInt(t_saveas,"ACTIVE",tabfile=currfile)
    IupPopup(tmenu, x, y)
    tabfile = 0
end procedure

function tab_rightclick_cb(Ihandle /*tabs*/, integer pos)
--ih: identifier of the element that activated the event.
--pos: the tab position (0-based)
    show_tmenu(pos)
    return IUP_DEFAULT
end function

Ihandln cmenu = NULL
Ihandle cm_cut, cm_cuta, cm_cutp, cm_copy, cm_copya, cm_copyp, cm_paste--, cm_info

procedure set_cmenu(integer shift)
    if cmenu=NULL then
--DEV submenus? (case/clipboard..)
        cm_cut   = menu_item("Cu&t\tCtrl X",                "PNG_EditCut",      cb_cut,     1)
        cm_cuta  = menu_item("Cut Append\tCtrl Shift X",    "PNG_EditCuta",     cb_cuta,    1)
        cm_cutp  = menu_item("Cut Prepend\tAlt Shift X",    "PNG_EditCutp",     cb_cutp,    1)
        cm_copy  = menu_item("&Copy\tCtrl C",               "PNG_EditCopy",     cb_copy,    1)
        cm_copya = menu_item("Copy Append\tCtrl Shift C",   "PNG_EditCopya",    cb_copya,   1)
        cm_copyp = menu_item("Copy Prepend\tAlt Shift C",   "PNG_EditCopyp",    cb_copyp,   1)
        cm_paste = menu_item("&Paste\tCtrl V",              "PNG_EditPaste",    cb_paste,   1)
--      cm_info  = menu_item("info",                        "PNG_EditInfo",     cb_info,    0)
--      cmenu = IupMenu({cm_cut, cm_cuta, cm_cutp, cm_copy, cm_copya, cm_copyp, cm_paste, cm_info})
        cmenu = IupMenu({cm_cut, cm_cuta, cm_cutp, cm_copy, cm_copya, cm_copyp, cm_paste})
    end if
--  integer isclip = length(IupGetAttribute(clipboard,"TEXT"))!=0
    integer isclip = IupGetInt(clipboard, "TEXTAVAILABLE")
    integer sel = (currfile and selON and (selX!=CursorX or selY!=CursorY))
--  integer selclip = (sel and isclip)
--  IupSetInt(cm_cut,"ACTIVE",sel)
--  IupSetInt(cm_cuta,"ACTIVE",selclip)
--  IupSetInt(cm_cutp,"ACTIVE",selclip)
--  IupSetInt(cm_copy,"ACTIVE",sel)
--  IupSetInt(cm_copya,"ACTIVE",selclip)
--  IupSetInt(cm_copyp,"ACTIVE",selclip)
    IupSetInt({cm_cut,cm_copy},"ACTIVE",sel)
    IupSetInt({cm_cuta,cm_cutp,cm_copya,cm_copyp},"ACTIVE",sel and isclip)
    IupSetInt(cm_paste,"ACTIVE",currfile and isclip)
-->[DEV info"" - better yet, if Shift down, and word at x,y is coloured -> cb_info (inlined?)..]
    if shift then end if --DEV
end procedure

function canvas_button_cb(Ihandle ih, integer button, integer pressed, integer x, integer y, atom pStatus)
--
-- Note: If you select some text (with the mouse or keyboard) and right click on it, the pop-up appears, fine.
--       Now, if you right-click somewhere else, the selection changes - that was not planned, I have no idea
--       how/why/where it reselects, but it is perfectly reasonable and hence will simply be left like that.
--       (Actually, I now know it is because IUP sends a mouse move message, but I'm still leaving it as is.)
--       (And the "problem" only occurs if you right-click elsewhere while cmenu is actually shown on-screen)
--
    if currfile then
        if button=IUP_BUTTON1 then  -- left mouse button
            if iup_isdouble(pStatus) then
                selectWord(1)
            elsif pressed=1 then
                x = floor(x/charwidth)-marginRqd
                y = TopLine+floor(y/charheight)
--7/7/20:
--              if x>=0 and y<length(filetext[currfile]) then
                if x>=0 and currfile<=length(filetext) and y<length(filetext[currfile]) then
                    x = min(x,ExpLength(filetext[currfile][y+1]))
                    startSelection(iup_isshift(pStatus),iup_isalt(pStatus))
                    CursorX = x
                    CursorY = y
                    appUpdateRender()
--                  update_statusbar()  -- (now done inside "")
                end if
            end if
        elsif button=IUP_BUTTON3    -- right mouse button
          and pressed=0 then        -- (on release)
            set_cmenu(iup_isshift(pStatus))
            -- (I think ih is always canvas here)
--          {x,y} = sq_add({x,y},IupGetIntInt(ih,"SCREENPOSITION"))
            {x,y} = sq_add({x,y},IupGetIntInt(canvas,"SCREENPOSITION"))
            IupPopup(cmenu, x, y);
        end if
--?{"canvas_button_cb",button,IUP_BUTTON1,IUP_BUTTON1,selON,{selX,selY,CursorX,CursorY}}
    end if
    return IUP_DEFAULT
end function

procedure menu_key(integer ctrl, integer shift, integer alt)
    if ctrl then
        -- tab menu
        show_tmenu(-1)
    elsif not alt then
        -- edit area menu
        set_cmenu(shift)
        integer x = (CursorX+marginRqd)*charwidth
        integer y = (CursorY-TopLine+1)*charheight
        {x,y} = sq_add({x,y},IupGetIntInt(canvas,"SCREENPOSITION"))
        IupPopup(cmenu, x, y)
    end if
end procedure

function scroll_cb(Ihandle ih, integer op, atom posx, atom posy)
    posx = IupGetDouble(ih,"POSX")
    posy = IupGetDouble(ih,"POSY")
    if op<=IUP_SBDRAGV then
--set DY to linesPerPage (or crash if not)
--set YMAX to file length, YMIN to 1  ""
--      ?"vertical"
        TopLine = IupGetInt(canvas,"POSY")
        appUpdateRender()
    else
        ?{ih, op, posx, posy}
--set DX to charsWide
--set XMAX to max(linelengths), XMIN to 1
        ?"horizontal"
    end if
--if op=IUP_SBUP then
--  ?"IUP_SBUP,vertical"
--elsif op=IUP_SBDN then
--  ?"IUP_SBDN,vertical"
--elsif op=IUP_SBPGUP then
--  ?"IUP_SBPGUP,vertical"
--elsif op=IUP_SBPGDN then
--  ?"IUP_SBPGDN,vertical"
--elsif op=IUP_SBPOSV then   -- (when letting go)
--  ?"IUP_SBPOSV,vertical"
--elsif op=IUP_SBDRAGV then
--  ?"IUP_SBDRAGV,vertical"
--else
--  ?9/0
----/*
----        IUP_SBUP = 0,
----        IUP_SBDN, = 1
----        IUP_SBPGUP, 2   
----        IUP_SBPGDN, 3
----        IUP_SBPOSV, 4
----        IUP_SBDRAGV,    5
--      IUP_SBLEFT,     6
--      IUP_SBRIGHT,    7
--      IUP_SBPGLEFT,   8
--      IUP_SBPGRIGHT,  9
--      IUP_SBPOSH,     10
--      IUP_SBDRAGH,    11
----*/
--end if
    return IUP_DEFAULT
end function

function motion_cb(Ihandle /*ih*/, integer x, integer y, atom pStatus)
--?{x,y}
--DEV
--  if currfile then
    if currfile and currfile<=length(filetext) then
        x = floor(x/charwidth)-marginRqd
--      y = TopLine+floor(y/charheight)
        y = floor(y/charheight)+TopLine
--DEV 2/12/16:
--      if x>=0 and y<length(filetext[currfile]) then
        if x>=0 and y>0 and y<length(filetext[currfile]) then
            if not iup_isalt(pStatus) then
                x = min(x,ExpLength(filetext[currfile][y+1]))
            end if
            if iup_isbutton1(pStatus) 
            or iup_isbutton3(pStatus) then
--              string status = peek_string(pStatus)
--              ?{"motion_cb",x,y,status}
--              startSelection(1, 0)
                startSelection(1, iup_isalt(pStatus))
--?{x,y}
                CursorX = x
                CursorY = y
                appUpdateRender()
--              update_statusbar()  -- (now done inside "")
--              if not selON then
--              CursorX = x
--          CursorY = y
--                  selON=1
--              end if
--          if not selON 
--          else
--              startSelection(iup_isshift(pStatus),iup_isalt(pStatus))
--?selON
            end if
        end if
    end if
--/*
iup_isshift(pStatus)
iup_iscontrol(pStatus)
iup_isbutton1(pStatus)
iup_isbutton2(pStatus)
iup_isbutton3(pStatus)
iup_isbutton4(pStatus)
iup_isbutton5(pStatus)
iup_isdouble(pStatus)
iup_isalt(pStatus)
iup_issys(pStatus)
--*/
    return IUP_DEFAULT
end function
--/*
procedure mouseHandler(integer msg, atom wParam, object lParam)
integer x, y, inClipRgn
integer prevCursorY, k
sequence oneline, chunk
object path
--atom msg_pos
atom point
integer tCtrl
sequence screen_coords
integer foldMargin, foldchar
--integer cip3
integer fn
integer ch
integer startx


    if currfile then
        if sequence(lParam) then
            x = lParam[1]
            y = lParam[2]
        end if
        if msg = WM_LBUTTONDOWN 
        or msg = WM_RBUTTONDOWN then
            inClipRgn = c_func(xPtInRegion,{ClipRgn,x,y})
            WExStart = x
        end if
        foldMargin = marginRqd*CharWidth
        if (msg = WM_MOUSEMOVE and and_bits(wParam,MK_LBUTTON) and not F12down)
        or (msg = WM_LBUTTONDOWN and inClipRgn)
        or (msg = WM_RBUTTONDOWN and inClipRgn) then
--          if WESizing and WExStart>=0 then
--              void = setCursor(SizeWECursor)
--              isFilePanelWidth += x-WExStart
--              WExStart = x
--              hideCaret()
--              void = sendMessage(Main,WM_SIZE,0,0)
--          else
                startSelection(Shift(),Menu())
                prevCursorY = CursorY
                if y<ClipRect[2] then                   -- above line 1
                    if TopLine then
                        TopLine = adjustLine(TopLine,-1,TopChunk)
                        TopChunk = nacX
                        paintall()
                    end if
                    CursorY = TopLine
                    paintLines(TopLine,prevCursorY)
                elsif y>ClipRect[4] then                -- below last line
                    CursorY = min(length(filetext[currfile])-1,
                                  adjustLine(TopLine,linesPerPage,TopChunk))
                    paintall()
                else    -- anywhere inbetween, just move cursor, but not past eof.
                    CursorY = min(adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk),
                                  length(filetext[currfile])-1)
                    paintLines(CursorY,prevCursorY)
                end if
                if x<ClipRect[1]+foldMargin then            -- left of column 1
                    if Column then
                        Column = CursorLeft(filetext[currfile][CursorY+1],Column)
                        paintall()
                    end if
                    CursorX = Column
                    if foldMargin and msg = WM_LBUTTONDOWN then
                        foldchar = '-'
                        if sequence(bookmarks[currfile][CursorY+1])
                        and and_bits(bookmarks[currfile][CursorY+1][bfType],FOLD) then
                            foldchar = '+'
                        end if
                        Fold(foldchar,0)
                    end if
                elsif x>ClipRect[3] then                -- right of last column
                    if CursorX<ExpLength(filetext[currfile][CursorY+1]) then
                        CursorX = CursorRight(filetext[currfile][CursorY+1],CursorX)
                    end if
                else    -- anywhere inbetween, just move cursor, but not past eol.
                    CursorX = min(Column+floor((x-ClipRect[1]-foldMargin)/CharWidth),
                                  ExpLength(filetext[currfile][CursorY+1]))
                    if isWordWrapON then
                        void = adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk)
                        CursorX += nacX
                    end if
                end if
                checkCursorX()
                if msg = WM_LBUTTONDOWN then
                    mouseDown = 1
                    captureMouse(Main)
                elsif msg = WM_RBUTTONDOWN then

-- added 5/6/14:
--trace(1)
                    chovinfo = 0
                    if not find(filenames[currfile],{"ex.err","p.err","ctrace.out"}) then
                        oneline = ExpandTabs(filetext[currfile][CursorY+1])
                        chunk = syntaxColour(oneline,CursorY+1,0,0)
                        x = 0
                        for i=1 to chunkMax by 4 do
                            x += chunk[i] -- plus length
                            if x > CursorX then
                                if chunk[i+3] = 5 then  -- correct font
                                    oneline = oneline[x-chunk[i]+1..x]
                                    if chovline=CursorY+1 
                                    and chovto=x then
                                        chovinfo = 1
                                    end if
                                end if
                                exit
                            end if
                        end for
                        chunk = {}
                        x = WExStart
                    end if

                    TrackMenu(0,1,
                              min(Column+floor((x-ClipRect[1])/CharWidth),
                                  ExpLength(filetext[currfile][CursorY+1])),
                              min(adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk),
                                  length(filetext[currfile])-1))
                end if
                if selON=2 or isCurrLineColoured then
                    paintLines(selY,CursorY)
                else
                    paintCursorY()
                end if
--          end if
        elsif msg = WM_MOUSEMOVE then
            WESizing = 0
            softSetFocus(Main)
            if caretBelongsToMain then
                if x >= ClipRect[1]+foldMargin and x <= ClipRect[3]
                and y >= ClipRect[2] and y <= ClipRect[4] then
                    void = setCursor(BeamCursor)
                    captureMouse(Main)
                else
                    if isFilePanelVIS and x<=ClipRect[1] and x>=ClipRect[1]-5 then
                        WESizing = 1
                        WExStart = -1
                        void = setCursor(SizeWECursor)
                    else
                        void = setCursor(ArrowCursor)
                    end if
                    releaseMouse()
                end if
            end if
            if not mouseover then
                mouseover = True
                trackMouseEvent(Main,or_bits(TME_HOVER,TME_LEAVE),HOVER_DEFAULT)
            end if
        elsif msg = WM_LBUTTONDOWN and WESizing then
            void = setCursor(SizeWECursor)
            captureMouse(Main)
        elsif msg = WM_LBUTTONDBLCLK then
            justDblClick = 1    -- focus issues (see eaqj)
        elsif (msg = WM_LBUTTONUP and justDblClick) then
--trace(1)
            justDblClick = 0

            inClipRgn = c_func(xPtInRegion,{ClipRgn,x,y})
            if inClipRgn then
                if find(filenames[currfile],{"ex.err","p.err","ctrace.out"}) then
                    void = virtualKey(VK_F12,0,0)
                    F12down = 1
                else
                    oneline = ExpandTabs(filetext[currfile][CursorY+1])
                    chunk = syntaxColour(oneline,CursorY+1,0,0)
                    x = 0
--                  for i=1 to length(chunk) by 4 do
                    for i=1 to chunkMax by 4 do
                        x += chunk[i] -- plus length
                        if x > CursorX then
--                          cip3 = chunk[i+3]
                            if chunk[i+3] = 5 then  -- correct font
                                oneline = oneline[x-chunk[i]+1..x]
                                if chovline=CursorY+1 
                                and chovto=x then
                                    intellilinkgo()
                                    x = -1
                                else
                                    if length(oneline) >= 5 and oneline[5]=':' then
                                        k = find(LowerCase(oneline[1..4]),{"file","edit"})
                                        if k then
                                            if k=1 and length(oneline)>17
                                            and equal(LowerCase(oneline[1..17]),"file://localhost/") then
                                                k = 3
                                            elsif oneline[6]='\"' and oneline[length(oneline)]='\"' then
                                                oneline = oneline[7..length(oneline)-1]
                                            else
                                                oneline = oneline[6..length(oneline)]
                                            end if
                                            if k=2 then     -- edit:
--                                              void = openFile(oneline,1,isLegacyTabHandling)
                                                {} = openFile(0,oneline,1)
                                                x = -1
                                                exit
                                            end if
                                            if find('#',oneline)>2 then
                                                if k=1 and not find(oneline[2],`:/\`) then
                                                    oneline = "file://localhost/"&filepaths[currfile]&oneline
                                                end if
                                                fn = open("redirect.htm","w")
                                                puts(fn,`<html><head><meta http-equiv=refresh content="0;url=`)
                                                puts(fn,oneline)
                                                puts(fn,`"></head></html>`)
                                                close(fn)
                                                oneline = "redirect.htm"
                                            end if
                                        end if
                                    end if
                                    path = NULL
                                    for j=length(oneline) to 1 by -1 do
                                        if oneline[j]='\\' then
--path = filepaths[currfile]
                                            path = oneline[1..j]
--oneline = oneline[j+1..length(oneline)]
                                            exit
                                        end if
                                    end for
                                    void = shellExecute(NULL, "open", oneline, NULL, path, SW_SHOWNORMAL)
--
--  ShellExecute:
--  If the function fails, the return value is an error value that is less than or equal to 32.
--  The following table lists these error values:
--Value Meaning
--0                             The operating system is out of memory or resources.
--   2  ERROR_FILE_NOT_FOUND    The specified file was not found.
--   3  ERROR_PATH_NOT_FOUND    The specified path was not found.
--  11  ERROR_BAD_FORMAT        The .EXE file is invalid (non-Win32 .EXE or error in .EXE image).
--   5  SE_ERR_ACCESSDENIED     Windows 95 only: The operating system denied access to the specified file. 
--  ?   SE_ERR_ASSOCINCOMPLETE  The filename association is incomplete or invalid.
--  ?   SE_ERR_DDEBUSY          The DDE transaction could not be completed because other DDE transactions 
--                              were being processed.
--  ?   SE_ERR_DDEFAIL          The DDE transaction failed.
--  ?   SE_ERR_DDETIMEOUT       The DDE transaction could not be completed because the request timed out.
--  ?   SE_ERR_DLLNOTFOUND      Windows 95 only: The specified dynamic-link library was not found. 
--  ?   SE_ERR_FNF              Windows 95 only: The specified file was not found. 
--  ?   SE_ERR_NOASSOC          There is no application associated with the given filename extension.
--  ?   SE_ERR_OOM              Windows 95 only: There was not enough memory to complete the operation.
--  ?   SE_ERR_PNF              Windows 95 only: The specified path was not found.
--  32  SE_ERR_SHARE            A sharing violation occurred.
                                    if void = 2 then
                                        IupMessage(xl("Error"),"ERROR_FILE_NOT_FOUND\n("&oneline&")")
                                    elsif void = 3 then
                                        IupMessage(xl("Error"),"ERROR_PATH_NOT_FOUND\n("&path&")")
                                    elsif void = 31 then
                                        IupMessage(xl("Error"),"ERROR_GEN_FAILURE")
                                    elsif void<=32 then
                                        IupMessage(xl("Error"),sprintf("shellExecute error %d",void))
                                    end if
                                    x = -1
                                end if
                            end if
                            exit
                        end if
                    end for
                    if x!=-1 then selectWord(1) end if
                    chunk = {}
                end if
            end if
        elsif msg = WM_LBUTTONUP then
            mouseDown = 0
            F12down = 0
            releaseMouse()
-- moved above 5/6/14 (and forced CursorX/CursorY update).
--      elsif msg = WM_RBUTTONDOWN and inClipRgn then
--
--          TrackMenu(0,1,
--                    min(Column+floor((x-ClipRect[1])/CharWidth),
--                        ExpLength(filetext[currfile][CursorY+1])),
--                    min(adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk),
--                        length(filetext[currfile])-1))
        end if
    end if
    if msg=WM_MOUSEWHEEL then
        wParam = floor(wParam/#10000)
        if wParam>=#8000 then   -- sign bit set
            wParam-=#10000
        end if
        wParam = floor(wParam/120)*mouseWheelScroll

        -- get the mouse position in Client coords
        point = allocate_Point()
        void = c_func(xGetCursorPos,{point})
        void = c_func(xScreenToClient,{mainHwnd,point})
        if peek4s(point)<ClipRect[1] then
            if isVisible(TVdirl) then
                tCtrl = TVdirl
            elsif isVisible(TVprjl) then
                tCtrl = TVprjl
            elsif isVisible(TVrecl) then
                tCtrl = TVrecl
            else
                tCtrl = 0
            end if
            if tCtrl then
                while wParam>0 do
                    void = sendMessage(tCtrl,WM_VSCROLL,SB_LINEUP,0)
                    wParam -= 1
                end while
                while wParam<0 do
                    void = sendMessage(tCtrl,WM_VSCROLL,SB_LINEDOWN,0)
                    wParam += 1
                end while
            end if
        elsif currfile then
            startSelection(Shift(),Menu())
            while wParam>0 and CursorY and TopLine do
                TopLine = adjustLine(TopLine,-1,TopChunk)
                TopChunk = nacX
                CursorY = adjustLine(CursorY,-1,CursorX)
                CursorX = nacX
                paintall()
                wParam -= 1
            end while
            while wParam<0 and CursorY+1<length(filetext[currfile]) do
                TopLine = adjustLine(TopLine,+1,TopChunk)
                TopChunk = nacX
                CursorY = adjustLine(CursorY,+1,CursorX)
                CursorX = nacX
                paintall()
                wParam += 1
            end while
            forceCursorOnscreen()
        end if
    elsif msg=WM_MOUSEHOVER then
        if and_bits(wParam,MK_CONTROL) 
        and currfile then
            inClipRgn = c_func(xPtInRegion,{ClipRgn,x,y})
            if inClipRgn
            and y>=ClipRect[2]
            and y<=ClipRect[4]
            and x>=ClipRect[1]+foldMargin
            and x<=ClipRect[3] then
                y = adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk)+1
                if y<=length(filetext[currfile]) then
                    x = Column+floor((x-ClipRect[1]-foldMargin)/CharWidth)
                    if x<=ExpLength(filetext[currfile][y]) then
                        oneline = ExpandTabs(filetext[currfile][y])
                        while x>0 do
                            ch = oneline[x]
                            if ch<=128 and wordChar[ch+1]!=TokenChar then exit end if
                            if ch='.' then exit end if
                            x -= 1
                        end while
                        startx = x+1
                        while x<length(oneline) do
                            ch = oneline[x+1]
                            if ch<=128 and wordChar[ch+1]!=TokenChar then exit end if
                            if ch='.' then exit end if
                            x += 1
                        end while
                        if x>=startx then
                            intellilink(oneline[startx..x],y,startx)
                        end if
                    end if
                end if
            end if
        elsif chovline!=0 then
            chovline -= 1
            paintLines(chovline, chovline)
            chovline = 0
        end if
        trackMouseEvent(Main,or_bits(TME_HOVER,TME_LEAVE),HOVER_DEFAULT)
--      trackMouseEvent(Main,TME_HOVER,1)
    elsif msg=WM_MOUSELEAVE then
        mouseover = False
    end if
end procedure
mouseHandler(WM_MOUSEHOVER,0,0)
--*/

function isensekey_cb(Ihandle ih, atom c)
    --DEV use key settings...
    switch c do
--      case K_cO: return open_cb(ih)
        case K_TAB,K_CR:
--(DEV this works fine:)
            IupSetStrAttribute(dlg,"TITLE","isensekey_cb:%s",{IupGetAttribute(ih,"VALUESTRING")})
            return IUP_CLOSE
        --DEV to go (when it gets useable):
        case K_ESC: return IUP_CLOSE
--      case K_cSP: intellisense()
--      default: IupSetStrAttribute(dlg,"TITLE","isensekey_cb:%0x",{c})
    end switch
    return IUP_CONTINUE
--  return IUP_IGNORE
end function

procedure intellisense()
--DEV/temp (nick code from Edita!)
--Ihandle list = IupList("CANFOCUS=NO, DROPDOWN=YES, EXPAND=HORIZONTAL")
Ihandle list = IupList("EXPAND=HORIZONTAL, EDITBOX=NO")
--  for i=1 to length(actset) do
--      IupSetAttributeId(tool_rtns, "", i, actset[i])
--  end for
    IupSetAttributeId(list, "", 1, "IupAlarm")
    IupSetAttributeId(list, "", 2, "IupButton")
    IupSetAttributeId(list, "", 3, "IupCanvas")
    IupSetAttributeId(list, "", 4, "IupDialog")
    IupSetAttributeId(list, "", 5, "IupExitLoop")
    IupSetAttributeId(list, "", 6, "IupFill")
--  IupSetInt(list,"VISIBLEITEMS",3)
    IupSetInt(list,"VISIBLELINES",3)
    IupSetInt(list,"VALUE",0)
    Ihandln idialog = IupDialog(list,"BORDER=NO, RESIZE=NO, MAXBOX=NO, MINBOX=NO, MENUBOX=NO")
    IupSetCallback(list, "K_ANY", Icallback("isensekey_cb"))
    integer {x,y} = IupGetIntInt(canvas,"SCREENPOSITION")
    x += charwidth*(CursorX+marginRqd)
    y += charheight*(CursorY-TopLine+1)
    IupPopup(idialog,x,y)
    idialog = IupDestroy(idialog)
end procedure

procedure intellitip()
--DEV/temp/quite a bit more to do here... (nick code from Edita!)
    tip_visible = 1
    appUpdateRender()
end procedure

--DEV fix rein:
--procedure uparrow(integer ctrl, shift, alt)
procedure uparrow(integer ctrl, integer shift, integer alt)
integer newY
    if and_bits(isClearOverStrike,cOVRup) then
        insertMode = 1
    end if
    if alt then
        mouseDown = 1
--          void = virtualKey2(wParam,0,1,1) -- pretend shift down
        shift = 1
    end if
    startSelection(shift,alt)
    if ctrl then
        if TopLine then
            TopLine = adjustLine(TopLine,-1,TopChunk)
            TopChunk = nacX
            CursorY = adjustLine(CursorY,-1,CursorX)
            paintall()
        end if
    else
        if TopLine then
            if distanceFromTopLine(CursorY,CursorX)=0 then
                TopLine = adjustLine(TopLine,-1,TopChunk)
                TopChunk = nacX
                paintall()
            end if
        end if
        newY = adjustLine(CursorY,-1,CursorX)
        if selON or isCurrLineColoured then
            paintLines(newY,CursorY)
        end if
        CursorY = newY
    end if
    CursorX = nacX
    checkCursorX()
    if alt then
        mouseDown = 0
    end if
end procedure

--DEV ditto
--procedure downarrow(integer ctrl, shift, alt)
procedure downarrow(integer ctrl, integer shift, integer alt)
integer newY, wasCursorX
    if and_bits(isClearOverStrike,cOVRdown) then
        insertMode = 1
    end if
    if alt then
        mouseDown = 1
--          void = virtualKey2(wParam,0,1,1) -- pretend shift down
        shift = 1
    end if
    startSelection(shift,alt)
    newY = adjustLine(CursorY,+1,CursorX)
    if newY<length(filetext[currfile]) then
        if ctrl then
            wasCursorX = nacX
            TopLine = adjustLine(TopLine,+1,TopChunk)
            TopChunk = nacX
            nacX = wasCursorX
            CursorY = newY
            paintall()
        else
            if selON or isCurrLineColoured then
                paintLines(CursorY,newY)
            end if
            CursorY = newY
        end if
        CursorX = nacX
        checkCursorX()
    end if
    if alt then
        mouseDown = 0
    end if
end procedure

procedure leftarrow(integer ctrl, shift, alt)
--procedure leftarrow(atom c)
--integer ctrl  = iup_isCtrlXkey(c),
--      shift = iup_isShiftXkey(c), 
--      alt   = iup_isAltXkey(c)
integer newY
    clearcursor()
--catchme=1
    startSelection(shift,alt)
    if isWordWrapON and isCurrLineColoured then paintCursorY() end if
    if ctrl then -- jump word left
        while 1 do
            CursorX = WordLeft(filetext[currfile][CursorY+1],CursorX,alt)
--          string oneline = ConvertTabs(filetext[currfile][CursorY+1],8,isTabWidth)
--          CursorX = WordLeft(oneline,CursorX,alt)
            if CursorX != -1 then exit end if
            if CursorY = 0 then
                CursorX = 0
                exit
            end if
            newY = adjustLine(CursorY,-1,0)
            CursorX = ExpLength(filetext[currfile][newY+1])+alt
            if selON or isCurrLineColoured or isWordWrapON then
                paintCursorY()
                CursorY = newY
                paintCursorY()
            else
                CursorY = newY
            end if
        end while
    else
        if CursorX then
            CursorX = CursorLeft(filetext[currfile][CursorY+1],CursorX)
--          string oneline = ConvertTabs(filetext[currfile][CursorY+1],8,isTabWidth)
--          CursorX = CursorLeft(oneline,CursorX)
            if selON then paintCursorY() end if
        elsif CursorY then  -- move to end of prev. line
--          CursorX = ExpLength(filetext[currfile][adjustLine(CursorY,-1,CursorX)+1])
--          newY = adjustLine(CursorY,-1,CursorX)
            newY = adjustLine(CursorY,-1,0)         -- 21/5/07
            CursorX = ExpLength(filetext[currfile][newY+1]) -- ""
--          CursorX = length(filetext[currfile][newY+1])
            if selON=2 or isCurrLineColoured or isWordWrapON then
                paintCursorY()
                CursorY = newY
                paintCursorY()
            else
                CursorY = newY
            end if
        end if
    end if
    forceCursorOnscreen()
    if selON=2 then
        paintLines(selY,CursorY)
    end if
--catchme=0
    clearcursor()
end procedure

procedure rightarrow(integer ctrl, shift, alt)
--procedure rightarrow(atom c)
--integer ctrl  = iup_isCtrlXkey(c),
--      shift = iup_isShiftXkey(c), 
--      alt   = iup_isAltXkey(c)
integer newY
    clearcursor()
    startSelection(shift,alt)
    if isWordWrapON and isCurrLineColoured then paintCursorY() end if
    if ctrl then -- jump word right
        while 1 do
            CursorX = WordRight(filetext[currfile][CursorY+1],CursorX,alt)
            if CursorX != -1 then exit end if
            CursorX = ExpLength(filetext[currfile][CursorY+1])
            if CursorY >= length(filetext[currfile])-1 then exit end if
            newY = adjustLine(CursorY,+1,CursorX)
            CursorX = -1    -- Let next call to WordRight stop on column 1.
            if selON or isCurrLineColoured or isWordWrapON then
                paintCursorY()
                CursorY = newY
                paintCursorY()
            else
                CursorY = newY
            end if
        end while
    else
        if CursorX<ExpLength(filetext[currfile][CursorY+1]) then
            CursorX = CursorRight(filetext[currfile][CursorY+1],CursorX)
--          string oneline = ConvertTabs(filetext[currfile][CursorY+1],8,isTabWidth)
--          CursorX = CursorRight(oneline,CursorX)
        else                -- linewrap
            newY = adjustLine(CursorY,+1,CursorX)
            if newY<length(filetext[currfile]) then
                if selON or isCurrLineColoured or isWordWrapON then
                    paintCursorY()
                    CursorY = newY
                    paintCursorY()
                else
                    CursorY = newY
                end if
                CursorX = 0
            end if
        end if
    end if
    forceCursorOnscreen()
    if selON=2 then
        paintLines(selY,CursorY)
    end if
    clearcursor()
end procedure

--/*
-- Process Alt function keys.

        if find(wParam,{VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN}) then
            -- column selection
            mouseDown = 1
            void = virtualKey2(wParam,0,1,1) -- pretend shift down
            mouseDown = 0

--*/

function tabkey(integer ctrl, shift, alt)
    if ctrl then
        addAction(INDENT,indentWith(K_TAB))
    elsif alt then
        -- do nothing [
    elsif shift then
--      addAction(UNINDENT,unindent(VK_TAB))
        addAction(UNINDENT,unindent(K_TAB))
    else
        if not deleteSelection() then
--26/1/18: (decided against the utf call)
--          string oneline = filetext[currfile][CursorY+1]
            sequence oneline = filetext[currfile][CursorY+1]
--          if not string(oneline) then oneline = utf32_to_utf8(oneline) end if
            integer k = MapToByte(oneline,CursorX)
            if k then
                if not insertMode then
                    addAction(DELETECHAR,oneline[k])
                end if
            else
--DEV isense: autocomplete?
--DEV if at end of line...
--              if synclr:isautocomplete(VK_ESCAPE) then
                if synclr:isautocomplete(K_ESC) then
                    insertMode = 1
                    string acrest = {synclr:getautocomplete()}
                    addAction(INSERTBLOCK,acrest)
                    InsertBlock(acrest)
--                  c = 0
--                  shift = 1   -- (suppress next)
                    forceCursorOnscreen()
                    return IUP_IGNORE
                end if
            end if
        end if
--      if c='\t' then
--      if shift=0 then
--          addAction(INSERTCHAR,VK_TAB)
            addAction(INSERTCHAR,K_TAB)
--          InsertChar(VK_TAB,insertMode)
            InsertChar(K_TAB,insertMode)
--      end if
    end if
    forceCursorOnscreen()
    return IUP_IGNORE
end function

procedure homekey(integer ctrl, shift, alt)
    clearcursor()
    if and_bits(isClearOverStrike,cOVRhome) then
        insertMode = 1
    end if
    startSelection(shift,alt)
    if ctrl then
--DEV: prevRtnIdx is not set if the toolbar is not visible...
--  if rtnList and prevRtnIdx 
--      if getKeyState(VK_MENU) then        -- Ctrl Alt Home = col 1 (useful for wordwrapped lines)
--      if Menu() then  --[=getKeyState(VK_MENU)]       -- Ctrl Alt Home = col 1
        if alt then --[=getKeyState(VK_MENU)]       -- Ctrl Alt Home = col 1
            jumpTo(0,CursorY)                           --  (useful for wordwrapped lines)
--DEV (1/7/16)
--      elsif prevRtnIdx 
--      and sequence(routines[currfile])
--      and CursorY!=routines[currfile][rtnSTART][prevRtnIdx]-1 then
--          jumpTo(0,routines[currfile][rtnSTART][prevRtnIdx]-1)
        else
            jumpTo(0,0)
        end if
    elsif isHomeFirstNonBlank then
        if isWordWrapON then
            {} = distanceFromTopLine(CursorY,CursorX)
        end if
        if isWordWrapON and landingChunk then
            CursorX = landingChunk
        else
--          newCol = leadingWhiteSpaceLength(filetext[currfile][CursorY+1])
            if CursorX = 0 then
--              CursorX = newCol
                CursorX = leadingWhiteSpaceLength(filetext[currfile][CursorY+1])
            else
                CursorX = 0
            end if
        end if
    elsif isWordWrapON then
        {} = distanceFromTopLine(CursorY,CursorX)
        CursorX = landingChunk
    else
        CursorX = 0
    end if
    forceCursorOnscreen()
    clearcursor()
end procedure

procedure endkey(integer ctrl, shift, alt)
object bci
    clearcursor()
    if and_bits(isClearOverStrike,cOVRhome) then
        insertMode = 1
    end if
    startSelection(shift,alt)
    if ctrl then
        if alt then -- [=getKeyState(VK_MENU)]                  -- Ctrl Alt End = eol
            CursorX = ExpLength(filetext[currfile][CursorY+1])      -- (useful in wordwrap mode)
            jumpTo(CursorX,CursorY)
--DEV (1/7/16)
--      elsif prevRtnIdx 
--      and sequence(routines[currfile])
--      and prevRtnIdx<=length(routines[currfile][rtnEND])
--      and CursorY!=routines[currfile][rtnEND][prevRtnIdx]-1 then
--          jumpTo(0,routines[currfile][rtnEND][prevRtnIdx]-1)
--          CursorX = ExpLength(filetext[currfile][CursorY+1])
        else
            CursorY = length(filetext[currfile])-1
            -- BUT: if last line is folded away (eg eacca.e, Alt -, Ctrl End)
            --      then position at the start of the fold that ends there.
            for i=length(bookmarks[currfile]) to 1 by -1 do
                bci = bookmarks[currfile][i]
                if sequence(bci)
                and and_bits(bci[bfType],FOLD)
                and CursorY=bci[bfEnd] then
                    CursorY = bci[bfStart]
                    exit
                end if
            end for
            CursorX = ExpLength(filetext[currfile][CursorY+1])
            TopLine = 0
            TopChunk = 0
            integer k = distanceFromTopLine(CursorY,CursorX)
            if k>=linesPerPage then
                TopLine = adjustLine(0,k-linesPerPage+1,0)
                TopChunk = nacX
            end if
            paintall()
        end if
    else
        endChunk = 0
        if isWordWrapON then
            {} = distanceFromTopLine(CursorY,CursorX)
        end if
        if endChunk then
            CursorX = endChunk-1
        else
            CursorX = ExpLength(filetext[currfile][CursorY+1])
        end if
    end if
    forceCursorOnscreen()
    clearcursor()
end procedure

procedure pageup(integer ctrl, shift, alt)
    if ctrl then
--      if currfile>1 then
--          if isEnabled(TC) then
--              if shift and isTabBarVIS then
                integer pos = IupGetInt(tabs,"VALUEPOS")
                if pos>0 then
                    if shift then
--                  for i=currfile-1 to 1 by -1 do
--                      if tabs[i] then
--                          shuffleTabs(i-currfile)
--                          exit
--                      end if
--                  end for
--DEV:
                        Ihandle ctab = IupGetAttributeHandle(tabs, "VALUE")
                        integer cidx = IupGetInt(ctab,"FILEIDX")
                        if currfile!=cidx then ?9/0 end if  -- sanity check
                        IupSetInt(tabs,"VALUEPOS",pos-1)
                        Ihandle ntab = IupGetAttributeHandle(tabs, "VALUE")
                        integer nidx = IupGetInt(ntab,"FILEIDX")
                        IupSetInt(ctab,"FILEIDX",nidx)
                        IupSetInt(ntab,"FILEIDX",cidx)
                        -- does not work (as documented):
--                      IupSetAttribute(ctab, "TABTITLE", filenames[nidx])
--                      IupSetAttribute(ntab, "TABTITLE", filenames[cidx])
                        IupSetAttributeId(tabs, "TABTITLE", pos, filenames[nidx])
                        IupSetAttributeId(tabs, "TABTITLE", pos-1, filenames[cidx])
                        setSaveIcon(pos,ctab)
                        setSaveIcon()
--                      currfile = nidx
                    else
--                  for i=currfile-1 to 1 by -1 do
--                      if isTabBarVIS=0 or tabs[i] then
--                          changeTo(i)
--                          exit
--                      end if
--                  end for
--31/8/16:
--if 0 then
--                      IupSetInt(tabs,"VALUEPOS",pos-1)
--                      Ihandle ntab = IupGetAttributeHandle(tabs, "VALUE")
--                      integer nidx = IupGetInt(ntab,"FILEIDX")
----                        currfile = nidx
--                      changeTo(nidx)
--else
                        savecurr()
                        Ihandle ntab = IupGetChild(tabs, pos-1)
                        integer nidx = IupGetInt(ntab,"FILEIDX")
--                      currfile = nidx
                        changeTo(nidx,pos-1)
--                      IupSetInt(tabs,"VALUEPOS",pos-1)
--end if
                    end if
                    IupRefresh(tabs)
                    appUpdateRender()
                end if
--          end if
--      end if
    else
        if and_bits(isClearOverStrike,cOVRpage) then
            insertMode = 1
        end if
        startSelection(shift,alt)
--24/2/10:
--              if TopLine then
        if TopLine or TopChunk then
            TopLine = adjustLine(TopLine,-linesPerPage,TopChunk)
            TopChunk = nacX
            CursorY = adjustLine(CursorY,-linesPerPage,CursorX)
            CursorX = nacX
            paintall()
            checkCursorX()
        elsif CursorY then
            jumpTo(0,0)
        end if
    end if
end procedure

procedure pagedn(integer ctrl, shift, alt)
    if ctrl then
        integer pos = IupGetInt(tabs,"VALUEPOS")
        if pos+1<IupGetInt(tabs,"COUNT") then
            if shift then
                Ihandle ctab = IupGetAttributeHandle(tabs, "VALUE")
                integer cidx = IupGetInt(ctab,"FILEIDX")
                if currfile!=cidx then ?9/0 end if  -- sanity check
                IupSetInt(tabs,"VALUEPOS",pos+1)
                Ihandle ntab = IupGetAttributeHandle(tabs, "VALUE")
                integer nidx = IupGetInt(ntab,"FILEIDX")
                IupSetInt(ctab,"FILEIDX",nidx)
                IupSetInt(ntab,"FILEIDX",cidx)
                -- does not work (as documented):
--              IupSetAttribute(ctab, "TABTITLE", filenames[nidx])
--              IupSetAttribute(ntab, "TABTITLE", filenames[cidx])
                IupSetAttributeId(tabs, "TABTITLE", pos, filenames[nidx])
                IupSetAttributeId(tabs, "TABTITLE", pos+1, filenames[cidx])
                setSaveIcon(pos,ctab)
                setSaveIcon()
            else
                savecurr()
                IupSetInt(tabs,"VALUEPOS",pos+1)
                Ihandle ntab = IupGetAttributeHandle(tabs, "VALUE")
                integer nidx = IupGetInt(ntab,"FILEIDX")
                changeTo(nidx,-1) -- (pos just set)
            end if
            IupRefresh(tabs)
            appUpdateRender()
        end if
    else
        if and_bits(isClearOverStrike,cOVRpage) then
            insertMode = 1
        end if
        startSelection(shift,alt)
        integer filelen = length(filetext[currfile])
        if adjustLine(TopLine,+linesPerPage,TopChunk) < filelen then
            TopLine = adjustLine(TopLine,+linesPerPage,TopChunk)
            TopChunk = nacX
            CursorY = min(adjustLine(CursorY,+linesPerPage,CursorX),filelen-1)
            CursorX = nacX
            paintall()
            checkCursorX()
        elsif CursorY != filelen-1 then
            jumpTo(ExpLength(filetext[currfile][filelen]),filelen-1)
        end if
    end if
end procedure

procedure backdel(integer base, ctrl, shift, /*alt*/)
    if ctrl then
        if base=K_DEL then
            Clip(CUT,shift)
        end if
--  elsif shift and base=K_DEL then
--      Cut(0)  -- No, Ctrl Delete is Cut, not Shift Delete (CSD is cuta)
    else
        if not deleteSelection() then
            integer filelen = length(filetext[currfile])
            if base=K_DEL 
            and CursorX=ExpLength(filetext[currfile][CursorY+1]) then
                -- join two lines
                if CursorY+1<filelen then
                    addAction(DELETEBLOCK,{"",""})
                    replaceLine(CursorY+1,filetext[currfile][CursorY+1]&filetext[currfile][CursorY+2])
                    removeLineLength(CursorY+2)
                    updateQJ(CursorY+1,-1)--,5)
                    filetext[currfile] = filetext[currfile][1..CursorY+1]&
                                         filetext[currfile][CursorY+3..filelen]
                    if length(bookmarks[currfile])!=length(filetext[currfile]) then ?94/(1-isDebug) end if
                    paintall()
                end if
            elsif base=K_BS 
              and CursorX=0 then
                -- join two lines
                if CursorY then
                    CursorX = ExpLength(filetext[currfile][CursorY])
                    CursorY -= 1        -- NB this is correct; previous line, visible or not.
                    replaceLine(CursorY+1,filetext[currfile][CursorY+1]&filetext[currfile][CursorY+2])
                    removeLineLength(CursorY+2)
                    updateQJ(CursorY+1,-1)--,6)
                    filetext[currfile] = filetext[currfile][1..CursorY+1]&
                                         filetext[currfile][CursorY+3..filelen]
                    if length(bookmarks[currfile])!=length(filetext[currfile]) then ?95/(1-isDebug) end if
                    paintall()
                    forceCursorOnscreen()
                    addAction(DELETEBLOCK,{"",""})
                end if
            else
--              string oneline = filetext[currfile][CursorY+1]
                sequence oneline = filetext[currfile][CursorY+1]
                integer myAction
                if base=K_BS then
                    CursorX = CursorLeft(oneline,CursorX)
                    myAction = BACKSPACE
                else
                    myAction = DELETECHAR
                end if
                integer k = MapToByte(oneline,CursorX)
                if k then
                    addAction(myAction,oneline[k])
                    oneline = oneline[1..k-1]&oneline[k+1..length(oneline)]
                    replaceLine(CursorY+1,oneline)
                    paintCursorY()
                    forceCursorOnscreen()
                end if
            end if
        end if
    end if
end procedure

procedure insertkey(integer ctrl, shift, /*alt*/)
-- Note: <Ctrl Insert> and <Shift Insert> are defaults in keyboard.e
    if ctrl then
--DEV keybd:
--?"insertkey(ctrl)"
        Clip(COPY,shift)
    elsif shift then
--DEV keybd:
--?"insertkey(shift)"
        Paste()
    else
        insertMode = not insertMode
        clearSelection()
        update_statusbar()
    end if
end procedure

function autoindent(sequence prevline, integer k)
integer tabs, taba, tokstart, ctype, tokend, c, IndentIdx, thisII
    tabs = 0
    while tabs<k and prevline[tabs+1]='\t' do
        tabs += 1
    end while
    tokstart = tabs+1
    taba = 0
    while tokstart<=k do
        c = prevline[tokstart]
        if c>128 then
            ctype = TokenChar
        else
            ctype = charMap[c+1]
        end if
--DEV may need tweak for TokenFirst/Last:
        if ctype=TokenStart then
            tokend = tokstart+1
            while tokend<=k do
                c = prevline[tokend]
                if c>128 then
                    ctype = TokenChar
                else
                    ctype = charMap[c+1]
                end if
                if ctype>TokenChar then exit end if
                tokend += 1
            end while
            IndentIdx = find(prevline[tokstart..tokend-1],Indents[newSyntax][1])
            if IndentIdx then
                thisII = Indents[newSyntax][2][IndentIdx]
                if taba or thisII = +1 then -- keep taba>=0
                    taba += thisII
                end if
            end if
            tokstart = tokend
        elsif c='\"' then
            while 1 do
                tokstart += 1
                if tokstart>k then exit end if
                c = prevline[tokstart]
                if c = '\\' then
                    tokstart += 1
                elsif c='\"' then
                    tokstart += 1
                    exit
                end if
            end while
--10/07/20
--      elsif length(comment) and c=comment[1]
--      and (length(comment)<2 or (tokstart<k and prevline[tokstart+1]=comment[2]))
--      and (length(comment)<3 or (tokstart<k-1  and prevline[tokstart+2]=comment[3])) then
--          exit        
        else
            bool cfound = false
            for cdx=1 to length(lineComments) do
                string comment = lineComments[cdx]
                if length(comment) and c=comment[1]
                and (length(comment)<2 or (tokstart<k and prevline[tokstart+1]=comment[2]))
                and (length(comment)<3 or (tokstart<k-1  and prevline[tokstart+2]=comment[3])) then
                    cfound = true
                    exit        
                end if
            end for
            if cfound then exit end if
            if length(Indents[newSyntax][3]) then   -- single char indents, eg '{'
                IndentIdx = find(prevline[tokstart],Indents[newSyntax][3])
                if IndentIdx then
                    thisII = Indents[newSyntax][4][IndentIdx]
                    if taba or thisII = +1 then
                        taba += thisII
                    end if
                end if
            end if
            tokstart += 1
        end if
    end while
    return repeat('\t',tabs+taba)
end function

procedure returnkey()
    ensureVisible(CursorY,True) -- unfold (top line too)
    if deleteSelection() then end if
    integer filelen = length(filetext[currfile])
--  string oneline = filetext[currfile][CursorY+1]
    sequence oneline = filetext[currfile][CursorY+1]
    integer k = MapToByte(oneline,CursorX)
--  if acNoDrag(k,oneline,VK_RETURN) then -- check for autocompletes
    if acNoDrag(k,oneline,K_CR) then -- check for autocompletes
        k = 0 -- so don't drag "then", "do", etc to next line.
    end if
    string tabline
    if k=0 then -- end of line
--DEV strip trailing spaces then?
        tabline = autoindent(oneline,length(oneline))
        oneline = tabline
    else
        replaceLine(CursorY+1,oneline[1..k-1])
        tabline = autoindent(oneline,k-1)
        oneline = tabline&oneline[k..length(oneline)]
    end if
    addLineLengths({oneline})
    updateQJ(CursorY+1,1)--,7)
    filetext[currfile] = filetext[currfile][1..CursorY+1]&
                         {oneline}&
                         filetext[currfile][CursorY+2..filelen]
    if length(bookmarks[currfile])!=length(filetext[currfile]) then ?9/(1-isDebug) end if

    addAction(INSERTBLOCK,{"",tabline}) -- /before/ cursor moves...
    CursorX = ExpLength(tabline)
--DEV 8/5/07: hmm... we've just unfolded cY anyhow...
--  CursorY = adjustLine(CursorY,+1,CursorX)
    CursorY += 1
    paintall()
    forceCursorOnscreen()
end procedure

--DEV syntax colour/index:
--ctrl_shift_c = iup_XkeyCtrl(iup_XkeyShift('C'))

function clear_tip_sel()
-- (escape handling)
    if tip_visible 
    or selON then
        tip_visible = 0
        selON = 0
        appUpdateRender()
        update_toolbar()
--SUG:
--  elsif not closeChm() then
--  else
--      return exit_cb(dlg) -- DEV to go (once edix gets useable)
    end if
    return IUP_CONTINUE
end function

--/*
function alt_cb(Ihandle ih, atom c)
?{"alt_cb",sprintf("%x",c)}
string Yelp = "&Yelp"
    Yelp[2] = iup_XkeyBase(c)
    IupSetStrAttribute(main_help_menu,"TITLE",Yelp)
--  IupSetInt(main_help_menu,"VISIBLE",0)
--  return IUP_DEFAULT

--/* DEV (untried)
    switch c do
        case K_mD:  DragLine(+1)                    -- Alt D = drag line down
    end switch
--*/

    return IUP_CONTINUE
--  return IUP_IGNORE
--  return IUP_CLOSE    -- no!
end function
--*/

--function keypress_cb(Ihandle ih, atom c, bool press)
--?{"keypress_cb",c,press}
--  IupSetInt(main_help_menu,"ACTIVE",1)
--  return IUP_IGNORE
--end function

function key_cb(Ihandle ih, atom c)
--?"key_cb"&c
--sleep(1)
    if MacroPlaying=0 then
        c = keybd:mapkey(c)
--?"key_cb=>"&c
    end if
    -- first handle all keys that work without a current file
    switch c do
        case K_cL: return file_panel_cb(NULL)   -- erm? [DEV - ensure a null project tree is fine]
        case K_cN: return new_cb(ih)
        case K_cO: return open_cb(ih)
        case K_ESC: return clear_tip_sel()
    end switch
    if currfile then
        integer base = iup_XkeyBase(c)
        integer ctrl = iup_isCtrlXkey(c)
        integer shift = iup_isShiftXkey(c)
        integer alt = iup_isAltXkey(c)
        if find(base,{K_LSHIFT,K_RSHIFT,K_LCTRL,K_RCTRL,
                      K_LALT,K_RALT,K_NUM,K_SCROLL,K_CAPS}) then
            -- avoid TITLE update, and macro/record
            return IUP_CONTINUE
        elsif alt and find(base,"BD") then
--      elsif alt and find(base,"BCDILUX") then
            -- silence alt keys:
            string Yelp = "&Yelp"
            Yelp[2] = base
            IupSetStrAttribute(main_help_menu,"TITLE",Yelp)
            reset_help = true
        end if
        if MacroLearn
        and not find(base,{K_F6,K_F7,K_F8,K_F9}) then
--          MacroKeys[MacroLearn] = append(MacroKeys[MacroLearn],{MR_VIRT,{base,ctrl,shift}}) --,alt?
--          MacroKeys[MacroLearn] = append(MacroKeys[MacroLearn],{MR_KEY,{c}})
            MacroKeys[MacroLearn] = append(MacroKeys[MacroLearn],c)
        end if
        if iup_isprint(c) then
--          IupSetStrAttribute(dlg,"TITLE","iup_isprint:%0x",{c})
            if deleteSelection() then end if
            addAction(INSERTCHAR,c)
            InsertChar(c,insertMode)
            update_toolbar()
            return IUP_CONTINUE
        end if
        if base!=K_LEFT
        and base!=K_RIGHT then  
            tip_visible = 0     --DEV (not left/right?)
        end if
        switch base do
            case K_CR: returnkey()
            case K_UP: uparrow(ctrl,shift,alt)
            case K_DOWN: downarrow(ctrl,shift,alt)
            case K_LEFT: leftarrow(ctrl,shift,alt)
            case K_RIGHT: rightarrow(ctrl,shift,alt)
            case K_TAB: return tabkey(ctrl,shift,alt)
            case K_PGUP: pageup(ctrl,shift,alt)
            case K_PGDN: pagedn(ctrl,shift,alt)
            case K_BS: backdel(base,ctrl,shift,alt)
            case K_INS: insertkey(ctrl,shift,alt)
            case K_DEL: backdel(base,ctrl,shift,alt)
            case K_HOME: homekey(ctrl,shift,alt)
            case K_END: endkey(ctrl,shift,alt)
--          case K_Menu: CSM(ctrl,shift,alt)
            case K_Menu: menu_key(ctrl,shift,alt)
--          case K_F1: F1help(ctrl,shift,alt)
--          case K_F1: {} = help_cb(F1menuitem)
            case K_F1: F1key(ctrl)
--          case K_F2: F2mark(ctrl,shift,alt)
            case K_F3: fdlg:F3find(ctrl,shift)
            case K_F4: F4key(ctrl,shift,alt)
            case K_F5: F5key(ctrl,shift)--,alt)
            case K_F6, K_F7, K_F8, K_F9: macro:macrokey(base,ctrl,shift,alt)
            case K_F12: F12() -- (jump to error) --ctrl,shift,alt)
--DEV cannot stop the bell on alt...
--          case '<',',': addAction(UNINDENT,unindent(iff(alt?K_TAB:comment))) --return IUP_IGNORE
            case '<',',': addAction(UNINDENT,unindent(iff(alt?K_TAB:lineComments[1]))) --return IUP_IGNORE
--trace(1)
--          case '>','.': addAction(INDENT,indentWith(iff(alt?K_TAB:comment))) --return IUP_DEFAULT
            case '>','.': addAction(INDENT,indentWith(iff(alt?K_TAB:lineComments[1]))) --return IUP_DEFAULT
--          case '-','+': fold(base,ctrl,shift,alt)
            case '[',']': bracket(base,ctrl,shift,alt)
--          case K_LSHIFT,K_RSHIFT,K_LCTRL,K_RCTRL,
--               K_LALT,K_RALT,K_NUM,K_SCROLL,K_CAPS:
--              break   -- (avoid TITLE update)
            default:
            switch c do
                case K_cA:  selectAll()
                case K_cB:  show_as_base(2)
                case K_csB: show_as_base(8)
                case K_mB:  DragLine(-1)                    -- Alt B = drag line back up
                case K_cC:  Clip(COPY,0)                    -- normal copy (Ctrl C)
                case K_csC: Clip(COPY,1)                    -- copy append (Ctrl Shift C)
                case K_msC: Clip(COPY,-1)                   -- copy prepend (Alt Shift C)
                case K_cD:  duplicate_line()
                case K_csE: zoom(+1)
                case K_mD:  DragLine(+1)                    -- Alt D = drag line down
                case K_cF:  fdlg:find_dialog()
--              case K_csF: return fif_cb(dlg) --FIF()
                case K_csF: fif:find_in_files()
                case K_cG:  return gdlg:goto_cb(dlg)        -- (K_mG via keyboard.e)
                case K_cH:  show_as_base(16)
                case K_csH: return showfmt_cb(toolm_showf)  -- show_formatting()
                case K_mI:  caseOp(INVERT)
                case K_csO: return reopen_cb(file_reopen)
                case K_cJ:  show_as_base(-1)                -- toggle seq
                case K_cK:  show_as_base(10)
                case K_csL: toggle_line_numbers()
                case K_mL:  caseOp(LOWER)
                case K_msL: caseOp(SENTENCE)
                case K_cP:  return preview_cb(file_prntp)   -- print preview
                case K_cQ:  onClickToolQjmp()
                case K_csR: zoom(-1)
--SUG:
                case K_cS:  return save_cb(ih)
--              case K_cS:  {} = save_file(currfile)
--              case K_cT:  fileList()
                case K_cT:  IupFileList(filenames, filepaths, openFile, dlg, config)
                case K_mU:  caseOp(UPPER)
                case K_msU: caseOp(CAPITALISE)
                case K_cV:  Paste()
                case K_cW:  selectWord(1)
--              case K_mW:  word_wrap()
                case K_cX:  Clip(CUT,0)                     -- normal cut (Ctrl X)
                case K_csX: Clip(CUT,1)                     -- cut append (Ctrl Shift X)
                case K_msX: Clip(CUT,-1)                    -- cut prepend (Alt Shift X)
                case K_cY:  UndoRedo(REDO)
                case K_cZ:  UndoRedo(UNDO)
                case K_cSP: intellisense()
                case K_csSP: intellitip()
--/*
(I think the above is better)
constant K_cGT = iup_XkeyCtrl('>')
constant K_mGT = iup_XkeyAlt('>')
constant K_cLT = iup_XkeyCtrl('<')
constant K_mLT = iup_XkeyAlt('<')
--*/
--              case K_cGT: comment()
--              case K_mGT: indent()
--              case K_cLT: uncomment()
--              case K_mLT: unindent()
--/*
    Ctrl:                       Ctrl+Shift:              Alt:               Alt+Shift:
 -  Fold                        Re-fold                  Fold all           -
 +  Expand                      -                        Expand all         -
 [  Bracket/Ctrl back           (+block select)          -                  -
 ]  Bracket/Ctrl fwd            (+block select)          -                  -


Function keys
=============                    Ctrl:               Shift:              Ctrl+Shift:     Alt:
 F1         Help                Keyboard Help       -                   -
 F2         Next Bookmark       Toggle Bookmark     Prior BookMark      Cancel All Bookmarks
 F3         Find Next           Find First sel      Find Prior          Find Next sel
 F4         Next Difference     Close file          Previous Difference -               Exit Edita
 F5         Run                 Parameterised Run   Run Previous        Run Direct*
 F6         Play Macro F6       Record F6           -                   -
 F7         Play Macro F7       Record F7           -                   -
 F8         Play Macro F8       Record F8           Macro Management    -
 F9         Play Macro F9       Record F9           -                   -
 F10        [Windows Menu]                          [Context menu]
 F11        FullScreen          -                   Hide menus          -
 F12        Jump to Error       -                   -                   -
 Backspace  Delete left
 Insert     INS/OVR             Copy                Paste               Copy Append     Comment
 Delete     Delete              Cut                 -                   Cut Append      Uncomment
 CSM        Context menu        Tab menu
 Esc        Cancel selection    [Start Menu]                            -
 Tab        Insert Tab char     increase indent     decrease indent     -               [Switch App.]
--*/
                default:
                    if not alt then -- (assume a menu key) [DEV this is temp anyway...]
                        IupSetStrAttribute(dlg,"TITLE","key_cb:%0x",{c})
--                      IupSetStrAttribute(dlg,"TITLE","key_cb:%0x (base=%0x)",{c,base})
                    end if
            end switch
        end switch
    end if
    update_toolbar()
--  return IUP_CONTINUE
--  return IUP_DEFAULT
    return IUP_IGNORE
end function
r_macro_key = routine_id("key_cb")

--/*
--Note: this means key_cb will not be called:
function K_action_cb(Ihandle /*ih*/)
?"K_action_cb"
  return IUP_IGNORE
--  return IUP_CONTINUE
--  return IUP_DEFAULT
end function

--public constant IUP_K_comma = "K_comma"
--public constant IUP_K_minus = "K_minus"
--public constant IUP_K_period = "K_period"

--public constant IUP_K_mUP = "K_mUP"


function keypress_cb(Ihandle /*ih*/, atom /*c*/, bool /*press*/)
?"keypress_cb"
    return IUP_IGNORE
--  return IUP_CONTINUE
--  return IUP_DEFAULT
end function

function globalkeypress_cb(atom /*c*/, bool /*press*/) 
?"globalkeypress_cb"
--sleep(1)
    return IUP_IGNORE
--  return IUP_DEFAULT
--  return IUP_CONTINUE
end function
--constant cb_keypress = Icallback("keypress_cb")
--*/

function tabchange_cb(atom /*self*/, atom new_tab, atom old_tab)
--  if self or old_tab then end if
--  IupSetFocus(new_tab)
--  sequence path = IupGetAttribute(new_tab, "PATH")

--  atom field1 = IupGetHandle("field1")
--  IupSetAttribute(field1, "TITLE", path)
    tip_visible = 0
--18/7/16:
    integer fidx = IupGetInt(new_tab,"FILEIDX")
--  savecurr()  -- no help...
--2/12/16:
if fidx!=0 then
    changeTo(fidx,-1)   -- (pos not changed)
end if

--DEV I should probably have a posmap[] to do this... (and get rid of FILEIDX)
    for pos=0 to IupGetInt(tabs,"COUNT")-1 do
        if IupGetChild(tabs, pos)=old_tab then
            setSaveIcon(pos, old_tab)
            exit
        end if
    end for

    appUpdateRender()

    return IUP_DEFAULT
end function

object PTICK,       -- (get_image("PNG_Ptick"), after IupOpen)
       PBACK=NULL   -- (get_image("PNG_Pback"), after IupOpen)

Ihandle tproject, tdirectory

function projdir_cb(Ihandle ih, integer state)
--function projdir_cb(Ihandle ih)
object image
--DEV this is probably not right for directory... which probably wants PTICK in IMAGEid and IMAGEEXPANDEDid for all non-dir nodes,
--                                                                      NULL for IMAGEBRANCHCOLLAPSED and IMAGEBRANCHEXPANDED on dirs,
--                                                                      possibly drive icons for the actual drives,
--                                                                      and a new image for IMAGELEAF (backup) nodes.

--  integer state = IupGetInt(ih,"VALUE")
--?{iff(ih=tproject?"project":iff(ih=tdirectory?"directory":"???")),state}
    if state=1 then
        image = iff(ih=tproject?PTICK:NULL)
        IupSetStrAttribute(tree, "IMAGEBRANCHCOLLAPSED", image)
        IupSetStrAttribute(tree, "IMAGEBRANCHEXPANDED", image)
        if ih=tdirectory then
            if PBACK=NULL then
                PBACK = get_image("PNG_Pback")
            end if
            image = PBACK
        end if
        IupSetStrAttribute(tree, "IMAGELEAF", image)
    end if
    return IUP_DEFAULT
end function

function copydata_cb(Ihandle /*ih*/, atom v, integer size)
--  if ih then end if
    printf(1,"COPYDATA(%s, %d)\n",{peek_string(v), size});
    return IUP_DEFAULT;
end function

-- moved to ini.e:
--/*
function decode11(string s)
-- (retrieves cursel session info from the config file)
sequence res = repeat(0,11), work
    s = trim(s,"{}")
    work = split(s,',')
    if length(work)=11 then
        for i=1 to 11 do
            string numstr = work[i]
            integer ri = 0
            for j=1 to length(numstr) do
                integer ch = numstr[j]
                if ch<'0' or ch>'9' then
                    -- (should never trigger)
                    ?"warning: ini cursel decode error"
                    ri = 0
                    exit
                end if
                ri = ri*10+ch-'0'
            end for
            res[i] = ri
        end for
    end if
    res[11] += 1    -- increment "un-visted count"
    return res
end function
--*/

function idle_action()
    if not load_prev_file() then
        saveINI()
        return IUP_IGNORE -- removes the callback
    end if
    return IUP_CONTINUE
end function

--with trace
--trace(1)
procedure main()
bool normalconfig = true

--  IupOpen(join_path({initialcurrentdir,"..","pGUI"},1))
    IupOpen()

    IupSetGlobal("SINGLEINSTANCE", "Edix") -- (must [partially] match the main window title)
    if IupGetGlobal("SINGLEINSTANCE")="" then
        ?"SINGLEINSTANCE!"
if 01 then
        normalconfig = false
else
--DEV/temp[?]:
        sleep(1)
        IupClose()
        return
end if
    end if

--  IupImageLibOpen()   -- (no longer used)

    IupSetGlobal("UTF8MODE","YES")
--  IupSetGlobal("GLOBALMENU","YES")
    IupSetGlobal("GLOBALMENU","NO")

    config = IupConfig()
--  IupSetAttribute(config, "APP_NAME", "edix")
    string configname = iff(normalconfig?"edix":"edix2")
    IupSetAttribute(config, "APP_NAME", configname)
    integer errcode = IupConfigLoad(config)
    loadINI(configname)
    if errcode!=0 then
        ?{"IupConfigLoad error",errcode}
--      ?9/0
    end if

    clipboard = IupClipboard()

--/*
    item_revert = IupMenuItem("&Revert");
    IupSetAttribute(item_revert, "NAME", "ITEM_REVERT");
    IupSetCallback(item_revert, "ACTION", Icallback("item_revert_action_cb"));

    item_exit = IupMenuItem("E&xit");
    IupSetCallback(item_exit, "ACTION", cb_exit);

    btn_find = IupButton()
    IupSetAttribute(btn_find, "IMAGE", "PNG_EditFind");
    IupSetAttribute(btn_find, "FLAT", "Yes");
    IupSetCallback(btn_find, "ACTION", Icallback("item_find_action_cb"));
    IupSetAttribute(btn_find, "TIP", "Find (Ctrl F)");
    IupSetAttribute(btn_find, "CANFOCUS", "No");

    item_find_next = IupMenuItem("Find &Next\tF3");
    IupSetAttribute(item_find_next, "NAME", "ITEM_FINDNEXT");
    IupSetCallback(item_find_next, "ACTION", fdlg:cb_findnext);

    item_replace = IupMenuItem("&Replace...\tCtrl H");
    IupSetCallback(item_replace, "ACTION", Icallback("item_replace_action_cb"));

    item_toolbar = IupMenuItem("&Toobar");
    IupSetCallback(item_toolbar, "ACTION", Icallback("item_toolbar_action_cb"));
    IupSetAttribute(item_toolbar, "VALUE", "ON");

    item_statusbar = IupMenuItem("&Statusbar");
    IupSetCallback(item_statusbar, "ACTION", Icallback("item_statusbar_action_cb"));
    IupSetAttribute(item_statusbar, "VALUE", "ON");

    item_font = IupMenuItem("&Font...");
    IupSetCallback(item_font, "ACTION", Icallback("item_font_action_cb"));

    item_help = IupMenuItem("&Help...");
    IupSetCallback(item_help, "ACTION", Icallback("item_help_action_cb"));

    item_about = IupMenuItem("&About...");
    IupSetCallback(item_about, "ACTION", Icallback("item_about_action_cb"));

    recent_menu = IupMenu({});

    file_menu = IupMenu({item_new,
                         item_open,
                         item_save,
                         item_saveas,
                         item_revert,
                         IupSeparator(),
                         IupSubmenu("Recent &Files", recent_menu),
                         item_exit});
    edit_menu = IupMenu({item_cut,
                         item_copy,
                         item_paste,
                         item_delete,
                         IupSeparator(),
                         item_find,
                         item_find_next,
                         item_replace,
                         item_goto,
                         IupSeparator(),
                         item_select_all});
    format_menu = IupMenu({item_font});
    view_menu = IupMenu({item_toolbar,
                         item_statusbar});
    help_menu = IupMenu({item_help,
                         item_about});

    IupSetCallback(file_menu, "OPEN_CB", Icallback("file_menu_open_cb"));
    IupSetCallback(edit_menu, "OPEN_CB", Icallback("edit_menu_open_cb"));

    sub_menu_file = IupSubmenu("&File", file_menu);
    sub_menu_edit = IupSubmenu("&Edit", edit_menu);
    sub_menu_format = IupSubmenu("F&ormat", format_menu);
    sub_menu_view = IupSubmenu("&View", view_menu);
    sub_menu_help = IupSubmenu("&Help", help_menu);

    menu = IupMenu({sub_menu_file,
                    sub_menu_edit,
                    sub_menu_format,
                    sub_menu_view,
                    sub_menu_help});

    toolbar_hb = IupHbox({btn_new,
                          btn_open,
                          btn_save,
                          IupLabel(NULL, "SEPARATOR=VERTICAL"),
                          btn_cut,
                          btn_copy,
                          btn_paste,
                          IupLabel(NULL, "SEPARATOR=VERTICAL"),
                          btn_find});

    IupSetAttribute(toolbar_hb, "MARGIN", "5x5");
    IupSetAttribute(toolbar_hb, "GAP", "2");

    vbox = IupVbox({toolbar_hb,
                    multitext,
                    lbl_statusbar});

    dlg = IupDialog(vbox);

--*/

--  Ihandle item_exit = menu_item("item_exit","E&xit", "PNG_FileExit", cb_exit, 1)

--  Ihandle file_menu = IupMenu({item_new,
--                               item_open,
--                               item_save,
--                               item_saveas,
----                                 item_revert,
----                                 IupSeparator(),
----                                 IupSubmenu("Recent &Files", recent_menu),
--                               item_exit});

    Ihandle toolbar = create_toolbar()
--  Ihandle toolbar = IupHbox({btn_new,
--                                btn_open,
--                                btn_save,
----                                  IupLabel(NULL, "SEPARATOR=VERTICAL"),
----                                  btn_cut,
----                                  btn_copy,
----                                  btn_paste,
----                                  IupLabel(NULL, "SEPARATOR=VERTICAL"),
----                                  btn_find});
--})


    tabs = IupTabs({})
--DEV edit option?
--if 01 then
    IupSetAttribute(tabs, "SHOWCLOSE", "YES")
--  IupSetAttribute(tabs, "MAXSIZE", "x28")
    IupSetAttribute(tabs, "PADDING", "x4")
--  IupSetAttribute(tabs, "RASTERSIZE", "1x1")
--else
--  IupSetAttribute(tabs, "PADDING", "4x4")
--end if
--  IupSetAttribute(tabs, "MULTILINE", "YES") -- NAH
    IupSetCallback(tabs, "TABCHANGE_CB",  Icallback("tabchange_cb"))
    IupSetCallback(tabs, "TABCLOSE_CB",   Icallback("tabclose_cb"))
--  IupSetCallback(tabs, "GETFOCUS_CB",   Icallback("tabfocus_cb")) --NO!
    IupSetCallback(tabs, "RIGHTCLICK_CB", Icallback("tab_rightclick_cb"))

--NB: SCROLLBAR is creation-only... (use XAUTOHIDE/YAUTOHIDE to hide/show instead..)
    canvas = IupCanvas(Icallback("redraw_cb"), "RASTERSIZE=200x20, SCROLLBAR=YES, CURSOR=TEXT")
    IupSetCallback(canvas, "MAP_CB",    Icallback("map_cb"))
    IupSetCallback(canvas, "UNMAP_CB",  Icallback("unmap_cb"))
--  IupSetCallback(canvas, "ACTION",    Icallback("redraw_cb"))
    IupSetCallback(canvas, "BUTTON_CB", Icallback("canvas_button_cb"))
--DROPFILES_CB
--MOTION_CB??
    IupSetCallback(canvas, "SCROLL_CB", Icallback("scroll_cb"))
    IupSetCallback(canvas, "MOTION_CB", Icallback("motion_cb"))

    cursorblink = IupTimer(cb_cursorblink, 400)
    autosavetimer = IupTimer(cb_save,isAutoSaveTimer*1000,isAutoSaveTimer!=0)   -- (every 5 mins)
    -- image updating on toolb_back:
    backtimer = IupTimer(cb_backtimer, 200)
    IupSetAttribute(backtimer,"RUN","NO")
    rotate_images = {get_image("PNG_rotate1"),
                     get_image("PNG_rotate2"),
                     get_image("PNG_rotate6"),
                     get_image("PNG_rotate7")}

    tree = IupTree();
--  IupSetAttribute(tree, "SHOWRENAME", "YES");
    IupSetAttribute(tree, "EXPAND", "YES");
--  IupSetAttribute(tree, "SHRINK", "YES");
--  IupSetAttribute(tree,"RASTERSIZE","100x150");
--?IupGetHandle(tree,"IMAGEBRANCHCOLLAPSED")    -- nah, they're globals
--?IupGetHandle(tree,"IMAGEBRANCHEXPANDED")
    PTICK = get_image("PNG_Ptick")
    IupSetStrAttribute(tree, "IMAGEBRANCHCOLLAPSED", PTICK)
    IupSetStrAttribute(tree, "IMAGEBRANCHEXPANDED", PTICK)
    IupSetStrAttribute(tree, "IMAGELEAF", PTICK)

--  Ihandle scrollbox = IupScrollBox(canvas)

--  rtbox = IupExpander(IupSetAttributesf(IupSbox(IupVbox({IupRadio(IupHbox({IupToggle("Project"),IupToggle("Directory")})),
--                                                         tree})),"DIRECTION=EAST"))
--  rtbox = IupExpander(IupVbox({IupRadio(IupHbox({IupToggle("Project"),IupToggle("Directory")})),
--                                                         tree}))
--  IupSetAttribute(rtbox,"BARPOSITION","LEFT")
--DEV mnemonic support question asked 19/6/16 - will be fixed next release 20/6/16
    tproject = IupToggle("Project","ACTION",Icallback("projdir_cb"))
--  tproject = IupToggle("&Project","ACTION",Icallback("projdir_cb"))
--  tproject = IupToggle("&Project","VALUECHANGED_CB",Icallback("projdir_cb"))
    tdirectory = IupToggle("Directory","ACTION",Icallback("projdir_cb"))
--  tdirectory = IupToggle("&Directory","ACTION",Icallback("projdir_cb"))
--  tdirectory = IupToggle("&Directory","VALUECHANGED_CB",Icallback("projdir_cb"))
    Ihandle radio = IupRadio(IupHbox({tproject,tdirectory},"MARGIN=4x4"))
    IupSetAttributePtr(radio,"VALUE_HANDLE",tproject)
--  IupSetAttributePtr(radio,"VALUE_HANDLE",tdirectory)
    rtbox = IupVbox({radio,
--  rtbox = IupVbox({IupHbox({radio,htlbl}),
                     tree})
--  IupSetAttribute(rtbox,"SHRINK","YES")
--  tbox = IupHbox({rtbox,tcbox})
    tcbox = IupVbox({tabs,canvas})

--DEV cannot get VALUE to do anything meaningful...
--  tbox = IupSetAttributesf(IupSplit(rtbox,tcbox),"ORIENTATION=VERTICAL, AUTOHIDE=YES, VALUE=305")
    tbox = IupSplit(rtbox,tcbox,"ORIENTATION=VERTICAL, AUTOHIDE=YES, VALUE=305")
--  tbox = IupSetAttributesf(IupSplit(rtbox,tcbox),"ORIENTATION=VERTICAL, AUTOHIDE=YES, NORMALIZESIZE=HORIZONTAL")
--  tbox = IupSetAttributesf(IupSplit(rtbox,tcbox),"ORIENTATION=VERTICAL, AUTOHIDE=YES")

--DEV an IupHbox with 5 fixed (LineCol, InsOvr, Char, Date, Time) and one expand...
--  better: 2 fixed, auto-expand to fit??
--  statusbar = IupLabel("Line 1 of 1, Column 1","NAME=STATUSBAR, EXPAND=HORIZONTAL, PADDING=10x5")
    sbline = IupLabel("Line 1 of 1, Column 1","PADDING=10x5,SIZE=120x")
    sbinfo = IupLabel("UTF-16 INS #cccc ","PADDING=10x5,SIZE=80x")
    sbdate = IupLabel("dd Mmmm Yyyy hh:mmpm","PADDING=10x5")--,"SIZE=??")
--  sbtemp = IupLabel("gdi","PADDING=10x5")
    sbmsg  = IupLabel("","EXPAND=HORIZONTAL, PADDING=10x5")
--  sbhbox = IupHbox({sbline,sbinsovr,sbchar,sbdate,sbtime,sbmsg})
    sbhbox = IupHbox({sbline, -- (Line n of m, Column c)
                      IupLabel(NULL, "SEPARATOR=VERTICAL"),
                      sbinfo, -- (INS/OVR, char)
                      IupLabel(NULL, "SEPARATOR=VERTICAL"),
                      sbdate, -- (date and time)
--                    sbtemp,
                      IupLabel(NULL, "SEPARATOR=VERTICAL"),
                      sbmsg})
    integer seconds = (60-date()[DT_SECOND])*1000 -- (on next whole minute)
    Ihandle time_update = IupTimer(cb_update_time,seconds,true)

    Ihandle vbox = IupVbox({toolbar,
                            tbox,
                            sbhbox});
--  IupSetAttribute(vbox, "SHRINK", "YES");

    dlg = IupDialog(vbox, "TITLE=Edix, SHRINK=YES")
--  IupSetGlobal("PARENTDIALOG", dlg)
--  IupSetHandle("PARENTDIALOG", dlg)
    IupSetAttributeHandle(NULL,"PARENTDIALOG",dlg) -- gah, no better... (1/9/2020)
--  IupSetAttributePtr(NULL,"PARENTDIALOG",dlg) -- gah, no better... (1/9/2020)
--  IupSetAttribute(dlg, "MINSIZE", "144x87")   -- 96x46
--  IupSetAttribute(dlg, "MINSIZE", "216x163")  -- 144x87
    IupSetAttribute(dlg, "MINSIZE", "462x163")
--  menu = create_menu()
--  IupSetAttributeHandle(dlg, "MENU", menu)
    IupSetAttributeHandle(dlg, "MENU", create_menu())

    IupSetCallback(dlg, "K_ANY",       Icallback("key_cb"))
--  IupSetCallback(dlg, "K_mD",    Icallback("alt_cb"))
--if 0 then
--  IupSetCallback(dlg, "KEYPRESS_CB", Icallback("keypress_cb"))
----    IupSetCallback(canvas, "KEYPRESS_CB", Icallback("keypress_cb"))
--  IupSetCallback(canvas, "KEYPRESS_CB", Icallback("keypress_cb"))
--end if
--if 0 then
--  IupSetGlobalFunction("GLOBALKEYPRESS_CB",Icallback("globalkeypress_cb"))
--IupSetGlobal("INPUTCALLBACKS","YES")
--end if
--if 0 then
----IupSetCallback(dlg, "K_c0", (Icallback)K_action_cb);
----IupSetCallback(dlg, "K_mcomma", Icallback("K_action_cb"))
--IupSetCallback(dlg, "K_mComma", Icallback("K_action_cb"))
--IupSetCallback(dlg, "K_mC", Icallback("K_action_cb"))
--end if


    IupSetCallback(dlg, "RESIZE_CB",   Icallback("resize_cb"))
    IupSetCallback(dlg, "COPYDATA_CB", Icallback("copydata_cb"));
    IupSetCallback(dlg, "CLOSE_CB",    Icallback("exit_cb"));
--DEV temp (to avoid confusing Edita with Edix, on the taskbar)
--  IupSetStrAttribute(dlg, "ICON", "icons/95.ico")
    IupSetStrAttribute(dlg, "ICON", "icons/96.ico")
    -- (above might not be supported by GDK-PixBuf ... in which case:)
--  IupSetStrAttribute(dlg, "ICON", iff(platform()=WINDOWS?`icons\95.ico`:"icons/95.png"))
    -- (for some reason, despite the fact they are both 32x32bit identical/lossless images,
    --  windows does a far better job resizing the .ico to 16x16 than it does with .png)

--DEV previous location/size (IupConfig) [DONE]
    IupSetAttribute(dlg, "SIZE", "211x183")


--  IupSetAttribute(vbox,"MARGIN","5x5");
--  IupSetAttribute(vbox,"GAP","5");

    IupMap(dlg);

--DEV do this later, with project/directory/recovery info...
--(actually, use IupAddNodes()...)
    IupSetAttribute(tree, "TITLE0",     "Figures");
    IupSetAttribute(tree, "ADDLEAF0",   "Other")         /* new id=1 */
    IupSetAttribute(tree, "ADDBRANCH1", "triangle");     /* new id=2 */
    IupSetAttribute(tree, "ADDLEAF2",   "equilateral");  /* ... */
    IupSetAttribute(tree, "ADDLEAF3",   "isoceles");
    IupSetAttribute(tree, "ADDLEAF4",   "scalenus");
    IupSetAttribute(tree, "RASTERSIZE", NULL)
--  IupSetAttribute(tree, "SHRINK", "YES")

    IupSetInt(tbox,"VALUE", 0)  -- (visibility glitch if this is done before IupMap)

    IupConfigDialogShow(config, dlg, "MainWindow")

    -- set parent for pre-defined dialogs in closed functions (IupMessage and IupAlarm)
--  IupSetGlobal("PARENTDIALOG", dlg)

--if not USEINI or isNewIni() then
--  sequence prevfiles = {}
--  -- restore session
--  integer currfileN = IupConfigGetVariableInt(config,"Session","current")
--  for i=1 to IupConfigGetVariableInt(config,"Session","Max") do
--      string filepath = IupConfigGetVariableStrId(config,"Session","filepath",i)
--      if filepath!="" then
----if USEINI then
--          prevfiles = append(prevfiles,filepath&","&IupConfigGetVariableStrId(config,"Session","cursel",i))
--          if i=currfileN then currfileN = length(prevfiles) end if
---- Hi antonio,
----    I was getting a bit of jip from my IupConfig, so I've reverted to an older .ini method of storing things.
----    In doing so
----filepath200..209 missing, 210..282 present, cursel215+ missing (cursel200..209 correctly ignored)
----hmm... there really is no cursel10...63
----else
----            if openFile(1,filepath,-1) then
----                sequence cursel = decode11(IupConfigGetVariableStrId(config,"Session","cursel",i),i)
----                filecursel[$] = cursel
------?filecursel
----                restcursel()
------          else
------DEV delayed message
------              ?? &= filepath&"\n"             
----            elsif currfileN>=i then
------?9/0
----                currfileN -= 1
----            end if
----end if
--      end if
--  end for
--  currfile = currfileN
----    if USEINI then
--      iniSetPrev(prevfiles,currfile)
----    end if
--end if
--if USEINI then
    iniCreateTabs()
    if load_prev_file() then
        IupSetGlobalFunction("IDLE_ACTION", Icallback("idle_action"))
    end if
--end if

--?currfile
--  if currfile!=0 then
    if length(filenames)!=0 then
        if currfile=0 then
            currfile = 1
        end if
--?{"currfile = ",currfile}
        IupSetInt(tabs,"VALUEPOS",currfile-1)
        restcursel()
        IupRefresh(tabs)
        changeTo(currfile,-1)   -- (pos just set)
    end if

    IupSetFocus(canvas)

--  IupSetGlobal("CURSORPOS","200x200") -- no, that's the mouse!

    IupMainLoop()

    clipboard = IupDestroy(clipboard)

    IupClose()
end procedure

main()

