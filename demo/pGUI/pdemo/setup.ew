--
-- setup.ew
-- ========
--
--  Part of pdemo.exw; as much code as possible for the setup (registry settings) tab should reside in here.
--
--  Of course I realise this is somewhat over-engineered (and then some) for the average home user, but if
--  we are to do it at all, may as well do it right. Trust me when I say that I now understand why so many
--  compiler/development environments make you configure these things by hand. Since Windows Vista most of
--  the registry is read-only to standard applications, so I have elected to do everything via .reg files,
--  or at least use regedit commands to import them.
--
--  For more information about .reg files, see (eg) http://support.microsoft.com/kb/310516
--                                              or  http://en.wikipedia.org/wiki/Windows_Registry
--
--  Tip/general principle:  Avoid caching registry settings, instead re-fetch them whenever you feel like
--                          using/testing them (without worrying about any performance implications). You 
--                          should be able to modify various settings in regedit.exe, and Alt-Tab back to 
--                          here and see the gui magically update itself.
--
--  Note: FGCOLOR is ineffective on IupToggle, hence they have been reworked as an IupToggle("") plus a
--        following IupLabel (eg tpert,xpert). When you click on, or tab to, such a toggle the focus is
--        shown as a somewhat orphaned and dotted '|' next to it, which I don't think can be helped.
--        FIXED: the focus marks went away when I put "RIGHTBUTTON=YES" on all the IupToggles. (niw)
--
--DEV/temp:
constant WINDERS = WINDOWS
--constant WINDERS = LINUX

Ihandle --runBtn, flbl, helpBtn, closeBtn, rlfhc, tab1, tab2, box,
        ruser, rmach, cpath, path1, path2, path3, 
        tpert, xpert, 
        tper2, xper2,
        tdefi, xdefi, icon1, 
        terri, xerri, icon2, 
        tedix, xedix, edit1, 
        trun1, xrun1, 
        trunw, xrunw, 
        actdd, bOK, tab2
--      lpath, radio, lpad1, 
--      lpert, lper2, ldefi, lerri, 
--      ledix, lrun1, lrunw, lpad3, lpad4, lpad5,
--      lpad2, bHelp

constant htxt = 
        "Note: These settings are all assumed to be ineffective on old and unsupported versions of Windows, prior to XP (which "&
        "was, after all, first released on the 24th of August way back in 2001).\n\n"&

        `Items in error are coloured red (and start with "error"), those that need applying are amber, and current settings `&
        "green. Note that unticking a box may leave items green, if current settings match those in undo.reg (see below). "&
        "On your first visit, all recommended settings should be pre-selected, so after a quick scan for anything red, you can "&
        "just click on the OK button (disabled when there is nothing to do) and exit. Appropriate care has been taken to ensure "&
        "this program can restore things to their original state, however for complete peace of mind you might want to make a "&
        "backup of the windows registry before proceeding.\n\n"&

        "The path only needs to be set to allow Phix to be run from any command prompt. The path is not needed by Edita, and "&
        "double-clicking on a Phix source is taken care of by the (Run) file associations below. As detailed next, there are "&
        "potential reboot/login issues with modifying the path, and it may also adversely affect other applications on your "&
        "system, unlike the file associations (Run/Edit) which are technically speaking much safer, and stand a much better "&
        "chance of taking effect instantly, without any restart of any kind.\n\n"&

        "Changes to the path will not affect any already-open consoles. I trust the choice of HKCU or HKLM is self explanatory "&
        `- if not, open the Control Panel, search for "path", and select/click on "Edit the System Environment Variables" `& 
        `and then the "Environment Variables" button, and you should get the same User/System choice for setting "Path" `&
        `(any "User" settings are appended to "System").`&"\n\n"&

        `The text "Phix" may not (by my choice here) occur in both HKCU and HKLM, hence options may be disabled to prevent that. `&
        "It may need the user to re-login (if HKCU chosen) or the computer restarting (if HKLM chosen) before the path settings "&
        "take full effect, hopefully not. A proper broadcast is sent, so all compliant running applications should be fine (and "&
        "that broadcast definitely helps, particularly with opening new consoles).  Note that the path checkbox (on the third line) "&
        "is deliberately left unchecked by default, and I would recommend you leave it so unless/until you start to miss it "&
        `(without overly implying that setting it is in any way "bad", just that it is sometimes potentially troublesome). `&
        "You can of course manually set or vet any path changes via Control Panel, should this program fail in any way.\n\n"&

        `Perceived Type ("text") is fairly harmless (unless it mullers something else) and simply ensures that Windows Explorer `&
        "can display a sensible preview. Of course, .bat, .css, .inc, and .js are not really anything to do with Phix, nor is .asm "&
        "(though Phix does create .asm listing files), however said preview is quite useful for me, for example when updating help "&
        "and generating new releases, or testing on a freshly created virtual machine, so while I'm here...\n\n"&

        "Likewise the DefaultIcon for source and error files really only affects Explorer (and therefore the standard file "&
        "open dialogue). Note that icons for executable files are stored in the files themselves, rather than set here.\n\n"&

        "Edit with Edita and Run with Phix are assumed to be self-explanatory. The locations of Phix and Edita are initially "&
        `deduced from the command line used to run pgui. Normally Type/Icon/Edit show the full set of ".e,.err,.ex,.exw", `&
        "unless only some of them need applying or in the case of undo, the first value that will be restored, see next.\n\n"&

        "The action drop-down allows detailed step-by-step control of the program (not normally required):\n"&
        "* create undo.reg  -- allows you to deliberately overwrite an existing file to make a fresh restore point.\n"&
        "* edit undo.reg    -- using Edita, or if that this not available, Notepad.\n"&
        "* reload undo.reg  -- ensure (hidden) copies of various values are brought back up to date.\n"&
        "* merge undo.reg   -- restore the registry to the original settings/last restore point/as just edited.\n"&
        "* create setup.reg -- allows you to vet and/or edit the file, and manually apply it (r/click merge).\n"&
        "* edit setup.reg   -- using Edita, or if that this not available, Notepad.\n"&
        "* merge setup.reg  -- applies a manually modified file.\n"&
        "* apply (default)  -- creates an undo.reg if one does not already exist, and a setup.reg, and merges it.\n\n"&

        "Generally the last (default) action is all that is required, unless something does not seem to work properly. "&
        "Clicking on OK for merge/apply usually triggers several further system-level confirmation prompts.\n\n"&
        
        "After selecting an option from the drop-down, OK must be clicked to perform it. Note that the OK button is "&
        "normally enabled/disabled depending on whether there is anything to do (something above is being shown in "&
        "amber), but changing the action drop-down enables it. This program holds (hidden) copies of values from the "&
        "undo.reg file (which may have been present from a previous run), so if you modify it externally you may "&
        "want to reload it to ensure the display is fully up to date. In contrast, there is no way to show any of "&
        "the contents of an externally modified setup.reg within this screen, rather it shows the values it would "&
        "put into setup.reg if you performed the default apply action (or obviously, create setup). The display should "&
        "automatically update with any external modifications to these settings, on Alt-Tabbing back to it.\n\n"&
        
        `Both undo.reg and setup.reg are created in Phix\demo\pGUI\pdemo\. For more information about .reg files, `&
        "see (eg) http://support.microsoft.com/kb/310516 or http://en.wikipedia.org/wiki/Windows_Registry\n\n"&

        "Warning: merging .reg files created on a completely different machine is fraught with danger, for example Phix "&
        `might be installed in C:\Program Files\Phix or C:\Program Files (x86)\Phix or somewhere else entirely. `&
        "There may be cases where it is perfectly sensible, but do such at your own risk."

                
global procedure Help()
--  void = messageBox("Registry Settings",htxt,MB_OK)
    IupMessage("Registry Settings",htxt)
end procedure

function help_cb(Ihandle /*helpBtn*/)
    Help()
    return IUP_DEFAULT
end function
constant cb_help = Icallback("help_cb")


--enum A_CREATEUNDO, A_EDITUNDO, A_RELOADUNDO, A_MERGEUNDO, A_CREATESETUP, A_EDITSETUP, A_MERGESETUP, A_APPLY
constant A_CREATEUNDO=1,
         A_EDITUNDO=2,
         A_RELOADUNDO=3,
         A_MERGEUNDO=4,
         A_CREATESETUP=5,
         A_EDITSETUP=6,
         A_MERGESETUP=7,
         A_APPLY=8
--DEV already in pdemo.exw?? (now in create_tab2())
constant actset = {"create undo.reg",
                   "edit undo.reg",
                   "reload undo.reg",
                   "merge undo.reg",
                   "create setup.reg",
                   "edit setup.reg",
                   "merge setup.reg",
                   "apply (default)"}

constant HKCR = `HKEY_CLASSES_ROOT\`,
         HKLM = `HKEY_LOCAL_MACHINE\`,
         HKCU = `HKEY_CURRENT_USER\`,
         PHKLM = `SYSTEM\CurrentControlSet\Control\Session Manager\Environment`,    -- Path in HKLM
         PHKCU = "Environment",                                                     -- Path in HKCU
         PerceivedType = "PerceivedType",
         PerceivedTypeEqText = `"PerceivedType"="text"`,
         DefaultIcon = "DefaultIcon",

         -- NB: "ew" is a "slave" to "e", not separately settable.
         --     See also "desired" in setButtonStates() before/when modifying.
         --     And, obviously, keep EXTS/amap/ewmap/ksmap in step (amap just
        --      converts to knownSubkeys, ksmap back, and ewmap "ew" to "e").
         EXTS = {"e","err","ex","exw","asm","bat","css","inc","js","ew"},
         amap = { 3,  1,    2,   4,    0,    0,    0,    0,    0,   3},
         ewmap = {1,  2,    3,   4,    5,    6,    7,    8,    9,   1},
         kErr = 1 -- aka amap[find("err",EXTS)]==idx for knownSubkeys

sequence exti   -- {PT,ICON,EDIT,RUN[,KEY]}, for each EXTS[i], from undo.reg
                -- (KEY (==EXTS[i]) is [sometimes] present for debugging only)
                -- Note that [PT] is a 0|1 flag, whereas the rest are 0|value.
constant PT = 1,    -- (Percieved Type)
         ICON = 2,  -- (Default Icon)
         EDIT = 3,  -- (Edit with)
         RUN = 4    -- (Run with)
--       KEY = 5    -- (for debugging only)

-- (in the order we want them in the .reg files)
constant knownSubkeys = {"PhixErrorFile",       -- (err)
                         "PhixConsoleSource",   -- (ex)
                         "PhixIncludeFile",     -- (e and ew)
                         "PhixSource"}          -- (exw)
constant ksmap = {2,3,1,4} -- map knownSubkeys to EXTS/desired[1..4]
constant knownDescs = {"Phix Error File",
                       "Phix Console Program Source",
                       "Phix Include File",
                       "Phix Program Source"}

sequence desired
--  desired = {{1,Icon,EditWithEdita},          -- e/ew
--             {1,ErrorIcon,EditWithEdita},     -- err
--             {1,Icon,EditWithEdita,RunEx},    -- ex
--             {1,Icon,EditWithEdita,RunExw},   -- exw

-- saves from undo.reg, for showing "restore to xxx" when a box is unchecked:
--enum UHKLMPATH, UHKCUPATH
constant UHKLMPATH=1, UHKCUPATH=2
sequence undos
         undos = {0,    -- UHKLMPATH
                  0}    -- UHKCUPATH

constant
    CP_UTF8 = 65001,
    HWND_BROADCAST = #0000FFFF,
    HKEY_CLASSES_ROOT = #80000000,
    HKEY_CURRENT_USER = #80000001,
    HKEY_LOCAL_MACHINE = #80000002,
    KEY_READ = #20019,
    ERROR_FILE_NOT_FOUND = 2,
    ERROR_ACCESS_DENIED = 5,
    ERROR_INVALID_PARAMETER = 87,
    ERROR_MORE_DATA = 234,
    REG_SZ = 1,
    REG_EXPAND_SZ = 2,
--  RRF_RT_REG_SZ = #00000002,
--  RRF_RT_REG_EXPAND_SZ = #00000004,
--  RRF_NOEXPAND = #10000000,
    WM_SETTINGCHANGE = 26

atom advapi32,
     RegOpenKeyExA,
--   RegGetValueA,
     RegQueryValueExA,
     RegCloseKey,
     kernel32,  
     xMultiByteToWideChar,
     user32,
     xSendMessage,
     phkResult,
     lpType,
     lpcbData

--
-- The following items are set by setButtonStates(), used by Undo(), apply_action(), and CreateDotReg():
--
string basedir      -- eg C:\Program Files (x86)\Phix   (PATHREPLACE)
string restdir      -- "", but from undo.reg            (PATHRESTORE)
string Edita, EditWithEdita

integer pathmode    -- one of the following constants:
constant PATHADD = 1,       -- append  \ HKLM / depending on
         PATHREPLACE = 2,   -- replace  } or {     rmach
         PATHRESTORE = 3,   -- restore  }    {      or 
         PATHREMOVE = 4     -- remove  / HKCU \    ruser

--/*
DEV get rid of all these and dynamically locate them... NAH, IupSetInt(id,"FGCOLOR",c)
constant kPath1 = find(lPath1,colourids),
         kPath2 = find(lPath2,colourids),
         kPath3 = find(lPath3,colourids),
--       kType1 = find(lType1,colourids),
         kType1 = find(tpert,colourids),
--       kType2 = find(lType2,colourids),
         kType2 = find(tper2,colourids),
--       kIcon  = find(lIcon, colourids),
         kIcon  = find(tdefi, colourids),
--       kEIcon = find(lEIcon,colourids),
         kEIcon = find(terri,colourids),
         kEdit  = find(lEdit, colourids),
         kEdit1 = find(edit1, colourids),
         kRun   = find(run1,  colourids),
         kRunW  = find(run2,  colourids)
--*/

integer applyrqd
        applyrqd = 0

procedure erm(object title, string msg)
    if atom(title) then
        if title=ERROR_ACCESS_DENIED then
            title = "Access Denied"
        elsif title=ERROR_INVALID_PARAMETER then
            title = "Invalid Parameter"
--      elsif title=?? then -- (add any others rqd)
        else
            title = sprintf("Error code %d",title)
        end if
    end if
--  void = messageBox(title,msg,MB_OK)
    IupMessage(title,msg)
end procedure

--DEV why no warning?
--function ZKeyValue(atom key_id, string SubKey, object Value, integer RRF_TYPE)
--object data = 0
--integer res
--integer data_len
--atom lpData
--
--  -- first just get size
--  res = c_func(RegGetValueA,{key_id,SubKey,Value,RRF_TYPE,NULL,NULL,lpcbData})
--  if res=0 then
--      -- then get actual data
--      data_len = peek4u(lpcbData)
--      lpData = allocate(data_len)
--      res = c_func(RegGetValueA,{key_id,SubKey,Value,RRF_TYPE,NULL,lpData,lpcbData})
--      if res!=0 then ?9/0 end if
--      -- (not really sure why RegGetValueA says we need 6 bytes for "text\0",
--      --  but it does, however, it is easy enough to skip any extra nulls.)
--      while 1 do
--          data_len -= 1
--          if peek(lpData+data_len-1)!=0 then exit end if
--      end while
--      data = peek({lpData,data_len})
--      free(lpData)
--  elsif res!=ERROR_FILE_NOT_FOUND then
--      erm(res,"KeyValue")
--  end if
--  return data
--end function

function KeyValue2(string key, atom key_id, string SubKey, object Value)--, integer RRF_TYPE)
integer res
integer data_len
atom lpData
--atom lpSubKey = allocate_StringZ(SubKey)
object data
--object data2 --DEV
    if platform()!=WINDERS then ?9/0 end if
    data = 0
    -- first just get size
--  res = c_func(RegGetValueA,{key_id,SubKey,Value,RRF_TYPE,NULL,NULL,lpcbData})
--  if string(Value) then
--      Value = allocate_StringZ(Value)
--  end if
--if RegGetValueA!=-1 then
--  res = c_func(RegGetValueA,{key_id,SubKey,Value,RRF_TYPE,NULL,NULL,lpcbData})
--  if res=0 then
--      -- then get actual data
--      data_len = peek4u(lpcbData)
----if 0 then -- replaced 5/8/15
----        lpData = allocate(data_len)
------      res = c_func(RegGetValueA,{key_id,SubKey,Value,RRF_TYPE,NULL,lpData,lpcbData})
----        res = c_func(RegGetValueA,{key_id,lpSubKey,Value,RRF_TYPE,NULL,lpData,lpcbData})
----else
--      while 1 do
--          lpData = allocate(data_len)
--          res = c_func(RegGetValueA,{key_id,SubKey,Value,RRF_TYPE,NULL,lpData,lpcbData})
--          if res!=ERROR_MORE_DATA then exit end if
--          free(lpData)
--          data_len += 100
--          poke4(lpcbData,data_len)
--      end while
----end if
--      if res!=0 then ?9/0 end if
--      data_len = peek4u(lpcbData)
----    key = `HKEY_CURRENT_USER\`
----    key_id = #80000001
----    SubKey = "Environment" 
----    Value = 39807340 
----    RRF_TYPE = 2 
----    res = 234
----    data_len = 36
----    lpData = 34655248 
----    data = 0 
--      -- (not really sure why RegGetValueA says we need 6 bytes for "text\0",
--      --  but it does, however, it is easy enough to skip any extra nulls.)
--      while 1 do
--          data_len -= 1
--          if peek(lpData+data_len-1)!=0 then exit end if
--      end while
--      data = peek({lpData,data_len})
--      free(lpData)
--  elsif res!=ERROR_FILE_NOT_FOUND then
--      erm(res,key&SubKey)
--  end if
--end if
--/!*
--from edita\pFreg.ew:
--global function regIconInfo(string subkey)
--
-- Get default icon info from registry.
-- Called once with eg ".bat", to return "batfile", then with (eg)
--  `batfile\DefaultIcon` to return `C:\Windows\System\shell32.dll,-153`.
--
--atom key_id
--object data2
--integer DataLen
--atom lpData

--  data2 = 0
    res = c_func(RegOpenKeyExA,{key_id,SubKey,0,KEY_READ,phkResult})
    if res=0 then
        atom key_id2 = peek4u(phkResult)
        -- first just get size of buffer required:
        if c_func(RegQueryValueExA,{key_id2,Value,0,lpType,0,lpcbData})=0
        and find(peek4u(lpType),{REG_SZ,REG_EXPAND_SZ}) then
            data_len = peek4u(lpcbData)
if data_len<=0 then ?9/0 end if
            lpData = allocate(data_len)
            -- then get actual data:
            while 1 do
                lpData = allocate(data_len)
                res = c_func(RegQueryValueExA,{key_id2,Value,0,lpType,lpData,lpcbData})
                if res!=ERROR_MORE_DATA then exit end if
                free(lpData)
                data_len += 100
                poke4(lpcbData,data_len)
            end while
            if res=0 then
                data_len = peek4u(lpcbData)
--              while 1 do
                while data_len>0 do
                    data_len -= 1
                    if peek(lpData+data_len-1)!=0 then exit end if
                end while
--              data = peek({lpData,data_len})
                if data_len<=0 then
                    data  = ""
                else
                    data = peek({lpData,data_len})
                end if
            end if
            free(lpData)
        end if
        {} = c_func(RegCloseKey,{key_id2})
    elsif res!=ERROR_FILE_NOT_FOUND then
        erm(res,key&SubKey)
    end if
--if data!=data2 then
--  ?{data=data2,data,data2}
--  ?{key, key_id, SubKey, Value, RRF_TYPE}
----/*
----*/
--end if
--  return data2    -- -1 on failure
--end function
--*!/
    return data
end function

function splitpath(string path)
-- not to be confused with split_path()!
sequence parts, phixes
string part
integer k
    parts = {}
    phixes = {}
    while 1 do
        k = find(';',path)
        if k=0 then
            if length(path) then
                parts = append(parts,path)
                if match("Phix",path) then
                    phixes = append(phixes,length(parts))
                end if
            end if
            exit
        end if
        part = path[1..k-1]
        path = path[k+1..length(path)]
        parts = append(parts,part)
        if match("Phix",part) then
            phixes = append(phixes,length(parts))
        end if
    end while
    return {parts,phixes}
end function

--DEV/tryme is this not join(parts,";")?
function joinpath(sequence parts)
-- not to be confused with join_path()!
string res
    res = ""
    if length(parts) then
        res = parts[1]
        for i=2 to length(parts) do
            res &= ';'&parts[i]
        end for
    end if
    return res
end function

function appendexts(string exts, string ext)
-- for building strings such as ".e,.ex,.exw", one entry at a time
    if length(exts) then exts &= ',' end if
    exts &= '.'&ext
    return exts
end function

constant
    Black           = "0 0 0",
--  Blue            = "0 0 128",
    Green           = "0 128 0",
--  Cyan            = "0 128 128",
--  Red             = "128 0 0",
--  Orange          = "128 64 0",
    Amber           = "255 160 0",
--  Magenta         = "128 0 128",
--  DarkBrown       = "64 64 0",
--  Brown           = "128 128 0",
--  DarkGray        = "64 64 64",
--  Gray            = "128 128 128",
--  LightGray       = "192 192 192",
--  BrightBlue      = "0 0 255",
--  BrightGreen     = "0 255 0",
--  BrightCyan      = "0 255 255",
    BrightRed       = "255 0 0",
--  Pink            = "255 176 176",
--  BrightMagenta   = "255 0 255",
--  Purple          = "208 128 208",
--  Yellow          = "255 255 0",
--  White           = "224 224 224",
--  Parchment       = "255 255 224",
--  BrightWhite     = "255 255 255",
    $

--procedure setOptions(sequence eset, integer checked, integer idx, sequence actual, integer id, integer kid, integer vid)
--procedure setOptions(sequence eset, integer checked, integer idx, sequence actual, Ihandle id, integer kid, Ihandln vid)
procedure setOptions(sequence eset, integer idx, sequence actual, Ihandle id, Ihandln xid, Ihandln vid)
-- eset is a set of extensions, eg {"e","ex","exw"}.
-- idx is one of PT/ICON/EDIT (for RUN see setRun())
-- id is a checkbox.
-- xid is the text which is logically part of id, but a separate label is used so we can colour it.
-- vid is an associated label, under the checkbox.
integer checked
--, kid
string ambers, greens
object what, firstgwhat, firstawhat
string ei
integer k
string c
--  ({"e","err","ex","exw"},IupGetAttribute(tpert,"VALUE"),?,actual,tpert,kType1,?)
    if not find(id, {tpert,tper2,tdefi,terri,tedix}) then ?9/0 end if   -- IupToggles
    if not find(xid,{xpert,xper2,xdefi,xerri,xedix}) then ?9/0 end if   -- IupLabels
    if not find(vid,{    0,    0,icon1,icon2,edit1}) then ?9/0 end if   -- IupLabels
--  checked = isChecked(id)
    checked = IupGetInt(id,"VALUE")
-->??   kid = find(id,colourids)
    ambers = ""
    greens = ""
    what = repeat(0,length(eset))
    for i=1 to length(what) do
        ei = eset[i]
        k = find(ei,EXTS)
        if checked then
            what = desired[k][idx]
        else
            what = exti[k][idx]
            desired[k][idx] = what
        end if
--      if actual[k][idx]=what then
        if equal(actual[k][idx],what) then
--          if length(greens)=0 or what=firstgwhat then
            if length(greens)=0 or equal(what,firstgwhat) then
                greens = appendexts(greens,ei)
                firstgwhat = what
            end if
        else
--          if length(ambers)=0 or what=firstawhat then
            if length(ambers)=0 or equal(what,firstawhat) then
                ambers = appendexts(ambers,ei)
                firstawhat = what
            end if
        end if
    end for
    if length(ambers) then
--      setText(id,ambers)
        if xid!=NULL then
            IupSetStrAttribute(xid,"TITLE",ambers)
        end if
        c = Amber
        applyrqd = 1
        what = firstawhat   -- (for vid, iff!=0)
--?     ewhat[idx] = what   -- for Apply (and what is wrong with desired? now done above) [DEV]
    else
        if length(greens)=0 then ?9/0 end if -- (sanity check)
-->     setText(id,greens)
        if xid!=NULL then
            IupSetStrAttribute(xid,"TITLE",greens)
        end if
        c = Green
        what = firstgwhat   -- (for vid, iff!=0)
    end if
--  colours[kid] = c
-- has no effect:
--  IupSetAttribute(id,"FGCOLOR",c)
    if xid!=NULL then
        IupSetAttribute(xid,"FGCOLOR",c)
    end if
--> repaintWindow(id,False)
--  IupUpdate(id)
    if vid!=0 then -- set associated label
--DEV?? (14/10/16)
        if idx=PT then ?9/0 end if -- (sanity check/[PT] is [0|1], not useable text)
-->     setText(vid,what)
        IupSetStrAttribute(vid,"TITLE",what)
--      colours[find(vid,colourids)] = c
        IupSetAttribute(vid,"FGCOLOR",c)
-->     repaintWindow(vid,False)
--      IupUpdate(vid)
    end if
--end if
    IupSetAttribute(tab2,"SIZE",NULL)
    IupRefresh(tab2)
end procedure

--procedure setRun(string ext, integer checked, sequence actual, integer id, integer kid)
procedure setRun(string ext, sequence actual, Ihandle id, Ihandle xid)
integer k
--string runw
nullable_string runw
string c
    if platform()!=WINDERS then ?9/0 end if
    if not find(id,{trun1,trunw}) then ?9/0 end if      -- IupToggles
    if not find(xid,{xrun1,xrunw}) then ?9/0 end if     -- IupLabels
    k = find(ext,EXTS)
    integer checked = IupGetInt(id,"VALUE")
    if checked then
        runw = desired[k][RUN]
    else
        runw = exti[k][RUN]
        desired[k][RUN] = runw
    end if
--> setText(id,runw)
    IupSetStrAttribute(xid,"TITLE",runw)
    if actual[k][RUN]=runw then
        c = Green
    else
        c = Amber
        applyrqd = 1
    end if
--  colours[kid] = c
    IupSetAttribute(xid,"FGCOLOR",c)
--> repaintWindow(id,False)
--  IupUpdate(id)
    IupSetAttribute(tab2,"SIZE",NULL)
    IupRefresh(tab2)
end procedure

procedure setError(string msg)
--?"setError"
--?msg
--> setText(lPath1,"")
    IupSetAttribute(path1,"TITLE","")
--> setText(lPath2,msg)
    IupSetStrAttribute(path2,"TITLE",msg)
--> setText(lPath3,"")
    IupSetAttribute(path3,"TITLE","")
    applyrqd = 0
--  colours[kPath1] = Black
--  colours[kPath2] = BrightRed
--  colours[kPath3] = Black
    IupSetAttribute(path1,"FGCOLOR",Black)
    IupSetAttribute(path2,"FGCOLOR",BrightRed)
    IupSetAttribute(path3,"FGCOLOR",Black)
--> repaintWindow({lPath1,lPath2,lPath3},False)
--  IupSetAttribute(path1,"SIZE",NULL)
--  IupSetAttribute(path2,"SIZE",NULL)
--  IupSetAttribute(path3,"SIZE",NULL)
    IupSetAttribute(tab2,"SIZE",NULL)
--  IupUpdate({path1,path2,path3})
    IupRefresh(tab2)
end procedure

integer firsttime = 1

procedure setButtonStates()
--
-- Invoked whenever a button is clicked or the psettings tab gets focus (including Alt-Tab)
-- NB: that means often, no messageBoxes or similar can arise from invoking this routine!
--
string subkey, verb
object subname
atom key_id
sequence subkeys
sequence subkeyidx
sequence actual
integer res
integer k
--!/**/sequence cl
object d
--string Icon, ErrorIcon, RunEx, RunExw, Edita, EditWithEdita
string Icon, ErrorIcon, RunEx, RunExw
object HKLMPath, HKCUPath
sequence parts,phixes
sequence uparts,uphixes
string c
sequence lPaths
--integer firsttime
integer pt, ptO
--, di
--sequence desiredi
--integer wasFocus
Ihandln wasFocus

    if platform()!=WINDERS then ?9/0 end if
    -- first, locate p[w].exe, Psrc.ico, and edita.ex(w|e):
--/*
-- note: this relies on Phix/command_line() returning full paths, which RDS Eu/OpenEuphoria do not...
--/**/  cl = command_line()
--/**/  cl = cl[2]
--/**/  for i=length(cl) to 1 by -1 do
--/**/      if cl[i]='\\' then
--/**/          basedir = cl[1..i]
--/**/          exit
--/**/      end if
--/**/  end for
--/**/  if match("Phix",basedir)=0 then setError(`error: "Phix" does not occur in `&basedir) return end if
--/*
    basedir = `C:\Program Files (x86)\Phix\`
--*/
--*/
--DEV replace throughout:
    basedir = croot
--?"SetButtonStates"
--?basedir
--  Icon = basedir&"Psrc.ico"
    Icon = basedir&"ptick.ico"
    d = dir(Icon)
    if atom(d) or length(d)!=1 then setError("error: "&Icon&" not found.") return end if
    Icon = `"`&Icon&`",0`
--  ErrorIcon = `C:\Windows\system32\shell32.dll`
    ErrorIcon = basedir&"pcross.ico"
    d = dir(ErrorIcon)
    if atom(d) or length(d)!=1 then setError("error: "&ErrorIcon&" not found.") return end if
--  ErrorIcon &= ",78"
--  ErrorIcon &= ",65"
--  ErrorIcon &= ",271"
    ErrorIcon = `"`&ErrorIcon&`",0`
    RunEx = basedir&"p.exe"
    d = dir(RunEx)
    if atom(d) or length(d)!=1 then setError("error: "&RunEx&" not found.") return end if
    RunEx = `"`&RunEx&`\ "%1"`
    RunExw = basedir&"pw.exe"
    d = dir(RunExw)
    if atom(d) or length(d)!=1 then setError("error: "&RunExw&" not found.") return end if
    EditWithEdita = RunExw
    RunExw = `"`&RunExw&`" "%1"`
    if length(basedir)<6 then setError("error: length("&basedir&")<6") return end if
    if basedir[-6..-1]!=`\Phix\` then setError("error: "&basedir&` does not end with "Phix".`) return end if
--  if not equal(basedir[length(basedir)-5..length(basedir)],`\Phix\`) then setError("error: "&basedir&` does not end with "Phix".`) return end if
--  Edita = basedir[1..-6]&`Edita\edita.exw`
--  Edita = basedir[1..length(basedir)-5]&`Edita\edita.exw` -- replaced 11/8/15
    Edita = basedir&`demo\edita\edita.exw`
    d = dir(Edita)
    if atom(d) or length(d)!=1 then
        Edita[length(Edita)] = 'e'
        d = dir(Edita)
--DEV bit draconian innit? (can we set EditWithEdita to ""?)
--      if atom(d) or length(d)!=1 then Edita[$] = 'w' setError("error: "&Edita&" not found.") return end if
        if atom(d) or length(d)!=1 then
            EditWithEdita = ""
        else
            EditWithEdita = `"`&Edita&`" "%1"`
        end if
    else
        EditWithEdita = `"`&EditWithEdita&`" "`&Edita&`" "%1"`
    end if

    HKLMPath = KeyValue2(HKLM,HKEY_LOCAL_MACHINE,PHKLM,"Path")--,RRF_RT_REG_EXPAND_SZ+RRF_NOEXPAND)
--?HKLMPath
    pathmode = 0
    lPaths = repeat("",3)
--> firsttime = length(getText(cbPath))!=0
--> setText(cbPath,"")
    applyrqd = 0
    if not string(HKLMPath) then
        lPaths[1] = "error reading "&HKLM&PHKLM&`\Path`
        c = BrightRed
    else
        HKCUPath = KeyValue2(HKCU,HKEY_CURRENT_USER,PHKCU,"Path")--,RRF_RT_REG_SZ)
        if not string(HKCUPath) then HKCUPath="" end if
        if match("Phix",HKLMPath)=0 then
            if match("Phix",HKCUPath)=0 then
                -- (This is the only way the user gets a choice)
-->             setEnable({rbMachine,rbUser},True)
                IupSetInt({rmach,ruser},"ACTIVE",True)
-->             if not isChecked(rbMachine) then
                if not IupGetInt(rmach,"VALUE") then
-->                 setCheck(rbUser,True)
                    IupSetInt(ruser,"VALUE",True)
                end if
                lPaths[1] = "add "&basedir
-->             if isChecked(cbPath) then
                if IupGetInt(cpath,"VALUE") then
                    c = Amber   -- amber
                    pathmode = PATHADD
                else
                    c = Black
                end if
            else
-->             setEnable(rbMachine,False)
                IupSetInt(rmach,"ACTIVE",False)
-->             setCheck(rbMachine,False)
                IupSetInt(rmach,"VALUE",False)
-->             setEnable(rbUser,True)
                IupSetInt(ruser,"ACTIVE",True)
-->             setCheck(rbUser,True)
                IupSetInt(ruser,"VALUE",True)
--/**/          {parts,phixes} = splitpath(HKCUPath)
--/*
                phixes = splitpath(HKCUPath)
                parts = phixes[1]
                phixes = phixes[2]
--*/
                if length(phixes)>1 then
                    lPaths[1] = `error: "Phix" already occurs more than once in HKCU:`
                    lPaths[2] = parts[phixes[1]]
                    lPaths[3] = parts[phixes[2]]
-->                 setEnable(cbPath,False)
                    IupSetInt(cpath,"ACTIVE",False)
                    c = BrightRed
                elsif parts[phixes[1]]=basedir then
                    if firsttime then
-->                     setCheck(cbPath,True)
                        IupSetInt(cpath,"VALUE",True)
                    end if
-->                 if isChecked(cbPath) then
                    if IupGetInt(cpath,"VALUE") then
                        lPaths[1] = "HKCU already contains "&basedir
                        c = Green
                    else
                        c = Black
                        if undos[UHKCUPATH]=0 then ?9/0 end if  --DEV tryme
--/**/                  {uparts,uphixes} = splitpath(undos[UHKCUPATH])
--/*
                        uphixes = splitpath(undos[UHKCUPATH])
                        uparts = uphixes[1]
                        uphixes = uphixes[2]
--*/
                        if length(uphixes)=0 then
                            if length(uparts)=length(parts)-1
                            and phixes[1]=length(parts)
--                          and uparts=parts[1..-2] then
                            and equal(uparts,parts[1..length(parts)-1]) then
                                lPaths[1] = "remove "&basedir
                                c = Amber
                                pathmode = PATHREMOVE
                            end if
--                      elsif uphixes=phixes then
                        elsif equal(uphixes,phixes) then
                            restdir = uparts[uphixes[1]]
                            parts[phixes[1]] = restdir
                            if parts=uparts then
                                lPaths[1] = "restore "&basedir
                                lPaths[2] = "back to "&restdir
                                c = Amber
                                pathmode = PATHRESTORE
                            end if
                        end if
                    end if
                else
                    lPaths[1] = "replace "&parts[phixes[1]]
                    lPaths[2] = "with "&basedir
                    if firsttime then
-->                     setCheck(cbPath,True)
                        IupSetInt(cpath,"VALUE",True)
                    end if
-->                 if isChecked(cbPath) then
                    if IupGetInt(cpath,"VALUE") then
                        c = Amber   -- amber
                        pathmode = PATHREPLACE
                    else
                        c = Black
                    end if
                end if
            end if
        else -- match("Phix",HKLMPath)!=0:
            {parts,phixes} = splitpath(HKLMPath)
            if match("Phix",HKCUPath)!=0 then
-->             setEnable({rbMachine,rbUser},False)
                IupSetInt({rmach,ruser},"ACTIVE",False)
                lPaths[1] = `error: "Phix" already occurs more than once in PATH:`
                lPaths[2] = "HKLM "&parts[phixes[1]]
                {parts,phixes} = splitpath(HKCUPath)
                lPaths[3] = "HKCU "&parts[phixes[1]]
                c = BrightRed
            else
-->             setEnable(rbMachine,True)
                IupSetInt(rmach,"ACTIVE",True)
-->             setCheck(rbMachine,True)
                IupSetInt(rmach,"VALUE",True)
-->             setEnable(rbUser,False)
                IupSetInt(ruser,"ACTIVE",False)
-->             setCheck(rbUser,False)
                IupSetInt(ruser,"VALUE",False)
                if length(phixes)>1 then
                    lPaths[1] = `error: "Phix" already occurs more than once in HKLM:`
                    lPaths[2] = parts[phixes[1]]
                    lPaths[3] = parts[phixes[2]]
                    c = BrightRed
                elsif parts[phixes[1]]=basedir then
                    if firsttime then
-->                     setCheck(cbPath,True)
                        IupSetInt(cpath,"VALUE",True)
                    end if
-->                 if isChecked(cbPath) then
                    if IupGetInt(cpath,"VALUE") then
                        lPaths[1] = "HKLM already contains "&basedir
                        c = Green
                    else
                        c = Black
                        if undos[UHKLMPATH]=0 then ?9/0 end if
                        {uparts,uphixes} = splitpath(undos[UHKLMPATH])
                        if length(uphixes)=0 then
                            if length(uparts)=length(parts)-1
                            and phixes[1]=length(parts)
                            and uparts=parts[1..-2] then
                                lPaths[1] = "remove "&basedir
                                c = Amber
                                pathmode = PATHREMOVE
                            end if
                        elsif uphixes=phixes then
                            restdir = uparts[uphixes[1]]
                            parts[phixes[1]] = restdir
                            if parts=uparts then
                                lPaths[1] = "restore "&basedir
                                lPaths[2] = "back to "&restdir
                                c = Amber
                                pathmode = PATHRESTORE
                            end if
                        end if
                    end if
                else
                    lPaths[1] = "replace "&parts[phixes[1]]
                    lPaths[2] = "with "&basedir
                    if firsttime then
-->                     setCheck(cbPath,True)
                        IupSetInt(cpath,"VALUE",True)
                    end if
-->                 if isChecked(cbPath) then
                    if IupGetInt(cpath,"VALUE") then
                        c = Amber   -- amber
                        pathmode = PATHREPLACE
                    else
                        c = Black
                    end if
                end if
            end if
        end if
    end if
--> setText(lPath1,lPaths[1])
    IupSetStrAttribute(path1,"TITLE",lPaths[1])
--> setText(lPath2,lPaths[2])
    IupSetStrAttribute(path2,"TITLE",lPaths[2])
--> setText(lPath3,lPaths[3])
    IupSetStrAttribute(path3,"TITLE",lPaths[3])
    if c=Amber
    or pathmode!=0 then
        if c!=Amber then ?9/0 end if
        if pathmode=0 then ?9/0 end if
        applyrqd = 1
    end if
--  colours[kPath1] = c
--  colours[kPath2] = c
--  colours[kPath3] = c
    IupSetAttribute(path1,"FGCOLOR",c)
    IupSetAttribute(path2,"FGCOLOR",c)
    IupSetAttribute(path3,"FGCOLOR",c)
--> repaintWindow({lPath1,lPath2,lPath3},False)
--?lPaths
--  IupUpdate({path1,path2,path3})
    IupSetAttribute(tab2,"SIZE",NULL)
    IupRefresh(tab2)
--trace(1)
    actual = repeat({0,0,0,0,0},length(EXTS))
    subkeys = {}
    subkeyidx = repeat(0,length(EXTS))
    for i=1 to length(EXTS) do
        actual[i][5] = EXTS[i] -- (debug aid, otherwise not used)
        subkey = "."&EXTS[i]
        subname = KeyValue2(HKCR,HKEY_CLASSES_ROOT,subkey, NULL)--, RRF_RT_REG_SZ)
        if string(subname) then -- and find(subname,knownTypes)?
            k = find(subname,subkeys)
            if k=0 then
                subkeys = append(subkeys,subname)
                k = length(subkeys)
            end if
            subkeyidx[i] = k
        end if
        subname = KeyValue2(HKCR,HKEY_CLASSES_ROOT, subkey, PerceivedType)--, RRF_RT_REG_SZ)
        if subname="text" then
            actual[i][PT] = 1
        end if
    end for

    for i=1 to length(subkeys) do
        subkey = subkeys[i]
        res = c_func(RegOpenKeyExA,{HKEY_CLASSES_ROOT,subkey,0,KEY_READ,phkResult})
--      res = c_func(RegOpenKeyExA,{HKEY_CLASSES_ROOT,allocate_StringZ(subkey),0,KEY_READ,phkResult})
        if res=0 then
            key_id = peek4u(phkResult)
            subname = KeyValue2(HKCR&subkey,key_id,DefaultIcon,NULL)--,RRF_RT_REG_SZ)
            if string(subname) then
                for j=1 to length(subkeyidx) do
--                  if EXTS[j][1]='e'
                    if amap[j]!=0
                    and subkeyidx[j]=i then
                        actual[j][ICON] = subname
                        exit
                    end if
                end for
            end if
            for dix=EDIT to RUN do  -- (2 iterations)
                if dix=EDIT then
                    if subkey=knownSubkeys[kErr] then   -- ie "PhixErrorFile"
                        verb = "debug"
                    else
                        verb = "edit"
                    end if
                else -- dix=RUN
                    verb = "open"
                end if
                subname = KeyValue2(HKCR&subkey,key_id,`shell\`&verb&`\command`,NULL)--,RRF_RT_REG_SZ)
                if string(subname) then
                    for j=1 to length(subkeyidx) do
--                      if EXTS[j][1]='e'
                        if amap[j]!=0
                        and subkeyidx[j]=i then
                            actual[j][dix] = subname
                            exit
                        end if
                    end for
                end if
            end for
            res = c_func(RegCloseKey,{key_id})
        end if
    end for

    -- NB: implicit correspondence with EXTS (and PT..RUN), and, of course, "actual":
--> pt = isChecked(cbPerceivedType)
    pt = IupGetInt(tpert,"VALUE")
--> ptO = isChecked(cbPTOther)
    ptO = IupGetInt(tper2,"VALUE")
--/* sug:
--  desired = {Icon,ErrorIcon,EditWithEdita,RunEx,RunExw}
--  if not isChecked(cbDefaultIcon) then desired[1] = 0 end if
--  if not isChecked(cbErrorIcon)   then desired[2] = 0 end if
--  if not isChecked(cbEdita)       then desired[3] = 0 end if
--  if not isChecked(cbRun)         then desired[4] = 0 end if
--  if not isChecked(cbRunW)        then desired[5] = 0 end if
--  desired = {{pt,desired[1],desired[3]},              -- e/ew
--             {pt,desired[2],desired[3]},              -- err
--             {pt,desired[1],desired[3],desired[4]},   -- ex
--             {pt,desired[1],desired[3],desired[5]},   -- exw
--             {ptO}, {ptO}, {ptO}, {ptO}, {ptO}}       -- asm/bat/css/inc/js (no sep. ew)
----or (better?)
--  if isChecked(cbDefaultIcon) then dIcon          = Icon          else dIcon          = 0 end if
--  if isChecked(cbErrorIcon)   then dErrorIcon     = ErrorIcon     else dErrorIcon     = 0 end if
--  if isChecked(cbEdita)       then dEditWithEdita = EditWithEdita else dEditWithEdita = 0 end if
--  if isChecked(cbRun)         then dRunEx         = RunEx         else dRunEx         = 0 end if
--  if isChecked(cbRunW)        then dRunExW        = RunExW        else dRunExW        = 0 end if
---- or
--  {dIcon,dErrorIcon,dEditWithEdita,dRunEx,dRunExW} = {Icon,ErrorIcon,EditWithEdita,RunEx,RunExW}
--  if not isChecked(cbDefaultIcon) then dIcon          = 0 end if
--  if not isChecked(cbErrorIcon)   then dErrorIcon     = 0 end if
--  if not isChecked(cbEdita)       then dEditWithEdita = 0 end if
--  if not isChecked(cbRun)         then dRunEx         = 0 end if
--  if not isChecked(cbRunW)        then dRunExW        = 0 end if
--
--  desired = {{pt,dIcon,     dEditWithEdita},          -- e/ew
--             {pt,dErrorIcon,dEditWithEdita},          -- err
--             {pt,dIcon,     dEditWithEdita,dRunEx},   -- ex
--             {pt,dIcon,     dEditWithEdita,dRunExw},  -- exw
--             {ptO}, {ptO}, {ptO}, {ptO}, {ptO}}       -- asm/bat/css/inc/js (no sep. ew)
---- or (best? [if it works, it should, I think...])
--*/
--  if not isChecked(cbDefaultIcon) then Icon           = "" end if
--  if not isChecked(cbErrorIcon)   then ErrorIcon      = "" end if
--  if not isChecked(cbEdita)       then EditWithEdita  = "" end if
--  if not isChecked(cbRun)         then RunEx          = "" end if
--  if not isChecked(cbRunW)        then RunExw         = "" end if
--* /
    desired = {{pt,Icon,EditWithEdita},             -- e/ew
               {pt,ErrorIcon,EditWithEdita},        -- err
               {pt,Icon,EditWithEdita,RunEx},       -- ex
               {pt,Icon,EditWithEdita,RunExw},      -- exw
               {ptO}, {ptO}, {ptO}, {ptO}, {ptO}}   -- asm/bat/css/inc/js (no sep. ew)

    --
    -- And now, the tricky part(!)
    -- Update all the labels/colours to reflect current settings.
    -- we have: actual, from the registry,
    --          exti, from undo.reg, or all 0/1's
    --          desired, needs yet to be cropped (here and now) with unchecked flags [DEV]
    --
--> di = isChecked(cdDefaultIcon)
--> ei = isChecked(cbErrorIcon)
--> setOptions({"e","err","ex","exw"},isChecked(cbPerceivedType),PT,actual,lType1,kType1,0)
--  setOptions({"e","err","ex","exw"},pt,PT,actual,lType1,kType1,0)
    setOptions({"e","err","ex","exw"},PT,actual,tpert,xpert,0)
--  setOptions({"asm","bat","css","inc","js"},isChecked(cbPTOther),PT,actual,lType2,kType2,0)
--  setOptions({"asm","bat","css","inc","js"},ptO,PT,actual,lType2,kType2,0)
    setOptions({"asm","bat","css","inc","js"},PT,actual,tper2,xper2,0)
--  setOptions({"e","ex","exw"},isChecked(cbDefaultIcon),ICON,actual,lIcon,kIcon,icon1)
--  setOptions({"e","ex","exw"},di,ICON,actual,tdefi,kIcon,icon1)
    setOptions({"e","ex","exw"},ICON,actual,tdefi,xdefi,icon1)
--  setOptions({"err"},isChecked(cbErrorIcon),ICON,actual,lEIcon,kEIcon,icon2)
--  setOptions({"err"},ei,ICON,actual,lEIcon,kEIcon,icon2)
    setOptions({"err"},ICON,actual,terri,xerri,icon2)
-- draconian(cont, not tried):
    if length(EditWithEdita)=0 then
-->     setCheck(cbEdita,BST_UNCHECKED)
        IupSetInt(tedix,"VAUE",0)
-->     setEnable(cbEdita,False)
        IupSetInt(tedix,"ACTIVE",False)
-->     setText(edit1,"error: "&Edita&" not found")
        IupSetStrAttribute(edit1,"TITLE","error: "&Edita&" not found")
--      colours[kEdit] = BrightRed
--      colours[kEdit1] = BrightRed
--      IupSetAttribute(tedix,"FGCOLOR",BrightRed)
        IupSetAttribute(xedix,"FGCOLOR",BrightRed)
        IupSetAttribute(edit1,"FGCOLOR",BrightRed)
-->     repaintWindow({cbEdita,lEdit,edit1},False)
--      IupUpdate({tedix,edit1}) --[DEV see if we need this...]
        IupSetAttribute(tab2,"SIZE",NULL)
        IupRefresh(tab2)
    else
-->     setEnable(cbEdita,True)
        IupSetInt(tedix,"ACTIVE",True)
--      setOptions({"e","err","ex","exw"},isChecked(cbEdita),EDIT,actual,lEdit,kEdit,edit1)
        setOptions({"e","err","ex","exw"},EDIT,actual,tedix,xedix,edit1)
    end if

--> setRun("ex",isChecked(cbRun),actual,run1,kRun)
    setRun("ex",actual,trun1,xrun1)
--> setRun("exw",isChecked(cbRunW),actual,run2,kRunW)
    setRun("exw",actual,trunw,xrunw)

    if firsttime then
        firsttime = 0
-->     deleteItem(cddAct,0) -- empty list
--      for i=1 to length(actset) do
-->         void = insertItem(cddAct,actset[i],0)
--      end for
-->     setIndex(cddAct,A_APPLY)
    else
-->     if getIndex(cddAct)!=A_APPLY then
        if IupGetInt(actdd,"VALUE")!=A_APPLY then
            applyrqd = 1
        end if
    end if

--> wasFocus = getFocus()
    wasFocus = IupGetFocus()
--> setEnable(sbOK,applyrqd)
    IupSetInt(bOK,"ACTIVE",applyrqd)
--?{wasFocus,sbOK,psettings}
--  if wasFocus=sbOK then
    if wasFocus=bOK then
-->     setFocus(psettings)
        IupSetFocus(tab2)
    end if
IupSetAttribute(tab2,"SIZE",NULL)
IupRefresh(tab2)

end procedure

integer unicodeflag -- (one of the following four constants)
constant ANSI    = 0,
         UTF8    = 1,
         UTF16LE = 2,
         UTF16BE = 3

function get_unicode_char(integer fn)
integer ch, ch2
    ch = getc(fn)
    if ch!=-1 then
        ch2 = getc(fn)
        if unicodeflag=UTF16LE then
            if ch2 then -- (speedwise)
                ch += ch2*#100
            end if
        else -- UTF16BE
            ch = ch2+ch*#100
        end if
    end if
    return ch
end function

function get_unicode_line(integer fn)
integer ch
object res
integer nLen
atom pBuff
    if platform()!=WINDERS then ?9/0 end if
    if unicodeflag=UTF8 then
        res = gets(fn)
        if string(res) then
            nLen = c_func(xMultiByteToWideChar,{CP_UTF8,0,res,length(res),NULL,0})
            pBuff = allocate(nLen*2)
            nLen = c_func(xMultiByteToWideChar,{CP_UTF8,0,res,length(res),pBuff,nLen})
            res = peek2u({pBuff,nLen})
            free(pBuff)
        end if
    else        -- UTF16(LE|BE)
        ch = get_unicode_char(fn)
        if ch = -1 then
            res = -1
        else
            res = ""
            while ch!=-1 do
                if ch!='\r' then
                    res &= ch
                    if ch='\n' then exit end if
                end if
                ch = get_unicode_char(fn)
            end while
        end if
    end if
    return res
end function

function readFile(sequence name)
-- open and read contents of specified file.
-- Also sets unicodeflag (except on failure)
sequence file
integer fn
object line
integer uniskip

    file = {}
--?"readFile"
--?name
    fn = open(name,"r")
--?fn
    if fn!=-1 then
        unicodeflag = ANSI
        line = trim(gets(fn))
        if not atom(line)
        and length(line)>=2 then
            if equal(line[1..2],{#FF,#FE}) then
                unicodeflag = UTF16LE
                uniskip = 2
            elsif equal(line[1..2],{#FE,#FF}) then
                unicodeflag = UTF16BE
                uniskip = 2
            elsif length(line)>=3
              and equal(line[1..3],{#EF,#BB,#BF}) then
                unicodeflag = UTF8
                uniskip = 3
            end if
        end if
        if unicodeflag then
            -- gets() returns L"Hello" as "H\0e\0l\0l\0o\0" and makes a complete mess 
            -- of \r\0\n\0 handling, iyswim. So read things one (wide)char at a time.
            -- likewise getc() will not process "\r\0\n\0" as one might like, so close
            -- and re-open the file in binary mode (not strictly necessary for UTF8,
            -- but the uniskip is).
            close(fn)
            fn = open(name,"rb")
            if seek(fn,uniskip) then
                puts(1,"error seeking in readFile")
            end if
            line = trim(get_unicode_line(fn))
        end if
        while not atom(line) do
            if length(line)!=0 and line[1]!=';' then -- not blank/comment lines
                file = append(file,line)
            end if
            if unicodeflag then
                line = get_unicode_line(fn)
            else
                line = gets(fn)
            end if
            line = trim(line)
        end while
        close(fn)
    end if
--?file
    return file
end function

function dequote(string s)
string res
integer ch, skip
    res = ""
    skip = 0
    for i=1 to length(s) do
        ch = s[i]
        if ch='\\' and skip=0 then
            skip = 1
            if not find(s[i+1],`\"`) then ?9/0 end if -- (more code rqd?)
        else
            res &= ch
            skip = 0
        end if
    end for
    return res
end function

procedure readUndo()
-- perform a quick and dirty parse of undo.reg
-- note: no proper attempt is made to validate the content
-- populates exti (defined above)
sequence text
sequence line, subkey
string key
integer lno
integer ext, k
sequence subkeys
sequence subkeyidx
integer setting
integer lidx, odd, ch, ch2

    if platform()!=WINDERS then ?9/0 end if
--  text = readFile(`demo\arwendemo\pgui\undo.reg`)
--  text = readFile(`demo\pGUI\pdemo\undo.reg`)
    text = readFile(croot&`demo\pGUI\pdemo\undo.reg`)
--?text
    if length(text) then
        lno = 1
        if text[lno]!="Windows Registry Editor Version 5.00" then ?9/0 end if
        exti = repeat({0,0,0,0},length(EXTS))
        subkeys = {}
        subkeyidx = repeat(0,length(EXTS))
        while lno<=length(text) do
            while lno<length(text) and text[lno+1][1]='[' do
                -- (skips over eg shell/edit/command, where neither shell 
                --  nor edit contain any useful content, and any [- lines.)
                lno += 1
                line = text[lno] 
            end while
            -- 30/8/17:
            if lno>=length(text) then exit end if
            if line[1]!='[' then ?9/0 end if
            if line[length(line)]!=']' then ?9/0 end if
            key = line[2..-2]
            if match(HKLM,key)=1 then
                key = key[length(HKLM)+1..length(key)]
                if key!=PHKLM then ?9/0 end if
                lno += 1
                line = text[lno]
                key = `"Path"=hex(2):`
                if match(key,line)!=1 then ?9/0 end if
                line = line[length(key)+1..length(line)]
                key = ""
                lidx = 1
                odd = 1
                while lidx<=length(line) do
                    ch = line[lidx]
                    if ch='\\' then
                        lno += 1
                        line = text[lno]
                        lidx = 1
                        ch = line[1]
                    end if
                    if odd then
                        if ch>='0' and ch<='9' then
                            ch = ch-'0'
                        elsif ch>='a' and ch<='f' then
                            ch = ch-'a'+10
                        else
                            ?9/0
                        end if
                        ch *= 16
                        lidx += 1
                        ch2 = line[lidx]
                        if ch2>='0' and ch2<='9' then
                            ch += ch2-'0'
                        elsif ch2>='a' and ch2<='f' then
                            ch += ch2-'a'+10
                        else
                            ?9/0
                        end if
                        key &= ch
                        odd = 0
                    else
                        if ch!='0' then ?9/0 end if
                        lidx += 1
                        ch = line[lidx]
                        if ch!='0' then ?9/0 end if
                        odd = 1
                    end if
                    lidx += 1
                    if lidx>length(line) then exit end if
                    ch = line[lidx]
                    if ch!=',' then ?9/0 end if
                    lidx += 1
                end while
                lno += 1
                line = text[lno] 
                if key[length(key)]!='\0' then ?9/0 end if
                key = key[1..-2]
                undos[UHKLMPATH] = key
            elsif match(HKCU,key)=1 then
                key = key[length(HKCU)+1..length(key)]
                if key!=PHKCU then ?9/0 end if
                lno += 1
                line = text[lno] 
                key = `"Path"="`
                if match(key,line)!=1 then ?9/0 end if
                if line[length(line)]!='"' then ?9/0 end if
                key = dequote(line[length(key)+1..-2])
                lno += 1
                line = text[lno] 
                undos[UHKCUPATH] = key
            elsif match(HKCR,key)=1 then
                key = key[length(HKCR)+1..length(key)]
                ext = 0
                if key[1]='.' then
                    ext = find(key[2..length(key)],EXTS)
                    exti[ext] = {0,0,0,0,key}   -- (key is just for debugging, exti[i] always corresponds to EXTS[i])
                else
                    k = find('\\',key)
                    ext = find(key[1..k-1],subkeys)
                    if ext=0 then ?9/0 end if
                    key = key[k+1..length(key)]
                    k = find('\\',key)
                    if k!=0 then
                        if key[1..k]!=`shell\` then ?9/0 end if
                        key = key[k+1..length(key)]
                    end if
                end if
                while 1 do
                    lno += 1
                    if lno>length(text) then exit end if
                    line = text[lno]
                    if line[1]='[' then exit end if
                    if line[1]='@' then
                        if line[2]!='=' then ?9/0 end if
                        if line="@=-" then
                            if key[1]!='.' then ?9/0 end if -- (more code rqd?)
                            subkey = ""
                        else
                            if line[3]!='\"' then ?9/0 end if
                            if line[length(line)]!='\"' then ?9/0 end if
                            subkey = line[4..-2]
                        end if
                        if key[1]='.' then
                            if length(subkey) then
                                k = find(subkey,subkeys)
                                if k=0 then
                                    subkeys = append(subkeys,subkey)
                                    k = length(subkeys)
                                end if
                                subkeyidx[ext] = k
                            end if
                        else
                            setting = 0
                            if key=DefaultIcon then
                                setting = ICON
                            elsif key=`edit\command`
                               or key=`debug\command` then
                                setting = EDIT
                            elsif key=`open\command` then
                                setting = RUN
                            end if
                            if setting!=0 then
                                for i=1 to length(exti) do
                                    if subkeyidx[i]=ext then
                                        exti[i][setting] = dequote(subkey)
                                    end if
                                end for
                            end if
                        end if
                    elsif line=PerceivedTypeEqText then
                        if key[1]!='.' then ?9/0 end if
                        exti[ext][PT] = 1
                    else
                    end if
                end while
            else ?9/0
            end if

        end while
    else
--      exti = repeat({1,1,1,1},length(EXTS)) --DEV...
        exti = repeat({1,0,0,0},length(EXTS)) --DEV...
--      exti = repeat({1},length(EXTS))     -- (untried)
    end if
end procedure

integer sinit
        sinit = 0

procedure FatalErr(sequence err_msg)
--integer void
--  void = messageBox("Fatal Error", err_msg & "\n\nProgram aborting.", {MB_OK, MB_ICONERROR})
    IupMessage("Fatal Error", err_msg & "\n\nProgram aborting.")
    ?9/0
    abort(1)
end procedure

procedure link_error(sequence name)
    FatalErr("Couldn't link function:\n\n " & name & "()")  -- terminates with ?9/0 abort(1)
end procedure

-- dynamically link a C routine as a Euphoria/Phix function
function link_c_func(atom dll, sequence name, sequence args, atom result)
integer handle
    handle = define_c_func(dll, name, args, result)
    if handle = -1 then link_error(name) end if
    return handle
end function

-- dynamically link a C routine as a Euphoria/Phix procedure
--function link_c_proc(atom dll, sequence name, sequence args)
--integer handle
--  handle = define_c_proc(dll, name, args)
--  if handle = -1 then link_error(name) end if
--  return handle
--end function

-- open a dll file and get handle to it
function assign_dll(sequence dll_file)
atom handle
    handle = open_dll(dll_file)
    if handle = NULL then link_error(dll_file) end if
    return handle
end function

procedure Setup()
    if sinit=0 then
        sinit = 1
-->     setCheck({cbPerceivedType,cbPTOther,cbDefaultIcon,cbErrorIcon,cbEdita,cbRun,cbRunW},BST_CHECKED)
        bool flag = (platform()=WINDERS)
        IupSetInt({tpert,tper2,tdefi,terri,tedix,trun1,trunw},"VALUE",flag)
        IupSetInt({ruser,rmach,cpath,tpert,tper2,tdefi,terri,tedix,trun1,trunw,actdd,bOK},"ACTIVE",flag)
        if platform()=WINDERS then
            readUndo() -- (result in exti)
            advapi32 = assign_dll("advapi32.dll")
            RegOpenKeyExA = link_c_func(advapi32,"RegOpenKeyExA",
                {C_LONG,    --  HKEY  hKey (HKEY_CLASSES_ROOT) 
                 C_POINTER, --  LPCTSTR lpSubKey (eg ".bat", `batfile\DefaultIcon`)
                 C_LONG,    --  DWORD  ulOptions (must be 0)
                 C_LONG,    --  REGSAM  samDesired (KEY_ALL_ACCESS)
                 C_LONG},   --  PHKEY  phkResult
                C_LONG)     -- LONG 0=success, else error code.
-- not XP:
--          RegGetValueA = link_c_func(advapi32,"RegGetValueA",
--          RegGetValueA = define_c_func(advapi32,"RegGetValueA",
--              {C_LONG,    --  _In_        HKEY hkey
--               C_PTR,     --  _In_opt_    LPCTSTR lpSubKey,
--               C_PTR,     --  _In_opt_    LPCTSTR lpValue,
--               C_INT,     --  _In_opt_    DWORD dwFlags,
--               C_PTR,     --  _Out_opt_   LPDWORD pdwType,
--               C_PTR,     --  _Out_opt_   PVOID pvData,
--               C_PTR},    --  _Inout_opt_ LPDWORD pcbData
--              C_LONG)     -- LONG 0=success, else error code.
--PL 28/12/16 for XP:
            RegQueryValueExA = link_c_func(advapi32,"RegQueryValueExA",
                {C_LONG,    --  _In_        HKEY hKey,
                 C_PTR,     --  _In_opt_    LPCTSTR lpValueName,
                 C_PTR,     --  _Reserved_  LPDWORD lpReserved,
                 C_PTR,     --  _Out_opt_   LPDWORD lpType,
                 C_PTR,     --  _Out_opt_   LPBYTE lpData,
                 C_PTR},    --  _Inout_opt_ LPDWORD lpcbData
                C_LONG)     -- LONG 0=success, else error code.
            RegCloseKey = link_c_func(advapi32,"RegCloseKey",
                {C_LONG},   --  HKEY  hKey
                C_LONG)     -- LONG 0=success, else error code.
            kernel32 = assign_dll("kernel32.dll")
            xMultiByteToWideChar = link_c_func(kernel32,"MultiByteToWideChar",
                {C_INT,     --  UINT  CodePage,     // code page 
                 C_INT,     --  DWORD  dwFlags,     // character-type options 
                 C_PTR,     --  LPCSTR  lpMultiByteStr,     // address of string to map 
                 C_INT,     --  int  cchMultiByte,  // number of characters in string 
                 C_PTR,     --  LPWSTR  lpWideCharStr,      // address of wide-character buffer 
                 C_INT},    --  int  cchWideChar    // size of buffer 
                C_INT)      -- int
            user32 = assign_dll("user32.dll")
            xSendMessage = link_c_func(user32, "SendMessageA",
                {C_PTR,     --  HWND  hwnd, // handle of destination window
                 C_UINT,    --  UINT  uMsg, // message to send
                 C_UINT,    --  WPARAM  wParam, // first message parameter
                 C_UINT},   --  LPARAM  lParam  // second message parameter
                C_LONG)     -- LRESULT
            phkResult = allocate(4)
            lpType = allocate(4)
            lpcbData = allocate(4)
        end if
    end if
    -- refresh using current registry settings
    if platform()=WINDERS then
        setButtonStates()
    end if
end procedure

function escape(string s)
-- backslash-escape " and \ in (ansi) string s
integer ch
string res
    res = ""
    for i=1 to length(s) do
        ch = s[i]
        if ch='\"' then
            res &= `\"`
        elsif ch='\\' then
            res &= `\\`
        else
            res &= ch
        end if
    end for
    return res
end function

procedure putw(integer fn, string s)
-- write an ansi string in WideString format
-- fn should be open in binary mode
integer ch
    for i=1 to length(s) do
        ch = s[i]
        if ch='\n' then
            puts(fn,'\r')
            puts(fn,0)
        end if
        puts(fn,ch)
        puts(fn,0)
    end for
end procedure

function addline(string line, string hex2, integer fn)
-- append a hex2 word (REG_EXPAND_SZ) with line breaks
-- hex2 should be eg ",25" for '%', though it will be
-- just "25" for the very first character
    for byte=1 to 2 do
        if length(line)>=76 then
            line &=",\\\n"
            putw(fn,line)
            line = "  "
            hex2 = hex2[2..length(hex2)]
        end if
        line &= hex2
        hex2 = ",00"
    end for
    return line
end function

function updatePath(string path)
sequence parts,phixes
integer k
    if pathmode=PATHADD then
        path &= ";"&basedir
    else
        {parts,phixes} = splitpath(path)
        if length(phixes)!=1 then ?9/0 end if
        k = phixes[1]
        if pathmode=PATHREPLACE then
            parts[k] = basedir
        elsif pathmode=PATHRESTORE then
            parts[k] = restdir
        elsif pathmode=PATHREMOVE then
            parts[k..k] = {}
        end if
        path = joinpath(parts)
    end if
    return path
end function

constant UNDO=1,    -- create undo.reg from registry
         CREATE=2   -- create setup.reg from desired

--procedure createDotReg(integer flag, integer prompt=1)
procedure createDotReg(integer flag, integer prompt)
-- flag is one of UNDO, AUNDO, CREATE, ACREATE  --DEV bluff!
--  Note that, for example, if HKCR\.exw's original default value was "EuFile", which we intend
--  to redirect to "PhixSource", an undo will (create a file that can) restore HKCR\.exw in its 
--  entirety, including the "EuFile", and likewise reset/remove all of HKCR\PhixSource. Neither 
--  this, nor anything else in this program, goes anywhere near HKCR\EuFile, it is simply left 
--  completely untouched, however and of course, an earlier Apply/setup might (nb I said might) 
--  mean that nothing is actually using it any more.
string filename
integer fn
string subkey, verb
object subname
integer shelldone
integer res
atom key_id
sequence desiredi
object HKLMPath, HKCUPath
string line

    if platform()!=WINDERS then ?9/0 end if
--  filename = basedir&`demo\arwendemo\pgui\`
    filename = basedir&`demo\pGUI\pdemo\`
--  switch flag do
--    case UNDO:        filename &= "undo.reg"
--    case CREATE:      filename &= "setup.reg"
--  end switch
    if flag=UNDO then       filename &= "undo.reg"
    elsif flag=CREATE then  filename &= "setup.reg"
    end if

    fn = open(filename,"r")
    if fn!=-1 then
        close(fn)
        if not prompt then
            if flag=UNDO then return end if
        else
--DEV getSaveFileName()
-->         res = messageBox("File Already Exists","Overwrite "&filename&"?",MB_YESNO)
            res = IupAlarm("File Already Exists","Overwrite "&filename&"?","Yes","No")
--          if res=IDNO then return end if
            if res=2 then return end if
        end if
    end if

    HKLMPath = KeyValue2(HKLM,HKEY_LOCAL_MACHINE,PHKLM,"Path")--,RRF_RT_REG_EXPAND_SZ+RRF_NOEXPAND)
    if flag=CREATE and pathmode!=0 then
-->     if isChecked(rbMachine) then
        if IupGetInt(rmach,"VALUE") then
            HKLMPath = updatePath(HKLMPath)
        end if
    end if

    if not string(HKLMPath) then
--      for i=length(filename) to 1 by -1 do
--          if filename[i]='\\' then
--              filename = filename[i+1..length(filename)]
--              exit
--          end if
--      end for
--DEV/SUG: (general)
--      filename = filename[rfind('\\',filename)+1..length(filename)]
        filename[1..rfind('\\',filename)] = ""
-->     res = messageBox("Error","error reading "&HKLM&PHKLM&`\Path, `&filename&" *NOT* created",MB_OK)
        IupMessage("Error","error reading "&HKLM&PHKLM&`\Path, `&filename&" *NOT* created")
        return
    end if
    -- (output in UTF16LE, to match regedit/Export)
    fn = open(filename,"wb")
    puts(fn,{#FF,#FE})
    putw(fn,"Windows Registry Editor Version 5.00\n\n")

    putw(fn,sprintf("[%s%s]\n",{HKLM,PHKLM}))
    putw(fn,sprintf(";(Path=%s)\n",{HKLMPath})) -- (a comment)
    line = addline(`"Path"=hex(2):`,sprintf("%02X",HKLMPath[1]),fn)
    for i=2 to length(HKLMPath) do
        line = addline(line,sprintf(",%02X",HKLMPath[i]),fn)
    end for
    line = addline(line,",00",fn)
    line &= "\n\n"
    putw(fn,line)

    HKCUPath = KeyValue2(HKCU,HKEY_CURRENT_USER,PHKCU,"Path")--,RRF_RT_REG_SZ)
    if flag=CREATE and pathmode!=0 then
-->     if isChecked(rbUser) then
        if IupGetInt(ruser,"VALUE") then
            HKCUPath = updatePath(HKCUPath)
        end if
    end if
    if string(HKCUPath) then
        if length(HKCUPath)=0 then
            putw(fn,sprintf("[-%s%s]\n\n",{HKCU,PHKCU}))
        else
            putw(fn,sprintf("[%s%s]\n",{HKCU,PHKCU}))
            putw(fn,sprintf("\"Path\"=\"%s\"\n\n",{escape(HKCUPath)}))
        end if
    end if

    for i=1 to length(EXTS) do
        subkey = "."&EXTS[i]
        putw(fn,sprintf("[HKEY_CLASSES_ROOT\\%s]\n",{subkey}))
        if flag!=CREATE
        or amap[i]!=0 then
            if flag=CREATE then
                subname = knownSubkeys[amap[i]]
            else
                subname = KeyValue2(HKCR,HKEY_CLASSES_ROOT,subkey, NULL)--,RRF_RT_REG_SZ)
            end if
            if string(subname) then
                putw(fn,sprintf("@=\"%s\"\n",{subname}))
            else
                putw(fn,"@=-\n")
            end if
        end if
        if flag=CREATE then
            if desired[ewmap[i]][PT] then
                subname = "text"
            else
                subname = 0
            end if
--          subname = desired[ewmap[i]][PT]
        else
            subname = KeyValue2(HKCR,HKEY_CLASSES_ROOT, subkey, PerceivedType)--,RRF_RT_REG_SZ)
        end if
        if string(subname) then
            putw(fn,sprintf("\"PerceivedType\"=\"%s\"\n",{subname}))
        else
            putw(fn,"\"PerceivedType\"=-\n")
        end if
        putw(fn,"\n")
    end for

    for i=1 to length(knownSubkeys) do
        subkey = knownSubkeys[i]
        res = c_func(RegOpenKeyExA,{HKEY_CLASSES_ROOT,subkey,0,KEY_READ,phkResult})
        if res=0 then
            putw(fn,sprintf("[HKEY_CLASSES_ROOT\\%s]\n",{subkey}))
            if flag=CREATE then
                desiredi = desired[ksmap[i]]
                subname = knownDescs[i]
            else
                subname = KeyValue2(HKCR,HKEY_CLASSES_ROOT,subkey, NULL)--,RRF_RT_REG_SZ)
            end if
            if string(subname) then
                putw(fn,sprintf("@=\"%s\"\n\n",{subname}))
            else
                putw(fn,"@=-\n\n")
            end if
            if flag=CREATE then
                subname = desiredi[ICON]
            else
                key_id = peek4u(phkResult)
                subname = KeyValue2(HKCR&subkey,key_id,DefaultIcon,NULL)--,RRF_RT_REG_SZ)
            end if
            if string(subname) then
                putw(fn,sprintf("[HKEY_CLASSES_ROOT\\%s\\%s]\n",{subkey,DefaultIcon}))
                putw(fn,sprintf("@=\"%s\"\n\n",{escape(subname)}))
            else
                putw(fn,sprintf("[-HKEY_CLASSES_ROOT\\%s\\%s]\n\n",{subkey,DefaultIcon}))
            end if
            shelldone = 0
            for dix=EDIT to RUN do  -- (2 iterations)
                if dix=EDIT then
                    if subkey=knownSubkeys[kErr] then   -- ie "PhixErrorFile"
--                  if i=1 then
                        verb = "debug"
                    else
                        verb = "edit"
                    end if
                else -- dix=RUN
                    verb = "open"
                end if
                if flag=CREATE then
                    if length(desiredi)<dix then
                        subname = 0
                    else
                        subname = desiredi[dix]
                    end if
                else
--                  subname = KeyValue2(HKCR&subkey,key_id,"shell\\"&verb&"\\command",NULL)--,RRF_RT_REG_SZ)
                    subname = KeyValue2(HKCR&subkey,key_id,`shell\`&verb&`\command`,NULL)--,RRF_RT_REG_SZ)
                end if
                if string(subname) and length(subname)>0 then
                    if not shelldone then
                        putw(fn,sprintf("[HKEY_CLASSES_ROOT\\%s\\shell]\n\n",{subkey}))
                        shelldone = 1
                    end if
                    putw(fn,sprintf("[HKEY_CLASSES_ROOT\\%s\\shell\\%s]\n\n",{subkey,verb}))
                    putw(fn,sprintf("[HKEY_CLASSES_ROOT\\%s\\shell\\%s\\command]\n",{subkey,verb}))
                    putw(fn,sprintf("@=\"%s\"\n\n",{escape(subname)}))
                else
                    putw(fn,sprintf("[-HKEY_CLASSES_ROOT\\%s\\shell\\%s]\n\n",{subkey,verb}))
                end if
                verb = "open"
            end for
            if not shelldone then
                putw(fn,sprintf("[-HKEY_CLASSES_ROOT\\%s\\shell]\n\n",{subkey}))
            end if
            if flag!=CREATE then
                res = c_func(RegCloseKey,{key_id})
            end if
            putw(fn,"\n")
        elsif res=ERROR_FILE_NOT_FOUND then
            putw(fn,sprintf("[-HKEY_CLASSES_ROOT\\%s]\n\n",{subkey}))
        elsif res!=0 then
            erm(res,`HKEY_CLASSES_ROOT\`&subkey)
        end if
    end for
    close(fn)
    if prompt then
-->     void = messageBox("File Created",filename,MB_OK)
        IupMessage("File Created",filename)
    end if
end procedure

include builtins\syswait.ew

procedure merge(string filename)
-- (bugfix: using 64-bit regedit stopped a pointless system32->syswow64 on a shell icon)
--string cmd = sprintf(`regedit "%sdemo\arwendemo\pgui\%s"`,{basedir,filename})
string cmd
    if platform()!=WINDERS then ?9/0 end if
--  cmd = sprintf(`C:\windows\regedit "%sdemo\arwendemo\pgui\%s"`,{basedir,filename})
    cmd = sprintf(`C:\windows\regedit "%sdemo\pGUI\pdemo\%s"`,{basedir,filename})
--  void = sysexec(cmd)
    {} = system_exec(cmd)
--  void = system_exec(cmd,4)   --DEV maybe?
    setButtonStates()
    -- (note: will likely make the program become unresponsive for 10s or more)
    {} = c_func(xSendMessage,{HWND_BROADCAST,WM_SETTINGCHANGE,0,"Environment"})
end procedure

procedure edit(string filename)
string fmt, cmd
object d

--DEV platform()=WINDERS?? join_path??
--  filename = basedir&`demo\arwendemo\pgui\`&filename
    filename = basedir&`demo\pGUI\pdemo\`&filename
    d = dir(filename)
    if atom(d) or length(d)!=1 then
-->     void = messageBox("Error",filename&" not found.",MB_OK)
        IupMessage("Error",filename&" not found.")
        return
    end if
--  d = dir(Edita) -- (may be .exe or .exw, see setButtonStates)
--  if atom(d) or length(d)!=1 then
    if length(EditWithEdita)=0 then
        --DEV LINUX=gedit?
        fmt = `notepad "%s"`
    else
        fmt = EditWithEdita
--      if fmt[-3]!='%' then ?9/0 end if
        if fmt[length(fmt)-2]!='%' then ?9/0 end if
--      if fmt[-2]!='1' then ?9/0 end if
        if fmt[length(fmt)-1]!='1' then ?9/0 end if
--      fmt[-2] = 's' -- replace %1 with %s
        fmt[length(fmt)-1] = 's' -- replace %1 with %s
    end if
    cmd = sprintf(fmt,{filename})
--  sysproc(cmd)
    {} = system_exec(cmd,8)
end procedure

procedure apply_action()
    integer action = IupGetInt(actdd,"VALUE")
    switch action do
        case A_CREATEUNDO:  createDotReg(UNDO,1)
                            readUndo()
        case A_EDITUNDO:    edit("undo.reg")
        case A_RELOADUNDO:  readUndo()
        case A_MERGEUNDO:   merge("undo.reg")
        case A_CREATESETUP: createDotReg(CREATE,1)
        case A_EDITSETUP:   edit("setup.reg")
        case A_MERGESETUP:  merge("setup.reg")
        case A_APPLY:       createDotReg(UNDO,0)
                            createDotReg(CREATE,0)
                            merge("setup.reg")
    end switch
end procedure

--/*
--                  `Perceived Type ("text") is fairly harmless and simply ensures that Windows Explorer can `&
--                  "display a sensible preview. Of course, .bat, .css, .inc, and .js aren't really "&
--                  "Phix at all, nor is .asm (but Phix does create .asm listing files), however they are "&
--                  "useful for me (via .reg files) when setting up a new/test machine, in particular within "&
--                  "the standard Windows open file dialogue (which is itself an instance of Explorer).\n\n"&
--
--                  "Default Icon is likewise fairly harmless and just changes the display in Explorer.\n\n"&
--
--                  "Edit with Edita should be fairly self explanatory, disable if you want to carry on "&
--                  "using a different editor.\n\n"&
--
--                  "You can also disable Run if you don't want Phix source files to be runnable by "&
--                  "double clicking on them.\n\n"&
--
--  >
--                  "Initial settings are derived from the contents of the registry and setup.reg\n\n"&
--?                 "It should be clearly apparent that you cannot set .e and .ew independently.\n\n"&
--                  
--                  "Apply (disabled if nothing needs doing) creates an undo.reg if one does not already "&
--                  "exist, and then modifies the registry directly. Note that it is always going to be "&
--                  "safer to create a setup.reg and vet the contents before manually applying it, not "&
--                  "that this is (deliberately) doing anything particularly dangerous to your machine. "&
--                  "As above, I find .reg files useful, however you may not have any need for them, "&
--                  `execpt that creating a setup.reg acts as "save my defaults". In many respects `&
--                  "it is fair to say this dialogue is somewhat over-engineered for my personal use.\n\n"&
--
--  >               
--                  `Create undo.reg creates demo\pGUI\pdemo\undo.reg, prompting if the file already `&
--                  "exists before overwriting it. Obviously that file contains instructions to return "&
--                  "the registry to the state before any modifications were made. Naturally, after an "&
--                  "overwrite or two the undo.reg will be indistinguishable from a setup.reg file. In "&
--  X               "fact, creating an undo.reg is actually a better way to transfer the exact settings "&
--                  "from the current machine to another, rather than creating setup.reg, which might "&
--                  "add in a few extra tweaks you don't actually want. Admittedly such a low-level "&
--                  "transfer only makes sense when working with virtual machines, that you know will "&
--                  "all have the exact same configuration, and (in my case) logging into 32 machines "&
--                  "and running pgui on each (as part of the monthly rollout) takes quite a bit longer "&
--                  "that writing a quick powershell (or similar) script to automate it. "&
--                  "Note that to (manually) apply such a .reg file, you should right click on it in "&
--                  "Windows Explorer and select Merge.\n\n"&
--
--  X-- See demo\pGUI\pdemo\setup.reg for (example) details of the actual settings this makes.
--  >?              `Create setup.reg (re-)creates demo\pGUI\pdemo\setup.reg, but does not prompt before `&
--                  "overwriting it. As above, said file would normally be used via Windows Explorer. Note "&
--  X               "that the setup.reg distributed with Phix is for 32-bit Phix on a 64-bit box (if you "&
--                  `should need to, remove a few " (x86)" from it manually). If the setup.reg does not `&
--                  "exist, or the one distributed with Phix is never overwritten, the defaults will always "&
--                  `be "turn everything on". Of course, if you have no idea what .reg files are, right `&
--                  "now is as good a time as any to learn about them!\n\n"&
--  >
--                  "Finally, the Help button (or F1), of course, displays this very message."
--*/
--/*
--  Black           = rgb(  0,   0,   0),
--  Blue            = rgb(  0,   0, 128),
--  Green           = rgb(  0, 128,   0),
--  Cyan            = rgb(  0, 128, 128),
--  Red             = rgb(128,   0,   0),
--  Orange          = rgb(128,  64,   0),
--  Amber           = rgb(255, 160,   0),
--  Magenta         = rgb(128,   0, 128),
--  DarkBrown       = rgb( 64,  64,   0),
--  Brown           = rgb(128, 128,   0),
--  DarkGray        = rgb( 64,  64,  64),
--  Gray            = rgb(128, 128, 128),
--  LightGray       = rgb(192, 192, 192),
--  BrightBlue      = rgb(  0,   0, 255),
--  BrightGreen     = rgb(  0, 255,   0),
--  BrightCyan      = rgb(  0, 255, 255),
--  BrightRed       = rgb(255,   0,   0),
--  Pink            = rgb(255, 176, 176),
--  BrightMagenta   = rgb(255,   0, 255),
--  Purple          = rgb(208, 128, 208),
--  Yellow          = rgb(255, 255,   0),
--  White           = rgb(224, 224, 224),
--  Parchment       = rgb(255, 255, 224),
--  BrightWhite     = rgb(255, 255, 255)
--
--*/

function valuechanged_cb(Ihandle /*any*/)
    setButtonStates()
    return IUP_CONTINUE
end function
constant cb_valuechanged = Icallback("valuechanged_cb")

function apply_cb(Ihandle /*bOK*/)
    apply_action()
    return IUP_CONTINUE
end function
constant cb_apply = Icallback("apply_cb")

global function create_settings_tab()
Ihandle --runBtn, flbl, helpBtn, closeBtn, rlfhc, tab1, tab2, box,
        lwino, lpath, 
--      radio, 
        lpad1, 
        lpert, lper2, ldefi, lerri,
        ledix, lrun1, lrunw, 
--      lpad3, 
--      lpad4, lpad5,
        lpad2, bHelp

    lwino = IupLabel(iff(platform()=WINDERS?"":"These settings are Windows only"),"PADDING=0x20")
    lpath = IupLabel("PATH:","ALIGNMENT=ARIGHT, PADDING=0x4")

    ruser = IupToggle(`HKEY_CURRENT_USER\Environment\Path`)
--IupSetAttribute(ruser,"FGCOLOR",Amber) -- does not work on an IupToggle!
    rmach = IupToggle(`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\Path`)
--  radio = IupRadio(IupVbox({ruser,rmach}))
    lpad1 = IupLabel()
    cpath = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    path1 = IupLabel("")
    path2 = IupLabel("")
    path3 = IupLabel("")
    lpert = IupLabel("Percieved Type","ALIGNMENT=ARIGHT, PADDING=0x2")
--  tpert = IupToggle(".e,.ew,.ex,.exw")
    tpert = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    xpert = IupLabel(".e,.ew,.ex,.exw")
    lper2 = IupLabel(`(of "text")`,"ALIGNMENT=ARIGHT, PADDING=0x2")
--  tper2 = IupToggle(".asm,.bat,.css,.inc,.js")
    tper2 = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    xper2 = IupLabel(".asm,.bat,.css,.inc,.js")
    ldefi = IupLabel("Default Icon","ALIGNMENT=ARIGHT, PADDING=0x2")
--  tdefi = IupToggle(".e,.ew,.ex,.exw")
    tdefi = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    xdefi = IupLabel(".e,.ew,.ex,.exw")
--  lpad3 = IupLabel("","SIZE=4x4")
    icon1 = IupLabel(`C:\Program Files\Phix\Psrc.ico,1`)
    lerri = IupLabel("Error File Icon","ALIGNMENT=ARIGHT, PADDING=0x2")
--  terri = IupToggle(".err")
    terri = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    xerri = IupLabel(".err")
--  lpad4 = IupLabel("","SIZE=4x4")
    icon2 = IupLabel(`C:\Windows\system32\shell32.dll,78`)
    ledix = IupLabel("Edit with Edix","ALIGNMENT=ARIGHT, PADDING=0x2")
--  tedix = IupToggle(".e,.ew,.ex,.exw")
    tedix = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    xedix = IupLabel(".e,.ew,.ex,.exw")
--  lpad5 = IupLabel("","SIZE=4x4")
    edit1 = IupLabel("pw edix %1")
    lrun1 = IupLabel(`Run ".ex" with Phix`,"ALIGNMENT=ARIGHT, PADDING=0x2")
--  trun1 = IupToggle("p %1")
    trun1 = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    xrun1 = IupLabel("p %1")
    lrunw = IupLabel(`Run ".exw" with Phix`,"ALIGNMENT=ARIGHT, PADDING=0x2")
--  trunw = IupToggle("pw %1")
    trunw = IupToggle("","VALUECHANGED_CB",cb_valuechanged,"RIGHTBUTTON=YES")
    xrunw = IupLabel("pw %1")

    lpad2 = IupLabel()
    actdd = IupList()
    IupSetAttribute(actdd,"DROPDOWN","YES")
--  IupSetInt(actdd,"VISIBLEITEMS",length(actset))
    IupSetInt(actdd,"VISIBLEITEMS",length(actset)+1)    -- [no idea why it needs the +1]
    for i=1 to length(actset) do
        IupSetAttributeId(actdd, "", i, actset[i])
    end for
    IupSetInt(actdd,"VALUE",length(actset))
    bOK = IupButton("OK",cb_apply,"PADDING=10x0")
    bHelp = IupButton("Help",cb_help,"PADDING=10x0")

    sequence nset = {lpath,lpad1,lpert,lper2,ldefi,lerri,ledix,lrun1,lrunw,lpad2}
    {} = IupDestroy(IupNormalizer(nset,"NORMALIZE=HORIZONTAL"))
    tab2 = IupHbox({IupFill(),
                    IupVbox({lwino,
--                           IupHbox({lpath,IupVbox({radio})}),
                             IupHbox({lpath,IupRadio(IupVbox({ruser,
                                                              rmach}))}),
                             IupHbox({lpad1,cpath,IupVbox({path1,
                                                           path2,
                                                           path3})}),
--                           IupHbox({lpert,IupVbox({tpert})}),
                             IupHbox({lpert,tpert,xpert}),
--                           IupHbox({lper2,IupVbox({tper2})}),
                             IupHbox({lper2,tper2,xper2}),
--                           IupHbox({ldefi,IupVbox({IupHbox({tdefi,xdefi}),
--                                                   IupHbox({lpad3,icon1})})}),
                             IupHbox({ldefi,tdefi,IupVbox({xdefi,
                                                           icon1})}),
--                           IupHbox({lerri,IupVbox({terri,
--                                                   IupHbox({lpad4,icon2})})}),
                             IupHbox({lerri,terri,IupVbox({xerri,
                                                           icon2})}),
--                           IupHbox({ledix,IupVbox({tedix,
--                                                   IupHbox({lpad5,edit1})})}),
                             IupHbox({ledix,tedix,IupVbox({xedix,
                                                           edit1})}),
--                           IupHbox({lrun1,IupVbox({trun1})}),
                             IupHbox({lrun1,trun1,xrun1}),
--                           IupHbox({lrunw,IupVbox({trunw})}),
                             IupHbox({lrunw,trunw,xrunw}),
--                           IupHbox({lpad2,IupHbox({actdd,bOK,bHelp})}),
                             IupHbox({lpad2,actdd,bOK,bHelp}),
                            $
                            }),
                    IupFill()},"TABTITLE=Settings")

    Setup()
--/*
--  psettings = create(TabItem,"Settings",0,TC,0,0,0,0,0),
--  lPath = create(Label,"PATH:",0,psettings,8,17,109,20,SS_RIGHT),
--  cHKCU = `HKEY_CURRENT_USER\Environment\Path`,
--  cHKLM = `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\Path`,
--  rbUser    = create(RadioButton,cHKCU,0,psettings,121,14,559,20,0),
--  rbMachine = create(RadioButton,cHKLM,0,psettings,121,31,631,20,0),
--  cbPath = create(CheckBox,"cbPath",0,psettings,119,53,14,20,{{BS_LEFTTEXT,BS_RIGHT},0}),
--  lPath1 = create(Label,"path1",0,psettings,137,56,535,20,SS_OWNERDRAW),
--  lPath2 = create(Label,"path2",0,psettings,137,75,535,20,SS_OWNERDRAW),
--  lPath3 = create(Label,"path3",0,psettings,137,94,535,20,SS_OWNERDRAW),
--  cbPerceivedType = create(CheckBox,"Percieved Type",0,psettings,  8,111,124,20,{{BS_LEFTTEXT,BS_RIGHT},0}),
--  lType1 =          create(Label,  ".e,.ew,.ex,.exw",0,psettings,137,114,535,20,SS_OWNERDRAW),
--  cbPTOther       = create(CheckBox,`(of "text")`, 0,psettings, 41,130,91,20,{{BS_CENTER,BS_LEFTTEXT},0}),
>
--  lType2 =    create(Label,".asm,.bat,.css,.inc,.js",0,psettings,137,133,535,20,SS_OWNERDRAW),
--  cbDefaultIcon = create(CheckBox,"Default Icon",0,psettings,8,151,124,20,{{BS_LEFTTEXT,BS_RIGHT},0}),
--  lIcon  = create(Label,".e,.ew,.ex,.exw",        0,psettings,137,154,535,20,SS_OWNERDRAW),
--  icon1 = create(Label,`C:\Program Files\Phix\Psrc.ico,1`,0,psettings,137,169,535,20,SS_OWNERDRAW),
--  cbErrorIcon = create(CheckBox,"Error File Icon",0,psettings,8,181,124,20,{{BS_LEFTTEXT,BS_RIGHT},0}),
--  lEIcon = create(Label,".err",                   0,psettings,137,184,180,20,SS_OWNERDRAW),
--  icon2 = create(Label,`C:\Windows\system32\shell32.dll,78`,0,psettings,137,197,535,20,SS_OWNERDRAW),
--  cbEdita = create(CheckBox,"Edit with Edita",0,psettings,8,210,124,19,{{BS_LEFTTEXT,BS_RIGHT},0}),
--  lEdit = create(Label,".e,.ew,.ex,.exw",0,psettings,137,213,196,20,SS_OWNERDRAW),
--  edit1 = create(Label,"pw edita %1",0,psettings,137,227,535,15,SS_OWNERDRAW),
--  cbRun = create(CheckBox,`Run ".ex" with Phix`,0,psettings,8,242,124,20,{{BS_LEFTTEXT,BS_RIGHT},0}),
--  run1 = create(Label,"p %1",0,psettings,137,245,535,13,SS_OWNERDRAW),
--  cbRunW = create(CheckBox,`Run ".exw" with Phix`,0,psettings,8,264,124,20,{{BS_LEFTTEXT,BS_RIGHT},0}),
--  run2 = create(Label,"pw %1",0,psettings,137,267,535,20,SS_OWNERDRAW),

--  cddAct = create(ComboDropDown,"Action", 0,psettings,120, 295, 116,157,0),
--  sbOK  = create(Button,"OK",         0,psettings, 246,289, 75,30,0),
--  sbHelp   = create(Button,"Help",            0,psettings,334,289, 75,30,0),
--*/

    return tab2
end function

