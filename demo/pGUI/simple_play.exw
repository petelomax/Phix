/*

  Simple Draw Application

  Shows the same picture on several canvas. Used to quick test the CD library and
  to demonstrate the use of CD library functions.

  This module uses only the CD library, there is another module to initialize the Window and its menus.

*/
include pGUI.e
include opengl.e

--#withtype atom_string
--#withtype cdContext

Ihandle SimpleDialog,
        SimpleCanvas

procedure SimpleUpdateSize(cdCanvan cnv)
int {w,h} = IupGetIntInt(SimpleCanvas, "RASTERSIZE")
    IupGLMakeCurrent(SimpleCanvas)

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
--PL [DEV] dunno what this does, does not /seem/ to be needed...
--?"gluOrtho2D(0, w, 0, h);"    -- ???

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    if cnv!=NULL then
        /* no need to update resolution */
        cdCanvasSetAttribute(cnv, "SIZE", "%dx%d", {w, h})
    end if
end procedure

/* Global variables */

cdCanvan winCanvas = NULL;     /* The window drawing canvas */
atom_string winData = NULL;
cdCanvan dbCanvas = NULL;         /* The double buffer canvas */
cdCanvan curCanvas = NULL;     /* The current canvas */

int clipping = CD_CLIPOFF;                     /* Clipping flag, same as the CD */
int write_mode = CD_REPLACE;                   /* Write Mode flag, same as the CD */
int contextplus = 0;
int simple_draw = 0;
int use_transform = 0;
int simulate = 0;
int use_opengl = 0;

enum DRAW_ALL, DRAW_TEXTFONTS, DRAW_TEXTALIGN, DRAW_TEST

constant STYLE_SIZE = 10 /* A small pattern and stipple size */
--long pattern[STYLE_SIZE*STYLE_SIZE];        /* Pattern buffer */
--unsigned char stipple[STYLE_SIZE*STYLE_SIZE]; /* Stipple buffer */
sequence pattern
string stipple = repeat('\0',STYLE_SIZE*STYLE_SIZE)

constant IMAGE_BUFFER_SIZE = 100
--unsigned char red[IMAGE_BUFFER_SIZE*IMAGE_BUFFER_SIZE];       /* Red image buffer */
--unsigned char green[IMAGE_BUFFER_SIZE*IMAGE_BUFFER_SIZE];     /* Green image buffer */
--unsigned char blue[IMAGE_BUFFER_SIZE*IMAGE_BUFFER_SIZE];      /* Blue image buffer */
string red, green, blue
string alpha = repeat('\0',IMAGE_BUFFER_SIZE*IMAGE_BUFFER_SIZE) /* Alpha image buffer */

procedure DrawTextBox(cdCanvas canvas, atom x, atom y, string text)

    cdCanvasSetLineWidth(canvas, 1)
    cdCanvasSetLineStyle(canvas, CD_CONTINUOUS)

    bool draw_box = false
    if draw_box then
        atom {xmin, xmax, ymin, ymax} = cdCanvasGetTextBox(canvas, x, y, text)
        cdCanvasRect(canvas, xmin, xmax, ymin, ymax)

-->
        if cdCanvasTextOrientation(canvas, CD_QUERY)==0 then
            cdCanvasSetForeground(canvas, CD_RED)
            cdCanvasLine(canvas, xmin, y, xmax, y)
        end if

    else /* bounding box */

        sequence rect = cdCanvasGetTextBounds(canvas, x, y, text)
        cdCanvasSetForeground(canvas, CD_GREEN)
        cdCanvasBegin(canvas, CD_CLOSED_LINES)
--SUG
--      for i=1 to length(rect) by 2 do
--          cdCanvasVertex(canvas, rect[i], rect[i+1])
--      end for
        cdCanvasVertex(canvas, rect[0+1], rect[1+1])
        cdCanvasVertex(canvas, rect[2+1], rect[3+1])
        cdCanvasVertex(canvas, rect[4+1], rect[5+1])
        cdCanvasVertex(canvas, rect[6+1], rect[7+1])
        cdCanvasEnd(canvas)
    end if

    /* reference point */
    cdCanvasSetForeground(canvas, CD_BLUE)
-->
    {} = cdCanvasMarkType(canvas, CD_PLUS)
    {} = cdCanvasMarkSize(canvas, 30)
    cdCanvasMark(canvas, x, y)

    cdCanvasSetForeground(canvas, CD_BLACK)
    cdCanvasText(canvas, x, y, text)
end procedure


procedure DrawTextFont(cdCanvas canvas, string font, int size, int xoff, int yoff, string text)
    cdCanvasFont(canvas, font, CD_PLAIN, size);
    DrawTextBox(canvas, xoff, yoff, text);

    cdCanvasFont(canvas, font, CD_BOLD, size);
    DrawTextBox(canvas, 2*xoff, yoff, text);

    cdCanvasFont(canvas, font, CD_ITALIC, size);
    DrawTextBox(canvas, 3*xoff, yoff, text);

    cdCanvasFont(canvas, font, CD_BOLD_ITALIC, size);
    DrawTextBox(canvas, 4*xoff, yoff, text);
end procedure

procedure SimpleDrawTextFonts(cdCanvas canvas)
int xoff, yoff, size;

    cdCanvasSetBackground(canvas, CD_WHITE);
    cdCanvasClear(canvas);

    xoff = 470;
    yoff = 150;
    size = -30;

    {} = cdCanvasTextAlignment(canvas, CD_CENTER);

    DrawTextFont(canvas, "Courier", size, xoff, yoff, "Courier");
    DrawTextFont(canvas, "Times", size, xoff, 2*yoff, "Times Roman");
    DrawTextFont(canvas, "Helvetica", size, xoff, 3*yoff, "Helvetica");
    DrawTextFont(canvas, "System", size, xoff, 4*yoff, "System");

--  {
--    static char native[50] = "Tecmedia, -60";
--    static char native[50] = "-*-helvetica-medium-r-*-*-8-*";
--    static char native[50] = "Edwardian Script ITC, 24";
--    cdSetAttribute("ADDFONTMAP","Edwardian Script ITC=ITCEDSCR");

--    char native[50] = "Book Antiqua, 24";
--    cdSetAttribute("ADDFONTMAP", "Book Antiqua=BKANT");

--    cdNativeFont("-d");
--    cdNativeFont(native);
--    DrawTextBox(xoff, yoff, native);
--    DrawTextBox(xoff, yoff, "The quick brown fox.");
--  }

  --cdNativeFont("Tecmedia, 36");

  --cdSetAttribute("ADDFONTMAP", "WingDings=WingDing");
  --cdNativeFont("WingDings, 36");

  --cdText(500, 50, "X");
  --cdText(500, 50, "abcdefghijklmnopqrstuvwxyz");
  --cdText(500, 150, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  --cdText(500, 250, "1234567890");
  --cdText(500, 350, "'\"!@#$%&*()_+-=[]^/;.,");

  --cdFont(CD_COURIER, 0, 22);
  --cdText(10, 60, "abcdefghijklmnopqrstuvwxyz");
  --cdText(10, 160, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  --cdText(10, 260, "1234567890");
  --cdText(500, 360, "'\"!@#$%&*()_+-=[]^/;.,");
end procedure

procedure DrawVectorTextBox(cdCanvas canvas, int x, int y, string text)

    cdCanvasSetLineWidth(canvas, 1);
    cdCanvasSetLineStyle(canvas, CD_CONTINUOUS);

    bool draw_box = false
    if draw_box then
        -->>
        ?"cdCanvasGetVectorTextBox not implemented"
--  int {xmin, xmax, ymin, ymax} = ;
--  cdCanvasGetVectorTextBox(canvas, x, y, text, &xmin, &xmax, &ymin, &ymax);
--  cdCanvasSetForeground(canvas, CD_GREEN);
--  cdCanvasRect(canvas, xmin, xmax, ymin, ymax);
--
--  if cdCanvasTextOrientation(canvas, CD_QUERY)==0 then
--    cdCanvasSetForeground(canvas, CD_RED);
--    cdCanvasLine(canvas, xmin, y, xmax, y);
--  end if
    else
        /* bounding box */
        sequence rect = cdCanvasGetVectorTextBounds(canvas, text, x, y)
        cdCanvasSetForeground(canvas, CD_GREEN);
        cdCanvasBegin(canvas, CD_CLOSED_LINES);
        cdCanvasVertex(canvas, rect[0+1], rect[1+1]);
        cdCanvasVertex(canvas, rect[2+1], rect[3+1]);
        cdCanvasVertex(canvas, rect[4+1], rect[5+1]);
        cdCanvasVertex(canvas, rect[6+1], rect[7+1]);
        cdCanvasEnd(canvas);
    end if

    /* reference point */
    cdCanvasSetForeground(canvas, CD_BLUE);
    {} = cdCanvasMarkType(canvas, CD_PLUS);
    {} = cdCanvasMarkSize(canvas, 30);
    cdCanvasMark(canvas, x, y);

    cdCanvasSetForeground(canvas, CD_BLACK);
-->
    cdCanvasVectorText(canvas, x, y, text);
end procedure

procedure SimpleDrawTextAlign(cdCanvas canvas)

sequence text_aligment = {
                          CD_NORTH,
                          CD_SOUTH,
                          CD_EAST,
                          CD_WEST,
                          CD_NORTH_EAST,
                          CD_NORTH_WEST,
                          CD_SOUTH_EAST,
                          CD_SOUTH_WEST,
                          CD_CENTER,
                          CD_BASE_CENTER,
                          CD_BASE_RIGHT,
                          CD_BASE_LEFT
                         };

sequence text_aligment_str = {
                              "North",
                              "South",
                              "East",
                              "West",
                              "North East",
                              "North West",
                              "South East",
                              "South West",
                              "Center",
                              "Base Center",
                              "Base Right",
                              "Base Left"
                             };

integer {width, height} = cdCanvasGetSize(canvas)

    cdCanvasSetBackground(canvas, CD_WHITE)
    cdCanvasClear(canvas)

    bool use_vector = false

--#if 0
--  if use_vector then
--      cdCanvasVectorTextDirection(canvas, 0, 0, 1, 1);
--  else
--      {} = cdCanvasTextOrientation(canvas, 45);
--  end if
--#endif

    atom xoff = width/4,
       yoff = height/7

    if use_vector then
-->
        {} = cdCanvasVectorCharSize(canvas, 30)
    else
        --cdCanvasFont(canvas, "Times", CD_PLAIN, 14)
        cdCanvasFont(canvas, "Helvetica", CD_PLAIN, 24)
    end if

    for i=1 to 12 do
        {} = cdCanvasTextAlignment(canvas, text_aligment[i])
        string ti = text_aligment_str[i]
        ti &= "\nSecond Line"
        if i<7 then
            if use_vector then
                DrawVectorTextBox(canvas, xoff, yoff*i, ti)
            else
                DrawTextBox(canvas, xoff, yoff*i, ti)
            end if
        else
            if use_vector then
                DrawVectorTextBox(canvas, 3*xoff, yoff*(i-4), ti)
            else
                DrawTextBox(canvas, 3*xoff, yoff*(i-4), ti)
            end if
        end if
    end for
end procedure

procedure SimpleDrawTest(cdCanvas canvas)

sequence pattern = repeat(0,16)  /* 4x4 pattern */

/* notice that if we are not using world coordinates 
   it is harder to position all the objects we want. */
int {w, h} = cdCanvasGetSize(canvas)

    cdCanvasSetBackground(canvas, CD_WHITE);
    cdCanvasClear(canvas);

/* pattern initialization */
    pattern[0+1]    = CD_RED;    pattern[1+1]  = CD_RED;    /* first line */
    pattern[2+1]    = CD_YELLOW; pattern[3+1]  = CD_YELLOW;
    pattern[4+1]    = CD_RED;    pattern[5+1]  = CD_RED;    /* second line */
    pattern[6+1]    = CD_YELLOW; pattern[7+1]  = CD_YELLOW;
    pattern[8+1]    = CD_YELLOW; pattern[9+1]  = CD_YELLOW; /* third line */
    pattern[10+1]   = CD_YELLOW; pattern[11+1] = CD_YELLOW;
    pattern[12+1]   = CD_YELLOW; pattern[13+1] = CD_YELLOW; /* fourth line */
    pattern[14+1]   = CD_YELLOW; pattern[15+1] = CD_YELLOW;

/* set the line attributes */
    cdCanvasSetLineWidth(canvas, 4);
    cdCanvasSetLineStyle(canvas, CD_CONTINUOUS);

/* in the center draw a pattern pizza 
   with a slice mising */
-->
    cdCanvasSetPattern(canvas, 4, 4, pattern);
    cdCanvasSector(canvas, w/2, h/2, w/2, h/2, 45, 0);
/* draws a dark red border */
    cdCanvasSetForeground(canvas, CD_DARK_RED);
-->
    cdCanvasSetInteriorStyle(canvas, CD_HOLLOW);
    cdCanvasSector(canvas, w/2, h/2, w/2, h/2, 45, 0);

/* on the left a red hash diamond */
/* notice the the default back opacity is transparent
   and the pattern of the sector will still be visible
   inside the hatch where the two objects intersect */
    cdCanvasSetForeground(canvas, CD_RED);
-->
    cdCanvasSetHatch(canvas, CD_DIAGCROSS);
    cdCanvasBegin(canvas, CD_FILL);
    cdCanvasVertex(canvas, w/4, h/4);
    cdCanvasVertex(canvas, w/2-w/8, h/2);
    cdCanvasVertex(canvas, w/4, 3*h/4);
    cdCanvasVertex(canvas, w/8, h/2);
    cdCanvasEnd(canvas);

/* draws a blue roof.*/
    cdCanvasSetForeground(canvas, CD_BLUE);
    cdCanvasLine(canvas, w/8, h/2, w/4, 3*h/4);
    cdCanvasLine(canvas, w/4, 3*h/4, w/2-w/8, h/2);

/* draws a dashed ribbon on the right 
   with a custom color */
    cdCanvasSetForeground(canvas, cdEncodeColor(100, 25, 200));
    cdCanvasSetLineStyle(canvas, CD_DASH_DOT);
    cdCanvasBegin(canvas, CD_BEZIER);
    cdCanvasVertex(canvas, 3*w/4-20, h/2-50);
    cdCanvasVertex(canvas, 3*w/4+150, 3*h/4-50);
    cdCanvasVertex(canvas, 3*w/4-150, 3*h/4-50);
    cdCanvasVertex(canvas, 3*w/4+20, h/2-50);
    cdCanvasEnd(canvas);

    cdCanvasFont(canvas, "Helvetica", CD_BOLD, 40);
    {} = cdCanvasTextAlignment(canvas, CD_CENTER);
    cdCanvasText(canvas, w/2, h/4-50, "Canvas Draw");
    atom {xmin, xmax, ymin, ymax} = cdCanvasGetTextBox(canvas, w/2, h/4-50, "Canvas Draw")
    cdCanvasRect(canvas, xmin, xmax, ymin, ymax);
end procedure

constant IMAGE_SIZE = 16

procedure SimpleDrawAll(cdCanvas canvas)

int {w, h} = cdCanvasGetSize(canvas)

  /* Clear the background to be white */
    cdCanvasSetBackground(canvas, CD_WHITE);
--  cdBackground(CD_GREEN);
    cdCanvasClear(canvas);

  /* Draw a reactangle and a polyline at the bottom-left area,
     using a thick line with transparency.
     Observe that transparency is only supported in a few drivers,
     and line join is not supported in the IMAGERGB driver. */
    cdCanvasSetLineWidth(canvas, 3);
    cdCanvasSetLineStyle(canvas, CD_CONTINUOUS);
    cdCanvasSetForeground(canvas, cdEncodeAlpha(CD_MAGENTA, 128));
    cdCanvasRect(canvas, 100, 200, 100, 200);

    cdCanvasBegin(canvas, CD_OPEN_LINES);
    cdCanvasVertex(canvas, 300, 250);
    cdCanvasVertex(canvas, 320, 270);
    cdCanvasVertex(canvas, 350, 260);
    cdCanvasVertex(canvas, 340, 200);
    cdCanvasVertex(canvas, 310, 210);
    cdCanvasEnd(canvas);

  /* Draw the red diagonal line with a custom line style. 
     Observe that line styles are not supported in the IMAGERGB driver. */
    cdCanvasSetForeground(canvas, CD_RED);
    cdCanvasSetLineWidth(canvas, 3);
-->
--  int dashes[] = {20, 15, 5, 5};
    sequence dashes = {20, 15, 5, 5}
    cdCanvasLineStyleDashes(canvas, dashes)

    cdCanvasSetLineStyle(canvas, CD_CUSTOM);
    cdCanvasLine(canvas, 0, 0, w-1, h-1);

  /* Draw the blue diagonal line with a pre-defined line style.
     Observe that the pre-defined line style is dependent on the driver. */
    cdCanvasSetForeground(canvas, CD_BLUE);
    cdCanvasSetLineWidth(canvas, 10);
    cdCanvasSetLineStyle(canvas, CD_DOTTED);
    cdCanvasLine(canvas, 0, h-1, w-1, 0);

    switch (clipping) do
        case CD_CLIPOFF:
-->
            {} = cdCanvasClip(canvas, CD_CLIPOFF);
        case CD_CLIPAREA:
    /* Defines the clipping area equals the canvas area minus a 100 pixels margin. */
-->
            cdCanvasClipArea(canvas, 100, w-100, 100, h-100);
            {} = cdCanvasClip(canvas, CD_CLIPAREA);
        case CD_CLIPPOLYGON:
            cdCanvasBegin(canvas, CD_CLIP);
            cdCanvasVertex(canvas, 100, 100);
            cdCanvasVertex(canvas, w-100, 100);
            cdCanvasVertex(canvas, w/2, h-100);
            cdCanvasEnd(canvas);
            {} = cdCanvasClip(canvas, CD_CLIPPOLYGON);
        case CD_CLIPREGION:
            {} = cdCanvasTextAlignment(canvas, CD_CENTER);
            cdCanvasFont(canvas, "Times", CD_BOLD, 50);

            cdCanvasBegin(canvas, CD_REGION);
-->
            cdCanvasRegionCombineMode(canvas, CD_UNION);
            cdCanvasBox(canvas, 100, 200, 100, 200);
            cdCanvasSector(canvas, w/2-50, h/2+50, 150, 150, 0, 360);
            cdCanvasSector(canvas, w/2-50, h/2-50, 150, 150, 0, 360);
            cdCanvasSector(canvas, w/2+50, h/2+50, 150, 150, 0, 360);
            cdCanvasSector(canvas, w/2+50, h/2-50, 150, 150, 0, 360);
            cdCanvasRegionCombineMode(canvas, CD_DIFFERENCE);
            cdCanvasText(canvas, w/2, h/2, "TEXT");
            cdCanvasEnd(canvas);
--    cdCanvasOffsetRegion(canvas, -50, 50);
            {} = cdCanvasClip(canvas, CD_CLIPREGION);

            cdCanvasSetForeground(canvas, CD_DARK_RED);
            cdCanvasBox(canvas, 0,w,0,h);
    end switch

    switch (write_mode) do
        case CD_REPLACE:
-->
            cdCanvasSetWriteMode(canvas, CD_REPLACE);
        case CD_XOR:
            cdCanvasSetWriteMode(canvas, CD_XOR);
        case CD_NOT_XOR:
            cdCanvasSetWriteMode(canvas, CD_NOT_XOR);
    end switch

    if use_transform then
        cdCanvasTransform(canvas, NULL);
        cdCanvasTransformTranslate(canvas, w/2, h/2);
        cdCanvasTransformRotate(canvas, 30);
        cdCanvasTransformScale(canvas, 0.5, 0.5);
        cdCanvasTransformTranslate(canvas, -w/2, -h/2);
    end if

--  cdSetfAttribute("ROTATE", "15 %d %d", w/2, h/2);

  /* Reset line style and width */
    cdCanvasSetLineStyle(canvas, CD_CONTINUOUS);
    cdCanvasSetLineWidth(canvas, 1);
--  cdBackOpacity(CD_TRANSPARENT); 

  /* Draw an arc at bottom-left, and a sector at bottom-right.
     Notice that counter-clockwise orientation of both. */
    cdCanvasSetInteriorStyle(canvas, CD_SOLID);
    cdCanvasSetForeground(canvas, CD_MAGENTA);
    cdCanvasSector(canvas, w-100, 100, 100, 100, 50, 180);
    cdCanvasSetForeground(canvas, CD_RED);
    cdCanvasArc(canvas, 100, 100, 100, 100, 50, 180);

  /* Draw a solid filled rectangle at center. */
    cdCanvasSetForeground(canvas, CD_YELLOW);
    cdCanvasBox(canvas, w/2-100, w/2+100, h/2-100, h/2+100);

  /* Prepare font for text. */
    {} = cdCanvasTextAlignment(canvas, CD_CENTER);
    {} = cdCanvasTextOrientation(canvas, 70);
    cdCanvasFont(canvas, "Times", CD_BOLD, 24);

  /* Draw text at center, with orientation, 
     and draw its bounding box. 
     Notice that in some drivers the bounding box is not precise. */
    sequence rect = cdCanvasGetTextBounds(canvas, w/2, h/2, "cdMin Draw (çãí)")
    cdCanvasSetForeground(canvas, CD_RED);
    cdCanvasBegin(canvas, CD_CLOSED_LINES);
    cdCanvasVertex(canvas, rect[0+1], rect[1+1]);
    cdCanvasVertex(canvas, rect[2+1], rect[3+1]);
    cdCanvasVertex(canvas, rect[4+1], rect[5+1]);
    cdCanvasVertex(canvas, rect[6+1], rect[7+1]);
    cdCanvasEnd(canvas);

    cdCanvasSetForeground(canvas, CD_BLUE);
    cdCanvasText(canvas, w/2, h/2, "cdMin Draw (çãí)");
    {} = cdCanvasTextOrientation(canvas, 0);

  /* Prepare World Coordinates */
    wdCanvasViewport(canvas, 0,w-1,0,h-1);
    if w>h then
        wdCanvasWindow(canvas, 0,w/h,0,1);
    else
        wdCanvasWindow(canvas, 0,1,0,h/w);
    end if

  /* Draw a filled blue rectangle in WC */
-->
    wdCanvasBox(canvas, 0.20, 0.30, 0.40, 0.50);
    cdCanvasSetForeground(canvas, CD_RED);
  /* Draw the diagonal of that rectangle in WC */
-->
    wdCanvasLine(canvas, 0.20, 0.40, 0.30, 0.50);

--  wdVectorTextDirection(0, 0, 1, 1);
  /* Prepare Vector Text in WC. */
-->
    {} = wdCanvasVectorCharSize(canvas, 0.07);

--  wdVectorText(0.1, 0.4, "    ");
--  wdVectorText(0.1, 0.2, "    ");
  --{
  --  int i;
  --  char t[2];
  --  char s[10];
  --  int x = 20;
  --  int y = 0;
  --  t[1] = 0;
  --  for (i = 0; i < 256; i++)
  --  {
  --    int dx = 90;
  --    t[0] = (char)i;
  --    sprintf(s, "%d", i);
  --    cdText(x, y, s);
  --    cdText(x+dx, y, t);
  --    cdVectorText(x+2*dx, y, t);
  --    
  --    x += 3*dx + 2*dx/3;
  --    if ((i+1) % 7 == 0)
  --    {
  --      x = 20;
  --      y += 90;
  --    }

  --  }
  --}

  /* Draw vector text, and draw its bounding box. 
     We also use this text to show when we are using a contextplus driver. */
    cdCanvasSetForeground(canvas, CD_RED);
    if contextplus then
        rect = wdCanvasGetVectorTextBounds(canvas, "WDj-Plus", 0.25, 0.35)
    else
        rect = wdCanvasGetVectorTextBounds(canvas, "WDj", 0.25, 0.35)
    end if
    cdCanvasBegin(canvas, CD_CLOSED_LINES);
-->
    wdCanvasVertex(canvas, rect[0+1], rect[1+1]);
    wdCanvasVertex(canvas, rect[2+1], rect[3+1]);
    wdCanvasVertex(canvas, rect[4+1], rect[5+1]);
    wdCanvasVertex(canvas, rect[6+1], rect[7+1]);
    cdCanvasEnd(canvas);

    cdCanvasSetLineWidth(canvas, 2);
    cdCanvasSetLineStyle(canvas, CD_CONTINUOUS);
    if contextplus then
-->
        wdCanvasVectorText(canvas, 0.25, 0.35, "WDj-Plus");
    else
        wdCanvasVectorText(canvas, 0.25, 0.35, "WDj");
    end if
    cdCanvasSetLineWidth(canvas, 1);

  /* Draw a filled path at center-right (looks like a weird fish). 
     Notice that in PDF the arc is necessarily a circle arc, and not an ellipse. */
    cdCanvasSetForeground(canvas, CD_GREEN);
    cdCanvasBegin(canvas, CD_PATH);
-->
    cdCanvasPathSet(canvas, CD_PATH_MOVETO);
    cdCanvasVertex(canvas, w/2+200, h/2);
    cdCanvasPathSet(canvas, CD_PATH_LINETO);
    cdCanvasVertex(canvas, w/2+230, h/2+50);
    cdCanvasPathSet(canvas, CD_PATH_LINETO);
    cdCanvasVertex(canvas, w/2+250, h/2+50);
    cdCanvasPathSet(canvas, CD_PATH_CURVETO);
    cdCanvasVertex(canvas, w/2+150+150, h/2+200-50); /* control point for start */
    cdCanvasVertex(canvas, w/2+150+180, h/2+250-50); /* control point for end */
    cdCanvasVertex(canvas, w/2+150+180, h/2+200-50); /* end point */
    cdCanvasPathSet(canvas, CD_PATH_CURVETO);
    cdCanvasVertex(canvas, w/2+150+180, h/2+150-50);
    cdCanvasVertex(canvas, w/2+150+150, h/2+100-50);
    cdCanvasVertex(canvas, w/2+150+300, h/2+100-50);
    cdCanvasPathSet(canvas, CD_PATH_LINETO);
    cdCanvasVertex(canvas, w/2+150+300, h/2-50);
    cdCanvasPathSet(canvas, CD_PATH_ARC);
    cdCanvasVertex(canvas, w/2+300, h/2);  /* center */
    cdCanvasVertex(canvas, 200, 100);  /* width, height */
    cdCanvasVertex(canvas, -30*1000, -170*1000);    /* start angle, end angle (degrees / 1000) */
--  cdCanvasPathSet(canvas, CD_PATH_CLOSE);
--  cdCanvasPathSet(canvas, CD_PATH_STROKE);
--  cdCanvasPathSet(canvas, CD_PATH_FILL);
    cdCanvasPathSet(canvas, CD_PATH_FILLSTROKE);
    cdCanvasEnd(canvas);

  /* Draw 3 pixels at center left. */
    cdCanvasPixel(canvas, 10, h/2+0, CD_RED);
    cdCanvasPixel(canvas, 11, h/2+1, CD_GREEN);
    cdCanvasPixel(canvas, 12, h/2+2, CD_BLUE);

  /* Draw 4 mark types, distributed near each corner.  */
    cdCanvasSetForeground(canvas, CD_RED);
    {} = cdCanvasMarkSize(canvas, 30);
    {} = cdCanvasMarkType(canvas, CD_PLUS);
    cdCanvasMark(canvas, 200, 200);
    {} = cdCanvasMarkType(canvas, CD_CIRCLE);
    cdCanvasMark(canvas, w-200, 200);
    {} = cdCanvasMarkType(canvas, CD_HOLLOW_CIRCLE);
    cdCanvasMark(canvas, 200, h-200);
    {} = cdCanvasMarkType(canvas, CD_DIAMOND);
    cdCanvasMark(canvas, w-200, h-200);

  /* Draw all the line style possibilities at bottom. 
     Notice that they have some small differences between drivers. */
    cdCanvasSetLineWidth(canvas, 1);
    cdCanvasSetLineStyle(canvas, CD_CONTINUOUS);
    cdCanvasLine(canvas, 0, 10, w, 10);
    cdCanvasSetLineStyle(canvas, CD_DASHED);
    cdCanvasLine(canvas, 0, 20, w, 20);
    cdCanvasSetLineStyle(canvas, CD_DOTTED);
    cdCanvasLine(canvas, 0, 30, w, 30);
    cdCanvasSetLineStyle(canvas, CD_DASH_DOT);
    cdCanvasLine(canvas, 0, 40, w, 40);
    cdCanvasSetLineStyle(canvas, CD_DASH_DOT_DOT);
    cdCanvasLine(canvas, 0, 50, w, 50);

  /* Draw all the hatch style possibilities in the top-left corner.
     Notice that they have some small differences between drivers. */
    cdCanvasSetHatch(canvas, CD_VERTICAL);
    cdCanvasBox(canvas, 0, 50, h-60, h);
    cdCanvasSetHatch(canvas, CD_FDIAGONAL);
    cdCanvasBox(canvas, 50, 100, h-60, h);
    cdCanvasSetHatch(canvas, CD_BDIAGONAL);
    cdCanvasBox(canvas, 100, 150, h-60, h);
    cdCanvasSetHatch(canvas, CD_CROSS);
    cdCanvasBox(canvas, 150, 200, h-60, h);
    cdCanvasSetHatch(canvas, CD_HORIZONTAL);
    cdCanvasBox(canvas, 200, 250, h-60, h);
    cdCanvasSetHatch(canvas, CD_DIAGCROSS);
    cdCanvasBox(canvas, 250, 300, h-60, h);

  /* Draw 4 regions, in diamond shape,
     at top, bottom, left, right, 
     using different interior styles. */

  /* At top, not filled polygon, notice that the last line style is used. */
    cdCanvasBegin(canvas, CD_CLOSED_LINES);
    cdCanvasVertex(canvas, w/2, h-100);
    cdCanvasVertex(canvas, w/2+50, h-150);
    cdCanvasVertex(canvas, w/2, h-200);
    cdCanvasVertex(canvas, w/2-50, h-150);
    cdCanvasEnd(canvas);

  /* At left, hatch filled polygon */
    cdCanvasSetHatch(canvas, CD_DIAGCROSS);
    cdCanvasBegin(canvas, CD_FILL);
    cdCanvasVertex(canvas, 100, h/2);
    cdCanvasVertex(canvas, 150, h/2+50);
    cdCanvasVertex(canvas, 200, h/2);
    cdCanvasVertex(canvas, 150, h/2-50);
    cdCanvasEnd(canvas);

  /* At right, pattern filled polygon */
    cdCanvasSetPattern(canvas, STYLE_SIZE, STYLE_SIZE, pattern);
    cdCanvasBegin(canvas, CD_FILL);
    cdCanvasVertex(canvas, w-100, h/2);
    cdCanvasVertex(canvas, w-150, h/2+50);
    cdCanvasVertex(canvas, w-200, h/2);
    cdCanvasVertex(canvas, w-150, h/2-50);
    cdCanvasEnd(canvas);

  /* At bottom, stipple filled polygon */
-->
    cdCanvasSetStipple(canvas, STYLE_SIZE, STYLE_SIZE, stipple);
    cdCanvasBegin(canvas, CD_FILL);
    cdCanvasVertex(canvas, w/2, 100);
    cdCanvasVertex(canvas, w/2+50, 150);
    cdCanvasVertex(canvas, w/2, 200);
    cdCanvasVertex(canvas, w/2-50, 150);
    cdCanvasEnd(canvas);

  /* Draw two beziers at bottom-left */
    cdCanvasBegin(canvas, CD_BEZIER);
    cdCanvasVertex(canvas, 100, 100);
    cdCanvasVertex(canvas, 150, 200);
    cdCanvasVertex(canvas, 180, 250);
    cdCanvasVertex(canvas, 180, 200);
    cdCanvasVertex(canvas, 180, 150);
    cdCanvasVertex(canvas, 150, 100);
    cdCanvasVertex(canvas, 300, 100);
    cdCanvasEnd(canvas);

  /* Initialize the image buffer contents */
-->>
    red = repeat('\0',IMAGE_SIZE*IMAGE_SIZE)
    green = repeat('\0',IMAGE_SIZE*IMAGE_SIZE)
    blue = repeat('\0',IMAGE_SIZE*IMAGE_SIZE)
    red[IMAGE_SIZE+1..IMAGE_SIZE*IMAGE_SIZE/2] = '\xFF'
    red[IMAGE_SIZE*IMAGE_SIZE/2+1..(IMAGE_SIZE-1)*IMAGE_SIZE] = '\x5F'
    green[IMAGE_SIZE+1..IMAGE_SIZE*IMAGE_SIZE/2] = '\x5F'
    green[IMAGE_SIZE*IMAGE_SIZE/2+1..(IMAGE_SIZE-1)*IMAGE_SIZE] = '\x8F'
    blue[IMAGE_SIZE+1..IMAGE_SIZE*IMAGE_SIZE/2] = '\x5F'
    blue[IMAGE_SIZE*IMAGE_SIZE/2+1..(IMAGE_SIZE-1)*IMAGE_SIZE] = '\x5F'
--  green = repeat('\x5F',IMAGE_SIZE*IMAGE_SIZE/2)&repeat('\x8F',(IMAGE_SIZE-1)*IMAGE_SIZE/2)&repeat('\0',IMAGE_SIZE)
--  blue = repeat('\x5F',IMAGE_SIZE*IMAGE_SIZE/2)&repeat('\x5F',(IMAGE_SIZE-1)*IMAGE_SIZE/2)&repeat('\0',IMAGE_SIZE)
--  memset(red, 0xFF, IMAGE_SIZE*IMAGE_SIZE/2);
--  memset(green, 0x5F, IMAGE_SIZE*IMAGE_SIZE/2);
--  memset(blue, 0x5F, IMAGE_SIZE*IMAGE_SIZE/2);
--  memset(red+IMAGE_SIZE*IMAGE_SIZE/2, 0x5F, IMAGE_SIZE*IMAGE_SIZE/2);
--  memset(green+IMAGE_SIZE*IMAGE_SIZE/2, 0x8F, IMAGE_SIZE*IMAGE_SIZE/2);
--  memset(blue+IMAGE_SIZE*IMAGE_SIZE/2, 0x5F, IMAGE_SIZE*IMAGE_SIZE/2);
--  memset(red+IMAGE_SIZE*(IMAGE_SIZE-1), 0, IMAGE_SIZE);
--  memset(green+IMAGE_SIZE*(IMAGE_SIZE-1), 0, IMAGE_SIZE);
--  memset(blue+IMAGE_SIZE*(IMAGE_SIZE-1), 0, IMAGE_SIZE);
--  memset(red, 0, IMAGE_SIZE);
--  memset(green, 0, IMAGE_SIZE);
--  memset(blue, 0, IMAGE_SIZE);
    for i=1 to IMAGE_SIZE do
        integer offset = (i-1)*IMAGE_SIZE+1;
        red[offset] = 0;
        green[offset] = 0;
        blue[offset] = 0;
        red[offset+IMAGE_SIZE-1] = 0;
        green[offset+IMAGE_SIZE-1] = 0;
        blue[offset+IMAGE_SIZE-1] = 0;
    end for

    --PL:
    alpha  = alpha[1..IMAGE_SIZE*IMAGE_SIZE]

--  cdSetAttribute("ANTIALIAS", "0");
--  cdGetImageRGB(red, green, blue, w/2 - 50, h/2-50, 100, 100);
--  cdPutImageRectRGB(14, 13, red, green, blue, -20, -15, 649, 603, 0, 13, 0, 12);
--  cdPutImageRectRGB(16, 16, red, green, blue, 10, 10, 608, 608, 5, 10, 5, 10);
--  cdPutImageRectRGB(16, 16, red, green, blue, 10, 10, 64, 64, 5, 10, 5, 10);

--  cdPutImageRGB(IMAGE_SIZE, IMAGE_SIZE, red, green, blue, 100, h - 200, IMAGE_SIZE, IMAGE_SIZE);
--  cdPutImageRGBA(IMAGE_SIZE, IMAGE_SIZE, red, green, blue, alpha, 100, h - 200, IMAGE_SIZE, IMAGE_SIZE);
--  cdPutImageRGB(IMAGE_SIZE, IMAGE_SIZE, red, green, blue, w - 400, h - 310, 3*IMAGE_SIZE, 3*IMAGE_SIZE);
  /* Draw the image on the top-right corner but increasing its actual size, and uses its full area */
-->
    cdCanvasPutImageRectRGBA(canvas, IMAGE_SIZE, IMAGE_SIZE, {red, green, blue, alpha}, w-400, h-310, 3*IMAGE_SIZE, 3*IMAGE_SIZE, 0, 0, 0, 0);
--global procedure cdCanvasPutImageRectRGB A(cdCanvas hCdCanvas, atom iw, atom ih, sequence rgba, atom x, atom y,
--                                        atom w, atom h, atom xmin, atom xmax, atom ymin, atom ymax)


    cdCanvasSetAttribute(canvas, "ROTATE", NULL);
    if use_transform then
        cdCanvasTransform(canvas, NULL);
    end if
    {} = cdCanvasClip(canvas, CD_CLIPOFF);

  /* Adds a new page, or 
     flushes the file, or
     flushes the screen, or
     swap the double buffer. */
    cdCanvasFlush(canvas);
end procedure

procedure SimpleFlush()
    IupGLSwapBuffers(SimpleCanvas)
end procedure

procedure SimpleDraw(cdCanvas canvas)
    if use_opengl then
        SimpleUpdateSize(canvas);
    end if

    if (simple_draw==DRAW_TEXTFONTS) then
        SimpleDrawTextFonts(canvas);
    elsif (simple_draw==DRAW_TEXTALIGN) then
        SimpleDrawTextAlign(canvas);
    elsif (simple_draw==DRAW_TEST) then
        SimpleDrawTest(canvas);
    else
        SimpleDrawAll(canvas);
    end if

    cdCanvasFlush(canvas);

    if use_opengl then
        SimpleFlush();
    end if
end procedure

function SimpleInitAlpha(int width, int height, string _alpha)
/* initialize the alpha image buffer with a degrade from transparent to opaque */
    for l=0 to height-1 do
        for c=0 to width-1 do
            _alpha[l*width+c+1] = and_bits(floor((c*255)/(width-1)),#FF)
        end for
    end for
    return _alpha
end function

procedure SimpleCreateCanvasWindow()
  /* creates the canvas based in an existing window */
    if contextplus then cdUseContextPlus(1) end if
    winCanvas = cdCreateCanvas(CD_IUP, winData);
    if winCanvas=NULL then ?9/0 end if
    if contextplus then cdUseContextPlus(0) end if
    curCanvas = winCanvas
end procedure

procedure SimpleDrawWindow()
    use_opengl = 0;
    curCanvas = winCanvas;
--  if curCanvas!=NULL then --PL ??
        SimpleDraw(curCanvas);
--  end if
end procedure
constant r_SimpleDrawWindow = routine_id("SimpleDrawWindow")

procedure SimpleCreateCanvas(atom_string data)
int c, l;

    pattern = repeat(0xFF,STYLE_SIZE*STYLE_SIZE)

    pattern[11+1] = CD_RED; /*------------*/
    pattern[21+1] = CD_RED; /*  0123456789*/
    pattern[31+1] = CD_RED; /*          */
    pattern[41+1] = CD_RED; /*9 WWWWWWWWWW*/
    pattern[51+1] = CD_RED; /*8 WWWWGGGGGW*/
    pattern[12+1] = CD_RED; /*7 WWWGGGGGBW*/
    pattern[22+1] = CD_RED; /*6 WWGGGGGBBW*/
    pattern[32+1] = CD_RED; /*5 WrrrrrBBBW*/
    pattern[42+1] = CD_RED; /*4 WrrrrrBBBW*/
    pattern[52+1] = CD_RED; /*3 WrrrrrBBWW*/
    pattern[13+1] = CD_RED; /*2 WrrrrrBWWW*/
    pattern[23+1] = CD_RED; /*1 WrrrrrWWWW*/
    pattern[33+1] = CD_RED; /*0 WWWWWWWWWW*/
    pattern[43+1] = CD_RED; /*------------*/
    pattern[53+1] = CD_RED;
    pattern[14+1] = CD_RED; pattern[15+1] = CD_RED;
    pattern[24+1] = CD_RED; pattern[25+1] = CD_RED;
    pattern[34+1] = CD_RED; pattern[35+1] = CD_RED;
    pattern[44+1] = CD_RED; pattern[45+1] = CD_RED;
    pattern[54+1] = CD_RED; pattern[55+1] = CD_RED;

    pattern[26+1] = CD_BLUE;    pattern[37+1] = CD_BLUE;
    pattern[36+1] = CD_BLUE;    pattern[47+1] = CD_BLUE;
    pattern[46+1] = CD_BLUE;    pattern[57+1] = CD_BLUE;
    pattern[56+1] = CD_BLUE;    pattern[67+1] = CD_BLUE;

    pattern[48+1] = CD_BLUE;    pattern[62+1] = CD_GREEN;
    pattern[58+1] = CD_BLUE;    pattern[63+1] = CD_GREEN;
    pattern[68+1] = CD_BLUE;    pattern[64+1] = CD_GREEN;
    pattern[78+1] = CD_BLUE;    pattern[65+1] = CD_GREEN;
    pattern[66+1] = CD_GREEN;

    pattern[73+1] = CD_GREEN; pattern[84+1] = CD_GREEN;
    pattern[74+1] = CD_GREEN; pattern[85+1] = CD_GREEN;
    pattern[75+1] = CD_GREEN; pattern[86+1] = CD_GREEN;
    pattern[76+1] = CD_GREEN; pattern[87+1] = CD_GREEN;
    pattern[77+1] = CD_GREEN; pattern[88+1] = CD_GREEN;

  /* initialize the stipple buffer with cross pattern */
    for l=0 to STYLE_SIZE-1 do
        for c=0 to STYLE_SIZE-1 do
            stipple[l*STYLE_SIZE+c+1] = iff(mod(c,4)==0? 1: 0)
        end for
    end for
    alpha = SimpleInitAlpha(IMAGE_BUFFER_SIZE, IMAGE_BUFFER_SIZE, alpha)

    winData = data;
    SimpleCreateCanvasWindow();
    SimpleDrawWindow();
end procedure

procedure SimpleTransform()
    use_transform = not use_transform;
    SimpleDraw(curCanvas);
end procedure
constant r_SimpleTransform = routine_id("SimpleTransform")

procedure SimpleKillCanvas()

    if dbCanvas!=NULL then
        cdKillCanvas(dbCanvas)
        dbCanvas = NULL
    end if
    if winCanvas!=NULL then
        cdKillCanvas(winCanvas)
        winCanvas = NULL
    end if
end procedure

procedure SimpleContextPlus()
    contextplus = not contextplus;
    SimpleKillCanvas();
    SimpleCreateCanvasWindow();
    SimpleDraw(curCanvas);
end procedure
constant r_SimpleContextPlus = routine_id("SimpleContextPlus")

procedure PlayCanvasDriver(cdContext ctx, atom_string StrData)

    cdCanvasActivate(curCanvas);
    cdCanvasSetBackground(curCanvas, CD_WHITE);
    cdCanvasClear(curCanvas);
    int {w, h} = cdCanvasGetSize(curCanvas)
    {} = cdCanvasPlay(curCanvas, ctx, 100, w-100, 100, h-100, StrData);
--  {} = cdCanvasPlay(curCanvas, ctx, 0, 0, 0, 0, StrData);
end procedure
constant r_PlayCanvasDriver = routine_id("PlayCanvasDriver")


function SimpleRepaint()    -- ih,x,y)?
    if curCanvas!=NULL then -- PL(??)
        SimpleDraw(curCanvas)
    end if
    return IUP_DEFAULT
end function
constant cb_SimpleRepaint = Icallback("SimpleRepaint")

procedure DrawCanvasDriver(cdContext ctx, string StrData)
    if contextplus then cdUseContextPlus(1) end if
    cdCanvan tmpCanvas = cdCreateCanvas(ctx, StrData)
    if contextplus then cdUseContextPlus(0) end if
    if tmpCanvas==NULL then
        printf(1, "CreateCanvas(%s) - Failed!\n", StrData);
        return
    end if
    printf(1,"CreateCanvas(%s)\n", StrData);
    SimpleDraw(tmpCanvas);
    cdKillCanvas(tmpCanvas);
    printf(1,"KillCanvas()\n");
end procedure
constant r_DrawCanvasDriver = routine_id("DrawCanvasDriver")

procedure DrawCanvasDriverSize(cdContext ctx, string name, integer pixels)
string StrData
integer w, h
atom w_mm, h_mm
    {w, h, w_mm, h_mm} = cdCanvasGetSize(curCanvas)
    if pixels==1 then
        StrData = sprintf("%s %dx%d", {name, w, h})
    elsif pixels==2 then
        StrData = sprintf("%s -w%g -h%g -s%g", {name, w_mm, h_mm, (w/w_mm)*25.4})
    else
        StrData = sprintf("%s %gx%g %g", {name, w_mm, h_mm, w/w_mm})
    end if
    DrawCanvasDriver(ctx, StrData)
end procedure
constant r_DrawCanvasDriverSize = routine_id("DrawCanvasDriverSize")

procedure DrawCanvasDriverSizeParam(cdContext ctx, string param)
int {w, h} = cdCanvasGetSize(curCanvas)
string StrData = sprintf("%dx%d %s", {w, h, param})
    DrawCanvasDriver(ctx, StrData)
end procedure
constant r_DrawCanvasDriverSizeParam = routine_id("DrawCanvasDriverSizeParam")

procedure SimpleMode(integer m)
    write_mode = m
    SimpleDraw(curCanvas)
end procedure
constant r_SimpleMode = routine_id("SimpleMode")

procedure SimpleClipping(integer c)
    clipping = c
    SimpleDraw(curCanvas);
end procedure
constant r_SimpleClipping = routine_id("SimpleClipping")

procedure Simple(integer d)
    simple_draw = d
--  if curCanvas!=NULL then -- PL??
        SimpleDraw(curCanvas);
--  end if
end procedure
constant r_Simple = routine_id("Simple")

procedure SimpleDrawImage()

    use_opengl = 0;
    if dbCanvas!=NULL then cdKillCanvas(dbCanvas) end if

    if contextplus then cdUseContextPlus(1) end if
    dbCanvas = cdCreateCanvas(CD_DBUFFER, winCanvas);
    if contextplus then cdUseContextPlus(0) end if

    curCanvas = dbCanvas;
    SimpleDraw(curCanvas);

end procedure
constant r_SimpleDrawImage = routine_id("SimpleDrawImage")

procedure SimpleDrawImageRGB()

    use_opengl = 0;
    if dbCanvas then cdKillCanvas(dbCanvas) end if

    if contextplus then cdUseContextPlus(1) end if
    dbCanvas = cdCreateCanvas(CD_DBUFFERRGB, winCanvas)
    if contextplus then cdUseContextPlus(0) end if

    curCanvas = dbCanvas
    SimpleDraw(curCanvas)

end procedure
constant r_SimpleDrawImageRGB = routine_id("SimpleDrawImageRGB")

--#ifdef USE_OPENGL
procedure SimpleDrawGL()

int w, h;
atom w_mm, h_mm;

    if not use_opengl then

        {w, h, w_mm, h_mm} = cdCanvasGetSize(curCanvas)

        string StrData = sprintf("%dx%d %g", {w, h, (w/w_mm)});

        if dbCanvas!=NULL then cdKillCanvas(dbCanvas) end if

        dbCanvas = cdCreateCanvas(CD_GL, StrData)

        curCanvas = dbCanvas;
        use_opengl = 1;
        SimpleDraw(curCanvas);
    end if
end procedure
constant r_SimpleDrawGL = routine_id("SimpleDrawGL")
--#endif

procedure SimpleDrawSimulate()

    simulate = not simulate;

    if simulate then
        {} = cdCanvasSimulate(curCanvas, CD_SIM_ALL);
    else
        {} = cdCanvasSimulate(curCanvas, CD_SIM_NONE);
    end if

    SimpleDraw(curCanvas);

end procedure
constant r_SimpleDrawSimulate = routine_id("SimpleDrawSimulate")

--#if 0
--/*
void draw_wd(void)
{
  char* text;
  double x, y;
  double rect[8];

  cdBackground(CD_WHITE);
  cdClear();
  cdLineStyle(CD_CONTINUOUS);
  cdLineWidth(1);

--  wdVectorTextDirection(0, 0, 1, 1);
  cdTextAlignment(CD_NORTH_WEST);

--  text = "Vector Text";
  text = "Vector Text\nSecond Line\nThird Line";
  x = 0.25;
  y = 0.40;

  cdForeground(CD_BLACK);
  wdLine(0, 0, 1, 1);
  wdLine(0, 1, 1, 0);

  cdForeground(CD_GREEN);
  cdMarkType(CD_STAR);
  wdMark(x, y);

  cdForeground(CD_BLUE);
  wdVectorCharSize(0.1);
  wdVectorText(x, y, text);

  cdForeground(CD_RED);
  wdGetVectorTextBounds(text, x, y, rect);
  cdBegin(CD_CLOSED_LINES);
  wdVertex(rect[0], rect[1]);
  wdVertex(rect[2], rect[3]);
  wdVertex(rect[4], rect[5]);
  wdVertex(rect[6], rect[7]);
  cdEnd();
}

--void SimpleDrawTest(cdCanvas* canvas)
void SimpleDrawTestHardCopy(cdCanvas* canvas)
{
  int w, h;
  cdGetCanvasSize(&w, &h, 0, 0);
  
  wdViewport(0,w-1,0,h-1);
  if (w>h)
    wdWindow(0,w/h,0,1);
  else
    wdWindow(0,1,0,h/w);

  draw_wd();

  --wdHardcopy(CD_CLIPBOARD, "800x600", cdActiveCanvas(), draw_wd );
}

--void SimpleDrawTest(cdCanvas* canvas)
void SimpleDrawTestImageRGB(cdCanvas* canvas)
{
  int size = 2048*2048;
  unsigned char *red, *green, *blue;
  cdCanvas* canvas = cdCreateCanvas(CD_IMAGERGB, "2048x2048");
  cdActivate(canvas);

  red = calloc(size, 1);
  green = calloc(size, 1);
  blue = calloc(size, 1);

  cdPutImageRectRGB(2048, 2048, red, green, blue, 0, 3, 2048, 2017, 0, 2047, 3, 2020);

  free(red);
  free(green);
  free(blue);

  cdKillCanvas(canvas);
}

--void SimpleDrawTest(cdCanvas* canvas)
void SimpleDrawVectorFont(cdCanvas* canvas)
{
  cdBackground(CD_WHITE);
  cdClear();
  cdLineStyle(CD_CONTINUOUS);
  cdLineWidth(1);

--  wdVectorText(0.1, 0.4, "    ");
--  wdVectorText(0.1, 0.2, "     ");
  cdVectorFont("../etc/vectorfont26.txt"); /* original Simplex II */
  {
    int i;
    char t[2];
    char s[10];
    int x = 10;
    int y = 600;
    t[1] = 0;
  cdFont(CD_COURIER, CD_BOLD, 14);
  cdVectorCharSize(25);
    for (i = 128; i < 256; i++)
    {
      int dx = 30;
      t[0] = (char)i;
      sprintf(s, "%3d", i);
      cdForeground(CD_DARK_RED);
      cdText(x, y, s);
--      cdText(x+dx, y, t);
      cdForeground(CD_BLACK);
      cdVectorText(x+2*dx-10, y, t);
      
      x += 3*dx;
      if ((i+1) % 8 == 0)
      {
        x = 10;
        y -= 30;
      }
    }
  --cdFont(CD_TIMES_ROMAN, CD_PLAIN, 24);
  --cdVectorCharSize(24);
  --  for (i = 192; i < 256; i++)
  --  {
  --    int dx = 92;
  --    t[0] = (char)i;
  --    sprintf(s, "%d", i);
  --    cdText(x, y, s);
  --    cdText(x+dx, y, t);
  --    cdVectorText(x+2*dx, y, t);
  --    
  --    x += 3*dx + 2*dx/3;
  --    if ((i+1) % 4 == 0)
  --    {
  --      x = 30;
  --      y += 52;
  --    }
  --  }
  }
}

--void SimpleDrawTest(cdCanvas* canvas)
void SimpleDrawPoly(cdCanvas* canvas)
{
  int w, h;
  cdGetCanvasSize(&w, &h, 0, 0);

  cdBackground(CD_WHITE);
  cdClear();

  --cdSetAttribute("ANTIALIAS", "0");
  cdForeground(cdEncodeAlpha(cdEncodeColor(255, 0, 0), 100));

  cdfCanvasArc(cdActiveCanvas(), 255, 255, 100, 100, 0, 360);

  cdLine(0, 0, 200, 200);

  cdBegin(CD_BEZIER);
  cdVertex(100, 100); 
  cdVertex(150, 200); 
  cdVertex(180, 250); 
  cdVertex(180, 200); 
  cdVertex(180, 150); 
  cdVertex(150, 100); 
  cdVertex(300, 100); 
  cdEnd();


  cdEnd();
}
--*/
--#endif

function cmdExit()
    return IUP_CLOSE
end function
constant r_cmdExit = Icallback("cmdExit")

sequence m_rids = {},
         m_args = {}

function menu_handler(Ihandle ih)
string title = IupGetAttribute(ih,"TITLE")  -- debug aid (why not)
integer mdx = IupGetInt(ih,"MDX")
integer rid = m_rids[mdx]
sequence args = m_args[mdx]
    call_proc(rid,args)
    return IUP_DEFAULT
end function
constant cb_menu_handler = Icallback("menu_handler")

function menu_item(string title, integer rid, sequence args)
Ihandle mitem = IupMenuItem(title,cb_menu_handler)
    m_rids = append(m_rids,rid)
    m_args = append(m_args,args)
    integer mdx = length(m_rids)
    IupSetInt(mitem,"MDX",mdx)
    return mitem
end function

procedure simple_loadled()

Ihandle mnOpen = IupMenu({menu_item("CGM - Binary", r_PlayCanvasDriver, {CD_CGM, "simple_b.cgm"}),
                          menu_item("CGM - Text",   r_PlayCanvasDriver, {CD_CGM, "simple_t.cgm"}),
                          menu_item("METAFILE",     r_PlayCanvasDriver, {CD_METAFILE, "simple.mf"}),
                          menu_item("WMF",          r_PlayCanvasDriver, {CD_WMF, "simple.wmf"}),
                          menu_item("EMF",          r_PlayCanvasDriver, {CD_EMF, "simple.emf"})})
Ihandle mnSaveAs = IupMenu({menu_item("DEBUG",          r_DrawCanvasDriverSize, {CD_DEBUG, "simple_debug.txt", 0}),
                            menu_item("CGM - Binary",   r_DrawCanvasDriverSize, {CD_CGM, "simple_b.cgm", 0}),
                            menu_item("CGM - Text",     r_DrawCanvasDriverSize, {CD_CGM, "simple_t.cgm -t", 0}),
                            menu_item("DGN",            r_DrawCanvasDriverSize, {CD_DGN, "simple.dgn", 0}),
                            menu_item("DXF",            r_DrawCanvasDriverSize, {CD_DXF, "simple.dxf", 0}),
                            menu_item("EMF",            r_DrawCanvasDriverSize, {CD_EMF, "simple.emf", 1}),
                            menu_item("METAFILE",       r_DrawCanvasDriverSize, {CD_METAFILE, "simple.mf", 0}),
--                          menu_item("PDF",            r_DrawCanvasDriverSize, {CD_PDF, "simple.pdf", 2}),
                            menu_item("PS",             r_DrawCanvasDriverSize, {CD_PS, "simple.ps -l0 -r0 -t0 -b0", 2}),
                            menu_item("EPS",            r_DrawCanvasDriverSize, {CD_PS, "simple.eps -e", 2}),
                            menu_item("SVG",            r_DrawCanvasDriverSize, {CD_SVG, "simple.svg", 0}),
                            menu_item("WMF",            r_DrawCanvasDriverSize, {CD_WMF, "simple.wmf", 1})})
Ihandle mnFile = IupMenu({IupSubmenu("Open", mnOpen),
                          IupSubmenu("Save As", mnSaveAs),
                          IupSeparator(),
                          menu_item("Print",            r_DrawCanvasDriver, {CD_PRINTER, "simple print"}),
                          menu_item("Print Dialog...",  r_DrawCanvasDriver, {CD_PRINTER, "simple -d"}),
                          IupSeparator(),
                          IupMenuItem("Exit", r_cmdExit)})
Ihandle mnEdit = IupMenu({menu_item("Copy as Metafile", r_DrawCanvasDriverSizeParam, {CD_CLIPBOARD, "-m"}),
                          menu_item("Copy as EMF",      r_DrawCanvasDriverSizeParam, {CD_CLIPBOARD, ""}),
                          menu_item("Copy as Bitmap",   r_DrawCanvasDriverSizeParam, {CD_CLIPBOARD, "-b"}),
                          menu_item("Paste",            r_PlayCanvasDriver, {CD_CLIPBOARD, NULL})})
Ihandle mnClipping = IupMenu({menu_item("Off",      r_SimpleClipping, {CD_CLIPOFF}),
                              menu_item("Area",     r_SimpleClipping, {CD_CLIPAREA}),
                              menu_item("Polygon",  r_SimpleClipping, {CD_CLIPPOLYGON}),
                              menu_item("Region",   r_SimpleClipping, {CD_CLIPREGION})})
Ihandle mnWriteMode = IupMenu({menu_item("Replace", r_SimpleMode, {CD_REPLACE}),
                               menu_item("Xor",     r_SimpleMode, {CD_XOR}),
                               menu_item("Not Xor", r_SimpleMode, {CD_NOT_XOR})})
Ihandle mnOptions = IupMenu({IupSubmenu("Clipping", mnClipping),
                             IupSubmenu("Write Mode", mnWriteMode),
                             menu_item("Simulate",      r_SimpleDrawSimulate, {}),
                             menu_item("Transform",     r_SimpleTransform, {}),
                             menu_item("Context Plus",  r_SimpleContextPlus, {})})
Ihandle mnSurface = IupMenu({menu_item("Window",        r_SimpleDrawWindow, {}),
                             menu_item("Server Image",  r_SimpleDrawImage, {}),
                             menu_item("Image RGB",     r_SimpleDrawImageRGB, {}),
                             menu_item("OpenGL",        r_SimpleDrawGL, {})})
Ihandle mnPrimitives = IupMenu({menu_item("All",        r_Simple, {DRAW_ALL}),
                                menu_item("Text Align", r_Simple, {DRAW_TEXTALIGN}),
                                menu_item("Text Fonts", r_Simple, {DRAW_TEXTFONTS}),
                                menu_item("Test",       r_Simple, {DRAW_TEST})})
Ihandle mnSimpleMenu = IupMenu({IupSubmenu("File", mnFile),
                                IupSubmenu("Edit", mnEdit),
                                IupSubmenu("Options", mnOptions),
                                IupSubmenu("Surface", mnSurface),
                                IupSubmenu("Primitives", mnPrimitives)})
--  SimpleCanvas = IupCanvas(cb_SimpleRepaint, "BORDER=0")
    SimpleCanvas = IupGLCanvas(cb_SimpleRepaint, "BORDER=0")
    SimpleDialog = IupDialog(SimpleCanvas)
    IupSetAttribute(SimpleDialog, "TITLE", "Simple Draw")
--  IupSetHandle(SimpleDialog, "MENU", mnSimpleMenu)
    IupSetAttributeHandle(SimpleDialog,"MENU",mnSimpleMenu)
    IupCloseOnEscape(SimpleDialog)
end procedure

procedure main()

    IupOpen()
    IupSetGlobal("UTF8MODE","Yes")
    cdInitContextPlus();

    simple_loadled()

--  IupSetAttribute(SimpleDialog, "PLACEMENT", "MAXIMIZED");
    IupSetAttribute(SimpleDialog, "SIZE", "850x400");
    IupShow(SimpleDialog);

    SimpleCreateCanvas(SimpleCanvas);

    SimpleDrawWindow()

    SimpleUpdateSize(NULL);
    IupUpdate(SimpleCanvas)

    IupMainLoop();

    SimpleKillCanvas()

    IupClose()

end procedure

main()

