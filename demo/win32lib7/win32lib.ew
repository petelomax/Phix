--/makedoc title Documentation for Win32lib v0.70.3
--/topic introduction
--/i "see also:" /"General Info"
--/code
--------------------NOTICE-------------------------------*
-- Software ID: win32lib
-- Version:     0.70.4a 17/June/2008 (Phix compatible)
-- Copyright:   (c) 2000 /"David Cuny" and friends
--              All rights reserved.
-- Licence:
-- This software is provided 'as-is', without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from
-- the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictictions:
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software.
-- 2. If you use this software in a product, acknowedgement in the product's
--    documenation and binary are required.
-- 3. Altered source versions, and works substantially derived from the it,
--    must...
--   a) be plainly be marked as such,
--   b) not be misrepresented as the original software,
--   c) include this notice, unaltered.
--------------------End of NOTICE------------------------*
--/endcode
--#withtype w32string

-- when a toolbar was subclassed, a problem arises when inserting a new item with an image, since
-- the image lists may not be the same. However, the library doesn't provide a wrapper for using the TB_ADDBITMAP message, so this should be ok.

--/topic Authors
--/info
--A bit of background on the authors of this library.
--
--/bm "David Cuny" /n
--David originally wrote Win32lib in an attempt to create a platform independant
-- GUI add-on for Euphoria.
--
--/bm "Matthew Lewis" /n
--Matthew implemented most of the common Windows controls
--
--/bm "Derek Parnell" /n
--Derek has acted as custodian once David could no longer concentrate on the library.
-- Since then he has reorganised the code and implemented improvements
-- based on submissions from the many users of the library.
--
--/bm "Christian Cuvier" /n
--Christian has been changing and repairing the library since 2006.
--
--/topic General Info
--/info
-- Some background and historical notes about win32lib.
-- The library was originally developed by /"David Cuny", and over time, a
-- number of other people have made additions and corrections. Where
-- appropriate the work that other people have contributed is marked thus...
--/code
--     -- Begin ~<person's name>~
--     -- End   ~<person's name>~
--/endcode
-- This library provides access to the /i"Window32 API" from a fairly high
-- level, hiding most of the guts from the user.
--
--See also: /lit'<a href="win32geninfo.html">Further Information</a>' /n
--See Also: /lit'<a href="http://euwiki.ayo.biz/Category:Win32lib">articles on win32lib, which may be considered as an alternate documentation</a>'

--/topic Frequently Asked Questions
--/info
-- Questions and Answers that are often sought by new comers to Win32lib.
-- This section contains the answers to many questions that beginners have.
--Details in /lit'<a href="w32faq.htm">Win32Lib FAQ</a>'

---/topic Known Bugs
-- Okay, so not everything is perfect. At least we admit it!
-- The following are known bugs. They will probably be fixed before the next major release.
--/define
--/term Bug
-- Undocumented feature.
--/term Feature
-- Documented bug.
--/enddefine
-- quoted from EuForum, Don Cole's signature.

--/makedoc insert ..\include\options.e
--/makedoc insert ..\include\rttext.e
--/makedoc insert ..\include\seqop.e
--/makedoc insert ..\include\series.e
--/makedoc insert ..\include\w32advapi.ew
--/makedoc insert ..\include\w32comctl.ew
--/makedoc insert ..\include\w32comdlg.ew
--/makedoc insert ..\include\w32dll.ew
--/makedoc insert ..\include\w32file.ew
--/makedoc insert ..\include\w32gdi.ew
--/makedoc insert ..\include\w32kernel.ew
--/makedoc insert ..\include\w32msgs.e
--/makedoc insert ..\include\w32ole.ew
--/makedoc insert ..\include\w32shell.ew
--/makedoc insert ..\include\w32sock.ew
--/makedoc insert ..\include\w32start.ew
--/makedoc insert ..\include\w32utils.e
--/makedoc insert ..\include\w32user.ew
--/makedoc insert ..\include\w32winmm.ew
--/makedoc insert ..\include\changes.txt
--/makedoc insert ..\include\w32constants.ew
--/makedoc insert ..\include\w32structures.ew
--/makedoc insert ..\include\w32memory.ew
--/makedoc insert ..\include\w32forms.ew
--/makedoc insert ..\include\w32resources.ew
--/makedoc insert ..\include\w32xpm.ew

--/topic Defaults
--/info
--Setting the default values that Win32lib applications use.
--There are a number of values that Win32lib uses that can be changed
-- on a per application basis. These new values are specified using the
-- operating system's SET environment symbol command.
--
--The symbol to use is 'w32Defaults'. This takes a comma separated list of
--keyword/value pairs. The keyword is delimited from the value by a colon ':'
-- character.
--
--/b FONT /n
--Unless you explicitly specify a font for a control, the get the
-- Win32lib default font.
--The default font used for text is /b"MS Sans Serif 8-point Normal". You can change
-- this with the /i Font keyword. It is followed by a list of one to three
-- values enclosed in brackets.
--
-- Font:{ /b facename, /b size, /b style } /n
--where /i facename is the name of the font, /i size is the point-size required,
-- and /i style is an integer whose value is the sum of ...
--/code
--    Normal    = 0
--    Bold      = 1
--    Italic    = 2
--    Underline = 4
--    Strikeout = 8
--/endcode
--Thus to get /b Bold and /i Italic you add 1 and 2 and make the /i style value
--equal 3.
--
--Example:
--/code
--      set w32Defaults=Font:(Comic Sans MS,12,3)
--/endcode

-----------------------------------------------------------------------------

--/topic Change History
-- This records, in brief, the major changes done to the source code.
-- Where possible, the appropriate people are given credit as well.
-- See details in /lit'<a href="change.htm">Changes</a>'

-----------------------------------------------------------------------------
-- info on topics

-----------------------------------------------------------------------------
--/topic System Attributes
--/info
-- These are routines that let you inspect and alter attributes of various system-wide elements.

-----------------------------------------------------------------------------
--/topic Values
--/info
-- These are routines that let you inspect and alter the current value of a control.
-- This is usually a text value but also include checkboxes,
-- progress bars, and scroll bars.

--/topic Attributes
--/info
-- These are routines that let you inspect and alter attributes of controls.
-- For more specialized routines, see:
--
-- /li /"Edit Control": Working with text edit controls
--          ( /EditText, /MleText ).
-- /li /"List Control": Working with lists ( /List, /SortedList ),
--          combos ( /Combo, /SortedCombo ), etc.
-- /li /"ListView Control"
-- /li /"MonthCalendar Control"
-- /li /"RichEdit Control"
-- /li /"TreeView Control"
-- /li /"Scroll Control": Working with scrollbars ( /HScroll, /VScroll )
--          trackbars ( /HTrackBar, /VTrackbar ) and the /ProgressBar.
-- /li /"UpDown Control"

-----------------------------------------------------------------------------
--/topic Controls
--/info
-- Controls are the basic elements of Windows programs.
-- You can /create them, query and change /Attributes, and respond to
-- /Events.
--
-- See Also: /Attributes

--/topic Forms
--/info
--Forms are a combination of a Window and its controls.
--Win32lib enables easy ways of creating a form and writing event handlers for it.

-----------------------------------------------------------------------------
--/topic Menus
--/info
-- Routines that deal with menu and menuitem handling.

-----------------------------------------------------------------------------
--/topic Dialogs
--/info
-- These are functions the bring up common dialogs.

-----------------------------------------------------------------------------
--/topic Edit Controls
--/info
-- These are routines that let you inspect and alter attributes of the text edit controls
-- Such as /EditText, /MleText and /RichEdit.

-----------------------------------------------------------------------------
--/topic Events
--/info
-- Events are routines that are triggered in response to actions taken by the user.
-- Application events, like mouse clicks, key presses, resizing windows, and so on,
-- are the basis for invoking user-developed routines. Once an application calls /WinMain,
-- Windows takes over and only runs the user code when an event, that has been nominated
-- by the user, occurs. To nominate which events the application wishes to respond to, the
-- application must register event handlers for each control/event combination that is relevent.
--
-- To establish an event handler, you use the /setHandler() routine. This links together
-- three things: A control, an Event Type, and a Routine that you write. /n
--Example:
--/code
--      setHandler(okButton, w32HClick, routine_id("myClickHandler"))
--/endcode
--
-- The event handler routine that you write is always passed three parameters: /n
--  /i"integer self" This is the id of the control that triggered the event. /n
--  /i"integer event" This is the Win32lib code for the event type that was
-- triggered. /n
-- /i"sequence parms" This is zero of more parameters that are specific to
-- the type of event being triggered.
--
-- A given event handler can be shared by many controls and event types. In this case, you can use
-- the /i self and /i event parameters to determine your actions.
--/code
--   procedure myClickHandler(integer self, integer event, sequence parms)
--       if self = okBtn then
--          . . .
--       else
--          . . .
--       end if
--   end procedure
--   setHandler({okBtn,cancelBtn}, w32HClick, routine_id("myClickHandler"))
--/endcode

-----------------------------------------------------------------------------
--/topic Fonts
--/info
-- These routines allow you to work with text.
-- Such as displaying text, changing the font, and so on.

-----------------------------------------------------------------------------
--/topic Graphics
--/info
-- These are routines that allow you to draw on controls.
-- Usually used with a /Window, /Pixmap or /Printer.
--
-- The predefined colors are:
--/code
--  Black, NavyBlue, Blue, BrightBlue
--  ForestGreen, Green, Cyan, SkyBlue
--  BrightGreen, BrightCyan, DarkGray, Eggplant
--  Red, Magenta, DarkBrown, Olive
--  Gray, Brown, LightGray, Purple
--  White, BrightRed, BrightMagenta, Violet
--  Orange, Pink, Yellow, Parchment, BrightWhite
--/endcode

-----------------------------------------------------------------------------
--/topic List Control
--/info
-- These are routines that let you inspect and alter attributes of controls with lists
-- This includes /Combo, /DropDownList, /List, /SimpleCombo,
-- /SortedCombo, /SortedList.
--
-- The first item in a list is 1, not 0. This makes it consistant with
-- Euphoria's indexing method, but can be a bit confusing if you are
-- used to working with zero-based arrays.

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/info
-- These routines give you access to low-level internals.
-- Such as C data structures, the device context,
-- and other Win32 API goodies.

-----------------------------------------------------------------------------
--/topic Mouse
--/info
-- These are routines that deal with the mouse and mouse pointer.

-----------------------------------------------------------------------------
--/topic Printing
--/info
-- These are routines that allow you to interact with the /Printer.

-----------------------------------------------------------------------------
--/topic Scroll Control
--/info
-- These routines let you inspect and alter attributes of the scroll bar controls.
-- Including /HScroll and /VScroll and track bar controls /HTrackBar
-- and /VTrackBar.

--/topic Updown Control
--/info
-- These routines let you manage the attributes of the UpDown control.

-----------------------------------------------------------------------------
--/topic Types
--/info
-- These are data types defined by Win32Lib.

-----------------------------------------------------------------------------
--/topic Utilities
--/info
-- These are useful routines that don't seem to fit in any other category.

-----------------------------------------------------------------------------
--/topic Date and time
--/info
-- These routines are used to extract and display system date and time information.

-----------------------------------------------------------------------------
--/topic Errors
--/info
-- These routines are used to manage warnings and errors occurring as your program runs.

-----------------------------------------------------------------------------
--/topic XPM
--/info
-- These routines deal with a portable graphics file format called XPM
-- XPM stands for "X Pixmap". XPM graphics can be embedded in programs as text data.

-----------------------------------------------------------------------------
--/topic ListView Control
--/info
-- These routines deal with the /ListView common control. /n
-- It is important to know that each item in a list view has a unique ID
-- number. In other words, no two listview items have the same ID value,
-- regardless of which listview it they are in. The item ID is not the same
-- as its index value. The index value is where in a list view the item is
-- positioned. The ID is used as a way to identify an item without referring
-- to its column values or position. When you add an item using /addLVItem,
-- you get the item's ID returned. /n
--  The following routines support /ListView as well as other controls:
-- /li /deleteItem
-- /li /eraseItems
-- /li /getIndex
-- /li /getItem
-- /li /getData
-- /li /findItem
--
-- The following routines are specific to the /b ListView control.
--
--/li /addLVItem
--/li /getLVAllChecked
--/li /getLVAllText
--/li /getLVChecked
--/li /getLVCount
--/li /getLVItem
--/li /getLVItemlParam
--/li /getLVItemText
--/li /getLVSelected
--/li /getLVSelectedCount
--/li /getLVSelectedText
--/li /hitTestLV
--/li /insertLVColumn
--/li /insertLVItem
--/li /setLVAttr
--/li /setLVChecked
--/li /setLVInsert
--/li /setLVImage
--/li /setLVItem
--/li /setLVItemlParam
--/li /setLVItemText
--/li /setLVStyle
--/li /struct_LVCOLUMN


-----------------------------------------------------------------------------
--/topic TreeView Control
--/info
-- These routines deal with the /TreeView common control.
-- The following routines support /TreeView as well as other controls:
-- /li /deleteItem
-- /li /eraseItems
-- /li /getIndex
-- /li /getItem
-- /li /getData
--
-- The following routines are specific to the /b TreeView control.
--
--/li /addTVItem
--/li /expandTV
--/li /getTVIndex
--/li /getTVParent
--/li /getTVSelectedText
--/li /getTVText
--/li /hitTestTV
--/li /removeTVItem
--/li /setTVImages
--/li /setTVParent
--/li /setTVText

-----------------------------------------------------------------------------
--/topic Image Lists
--/info
-- These routines deal with win32lib's /ImageList controls.

-----------------------------------------------------------------------------
--/topic MonthCalendar Control
--/info
-- These routines work with /MonthCalendar Controls:

-----------------------------------------------------------------------------
--/topic RichEdit controls
--/info
-- In addition to the specialized /RichEdit control routines.
-- The /"Edit Control" routines also work with /RichEdit Controls:
-- /li /clear( object )
-- /li /copy( object )
-- /li /cut( object )
-- /li /paste( object )
-- /li /undo( object )

--/topic Miscellaneous
--/info
--Routines that don't easily fit into other categories.

--/topic Text
--/info
--Routines that deal with text output.

without trace
without profile
--without warning

--/topic Constants
--/const w32VOID
--/desc This junkyard is provided so as to receive return values you don't need.
-- Although it is a regular Euphoria global variable, it is not intended to be read from.

global object w32VOID w32VOID = 0
object VOID
-- Various routine ids used internally.
integer
    r_activateTabItems,
    r_AppCallback,
    r_autoclose,
    r_createEx,
    r_defaultProcessing,
    r_destroy,
    r_doEvents,
    r_eventLoop,
    r_getCaption,
    r_getClientRect,
    r_getEdit,
    r_getIndex,
    r_getItem,
    r_getKeyMasks,
    r_getRect,
    r_getScrollPos,
    r_isVisible,
    r_isChecked,
    r_libCleanUp,
    r_lvSortitems,
    r_moveZOrder,
    r_openWindow,
    r_registerNotification,
    r_setBackColor,
    r_setCtlPosition,
    r_setFocus,
    r_setHintEx,
    r_setMonthColor,
    r_setNotificationState,
    r_setPenPos,
    r_setRect,
    r_setScrollPos,
    r_setText,
    r_subClassControl,
    r_xpmToEuBmp

integer vWinMainState
integer vEndAction
constant
     kNotStarted = 0,
     kStarted = 1,
     kFinished = 2
vWinMainState = kNotStarted  -- If set to non-zero, then eventLoop does nothing.
vEndAction = -1

sequence vRegisteredNames
sequence vRegisteredRID
vRegisteredNames = {}
vRegisteredRID = {}

--/topic Support Routines
--/func w32routine_id(sequence pRoutineName)
--/desc Returns the routine id for the registered routine /i pRoutineName
--/ret INTEGER: The routine id or -1 if /i pRoutineName is not registered.
--This can only find routines that have been registered via /registerRoutine()
-- and is used by /w32Start.ew to automatically set handlers based on the
-- standard naming convention for event handlers.
--
--Example:
--/code
--  integer id
--  id = w32routine_id( EventType & "_" & ControlName )
--/endcode

global function w32routine_id(sequence pRoutineName)
integer lPos

    lPos = find(pRoutineName, vRegisteredNames)
    if lPos>0 then
        return vRegisteredRID[lPos]
    else
        return -1
    end if
end function

--/topic Support Routines
--/proc registerRoutine(sequence pRoutineName, integer pRoutineId)
--/desc Registers a text string with an associated routine_id.
--This is primarily used to add routines to an internal list so that /w32start.ew
-- can automatically find event handlers. However it can be used to link a text string to
-- a routine_id, and later you can use /w32routine_id() to retrieve the routine_id given the
-- text string. For instance, this routine has been used extensively to enable a sub include file
-- to call a routine in another file without making the routine global, nor its routine_id.
--
--Example:
--/code
--  registerRoutine("Click_BigButton", routine_id("Click_BigButton"))
--  registerRoutine("MainAction", routine_id("Click_BigButton"))
--
--  rid = w32routine_id("MainAction")
--  if rid != -1 then
--      call_proc(rid, { . . . }) -- This calls Click_BigButton procedure.
--  end if
--/endcode
global procedure registerRoutine(sequence pRoutineName, integer pRoutineId)
    vRegisteredNames = append(vRegisteredNames, pRoutineName)
    vRegisteredRID = append(vRegisteredRID, pRoutineId)
end procedure

--/topic Application
--/info
--Routines dealing with the running application process.

--/topic Application
--/func getAppState()
--/desc Returns the current state of the application.
-- Returns either 0 (not started), 1 (running) or 2 (finished).
global function getAppState()
    return vWinMainState
end function

procedure finishAppInternal()
    vWinMainState = kFinished
end procedure
registerRoutine("finishAppInternal",routine_id("finishAppInternal"))

include machine.e
include dll.e
include msgbox.e
include file.e
include get.e
include wildcard.e
include image.e
include w32Keys.e         -- Definitions of Windows keycodes.
include w32msgs.e
include w32support.e      -- both w32memory.ew and w32utils.e
include w32constants.ew
include w32structures.ew
include w32dll.ew
include w32gdi.ew
include w32user.ew
include w32winmm.ew
include w32comdlg.ew
include w32comctl.ew
include w32Kernel.ew as KNL
include w32Shell.ew
include w32advapi.ew
include w32winspool.ew


include series.e as series
include rttext.e as rt


--/topic Constants
--/info
--These are constants that are used in a number of Win32Lib routines.
--They are often required to send information to the routines in the library.
--


--/topic Constants
--/const Win32LibVersion
--/desc Contains the current version of win32lib library.
-- This is a sequence containing four elements. /n
--/li Major version number (integer)
--/li Minor version number (integer)
--/li Patch or /i Revision number (integer)
--/li Date of the version in DD-Mmm-YYYY format (string)
--
-- The indexes of these parts are known as Win32libVersionMajor, Win32libVersionMinor,
-- Win32libVersionPatch and Win32libVersionDate respectively.
--
--Example
--/code
--       setText(SB, sprintf("Win32Lib version %d.%d Patch#%d, %s",
--                            Win32LibVersion))
--/endcode
global constant
    Win32LibVersion = {0,70,4, "17-Jun-2008"}   -- {Major, Minor, Patch, Date}
global constant
    Win32libVersionMajor = 1,
    Win32libVersionMinor = 2,
    Win32libVersionPatch = 3,
    Win32libVersionDate = 4

--/topic Constants
--/const Win32LibVersionEx
--/desc Contains the current version of win32lib library.
-- This is a sequence containing five elements. /n
--/li Major version number (integer)
--/li Minor version number (integer)
--/li Patch or /i Revision number (integer)
--/li Revision for patch (character)
--/li Date of the version in DD-Mmm-YYYY format (string)
--
-- The indexes of these parts are known as Win32libVersionExMajor, Win32libVersionExMinor,
-- Win32libVersionExPatch, Win32libVersionExRevision and Win32libVersionExDate, respectively.
--
-- If there is no revision letter, the latter is a space
--
--Example
--/code
--       setText(SB, sprintf("Win32Lib version %d.%d Patch#%d%s, %s",
--                            Win32LibVersion))
-- or, if you don't want the extra space when there is no revision letter:
--       setText(SB, sprintf("Win32Lib version %d.%d Patch#%d"
--                             & w32iff(Win32LibVersionEx[Win32libVersionExRevision]=' ',"","%s") -- letter or nothing
--                             & ", %s",                                  -- the date
--                            Win32LibVersionEx))
--/endcode
global constant
    Win32LibVersionEx = {0,70,4,'a', "17-Jun-2008"}   -- {Major, Minor, Patch, Revision, Date}
global constant
    Win32libVersionExMajor = Win32libVersionMajor,
    Win32libVersionExMinor = Win32libVersionMinor,
    Win32libVersionExPatch = Win32libVersionPatch,
    Win32libVersionExRevision = 4,
    Win32libVersionExDate = 5
sequence vAppName vAppName = "Win32Lib AppWindow"

-- Initialise the general UI message subsystem.
Init_UI_Msgs({
              {"AppName", vAppName},
              {"AppVersion", sprintf("Win32Lib v%d.%d.%d %s",
                                     {Win32LibVersion[1],
                                      Win32LibVersion[2],
                                      Win32LibVersion[3],
                                      Win32LibVersion[4]})
              }
             })

-- Set the message handler for memory allocation errors.
VOID = w32llSetAbort(routine_id("abortErr"))


r_AppCallback = -1

sequence vWinMsg        vWinMsg = repeat(0, 16)
integer  vWMI           vWMI = 0
sequence vDuringPaint   vDuringPaint = {}
sequence vDragData      vDragData = {}

-- Use Logical or Screen resolutions in Font Creation.
integer vFontResolution vFontResolution = 1 -- Use screen resolution

-----------------------------------------------------------------------------
-- current id and return value
sequence idStack, returnStack
integer SP
    SP = 0
    idStack = repeat(0, 10)
    returnStack = repeat(0, 10)

-----------------------------------------------------------------------------

--/topic System Attributes
--/func setEndAction(integer code)
--/desc Sets the exit code and behaviour at application closure.
--/ret INTEGER: Current value of the exit code
--This is used to signal what is to happen when the main window
--is closed. At that time, if the last use of setEndAction() uses
--a /i code less than zero, control returns to the application
--from the /WinMain() call. However, a /i code of zero or higher
--causes the library to call the standard Euphoria abort() routine
--using the value of /i code.
--
--Example
--/code
--      integer CurrentVal
--      -- Set the app to end when the main window is closed.
--      CurrentVal = setEndAction(0)
--
--/endcode
global function setEndAction(integer code)
integer lCurVal

    lCurVal = vEndAction
    vEndAction = code
    return vEndAction
end function

--/topic Attributes
--/func getSelf()
--/desc Get the id number of the current active control.
--/ret (INTEGER) id of active control. /i Zero if no control is active.
--This is used by event handlers to find out which control was active when
--the event was invoked.
--
--Example
--/code
--      procedure Clicker()
--        integer lSelf
--
--        lSelf = getSelf()
--        if lSelf = btnOne then
--           ...
--        else
--           ...
--        end if
--      end procedure
--/endcode
global function getSelf()
    -- return id of current active control
    if SP>0 then
        return idStack[SP]
    else
        return 0
    end if
end function



constant
   Err_GETHCHANGED = {"getHandle:The stored hWnd for id %d is now attached to id %d", 499},
--   Err_COMCTLFAIL = {"Common controls could not be initialized!", 498},
   Err_GETHOBJECTDESTROYED = {"getHandle: Object is destroyed.", 497},
   Err_GETHNULLHANDLE = {"getHandle returned Null handle.", 496},
   Err_GETHFAIL = {"getHandle failed.", 495},
--   Err_QFNOWINDOW = {"queryFont: no windows defined", 485},
   Err_GETTEXTEXTENT = {"getTextExtent:GetTextExtentPoint failed.", 484},
   Err_REGCLASS = {"RegisterClassEx failed.", 483},
   Err_CREATEWINDOW = {"CreateWindow in createWindow failed.", 482},
   Err_CREATETABITEM = {"Failed to create a TabItem in create:createTabItem.", 481},
--   Err_DESTROYWINDOW = {"destroy:Window failed", 480},
--   Err_DESTROYBUTTON = {"destroy:Button failed", 479},
--   Err_DESTROYCONTROL = {"destroy:Control failed", 478},
   Err_DESTROYMENU = {"destroy:Menu failed", 477},
--   Err_DESTROYMENUITEM = {"destroy:MenuItem failed", 476},
--   Err_DESTROYCLASS = {"destroy: Class cannot be destroyed yet.", 475},
--   Err_FPINVALIDATERECT = {"InvalidateRect in flushPaintEvent failed.", 474},
--   Err_RWINVALIDATERECT = {"InvalidateRect in repaintWindow failed.", 473},
   Err_GSGETWINDRECT = {"getRect:GetWindowRect failed.", 472},
   --Err_CREATEMDIWINDOW = {"CreateMDIWindow in createMDIWindow failed.", 471},
   --Err_CPCLIENTTOSCREEN = {"getClientPoint:ClientToScreen failed.", 470},
   Err_WNDPROCNOID = {"routine_id for WndProc failed!", 469},
   Err_SUBPROCNOID = {"routine_id for SubProc failed!", 468},
--   Err_BADID = {"Unknown control id supplied.", 467},
   Err_STACKERR = {"Internal ID or Return stack lengths incorrect.", 466},
   Err_CREATETABITEM2 = {"Cannot create a TabItem: Parent not a TabControl.", 462},
   Err_CREATECONTROL = {"Failed to acquire a hWnd when creating a control.", 461},
--   Err_CREATECONTROL2 = {"Failed to acquire a hWnd when subclassing a control.", 460},
   Err_OWNERINVALID = {"create():Invalid parent id.", 459},
--   Err_SETTEXTCOLOR = {"SetTextColor in assignFont failed.",448},
   Err_SETBKMODE = {"SetBkMode in assignFont failed.",447},
   Err_GETFONTMETRIC = {"GetTextMetrics in getFontSize failed.",446},
   Err_GETFONTSIZE = {"GetTextMetrics in getFontSize failed.",445},
   Err_CREATEMENU = {"CreateMenu in createMenu failed.",444},
   Err_SETMENU = {"SetMenu in createMenu failed.",443},
   Err_CREATEPOPUP = {"CreatePopupMenu in CreateMenu failed.",442},
   Err_APPENDMENU = {"AppendMenu in createMenu failed.",441},
   Err_APPENDMENUITEM = {"AppendMenu in createMenuItem failed.",440},
   Err_CREATEPIXMAP = {"createPixmap:CreateCompatibleBitmap failed",439},
   Err_FLATTOOLBARBTN = {"createEx: failed to create button",438},
   Err_REPAINTRECT = {"InvalidateRect in repaintRect failed.",437},
   Err_GSGETBITMAP = {"getRect:GetObject for bitmap failed.",436},
   Err_GSGETPIXMAP = {"getRect:GetObject for pixmap failed.",435},
   Err_GCSGETCLIENTRECT = {"getClientSize:GetClientRect failed.",434},
   --Err_GCSCLIENTTOSCREEN = {"getClientSize:ClientToScreen failed.",433},
   Err_GCRGETCLIENTRECT = {"getClientRect:GetClientRect failed.",432},
--   Err_SETTEXT = {"SetWindowText in setText failed.",431},
   Err_SETENABLE = {"EnableMenuItem in enableMenuItem failed.",430},
   Err_SETCHECK = {"CheckMenuItem in checkMenuItem failed.",429},
   Err_SETBKCOLOR = {"SetBkColor in assignFont failed.",428},
   --Err_CLIENTTOSCREEN = {"ClientToScreen failed.", 427},
   Err_SCREENTOCLIENT = {"ScreenToClient failed.", 426}
----------------------------------------------------------------------------

--/topic System Attributes
--/func getSystemMetrics( object Code )
--/desc Allows you to get miscellaneous information about the Windows system your application is running on.
--/ret Depends on the input /i Code.
-- Note that /i Code can be an atom for single requests or a sequence of
-- atoms for multiple requests in one call. /n
--The codes and their return values are <a href="..\win32_constants.htm#getSystemMetrics() parameters">enumerated here</a>. /n

global function getSystemMetrics(object Code)
sequence lResult
    if atom(Code) then
        return w32Func(xGetSystemMetrics, {Code})
    end if

    lResult = repeat(0, length(Code))
    for i=1 to length(Code) do
        lResult[i] = w32Func(xGetSystemMetrics, {Code[i]})
    end for
    return lResult
end function



-----------------------------------------------------------------------
--/topic Mouse
--/proc setPointerPos(sequence pos)
--/desc Moves the mouse pointer to a specified spot on the screen.
-- /i pos is a two-element sequence that specifies the /b X and /b Y position
-- that the mouse pointer is to be moved to.
--
-- Example:
--/code
--      -- Move the mouse pointer to 120,76
--      setPointerPos({120, 76})
--/endcode

global procedure setPointerPos(sequence pos)
    w32Proc(xSetCursorPos,{pos[1],pos[2]})
end procedure




-----------------------------------------------------------------------
--/topic Mouse
--/func getWheelScrollLines()
--/desc Retrieves the number of lines that a mouse wheel movement represents.
--/ret ATOM: The number of lines.
--
-- Example:
--/code
--  atom cnt
--  cnt = getWheelScrollLines()
--/endcode
atom gwsMem gwsMem = w32acquire_mem(-2, 4)
global function getWheelScrollLines()
atom lLines

    VOID = w32Func(xSystemParametersInfo,{SPI_GETWHEELSCROLLLINES,0,gwsMem,0})
    lLines =  peek4u(gwsMem)
    return lLines
end function


-----------------------------------------------------------------------
--/topic Mouse
--/func getPointerPos()
--/desc Find where the mouse pointer is on the screen.
--/ret SEQUENCE: {X,Y} The mouse position.
-- This returns a two-element sequence that specifies the /b X and /b Y position
-- of the mouse pointer.
--
-- Example:
--/code
-- sequence pos
--
--  pos = getPointerPos()
--  if pos[1] > 200 then
--      -- code goes here...
--  end if
--/endcode
atom gppMem gppMem = w32acquire_mem(-2, 8)
global function getPointerPos()
    VOID = w32Func(xGetCursorPos,{gppMem})
    return peek4s({gppMem, 2})
end function

--/topic Mouse
--/proc clickPointerLeft()
--/desc Simulates the clicking of the left mouse button.

global procedure clickPointerLeft()
    w32Proc(xmouse_event,{6,0,0,0,0})
end procedure

--/topic Mouse
--/proc dragPointerTo(sequence pos)
--/desc Simulates the draging of the left mouse button to a specified position.
-- /i pos is a two-element sequence that contains the /b X and /b Y location to drag the pointer to.
--
--Example
--/code
--  dragPointerTo( {100, 200} )
--/endcode

global procedure dragPointerTo(sequence pos)
    w32Proc(xmouse_event,{#2,0,0,0,0})
    w32Proc(xSetCursorPos,{pos[1],pos[2]})
    w32Proc(xmouse_event,{#4,0,0,0,0})
end procedure


--/topic System Attributes
--/func getWinVersion()
--/desc Gets the version information of the windows platform you are running in.
--/ret SEQUENCE: {WinVer, VariantString, BuildNo}
--
-- /i WinVer return value can be one of <a href="..\win32_constants.htm#Windows major versions">these</a>. /n
-- /i VariantString is a service pack name. /n
--/i BuildNo is the operating system's build number.
--
--Example
--/code
--      sequence winver
--      winver = getWinVersion()
--/endcode

global function getWinVersion()
sequence lResult
atom lOV
atom lResp

    lOV = w32to_memory(0,ID_OSVERSIONINFOEX,0)
    lResp = w32Func(xGetVersionEx, {lOV})
    lResult = repeat(0,9)
    if lResp=0 then
        w32store(lOV, dwOSVersionInfoSize,  SIZEOF_OSVERSIONINFO)
        lResp = w32Func(xGetVersionEx, {lOV})
    end if
    lResult[1..4] = peek4s({lOV+4, 4})
    lResult[5] = w32peek_string(lOV+20)
    lResult[6]  = w32fetch(lOV,wServicePackMajor)
    lResult[7]  = w32fetch(lOV,wServicePackMinor)
    lResult[8]  = w32fetch(lOV,wSuiteMask)
    lResult[9]  = w32fetch(lOV,wProductType)

    w32release_mem(lOV)
    if lResult[1]=6 then
        lResult[1] = WIN_VISTA
    elsif lResult[4]=0 then
        lResult[1] = WIN_3_1
    elsif lResult[4]=1 then
        if lResult[2]=0 then
            if equal(lResult[5], " C") then
                lResult[1] = WIN_95_OSR2
            else
                lResult[1] = WIN_95
            end if

        elsif lResult[2]=10 then
            if equal(lResult[5], " A") then
                lResult[1] = WIN_98SE
            else
                lResult[1] = WIN_98
            end if
        else
            lResult[1] = WIN_ME
        end if
        lResult[3] = and_bits(#FFFF, lResult[3])
    else
        if lResult[2]=51 then
            lResult[1] = WIN_NT_3_51
        elsif lResult[2]=0 then
            if lResult[1]=4 then
                lResult[1] = WIN_NT_4
            else
                lResult[1] = WIN_2000
            end if
        elsif lResult[2]=1 then
            lResult[1] = WIN_XP
        else
            lResult[1] = WIN_UNKNOWN
        end if
    end if
    lResult[2] = lResult[5]

    if lResult[6]=0 then
        lResult = lResult[1..3]
    else
        lResult = lResult[1..3] & lResult[6..9]
    end if

    return lResult
end function

global constant WINDOWS_VERSION = getWinVersion()


constant ccNames = {
                    "LISTVIEW",
                    "TREEVIEW",
                    "BAR",
                    "TAB",
                    "UPDOWN",
                    "PROGRESS",
                    "HOTKEY",
                    "ANIMATE",
                    "DATE",
                    "COMBOEX",
                    "REBAR",
                    "INTERNET",
                    "PAGESCROLLER",
                    "NATIVEFNTCTL"
                   }
-----------------------------------------------------------------------------
procedure InitCommonControls()
atom icc
integer lClassFlag
sequence lNames

    lNames = {}
    icc = w32to_memory(0,ID_INITCOMMONCONTROLSEX  ,0)
    lClassFlag = 1
    for i=1 to length(ccNames) do
        w32store(icc, INITCOMMONCONTROLSEX_dwICC, lClassFlag)
        if w32Func(xInitCommonControlsEx, {icc})=0 then
            lNames &= '\t' & ccNames[i] & '\n'
        end if
        lClassFlag *= 2
    end for
    if WINDOWS_VERSION[1]>=WIN_98 and length(lNames)>0 then
        warnErr("The following Common Control Classes cannot be used...\n" &
                lNames & "\nYou may need to install the latest 'comctl32.dll'")
    end if
    w32release_mem(icc)
end procedure

InitCommonControls()
-----------------------------------------------------------------------------
sequence vDragPointer vDragPointer = repeat(CrossPointer, 4)


constant
    WindowColor                 = w32Color_BTNFACE

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getSysColor( window, color )
--/ret ATOM:Returns the RGB value of the specified system color.
--/desc Return atom with value of a system color.
-- The system colors in Windows are <a href="..\win32_constants.htm#System Colors">listed here</a>. /n
--
-- /li /b COLOR_SCROLLBAR
-- /li /b COLOR_BACKGROUND
-- /li /b COLOR_DESKTOP
-- /li /b COLOR_ACTIVECAPTION
-- /li /b COLOR_INACTIVECAPTION
-- /li /b COLOR_MENU
-- /li /b COLOR_WINDOW
-- /li /b COLOR_WINDOWFRAME
-- /li /b COLOR_MENUTEXT
-- /li /b COLOR_WINDOWTEXT
-- /li /b COLOR_CAPTIONTEXT
-- /li /b COLOR_ACTIVEBORDER
-- /li /b COLOR_INACTIVEBORDER
-- /li /b COLOR_APPWORKSPACE
-- /li /b COLOR_HIGHLIGHT
-- /li /b COLOR_HIGHLIGHTTEXT
-- /li /b COLOR_BTNFACE
-- /li /b COLOR_BTNSHADOW
-- /li /b COLOR_GRAYTEXT
-- /li /b COLOR_BTNTEXT
-- /li /b COLOR_INACTIVECAPTIONTEXT
-- /li /b COLOR_BTNHIGHLIGHT
-- /li /b COLOR_3DDKSHADOW
-- /li /b COLOR_3DLIGHT
-- /li /b COLOR_INFOTEXT
-- /li /b COLOR_INFOBK
-- /li /b COLOR_HOTLIGHT
-- /li /b COLOR_GRADIENTACTIVECAPTION
-- /li /b COLOR_GRADIENTINACTIVECAPTION
-- /li /b COLOR_MENUHILIGHT
-- /li /b COLOR_MENUBAR
--
-- Example:
--
--/code
--          -- Set the window to the button color
--          /setWindowBackColor( MyWindow, /getSysColor( COLOR_BTNFACE ) )
--/endcode
global function getSysColor(atom winPart)

    -- returns the color associated with a graphical element
    -- use the COLOR_xxxx constants
    if winPart<0 then
        winPart = -winPart-1
    end if
    return w32Func(xGetSysColor, {winPart})

end function

global function UseColor(atom x)
    x = floor(x)
    if x<0 then
        return w32Func(xGetSysColor, {-x-1})
    else
        return and_bits(#FFFFFF, x)
    end if
end function

-----------------------------------------------------------------------------
--/topic Graphics
--/func rgb( integer red, integer green, integer blue )
--/desc Convert a {red, green, blue} tuple into a 24-bit color value.
--/ret Atom: representing the color tuple.
-- Converts the /i red, /i green and /i blue values (ranging from 0-255)
-- into an atom representing that color tuple. Each value represents the
-- relative brightness of each primary color element.
--
-- Example:
-- /code
--      -- set the pen color to a random blue
--      /setPenColor( MyControl, /rgb( 0, 0, rand( 255 )
-- /endcode

global function rgb(integer r, integer g, integer b)
    return r+g*256+b*65536
end function

constant vkEvents = next_number(0)
global constant
    w32HBreak     = next_number(vkEvents),
    w32HPause     = next_number(vkEvents),
    w32HMouse     = next_number(vkEvents),
    w32HClick     = next_number(vkEvents),
    w32HKeyPress  = next_number(vkEvents),
    w32HKeyUp     = next_number(vkEvents),
    w32HKeyDown   = next_number(vkEvents),
    w32HResize    = next_number(vkEvents),
    w32HChange    = next_number(vkEvents),
    w32HGotFocus  = next_number(vkEvents),
    w32HLostFocus = next_number(vkEvents),
    w32HScroll    = next_number(vkEvents),
    w32HOpen      = next_number(vkEvents),
    w32HClose     = next_number(vkEvents),
    w32HDestroy   = next_number(vkEvents),
    w32HTimer     = next_number(vkEvents),
    w32HPaint     = next_number(vkEvents),
    w32HDragAndDrop = next_number(vkEvents),
    w32HEvent     = next_number(vkEvents),
    w32HActivate  = next_number(vkEvents),
    w32HAfterEvent = next_number(vkEvents), -- Not supported by onXXX
    w32HDropDown  = next_number(vkEvents), -- Not supported by onXXX
    w32HCloseUp   = next_number(vkEvents), -- Not supported by onXXX
    w32HIdle      = next_number(vkEvents),  -- Not supported by onXXX
    w32HMouseTrap    = next_number(vkEvents),  -- Not supported by onXXX
    w32HNotify    = next_number(vkEvents),  -- Not supported by onXXX
    w32HGetHandler = next_number(vkEvents),  -- Not supported by onXXX
    w32HDataChange = next_number(vkEvents), -- Not supported by onXXX
    w32HKeyboard = next_number(vkEvents) -- Not supported by onXXX

function w32LastEventType()
    return current_number(vkEvents)
end function

--/topic Events
--/const w32EventCodes
--/desc List of all recognised event codes, in the same order as /w32EventNames.
global sequence w32EventCodes
w32EventCodes = {
                 w32HBreak,
                 w32HPause,
                 w32HMouse,
                 w32HClick,
                 w32HKeyPress,
                 w32HKeyUp,
                 w32HKeyDown,
                 w32HResize,
                 w32HChange,
                 w32HGotFocus,
                 w32HLostFocus,
                 w32HScroll,
                 w32HOpen,
                 w32HClose,
                 w32HDestroy,
                 w32HTimer,
                 w32HPaint,
                 w32HDragAndDrop,
                 w32HEvent,
                 w32HActivate,
                 w32HAfterEvent,
                 w32HDropDown,
                 w32HCloseUp,
                 w32HIdle,
                 w32HKeyboard,
                 w32HMouseTrap,
                 w32HDataChange,
                 w32HGetHandler
}
--/topic Events
--/const w32EventNames
--/desc List of all recognised event names, without the "w32H" prefix.

global sequence w32EventNames
w32EventNames = {
                 "Break",
                 "Pause",
                 "Mouse",
                 "Click",
                 "KeyPress",
                 "KeyUp",
                 "KeyDown",
                 "Resize",
                 "Change",
                 "GotFocus",
                 "LostFocus",
                 "Scroll",
                 "Open",
                 "Close",
                 "Destroy",
                 "Timer",
                 "Paint",
                 "DragAndDrop",
                 "Event",
                 "Activate",
                 "AfterEvent",
                 "DropDown",
                 "CloseUp",
                 "Idle",
                 "Keyboard",
                 "Region",
                 "DataChange",
                 "GetHandler"
}

--/topic Defining Controls
--/const w32ControlTypes
--/desc Holds the values of recognised controls, in the same order as /w32ControlNames.
global sequence w32ControlTypes
--/topic Defining Controls
--/const w32ControlNames
--/desc Holds the names of recognised controls.
global sequence w32ControlNames

sequence vControlRID
constant
    w32CRID       = series:next_number(0),
    kCRID_Create  = series:next_number(w32CRID),
    kCRID_Destroy = series:next_number(w32CRID),
    kCRID_Process = series:next_number(w32CRID),
    kCRID_Control = series:next_number(w32CRID),
    kCRID_SIZEOF  = series:current_number(w32CRID)

--/topic Attributes
--/const w32ColorNames
--/desc List of all recognised color names.
global sequence w32ColorNames
w32ColorNames = {
                 "BLACK",
                 "NAVYBLUE",
                 "BLUE",
                 "BRIGHTBLUE",
                 "FORESTGREEN",
                 "GREEN",
                 "CYAN",
                 "SKYBLUE",
                 "BRIGHTGREEN",
                 "BRIGHTCYAN",
                 "DARKGRAY",
                 "EGGPLANT",
                 "RED",
                 "MAGENTA",
                 "DARKBROWN",
                 "OLIVE",
                 "GRAY",
                 "BROWN",
                 "LIGHTGRAY",
                 "PURPLE",
                 "WHITE",
                 "BRIGHTRED",
                 "BRIGHTMAGENTA",
                 "VIOLET",
                 "ORANGE",
                 "PINK",
                 "YELLOW",
                 "PARCHMENT",
                 "BRIGHTWHITE"
}


global integer
    Screen,         -- id of screen
    Printer         -- id of printer


-----------------------------------------------------------------------------
-- names of indexes for window_change
constant
    MY_SMALLCHANGE      = 1,        -- scroll bar line up/down amount
    MY_LARGECHANGE      = 2         -- scroll bar page up/down amount


-----------------------------------------------------------------------------
sequence
    className,      -- class name
    classType,      -- message class
    classAlias,     -- which class must be reflected
    classStyle,     -- attributes
    classStyleEx,   -- extended class attributes
    classAttr,      -- Attributes used internally by win32lib
    classBGColor,   -- Default background color
    classDefPointer,-- Default shape for Mouse Pointer
    classFGColor,   -- Default foregrond color
    classKbdInput,  -- Default value or routine for WM_GETDLGCODE
    vWindowClassStyle -- The styles used in registering a Window class.

    vWindowClassStyle = {CS_DBLCLKS}--CS_HREDRAW, CS_VREDRAW }

-- hidden classes
constant
    Screen_   = w32NewClass(),
    Printer_  = w32NewClass()

    className     = repeat( -1, w32NumClasses())
    classType     = repeat( -1, w32NumClasses())
    classAlias     = repeat( -1, w32NumClasses())
    classStyle    = repeat(0, w32NumClasses())
    classStyleEx  = repeat(0, w32NumClasses())
    classAttr     = repeat(0, w32NumClasses())
    classDefPointer = repeat(IDC_ARROW, w32NumClasses())
    classBGColor  = repeat(WindowColor, w32NumClasses())
    classFGColor  = repeat(w32Color_WINDOWTEXT, w32NumClasses())
    classKbdInput     = repeat(0, w32NumClasses())

    for i=1 to w32NumClasses() do
        classAlias[i] = i
    end for

integer AutoReBarSizing AutoReBarSizing = w32False

    classAttr[Screen_] = w32NoConv
    classAttr[Printer_] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const Window
--/desc A Window is a normal Win32 window.

    className[Window] = "" -- To be determined at creation time.
    classType[Window] = WINDOW
    classStyle[Window] = WS_OVERLAPPEDWINDOW
    classStyleEx[Window] = WS_EX_ACCEPTFILES
    classAttr[Window] = w32Clickable


-----------------------------------------------------------------------------
--/topic Controls
--/const PushButton
--/desc Command button control.
-- A PushButton is a normal push button (sometimes called
-- /i command /i button). A PushButton has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[PushButton] = "button"
    classType[PushButton] = BUTTON
    classStyle[PushButton] = w32or_all({WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        BS_PUSHBUTTON,
                                        WS_TABSTOP})

    classAttr[PushButton] = 0
    classBGColor[PushButton] = w32BGTransparent
    classKbdInput[PushButton] = DLGC_UNDEFPUSHBUTTON

-----------------------------------------------------------------------------
--/topic Controls
--/const DefPushButton
--/desc Default command button control.
-- A DefPushButton is a /PushButton, but
-- is displayed with an extra border indicating that this button
-- will automatically be selected if the user presses the Return
-- button on the keyboard.
--
-- A DefPushButton has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_DEFPUSHBUTTON: button style is default pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[DefPushButton] = "button"
    classType[DefPushButton] = BUTTON
    classStyle[DefPushButton] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           BS_DEFPUSHBUTTON,
                                           WS_TABSTOP})
    classAttr[DefPushButton] = w32UseSubProc
    classKbdInput[DefPushButton] = DLGC_DEFPUSHBUTTON
-----------------------------------------------------------------------------
--/topic Controls
--/const CancelButton
--/desc Command button that reacts to the Escape key.
-- A CancelButton is a /PushButton, but
-- is displayed with italic font indicating that this button
-- will automatically be selected if the user presses the Escape
-- key.
--
-- A CancelButton has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[CancelButton] = "button"
    classType[CancelButton] = BUTTON
    classStyle[CancelButton] = w32or_all({WS_CLIPPINGCHILD,
                                          WS_VISIBLE,
                                          BS_PUSHBUTTON,
                                          WS_TABSTOP})
    classAttr[CancelButton] = w32AutoCancel
    classKbdInput[CancelButton] = DLGC_UNDEFPUSHBUTTON
-----------------------------------------------------------------------------
--/topic Controls
--/const CheckBox
--/desc CheckBox control.
-- A CheckBox is a button that can be toggled on or off.
-- It appears as a box with a label to the side. Clicking the
-- checkbox causes an 'X' to be toggled in the box.
--
-- A CheckBox has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_AUTOCHECKBOX: checkbox, default window handling
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[CheckBox] = "button"
    classType[CheckBox] = BUTTON
    classStyle[CheckBox] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      BS_AUTOCHECKBOX,
                                      WS_TABSTOP,
                                      BS_NOTIFY})
    classBGColor[CheckBox] = w32BGTransparent
    classAttr[CheckBox] = w32UseSubProc
    classKbdInput[CheckBox] = DLGC_BUTTON+DLGC_WANTCHARS
-----------------------------------------------------------------------------
--/topic Controls
--/const TriCheckBox
--/desc Three state checkbox control.
-- A TriCheckBox is similar to a /CheckBox, but it
-- has three states: on, off, or dim.
--
-- A TriCheckBox has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_AUTO3STATE: tri-state check box
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[TriCheckBox] = "button"
    classType[TriCheckBox] = BUTTON
    classStyle[TriCheckBox] = w32or_all({WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         BS_AUTO3STATE,
                                         WS_TABSTOP,
                                         BS_NOTIFY})
    classAttr[TriCheckBox] = w32UseSubProc
    classBGColor[TriCheckBox] = w32BGTransparent
    classKbdInput[TriCheckBox] = DLGC_BUTTON+DLGC_WANTCHARS+DLGC_3STATE


-----------------------------------------------------------------------------
--/topic Controls
--/const Radio
--/desc Radio button control.
-- A Radio is similar to a /CheckBox, in functionality.
-- Like a checkbox, it can be toggled on and off. However, radio buttons
-- are grouped controls - if one is toggled on, the rest in the group are
-- toggled off.
--
-- Win32Lib considers a radio button in a group if they are contained
-- by the same /Group control. If there is no /Group control,
-- then all the radio buttons are considered to belong to the same
-- group.
--
-- A Radio has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_AUTORADIOBUTTON: radio button control
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[Radio] = "button"
    classType[Radio] = BUTTON
    classStyle[Radio] = w32or_all({WS_CHILD,
                                   WS_VISIBLE,
                                   BS_AUTORADIOBUTTON,
                                   WS_TABSTOP,
                                   BS_NOTIFY})
    classStyleEx[Radio] = WS_EX_TRANSPARENT
    --classAttr [ Radio ] =  w32UseSubProc
    --classBGColor[ Radio ] = w32BGTransparent
    classKbdInput[Radio] = DLGC_BUTTON+DLGC_RADIOBUTTON

-----------------------------------------------------------------------------
--/topic Controls
--/const Group
--/desc Group control.
-- A Group is a static control, and receives no events. It's
-- main function is to seperate other controls into groups.
--
-- In addition to providing a visual cue, the group alters the behavior of
-- the /Radio control; all the radio buttons within a single group are
-- considered to belong to the same group.
--
-- When placing controls in groups, it's a good idea to make them
-- children of the Group, instead of children of the Window. If you
-- don't, the Group may end up routing events meant for the control to
-- itself. For example, /onDragAndDrop events will be routed to the
-- Group instead of the child.
--
-- A Group has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_GROUPBOX: group box control

    className[Group] = "button"
    classType[Group] = BUTTON
    classStyle[Group] = w32or_all({WS_CHILD, WS_CLIPSIBLINGS,
                                   WS_VISIBLE,
                                   BS_GROUPBOX,
                                   WS_TABSTOP})
    classAttr[Group] = w32Clickable+w32UseSubProc+w32HasChildren
    classStyleEx[Group] = WS_EX_TRANSPARENT
    classKbdInput[Group] = DLGC_STATIC


-----------------------------------------------------------------------------
--/topic Controls
--/const SortedList
--/desc Sorted list control.
-- A SortedList contains a list of items, arranged in alphabetical
-- order. To have an unsorted list, use the /List control instead.
--
-- A SortedList has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b LBS_NOTIFY: notify parent of events
-- /li /b LBS_SORT: sort items in list
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b WS_BORDER: draw a border on the control
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support


    className[SortedList] = "listbox"
    classType[SortedList] = LISTBOX
    classStyle[SortedList] = w32or_all({WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        LBS_NOTIFY,
                                        LBS_SORT,
                                        WS_VSCROLL,
                                        WS_BORDER,
                                        WS_TABSTOP})

    classStyleEx[SortedList] = w32or_all({WS_EX_CLIENTEDGE,
                                          WS_EX_ACCEPTFILES})

    classAttr[SortedList] = w32Clickable
    classBGColor[SortedList] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[SortedList] = DLGC_WANTARROWS+DLGC_WANTCHARS
-----------------------------------------------------------------------------
--/topic Controls
--/const List
--/desc List.
-- A List contains a list of items, arranged in the order that
-- they were placed into the list. To have a sorted list, either sort
-- the items before placing them into the list, or use the /SortedList
-- control.
--
-- A List has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b LBS_NOTIFY: notify parent of events
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b WS_BORDER: draw a border on the control
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support

    className[List] = "listbox"
    classType[List] = LISTBOX
    classStyle[List] = w32or_all({WS_CLIPPINGCHILD,
                                  WS_VISIBLE,
                                  LBS_NOTIFY,
                                  WS_VSCROLL,
                                  WS_BORDER,
                                  WS_TABSTOP})

    classStyleEx[List] = w32or_all({WS_EX_CLIENTEDGE,
                                    WS_EX_ACCEPTFILES})

    classAttr[List] = w32Clickable
    classBGColor[List] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[List] = DLGC_WANTARROWS+DLGC_WANTCHARS

-----------------------------------------------------------------------------
--/topic Controls
--/const Combo
--/desc Combo box control.
-- A Combo is a combination of an edit control and a list.
-- If you need the items in the combo to be sorted, use a /SortedCombo
-- instead. In addition to being able to select a value from the combo's
-- list, the user can enter their own value as well.
--
-- A Combo has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b CBS_DROPDOWN: the list can drop down, like a menu
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[Combo] = "combobox"
    classType[Combo] = COMBO
    classStyle[Combo] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   WS_VSCROLL,
                                   CBS_DROPDOWN,
                                   CBS_HASSTRINGS,
                                   WS_TABSTOP})
    classStyleEx[Combo] = w32or_all({WS_EX_CLIENTEDGE,
                                     WS_EX_ACCEPTFILES})
    classAttr[Combo] = w32Clickable
    classBGColor[Combo] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[Combo] = DLGC_WANTARROWS+DLGC_WANTCHARS


-----------------------------------------------------------------------------
--/topic Controls
--/const SortedCombo
--/desc Sorted combo box control.
-- A SortedCombo is a combination of an edit control and a list.
--
-- A SortedCombo has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b CBS_DROPDOWN: the list can drop down, like a menu
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b CBS_SORT: sorted
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[SortedCombo] = "combobox"
    classType[SortedCombo] = COMBO
    classStyle[SortedCombo] = w32or_all({WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         WS_VSCROLL,
                                         CBS_DROPDOWN,
                                         CBS_HASSTRINGS,
                                         CBS_SORT,
                                         WS_TABSTOP})
    classStyleEx[SortedCombo] = w32or_all({WS_EX_CLIENTEDGE,
                                           WS_EX_ACCEPTFILES})
    classAttr[SortedCombo] = w32Clickable
    classBGColor[SortedCombo] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[SortedCombo] = DLGC_WANTARROWS+DLGC_WANTCHARS

-----------------------------------------------------------------------------
--/topic Controls
--/const SimpleCombo
--/desc Simple combo box control.
-- A SimpleCombo is a combo box with no dropdown. The user can
-- select from various values by using the cursor keys.
--
-- A SimpleCombo has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b CBS_SIMPLE: has a list of values
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[SimpleCombo] = "combobox"
    classType[SimpleCombo] = COMBO
    classStyle[SimpleCombo] = w32or_all({
                                         WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         CBS_SIMPLE,
                                         CBS_HASSTRINGS,
                                         WS_TABSTOP})
    classStyleEx[SimpleCombo] = w32or_all({WS_EX_CLIENTEDGE,
                                           WS_EX_ACCEPTFILES})
    classAttr[SimpleCombo] = w32Clickable
    classBGColor[SimpleCombo] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[SimpleCombo] = DLGC_WANTARROWS+DLGC_WANTCHARS


-----------------------------------------------------------------------------
--/topic Controls
--/const DropDownList
--/desc Drop down list control.
-- A DropDownList is like a /Combo, but the user can only
-- select items on the list, and not enter their own value into the edit
-- box.
--
-- A DropDownList has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_VSCROLL: attach a vertical scroll bar
-- /li /b CBS_DROPDOWNLIST: the list can drop down, like a menu
-- /li /b CBS_HASSTRINGS: contains string values
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[DropDownList] = "combobox"
    classType[DropDownList] = COMBO
    classStyle[DropDownList] = w32or_all({WS_CLIPPINGCHILD,
                                          WS_VISIBLE,
                                          WS_VSCROLL,
                                          CBS_DROPDOWNLIST,
                                          CBS_HASSTRINGS,
                                          WS_TABSTOP})
    classStyleEx[DropDownList] = w32or_all({WS_EX_CLIENTEDGE,
                                            WS_EX_ACCEPTFILES})
    classAttr[DropDownList] = w32Clickable
    classBGColor[DropDownList] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[DropDownList] = DLGC_WANTARROWS+DLGC_WANTCHARS

-----------------------------------------------------------------------------
--/topic Controls
--/const EditText
--/desc Text edit control control.
-- An EditText allows the user to enter a single-line of text into the control.
--
-- /b Note that when the user presses the Return Key, the focus will move to the next control
-- in the focus order. To prevent this from happening, you need to set a /w32HKeyPress handler
-- that sets the return value to -1 when a VK_RETURN key without shifts is received.
--
--/code
--      procedure IgnoreReturn(integer self, integer event, sequence parms)
--          if parms[1] = VK_RETURN and parms[2] = 0 then
--              returnValue(-1)
--          end if
--      end procedure
--      setHandler(myEditField, w32HKeyPress, routine_id("IgnoreReturn"))
--/endcode
--
-- A EditText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_AUTOHSCROLL: automatic vertical scrollbar, if needed
-- /li /b ES_LEFT: left justify the text
-- /li /b WS_BORDER: draw with a border
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support

-- single line edit, left justified
    className[EditText] = "edit"
    classType[EditText] = EDIT
    classStyle[EditText] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_TABSTOP,
                                      WS_BORDER,
                                      ES_AUTOHSCROLL,
                                      ES_LEFT})

    classStyleEx[EditText] = w32or_all({WS_EX_CLIENTEDGE,
                                        WS_EX_ACCEPTFILES})
    classAttr[EditText] = w32AutoSelect
    classDefPointer[EditText] = IDC_IBEAM
    classBGColor[EditText] = w32WinDefColor -- w32Color_WINDOW
classKbdInput[EditText] = DLGC_WANTARROWS+DLGC_WANTCHARS+DLGC_HASSETSEL--+DLGC_WANTMESSAGE

-- MSDN says that, if the user presses Alt-Backspace, the control also returns DLGC_WANTMESSAGE. I don't know what this is about.

-----------------------------------------------------------------------------
--/topic Controls
--/const MleText
--/desc Multi-line edit control.
-- An MleText (multi-line edit) control is like a mini-text editor.
-- The user can enter in multiple lines of text.
--
-- Since the Tab key is accepted as input into the MLE, the user has to
-- press Control+Tab to move to the next control, instead of the standard
-- Tab key.
--
-- A MleText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_HSCROLL: horizontal scroll bar
-- /li /b WS_VSCROLL: vertical scroll bar
-- /li /b ES_LEFT: left justify the text
-- /li /b WS_BORDER: draw with a border
-- /li /b ES_MULTILINE: allow multiple lines of text
-- /li /b WS_TABSTOP: the control can be tabbed to
-- /li /b WS_EX_CLIENTEDGE: 3D effect
-- /li /b WS_EX_ACCEPTFILES: drag and drop support

    className[MleText] = "edit"
    classType[MleText] = EDIT
    classStyle[MleText] = w32or_all({WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     WS_TABSTOP,
                                     WS_VSCROLL,
                                     WS_BORDER,
                                     ES_LEFT,
                                     ES_MULTILINE})
    classStyleEx[MleText] = w32or_all({WS_EX_CLIENTEDGE,
                                       WS_EX_ACCEPTFILES})
    classAttr[MleText] = w32CtrlTab
    classDefPointer[MleText] = IDC_IBEAM
    classBGColor[MleText] = w32Color_WINDOW
classKbdInput[MleText] = DLGC_WANTARROWS+DLGC_WANTCHARS+DLGC_HASSETSEL--+DLGC_WANTMESSAGE
-----------------------------------------------------------------------------
--/topic Controls
--/const LText
--/desc Left-justified label control.
-- An LText control does not respond to events.
--
-- An LText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_LEFT: left justify the text
-- /li /b SS_NOTIFY: Enable click events


    className[LText] = "static"
    classType[LText] = STATIC
    classStyle[LText] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   ES_LEFT,
                                   SS_NOTIFY})
    classAttr[LText] = 0
    classBGColor[LText] = w32BGTransparent
classKbdInput[LText] = DLGC_STATIC
-----------------------------------------------------------------------------
--/topic Controls
--/const RText
--/desc Right-justified label control.
-- An RText control does not respond to events.
--
-- An RText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_RIGHT: right justify the text
-- /li /b SS_NOTIFY: Enable click events

    className[RText] = "static"
    classType[RText] = STATIC
    classStyle[RText] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   ES_RIGHT,
                                   SS_NOTIFY})
    classAttr[RText] = 0
    classBGColor[RText] = w32BGTransparent
classKbdInput[RText] = DLGC_STATIC


-----------------------------------------------------------------------------
--/topic Controls
--/const CText
--/desc Center-justified label control.
-- A CText control does not respond to events.
--
-- A CText has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b ES_CENTER: center justify the text
-- /li /b SS_NOTIFY: Enable click events

    className[CText] = "static"
    classType[CText] = STATIC
    classStyle[CText] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   ES_CENTER,
                                   SS_NOTIFY})
    classAttr[CText] = 0
    classBGColor[CText] = w32BGTransparent
classKbdInput[CText] = DLGC_STATIC


-----------------------------------------------------------------------------
--/topic Controls
--/const HScroll
--/desc Horizontal scrollbar control.
-- An HScroll has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SBS_HORZ: horizontal scroll bar
-- /li /b WS_TABSTOP: the control can be tabbed to


-- horizontal scroll bar
    className[HScroll] = "scrollbar"
    classType[HScroll] = SCROLLBAR
    classStyle[HScroll] = w32or_all({WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     SBS_HORZ,
                                     WS_TABSTOP})
    classAttr[HScroll] = w32UseSubProc+w32NoRenderDisabled
    classBGColor[HScroll] = w32WinDefColor
classKbdInput[HScroll] = DLGC_WANTARROWS

-----------------------------------------------------------------------------
--/topic Controls
--/const VScroll
--/desc Vertical scrollbar control.
--
-- A VScroll has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SBS_VERT: vertical scroll bar
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[VScroll] = "scrollbar"
    classType[VScroll] = SCROLLBAR
    classStyle[VScroll] = w32or_all({WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     SBS_VERT,
                                     WS_TABSTOP})
    classAttr[VScroll] = w32UseSubProc+w32NoRenderDisabled
    classBGColor[VScroll] = w32WinDefColor
classKbdInput[VScroll] = DLGC_WANTARROWS

-----------------------------------------------------------------------------
--/topic Controls
--/const Icon
--/desc Icon control.
-- An Icon is a static small graphic. As a static control, it does
-- not respond to events.
--
-- An Icon has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SS_ICON: icon
-- /li /b SS_NOTIFY: Enable click events

    className[Icon] = "static"
    classType[Icon] = STATIC
    classStyle[Icon] = w32or_all({WS_CLIPPINGCHILD,
                                  WS_VISIBLE,
                                  SS_ICON,
                                  SS_NOTIFY})
    classAttr[Icon] = 0
    classKbdInput[Icon] = DLGC_STATIC

-----------------------------------------------------------------------------
--/topic Controls
--/const Bitmap
--/desc Static bitmap control.
-- A Bitmap does not respond to events.
--
-- A Bitmap has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b SS_BITMAP: bitmap
-- /li /b SS_NOTIFY: Enable click events

    className[Bitmap] = "static"
    classType[Bitmap] = STATIC
    classStyle[Bitmap] = w32or_all({WS_CLIPPINGCHILD,
                                    WS_VISIBLE,
                                    SS_BITMAP,
                                    SS_NOTIFY})
    classAttr[Bitmap] = 0
    classKbdInput[Bitmap] = DLGC_STATIC

-----------------------------------------------------------------------------
--/topic Controls
--/const Menu
--/desc Menu bar item control.
-- A Menu is an item in a window's menubar. There is no need to
-- declare a menubar for a window; if a Menu is created, the menubar
-- will automatically be created for it.


-- menu bar item
    className[Menu] = ""
    classType[Menu] = MENU
    classAttr[Menu] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const Popup
--/desc Popup menu control.
-- A Popup is a menu not attached to a window. To display a popup,
-- use /popup().

    className[Popup] = ""
    classType[Popup] = POPUP

    classAttr[Popup] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const MenuItem
--/desc Dropdown menu item control.
-- A MenuItem is an item in a window's Menu. Menu items are
-- placed sequentially into menus.

    className[MenuItem] = ""
    classType[MenuItem] = MENUITEM

    classAttr[MenuItem] = w32NoConv
-----------------------------------------------------------------------------

--/topic Controls
--/const MenuSpacer
--/desc Horizontal spacer (line) in menu items.
-- A MenuSpacer is placed as a horizontal line in a window's Menu.

    className[MenuSpacer] = ""
    classType[MenuSpacer] = MENUITEM

    classAttr[MenuSpacer] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const Pixmap
--/desc Color bitmap.
-- A Pixmap is an off-screen color bitmap. It can be displayed
-- in a window by using one of the /i bitblt functions (see
-- Graphics for details).

    className[Pixmap] = ""
    classType[Pixmap] = PIXMAP
    classAttr[Pixmap] = w32NoConv

-----------------------------------------------------------------------------
--/topic Controls
--/const ToolBar
--/desc Window toolbar control.
-- A ToolBar is a container at the top of a window that can hold
-- other controls - typically /PushButtons or /ToggleButtons.
-- Toolbars are implemented using the Win32 common control toolbar.
--
-- When the parent window is resized, Win32Lib automatically repositions
-- the ToolBar.
--
-- Note that the toolbar occupies space like any other control. To determine
-- what portion of the window's client area is not occupied by the toolbar
-- (and statusbar), use the /getClientRect function.
--
-- A ToolBar has the following attributes:
--
-- /li /b CCS_TOP: place on top of the window
-- /li /b CCS_NORESIZE: don't automatically resize (Win32Lib does it)
-- /li /b WS_CHILD: child control of parent
-- /li /b WS_BORDER: draw a border
-- /li /b WS_CLIPSIBLINGS: clip child controls

    className[ToolBar] = TOOLBARCLASSNAMEA
    classType[ToolBar] = COMMON_CONTROL
    classStyle[ToolBar] = w32or_all({CCS_TOP,
                                     CCS_NORESIZE,
                                     WS_CLIPPINGCHILD,
                                     WS_VISIBLE,
                                     WS_BORDER})

    classAttr[ToolBar] = w32NoConv+w32Clickable+w32OwnerId+w32Toolbar

-----------------------------------------------------------------------------
--/topic Controls
--/const StatusBar
--/desc Window status bar control.
-- A StatusBar is a control placed at the bottom of the window
-- that status messages can be written into.
-- The status bar is implemented using the Win32 common control toolbar.
--
-- When the parent window is resized, Win32Lib automatically repositions
-- the StatusBar.
--
-- Note that the status bar occupies space like any other control. To
-- determine what portion of the window's client area is not occupied by
-- the statusbar (and toolbar), use the /getClientRect function.
--
-- A StatusBar has the following attributes:
--
-- /li /b CCS_BOTTOM: place on bottom of the window
-- /li /b WS_CHILD: child control of parent
-- /li /b WS_BORDER: draw a border
-- /li /b WS_CLIPSIBLINGS: clip child controls

    className[StatusBar]    = STATUSCLASSNAMEA
    classType[StatusBar]    = COMMON_CONTROL
    classStyle[StatusBar] = w32or_all({WS_CLIPPINGCHILD,
                                       WS_VISIBLE,
                                       CCS_BOTTOM})

    classAttr[StatusBar] = w32Clickable+w32OwnerId+w32Statusbar
-----------------------------------------------------------------------------
--/topic Controls
--/const PictureButton
--/desc Command button with graphic control.
-- A PictureButton is a /PushButton with a graphic instead
-- of text. The graphic can be specified by passing the name or address of
-- a bitmap control in the /i flags parameter, or with /setBitmap,
-- /setIcon
--
-- A PictureButton is typically used in a /ToolBar.
--
-- This can show either an Icon or a Bitmap. The choice is made when
-- the control is created using the /create() routine. When being created,
-- the /i style parameter is used to designate the image and format of
-- images on the button. The /i style parameter can be one of ... /n
--/li /w32PB_BITMAP which indicates that the application will later explicitly
-- set a bitmap image to the button.
--/li 0 which is the same as /i w32PB_BITMAP
--/li /w32PB_ICON which indicates that the application will later explicitly
-- set an icon image to the button.
--/li A handle to a pre-loaded bitmap image.
--/li A handle to a pre-loaded icon image.
--/li A filename to either a .BMP or a .ICO file.
--
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[PictureButton] = "button"
    classType[PictureButton] = BUTTON
    classStyle[PictureButton] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           BS_PUSHBUTTON,
                                           WS_TABSTOP})
    classAttr[PictureButton] = w32PictCtrl
    classKbdInput[PictureButton] = DLGC_DEFPUSHBUTTON
-----------------------------------------------------------------------------
--/topic Controls
--/const ToggleButton
--/desc Toggle button control.
-- A ToggleButton is a /PushButton that behaves like a
-- /CheckBox - clicking it toggles it down, clicking again toggles
-- it back up. It is typically used in a /ToolBar.
--
-- This can show either an Icon or a Bitmap. The choice is made when
-- the control is created using the /create() routine. When being created,
-- the /i style parameter is used to designate the image and format of
-- images on the button. The /i style parameter can be one of ... /n
--/li w32PB_BITMAP which indicates that the application will later explicitly
-- set a bitmap image to the button.
--/li 0 which is the same as /i w32PB_BITMAP
--/li w32PB_ICON which indicates that the application will later explicitly
-- set an icon image to the button.
--/li A handle to a pre-loaded bitmap image.
--/li A handle to a pre-loaded icon image.
--/li A filename to either a .BMP or a .ICO file.
--
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b BS_BITMAP: displays a bitmap
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[ToggleButton] = "button"
    classType[ToggleButton] = BUTTON
    classStyle[ToggleButton] = w32or_all({WS_CLIPPINGCHILD,
                                          WS_VISIBLE,
                                          BS_PUSHLIKE,
                                          BS_AUTOCHECKBOX,
                                          WS_TABSTOP})

    classAttr[ToggleButton] = 0
    classKbdInput[ToggleButton] = DLGC_BUTTON+DLGC_WANTCHARS
-----------------------------------------------------------------------------
--/topic Controls
--/const TogglePicture
--/desc Toggle button with graphic control.
-- A TogglePicture is a combination of a /ToggleButton
-- and a /PictureButton. The graphic can be specified by passing the
-- name or address of a bitmap in the /i flags parameter, or with
-- /setBitmap, /setIcon
--
-- This can show either an Icon or a Bitmap. The chice is made when
-- the control is created using the /create() routine.
--
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b BS_PUSHBUTTON: button style is pushbutton
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[TogglePicture] = "button"
    classType[TogglePicture] = BUTTON
    classStyle[TogglePicture] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           BS_PUSHLIKE,
                                           BS_AUTOCHECKBOX,
                                           WS_TABSTOP})
    classAttr[TogglePicture] = w32PictCtrl
    classKbdInput[TogglePicture] = DLGC_BUTTON+DLGC_WANTCHARS

-----------------------------------------------------------------------------
--/topic Controls
--/const HTrackBar
--/desc Horizontal track bar control.
-- An HTrackBar has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b TBS_HORZ: vertical scrollbar
-- /li /b TBS_AUTOTICKS: ticks automatically created
-- /li /b TBS_ENABLESELRANGE: range highlighted, triangles at end of range
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[HTrackBar] = TRACKBAR_CLASSA
    classType[HTrackBar] = COMMON_CONTROL
    classStyle[HTrackBar] = w32or_all({WS_CLIPPINGCHILD,
                                       WS_VISIBLE,
                                       TBS_HORZ,
                                       TBS_AUTOTICKS,
                                       TBS_ENABLESELRANGE,
                                       WS_TABSTOP})
    classAttr[HTrackBar] = w32Clickable+w32OwnerId
    classKbdInput[HTrackBar] = DLGC_WANTARROWS
-----------------------------------------------------------------------------
--/topic Controls
--/const VTrackBar
--/desc Vertical track bar control.
-- A VTrackBar has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b TBS_VERT: vertical scrollbar
-- /li /b TBS_AUTOTICKS: ticks automatically created
-- /li /b TBS_ENABLESELRANGE: range highlighted, triangles at end of range
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[VTrackBar] = TRACKBAR_CLASSA
    classType[VTrackBar] = COMMON_CONTROL
    classStyle[VTrackBar] = w32or_all({WS_CLIPPINGCHILD,
                                       WS_VISIBLE,
                                       TBS_VERT,
                                       TBS_AUTOTICKS,
                                       TBS_ENABLESELRANGE,
                                       WS_TABSTOP})
    classAttr[VTrackBar] = w32Clickable+w32OwnerId
    classKbdInput[VTrackBar] = DLGC_WANTARROWS

-----------------------------------------------------------------------------
--/topic Controls
--/const TabControl
--/desc Tab Control.
-- A TabControl is a container control. It can have one or more /TabItems.
-- Selecting a /TabItem in a TabControl activates it, and displays any
-- controls that are associated with it.
--
-- Since the TabControl is a container, controls can be placed into it,
-- just like placing them into a window. However, it becomes the coder's
-- responsibility to show and hide various controls as different /TabItems
-- are selected. It is easier to associate controls with /TabItems, since
-- Win32Lib will automatically take care of those details.
--
-- The TabControl has the following attributes:
--
-- /li /b WS_CHILD: child control of the parent
-- /li /b WS_VISIBLE: it is visible
-- /li /b WS_CLIPCHILDEN: controls not fitting on the TabControl are clipped.
-- /li /b WS_TABSTOP: the control can be tabbed to

    className[TabControl] = WC_TABCONTROLA
    classType[TabControl] = COMMON_CONTROL
    classStyle[TabControl] = w32or_all({WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        WS_CLIPCHILDREN,
                                        WS_TABSTOP})
    classAttr[TabControl] = w32Clickable+w32OwnerId
    classKbdInput[TabControl] = DLGC_WANTARROWS+DLGC_WANTCHARS


-----------------------------------------------------------------------------
--/topic Controls
--/const TabItem
--/desc Tab on a TabControl.
-- A TabItem is a tab attached to the top of a /TabControl. TabItems respond
-- to being selected by triggering an /onClick event.
--
-- Items can be automatically displayed in a /TabControl by setting their
-- owner to the TabItem instead of the /TabControl. Win32Lib will
-- automatically reparent controls with TabItems to the TabControl, and
-- maintain a logical association between them. For example:
--
--/code
--  constant
--    Win     = create( Window, "Testing", 0, Default, Default, 100, 100, 0 ),
--    Tabs    = create( TabControl, "", Win, 10, 10, 80, 80, 0 ),
--    Tab1    = create( TabItem, "Tab Number &1", Tabs, 0, 0, 0, 0, 0 ),
--    Tab2    = create( TabItem, "Tab Number &2", Tabs, 0, 0, 0, 0, 0 ),
--    Button1 = create( PushButton, "Button 1", Tab2, 10, 60, 80, 40, 0 )
--
--/endcode
--
-- In the example above, Button1 is created in Tabs (the parent of Tab2).
-- When Tab2 is clicked, it will appear in Tabs at {10,60}. When Tab1 is
-- clicked, it will disappear from Tabs.

    className[TabItem] = "w32 TabItem"
    classType[TabItem] = -1 -- Not a real class
    classStyle[TabItem] = 0 -- WS_TABSTOP
    classAttr[TabItem] = w32Clickable+w32Virtual
    classBGColor[TabItem] = w32WinDefColor
    classKbdInput[TabItem] = DLGC_WANTARROWS+DLGC_WANTCHARS


-----------------------------------------------------------------------------
--/topic Controls
--/const ProgressBar
--/desc Progress Bar
-- A ProgressBar is used to show what amount of a task is complete.
-- To move the position of the ProgressBar indicator, call /setScrollPos.
-- By default, the ProgressBar ranges from 1 to 100. You can change the
-- range by calling /setScrollRange().
--
-- For the most part, the ProgressBar behaves like most other
-- /"Scroll Controls".
--
-- The following example creates a /Window that contains a /Timer and
-- a /ProgressBar. As the /Timer ticks, the ProgressBar is automatically
-- incremented.
--
--/code
--  constant
--      Win   = /create(/Window,"Timer Window",0,Default,Default,200,100,0),
--      PBar  = /create(/ProgressBar,"",Win,5,40,180,20,0),
--      Timer = 1
--
--  procedure tick( integer self, integer event, sequence parms)
--      integer timerId
--      timerId = parms[1]
--      -- advance the progress bar by 5 ticks
--      /setScrollPos( PBar, /getScrollPos( PBar ) + 5 )
--  end procedure
--  setHandler(Win, w32HTimer, routine_id( "tick" ))
--
--  -- tick once per second
--  /setTimer( Win, Timer, 1000 )
--
--  /WinMain( Win, Normal )
--/endcode

    className[ProgressBar] = PROGRESS_CLASSA
    classType[ProgressBar] = COMMON_CONTROL
    classStyle[ProgressBar] = w32or_all({WS_CHILD,WS_VISIBLE})

    classAttr[ProgressBar] = w32Clickable+w32OwnerId

-----------------------------------------------------------------------------
--/topic Controls
--/const ListView
--/desc ListView
-- A list view control is a window that displays collection of
-- items, each item consisting of an icon and a label.  List
-- view controls provide several ways of arranging items and
-- displaying individual items.  For example, additional information
-- about each item can be displayed in columns to the right of the
-- icon and label.
--
-- List views have 3 modes:
-- /li Icon
-- /li List
-- /li Report
--
-- Report mode can display multiple columns, which can be defined
-- upon creation of the control:
--
-- /code
--      Win = create( /Window, "The Window", 0, 0, 0, 300, 300, 0 ),
--      lv  = create( ListView, {"Column 1", Column 2"}, Win,
--                  20, 20, 200, 200, LVS_REPORT )
--      WinMain( Win, Normal )
-- /endcode
--
-- See also: /addIcon, /addLVItem, /deleteItem

    className[ListView] = WC_LISTVIEWA
    classType[ListView] = COMMON_CONTROL
    classStyle[ListView] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_BORDER,
                                      WS_TABSTOP,
                                      LVS_SHAREIMAGELISTS})
    classStyleEx[ListView] = WS_EX_CLIENTEDGE
    classAttr[ListView] = w32Clickable+w32OwnerId
    classBGColor[ListView] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[ListView] = DLGC_WANTTAB+DLGC_WANTARROWS

constant
    lv_Default_Properties = {0, -2, 0, 0},
    lvitem_MASK = w32or_all({LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM})

--/topic Constants
--/const kLVColTypes
--/desc Used by /setLVAttr

--/topic Constants
--/const kLVSortSeq
--/desc Used by /setLVAttr


sequence
        lv_id,
        lvitem_owner,
        lvitem_lparam,
        lv_properties,
        ilicon_list

        lv_id = {}
        lvitem_owner = {}
        lvitem_lparam = {}
        lv_properties = {}
        ilicon_list = {}
integer
        lvInsertWhere
        lvInsertWhere = 1
atom
        vNextLVItemID
        vNextLVItemID = 0

atom    ILlarge,hILlarge,
        ILsmall,hILsmall

        ILlarge = 0
        ILsmall = 0
        hILlarge = 0
        hILsmall = 0
-----------------------------------------------------------------------------
--/topic Controls
--/const TreeView
--/desc TreeView
-- A tree view control is a window that displays a hierarchical list
-- of items, such as the headings in a document, the entries in an index,
-- or the files and directories on a disc.  Each item consists of a label
-- and an optional bitmapped image, and each item can have a list of subitems
-- associated with it.  By clicking an item, the user can expand and collapse
-- the associated list of subitems.
--
-- See also: /addTVItem, /deleteItem, /hitTestTV


    className[TreeView] = WC_TREEVIEWA
    classType[TreeView] = COMMON_CONTROL
    classStyle[TreeView] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_TABSTOP,
                                      WS_BORDER})
    classStyleEx[TreeView] = WS_EX_CLIENTEDGE
    classAttr[TreeView] =  w32OwnerId
    classBGColor[TreeView] = w32Color_WINDOW
    classKbdInput[TreeView] = DLGC_WANTARROWS+DLGC_WANTCHARS

sequence tv_id, tvitem_data, tvitem_owner, tvitem_parent, tvitem_handle
constant
        ktv_Blank = repeat(0, 5),
        tvitem_MASK = w32or_all({TVIF_TEXT,
                                 TVIF_IMAGE,
                                 TVIF_SELECTEDIMAGE,
                                 TVIF_PARAM,
                                 TVIF_CHILDREN}),
        ktv_TextAddr  = 1,
        ktv_TextSize = 2,
        ktv_NormImage = 3,
        ktv_SelectImage = 4,
        ktv_HasChildren = 5


    tv_id = {}
    tvitem_owner = {}
    tvitem_data = {}
    tvitem_parent = {}
    tvitem_handle = {}

-----------------------------------------------------------------------------
--/topic Controls
--/const RichEdit
--/desc RichEdit
-- A rich edit control is a window in which the user can enter and edit
-- text.  The text can be assigned character and paragraph formatting,
-- and can include embedded OLE objects.  Rich edit controls provide a
-- programming interface for formatting text.  However, application
-- must implement any user interface components necessary to make formatting
-- operations available to the user.
--
-- Example:
--
--/code
--           -- Create the RichEdit control
--           RE = /create( /RichEdit, "", Win , 20, 20, 360, 200, ES_NOHIDESEL)
--/endcode

    className[RichEdit] = WC_RICHEDIT
    classType[RichEdit] = COMMON_CONTROL
    classStyle[RichEdit] = w32or_all({WS_CLIPPINGCHILD,
                                      WS_VISIBLE,
                                      WS_VSCROLL,
                                      ES_DISABLENOSCROLL,
                                      ES_AUTOVSCROLL,
                                      WS_TABSTOP,
                                      ES_SAVESEL,
                                      ES_MULTILINE,
                                      WS_BORDER})
    classStyleEx[RichEdit] = WS_EX_CLIENTEDGE
    classAttr[RichEdit] = w32CtrlTab+w32OwnerId
    classDefPointer[RichEdit] = IDC_IBEAM

    classBGColor[RichEdit] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[RichEdit] = DLGC_WANTALLKEYS+DLGC_WANTARROWS+DLGC_WANTCHARS+DLGC_HASSETSEL--(+DLGC_WANTMESSAGE)
-----------------------------------------------------------------------------
--/topic Controls
--/const MonthCalendar
--/desc MonthCalendar
-- MonthCalendar is a control used for selecting dates.  It displays
-- a calendar (one month at a time) from which the user can select a
-- date or a range of dates.
--
-- See also: /formatDate(), /getSelectedDate(), /getSelectedDateRange(),
--          /setMonthColor(), /setSelectedDate(), /setSelectedDateRange()

    className[MonthCalendar] = MONTHCAL_CLASS
    classType[MonthCalendar] = COMMON_CONTROL
    classStyle[MonthCalendar] = w32or_all({WS_CLIPPINGCHILD,
                                           WS_VISIBLE,
                                           WS_TABSTOP,
                                           WS_BORDER
                                          })
    classStyleEx[MonthCalendar] = MCS_DAYSTATE
    classAttr[MonthCalendar] =  w32OwnerId
    classKbdInput[MonthCalendar] = DLGC_WANTARROWS
--/topic Controls
--/const UpDown
--/desc UpDown
-- An Up-Down control is a pair of arrow buttons that the user can click
-- to increment or decrement a vaue, such as a scroll position or a number
-- displayed in a companion control.  The value associated with an up-down
-- control is called its /i current /i position.  An up-down control is
-- most often used with a companion control, which is called a /i buddy
-- /i window.  The updown control will take care of scroll events
-- automatically.
--
-- There are two ways to set a buddy window:
-- /li style flag /b UDS_AUTOBUDDY sets the buddy to the previous control
-- /li /setBuddy( id ) sets control id to the buddy window
--
-- Typical flags for an UpDown control are ...
--/code
--        w32or_all( {
--                    UDS_ALIGNRIGHT,
--                    UDS_SETBUDDYINT,
--                    UDS_ARROWKEYS,
--                    UDS_NOTHOUSANDS  -- Avoids a thousands separator.
--                })
--/endcode
--
-- See also: /getScrollPos, /setBuddy, /setScrollPos, /setScrollRange


    className[UpDown] = UPDOWN_CLASSA
    classType[UpDown] = COMMON_CONTROL
    classStyle[UpDown] = w32or_all({WS_CLIPPINGCHILD,
                                    WS_VISIBLE
                                   })
    classAttr[UpDown] = w32OwnerId
    classKbdInput[UpDown] = DLGC_WANTARROWS
-----------------------------------------------------------------------------
--/topic Controls
--/const ReBar
--/desc ReBar
-- Rebars are similar to toolbars, but can do some fancier things.  You
-- can put any sort of control into a rebar.
--
-- Example:
-- /code
--         -- create the rebar
--      rebar = /create( /ReBar, "", owner, x, y, cx, cy, flags )
--         -- create a band for the rebar
--      band = /create( /ReBarBand, caption, rebar, 0, 0, cx, cy, flags )
--         -- [NOTE: to create the band on a new line within the rebar,
--         -- use RBBS_BREAK ]
--         -- add controls to the bands.  Controls should be children
--         -- of the rebar.
--      combo = /create( /Combo, "", rebar, 0, 0, cx, cy, flags )
--      /addToBand( combo, band )
-- /endcode
--
-- See also: /addToBand(), /ReBarBand

    className[ReBar] = REBARCLASSNAME
    classType[ReBar] = COMMON_CONTROL
    classStyle[ReBar] = w32or_all({WS_CLIPPINGCHILD,
                                   WS_VISIBLE,
                                   WS_TABSTOP,
                                   WS_CLIPCHILDREN,
                                   CCS_ADJUSTABLE,
                                   WS_BORDER})
    classStyleEx[ReBar] = WS_EX_CLIENTEDGE
    classAttr[ReBar] = w32NoConv+w32OwnerId+w32Toolbar


--/topic Controls
--/const ToolTip
--/desc Creates a ToolTip control.
--This is not normally required as one is automatically created for
--your application whenever you use /setHint() or supply tooltip
--text when creating a control.

    className[ToolTip] = TOOLTIPS_CLASSA
    classType[ToolTip] = COMMON_CONTROL
    classStyle[ToolTip] = TTS_ALWAYSTIP
    classStyleEx[ToolTip] = WS_EX_TOPMOST
    classAttr[ToolTip] = w32NoConv


-----------------------------------------------------------------------------
--/topic Controls
--/const FlatToolbar
--/desc Creates a toolbar without a 3D border.


    className[FlatToolBar] = TOOLBARCLASSNAMEA
    classType[FlatToolBar] = COMMON_CONTROL
    classStyle[FlatToolBar] = w32or_all({
                                         CCS_TOP,
                                         CCS_NORESIZE,
                    --CCS_ADJUSTABLE,
                                         WS_CLIPPINGCHILD,
                                         WS_VISIBLE,
                                         WS_BORDER,
                                         WS_TABSTOP,
                                         TBSTYLE_FLAT,
                                         TBSTYLE_TOOLTIPS})
    classStyleEx[FlatToolBar] = TBSTYLE_EX_DRAWDDARROWS
    classAttr[FlatToolBar] = w32NoConv+w32Clickable+w32OwnerId+w32Toolbar

atom himlFTBDefault, himlFTBHot, himlFTBDisabled
sequence FTB_images

    himlFTBDefault = 0
    himlFTBHot = 0
    himlFTBDisabled = 0
    FTB_images = {}

--/topic Controls
--/const SepButton
--/desc Separator button for use with /FlatToolBar Controls
-- This should only be used with /FlatToolBar controls.  It creates
-- a divider between buttons, which is shown as a vertical line.
    className[SepButton]    = "button"
    classType[SepButton]    = BUTTON
    classStyle[SepButton] = TBSTYLE_SEP
    classAttr[SepButton] = w32NoConv+w32Clickable
    classKbdInput[SepButton] = DLGC_UNDEFPUSHBUTTON
--/topic Controls
--/const ComboBoxEx
--/desc Combobox with images
-- The /ComboBoxEx control works almost exactly like a normal /Combo, but
-- you can include images to be displayed along side the item text.
-- See /addItem for details.
    className[ComboBoxEx] = WC_COMBOBOXEX
    classType[ComboBoxEx] = COMMON_CONTROL
    classStyle[ComboBoxEx] = w32or_all({
                                        WS_CLIPPINGCHILD,
                                        WS_VISIBLE,
                                        CBS_DROPDOWN,
                                        CBS_NOINTEGRALHEIGHT,
                                        WS_TABSTOP})

    classAttr[ComboBoxEx] = w32Clickable+w32OwnerId
    classBGColor[ComboBoxEx] = w32WinDefColor -- w32Color_WINDOW
    classKbdInput[ComboBoxEx] = DLGC_WANTARROWS+DLGC_WANTCHARS

------------------------------------------
--/topic Constants
--/const CCflags
--/desc Used by function /classDefaults() to indicate Style Flags

--/topic Constants
--/const CCexflags
--/desc Used by function /classDefaults() to indicate Extended Style Flags

--/topic Constants
--/const CCwinstyle
--/desc Used by function /classDefaults() to set the style flags when
--registering a new window class.

global constant
    CCflags = 1,       -- The code for class Style Flags
    CCexflags = 2,     -- The code for Extended Style Flags
    CCwinstyle = 3     -- Used to set the registered class style for windows

--/topic System Attributes
--/func classDefaults(integer class, sequence pData)
--/desc Used to change the default values for style and extended style flags.
--/ret The current values of these flags prior to changing them.
-- /i class is the type of control whose defaults you want to change. /n
-- /i pData is a sequence that contains zero or more sub-sequences. Each
-- sub-sequence must have two elements, the first is the type of flag being
-- changed, and the other is the new value for the flag. The flag value can
-- be either an atom with all the flags /b"or'd", or a sequence of individual
-- flags. /n
-- The types of flags that can be changed are: /n
--/li CCflags - Standard control flags
--/li CCexflags - Extended control flags
--/li CCwinstyle - Only applies to Window - the class style flags.
--
-- Note, if /i pData is an empty sequence, the current flags are returned.
-- example:
--/code
--   sequence oldFlags
--   -- Make LText initially hidden and have a border when displayed.
--   oldFlags = classDefaults(LText, {
--                   {CCflags, {WS_CHILD, ES_LEFT}},
--                   {CCexflags, WS_EX_CLIENTEDGE}
--                      })
--   -- Change the default class flags for windows.
--   oldFlags = classDefaults(Window, {
--                   {CCwinstyle, {CS_HREDRAW,CS_DBLCLKS}}
--                      })
--/endcode

global function classDefaults(integer class_id, sequence pData)
sequence lCurDefaults

    -- Make sure only real class ids are supplied.
    if class_id<1 or class_id>length(w32ControlTypes) then
        return {} -- Bad ID supplied.
    end if

    -- Collect the current values before changing them.
    lCurDefaults = {{CCflags, w32get_bits(classStyle[class_id])},
                    {CCexflags, w32get_bits(classStyleEx[class_id])},
                    {CCwinstyle, vWindowClassStyle}
                   }

    -- Change the defaults.
    for i=1 to length(pData) do
        -- Only looking for sequences
        if sequence(pData[i]) then
            -- of two elements
            if length(pData[i])=2 then
                -- Is this the Style Flags?
                if pData[i][1]=CCflags then
                    if atom(pData[i][2]) then
                        classStyle[class_id] = pData[i][2]
                    else
                        classStyle[class_id] = w32or_all(pData[i][2])
                    end if
                -- Is this the Extended Style Flags?
                elsif pData[i][1]=CCexflags then
                    if atom(pData[i][2]) then
                        classStyleEx[class_id] = pData[i][2]
                    else
                        classStyleEx[class_id] = w32or_all(pData[i][2])
                    end if
                -- Is this the Class Style flags
                elsif pData[i][1]=CCwinstyle then
                    if atom(pData[i][2]) then
                        vWindowClassStyle = w32get_bits(pData[i][2])
                    else
                        vWindowClassStyle = pData[i][2]
                    end if
                end if
            end if
        end if
    end for

    -- Return with what the defaults used to be.
    return lCurDefaults
end function

-----------------------------------------------------------------------------
--/topic Controls
--/const Screen
--/desc Identifes the screen.
-- The /Screen refers to the computer screen. It is automatically created,
-- and most graphic methods that work in /Windows will also work with
-- the screen.
--
-- When defining an event handler for Screen, that handler will be invoked whenever a control
-- in your application reports something relevant. Clicking on a non win32lib window won't 
-- be detected, for instance.
--
-- Example:
--/code
--          -- Draw an 'x' across the screen
--          sequence size
--
--          -- get the screen width & height
--          size = /getCtlSize( /Screen )
--
--          -- set the pen color to red
--          /setPenColor( /Screen, Red )
--
--          -- draw the lines
--          /drawLine( /Screen, 0, 0, size[1], size[2] )
--          /drawLine( /Screen, size[1], 0, size[2], 0 )
--/endcode

-----------------------------------------------------------------------------
--/topic Controls
--/const Printer
--/desc Handle to the printer.
-- The /Printer refers to the selected printer. Before it can be used,
-- you must first select a printer.After you are done
-- printing, you should release the /Printer with /releasePrinter. To select a printer, you can
-- either prompt user using /getPrinter, orselect a printer, possibly using /newPrinter(),
-- and then calling /getDefaultPrinter().
--
-- Each document should be begin and end with a /startDoc and /endDoc
-- pair. Likewise, each page should begin and end with a /startPage and
-- /endPage pair.
--
-- For the sake of space, the example doesn't use the values returned
-- by /getPrinter.
--
-- Example:
--
--/code
--    -- example of using printer
--    sequence result
--
--    -- select the printer
--    result = /getPrinter()
--
--    -- did the user select a printer?
--    if length( result ) then
--
--        -- start a new document
--        if not /startDoc( sprintf( "My Job, Copy %s", {i} ) ) then
--            exit
--        end if
--
--        -- start a new page
--        if not /startPage() then
--            exit
--        end if
--
--        -- print on the page
--        /wPuts( /Printer, "Hello, Printer!" )
--
--        -- close the page
--        if not /endPage() then
--            exit
--        end if
--
--        -- close the document
--        if not /endDoc() then
--            exit
--        end if
--
--        -- release the printer
--        /releasePrinter()
--
--    end if
--
--/endcode


-----------------------------------------------------------------------------
atom
    WndProcAddress,     -- 32 bit address of Window callback
    SubProcAddress      -- 32 bit address of Control callback


-----------------------------------------------------------------------------
-- vectors


integer mainWindow
sequence vRecent vRecent = {0, 0, 0, {-1}}
global constant
    w32RecentMenu = 1,
    w32RecentWindow = 2,
    w32RecentTabControl = 3,
    w32RecentForms = 4,
    w32GetMainWindow    = "GetMainWindow"

integer
    modalWindow,
    modalStyle,
    modalDepth
atom
    modalhWnd

sequence
    modalStack

    mainWindow  = 0     -- no main window set yet
    modalStack  = {}    -- modals under modal window
    modalWindow = 0     -- no modal windows
    modalhWnd   = 0     -- no modal window handles
    modalStyle  = 0     -- Modal Style
    modalDepth  = 0     -- Depth of the Dialog stack

-- controls
integer focus_current focus_current = -1
integer vPrevCtlBlkLength
sequence
    ctlblk_freelist,            -- A list of the free control blocks.
    ctrl_Handle,              -- hwnd of controls
    ctrl_Handle_type,         -- Type of handle
    ctrl_Destroyed,           -- true if destroyed
    ctrl_Function,                -- Long pointer to function
    ctrl_Family,              -- control class
    ctrl_Type,                -- win32lib type
    ctrl_Focus_order,         -- focus order of controls
    ctrl_Current_focus,       -- current focus
    ctrl_Previous_focus,      -- the previous current focus.
    ctrl_Parent,              -- owner
    ctrl_Menu,                -- for windows: the menu bar handle. For controls with an image list, that IL handle for small/default.
    ctrl_Popup,               -- records attached popmenus
    ctrl_Notify_List,         -- a list of ids that want to be notified of events
    ctrl_Toolbar,             -- toolbars/rebars in window
    ctrl_Statusbar,           -- statusbar in window
                              -- For subclassed LV, the handle to the large icon image list.
                              -- For RichEdit controls, the persistent data for the Find/Replace boxes
    ctrl_Hint_Text,             -- tooltip text or flattoolbar button's caption
    ctrl_Hint_Width,          -- tooltip width in pixels
    ctrl_Font,                -- font resource
    ctrl_Fg_Color,              -- foreground color
    ctrl_Bg_Color,              -- background color
    ctrl_Pen,                 -- pen: { id, color, style }
    ctrl_X_Pos,                   -- x position
    ctrl_Y_Pos,                   -- y position
    ctrl_Erase,               -- True if user self-erases background.
    ctrl_Scroll,              -- scroll: { small, large }  or {{vSmall, vLarge},{hSmall, hLarge}} for Windows
    ctrl_Range,               -- scroll range { low, high } or {{vLow, vHigh},{hLow, hHigh}} for Windows.
    ctrl_Specific,            -- tabs in tab control, autoselect property for edit controls and previous rectangle to restore from for Windows. LVinsert flag override for ListViews. Also initial style flag for Windows created in forms. Also, dropped state for lists/combos.
    ctrl_Group,               -- items grouped with window, but not owned
    ctrl_Cursor,              -- cursor associated with window
    ctrl_Hotkey_Keys,         -- hotkeys associated with the window
    ctrl_Hotkey_Ids,          -- ids associated with hotkeys
    ctrl_Text_Alignment,           -- alignment of text
    ctrl_Closed,              -- true if window has been closed.
    ctrl_TabKey_Used,          -- true if control uses raw tab keys,
                --   false if CTRL-tabkey must be used.
    ctrl_Handlers,        -- Routine IDs for event handlers.
    ctrl_Bg_Brush,              -- Brush for background.
    ctrl_UserData,                 -- User defined data for control
    ctrl_IntData,                -- User defined data for control
    ctrl_Name,                -- User-defined name for this control
    ctrl_Init_Posns,                -- Contains the initial children control positions
    ctrl_ClassAddr,               -- RAM Address of Window class name string
    ctrl_Mousetrap,               -- List of target mousetraps in a window.
    -- added CChris <oedoc@free.fr> Oct 26, 2006
    ctrl_Visible,                 -- user-defined visibility
    ctrl_SetVisible,              -- visibility as set by some set the control belongs to
    ctrl_HandlerStates,            -- same structure as ctrl_handlers, contains 1s for enables and 0s for disabled
    ctrl_ActualClass,              -- class that hides behind the known one in ctrl_Type
    ctrl_CanFocus,                  -- 1 if control is allowed to get focus
    ctrl_KbdInput,                  -- value or routine_id to return on a WM_GETDLGCODE
    ctrl_FormerId,                  -- former id for subclassed controls that have one, or -1 (have not) or 0 (created by this application).
    ctrl_Hatch,                     -- hatch brush for background filling
    ctrl_RecursivePaint,            -- 1 to allow recursion during paint, else(default) 0.
    ctrl_ProtectHandlers,           -- flags requesting to protect handlers
    ctrl_ImageList                  -- handle to control image list (small for listviews, normal for toolbars)

    -- initialize
    vPrevCtlBlkLength   = 3
    ctlblk_freelist     = {0}
    ctrl_Handle       = {}
    ctrl_Handle_type  = {}
    ctrl_Destroyed    = {}
    ctrl_Function         = {}
    ctrl_Family        = {}
    ctrl_Type         = {}
    ctrl_Focus_order  = {}
    ctrl_Current_focus        = {}
    ctrl_Previous_focus   = {}
    ctrl_Parent        = {}
    ctrl_Menu         = {}
    ctrl_Popup        = {}
    ctrl_Notify_List     = {}
    ctrl_Toolbar      = {}
    ctrl_Statusbar    = {}
    ctrl_Hint_Text      = {}
    ctrl_Hint_Width   = {}
    ctrl_Font         = {}
    ctrl_Fg_Color       = {}
    ctrl_Bg_Color       = {}
    ctrl_Pen          = {}
    ctrl_X_Pos            = {}
    ctrl_Y_Pos            = {}
    ctrl_Erase        = {}
    ctrl_Scroll       = {}
    ctrl_Range        = {}
    ctrl_Specific     = {}
    ctrl_Group        = {}
    ctrl_Cursor       = {}
    ctrl_Hotkey_Ids   = {}
    ctrl_Hotkey_Keys  = {}
    ctrl_Text_Alignment    = {}
    ctrl_Closed       = {}
    ctrl_TabKey_Used   = {}
    ctrl_Handlers = {}
    ctrl_Bg_Brush       = {}
    ctrl_UserData          = {}
    ctrl_IntData         = {}
    ctrl_Name         = {}
    ctrl_Init_Posns         = {}
    ctrl_ClassAddr        = {}
    ctrl_Mousetrap       = {}
    -- added CChris <oedoc@free.fr> Oct 26, 2006
    ctrl_Visible        = {}
    ctrl_SetVisible       = {}
    ctrl_HandlerStates    = {}
    ctrl_ActualClass     = {}
    ctrl_CanFocus     = {}
    ctrl_KbdInput     = {}
    ctrl_FormerId     = {}
    ctrl_Hatch     = {}
    ctrl_RecursivePaint = {}
    ctrl_ProtectHandlers = {}
    ctrl_ImageList = {}

-- 'structure' indexes for user defined properties held in tag field.
constant tagPropId = 3, tagPropInit = 2, tagPropData = 1

constant CONTROLINFOS = series:next_number(0)
global constant
   CONTROLINFO_handle       = series:next_number(CONTROLINFOS),
   CONTROLINFO_handle_type  = series:next_number(CONTROLINFOS),
   CONTROLINFO_destroyed    = series:next_number(CONTROLINFOS),
   CONTROLINFO_func         = series:next_number(CONTROLINFOS),
   CONTROLINFO_class        = series:next_number(CONTROLINFOS),
   CONTROLINFO_type         = series:next_number(CONTROLINFOS),
   CONTROLINFO_focus_order  = series:next_number(CONTROLINFOS),
   CONTROLINFO_focus        = series:next_number(CONTROLINFOS),
   CONTROLINFO_owner        = series:next_number(CONTROLINFOS),
   CONTROLINFO_menu         = series:next_number(CONTROLINFOS),
   CONTROLINFO_toolbar      = series:next_number(CONTROLINFOS),
   CONTROLINFO_statusbar    = series:next_number(CONTROLINFOS),
   CONTROLINFO_tooltip      = series:next_number(CONTROLINFOS),
   CONTROLINFO_font         = series:next_number(CONTROLINFOS),
   CONTROLINFO_fcolor       = series:next_number(CONTROLINFOS),
   CONTROLINFO_bcolor       = series:next_number(CONTROLINFOS),
   CONTROLINFO_pen          = series:next_number(CONTROLINFOS),
   CONTROLINFO_x            = series:next_number(CONTROLINFOS),
   CONTROLINFO_y            = series:next_number(CONTROLINFOS),
   CONTROLINFO_erase        = series:next_number(CONTROLINFOS),
   CONTROLINFO_scroll       = series:next_number(CONTROLINFOS),
   CONTROLINFO_range        = series:next_number(CONTROLINFOS),
   CONTROLINFO_tabitems     = series:next_number(CONTROLINFOS),
   CONTROLINFO_group        = series:next_number(CONTROLINFOS),
   CONTROLINFO_cursor       = series:next_number(CONTROLINFOS),
   CONTROLINFO_hotkey_keys  = series:next_number(CONTROLINFOS),
   CONTROLINFO_hotkey_ids   = series:next_number(CONTROLINFOS),
   CONTROLINFO_textalign    = series:next_number(CONTROLINFOS),
   CONTROLINFO_closed       = series:next_number(CONTROLINFOS),
   CONTROLINFO_tabenabled   = series:next_number(CONTROLINFOS),
   CONTROLINFO_eventhandler = series:next_number(CONTROLINFOS),
   CONTROLINFO_bbrush       = series:next_number(CONTROLINFOS),
   CONTROLINFO_classinfo    = series:next_number(CONTROLINFOS),
   CONTROLINFO_tag          = series:next_number(CONTROLINFOS),
   CONTROLINFO_tooltipwid   = series:next_number(CONTROLINFOS),
   CONTROLINFO_lost_focus   = series:next_number(CONTROLINFOS),
   CONTROLINFO_itag         = series:next_number(CONTROLINFOS),
   CONTROLINFO_name         = series:next_number(CONTROLINFOS),
   CONTROLINFO_deferredhandlers = series:next_number(CONTROLINFOS),
   CONTROLINFO_autoheight   = series:next_number(CONTROLINFOS),
   CONTROLINFO_autowidth    = series:next_number(CONTROLINFOS),
   CONTROLINFO_init         = series:next_number(CONTROLINFOS),
   CONTROLINFO_popup        = series:next_number(CONTROLINFOS),
   CONTROLINFO_mousetrap    = series:next_number(CONTROLINFOS),
   CONTROLINFO_notifyid     = series:next_number(CONTROLINFOS),
   CONTROLINFO_handlerstates = series:next_number(CONTROLINFOS),
   CONTROLINFO_formerId = series:next_number(CONTROLINFOS),
   CONTROLINFO_alias = series:next_number(CONTROLINFOS)

constant
    kht_Window = 1,
    kht_Bitmap = 2,
    kht_Menu   = 3,
    kht_TabItem = 4,
    kht_ImageList = 5


-----------------------------------------------------------------------------
-- Tool tips
global integer
    tooltipControl     -- id of tooltip control
-- defaults
    tooltipControl  = 0
-----------------------------------------------------------------------------
-- Pen Colors

global constant
    Black           = rgb(#00, #00, #00),
    NavyBlue        = rgb(#00, #00, #60),
    Blue            = rgb(#00, #00, #80),
    BrightBlue      = rgb(#00, #00, #FF),
    ForestGreen     = rgb(#00, #60, #00),
    Green           = rgb(#00, #80, #00),
    Cyan            = rgb(#00, #80, #80),
    SkyBlue         = rgb(#00, #80, #FF),
    BrightGreen     = rgb(#00, #FF, #00),
    BrightCyan      = rgb(#00, #FF, #FF),
    DarkGray        = rgb(#40, #40, #40),
    Eggplant        = rgb(#70, #20, #70),
    Red             = rgb(#80, #00, #00),
    Magenta         = rgb(#80, #00, #80),
    DarkBrown       = rgb(#80, #50, #00),
    Olive           = rgb(#80, #80, #00),
    Gray            = rgb(#80, #80, #80),
    Brown           = rgb(#B0, #70, #00),
    LightGray       = rgb(#C0, #C0, #C0),
    Purple          = rgb(#D0, #80, #D0),
    White           = rgb(#E0, #E0, #E0),
    BrightRed       = rgb(#FF, #00, #00),
    BrightMagenta   = rgb(#FF, #00, #FF),
    Violet          = rgb(#FF, #80, #FF),
    Orange          = rgb(#FF, #B0, #60),
    Pink            = rgb(#FF, #B0, #B0),
    Yellow          = rgb(#FF, #FF, #00),
    Parchment       = rgb(#FF, #FF, #E0),
    BrightWhite     = rgb(#FF, #FF, #FF)

--/topic Attributes
--/const w32ColorValues
--/desc List of all known color values, in the same order as /w32ColorNames.
global sequence w32ColorValues
w32ColorValues = {
                  Black,
                  NavyBlue,
                  Blue,
                  BrightBlue,
                  ForestGreen,
                  Green,
                  Cyan,
                  SkyBlue,
                  BrightGreen,
                  BrightCyan,
                  DarkGray,
                  Eggplant,
                  Red,
                  Magenta,
                  DarkBrown,
                  Olive,
                  Gray,
                  Brown,
                  LightGray,
                  Purple,
                  White,
                  BrightRed,
                  BrightMagenta,
                  Violet,
                  Orange,
                  Pink,
                  Yellow,
                  Parchment,
                  BrightWhite,
                  0  -- Default value.
}

--  Pen Styles
global constant
    Solid        = 0,
    Dash         = 1,                   --  -------
    Dot          = 2,                   --  .......
    DashDot      = 3,                   --  _._._._
    DashDotDot   = 4                    --  _.._.._



--/Topic Constants
--/const Default
--/desc Indicates the use of the Windows default position values when creating /Controls.

global constant
    Default = CW_USEDEFAULT,
    Center = "center"

procedure setSWStyle(integer id,integer flag)
    ctrl_Specific[id] = flag
end procedure
registerRoutine("setSWStyle",routine_id("setSWStyle"))



--/topic System Attributes
--/func getMainWindow()
--/desc Gets the id of the main window for this application.
--/ret INTEGER: ID of main window.
--
--Example
--/code
--      win = getMainWindow()
--/endcode
global function getMainWindow()
    return mainWindow
end function

--/topic System Attributes
--/func setMainWindow(integer New)
--/desc Used to tell the library which window is the primary one.
--This is only used if you wish to change the default window that
--is set by calling /WinMain().
--
--Example
--/code
--      integer CurWin
--      CurWin = setMainWindow( AltWindow )
--/endcode

global function setMainWindow(integer pNew)
integer lOld
    lOld = mainWindow
    mainWindow = pNew
    return lOld
end function

-- Changed CChris <oedoc@free.fr> Oct 26, 2006
-- If no form was created and w32RecentForm is used as argument, the function now consistently returns 0.

--/topic Utilities
--/func getRecent(integer owner_type)
--/desc Gets the most recently defined control of a specifc kind, and returns the requested id.
--/ret INTEGER: the id of the most recently created control of the specified type, or 0 if none was created so far.
--
-- The supported owner type specifications are:
--/li /b w32RecentMenu: id of the most recently created menu, or 0;
--/li /b w32RecentWindow: id of the most recently created window, or 0;
--/li /b w32RecentTabControl: id of the most recently created TabControl, or 0;
--/li /b w32RecentForms: id of the most recently created form window, or {-1}.
global function getRecent(integer pType)
    if find(pType, {w32RecentMenu, w32RecentWindow, w32RecentTabControl, w32RecentForms}) then
        return vRecent[pType]
    end if
    return 0
end function

procedure setRecent(integer pType,integer x)
    if find(pType, {w32RecentMenu, w32RecentWindow, w32RecentTabControl}) then
        vRecent[pType] = x
    elsif pType=w32RecentForms then
        vRecent[pType] &= x
    end if
end procedure
registerRoutine("setRecent",routine_id("setRecent"))

procedure clearRecents()
    vRecent[w32RecentMenu] = 0
    vRecent[w32RecentWindow] = 0
    vRecent[w32RecentTabControl] = 0
end procedure
registerRoutine("clearRecents",routine_id("clearRecents"))

--/topic System Attributes
--/func validId(object id)
--/desc Tests to see if the specified id is a valid one.
--/ret w32True if valid, w32False otherwise.

-----------------------------------------------------------------------------
global function validId(object id)
    -- returns true for valid Ids
    if sequence(id) then
        if length(id)!=2 then
            return w32False
        elsif not integer(id[2]) or id[2]<1 or id[2]>length(tvitem_data) then
            return w32False
        elsif ctrl_Type[id[1]]!=TreeView or tvitem_owner[id[2]]!=id[1] then
            return w32False
        else
            return w32True
        end if
    elsif not integer(id) then
        return w32False
    end if
    if id<=0 then
        return w32False
    end if
    if id>length(ctrl_Handle) then
        return w32False
    end if
    if ctrl_Destroyed[id]<0 then
        return w32False
    end if
    if ctrl_Handle[id]=0 then
        return w32False
    end if
    if ctrl_Parent[id]=0 then
        return w32True
    end if
    return validId(ctrl_Parent[id])
end function

-----------------------------------------------------------------------------
procedure setId(atom hWnd, integer id)
    VOID = w32Func(xSetWindowLong, {hWnd, GWL_USERDATA, id})
end procedure

--/topic Utilities
--/func getHandles()
--/desc Gets all the hWnd handles for every control created in your application.
--/ret A sequence of atoms.
-- Handles for destroyed controls, or controls that don't exist, appear as 0.
--/code
--        addBtn = create(PushButton, "", 100,100, 40,40,0)
--        allHandles = getHandles()
--        otherfunc( allHandles[ addBtn ], ... )
--/endcode
global function getHandles()
    return ctrl_Handle
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getId( object hWnd )
--/desc Finds the control/window ID given a Window Handle.
--/ret INTEGER: The Id corresponding to the /i hWnd supplied.
-- If the supplied hWnd is invalid or not belonging to a control
-- created by win32lib, this function will return zero.
--
-- /b"Note 1" this can be used to find a TreeView Item's Id from it's handle by
-- using the syntax:  id = getId( {TV, hTVI} )
--
--/b"Note 2" if /i hWnd is the special value /b w32GetMainWindow, it will return the
-- Id of the main window as used in the /WinMain() routine. This is useful if you
-- are writing an add-on library to this one.
--


constant qGetWindowLong = define_c_func(open_dll("user32.dll"), "GetWindowLongA", {C_POINTER, C_LONG}, C_LONG)

-- Added CChris <oedoc@free.fr> Oct 26, 2006
-- These record ids and handles of menus, so that the pairing is always guaranteed
sequence menu_ids menu_ids = {}
sequence menu_handles menu_handles = {}

global function getId(object hWnd)
atom lId

    if sequence(hWnd) and length(hWnd)=2 then
        return find(hWnd[2], tvitem_handle)
    elsif not equal(hWnd, w32GetMainWindow) then
        --lId = w32Func( xGetWindowLong, { hWnd, GWL_USERDATA } )

-- Changed CChris <oedoc@free.fr> Oct 26, 2006
-- Now returns a valid id if hWnd refers to a menu
        lId = find(hWnd,menu_handles)
        if lId then
            return menu_ids[lId]
        end if
        lId = c_func(qGetWindowLong, {hWnd, GWL_USERDATA})
        if not integer(lId) then
            lId = 0
        end if
        return lId
    else
        return mainWindow
    end if
end function

--/topic System Attributes
--/func getHWND(integer controlID)
--/desc Returns the Windows Handle of the specified control
--/ret The control's hWnd
-- This function is almost the same as /getHandle except that it does /b not
-- validate the /i controlID value supplied to it, and it cannot be used
-- to get the handle of a Treeview item. /n
-- You would use this function if you already knew that the /i controlID was
-- valid and you needed a faster routine than /getHandle.
--
--Example
--/code
--      atom hWnd
--      hWnd = getHWND(myWindow)
--/endcode

global function getHWND(object id)
    return ctrl_Handle[id]
end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getHandle(integer controlID OR sequence {TVid, TVItemID} )
--/desc Returns the Windows Handle of the specified control
--/ret The control's hWnd
-- This aborts the application if the specified id is invalid.
--
-- This can also return the handle of a treeview item by using the
-- syntax {tv, tvitem}
--
--Example
--/code
--      atom hWnd, hTV
--      hWnd = getHandle(myWindow)
--      hTV = getHandle( {myTreeView, Itemx} )
--/endcode

global function getHandle(object id)
atom hWnd
-- return the handle for the window
-- generates warning if not a valid id or handle
-- in range?

-- Special case. A zero id returns a zero handle.
    if equal(id, 0) then
        return 0
    end if

    if sequence(id) and
    length(id)=2 and
    validId(id[1]) and
    ctrl_Type[id[1]]=TreeView and
    id[2]>0 and
    id[2]<=length(tvitem_handle) and
    tvitem_owner[id[2]]=id[1] then
        return tvitem_handle[id[2]]
    end if

    if validId(id) then
        -- Get the stored value of the handle.
        if ctrl_Type[id]=TabItem then
            -- Use the tab control's handle.
            hWnd = ctrl_Handle[ctrl_Parent[id]]
        else
            hWnd =  ctrl_Handle[id]
        end if

        -- if its a control handle, then getID must work too.
        if  ctrl_Handle_type[id]!=kht_Window
        or getId(hWnd)=id then
            if hWnd= -1 then
                hWnd = 0
            end if
        else
            warnErr(append(Err_GETHCHANGED, {id, getId(hWnd)}))
        end if
        return hWnd

    else
        if compare(id,0)>0 and compare(id,length(ctrl_Handle))<=0  then
            if ctrl_Destroyed[id]<0 then
                warnErr(Err_GETHOBJECTDESTROYED)
            end if

            if ctrl_Handle[id]=0 then
                warnErr(Err_GETHNULLHANDLE)
            end if
        end if

        warnErr(Err_GETHFAIL)
    end if

    return 0 -- Bad handle
end function

include w32file.ew

--/topic System Attributes
--/func getIdName(integer controlID)
--/desc Returns the name of a control, given it's id.
--/ret SEQUENCE: The control's name /b or INTEGER: No name available.
--/b "Also see:" /setIDName and /newUIObj
--
--A return of "" means that the /i controlID was not valid. /n
--A return of 0 means that the /i controlID has no name.
--
--Example
--/code
--      sequence name
--      name = getIdName(myWindow)
--/endcode

global function getIdName(integer id)
    if validId(id) then
        return ctrl_Name[id]
    else
        return ""
    end if
end function

--/topic Miscellaneous
--/func makeStandardName(sequence Name)
--/desc Transforms a string into a standardized format suitable for naming things.
--/ret SEQUENCE: A Standard Name format
--/i Name is any string. It is converted to a standard form by removing any characters
--that are not alphanumeric, except that the first character can only be alphabetic or
-- the underscore character.
--
--Example:
--/code
--      sequence lName
--      lName = makeStandardName("Customer Dialog #1")
--      -- This should return "CustomerDialog1"
--/endcode

global function makeStandardName(sequence pName)
integer i

    pName = w32trim(pName)
    -- Remove any chars that cannot be in names.
    i = 1
    while i<=length(pName) do
        if not w32CType(pName[i], NameChar_CT) then
            pName = w32removeIndex(i, pName)
        else
            if i=1 and (w32CType(pName[1], Digit_CT) or w32CType(pName[1], Punct_CT)) then
                pName = w32removeIndex(1, pName)
            else
                i += 1
            end if
        end if
    end while

    return pName
end function

--/topic System Attributes
--/proc setIdName(integer controlID, sequence Name)
--/desc Sets the name of a control, given it's id.
--/b "Also see:" /getIDName and /newUIObj /n
-- This routine ensures that only alphanumeric and '_' characters are in the name. All
-- other characters stripped off the /Name parameter.
--
--Example
--/code
--      sequence name
--      setIdName(myWindow, "Prime Window")
--/endcode

global procedure setIdName(integer id, sequence pName)
    ctrl_Name[id] = makeStandardName(pName)
end procedure

--/topic System Attributes
--/func getNameId(sequence Name)
--/desc Returns the id of a control, given it's name.
--/ret SEQUENCE: The control's ID.
--/b "Also see:" /setIdName, /getIdName and /newUIObj
--
--A return of zero indicates that the name was not found. /n
--If more than one control has the same name, the result is
--still returned but it may be any of those controls. In this
--case it might be better to use /getNameIdInContext().
--
--Example
--/code
--      integer id
--      id = getNameId("Prime Window")
--/endcode

global function getNameId(sequence pName)
integer p

    pName = makeStandardName(pName)
    p = find(pName, ctrl_Name)
    if p=0 then
        return 0
    end if
    while not validId(p) do
--/**/  p = find(pName, ctrl_Name,p+1)      --/* -- Phix
        p=find_from(pName, ctrl_Name,p+1)   --*/ -- RDS
        if p=0 then
            return 0
        end if
    end while
    return p
end function

--/topic System Attributes
--/func getNameIdInContext(sequence Name, integer Parent)
--/desc Returns the id of a control, given it's name and parent control.
--/ret SEQUENCE: The control's ID.
--/b "Also see:" /setIdName, /getNameId, /getIdName and /newUIObj
--
--A return of zero indicates that the name was not found.
--
--Example
--/code
--      integer id
--      id = getNameIdInContext("AcceptButton", CustomerWindow)
--/endcode

global function getNameIdInContext(sequence pName, object pParent)
--  integer lParent
sequence lName
sequence lDependents
integer  lEnd, lStart

-- Standardize the supplied name.
    lName = makeStandardName(pName)


    -- Build a list of candidate controls
    if sequence(pParent) then
        pParent = getNameId(makeStandardName(pParent))
    end if
    if pParent<=0 then
        if vRecent[w32RecentWindow]>0 then
            pParent = vRecent[w32RecentWindow]
        elsif mainWindow>0 then
            pParent = mainWindow
        else
            pParent = 1
        end if
    end if
    lDependents = {pParent}
    lStart = 1
    lEnd = 0
    while lEnd<length(lDependents) do
        lEnd = length(lDependents)
        for i=lStart to lEnd do
            lDependents &= ctrl_Group[lDependents[i]]
        end for
        lStart = lEnd+1
    end while

    -- Start searching for the name in this context.
    for i=1 to length(lDependents) do
        lStart = lDependents[i]
        if equal(lName, ctrl_Name[lStart]) then
            return lStart
        end if
    end for

    return 0

end function

--/topic Low Level Routines
--/func sendMessage( object id, atom command, object wParam, object lParam )
--/desc Send a Win32 message to the requested control.
--/ret ATOM: Win32 result code.
--
-- /i id is either a control ID, or a control Name. /n
-- /i command is the Windows Message code to send. /n
-- /i wParam and lParam are the appropriate data items for the specific
-- /i command you are sending. These can be either atom values or text strings.
--
--There are hundreds of Windows message codes. Each type of control responds to
-- commands that are specific to it. There are too many to document here but
-- they can be found in many publications - the easiest might be the Microsoft
-- SDK documentation found at /b "http://msdn.microsoft.com". <a href="..\win32_constants.htm#Common Windows messages">Here</a>
-- is a list of messages understood bu win32lib, but it is not a comprehensive listing.
-- As a matter of fact, there is not a single, authoritative, official, comprehensive listing.
--
--Example:
--/code
--      res = sendMessage(myToolbar, TB_ADDSTRING, 0, "Test String" )
--/endcode

constant qSendMessage = define_c_func(open_dll("user32.dll"),
                                      "SendMessageA", {C_POINTER, C_UINT, C_LONG, C_LONG}, C_LONG)

global function sendMessage(object id, atom pCmd, object wParm, object lParm)
-- send a command to a control
atom memset
atom lRetVal

    if sequence(id) then
        id = getNameId(id)
    end if

--    if validId(id) then
--    if id > 0 then
    memset = 0
    -- Check for text being passed.
    if sequence(wParm) then
        memset = w32new_memset()
        wParm = w32acquire_mem(memset, wParm)
    end if
    if sequence(lParm) then
        if memset=0 then
            memset = w32new_memset()
        end if
        lParm = w32acquire_mem(memset, lParm)
    end if

    lRetVal = c_func(qSendMessage, {ctrl_Handle[id], pCmd, wParm, lParm})
    if memset!=0 then
        w32release_mem(memset)
    end if
    return lRetVal
--    else
--        return 0
--    end if
end function

-----------------------------------------------------------------------------
procedure pushSelf(integer id)
    -- push the current self and return value onto stack
    if SP=length(idStack) then
        idStack &= repeat(0, 10)
        returnStack &= repeat(0, 10)
    end if
    SP += 1
    idStack[SP] = id
    returnStack[SP] = 0
end procedure

-----------------------------------------------------------------------------
function popSelf()
    -- pop the current id from the stack
    -- return the return value

    -- get the return value
    if SP<=0 then
        abortErr(Err_STACKERR)
    end if

    -- pop the self and return stacks
    SP -= 1
    return returnStack[SP+1]

end function

-----------------------------------------------------------------------------
--/topic Events
--/proc returnValue( value )
--/desc Override default value returned by handler.
-- This allows you to override the value an event handler returns to Win32.
-- By default, when an event is processed, it goes through these steps:
--
--/li Registered Control Process: if the control class was created using /registerControl() and 
--          has a Process routine, this routine is called first.
--/li All-Event Pre Trap: if a w32HEvent handler was set for the control, this is called next.
--/li Message Trap: If there is an raw message handler for this control and this message, it
--          is passed the event. You set such handlers by calling /setWinMsgHandler().
--/li Event Trap: If there is a specific handler for this event, that
--          handler is triggered. For example, /b WM_SETFOCUS triggers
--          /w32HGotFocus, /b WM_SIZE triggers /w32HResize, etc.
--/li All-Event Post Trap: if a w32HAfterEvent handler was set for the control, this is called next.
--/li Default Windows Handler: Finally, the default Window handler for
--          the control is called. In the case of subclassed /controls,
--          /i CallWindowProc calls the normal handler; for /windows,
--          /i DefWindowProc is called.
--
-- Setting /returnValue at any stage causes processing to stop at the step that the
-- value was set in, and return that value to Windows.
--
-- Example:
--
--/code
--          -- prevent Button1 from seeing any space bar keys
--          procedure Button1_KeyDown( integer self, integer event, sequence parms)
--              integer keycode
--              integer shift
--              keycode = parms[1]
--              shift = parms[2]
--              if keycode = VK_SPACE then
--                  -- set return value
--                  /returnValue( w32True )
--              end if
--          end procedure
--          /setHandler( Button1, w32HKeyDown, routine_id("Button1_KeyDown"))
--/endcode

global procedure returnValue(object returns)
    -- change the return value of the current control
    if SP<=0 then
        abortErr(Err_STACKERR)
    end if

    returnStack[SP] = {returns}
end procedure

--/topic Events
--/proc resetReturnValue( )
--/desc Removes any value returned by handler.
--
--Example
--/code
--      resetReturnValue()
--/endcode
global procedure resetReturnValue()
    -- change the return value of the current control
    if SP<=0 then
        abortErr(Err_STACKERR)
    end if

    returnStack[SP] = 0
end procedure

-----------------------------------------------------------------------------
--/topic Events
--/func getReturnValue( )
--/desc Gets the current value of the value that will be returned to Windows.
--/ret OBJECT: A sequence if set by an event handler, otherwise an atom.
--
--Example:
--/code
--      object rv
--      -- Set a return value if not already set.
--      rv = getReturnValue()
--      if not sequence(rv) then
--          returnValue(-1)
--      end if
--/endcode
global function getReturnValue()
    -- gets the current return value of the current control
    if SP<0 then
        abortErr(Err_STACKERR)
    elsif SP=0 then
        return 0
    end if

    return returnStack[SP]
end function

-----------------------------------------------------------------------------
--/topic Events
--/func setCallback( integer routineID)
--/desc gets and sets the application's generic callback routine id
--/ret INTEGER: The current value of the application's callback routine id.
--/i routineID is either -1 or a valid routine id. /n
--This sets the application's callback routine id and returns the old
--value. If /i routineID is less than -1, the current value is returned and remains unchanged./n
--The application may call the callback routine for a number of reasons
--during the running of a program. It is mainly used to get information
--needed by Win32Lib that it has not received so far.
--
--The callback routine must be a /b procedure that takes three parameters:- /n
-- /b integer /i self /n
-- /b integer /i event /n
-- /b sequence /i data /n
--
--The contents of the parameters passed to the callback routine depend on
-- the value of the /i event parameter. /n
--When /i event /b"= w32HGetHandler" is called when Win32lib needs an event handler
-- to be associated for a specific control's event. This comes about when using
-- the "events=..." parameter in the /newUIObj routine./n
--The /i data contains three values... /n
-- [1] A string in the form ~<eventname>_~<controlname>, eg. "Click_OkayBtn" /n
-- [2] An integer with the symbolic event code, eg. w32HClick /n
-- [3] A string containing the control's name. /n
--And the /i self parameter contains the control-id for the control needing
-- the handler routine.
--
--Example
--/code
--      integer oldrtn
--      oldrtn = setCallback(routine_id("AppCallback"))
--/endcode
global function setCallback(integer pRoutineID)
integer lOldRtn

    lOldRtn = r_AppCallback
    if pRoutineID>= -1 then
        r_AppCallback = pRoutineID
    end if

    return lOldRtn
end function

-----------------------------------------------------------------------------
--/topic Events
--/func invokeHandler( integer id, integer event, sequence params)
--/desc Triggers a Win32Lib event.
--/ret OBJECT: The value set by returnValue() if called inside
--the handler, zero otherwise.
--
--Example:
--/code
--      object rv
--      -- Simulate a button press on the Close Button.
--      rv = invokeHandler(btnClose, w32HClick, {})
--      if not sequence(rv) then
--          closeWindow(mainWin)
--      end if
--/endcode

global function invokeHandler(integer id, integer event, sequence params)
sequence lRoutines, lStates
integer lPos
sequence lNotify
integer lRecvr

    if validId(id)=w32False then
        return 0
    end if

    pushSelf(id)
    lRoutines = {}
    lStates = {}

    if event=w32HGetHandler then
        lRoutines = {{r_AppCallback}}
        lStates = {{1}}
    end if

    -- Check for any 'screen' event first.
    if length(ctrl_Handlers[Screen][event])>0 then
        lRoutines = append(lRoutines,ctrl_Handlers[Screen][event])
        lStates = append(lStates,ctrl_HandlerStates[Screen][event])
    end if

    -- And now for any control-owned event
    if id!=Screen and length(ctrl_Handlers[id][event])>0 then
        lRoutines = append(lRoutines,ctrl_Handlers[id][event])
        lStates = append(lStates,ctrl_HandlerStates[id][event])
    end if


    for i=1 to length(lRoutines) do
        if not equal(lRoutines[i],-1) then
            for j=1 to length(lRoutines[i]) do
                if lStates[i][j] then
                    call_proc(lRoutines[i][j], {id, event, params})
                end if
            end for
        end if
    end for

    -- Check if any notifications are required.
    if event!=w32HNotify then
        -- Avoid recursive notifications!
        lNotify = ctrl_Notify_List[id][1]

        for i=1 to length(lNotify) do
            lRecvr = lNotify[i]
            lPos = find(event, ctrl_Notify_List[id][2][i])
            if lPos and ctrl_Notify_List[id][4][i][lPos] then
                VOID = invokeHandler(lRecvr, w32HNotify,
                                     {id, event,ctrl_Notify_List[id][3][i][lPos],params})
            end if
        end for
    end if

    return popSelf()
end function

global constant
    w32protectLeading = 1,
    w32protectTrailing = 2

--/topic Events
--/proc setHandler( object id, object htype, object rid)
--/desc Sets up an user written event handler
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event to trap. /n
--/i rid is the routine_id of the user written code that will handle
-- the event.
--
-- /b Note that /i id can be a sequence of ids. You would do this if they all
-- shared the same handler code. /n
-- /b Note that /i htype can be a sequence of event codes. You would do this
-- if the same handler code is to be invoked for different events. /n
-- /b Note that /i routine can be a sequence of routine_id() values. You
-- would do this to set a chain of routines that are triggered for each
-- event listed in /i htype. /n
-- This routine actually adds the handler's routine_id to the end of a list
-- of such routines for this ID and Event combination. This way, you can
-- chain together independantly written routines to fire for the same
-- id and same events.
--
-- A special note. To remove the current chain, set /i routine to -1. To clear
-- the existing chain before setting a new one, you can also pass /i routine
-- as {-1, routine_id("myhandler")}. This mimics the onXXX syntax which early 
-- versions of win32lib supported.
--
-- To add routine(s) as the /b last executed in the chain, insert the special value -2
-- before the routines. Thus, specifying {25,-2,13,18} as the /i routine argument
-- will cause 25 to be added at the front, then 13 and 18 to be added at the bottom,
-- 18 being bottom-most.
--
-- You can temporarily enable or disable handlers using the /enableHandler() function.
-- The event subsystem only calls enabled handlers.
--
-- /b "How the Event Handler subsystem works" /n
-- The Win32lib library receives various events notifications from Windows.
-- If an event handler has been set up for the specific control-event
-- combination, the library invokes the user written routine before
-- continuing. Each event handler is a procedure that is passed three
-- parameters by the library. /n
-- 1) integer /i ID. The control id that the event applies to. /n
-- 2) integer /i Event. The event code that invoked this routine. This
-- enables a single routine to handler multiple event types. /n
-- 3) sequence /i Params. This is a list of zero or more parameters
-- associated with the specific event. For example, a w32HKeyDown event will
-- have the keycode and shift mask in these parameters.
--
-- If you insert a handler at the top of a handler chain, and if the top of that chain
-- is protected (using /setHandlerProtection(), the handler will be inserted right below
-- the top handler. Likewise, if you insert at bottom and the bottom handler is protected,
-- the new handler will be inserted right above the bottom-most one.
--
--Example
--/code
--  -- Set a single routine to be triggered by one type of event.
--  setHandler(myWindow, w32HPaint, routine_id("repaintWindow"))
--
--  -- Set the same handler for two different buttons.
--  setHandler( {btn1, btn2}, w32HClick, routine_id("click_buttons"))
--
--  -- Set the same handler for two different events.
--  setHandler( btn1, {w32HClick, w32HKeyPress}, routine_id("click_buttons"))
--
--  -- Set a chain of handlers.
--  setHandler( btn1, w32HClick, routine_id("click_buttons"))
--  if DebugSwitch = w32True then
--      -- add a second routine to be called.
--      setHandler( btn1, w32HClick, routine_id("Debugger"))
--  end if
--/endcode

global procedure setHandler(object id, object htype, object rid)
integer lTemp
integer lControl
integer lEvent
integer lWhere
sequence s

    if atom(id) then
        id = {id}
    end if

    if atom(htype) then
        htype = {htype}
    end if

    if atom(rid) then
        rid = {rid}
    end if
    for i=1 to length(id) do
        lControl = id[i]
        for j=1 to length(htype) do
            lEvent = htype[j]
            if validId(lControl)
            and lEvent>0
            and lEvent<=w32LastEventType() then

                -- Special for Combo boxes and dragging.
                if lEvent=w32HDragAndDrop then
                    lTemp = call_func(r_getEdit,{lControl})
                    if lTemp!=0 then
                        -- Set the same handler for the Combo's editbox.
                        setHandler(lTemp, htype, rid)
                    end if
                elsif find(lEvent, {w32HBreak, w32HPause, w32HIdle}) then
                    -- These must only apply to the screen control.
                    lControl = Screen
                end if

                lWhere = 1
                for k=1 to length(rid) do
                    if rid[k]= -1 then
                        if k=1 then
                            -- Clear any existing list of handlers.
                            ctrl_Handlers[lControl][lEvent] = {}
                            ctrl_HandlerStates[lControl][lEvent] = {}
                        end if
                    elsif rid[k]= -2 then
                        lWhere = -1
                    else
                        -- Add this routine (if not already there) into the list.
                        if find(rid[k], ctrl_Handlers[lControl][lEvent])=0 then
                            if lWhere=1 then
                                if not and_bits(ctrl_ProtectHandlers[lControl][lEvent],w32protectLeading) then
                                    ctrl_Handlers[lControl][lEvent] &= rid[k]
                                    ctrl_HandlerStates[lControl][lEvent] &= 1
                                else
                                    s = ctrl_Handlers[lControl][lEvent]
                                    s &= s[length(s)]
                                    s[length(s)-1] = rid[k]
                                    ctrl_Handlers[lControl][lEvent] = s
                                    s = ctrl_HandlerStates[lControl][lEvent]
                                    s &= s[length(s)]
                                    s[length(s)-1] = 1
                                    ctrl_HandlerStates[lControl][lEvent] = s
                                end if
                            else
                                if not and_bits(ctrl_ProtectHandlers[lControl][lEvent],w32protectTrailing) then
                                    -- Force it to be at the head of the handler list.
                                    ctrl_Handlers[lControl][lEvent] = rid[k] & ctrl_Handlers[lControl][lEvent]
                                    ctrl_HandlerStates[lControl][lEvent] = 1 & ctrl_HandlerStates[lControl][lEvent]
                                else
                                    s = ctrl_Handlers[lControl][lEvent]
                                    s = prepend(s,s[1])
                                    s[2] = rid[k]
                                    ctrl_Handlers[lControl][lEvent] = s
                                    s = ctrl_HandlerStates[lControl][lEvent]
                                    s = prepend(s,s[1])
                                    s[2] = 1
                                    ctrl_HandlerStates[lControl][lEvent] = s
                                end if
                            end if
                        end if
                    end if
                end for
            end if
        end for
    end for

end procedure

--/topic Events
--/proc setProtectedHandler(integer id,integer event,object routine)
--/desc Same as setHandler(), but overrides any protection without changing it.
-- If a handler chain is protected using /setHandlerProtection(), you may need to bypass 
-- this protection sometimes when changing the top or bottom handler. In this case only, use
-- setProtectedHandler(). Othrwise, /setHandler() will do just fine, and will be more flexible, 
-- since you cannot use sequences of ids or events here.
global procedure setProtectedHandler(integer id,integer event,object rid)
integer prot

    prot = ctrl_ProtectHandlers[id][event]
    ctrl_ProtectHandlers[id][event] = 0
    setHandler(id,event,rid)
    ctrl_ProtectHandlers[id][event] = prot
end procedure

--/topic Events
--/func setHandlerProtection(integer id,integer event,integer flag)
--/desc Possibly sets the protection status for a pair {id,event}.
--/ret (INTEGER) The former protection flag for the pair.
-- The protection flag is the sum of zero or more of:
--/li /b w32protectLeading: the first handler to be executed is protected
--/li /b w32protectTrailing: the last handler to be executed is protected
--
-- Additionally, using w32GetValue as flag causes the current flag to be returned.
--
-- When a handler chain is protected, and you call /setHandler(), the current top or bottom
-- handler will remain where it is, and the handler is inserted below or above the former.
-- This is handy when superclassing conrols, or creating derived controls a user might install
-- event handlers on, even though yours does stuff that should be done before any user 
-- routine starts.
global function setHandlerProtection(integer id,integer event,integer flag)
integer oldVal

    oldVal = ctrl_ProtectHandlers[id][event]
    if flag!=w32GetValue then
        ctrl_ProtectHandlers[id][event] = and_bits(flag,w32protectLeading+w32protectTrailing)
    end if
    return oldVal
end function

--/topic Events
--/func enableHandler( object id, object htype, object rid, integer flag)
--/desc Retrieves and possibly sets the state of a user written event handler.
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event to trap. /n
--/i rid is the routine_id of the user written code that handles the event.
--/i flag tells the routine what to do.
--
-- /b Note that /i id can be a sequence of ids. You would do this if they all
-- shared the same handler code. /n
-- /b Note that /i htype can be a sequence of event codes. You would do this
-- if the same handler code is to be invoked for different events. /n
-- /b Note that /i rid can be a sequence of routine_id() values. You
-- would do this to set the state of a chain of routines that are triggered for each
-- event listed in /i htype. /n
--
-- If flag is greater than zero, the handler will be enabled if found; if it is zero,
-- it will be disabled if found. In any case, its previous state will be returned:
-- 1 = enabled, 0 = disabled, -1 = not found.
-- If id or htype or routines is a sequence, a sequence will be returned;
-- otherwise, only an integer is returned.
--
--/endcode

global function enableHandler(object id, object htype, object rid, integer flag)
integer lTemp
integer lControl
integer lEvent
integer lWhere
sequence result
integer lIndex

    if atom(id) then
        id = {id}
    end if

    if atom(htype) then
        htype = {htype}
    end if

    if atom(rid) then
        rid = {rid}
    end if

    flag = compare(flag,0)
    lIndex = 1
    result = repeat(-1,length(id)*length(htype)*length(rid))

    for i=1 to length(id) do
        lControl = id[i]
        for j=1 to length(htype) do
            lEvent = htype[j]
            if validId(lControl)
            and lEvent>0
            and lEvent<=w32LastEventType() then

                -- Special for Combo boxes and dragging.
                if lEvent=w32HDragAndDrop then
                    lTemp = call_func(r_getEdit,{lControl})
                    if lTemp!=0 then
                        -- Set the same handler for the Combo's editbox.
                        VOID = enableHandler(lTemp, htype, rid, flag)
                    end if
                elsif find(lEvent, {w32HBreak, w32HPause, w32HIdle}) then
                    -- These must only apply to the screen control.
                    lControl = Screen
                end if

                for k=1 to length(rid) do
                    -- Locate this routine in the list.
                    lWhere = find(rid[k], ctrl_Handlers[lControl][lEvent])
                    if lWhere then
                        result[lIndex] = ctrl_HandlerStates[lControl][lEvent][lWhere]
                        if flag>=0 then
                            ctrl_HandlerStates[lControl][lEvent][lWhere] = flag
                        end if
                    end if
                    lIndex += 1
                end for
            end if
        end for
    end for
    if length(result)=1 then
        return result[1]
    else
        return result
    end if
end function

--/topic Events
--/func getHandler( integer id, integer htype)
--/desc Gets the event handler(s) defined for a control.
--/ret SEQUENCE: A list of handlers defined so for this control event.
--
--/i id is the ID of the control that the event applies to. /n
--/i htype is the type of event being handled. /n
-- The first executed handler is the last one on the returned list;
-- second executed is second last and so on.
--
--Example
--/code
--       object hl
--       -- Make sure my handler is installed before any others.
--       hl = getHandler(myWindow, w32HPaint)
--       -- Chain mine to the front.
--       setHandler(myWindow, w32HPaint, -1 & routine_id("mypainter") & hl)
--/endcode

global function getHandler(integer id, integer htype)
    if validId(id) and htype>=0 and htype<=w32LastEventType() then
        return ctrl_Handlers[id][htype]
    else
        return {}
    end if
end function

--/topic Events
--/proc removeHandler( object id, object htype, object rid)
--/desc Removes user written event handlers previously set with /setHandler()
--/i id is one or more control IDs. /n
--/i htype is one or more event types. /n
--/i rid is one or more routine_ids previously set for the control-event combinations
-- in the previous parameters.
--
-- You use this routine to get rid of a handler that had been established earlier.
-- To temporarily disable or enable a handler, use /enableHandler().
--
--Example:
--/code
--      -- This causes the CommonHandler routine to no longer process the w32HClick event for the controls Btn1 and Btn2.
--      removeHandler( {Btn1, Btn2}, w32HClick, routine_id("CommonHandler"))
--/endcode
global procedure removeHandler(object id, object pEvent, object rid)
integer lControl, lEvent, lIndex
sequence lHandlers, lRoutines
sequence lStates, lHStates

    if atom(id) then
        id = {id}
    end if
    if atom(pEvent) then
        pEvent = {pEvent}
    end if
    if atom(rid) then
        rid = {rid}
    end if
    for i=1 to length(id) do
        lControl = id[i]
        if validId(lControl) then
            lHandlers = ctrl_Handlers[id[i]]
            lHStates = ctrl_HandlerStates[id[i]]
            for j=1 to length(pEvent) do
                lEvent = pEvent[j]
                if lEvent>0 and lEvent<=w32LastEventType() then
                    lRoutines = lHandlers[lEvent]
                    lStates = lHStates[lEvent]
                    for k=1 to length(rid) do
                        lIndex = find(rid[k], lRoutines)
                        if lIndex>0 then
                            lRoutines = w32removeIndex(lIndex,lRoutines)
                            lStates = w32removeIndex(lIndex,lStates)
                        end if
                    end for
                    lHandlers[lEvent] = lRoutines
                    lHStates[lEvent] = lStates
                end if
            end for
            ctrl_Handlers[id[i]] = lHandlers
            ctrl_HandlerStates[id[i]] = lHStates
        end if
    end for
end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/func colorValue(object Color)
--/desc Converts the parameter into the equivalent 24-bit color value.
--/ret ATOM: 24-bit color value.
--The /i Color parameter can take one of the following forms ... /n
--/li A atom expression that results in an integer from 0 to #FFFFFF
--/li One of the predefined Win32Lib color names, eg. Cyan, BrightMagenta, ...
--/li One of the system symbolic color names, eg. COLOR_BUTTONFACE
--/li One of the predefined Win32Lib color names as a negative string, eg. -"cyan", -"red", ...
--/li One of the predefined Win32Lib color names as a string, except for "red" eg. "cyan", "blue", ... .
-- The color names may be followed or preceded by whitespace, so that "red  " or " red" is recognised as red.
--/li A 3-element sequence in the form { red, green, blue } where each element is
-- an integer in the range 0 to 255.
--
--Example:
--/code
--      atom theColor
--      theColor = colorValue( -"Parchment" )
--      theColor = colorValue( {45,82,191} )
--      theColor = colorValue( Magenta )
--      theColor = colorValue( COLOR_ACTIVEBORDER )
--      theColor = colorValue( #C0C0C0 )
--/endcode
global function colorValue(object pColor)
atom lColor
integer lPos

    lColor = 0  -- Default is Black
    if sequence(pColor) then
        if length(pColor)=3 and pColor[1]>=0 then
            -- Note that this can be ambiguous if the string for "red" is used,
            -- as that is a 3-element sequence.
            return rgb(pColor[1], pColor[2], pColor[3])
        end if

        lPos = find(w32trim(upper(pColor)), w32ColorNames)
        if lPos=0 then
--/**/      lPos = find(w32trim(sq_uminus(upper(pColor))), w32ColorNames)   --/* -- Phix
            lPos = find(w32trim(-upper(pColor)), w32ColorNames)             --*/ -- RDS
        end if
        if lPos!=0 then
            lColor = w32ColorValues[lPos]
        end if
    else
        lColor = UseColor(pColor)
    end if

    return lColor
end function

--/topic Support routines
--/func ansiLower(object Text)
--/desc Converts a 8-bit encoded string to lower case, using the current codepage.
--/ret (SEQUENCE) The converted string.
global function ansiLower(object Text) -- added R. Stowasser
sequence lowerText
atom pText

    if sequence(Text) then
        pText = w32acquire_mem(0, Text)
    else
        pText = Text
    end if
    VOID = w32Func(xCharLowerBuff, {pText, length(Text)})
    lowerText = w32peek_string(pText)
    if sequence(Text) then
        w32release_mem(pText)
    end if

    return lowerText
end function

--/topic Support routines
--/func ansiUpper(object Text)
--/desc Converts a 8-bit encoded string to upper case, using the current codepage.
--/ret (SEQUENCE) The converted string.
global function ansiUpper(object Text)  -- added R. Stowasser
sequence upperText
atom pText

    if sequence(Text) then
        pText = w32acquire_mem(0, Text)
    else
        pText = Text
    end if
    VOID = w32Func(xCharUpperBuff, {pText, length(Text)})
    upperText = w32peek_string(pText)
    if sequence(Text) then
        w32release_mem(pText)
    end if

    return upperText
end function

--/topic Graphics
--/func newColor(sequence name,object val)
--/desc Attempts to define a new color named /i name with value /i value
--/ret w32False on failure, w32True on success.
-- The function will fail if the name is already known, or if the color specification is invalid,
-- ie is not understood by /colorValue(). Color names are case insensitive.
global function newColor(w32string name, object val)
    name = ansiUpper(name)
    if find(name,w32ColorNames) then
        return w32False
    end if
    val = colorValue(val)
--  if sequence(val) then
--      return w32False
--  end if
    w32ColorNames = append(w32ColorNames,name)
    w32ColorValues[length(w32ColorValues)] = val
    w32ColorValues &= 0
    return w32True
end function

--/topic Utilities
--/func getStyleFlags( id )
--/desc Retrieves the standard and extra style flags for a control.
--/ret SEQUENCE: {ATOM: standard, ATOM: extra}
--Example
--/code
--      sequence lFlags
--      lFlags = getStyleFlags(myButton)
--/endcode
global function getStyleFlags(integer id)
atom hWnd

    hWnd = getHWND(id)
    return {w32Func(xGetWindowLong, {hWnd, GWL_STYLE}),
            w32Func(xGetWindowLong, {hWnd, GWL_EXSTYLE})
           }
end function

-----------------------------------------------------------------------------
--/topic Utilities
--/proc removeStyle( id, style )
--/desc Remove a style from a control.
--If /i style is an atom then only the normal Windows style is modified,
-- but if style is a sequence, it must be a tw-atom sequence. The first is
-- the normal styles, and the second is the extended styles.
--
--Example
--/code
--        removeStyle(w1, {
--                 -- normal styles
--                 (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
--                 -- extended styles
--                 (WS_EX_CLIENTEDGE)
--                   })
--/endcode
global procedure removeStyle(integer id, object styles)
atom curStyle, styleMask, hWnd, style

    if equal(styles, w32AUTOCLOSE) then
        VOID = enableHandler(id,w32HClick,r_autoclose,w32False)
        return
    end if

    if sequence(styles) then
        style = styles[1]
    else
        style = styles
    end if

    hWnd = getHandle(id)
    if style!=0 then
        curStyle = w32Func(xGetWindowLong, {hWnd, GWL_STYLE})
        styleMask = xor_bits(#FFFFFFFF, style)
        style = and_bits(styleMask ,curStyle)
        if style!=curStyle then
            VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, style})
        end if
    end if

    if sequence(styles) and styles[2]!=0 then
        style = styles[2]
        curStyle = w32Func(xGetWindowLong, {hWnd, GWL_EXSTYLE})
        styleMask = xor_bits(#FFFFFFFF, style)
        style = and_bits(styleMask ,curStyle)
        if style!=curStyle then
            VOID = w32Func(xSetWindowLong,{hWnd, GWL_EXSTYLE, style})
        end if
    end if

    VOID = w32Func(xSetForegroundWindow, {hWnd})
    VOID = w32Func(xSetWindowPos, {hWnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})

end procedure

--/topic Utilities
--/proc addStyle( id, style )
--/desc Add a style to a control.
--If /i style is an atom then only the normal Windows style is modified,
-- but if style is a sequence, it must be a two-atom sequence. The first is
-- the normal styles, and the second is the extended styles.
--
-- A special use of this is to set a control to close its parent window. To
-- do this call the routine using the style /i w32AUTOCLOSE. It should not be combined with any other style.
--
--Example
--/code
--        addStyle(w1, {
--                 -- normal styles
--                 (WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_THICKFRAME),
--                 -- extended styles
--                 (WS_EX_CLIENTEDGE)
--                })
--      -- Set the control to close the window
--      addStyle( BtnClose, w32AUTOCLOSE)
--/endcode

global procedure addStyle(integer id, object styles)
atom curStyle, hWnd, style
--  object lTemp

    -- special processing
    if equal(styles, w32AUTOCLOSE) then
        setHandler(id, w32HClick, r_autoclose)
        return
    end if

    if sequence(styles) then
        style = styles[1]
    else
        style = styles
    end if

    hWnd = getHandle(id)
    if style!=0 then
        curStyle = w32Func(xGetWindowLong, {hWnd, GWL_STYLE})
        style = or_bits(style ,curStyle)
        if style!=curStyle then
            VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, style})
        end if
    end if

    if sequence(styles) and styles[2]!=0 then
        style = styles[2]
        curStyle = w32Func(xGetWindowLong, {hWnd, GWL_EXSTYLE})
        style = or_bits(style ,curStyle)
        if style!=curStyle then
            if and_bits(style, WS_EX_TOPMOST) then
                call_proc(r_moveZOrder,{id, HWND_TOPMOST})
            end if
            VOID = w32Func(xSetWindowLong,{hWnd, GWL_EXSTYLE, style})
        end if
    end if

    VOID = w32Func(xSetForegroundWindow, {hWnd})
    VOID = w32Func(xSetWindowPos, {hWnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})
end procedure

global constant
    STYLE_HAS = 0,
    STYLE_ADD = 1,
    STYLE_REMOVE = 2,
    STYLE_TOGGLE = 3

--/topic Attributes
--/func controlStyle(integer id,object flags,integer extended,integer actoion)
--/desg Retrieves or changes the (extended) style(s) for a control
--/ret (ATOM) Former state of the possibly affected style flags.
-- This function is more flexible than /addStyle() and /removeStyle(). /n
-- /i id is the control being queried, and /i flags either the sum of style flags or a 
-- sequence of them to be or'ed together. /n
-- Set /i exteded to w32True to operate on extended styles, and to w32False for regular styles. /n
-- /i action is any of:
--/li STYLE_ADD: add specified styles
--/li STYLE_REMOVE: remove specified styles
--/li STYLE_TOGGLE: toggle specified styles (set if not set, unset if set)
--/li STYLE_HAS: don't change the style.
-- In all cases, the former state of the specified set of flags will be returned as zero 
-- or more flags or'ed together.
global function controlStyle(integer id,object flags,integer extended,integer action)
atom oldFlags,addr,mask,hWnd
sequence words

    addr = w32iff(extended,GWL_EXSTYLE,GWL_STYLE)
    hWnd = getHandle(id)
    oldFlags = w32Func(xGetWindowLong,{hWnd,addr})
    if sequence(flags) then
        flags = w32or_all(flags)
    end if
    -- kludge: and_bits() only works on integers, not on atoms representing machine integers
--/**/  words = sq_and_bits(w32unpack_dword(oldFlags),w32unpack_dword(flags)) --/* -- Phix
    words=and_bits(w32unpack_dword(oldFlags),w32unpack_dword(flags))        --*/ -- RDS
    mask = 65536*words[2]+words[1]
    if action=STYLE_HAS then
        return mask
    elsif action=STYLE_ADD then
        oldFlags = or_bits(oldFlags,flags)
    elsif action=STYLE_REMOVE then
        oldFlags -= mask
    elsif action=STYLE_TOGGLE then
        oldFlags = xor_bits(oldFlags,flags)
    end if
    VOID = w32Func(xSetWindowLong,{hWnd,addr,oldFlags})
    VOID = w32Func(xSetForegroundWindow, {hWnd})
    VOID = w32Func(xSetWindowPos, {hWnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})
    return mask

end function

--/topic System Attributes
--/func ClientToScreen(integer id, integer x, integer y)
--/desc Converts a point in a control to screen-based coordinates.
--/ret SEQUENCE: {screenX, screenY}
--
--Example
--/code
--      sequence sPosn
--      -- Find the screen position of the window's top left corner.
--      sPosn = ClientToScreen(myWindow, 0, 0)
--      printf(o, "Window is at %d, %d", {sPosn[1], sPosn[2]})
--/endcode

-- Create a buffer of 16 point structs to allow for 16 levels of nested interrrupts (not likely to happen)
atom cts_preallocated
cts_preallocated = w32acquire_mem(-2, SIZEOF_POINT*16)
global function ClientToScreen(integer id, integer x, integer y)
atom    pt
sequence lPoints
-- Allocate a point structure
    pt = cts_preallocated
    cts_preallocated += SIZEOF_POINT

    poke4(pt, {x,y})
    -- convert to screen space
    VOID = w32Func(xClientToScreen, {getHandle(id), pt})

    -- get position
    lPoints = peek4s({pt,2})
    cts_preallocated = pt

    return lPoints
end function

--/topic System Attributes
--/func ScreenToClient(integer id, integer x, integer y)
--/desc Converts a point on a screen to control-based coordinates.
--/ret SEQUENCE: {ControlX, ControlY}
--
--Example
--/code
--      sequence cPosn, mXY
--      -- Find where the mouse is relative to the window.
--      mYX = getPointerPos()
--      cPosn = ScreenToClient(myWindow, mXY[1], mXY[2])
--      printf(o, "Mouse is at %d, %d", {cPosn[1], cPosn[2]})
--/endcode

global function ScreenToClient(integer id, integer x, integer y)
integer viewX, viewY
atom    pt
-- Allocate a point structure
    pt  = w32acquire_mem(0, SIZEOF_POINT)

    -- set to client (0, 0)
    w32store(pt, ptX, x)
    w32store(pt, ptY, y)

    -- convert to screen space
    if not w32Func(xScreenToClient, {getHandle(id), pt}) then
        abortErr(Err_SCREENTOCLIENT)
    end if

    -- get position
    viewX = w32fetch(pt, ptX)
    viewY = w32fetch(pt, ptY)

    w32release_mem(pt)

    return {viewX, viewY}
end function


--/topic System Attributes
--/func clientToClient(integer id1, integer id2, sequence xy)
--/desc Converts a point in /i id1 to a relative point in /i id2
--/ret SEQUENCE: {X, Y}
--/i xy is a sequence in the format { X, Y} which specifies a point in
-- the control /i id1. This value is transformed so that it is relative to
-- the control /i id2.
--
--Example
--/code
--      sequence mXY
--      -- Find where the point 2,-4 relative to the editbox is
--      -- relative to the label.
--      mXY = clientToClient(MyEditBox, MyLabelText, {2, -4 })
--
--/endcode

global function clientToClient(integer id1, integer id2, sequence xy)
atom    pt
sequence lPoints
--  integer lParent

    -- Allocate a point structure
    pt = cts_preallocated
    cts_preallocated += SIZEOF_POINT

    poke4(pt, xy[1..2])
    -- convert to screen space relative to id1
    VOID = w32Func(xClientToScreen, {getHandle(id1), pt})
    -- convert from screen space relative to id2
    VOID = w32Func(xScreenToClient, {getHandle(id2), pt})

    -- get position
    lPoints = peek4s({pt,2})
    cts_preallocated = pt

    return lPoints
end function


--/topic Constants
--/const w32Edge
--/desc Specifies the extreme edge required when creating or moving a control.
--example
--/code
--          -- Create a edit area
--          myEdit = /create(MleText, "", myWin,
--                     0.50,           -- left edge is 50% of window's width
--                     20,             -- top edge is 20 pixels down
--                     w32Edge,        -- right edge is window's right edge
--                     {w32Edge, -25},  -- bottom edge is window's bottom
--                                     --   edge less 25 pixels.
--                     0)
--/endcode

--/topic Constants
--/const w32AltEdge
--/desc Specifies the alternate edge required when creating or moving a control.
-- This only makes sense when used in specifing the X,Y positions. The constant
-- is a reference to the 'far' edge. This is the Righthand side for the X
-- co-ordinate, and the Bottom edge for the Y co-ordinate. It is usually used
-- in conjection with negative offsets.
--example
--/code
--          -- Create a edit area aligned with the righhand edge.
--          fldWidth = 100
--          myEdit = /create(MleText, "", myWin,
--                     -- left edge is 'fldWidth' pixels from the RHS side of the window.
--                     {w32AltEdge, -fldWidth}
--                     20,             -- top edge is 20 pixels down
--                     fldWidth,       -- width of the field
--                     200,            -- height of 200 pixels
--                     0)
--/endcode

global constant w32Edge = {-1},
w32AltEdge = {-2},
w32SameSize = {-3}

--------------------------------------
function convDimension(object pRaw, atom pLowEdge, atom pExtremeEdge,
               atom pParentSize, atom pControlEdge)
--------------------------------------
atom lNewDimension
atom lPctSize
atom lOffset
sequence lMinMax
atom lEdge
object lRaw_1
object lRaw_2

    if equal(pRaw, CW_USEDEFAULT) then
        return pRaw
    end if

    -- Initialise
    lMinMax = {}
    lPctSize = 0
    lOffset = 0
    lEdge = 0

    -- Check for a sequence first.
    if sequence(pRaw) then
        -- Check for simple edge request
        if equal(pRaw, w32Edge) then
            lPctSize = 0
            lOffset = pExtremeEdge
            lEdge = 1
        -- Check for complex request
        elsif length(pRaw)>=2 then
            -- Copy to locals for performance reasons.
            lRaw_1 = pRaw[1]
            lRaw_2 = pRaw[2]

            -- Either the first or second could be the edge request.
            if equal(lRaw_1, w32Edge) then
                lOffset = pExtremeEdge
                lPctSize = lRaw_2
                lEdge = 1
            elsif equal(lRaw_2, w32Edge) then
                lOffset = pExtremeEdge
                lPctSize = lRaw_1
                lEdge = 1
            elsif equal(lRaw_1, w32AltEdge) then
                lOffset = pParentSize
                lPctSize = lRaw_2
            elsif equal(lRaw_2, w32AltEdge) then
                lOffset = pParentSize
                lPctSize = lRaw_1
                -- Either the first or second could be a % request
            elsif integer(lRaw_2) then
                lPctSize = lRaw_1
                lOffset = lRaw_2
            elsif atom(lRaw_2) and (lRaw_2>=1 or lRaw_2<0) then
                lPctSize = lRaw_1
                lOffset = floor(lRaw_2)
            else
                lPctSize = lRaw_2
                lOffset = lRaw_1
            end if
            -- Check to see if a limit has been requested.
            if length(pRaw)=3
            and sequence(pRaw[3])
            and length(pRaw[3])=2
            then
                lMinMax = pRaw[3]
            end if
        end if
    else
        -- A simple % or pixel specified.
        lPctSize = pRaw
        lOffset = 0
    end if

    -- Calc the percentage of the parent size.
    if lPctSize>0 and lPctSize<1 then
        lPctSize *= pParentSize
    end if

    -- Add LowEdge to cater for client borders etc...
    lNewDimension = floor(lPctSize)+lOffset+pLowEdge

    -- Make adjustment if 'extreme' edge was asked for.
    if lEdge=1 then
        lNewDimension += pControlEdge
    end if

    -- Check that the result is within the limits.
    if length(lMinMax)=2 then
        if lNewDimension<lMinMax[1] then
            lNewDimension = lMinMax[1]
        end if
        if lNewDimension>lMinMax[2] then
            lNewDimension = lMinMax[2]
        end if
    end if


    return floor(lNewDimension)
end function

--/topic Attributes
--/func isTopLevelWindow(integer id)
--/desc Used to determine if the /i id is a Window that acts independently of other windows.
--/ret INTEGER: w32True or w32False
--
--Example:
--/code
--      if isTopLevelWindow(xx) then
--          moveWindow(  . . . )
--      end if
--/endcode

global function isTopLevelWindow(integer id)

    if ctrl_Family[id]=WINDOW and
       and_bits(WS_CHILD, w32Func(xGetWindowLong, {getHWND(id), GWL_STYLE}))=0 then
        return w32True
    end if

    return w32False
end function

--/topic Attributes
--/func findParentWindow(integer id)
--/desc Used to get the Window id of the control specified by /i id
--/ret The id of the Window or zero if this /i id is not in a window.

global function findParentWindow(integer id)
----------------------------------------------------------
    -- find the parent window
    if id<0 or ctrl_Parent[id]=0 then
        -- This is already the top level.
        return id
    end if
    -- loop until I hit top of the tree or a Window control.
    while id and ctrl_Type[id]!=Window and isTopLevelWindow(id)=w32False do
        -- move up
        id = ctrl_Parent[id]
    end while
    return id
end function

--------------------------------------
--/topic System Attributes
--/func convPctToPixel(integer id, object x, object y, object width, object height)
--/desc Converts relative coordinates to pixel coordinates.
--/ret SEQUENCE: 4-element list {Left, Top, Width, Height}
--This is used internally by /create() and a number of other routines
--to convert things like % values to pixels.
--
-- Each dimension can be expressed as either... /n
-- a) an integer >= 0, in which case it is not touched. /n
--     eg.  50 (= 50 pixels) /n
-- b) an atom in the range > 0 and ~< 1, which is taken to be a % /n
--    of the control's parent dimension. /n
--     eg.  0.50 (= 50% of parent's size) /n
-- c) The constant /i w32Edge which signifies the parent's extreme  /n
--    client edge for the dimension. That is, either the rightmost or /n
--    bottom most edge, as appropriate. /n
-- d) a sequence of two elements, the first as in (b) or (c) above, and /n
--    the other a pixel offset. The offset is added after converting. /n
--     eg.  {0.50, -3} ( = 50% of parent size less 3 pixels) /n
--     eq   (w32Edge, -10} ( = right/bottom pixel less 10 pixels) /n
-- e) a sequence of three elements, the first two as in (d), and /n
--    the other a two-element sequence containing the minimum and /n
--    maximum allowable values. These can be a percentage or a /n
--    pixel amount.  /n
--     eg.  {0.50, -3, {20, 300}} ( = 50% of parent size less /n
--            3 pixels, and a minimum of 20 pixels and a /n
--            maximum of 300 pixels) /n
--Example:
--/code
--       sequence BBox
--       BBox = convPctToPixels( myEditBox, 0.30, {w32Edge,-40}, {0.1,4}, 35)
--
--/endcode
global function convPctToPixel(integer id,
            object x, object y, object width, object height)
-- Converts a controls coordinates from percentages to pixels.
sequence BBox
sequence PBox
integer lParent


    -- Not a valid ID, or this type of control cannot
    -- be converted, just return what was supplied.
    if   validId(id)=w32False
    or and_bits(classAttr[ctrl_Type[id]], w32NoConv)!=0
    then
        return {x, y, width, height}
    end if

    --Get the control's parent.
    lParent = ctrl_Parent[id]
    if lParent=0 then
        lParent = Screen
    end if

    -- Get the parent's current dimensions.
    PBox = call_func(r_getClientRect, {lParent})

    -- Convert Right/Bottom pixel to width and height
    PBox[3] = PBox[3]-PBox[1]-1
    PBox[4] = PBox[4]-PBox[2]-1

    if integer(x) and integer(y) and integer(width) and integer(height) then
        return {x+PBox[1], y+PBox[2], width, height}
    end if

    BBox = {0, 0, 0, 0}

    if equal(x, Center) then
        if equal(y, Default) then
            y = 0
        end if
        BBox[1] = floor(PBox[3]/2)
    else
        BBox[1] = convDimension(x, PBox[1], PBox[1], PBox[3], 0)
    end if

    if equal(y, Center) then
        if equal(x, Default) then
            BBox[1] = 0
        end if
        BBox[2] = floor(PBox[4]/2)
    else
        BBox[2] = convDimension(y, PBox[2], PBox[2], PBox[4], 0)
    end if

    BBox[3] = convDimension(width,    0, PBox[3], PBox[3], PBox[1]-BBox[1])

    BBox[4] = convDimension(height,       0, PBox[4], PBox[4], PBox[2]-BBox[2])

    if equal(x, Center) then
        BBox[1] = BBox[1]-floor(BBox[3]/2)
    end if

    if equal(y, Center) then
        BBox[2] = BBox[2]-floor(BBox[4]/2)
    end if

    return BBox
end function


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setReadOnly( integer id, integer YesNo )
--/desc Sets the read-only state of an edit control.
-- /i YesNo is w32True to set it to read-only, and w32False to allow keystrokes.
--
--Example:
--/code
--      -- the following prevents keyboard input to myEdit (paste still works)
--      setReadOnly( myEdit, w32True)
--/endcode
global procedure setReadOnly(integer id, integer YesNo)
    VOID = sendMessage(id, EM_SETREADONLY, YesNo,0)
end procedure

global constant
    WINDOWINFO_WLeft    = {WINDOWINFO_WRect,rectLeft},
    WINDOWINFO_WTop     = {WINDOWINFO_WRect,rectTop},
    WINDOWINFO_WRight   = {WINDOWINFO_WRect,rectRight},
    WINDOWINFO_WBottom  = {WINDOWINFO_WRect,rectBottom},
    WINDOWINFO_CLeft    = {WINDOWINFO_CRect,rectLeft},
    WINDOWINFO_CTop     = {WINDOWINFO_CRect,rectTop},
    WINDOWINFO_CRight   = {WINDOWINFO_CRect,rectRight},
    WINDOWINFO_CBottom  = {WINDOWINFO_CRect,rectBottom}

--/topic Attributes
--/func getWindowInfo(integer id, object pFields)
--/desc Get various information about a window.
--/ret SEQUENCE: A list of the requested field values.
--/i id is the id of a window that you want information from. /n
--/i pFields is a list of fields whose value can be requested. /n
--/define
--/term WINDOWINFO_WLeft
--      The Window border's left pixel position
--/term WINDOWINFO_WTop
--      The Window border's top pixel position
--/term WINDOWINFO_WRight
--      The Window border's right pixel position
--/term WINDOWINFO_WBottom
--      The Window border's bottom pixel position
--/term WINDOWINFO_CLeft
--      The Window client area's left pixel position
--/term WINDOWINFO_CTop
--      The Window client area's top pixel position
--/term WINDOWINFO_CRight
--      The Window client area's right pixel position
--/term WINDOWINFO_CBottom
--      The Window client area's bottom pixel position
--/term WINDOWINFO_Style
--      The Window style flags
--/term WINDOWINFO_ExStyle
--      The Window extended style flags
--/term WINDOWINFO_WindowStatus
--      The Window's activation status. Zero = not-active.
--/term WINDOWINFO_xWindowBorders
--      The width, in pixels, of the window border.
--/term WINDOWINFO_yWindowBorders
--      The height, in pixels, of the window border.
--/term WINDOWINFO_WindowType
--      The window class atom. Used in Win32 CreateWindow() calls.
--/term WINDOWINFO_CreatorVersion
--      The version of Windows 32 that created this window.
--/enddefine
--
--Example:
--/code
--       sequence lValues
--       lValues = getWindowInfo(myWin,
--                      {WINDOWINFO_WLeft,
--                       WINDOWINFO_WTop,
--                       WINDOWINFO_WindowStatus
--                      })
--       printf(o, "Window is at %d, %d and is %s",
--             {lValues[1], lValues[2],
--              w32iff(lValues[3], "active", "inactive")})
--/endcode

global function getWindowInfo(integer id, sequence pFields)
sequence lResult
atom     lWindowInfo
    lResult = {}

    lWindowInfo = w32to_memory(0,ID_WINDOWINFO ,0)
    if w32Func(xGetWindowInfo,{getHandle(id), lWindowInfo}) then
        for i=1 to length(pFields) do
            lResult = append(lResult, w32fetch(lWindowInfo, pFields[i]))
        end for
    end if

    w32release_mem(lWindowInfo)

    return lResult
end function

integer r_getAutoSize
integer r_ResolveDeferredHandlers
integer r_getDeferredHandlers
--/topic Attributes
--/func getControlInfo(integer id, object pFields)
--/desc Get various internal information about a control.
--/ret SEQUENCE: A list of the requested field values.
--/i id is the id of a control that you want information from. /n
--/i pFields is a list of fields whose value can be requested. /n
--/define
--/term     CONTROLINFO_handle
--  Windows hWnd value of control
--/term     CONTROLINFO_handle_type
--  Type of handle /n
--    Window = 1  /n
--    Bitmap = 2  /n
--    Menu   = 3  /n
--    TabItem = 4  /n
--    ImageList = 5   /n
--/term     CONTROLINFO_destroyed
--  true if destroyed
--/term     CONTROLINFO_func
--  Long pointer to function
--/term     CONTROLINFO_class
--  control class
--/term     CONTROLINFO_classinfo
--  control class info used during create /n
-- The returns a sequence that contains... /n
--<ul>
--/li Name  : The name of the registered Window Class
--/li Type  : The family of controls. Possible values are:
-- WINDOW, BUTTON, COMBO, EDIT, LISTBOX, SCROLLBAR,
-- STATIC, MENU, POPUP, MENUITEM, PIXMAP, COMMON_CONTROL
--/li Attributes: The win32lib attributes of this control. Possible values are: /n
--  /b w32Clickable: Can allow mouseup detection to fire Click handler /n
--  /b w32NoConv: Must not allow relative dimension conversions /n
--  /b w32PictCtrl: Controls that pass bitmaps in the flags /n
--  /b w32CtrlTab: CTRL-tabkey must be used to move tabstops /n
--/li Background Color : The default background color
--/li Foreground Color : The default foreground color
--/li Pointer : The default mouse pointer shape.
--</ul>
--/term     CONTROLINFO_type
--  win32lib type as declared at control creation
--/term     CONTROLINFO_focus_order
--  focus order of controls
--/term     CONTROLINFO_focus
--  current focus
--/term     CONTROLINFO_owner
--  owner
--/term     CONTROLINFO_menu
--  menu in window
--/term     CONTROLINFO_popup
--  attached popup menu for the control
--/term     CONTROLINFO_notifyid
--  a list of ids that wish to be notified of events that happen to this control.
--/term     CONTROLINFO_toolbar
--  toolbars in window
--/term     CONTROLINFO_statusbar
--  statusbar in window
--/term     CONTROLINFO_tooltip
--  tooltip text or flattoolbar button's caption
--/term     CONTROLINFO_font
--  font resource
--/term     CONTROLINFO_fcolor
--  foreground color
--/term     CONTROLINFO_bcolor
--  background color
--/term     CONTROLINFO_pen
--  pen: { id, color, style }
--/term     CONTROLINFO_x
--  x position of the pen
--/term     CONTROLINFO_y
--  y position of the pen
--/term     CONTROLINFO_erase
--  True if application is responsible for erasing the window background.
--/term     CONTROLINFO_scroll
--  scroll: { small change, large change }
--/term     CONTROLINFO_range
--  scroll range { low, high }
--/term     CONTROLINFO_tabitems
--  tabs in tab control
--/term     CONTROLINFO_group
--  items owned by this window, regardless whether they are in the tab order or not.
--/term     CONTROLINFO_cursor
--  cursor associated with window
--/term     CONTROLINFO_hotkey_keys
--  hotkeys associated with the window
--/term     CONTROLINFO_hotkey_ids
--  ids associated with hotkeys
--/term     CONTROLINFO_textalign
--  alignment of text
--/term     CONTROLINFO_closed
--  true if window has been closed.
--/term     CONTROLINFO_tabenabled
--  true if control uses raw tab keys, false if CTRL-tabkey must be used.
--/term     CONTROLINFO_eventhandler
--  Routine IDs for event handlers.
--/term     CONTROLINFO_bbrush
--  The current Brush used to paint a control's background.
--/term     CONTROLINFO_cursor
--  The stack of cursor's used to set the current cursor shape
--/term     CONTROLINFO_tag
--  The current set of user defined properties for the control.
--/term     CONTROLINFO_name
--  The current user defined name for the control.
--/term     CONTROLINFO_deferredhandlers
--  The current set of unresolved event handlers for the control.
--/term     CONTROLINFO_autoheight
--  Is this an automatic height resizing control
--/term     CONTROLINFO_autowidth
--  Is this an automatic width resizing control
--/term     CONTROLINFO_init
--  Contains the initial Rect data for children controls if there is a toolbar in the window
--/term     CONTROLINFO_mousetrap
--  Contains a list of the defined mousetraps for a control.
--/term     CONTROLINFO_tooltipwid
--  Contains the maximum width of the tooltip display window for a control.
--/term     CONTROLINFO_lost_focus
--  Contains the previous owned control that had the focus.
--/term     CONTROLINFO_itag
--  Contains the list of unnamed user defined properties for a control (they were defined using an index).
--/term     CONTROLINFO_handlerstates
--  Contains the list of the handler states (0 = disabled) for a control.
--/term     CONTROLINFO_formerId
--  Returns 0 for non subclassed controls, -1 for subclassed controls that had no id, else the former id.
--/term     CONTROLINFO_alias
--  Returns the internal class for a control. For registered controls, this is supplied by the create routine.
--/enddefine
--
-- Note that you can index the entries in the returned sequence for CONTROLINFO_font using the following index values:
--/li w32FontName
--/li w32FontSize
--/li w32FontAttrib
--/li w32FontColor
--
-- Note that you can index the entries in the returned sequence for CONTROLINFO_pen using the following index values:
--/li   PenColor
--/li   PenStyle
--/li   PenROP2
--/li   PenBkMode
--/li   PenWidth
--/li   PenBkColor
--/li   PenBrushColor
--
--Example:
--/code
--       sequence lValues
--       lValues = getControlInfo(myWin,
--                      {CONTROLINFO_handle,
--                       CONTROLINFO_owner,
--                       CONTROLINFO_type
--                      })
--/endcode

global function getControlInfo(integer id, object pFields)
object lResult
sequence lFields

    lResult = {}
    if atom(pFields) then
        lFields = {pFields}
    else
        lFields = pFields
    end if
    if id>0 and id<=length(ctrl_Handle) then
        for i=1 to length(lFields) do
            if lFields[i]=CONTROLINFO_handle then
                lResult = append(lResult, ctrl_Handle[id])
            elsif lFields[i]=CONTROLINFO_handle_type then
                lResult = append(lResult, ctrl_Handle_type[id])
            elsif lFields[i]=CONTROLINFO_destroyed then
                lResult = append(lResult, ctrl_Destroyed[id])
            elsif lFields[i]=CONTROLINFO_func then
                lResult = append(lResult, ctrl_Function[id])
            elsif lFields[i]=CONTROLINFO_class then
                lResult = append(lResult, ctrl_Family[id])
            elsif lFields[i]=CONTROLINFO_type then
                lResult = append(lResult, ctrl_ActualClass[id])
            elsif lFields[i]=CONTROLINFO_focus_order then
                lResult = append(lResult, ctrl_Focus_order[id])
            elsif lFields[i]=CONTROLINFO_focus then
                lResult = append(lResult, ctrl_Current_focus[id])
            elsif lFields[i]=CONTROLINFO_lost_focus then
                lResult = append(lResult, ctrl_Previous_focus[id])
            elsif lFields[i]=CONTROLINFO_owner then
                lResult = append(lResult, ctrl_Parent[id])
            elsif lFields[i]=CONTROLINFO_menu then
                lResult = append(lResult, ctrl_Menu[id])
            elsif lFields[i]=CONTROLINFO_popup then
                lResult = append(lResult, ctrl_Popup[id])
            elsif lFields[i]=CONTROLINFO_notifyid then
                lResult = append(lResult, ctrl_Notify_List[id])
            elsif lFields[i]=CONTROLINFO_toolbar then
                lResult = append(lResult, ctrl_Toolbar[id])
            elsif lFields[i]=CONTROLINFO_range then
                lResult = append(lResult, ctrl_Range[id])
            elsif lFields[i]=CONTROLINFO_tooltip then
                lResult = append(lResult, ctrl_Hint_Text[id])
            elsif lFields[i]=CONTROLINFO_tooltipwid then
                lResult = append(lResult, ctrl_Hint_Width[id])
            elsif lFields[i]=CONTROLINFO_font then
                lResult = append(lResult, ctrl_Font[id])
            elsif lFields[i]=CONTROLINFO_fcolor then
                lResult = append(lResult, ctrl_Fg_Color[id])
            elsif lFields[i]=CONTROLINFO_bcolor then
                lResult = append(lResult, ctrl_Bg_Color[id])
            elsif lFields[i]=CONTROLINFO_pen then
                lResult = append(lResult, ctrl_Pen[id])
            elsif lFields[i]=CONTROLINFO_x then
                lResult = append(lResult, ctrl_X_Pos[id])
            elsif lFields[i]=CONTROLINFO_y then
                lResult = append(lResult, ctrl_Y_Pos[id])
            elsif lFields[i]=CONTROLINFO_erase then
                lResult = append(lResult, ctrl_Erase[id])
            elsif lFields[i]=CONTROLINFO_scroll then
                lResult = append(lResult, ctrl_Scroll[id])
            elsif lFields[i]=CONTROLINFO_tabitems then
                lResult = append(lResult, ctrl_Specific[id])
            elsif lFields[i]=CONTROLINFO_group then
                lResult = append(lResult, ctrl_Group[id])
            elsif lFields[i]=CONTROLINFO_cursor then
                lResult = append(lResult, ctrl_Cursor[id])
            elsif lFields[i]=CONTROLINFO_hotkey_keys then
                lResult = append(lResult, ctrl_Hotkey_Keys[id])
            elsif lFields[i]=CONTROLINFO_hotkey_ids then
                lResult = append(lResult, ctrl_Hotkey_Ids[id])
            elsif lFields[i]=CONTROLINFO_textalign then
                lResult = append(lResult, ctrl_Text_Alignment[id])
            elsif lFields[i]=CONTROLINFO_closed then
                lResult = append(lResult, ctrl_Closed[id])
            elsif lFields[i]=CONTROLINFO_tabenabled then
                lResult = append(lResult, ctrl_TabKey_Used[id])
            elsif lFields[i]=CONTROLINFO_eventhandler then
                lResult = append(lResult, ctrl_Handlers[id])
            elsif lFields[i]=CONTROLINFO_bbrush then
                lResult = append(lResult, ctrl_Bg_Brush[id])
            elsif lFields[i]=CONTROLINFO_tag then
                lResult = append(lResult, ctrl_UserData[id])
            elsif lFields[i]=CONTROLINFO_itag then
                lResult = append(lResult, ctrl_IntData[id])
            elsif lFields[i]=CONTROLINFO_name then
                lResult = append(lResult, ctrl_Name[id])
            elsif lFields[i]=CONTROLINFO_deferredhandlers then
                lResult = append(lResult, call_func(r_getDeferredHandlers,{id}))
            elsif lFields[i]=CONTROLINFO_autoheight then
                lResult = append(lResult, call_func(r_getAutoSize,{id,1}))
            elsif lFields[i]=CONTROLINFO_autowidth then
                lResult = append(lResult, call_func(r_getAutoSize,{id,2}))
            elsif lFields[i]=CONTROLINFO_init then
                lResult = append(lResult, ctrl_Init_Posns[id])
            elsif lFields[i]=CONTROLINFO_mousetrap then
                lResult = append(lResult, ctrl_Mousetrap[id])
            elsif lFields[i]=CONTROLINFO_handlerstates then
                lResult = append(lResult, ctrl_HandlerStates[id])
            elsif lFields[i]=CONTROLINFO_formerId then
                lResult = append(lResult, ctrl_FormerId[id])
            elsif lFields[i]=CONTROLINFO_alias then
                lResult = append(lResult, ctrl_Type[id])
            elsif lFields[i]=CONTROLINFO_classinfo then
                lResult = append(lResult,{
                                          className[ctrl_Type[id]],
                                          classType[ctrl_Type[id]],
                                          classStyle[ctrl_Type[id]],
                                          classStyleEx[ctrl_Type[id]],
                                          classAttr[ctrl_Type[id]],
                                          classBGColor[ctrl_Type[id]],
                                          classFGColor[ctrl_Type[id]],
                                          classDefPointer[ctrl_Type[id]]
                                         })
            end if
        end for
    end if

    if atom(pFields) then
        lResult = lResult[1]
    end if
    return lResult
end function

-- these internal variables allow reentrancy for the window enumerator
-- in cas several requests are processed at the same time
integer enumRequests enumRequests = 0 -- counter for requests
sequence hrequests hrequests = {}   -- list of handles being queried
sequence crequests crequests = {}   -- list of result lists

function childenum(atom h,integer index)
    if w32Func(xGetParent,{h})=hrequests[index] then
        crequests[index] &= h  -- only return level 1 children
    end if
    return w32True
end function

--/topic Attributes
--/func findChildren(integer id)
--/desc Used to find all the children controls contained in the specified /i id.
--/ret SEQUENCE: Zero or more subsequences {id, controlType}.
-- Each subsequence returned has the control id and the control's type, for
-- all the controls owned by /i id. /n
-- It returns an empty sequence if the /i id has no children.
-- For subclased controls, you get either the list of children created by the application if any,
-- the list of items if applicable, or a list of child handles (no attempt is made to guess their type or class).
--
--/see /getChildren
--
--Example
--/code
--    sequence children
--    -- Get a list of all the controls owned by this window
--    children = findChildren(myWin)
--
--    -- Set the caption for each of the PushButtons.
--    for i = 1 to length(children) do
--       if find(children[i][2],{PushButton,DefPushButton}) then
--          setText(children[i][1], sprintf("Button%d", i))
--       end if
--    end for
--/endcode

global function findChildren(integer id)
sequence lChildren
integer thisRequest -- request index for enumerating child windows

    lChildren = {}
    if ctrl_Type[id]=TabItem then

        for i=1 to length(ctrl_Group[id]) do
            lChildren &= {{ctrl_Group[id][i], ctrl_Type[ctrl_Group[id][i]]}}
        end for

    elsif ctrl_Type[id]=TabControl then
        -- Can only allow tabitems to be children
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i]=id and ctrl_Type[i]=TabItem then
                lChildren &= {{i, ctrl_Type[i]}}
            end if
        end for
    elsif ctrl_FormerId[id] and not length(ctrl_Group[id]) then
    -- subclassed control
        hrequests &= getHandle(id)
        crequests = append(crequests,{})
        enumRequests += 1
        thisRequest = enumRequests
        VOID = w32Func(xEnumChildWindows,{getHandle(id),call_back(routine_id("childenum")),enumRequests})
        lChildren = crequests[thisRequest]
        for i=1 to length(lChildren) do
            lChildren[i] = {lChildren[i]}
        end for
    else
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i]=id then
                lChildren &= {{i, ctrl_Type[i]}}
            end if
        end for
    end if
    return lChildren
end function

procedure resetFont(integer id)
    -- empty name indicates default font
    ctrl_Font[id][w32FontName]   = ""
end procedure
registerRoutine("resetFont",routine_id("resetFont"))

procedure setCursorInternal(integer id,sequence data)
    if length(data)<=length(ctrl_Cursor[id]) or data[1]!=ctrl_Cursor[id][1] then
        ctrl_Cursor[id] = data
    end if
end procedure
registerRoutine("setCursorInternal",routine_id("setCursorInternal"))

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenColor( window, color )
--/desc Set the the pen color used in /i window.
-- This is the color that is used by other graphics routines.
--
-- To set the color of text, use /setTextColor.
--
-- Example:
--/code
--          -- set pen color to red
--          /setPenColor( TheWindow, /Red )
--          -- draw a red line
--          /drawLine( TheWindow, 10, 10, 40, 40 )
--/endcode

global procedure setPenColor(integer id, object color)

    -- set a new pen color for the window

    -- save the color
    ctrl_Pen[id][PenColor] = color

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/func getCtlSize( atom id )
--/desc Get the width and height of /i object.
--/ret SEQUENCE: { width, height }
--
--
-- Example:
--
--/code
--      -- how large is TheButton?
--      sequence size
--
--      -- get the size of TheButton
--      size = /getCtlSize( TheButton )
--
--      -- display the size
--      /wPrintf( MyWindow, "TheButton is %d by %d"}, size )
--/endcode

global function getCtlSize(atom id)

-- get { width, height } for the requested item
sequence s

-- get extent
    s = call_func(r_getRect,{id})

    -- Calculate the width and height
    return {s[3]-s[1], s[4]-s[2]}

end function

-- NEW! 0.48e
-----------------------------------------------------------------------------
--/topic Attributes
--/func isScreenPointIn( control, x, y )
--/ret /b w32True if point { /i x, /i y } is within /i control.
--/desc Return /b w32True if the screen point { /i x, /i y } is within /i control.
-- This is used for hit testing, to determine if a point lies on a control.
--
-- Example:
--
--/code
--          -- check if screen point {10,10} lies in MyWindow
--          if /isScreenPointIn( MyWindow, 10, 10 ) then
--              -- point is in MyWindow
--          end if
--/endcode

global function isScreenPointIn(integer id, integer pX, integer pY)
sequence lScreenRect

    if not validId(id) then
        return w32False
    end if

    lScreenRect = call_func(r_getRect,{id})
--/**/  lScreenRect[3..4] = sq_sub(lScreenRect[3..4],lScreenRect[1..2])             --/* Pve
    lScreenRect[3..4] -= lScreenRect[1..2]                                          -- RDS */
    lScreenRect[1..2] = ClientToScreen(id, 0, 0)
--/**/  lScreenRect[3..4] = sq_add(lScreenRect[3..4],sq_sub(lScreenRect[1..2],1))   --/* Pve
    lScreenRect[3..4] += lScreenRect[1..2]-1                                        -- RDS */

    if pX>=lScreenRect[3] or
       pX<lScreenRect[1] or
       pY>=lScreenRect[4] or
       pY<lScreenRect[2] then
        return w32False
    else
        return w32True
    end if

end function

--/topic Menus
--/func inMenuBar(integer id)
--/desc Determines whether a menu belongs to a window menu bar.
--/ret (INTEGER) -1 if not a menu, 1 if the menu appears in a menu bar, else 0.
global function inMenuBar(integer id)
    if not validId(id) or ctrl_Type[id]!=Menu then
        return -1
    else
        id = ctrl_Parent[id]
        if ctrl_Type[id]!=Menu then
            return 0
        else
            return ctrl_Family[ctrl_Parent[id]]=WINDOW
        end if
    end if
end function

sequence menu_dropped menu_dropped = {}
sequence hilitems hilitems = {}

--/topic Attributes
--/func isDropped(integer id)
--/desc Returns 1 if the control is currently in dropped state, else 0.
--/ret (INTEGER) 1 when control dropped down, else 0.
-- This routine applies to any control of the LIST or COMBO family (DropDownList, ComboBox,
-- ListBox, SimpleCombo, ...), and to ComboBoxEx, as well as to Menus and Popups. 0 is 
-- returned otherwise.
global function isDropped(integer id)
    if not validId(id) then
        return w32False
    elsif ctrl_Family[id]=MENU then
        if not call_func(r_isVisible,{findParentWindow(id)}) then
            return w32False
        elsif find(id,menu_dropped) then
            return w32True
        elsif inMenuBar(id) then
            return find(id,hilitems)
        else
            return w32False
        end if
    elsif ctrl_Family[id]=LISTBOX or ctrl_Family[id]=COMBO or ctrl_Type[id]=ComboBoxEx then
        return ctrl_Specific[id]
    else
        return w32False
    end if
end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func isVisible( object )
--/desc Returns the visibility state of /i object.
-- /b Note: A TabItem is always visible.
--
-- Example:
--/code
--          -- is TheButton visible?
--          integer flag
--
--          flag = /isVisible( TheButton )
--/endcode

global function isVisible(integer id)

    if not validId(id) then
        return w32False
    end if

    if ctrl_Family[id]=MENUITEM or ctrl_Type[id]=TabItem then
    -- a menu/tab item is visible iff the menu it belongs to is visible
        id = ctrl_Parent[id]
    end if

    if ctrl_Family[id]=MENU then
        return isDropped(id)
    else
        -- return hidden state of control
        return ctrl_Visible[id] and ctrl_SetVisible[id]
    end if

end function
r_isVisible = routine_id("isVisible")


include w32resources.ew

constant r_getDefaultFontId = w32routine_id("getDefaultFontId")

-----------------------------------------------------------------------------
--/topic Values
--/proc setPixmap( pixmap, bitmap )
--/desc Assign a new value to a /Pixmap.
-- If /i bitmap is a sequence, it will be assumed to be the name of an
-- bitmap file, and Win32Lib will attempt to load the bitmap.
--
-- Otherwise, /i bitmap is assumed to be the handle of a bitmap.
--
-- Example:
--
--/code
--          -- assign a bitmap to the picture button
--          /setPixmap( Pixmap1, "spaceship.bmp" )
--/endcode

-- NEW! 0.45m bitmap is now passed as an object
global procedure setPixmap(integer id, object bitmap)

    -- assign a new value to a pixmap

    -- is there an old bitmap?
    if getHandle(id)>0 then
        deleteObject(getHandle(id))
    end if

    -- file name or handle?
    if sequence(bitmap) then
        -- try to load bitmap file
        ctrl_Handle[id] = loadBitmapFromFile(bitmap)
    else
        -- just assign to handle
        ctrl_Handle[id] = bitmap
    end if
    ctrl_Handle_type[id] = kht_Bitmap

end procedure

----------------------------------------------------------------------------
--/topic Fonts
--/func assignFont( integer id)
--/desc Gets the device context for /i id with the current font installed.
--/ret ATOM: A Device Context (hDC)
-- This is different to the /getDC() function, which only returns the DC with
-- the default font installed. This one assigns the 'current' font to the DC.
--
--/b Note that /i id can have the form {id, DC} which allows you to pass an
-- existing DC, to which you can assign a font to. The DC passed is returned
-- by this routine. However, if /i DC is zero, a new DC is created.
--
--Example:
--/code
--    atom dc
--    dc = assignFont(myPixMap)
--    w32Proc( xTextOut, {dc, x, y, textaddr, textlen} )
--    releaseDC(dc)
--/endcode
global function assignFont(object id)

-- set font into the hdc, using the attributes of the font
--  this is shared by wPuts, getFontSize and getTextExtent

atom fontID
--  object result
atom hdc
--  atom factor

    if sequence(id) then
        hdc = id[2]
        id = id[1]
    else
        hdc = 0
    end if

    if hdc=0 then
        hdc = getDC(id)
    end if

    -- need to create a font based on the attributes?
    if length(ctrl_Font[id][w32FontName])>0 then
        fontID = EzCreateFont(id, hdc,           -- create font
                              ctrl_Font[id][w32FontName],    -- font name
                              w32iff(sequence(ctrl_Font[id][w32FontSize]),
                                     ctrl_Font[id][w32FontSize],
                                     floor(ctrl_Font[id][w32FontSize]*10)),
                              0,
                              ctrl_Font[id][w32FontAttrib],  -- attributes
                              vFontResolution , 0)
    elsif id=Printer then
        -- set to hard-coded values for default printer font.
        fontID = EzCreateFont(id, hdc, "Times New Roman", 100, 0, 0,
                              vFontResolution , 0)

    else
        -- get the stock system font object
        fontID = call_func(r_getDefaultFontId,{})
    end if

    -- replace the font
    replaceObject(id, kFontObject, hdc, fontID, ForPaint)

    -- use the pen color?

    if w32Func(xSetTextColor, {hdc, UseColor(ctrl_Font[id][w32FontColor])})=CLR_INVALID then
        -- unable to set color
        --warnErr( Err_SETTEXTCOLOR )
    end if

    -- set transparent or opaque
    if not w32Func(xSetBkMode, {hdc, ctrl_Pen[id][PenBkMode]}) then
        -- unable to set mode
        warnErr(Err_SETBKMODE)
    end if

    if not w32Func(xSetBkColor , {hdc, UseColor(ctrl_Pen[id][PenBkColor])}) then
        -- unable to set mode
        warnErr(Err_SETBKCOLOR)
    end if

    return hdc
end function

-----------------------------------------------------------------------------
-- FONTS
--
-----------------------------------------------------------------------------

--/topic Fonts
--/func useLogicalResolution(integer pLogRes)
--/desc Possibly sets the flag that determines if logical font resolution is used or not.
--/ret The previous value of the flag
-- /i pLogRes is 1 to use logical resolution (initial value),
-- 0 to use physical resolution, /w32GetValue to just return the current value of the flag.
global function useLogicalResolution(integer pLogRes)
integer lOldValue

    lOldValue = vFontResolution
    vFontResolution = pLogRes

    return lOldValue
end function


-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPuts( object window, object text )
--/desc Equivalent to Euphoria's /i puts() function.
-- The /i window parameter determines what /Window will be written to. /n
-- It can be either a control id or a sequence in the form {id, X, Y} to move
-- the pen to X,Y before writing the text.
--
-- This is usually used inside an Paint event handler.
--
-- If /i text is actually a number, it will be converted to text first. The
-- /i text parameters can also be used to specify a formatting string. To do
-- so place the format string as the first element and the second element then
-- should contain a list of parameters for the format string.
--
-- It is also possible to supply a RAM address if the text is pre-stored in
-- memory rather than a sequence. To do this, you must format the second
-- parameter as {{RAMaddress, length}}
--
-- Example:
--/code
--      -- put text in a window
--      /wPuts( MyWindow, "Hello, World!" )
--      /wPuts( TotalAmountFld, 1234.56 )
--      /wPuts( {MyWindow, 17, 5}, {"Name: %s", {firstName}} )
--
--      /wPuts( MyWindow, {{hSavedText, 45}} )
--/endcode

global procedure wPuts(object id, object s)
atom hdc
integer sLen

    -- Move pen first if asked.
    if sequence(id) then
        call_proc(r_setPenPos,{id[1], id[2], id[3]})
        id = id[1]
    end if

    -- Check for formatting
    if atom(s) then
        s = sprintf("%g", s)
        sLen = length(s)
    elsif length(s)=2 and sequence(s[1]) then
        s = sprintf(s[1], s[2])
        sLen = length(s)
    elsif length(s)=1 and
    sequence(s[1]) and
    length(s[1])=2 and
    atom(s[1][1]) and
    atom(s[1][2]) then
        sLen = length(s[1][2]) -- Length of RAM text
        s = s[1][1] -- RAM address of text.
    else
        sLen = length(s)
    end if

    -- set the font
    hdc = assignFont(id)

    -- align the text
    VOID = w32Func(xSetTextAlign, {hdc, ctrl_Text_Alignment[id]})

    -- display the text in the buffer
    w32Proc(xTextOut, {hdc,
                       ctrl_X_Pos[id],
                       ctrl_Y_Pos[id],
                       s,
                       sLen})

    -- release the device context

    releaseDC(id)

end procedure

--/topic Text
--/proc textOut( atom HDC, sequence TextDef )
--/desc Writes text to a control.
--This is a special version of /wPuts that can be faster under certain
-- circumstances. /n
-- /i HDC is the Device Context of a control and not its /b Id. This can
-- be obtained by /getDC() or /assignFont(). And must be released after
-- use. /n
-- /i TextDef is a sequence of up to 7 elements. Elements 4 thru 7 are
-- optional and can be 'omitted' by using an empty sequence for them. /n
-- The elements are ... /n
--/li pTextDefn[1]  = text string to display.
--/li pTextDefn[2]  = x (horizontal pixel position)
--/li pTextDefn[3]  = y (vertical pixel position)
--/li pTextDefn[4]  = Foregroud color
--/li pTextDefn[5]  = Background color
--/li pTextDefn[6]  = Mode (OPAQUE or TRANSPARENT)
--/li pTextDefn[7]  = Vertical Alignment with respect to character height.
-- (AlignTop, AlignBottom, AlignBaseline) /n
--
-- Example:
--/code
--      atom hdc
--      hdc = assignFont(Mypixmap)
--      H = getTextHeight(Mypixmap, "|")
--      W = 4
--      textOut(hdc,{"   Name:", W, 0 * H, Black, White, OPAQUE})
--      textOut(hdc,{"Address:", W, 1 * H})
--      textOut(hdc,{"    Age:", W, 2 * H})
--      textOut(hdc,{" Weight:", W, 3 * H})
--
--      W = getTextWidth(Mypixmap, "_") * 9
--      textOut(hdc,{NameFld, W, 0 * H, Blue, BrightWhite})
--      textOut(hdc,{AddressFld, W, 1 * H})
--      textOut(hdc,{sprintf("%d",AgeFld), W, 2 * H})
--      textOut(hdc,{sprintf("%5.2f", WeightFld), W, 3 * H})
--      releaseDC(Mypixmap)
--/endcode

global procedure textOut(atom hdc, sequence pTextDefn)


    pTextDefn &= repeat({},7)

    if atom(pTextDefn[6]) then
        VOID = w32Func(xSetBkMode , {hdc, pTextDefn[6]})
    end if

    if atom(pTextDefn[4]) then
        VOID = w32Func(xSetTextColor, {hdc, UseColor(pTextDefn[4])})
    end if

    if atom(pTextDefn[5]) then
        VOID = w32Func(xSetBkColor , {hdc, UseColor(pTextDefn[5])})
    end if

    if atom(pTextDefn[7]) then
        VOID = w32Func(xSetTextAlign, {hdc, pTextDefn[7]})
    end if

    -- display the text in the buffer
    w32Proc(xTextOut, {hdc,
                       pTextDefn[2],
                       pTextDefn[3],
                       pTextDefn[1],
                       length(pTextDefn[1])
                      })


end procedure

-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPrintf( window, format, data )
--/desc Equivalent to Euphoria's /i printf() routine.
-- /i window specifies the /Window to receive the text. /n
-- /i window can either be a single window id, or a sequence in the form
-- { id, x, y } where /i x and /y is the pen position to write at. /n
-- This is usually used inside an Paint event handler. /n
-- Note that this does not handle NEWLINE characters, use /drawText for that.
--
--Example:
--/code
--      -- show value of a
--      /wPrintf( MyWindow, "the value of a is %d", {a} )
--
--      -- Now print at pen position (5,25).
--      /wPrintf( {MyWindow, 5, 25}, "Code %s", {theCode} )
--/endcode

global procedure wPrintf(object id, sequence s1, object o)

    -- use wPuts to display message
    wPuts(id, sprintf(s1, o))

end procedure

integer vShowChars
vShowChars = 0
--/topic Fonts
--/proc showChars(integer pFlag)
--/desc Determines if /wPrint displays characters or numbers
-- If /i pFlag is zero, then the /wPrint routine acts like Euphoria's
-- print command and displays normal characters as numbers in a sequence.
-- If /i pFlag is non-zero, the /wPrint command displays these characters
-- as quoted characters. /n
-- The initial setting is zero.
--
--Example
--/code
--        showChars(0)
--        wPrint(mywin, "abc") -- displays {97,98,99}
--        showChars(1)
--        wPrint(mywin, "abc") -- displays {'a','b','c'}
--/endcode

global procedure showChars(integer pFlag)
    vShowChars = (pFlag!=0)
end procedure

-----------------------------------------------------------------------------
function print_format(object o)

-- returns object formatted for wPrint
sequence s

    if integer(o) then
        -- number
        if   vShowChars!=0
        and find(o, "`~!@#$%^&*()_+-={}|[]\\:\";'<>?,./" &
                 "1234567890" &
                 "abcdefghijklmnopqrstuvwxyz" &
                 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                ) then
            return sprintf("'%s'", o)
        else
            return sprintf("%d", o)
        end if
    elsif atom(o) then
        return sprintf("%f", o)
    else
        -- list
        s = "{"
        for i=1 to length(o) do
            s = s & print_format(o[i])
            if i<length(o) then
                s = s & ","
            end if
        end for
        s = s & "}"
        return s
    end if

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/proc wPrint( window, object )
--/desc Equivalent to Euphoria's /i print() routine.
-- /i window specifies the /Window to receive the data.
--
-- For example:
--/code
--      -- dump s to the window
--      /wPrint( MyWindow, s )
--/endcode

global procedure wPrint(integer id, object o)

    -- win32 version of Euphoria's print statement
    -- use wPuts to display message
    wPuts(id, print_format(o))

end procedure


--/topic RichEdit controls
--/proc setAlignment( id, alignment )
--/desc Align text in a /RichEdit Control
-- Sets Alignment of the paragraph which includes the selection in a
-- /RichEdit control.
-- /i alignment should be one of the following values:
-- /li /b AlignLeft
-- /li /b AlignRight
-- /li /b AlignCenter
global procedure setAlignment(integer id, integer align)
atom PF

    if align=AlignLeft then
        align = PFA_LEFT
    elsif align=AlignRight then
        align = PFA_RIGHT
    else
        align = PFA_CENTER
    end if

    PF = w32to_memory(0,ID_PARAFORMAT, {PFM_ALIGNMENT, 0, 0, 0, 0, align, {}})
    VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

    w32release_mem(PF)

end procedure

--/topic RichEdit controls
--/proc setBullet( id )
-- Toggles the bulleting of the paragraph which includes the selection in a
-- /RichEdit control.
global procedure setBullet(integer id)
atom PF

    PF = w32to_memory(0,ID_PARAFORMAT, {PFM_NUMBERING})

    VOID = sendMessage(id, EM_GETPARAFORMAT, 0, PF)
    w32store(PF, PARAFORMAT_wNumbering, not w32fetch(PF, PARAFORMAT_wNumbering))
    w32store(PF, PARAFORMAT_dwMask, PFM_NUMBERING)
    VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

    w32release_mem(PF)

end procedure

--/topic RichEdit controls
--/proc setIndent( id, start, right, offset )
--/desc Change indenting in a /RichEdit Control
-- Sets indenting.  If you don't want to change any of the indent modes,
-- pass it's parameter as a sequence.  All values should be in pixels.
global procedure setIndent(integer id, object start, object right, object offset)
atom PF, mask

    mask = 0

    if atom(start) then
        mask = w32or_all({mask, PFM_STARTINDENT})
    else
        start = 0
    end if

    if atom(right) then
        mask = or_bits(mask, PFM_RIGHTINDENT)
    else
        right = 0
    end if

    if atom(offset) then
        mask = w32or_all({mask, PFM_OFFSET})
    else
        offset = 0
    end if

    PF = w32to_memory(0,ID_PARAFORMAT, {mask, 0, start, right, offset, 0, {}})

    VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

    w32release_mem(PF)

end procedure

--/topic List Control
--/proc setTabs( id, tabs )
--/desc Set/change tab stops in a /List or /SortedList Control.
-- /i tabs should be a sequence of integers. Each one is a tabstop
-- position measured in 1/4 character widths.

--/topic RichEdit controls
--/proc setTabs( id, tabs )
--/desc Change tab stops in a /RichEdit Control.
-- /i tabs should be a sequence of absolute positions for the tab stops
-- in 1/1000 of an inch.
global procedure setTabs(integer id, sequence tabs)
atom PF
--  atom NumberOfTabStops
atom TabArrayAddress -- address of integer array of TAB stops
--  atom pokeAt
--  atom ret
--  sequence bytes

    if ctrl_Type[id]=RichEdit then
        PF = w32to_memory(0,ID_PARAFORMAT,{PFM_TABSTOPS, 0, 0, 0, 0, 0, tabs})

        VOID = sendMessage(id, EM_SETPARAFORMAT, 0, PF)

        w32release_mem(PF)
    elsif find(ctrl_Type[id],{List, SortedList}) then
        -- Build and array of integers in memory to pass to windows
        -- w32allot bytes for each tab stop element to build a 32 bit tab array
        TabArrayAddress = w32acquire_mem(0, length(tabs)*4)
        -- poke the values into the tab array address
        poke4(TabArrayAddress, tabs)
        -- send a windows message to the list box to set tabstops
        VOID = sendMessage(id, LB_SETTABSTOPS,
                           length(tabs),
                           TabArrayAddress)

        w32release_mem(TabArrayAddress)

    end if

end procedure

--/topic Attributes
--/func setErasePolicy(integer id, integer Flag)
--/desc Possibly sets and gets the Background Erasing policy for the control /i id
--/ret INTEGER: The current policy value.
--/i id is a control id. /n
--If /i Flag is negative (eg. -1) then this routine just returns the current
-- policy value. If it is zero it sets the policy that the window's background
-- is automatically cleared to the default color whenever it needs erasing. If
-- it is positive (eg. 1) then the application must take responsibility of
-- erasing the background during a Paint event.
--
--Example:
--/code
--      integer oldval
--      oldval = setErasePolicy( TickerWin, 1)
--/endcode
global function setErasePolicy(integer id, integer pFlag)
integer lCurrentValue

    lCurrentValue = ctrl_Erase[id]
    if pFlag>=0 then
        ctrl_Erase[id] = (pFlag!=0)
    end if

    return lCurrentValue
end function

global constant
findDown = FR_DOWN,
findWholeWord = FR_WHOLEWORD,
findMatchCase = FR_MATCHCASE

--/topic RichEdit controls
--/func findText( id, text, range, flags )
--/desc Find text in a /RichEdit Control.
--/ret Index where text begins, or zero if not found
-- /i range should be a sequence containing the range of text you'd
-- like to search within the /RichEdit, or an atom, if you want to search
-- through all of the text. When specifying a range, the first index is included and the 
-- second index is excluded.
-- /i flags can be a combination of the folowing:
-- /li /b findWholeWord
-- /li /b findMatchCase
-- /li /b findDown = Current to DocEnd, else Current to DocStart
--
-- Example:
--/code
--   atom fnd, frompoint
--   integer cnt
--   sequence word
--      -- Count all occurances of a word.
--      word = "procedure"
--      cnt = 0
--      frompoint = 0
--      fnd = -1
--      while fnd != 0 do
--          fnd = findText(myRichFld, word, {frompoint,-1},
--                                  findDown + findMatchCase + findWholeWord)
--          if fnd then
--               cnt += 1
--               frompoint = fnd
--          end if
--      end while
--
--/endcode
global function findText(integer id, sequence text, object range,
    integer flags)
atom FT, index

    if atom(range) then
        range = {0, -1}
    end if

    if and_bits(flags,FR_DOWN) then
        FT = w32to_memory(0,ID_FINDTEXTEX, {range[1], range[2], text, 0, -1})
    else
        FT = w32to_memory(0,ID_FINDTEXTEX, {range[2], range[1], text, 0, -1})
    end if

    index = sendMessage(id, EM_FINDTEXTEX, flags, FT)

    w32release_mem(FT)

    -- convert to one-based index
    return index+1

end function

-- begin R. Stowasser Feb 3, 2008
sequence vFindReplaceIds, vFindReplaceHwnds
vFindReplaceIds = {}
vFindReplaceHwnds = {}

--/topic Dialogs
--/proc getFRText(integer id, integer replace_if_set,object callback)
--/desc Opens the "Find" Dialog
-- /i id should be the id of the control in which the Find  or Replace Dialog will
-- search.  The dialog is a modeless dialog, which means that it
-- will remain open and on top, until the user closes it. /n
-- The dialog is a Find dialog if /i replace_if_set is w32False, and a Replace dialof if it is not zero. /n
-- If /i callback is not -1, it is a routine id called on completion of a find or replace operation.
-- The callback procedure should take two integer parameter. The first one is the id of the control, and the second is:
--/li 0 if the operation failed;
--/li 1 if it succeeded and is not a ReplaceAll operation;
--/li the number of replaced occurences on completion of a ReplaceAll operation.
-- If /i callback is -1, a default behaviour takes place, which may involve displaying an information
-- dialog box. You can customise the strings it displays using /setFRStrings(). If /i callback is a 
-- sequence, then the previous callback will remain in force, or set to -1 if none.
global procedure getFRText(object id, integer replace_if_set,object callback)
atom fr, frmem
integer idx

    if atom(id) then
        if ctrl_Type[id]=RichEdit then
            idx = find(id,vFindReplaceIds)
            if not idx then
                if sequence(callback) then
                    callback = -1
                end if
                frmem = w32new_memset()
                fr = w32to_memory(0,ID_FINDREPLACE, {getHandle(id), 0, FR_FINDNEXT+FR_DOWN,
                                                     w32acquire_mem(frmem,256), w32acquire_mem(frmem,256), 256, 56})
                vFindReplaceIds &= id
                vFindReplaceHwnds &= w32Func(w32iff(replace_if_set,ReplaceTextA,FindTextA),{fr})
                ctrl_Statusbar[id] = {frmem,fr,callback,replace_if_set}
            else
                vFindReplaceHwnds[idx] = w32Func(
                    w32iff(replace_if_set,ReplaceTextA,FindTextA), {ctrl_Statusbar[id][2]})
                ctrl_Statusbar[id][4] = replace_if_set
                if atom(callback) then
                    ctrl_Statusbar[id][3] = callback
                end if
            end if
        end if
    else
        -- TODO: Implement callback hook
    end if
end procedure

--/topic Dialogs
--/proc getFindText( id )
--/desc Opens the "Find" Dialog
-- /i id should be the id of the control in which the Find Dialog will
-- search.  The Find dialog is a modeless dialog, which means that it
-- will remain open and on top, until the user closes it. /n
-- This call is equivalent to /getFRText(id,w32False,-1).
global procedure getFindText(object id)
    getFRText(id,w32False,{})
end procedure

--/topic Dialogs
--/proc getReplaceText( id )
--/desc Opens the "Replace" Dialog
-- /i id should be the id of the control in which the Replace Dialog will
-- search.  The Replace dialog is a modeless dialog, which means that it
-- will remain open and on top, until the user closes it. /n
-- This call is equivalent to /getFRText(id,w32True,-1).
global procedure getReplaceText(object id)
    getFRText(id,w32True,{})
end procedure
-- end RS

sequence vStreamCallbackBuffer
vStreamCallbackBuffer = {}
integer vStreamCBPosn
vStreamCBPosn = 1

function getStreamCallback(atom dwCookie, atom pbBuff, atom cb,
    atom pcb)
    -- Get the characters from the buffer
    vStreamCallbackBuffer &= peek({pbBuff, cb})
    -- Let the control know how many I pulled out.
    poke4(pcb, cb)
    -- Return 'no error'
    return  0
end function
constant gscb = call_back(routine_id("getStreamCallback"))

function putStreamCallback(atom dwCookie, atom pbBuff, atom cb,
    atom pcb)

atom lCBLen, lStart, lEnd, lRemaining


    lStart = vStreamCBPosn
    lRemaining = length(vStreamCallbackBuffer)-lStart+1

    if lRemaining<1 then
        -- Tell Windows that nothing is left.
        poke4(pcb, 0)
        return 0
    end if

    if cb>lRemaining then
        lCBLen = lRemaining
    else
        lCBLen = cb
    end if
    poke4(pcb, lCBLen)
    lEnd = lStart+lCBLen-1

    -- Avoid creating a slice if using the entire buffer.
    if lEnd=length(vStreamCallbackBuffer) and lStart=1 then
        poke(pbBuff, vStreamCallbackBuffer)
    else
        poke(pbBuff, vStreamCallbackBuffer[lStart..lEnd])
    end if
    if lEnd=length(vStreamCallbackBuffer) then
        vStreamCallbackBuffer = ""
    else
        vStreamCBPosn = lEnd+1
    end if

    return 0
end function
constant pscb = call_back(routine_id("putStreamCallback"))

-----------------------------------------------------------------------------
--/topic RichEdit controls
--/func getStream( integer id, integer flags )
--/desc Convert the data in a RichEdit control to a sequence.
--/ret SEQUENCE: The contents of the RichEdit control.
-- Use flag /b StreamText to return plain text, or /b StreamRTF to return
-- rich text. This can be combined to /b StreamSelection to only return
-- any selected content from the RichEdit.
--
-- Example:
--
--/code
--           -- Create a RichEdit control
--           RE = /create( /RichEdit, "", Win , 20, 20, 360, 200, ES_NOHIDESEL)
--           . . .
--           -- Save the text into a file from a RichEdit control
--           richout = open("MyRich.txt", "w")
--           -- Get the selected text from the control.
--           printf(richout, "%s", { /getStream( RE, StreamText + StreamSelection) } )
--
--           close( richout )
--
--/endcode
--
global function getStream(integer id, integer flags)
atom EDITSTREAM, uFormat
sequence streamout

    uFormat = and_bits(StreamMask, flags)

    vStreamCallbackBuffer = ""
    EDITSTREAM = w32to_memory(0,ID_EDITSTREAM, {0, 0, gscb})

    VOID = sendMessage(id, EM_STREAMOUT, uFormat, EDITSTREAM)

    w32release_mem(EDITSTREAM)
    streamout = vStreamCallbackBuffer
    vStreamCallbackBuffer = {}

    return streamout
end function

-----------------------------------------------------------------------------
--/topic RichEdit controls
--/proc putStream( integer id, integer flag, sequence text )
--/desc Load text into a RichEdit control from a text sequence.
-- Use /i flag /b StreamText to indicate that /i contains plain text,
-- or /b StreamRTF to indicate that /i text contains rich text.
-- This can be combined with StreamSelection so that only any selected
-- text in the control is replaced with /i text data.
--
-- Example:
--
--/code
--           sequence rich
--           integer RE, fn, c
--           . . .
--           -- Create a RichEdit control
--           RE = /create( /RichEdit, "", Win , 20, 20, 360, 200, ES_NOHIDESEL)
--
--           -- Load the text into the RichEdit control
--           fn = open("rich.rtf", "r")
--           if fn != -1 then
--               rich = {}
--               c = getc( fn )
--               while c != -1 do
--                   rich &= c
--                   c = getc( fn )
--               end while
--
--               /putStream( RE, StreamRTF, rich )
--
--               close( fn )
--           end if
--
--/endcode

global procedure putStream(integer id, integer flags, sequence streamin)
atom uFormat
atom EDITSTREAM
integer lLen
atom lResult

    if not length(streamin) then
        return
    end if

    lLen  = length(streamin)
    uFormat = and_bits(StreamMask, flags)

    vStreamCallbackBuffer = streamin
    vStreamCBPosn = 1

    EDITSTREAM = w32to_memory(0,ID_EDITSTREAM, {0, 0, pscb})

    VOID = sendMessage(id, EM_STREAMIN, uFormat, EDITSTREAM)
    lResult = w32fetch(EDITSTREAM, EDITSTREAM_dwError)
    w32release_mem(EDITSTREAM)

end procedure

--/topic Attributes
--/func setReBarAutoSizing( integer Flag)
--/desc Sets/Gets the automatic resizing facility for ReBar controls.
--/ret INTEGER: Current Value
--/i Flag is either /b w32True to enable Win32Lib to automatically take care
--of moving controls around relative to the height of the ReBar control,
--/b w32False to disable this facility, or /w32GetValue to get the current status..
--
-- The current value for this facility is returned. Initially this facility
-- is disabled.
--
--Example:
--/code
--      integer CurVal
--      -- Enable automatic handling of rebar height changes.
--      CurVal = setReBarAutoSizing( w32True )
--/endcode

global function setReBarAutoSizing(integer pFlag)
integer lOldFlag

    lOldFlag = AutoReBarSizing
    if pFlag!=w32GetValue then
        AutoReBarSizing = (pFlag!=0)
    end if

    return lOldFlag
end function

-----------------------------------------------------------------------------
function queryFont(integer id, atom pRequest, sequence pArgs)

-- this runs a query about font attributes. Because the query
-- can run against controls which have no obtainable DC, the
-- queries are performed on the mainWindow. The exception is
-- the Printer, which uses it's own DC.
--
-- The DC is automatically prepended to the /i pArgs list.
--
-- Since the mainWindow is used, it has to be restored to it's
-- prior state when the query is complete.

integer lUseId
atom lHDC, lResult
sequence lSavedFont

    lSavedFont = {}

    -- Attempt to get a DC for this control.
    lHDC = getDC({id, "ignorenull"})

    -- If I can't then use the Screen's DC
    if lHDC=0 then

        lUseId = Screen
        -- Swap font defn
        lSavedFont = ctrl_Font[lUseId]
        ctrl_Font[lUseId] = ctrl_Font[id]
    else
        lUseId = id
    end if

    -- set the font and get control's dc
    lHDC = assignFont({lUseId, lHDC})

    -- perform the requested function
    lResult = w32Func(pRequest, lHDC & pArgs)

    -- release the DC
    releaseDC(lUseId)

    -- used the main window?
    if length(lSavedFont)!=0 then
        -- restore the font attributes
        ctrl_Font[lUseId] = lSavedFont
    end if

    return lResult

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/func getFontMetric( id, field )
--/desc Gets font metric field value for /i id's current font.
--/ret field's value
-- The /i field can be one of:
--/li    tmHeight
--/li    tmAscent
--/li    tmDescent
--/li    tmInternalLeading
--/li    tmExternalLeading
--/li    tmAveCharWidth
--/li    tmMaxCharWidth
--/li    tmWeight
--/li    tmOverhang
--/li    tmDigitizedAspectX
--/li    tmDigitizedAspectY
--/li    tmFirstChar
--/li    tmLastChar
--/li    tmDefaultChar
--/li    tmBreakChar
--/li    tmItalic
--/li    tmUnderlined
--/li    tmStruckOut
--/li    tmPitchAndFamily
--/li    tmCharSet
--/li otmSize
--/li otmTextMetrics
--/li otmFiller
--/li otmPanoseNumber
--/li otmfsSelection
--/li otmfsType
--/li otmsCharSlopeRise
--/li otmsCharSlopeRun
--/li otmItalicAngle        
--/li otmEMSquare           
--/li otmAscent             
--/li otmDescent            
--/li otmLineGap            
--/li otmsCapEmHeight       
--/li otmsXHeight           
--/li otmrcFontBox          
--/li otmMacAscent          
--/li otmMacDescent         
--/li otmMacLineGap         
--/li otmusMinimumPPEM      
--/li otmptSubscriptSize    
--/li otmptSubscriptOffset  
--/li otmptSuperscriptSize  
--/li otmptSuperscriptOffset
--/li otmsStrikeoutSize     
--/li otmsStrikeoutPosition 
--/li otmsUnderscoreSize    
--/li otmsUnderscorePosition
--/li otmpFamilyName        
--/li otmpFaceName          
--/li otmpStyleName         
--/li otmpFullName
--
-- Please refer to Microsoft documentation for the meaning and measurement units related to 
-- these fields. The otmxxx fields are outline font metrics.
--
-- Example:
--
--/code
--          -- get the descent for the default font
--          integer descent
--
--          /setDefaultFont( MyWindow )
--          descent = /getFontMetric( MyWindow, tmDescent )
--          /wPrintf( MyWindow, "The default font's descent is %", descent )
--/endcode

global function getFontMetric(integer id, sequence field)

object result
atom tm
integer size

    size = queryFont(id, xGetOutlineTextMetrics, {1,0})
    -- text metric structure
    tm  = w32acquire_mem(0,  size)

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont(id, xGetOutlineTextMetrics, {size,tm}) then
        warnErr(Err_GETFONTMETRIC)
    end if

    if isFieldOf(field, ID_OUTLINETEXTMETRIC) then
        -- fetch field
        result = w32fetch(tm, field)
    else
        -- fetch from the text metrics field
        result = w32fetch(tm,{otmTextMetrics,field})
    end if

    -- release
    w32release_mem(tm)

    return result

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func getFontSize( id )
--/desc Gets font metrics for /i id's current font.
--/ret { width, height } of average character.
--
-- Example:
--
--/code
--          -- show the metrics of the default font
--          sequence size
--
--          /setDefaultFont( MyWindow )
--          size = /getFontSize( MyWindow )
--          /wPrintf( MyWindow, "The default font is %d by %d", size )
--/endcode

global function getFontSize(integer id)

-- get metrics for current font

integer width, height, maxwidth
atom tm

-- text metric structure
    tm  = w32acquire_mem(0, SIZEOF_TEXTMETRIC)

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont(id, xGetTextMetrics, {tm}) then
        warnErr(Err_GETFONTSIZE)
    end if

    -- assign values
    width   = w32fetch(tm,tmAveCharWidth)
    maxwidth   = w32fetch(tm,tmMaxCharWidth)
    height  = w32fetch(tm,tmHeight)+w32fetch(tm,tmExternalLeading)

    -- release
    w32release_mem(tm)

    -- return results
    return {width, height, maxwidth}

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextHeight( integer Id, sequence text )
--/desc Gets the height of the /i text using the current font for the /i id
--/ret ATOM: Height of the text.
global function getTextHeight(integer id, sequence text)

-- get metrics for current font
atom size, str, mset, height

    -- Grab some memory from the system
    mset = w32new_memset()
    size  = w32acquire_mem(mset, SIZEOF_SIZE)
    text = w32removeItem('&', text)
    str = w32acquire_mem(mset, text)

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont(id, xGetTextExtentPoint,
                     {str, length(text), size}) then
        abortErr(Err_GETTEXTEXTENT)
    end if

    height  = w32fetch(size,sizY)

    -- give back the memory
    w32release_mem(mset)

    -- return results
    return height

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextWidth( integer Id, sequence text )
--/desc Gets the width of the /i text using the current font for the /i id
--/ret ATOM: Width of the text.
global function getTextWidth(integer id, sequence text)

-- get metrics for current font
atom size, str, mset, width

    -- Grab some memory from the system
    mset = w32new_memset()
    size  = w32acquire_mem(mset, SIZEOF_SIZE)
    text = w32removeItem('&', text)
    str = w32acquire_mem(mset, text)

    -- get the metrics of the font (queryFont will prepend the DC)
    if not queryFont(id, xGetTextExtentPoint,
                     {str, length(text), size}) then
        abortErr(Err_GETTEXTEXTENT)
    end if

    width   = w32fetch(size,sizX)

    -- give back the memory
    w32release_mem(mset)

    -- return results
    return width

end function


-----------------------------------------------------------------------------
--/topic Fonts
--/func getTextExtent( integer Id, sequence textset )
--/desc Gets the metrics of the /i textset strings, using /i Id's current font.
--/ret SEQUENCE: maxwidth, maxheight, minwidth, minheight, totalwidth, totalheight
--The /i textset parameter can either be a normal text string or a sequence of
-- strings. /n
-- /b Note: The first or only /b'&' character in each string will not be included
-- in the metrics.
--
-- Example #1: Show the size of a text string.
--/code
--          sequence text, extent
--
--          -- the string to measure
--          text = "Hi, there!"
--
--          -- measure the string
--          extent = /getTextExtent( MyWindow, text )
--
--          -- show results
--          /wPrintf( MyWindow, "The string %s is %d by %d pixels",
--                                   {string, extent[1], extent[2]} )
--/endcode
--
-- Example #2: Calculate the size of some buttons
--/code
--          sequence btntext, extent, btns
--          integer btnheight, btnwidth
--          sequence x
--          integer y
--
--          -- the strings to measure
--          btntext = {"&Print", "&Cancel", "&Ok", "&Help"}
--
--          -- measure the string
--          extent = /getTextExtent( MyWindow, btntext )
--
--          -- calc button dimensions
--          btnheight = extent[2] + 10 -- adjust for borders
--          btnwidth  = extent[1] + 8  -- adjust for borders
--
--          -- Draw the buttons
--          btns = {}
--          x = 5
--          y = 10
--          for i = 1 to length(btntext) do
--              btns &= create(PushButton, MyWindow, btntext[i],
--                          x, y, btnwidth, btnheight, 0)
--              y += btnheight + 1
--          end for
--
--/endcode

global function getTextExtent(integer id, sequence text)

-- get metrics for current font

integer width, height
integer maxwidth, maxheight
integer minwidth, minheight
integer totwidth, totheight
atom size, lStrAddr, mset

    if length(text)=0 or atom(text[1]) then
        text = {text}
    end if
    maxheight = 0
    maxwidth = 0
    minheight = 0
    minwidth = 0
    totheight = 0
    totwidth = 0

    -- Grab some memory from the system
    mset = w32new_memset()
    size  = w32acquire_mem(mset, SIZEOF_SIZE)
    for i=1 to length(text) do
        text[i] = w32removeItem('&', text[i])
        lStrAddr = w32acquire_mem(mset, text[i])

        -- get the metrics of the font (queryFont will prepend the DC)
        if not queryFont(id, xGetTextExtentPoint,
                         {lStrAddr, length(text[i]), size}) then
            abortErr(Err_GETTEXTEXTENT)
        end if

        -- assign values
        width   = w32fetch(size,sizX)
        height  = w32fetch(size,sizY)

        -- determine maximums
        if i=1 or width>maxwidth then
            maxwidth = width
        end if
        if i=1 or height>maxheight then
            maxheight = height
        end if
        -- determine minimums
        if i=1 or width<minwidth then
            minwidth = width
        end if
        if i=1 or height<minheight then
            minheight = height
        end if
        -- determine totals
        totwidth += width
        totheight += height

    end for
    -- give back the memory
    w32release_mem(mset)

    -- return results
    return {maxwidth, maxheight, minwidth, minheight, totwidth, totheight}

end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc getCharExtent( integer Id)
--/desc Gets the average character width and height for the /i Id's current font.
--/ret SEQUENCE: avgwidth, avgheight
--/b Note 1: The averages are not integers. You may have to floor() them. /n
--/b Note 2: These are averages! Be wary of this when using them to calculate
-- field sizes for proportional fonts.
--
-- Example
--/code
--          sequence extent
--          integer fldWidth
--
--          extent = /getCharExtent( MyWindow )
--
--          -- Calculate the amount of space need to display the text.
--          fldWidth = floor(extent[1] * length(text))
--/endcode
--
-- Example #2: Calculate the size of some buttons
--/code
--          sequence btntext, extent, btns
--          integer btnheight, btnwidth
--          sequence x
--          integer y
--
--          -- the strings to measure
--          btntext = {"&Print", "&Cancel", "&Ok", "&Help"}
--
--          -- measure the string
--          extent = /getTextExtent( MyWindow, btntext )
--
--          -- calc button dimensions
--          btnheight = extent[2] + 10 -- adjust for borders
--          btnwidth  = extent[1] + 8  -- adjust for borders
--
--          -- Draw the buttons
--          btns = {}
--          x = 5
--          y = 10
--          for i = 1 to length(btntext) do
--              btns &= create(PushButton, MyWindow, btntext[i],
--                          x, y, btnwidth, btnheight, 0)
--              y += btnheight + 1
--          end for
--
--/endcode

global function getCharExtent(integer id)
sequence lExtent, lResult

    lExtent = getTextExtent(id, {"W"," ._-|@0123456789" &
                                 "abcdefghijklmnopqrstuvwxyz" &
                                 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"})
    lResult = {(lExtent[1]/68+lExtent[3])/2,
               (lExtent[2]+lExtent[4])/2
              }

    return lResult
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setTextAlign( id, style )
--/desc Set the font alignment to use when printing text.
--
-- The default option is AlignTop. Options include:
--
-- /li /b AlignTop: Text is displayed below {x,y}
-- /li /b AlignBottom: Text is displayed above {x,y}
-- /li /b AlignBaseline: Text is displayed on baseline {x,y}
--
-- Example:
--
--/code
--          -- draw a line
--          drawLine( Win, 10, 100, 100, 100 )
--
--          -- top alignment (default)
--          setTextAlign( Win, AlignTop )
--          setPenPos( Win, 10, 100 )
--          wPuts( Win, "AlignTop" )
--
--          -- bottom alignment
--          setTextAlign( Win, AlignBottom )
--          setPenPos( Win, 10, 100 )
--          wPuts( Win, "AlignBottom" )
--
--/endcode

global procedure setTextAlign(integer id, integer flag)
    ctrl_Text_Alignment[id] = flag
end procedure

--/topic Graphics
--/func adjustBrightness(atom pColor, atom pAdjustment)
--/desc Applies a luminosity factor to a color supplied as a 24-bit integer.
--/ret A 24-bit integer representing the adjusted color.
--
-- The higher the factor, the brighter the output color.
--
-- Example:
--/code
--         constant win=create(Window,"Test",0,Default,Default,Default,Default,0),
--                  btn=create(PushButton,"1.2 times brighter",win,10,10,100,30,0)
--
--        procedure slightlyBrighter(integer id,integer event,sequence data)
--            integer newColor
--            newColor=adjustBrightness(getControlInfo(win,CONTROLINFO_bcolor),1.2)
--            setWindowBackColor(win,newColor)
--        end procedure
--        setHandler(btn,w32HClick,routine_id("slightlyBrighter"))
--
--        setWindowBackColor(win,Parchment)
--        WinMain(0,Normal)
--/endcode

global function adjustBrightness(atom pColor, atom pAdjustment)
sequence lRGB

    lRGB = split_rgb(pColor)
--/**/  lRGB = sq_floor(sq_mul(lRGB,pAdjustment))   --/* -- Phix
    lRGB = floor( lRGB * pAdjustment )              --*/ -- RDS
    for i=1 to 3 do
        if lRGB[i]>255 then
            lRGB[i] = 255
        elsif lRGB[i]<0 then
            lRGB[i] = 0
        end if
    end for
    return rgb(lRGB[1], lRGB[2], lRGB[3])

end function

--/topic Graphics
--/func mixColors(sequence colors,object weight,integer output_triple)
--/desc Computes the weighted average of the supplied colors by calling /w32average()
--/ret The resulting color mix.
-- If /i output_triple is not zero, a RGB triple is returned, or else a 24 bit integer value. /n
-- Always returns -1 on error.
global function mixColors(sequence colors,object weight,integer output_triple)
object result

    for i=1 to length(colors) do
        colors[i] = split_rgb(colorValue(colors[i]))
    end for
    result = w32average(colors,weight)
    if atom(result) then
        return -1
    else
--/**/  result = sq_round(result)   --/* -- Phix
        result=floor(result+0.5)    --*/ -- RDS
        for i=1 to 3 do
            if result[i]<0 then
                result[i] = 0
            elsif result[i]>255 then
                result[i] = 255
            end if
        end for
    end if
    if output_triple then
        return result
    else
        return colorValue(result)
    end if
end function

-----------------------------------------------------------------------------
--/topic Graphics
--/func fillRectangle(integer id,object rectangle,integer isColor,object filler,integer transp)
--/desc Fills a rectangle in the window /i id with an arbitrary brush.
--/ret INTEGER 0 on failure, nonzero on success.
-- If the /i isColor is not w32False, filler designates a color, and this call
-- is equivalent to one to /drawRectangle() with the /i filled parameter nonzero.
-- Otherwise:
--/li If /i filler is an atom, it is a brush handle.
--/li If it is a string, it is the name of a bitmap file. The bitmap will be loaded and tiled over the filled rectangle.
--/li If it is a sequence of length 1, the element is a bitmap handle already obtained.
--/li Otherwise, the first element is a hatch style, and the second one a foreground value.
--/   See the hatch style values in the documentation for /setBackground().
--/li The empty sequence is a reserved special value and currently does nothing.
--
-- /i rectangle may be specified as:
--/li a {left,top,right,bottom} sequence;
--/li 0, in which case the client rectagle of /i id will be filled.
--/li a nonzero atom, the address of a rectangle already poked in RAM.
--
-- /i transp is nonzero to request a background mode of TRANSPARENT, and 0 to have it OPAQUE, during this operation.

global function fillRectangle(integer id,object rectangle,integer isColor,object filler, integer transp)
integer ret_code,saved_mode
atom rect_addr,fill_brush

-- interpret special values for rectangle
    if equal(filler,{}) or not validId(id) then
        return 0
    end if
    if equal(rectangle,0) then
        rectangle = call_func(r_getClientRect,{id})
    end if

    -- rect_addr must point to the rectangle
    if sequence(rectangle) then
        rect_addr = w32acquire_mem(0,{Long,4})
        poke4(rect_addr,rectangle)
    else
        rect_addr = rectangle
    end if

    -- Get the brush
    if isColor then
        fill_brush = w32Func(xCreateSolidBrush,{colorValue(filler)})
    elsif atom(filler) then
        fill_brush = filler
    elsif w32string(filler) then
        fill_brush = w32Func(xCreatePatternBrush,{loadBitmapFromFile(filler)})
    elsif length(filler)=1 then
        fill_brush = w32Func(xCreatePatternBrush,filler)
    else
        fill_brush = w32Func(xCreateHatchBrush,{filler[1],colorValue(filler[2])})
    end if

    -- Temporary background mode override
    if transp then
        transp = TRANSPARENT
    else
        transp = OPAQUE
    end if
    if transp=ctrl_Pen[id][PenBkMode] then
        saved_mode = -1
    else
        saved_mode = ctrl_Pen[id][PenBkMode]
        ctrl_Pen[id][PenBkMode] = transp
    end if

    ret_code = w32Func(xFillRect,{getHandle(id),rect_addr,fill_brush})

    -- Cleanup
    if sequence(rectangle) then
        w32release_mem(rect_addr)
    end if

    if saved_mode>=0 then
        ctrl_Pen[id][PenBkMode] = saved_mode
    end if

    return ret_code

end function

-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintWindow( window )
--/desc Force /i window to be entirely repainted.
-- This repaints the entire window in it's background color, effectively
-- erasing everything in it. It then triggers an /w32HPaint event
-- for that window, requesting that the entire window be repainted.
--
-- Example:
--
--/code
--      -- force MyWindow to be repainted
--      /repaintWindow( myWindow )
--/endcode

global procedure repaintWindow(integer id)
-- redraws *everything*
atom hwnd

-- get handle
    if id<=0 or id>length(ctrl_Handle) then
        hwnd = 0
    else
        hwnd = ctrl_Handle[id]
    end if

    -- invalidate all of the current window, and clear it
    VOID = w32Func(xInvalidateRect, {hwnd, NULL, 1})

    -- trigger an immediate paint message
    VOID = w32Func(xSendMessage,{hwnd, WM_PAINT, 0, 0})

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintFG( window )
--/desc Force /i window to be repainted but without clearing it first.
-- This triggers an /w32HPaint event
-- for that window, requesting that the entire window be repainted.
--
-- It is different to /repaintWindow() in that the window is not cleared
-- to its background color first.
--
-- Example:
--
--/code
--      -- force MyWindow to be repainted
--      /repaintFG( myWindow )
--/endcode
global procedure repaintFG(integer id)
-- redraws *everything*
atom hwnd

-- get handle
    if id<=0 or id>length(ctrl_Handle) then
        hwnd = 0
    else
        hwnd = ctrl_Handle[id]
    end if

    -- invalidate all of the current window, and clear it
    VOID = w32Func(xInvalidateRect, {hwnd, NULL, 0})

    -- trigger an immediate paint message
    VOID = w32Func(xSendMessage,{hwnd, WM_PAINT, 0, 0})


end procedure


-----------------------------------------------------------------------------
--/topic Graphics
--/proc repaintRect( window, x1, y1, x2, y2 )
--/desc Force /i window to be partially repainted.
-- This sends repaints at the specified portion of the /i window with
-- the background color, erasing that portion of it. It then triggers
-- an /Paint event for that window, passing the erased area as
-- parameters.
--
-- Example:
--
--/code
--      -- repaint only a portion of MyWindow
--      /repaintRect( myWindow, 1, 1, 10, 10 )
--/endcode

global procedure repaintRect(integer id, integer x1, integer y1,
                integer x2, integer y2)

-- invalidates only a portion of the window
atom hWnd
atom rect

-- Allocate rectangle
    rect = w32acquire_mem(0, SIZEOF_RECT)
    poke4(rect, {x1,y1,x2,y2})

    hWnd = getHandle(id)

    -- invalidate all of the current window, and clear it
    if not w32Func(xInvalidateRect, {hWnd, rect, 1}) then
        warnErr(Err_REPAINTRECT)
    end if

    -- Free the rectangle structure
    w32release_mem(rect)

    -- trigger an immediate paint message
    VOID = w32Func(xSendMessage,{hWnd, WM_PAINT, 0, 0})


end procedure



------------------------------------------------------
--/topic Attributes
--/proc clearWindow( integer id)
--/desc Sets /i id to its background color
-- This is used to wipe a Window or Pixmap. /n 
-- Example:
--
--/code
--          /clearWindow( MyWindow )
--          /clearWindow( MyPixmap )
--/endcode

global procedure clearWindow(integer id)
sequence lRect
sequence lSavedBrushColor

    if compare(ctrl_Bg_Color, w32WinDefColor) then
        lRect = call_func(r_getRect,{id})
        lSavedBrushColor = ctrl_Pen[id][PenBrushColor]
        -- Use Back color as temporary brush color.
        ctrl_Pen[id][PenBrushColor] = {ctrl_Bg_Color[id]}
        drawRectangle(id, w32True, 0, 0, lRect[3], lRect[4])
        ctrl_Pen[id][PenBrushColor] = lSavedBrushColor
    end if

    return

end procedure

------------------------------------------------------
global constant EM_SETBKGNDCOLOR = #443

global constant
       HatchHorz = 0,
       HatchVert = 1,
       HatchNWSE = 2,
       HatchSWNE = 3,
       HatchCross = 4,
       HatchXCross = 5

--/topic Attributes
--/proc setBackground(integer id,integer flag,object bkData)
--/desc Sets the background of control /i id with a color, pattern or bitmap.
-- /i id is the target control. The procedure will not affect buttons, menus and tab controls. /n
-- /i flag is either w32False or w32True. If w32False is passed, bkData is a color specification, and the call is equivalent to /setWinbackColor(/i id, /i bkData). /n
-- Otherwise, bkData is either a bitmap handle or a three element sequence. In the former case, the bitmap is tiled to form the background of the window. In the latter case, a hatch pattern is being specified as {style, background color, line color}.
-- The style parameter is any of the following:
--/li /b HatchHorz: horizontal lines
--/li /b HatchVert: vertical lines
--/li /b HatchNWSE: lines at a 45 degrees slope, going down from left to right
--/li /b HatchSWNE: lines at a 45 degrees slope, going up from left to right
--/li /b HatchCross: a canvas aligned on the client rectangle of the window
--/li /b HatchXCross: a canvas at a 45 degree sope relative to the client rectangle of the window.

global procedure setBackground(object id, integer flag, object bkData)

-- set the background color of a window or control
-- use rgb() to calculate a color

atom lNewBrush, lOldBrush, lFillBrush
atom bStyles
integer lId,lColor,hatched,changed
atom hdc,rect
sequence s

    if not sequence(id) then
        id = {id}
    end if
    hatched = 0
    for i=1 to length(id) do
        lId = id[i]
        -- save color
        if equal(bkData,w32WinDefColor) then
            repaintWindow(lId)
            return
        end if
        if not flag then
            lColor = colorValue(bkData)
            if not ctrl_Bg_Brush[lId] then
                ctrl_Bg_Brush[lId] = w32Func(xCreateSolidBrush,{lColor})
            end if
            changed = (lColor!=colorValue(ctrl_Bg_Color[lId]))
            if changed then
                ctrl_Bg_Color[lId] = bkData

                -- create a new brush
                lNewBrush = w32Func(xCreateSolidBrush, {lColor})
            else
                repaintWindow(lId)
                return
            end if
        else
            changed = 0
            if atom(bkData) then
                lNewBrush = w32Func(xCreatePatternBrush,{bkData})
                ctrl_Bg_Color[lId] = {bkData}
            elsif length(bkData)=1 then
                lNewBrush = w32Func(xCreatePatternBrush,bkData)
                ctrl_Bg_Color[lId] = bkData
            else
                bkData[2] = colorValue(bkData[2])
                bkData[3] = colorValue(bkData[3])
                ctrl_Bg_Color[lId] = bkData
                lNewBrush = w32Func(xCreateSolidBrush,{bkData[2]})
                lFillBrush = w32Func(xCreateHatchBrush,{bkData[1],bkData[3]})
                hatched = 1
            end if
        end if

        if ctrl_Type[lId]=Pixmap then
            clearWindow(lId)
        else
            -- set that as the background color
            lOldBrush = ctrl_Bg_Brush[lId]
            ctrl_Bg_Brush[lId] = lNewBrush

            -- delete the prior brush
            deleteObject(lOldBrush)

            -- If this is a window, then change the Class background too.
            if ctrl_Type[lId]=Window then
                VOID = w32Func(xSetClassLong, {getHandle(lId), GCL_HBRBACKGROUND, lNewBrush})
            elsif not flag then
                if ctrl_Family[lId]=BUTTON then
                    s = getStyleFlags(lId)
                    bStyles = s[1]
                    if and_bits(bStyles,BS_CHECKBOX) then
                        VOID = floodFill(lId,1,1,{-1,lColor},FLOODFILLSURFACE)
                    end if
                elsif ctrl_Type[lId]=ListView then
                    VOID = sendMessage(lId,LVM_SETBKCOLOR,0,lColor)
                elsif ctrl_Type[lId]=TreeView then
                    VOID = sendMessage(lId,TVM_SETBKCOLOR,0,lColor)
                elsif ctrl_Type[lId]=MonthCalendar then
                    call_proc(r_setMonthColor,{lId,lColor,MCSC_MONTHBK})
                elsif ctrl_Type[lId]=ReBar then
                    VOID = sendMessage(lId,RB_SETBKCOLOR,0,lColor)
                elsif find(ctrl_Family[lId],{EDIT,STATIC,SCROLLBAR,LISTBOX}) then
                    VOID = floodFill(lId,1,1,{-1,lColor},FLOODFILLSURFACE)
                elsif ctrl_Family[lId]=COMBO or ctrl_Type[lId]=ComboBoxEx then
                    VOID = floodFill(lId,1,1,{-1,lColor},FLOODFILLSURFACE)
                    changed = call_func(r_getEdit,{lId})
                    if changed then
                        setBackground(changed,0,lColor)
                    end if
                elsif ctrl_Type[lId]=RichEdit then
                    VOID = sendMessage(lId,EM_SETBKGNDCOLOR,0,lColor)
                elsif ctrl_Type[lId]=StatusBar then
                    VOID = sendMessage(lId,SB_SETBKCOLOR,0,lColor)
                end if
            end if
-- use owner drawn menus or tab controls in order to get a non default color
-- same for dropdown lists in dropdowns or combos
-- for toolbars, you need to use XP's visual styles

            -- redraw the screen
            if hatched then
                ctrl_Hatch[lId] = lFillBrush
                if ctrl_Type[lId]=Window then
                    addStyle(lId,WS_CLIPCHILDREN)
                end if
                hdc = getDC(lId)
                w32Proc(xSetBkMode,{hdc,TRANSPARENT})
                VOID = w32Func(xSetBkColor,{hdc,bkData[2]})
                s = call_func(r_getClientRect,{lId})
                rect = w32acquire_mem(0,16)
                poke4(rect,s[1..4])
                VOID = w32Func(xFillRect,{hdc,rect,lFillBrush})
                w32release_mem(rect)
                releaseDC(lId)
            else
                ctrl_Hatch[lId] = 0
                repaintWindow(lId)
            end if
        end if
    end for
end procedure

--/topic Attributes
--/proc setWindowBackColor( object id, object Color )
--/desc Sets the background of /i id to /i color.
-- This is used to change the background color of a window or control.
--
-- /i id can be a single control id or a list of ids.
--
-- /i Color can either be an atom with a rgb value or a three-element sequence
-- formated as {red, green, blue} values (0-255). /n
-- You can also use /getSysColor to get a default system color. /b
-- This will trigger an /Paint event.
--
-- /b Note: this will not affect menus, tab controls, buttons and toolbars.
--
-- Example:
--
--/code
--          -- Set the window background color to bright white
--          /setWindowBackColor( MyWindow, BrightWhite )
--          -- Set a list's background color to salmon pink
--          /setWindowBackColor( List1, {255, 128, 128} )
--          -- Set an edit field to look like a button color.
--          /setWindowBackColor( Edit1, getSysColor(COLOR_BTNFACE) )
--          -- Set a group of controls
--          /setWindowBackColor( {ctl1, ctl2, ctl3}, Cyan)
--/endcode
global procedure setWindowBackColor(object id, object rgbColor)
    setBackground(id,w32False,rgbColor)
end procedure


-----------------------------------------------------------------------------
-- CREATING CONTROLS
--
-----------------------------------------------------------------------------

-- added CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: The handle-id pairing for menus wouldn't work, because menus have no attached user data
-- Enhanced: now x is a position parameter, y a rank or id, cx the unchecked bitmaphandle, cy the checked bitmap handle, exFlags is hBitmap

--/topic Menus
--/func getMenuPosn(integer id)
--/desc Get the zero-based relative position of a menu item.
--/ret INTEGER: Zero-Based Position of the menu item, or -1 if not a menu item.
--/i id is the id of a menu (item).
--
--Example
--/code
--  integer pos
--  pos = getMenuPosn(miSave)
--/endcode

global function getMenuPosn(integer id)
    if validId(id) and find(ctrl_Family[id],{MENU,MENUITEM}) then
        return find(id,ctrl_Group[ctrl_Parent[id]])-1
    else
        return -1
    end if
end function

--/topic Menus
--/func setMenuItemBitmaps(integer id,object bitmap)
--/desc Sets the bitmap on a menu item, or the checked/unchecked marks
--/ret SEQUENCE: the handles for unchecked,checked and main bitmaps
-- /i id is the identifier of the menu item to be considered.
-- If /i bitmap is an atom, it is the handle to the bitmap displayed by the item.
-- If it is a sequence starting with a pair, the pair is {unchecked mark handle,checked mark handle}, and these marks will be set.
-- If it is an empty sequence, no attempt to change anything will be made.
-- Otherwise, bitmap is some text to be displayed instead of the current bitmap, if any.
-- The returned value always has 3 elements, unless the function fails in any way, in which case it returns {}.
global function setMenuItemBitmaps(integer id,object bitmap)
atom minfo,hmenu
integer itype,checkmarks
sequence result

    if not validId(id) and bitmap then
        return {}
    end if
    if ctrl_Type[id]!=MenuItem then
        return {}
    end if
    hmenu = w32lookup(ctrl_Parent[id],menu_ids,menu_handles)

    -- get info about the item
    minfo = w32to_memory(0,ID_MENUITEMINFO ,0)
    w32store(minfo,MENUITEMINFO_fMask,MIIM_CHECKMARKS+MIIM_TYPE)
    if not w32Func(xGetMenuItemInfo,{hmenu,id,0,minfo}) then
        return {}
    end if
    result = {w32fetch(minfo,MENUITEMINFO_hbmpUnchecked),w32fetch(minfo,MENUITEMINFO_hbmpChecked),0}
    itype = w32fetch(minfo,MENUITEMINFO_fType)

    -- set new the marks
    if sequence(bitmap) and length(bitmap)=1 and sequence(bitmap[1]) then
        checkmarks = 1
        w32store(minfo,MENUITEMINFO_hbmpUnchecked,bitmap[1][1])
        w32store(minfo,MENUITEMINFO_hbmpChecked,bitmap[1][2])
    else
        checkmarks = 0
    end if
    if and_bits(itype,MFT_BITMAP) then
        result[3] = w32fetch(minfo,MENUITEMINFO_dwTypeData)

        -- set new bitmap, or text
        if not checkmarks then
            if atom(bitmap) then
                w32store(minfo,MENUITEMINFO_dwTypeData,bitmap)
            else
                w32store(minfo,MENUITEMINFO_fType,xor_bits(itype,MFT_BITMAP+MFT_STRING))
                w32store(minfo,MENUITEMINFO_dwTypeData,w32acquire_mem(0,bitmap))
            end if
        end if
    elsif not checkmarks then
        if atom(bitmap) then
            w32store(minfo,MENUITEMINFO_fType,xor_bits(itype,MFT_BITMAP+MFT_STRING))
            w32store(minfo,MENUITEMINFO_dwTypeData,bitmap)
        else
            w32store(minfo,MENUITEMINFO_dwTypeData,w32acquire_mem(0,bitmap))
        end if
    end if
    if w32Func(xGetMenuItemInfo,{hmenu,id,0,minfo}) then
        return result
    else
        return {}
    end if
end function

constant mi_position = 1, mi_rank = 2,mi_hbmpunchecked = 3,mi_hbmpchecked = 4,mi_hbitmap = 5
global constant MP_AT = 1,MP_BEFORE = 2,MP_AFTER = 3,MP_END = 0

procedure createMenuBar(integer id)
    -- create a menu bar
    ctrl_Menu[id] = w32Func(xCreateMenu, {})
    if ctrl_Menu[id]=0 then
        warnErr(Err_CREATEMENU)
    end if
    -- attach the menu to the window
    if not w32Func(xSetMenu, {getHandle(id), ctrl_Menu[id]}) then
        warnErr(Err_SETMENU)
    end if

    VOID = call_func(r_subClassControl,{{Menu,id},ctrl_Menu[id]})
end procedure

-----------------------------------------------------------------------------
--/topic List Control
--/func getCount( list )
--/desc Get the count of items in /i list ( /List or /Combo )
--/ret Count of items, or zero if control's list is empty.
--
--This returns zero if /i list is not an appropriate control type.
--
-- Example:
--/code
--          -- count size of TheList
--          integer count
--
--          count = /getCount( TheList )
--/endcode
-- /getCount also works with /ListView controls.

-----------------------------------------------------------------------------
--/topic Menus
--/func getCount( menu )
--/desc Get the count of items in /i menu ( /Menu or /Popup )
--/ret Count of items, or zero if control's list is empty.
--
--This returns zero if /i menu is not an appropriate control type.
--
-- Example:
--/code
--          -- count size of TheList
--          integer count
--
--          count = /getCount( TheMenu )
--/endcode
global function getCount(atom id)

-- get count of items in list

integer msg

-- get the message, based on control type
    if      ctrl_Family[id]=LISTBOX then
        msg = LB_GETCOUNT

    elsif   ctrl_Family[id]=COMBO
       or ctrl_Type[id]=ComboBoxEx then
        msg = CB_GETCOUNT

    elsif ctrl_Type[id]=ListView then
        msg = LVM_GETITEMCOUNT

    elsif ctrl_Family[id]=MENU then
        return w32Func(xGetMenuItemCount,{ctrl_Handle[id]})

    else
        return 0
    end if

    return sendMessage(id, msg, 0, 0)

end function



function menuCreate(atom menuHandle,integer flag,atom id,sequence mText,sequence extraInfo)
integer pos,lRC,codepos
atom pstr
sequence s

    -- sanity check
    if length(w32get_bits(and_bits(flag,MF_SEPARATOR+MF_STRING+MF_BITMAP)))>1 then
        return 1
    end if
    if not find(extraInfo[mi_position],{MP_BEFORE,MP_AT,MP_AFTER,MP_END}) then
        codepos = MP_END  -- unknown position, assume at end
    else
        codepos = extraInfo[mi_position]
    end if
    if codepos!=MP_END and (not integer(extraInfo[mi_rank]) or extraInfo[mi_rank]<=0) then
        return 1
    end if

    if and_bits(flag,MF_BITMAP) then
        pstr = extraInfo[mi_hbitmap]
    else
        pstr = w32acquire_mem(0, mText)
    end if

    if codepos!=MP_END then
        if codepos=MP_AFTER then
            flag += MF_BYPOSITION
            pos = getMenuPosn(extraInfo[mi_rank])
        elsif codepos=MP_AT then
            flag += MF_BYPOSITION
            pos = extraInfo[mi_rank]-1
        else
            pos = extraInfo[mi_rank]
        end if
        if pos>=w32Func(xGetMenuItemCount,{menuHandle}) then
            codepos = MP_END
        end if
    end if
    if codepos!=MP_END then
        lRC = w32Func(xInsertMenu,{
                                   menuHandle,      -- menu to attach to
                                   pos,              -- id or rank following inserted item
                                   flag,                 -- string or seperator
                                   id,               -- id
                                   pstr})    -- text or bitmap
    else
        lRC = w32Func(xAppendMenu, {
                                    menuHandle,         -- menu to attach to
                                    flag,                       -- string or seperator
                                    id,                         -- id
                                    pstr})    -- text or bitmap
    end if
    if lRC then
        if extraInfo[mi_hbmpchecked] or extraInfo[mi_hbmpunchecked] then
            VOID = w32Func(xSetMenuItemBitmaps,{menuHandle,id,MF_BYCOMMAND,extraInfo[mi_hbmpunchecked],extraInfo[mi_hbmpchecked]})
        end if
        if codepos!=MP_END then
            if codepos=MP_BEFORE then
                pos = getMenuPosn(extraInfo[mi_rank])
            end if
            flag = w32lookup(menuHandle,menu_handles,menu_ids)
            s = ctrl_Group[flag][pos..length(ctrl_Group[flag])]
            ctrl_Group[flag][pos+1..length(ctrl_Group[flag])] = s[1..length(s)-1]
            ctrl_Group[flag][pos] = id
        end if
    end if
    w32release_mem(pstr)
    return not lRC

end function

procedure createMenu(integer id, sequence mText, integer owner,integer flag ,sequence extraInfo)

-- used to assign a menu or popup menu to a window
-- the structure is already created by create()
atom ownerHandle
atom mstyle
atom mid
integer family = ctrl_Family[id]

    -- create popup menu for this item
    ctrl_Handle[id] = w32Func(xCreatePopupMenu, {})
    ctrl_Handle_type[id] = kht_Menu
    if ctrl_Handle[id]=NULL then
        warnErr(Err_CREATEPOPUP)
    end if
    menu_ids &= id
    menu_handles &= ctrl_Handle[id]
    -- attach a menu item if it's not a popup
    if family=MENU then
        -- where does this attach to?
        if ctrl_Family[owner]=MENU or
           ctrl_Family[owner]=MENUITEM then
            ownerHandle = getHandle(owner)

        elsif ctrl_Family[owner]=WINDOW then
            ownerHandle = ctrl_Menu[owner]
        else
            ownerHandle = 0
        end if

        mstyle = find('!', mText)
        if mstyle!=0 then
            mText = mText[1..mstyle-1] & mText[mstyle+1..length(mText)]
            mid = id
        else
            flag = or_bits(flag, MF_POPUP)
            mid = ctrl_Handle[id]
        end if

        if menuCreate(ownerHandle,
                      flag,
                      mid,
                      mText,
                      extraInfo)
        then
            warnErr(Err_APPENDMENU)
        end if
    end if

    vRecent[w32RecentMenu] = id

end procedure

-----------------------------------------------------------------------------
procedure createMenuItem(integer id, sequence mText, integer owner, object styleFlags, sequence extraInfo)

integer flag,lRC
atom lMenuHandle

    lMenuHandle = getHandle(owner)

    -- store owner's handle
    ctrl_Handle[id] = lMenuHandle
    ctrl_Handle_type[id] = ctrl_Handle_type[owner]

    -- string, or seperator?
    if equal(mText, "-")    or length(mText)=0 then
        flag = MF_SEPARATOR
    elsif extraInfo[mi_hbitmap] then
        flag = w32or_all(MF_BITMAP & styleFlags)
    else
        flag = w32or_all(MF_STRING & styleFlags)
    end if

    -- create a menu item
    lRC = menuCreate(lMenuHandle,flag,id,mText,extraInfo)
    if lRC then
        warnErr(Err_APPENDMENUITEM)
    end if

end procedure

-----------------------------------------------------------------------------
--/topic System Attributes
--/func setAppName(sequence Name)
--/desc Sets the text used as a class name prefix for new Windows.
--/ret Zero if the same application name is not already running
--/b "This needs to be run before the first Window is created in your application."
--The initial value is /i "Win32Lib AppWindow"
--
--A non-zero return code is actually the Windows hWnd value for the other
-- instance of the application.
--
--
--Example
--/code
--     if setAppName("Super Database") != 0 then
--         warnErr("Application is already running")
--     end if
--/endcode

global function setAppName(sequence pName)
atom rc, ExWin


    if length(pName)>0 then
        vAppName = pName
    end if


    ExWin = w32acquire_mem(0, sprintf("%s 1", {vAppName}))

    rc = w32Func(xFindWindow, {ExWin, 0})

    w32release_mem(ExWin)

    return rc
end function

--/topic System Attributes
--/func getAppName()
--/desc Gets the application's name.
--/ret SEQUENCE: The application's name as set by /setAppName
global function getAppName()
    return vAppName
end function


--/topic System Attributes
--/func findWindow(sequence ClassName, sequence WindowTitle)
--/desc Looks to see if the named window exists in the system. Only top level or pop-up windows are inspected.
--/ret SEQUENCE: {0,0} if not found otherwise {id, hWnd} if found.
--
--/i ClassName can be zero or a string containing the registered
-- classname of the window you are looking for. /n
--/i WindowTitle can be zero or a string containing the sought after
-- window's caption text.
--
--/b "Note:" You must supply at least one non-zero parameter.
--
--Example
--/code
--      sequence h
--      h = findWindow(0, "Super Database")
--      if equal(h, {0,0}) then
--          -- not found
--      else
--          if h[1] > 0 then
--              -- A control in my running app
--          else
--              -- A window belonging to another app
--          end if
--      end if
--/endcode

global function findWindow(object pClassName, object pWindowCaption)
atom rc
atom id

    if equal(pClassName,0) and equal(pWindowCaption,0) then
        return {0,0}
    end if

    rc = w32Func(xFindWindow, {pClassName, pWindowCaption})
    if rc=0 then
        return {0,0}
    end if

    id = getId(rc)
    if not validId(id) then
        id = 0
    end if
    return {id, rc}
end function

integer regCount regCount = 1
sequence sharedClasses sharedClasses = {}
sequence sharedClassCount sharedClassCount = {}
-----------------------------------------------------------------------------
procedure registerClass(object szClassName)

-- register the application class
atom wndClassEx
atom lAppIcon
sequence lClassStyle
integer lExtraWinSpace

    if atom(szClassName) then
        lClassStyle = vWindowClassStyle
        lExtraWinSpace = 0
    else
        if length(szClassName)=3 and sequence(szClassName[1]) then
            lExtraWinSpace = szClassName[3]
        else
            lExtraWinSpace = 0
        end if
        lClassStyle = szClassName[2]
        szClassName = szClassName[1]
    end if

    lAppIcon = w32Func(xLoadIcon, {instance(), "exw"})
    if lAppIcon=0 then
        lAppIcon = w32Func(xLoadIcon, {NULL, IDI_APPLICATION})
    end if

    -- get some memory for the window class structure
    wndClassEx = w32to_memory(0,ID_WNDCLASSEX, {w32or_all(lClassStyle)
                                                       , WndProcAddress
                                                       ,0,0
                                                       , instance()
                                                       , lAppIcon
                                                       , NULL
                                                       , (-WindowColor-1)+1
                                                       , NULL
                                                       , szClassName
                                                       , lAppIcon
                                               })

    if w32Func(xRegisterClassEx, {wndClassEx})=0 then
        abortErr(Err_REGCLASS)
    end if

    -- Free structure
    w32release_mem(wndClassEx)

end procedure

--/topic System Attributes
--/func getClassName(integer id)
--/desc Gets the Windows Class name for the control.
--/ret SEQUENCE: The class name string
--
--Example
--/code
--      sequence lName
--      lName = getClassName( fld1 )
--/endcode
global function getClassName(integer id)
sequence lResult
atom lMem
integer lSize

    lSize = 256
    lMem = w32acquire_mem(0, lSize)
    lSize = w32Func(xGetClassName,{getHandle(id), lMem, lSize})
    lResult = peek({lMem, lSize})
    w32release_mem(lMem)
    return lResult
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setTextColor( integer window, object color )
--/desc Set the text color to use when drawing text in /i window.
-- To set the color of the graphics pen, use /setPenColor.
--
-- Example:
--/code
--          -- draw text in red in TheWindow
--          /setTextColor( TheWindow, Red )
--          /wPuts( TheWindow, "This text is in red" )
--          /setTextColor( TheWindow, "Cyan" )
--          /wPuts( TheWindow, "This text is in cyan" )
--/endcode


global procedure setTextColor(integer id, object color)

    -- set the text color for the window
    ctrl_Font[id][w32FontColor] = color

end procedure

-- Code from dEbUg_magic_box by Antonio Alessi
function get_effects(atom attrib)

    return and_bits(attrib, CFE_BOLD)
+and_bits(attrib, CFE_ITALIC)
+and_bits(attrib, CFE_UNDERLINE)
+and_bits(attrib, CFE_STRIKEOUT)

end function

function decodeREfont(integer id,sequence faceName)
atom color
sequence font_name

    color = ctrl_Font[id][w32FontColor]
    font_name = ctrl_Font[id][w32FontName]
    if length(faceName)=0 then
        faceName = {color,font_name}

    elsif length(faceName)=1 then
        if sequence(faceName[1]) then
            faceName = {color, faceName[1]}
        else
            faceName = {faceName[1], font_name}
        end if

    elsif length(faceName)=2 then
        if sequence(faceName[1]) then
            if atom(faceName[2]) then
                faceName = {faceName[2], faceName[1]}
            else --Ooops I've got two sequences
                faceName = {color, faceName[2]}
            end if
        else
            if atom(faceName[2]) then -- I've got two atoms
                faceName = {faceName[1], font_name}
            end if
        end if
    elsif length(faceName)>2    then
        faceName = {color, faceName}
    end if

    return faceName
end function

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setFont( object id, sequence w32FontName, object size, object attributes )
--/desc Set the font for a control or window.
--
-- /i id can be either a single control's id, or a sequence list of ids.
--
-- /i w32FontName is the name of a font, eg. "Arial" /n
-- For RichEdit controls this parameter can also specify the color of the font.
-- In this case it takes to form {color, name}, eg.  {Red, "Arial"}
--
-- The /i attributes flag can be a atom that combines the following:
--
-- /li /b Normal
-- /li /b Bold
-- /li /b Italic
-- /li /b Underline
-- /li /b Strikeout
--
-- or a sequence of nine elements. This form is used when using non-TrueType
-- fonts or using some of the advanced features of the Windows font engine. /n
--
--/li [1] Attributes (eg Bold+Italic)
--/li [2] Average Char Width
--/li [3] Escapement  (How much it slopes in 10-degree increments)
--/li [4] Orientation (Should be set to the same as Escapement)
--/li [5] CharSet  (eg. ANSI_CHARSET, SYMBOL_CHARSET)
--/li [6] OutPrecision
--/li [7] ClipPrecision
--/li [8] Quality
--/li [9] PitchAndFamily
--
-- For RichEdit controls only, the /i attrib parameter can also prepend "ALL"
-- to the attrib sequence so that all the text is set to the font, otherwise
-- the change of font just applies to the insertion point.
--
-- For example:
--
--/code
--      -- change the font in MyWindow
--      setFont( MyWindow, "Arial", 10, Bold+Italic )
--      /wPuts( MyWindow, "This is Arial 10 point bold italic." )
--
--      setFont( MyWindow, "System", 14, {Bold,0,0,0,ANSI_CHARSET,0,0,0,0} )
--
--      setFont( MyWindow, "Symbol", 10, {0,0,0,0,SYMBOL_CHARSET,0,0,0,0} )
--
--      change all the text to courier.
--      setFont( MyRichEdit, "Courier New", 12, {"ALL",Normal} )
--
--      -- Set a group of fields to all the same font.
--      setFont( {fld1, fld3, fld2, fld7}, "Arial", 10, Normal)
--/endcode

global procedure setFont(object id, sequence faceName, object points, object attrib)
-- set the current font attributes
-- Window fonts are set as attributes for later assignment
atom
        hFont,
        color,
        effects,
        font_effect,
        hdc
sequence
        lResult
integer
        ppi

    if atom(points) then
        points = floor(points+0.5)
    end if

    if sequence(id) then
        for i=1 to length(id) do
            setFont(id[i], faceName, points, attrib)
        end for
        return
    end if

    -- Note that the faceName is {color, "faceName"} for RichEdit
    if ctrl_Type[id]=RichEdit then
        -- Do some sanity checks on this parameter.

        faceName = decodeREfont(id,faceName)
        color = faceName[1]
        faceName = faceName[2]
        ctrl_Font[id][w32FontColor] = color

        font_effect = SCF_SELECTION
        if sequence(attrib) then
            if length(attrib)=0 then
                attrib = Normal
            else
                if sequence(attrib[1]) then
                    if equal(attrib[1], "ALL") then
                        font_effect = SCF_ALL
                    else
                        font_effect = SCF_SELECTION
                    end if
                    attrib = attrib[2..length(attrib)]
                end if
                if length(attrib)=0 then
                    attrib = Normal
                elsif length(attrib)=1 then
                    attrib = attrib[1]
                end if
            end if
        end if

    end if

    ctrl_Font[id][w32FontName]   = faceName
    ctrl_Font[id][w32FontSize]   = points
    ctrl_Font[id][w32FontAttrib] = attrib

    if ctrl_Type[id]=RichEdit then
        effects = 0

        lResult = findTrackedObject(id, {faceName,points,attrib,color})
        if length(lResult)=0 then
            if atom(attrib) then
                effects = get_effects(attrib)
            else
                effects = get_effects(attrib[1])
            end if
            if atom(points) then
                hdc = getDC(id)
                ppi = w32Func(xGetDeviceCaps,{hdc,LOGPIXELSY})
                points = -convPointsToLogical(id,floor(0.5+((points*1440)/ppi)),vFontResolution)
                releaseDC(id)
            else
                points = points[1]
            end if
            hFont = w32to_memory(0,ID_CHARFORMAT, {CFM_ALL , effects, points, 0, color,
                                                   0, 0, faceName})

           -- track it
            trackObject({id,kFontObject}, {hFont,{faceName,points,attrib,color}}, ForProgram)
        else
            hFont = lResult[1]
        end if

        VOID = sendMessage(id, EM_SETCHARFORMAT, font_effect, hFont)

    elsif find(id,{Printer, Screen})
    or
    find(ctrl_Family[id], {WINDOW, PIXMAP, MENU, MENUITEM, POPUP})  then
        -- defer creation until print event
    else
        -- create now

        hFont = EzCreateFont(id, 0, faceName,
                             w32iff(sequence(points), points,points*10), 0, attrib,
                             vFontResolution, 0)

        -- update immediately
        VOID = sendMessage(id, WM_SETFONT, hFont, w32True)

    end if

end procedure

sequence FontDefaults

--/topic System Attributes
--/func setCreateFont( sequence faceName, atom points, object attrib, atom color )
--/desc sets the font used for controls when they are created.
--/ret SEQUENCE: The previous values for the creation font.
--When controls are created, they need to have a font associated with them. By
-- default Win32lib initially uses "ms sans serif", 8 point, Normal. You
-- can use this function to set a different font for new controls rather than
-- change the font after they are created.
--
--Example
--/code
--      sequence oldFont
--      -- Set a special font to use.
--      oldFont = setCreateFont("Times New Roman", 14, Normal, Black)
--      -- Create some controls
--      fldA = create(Editbox, ...
--      fldB = create(Editbox, ...
--      fldC = create(List, ...
--      -- Restore fot to initial one.
--      VOID = setCreateFont(oldFont[1], oldFont[2], oldFont[3], oldFont[4])
--/endcode
global function setCreateFont(sequence faceName, atom points, object attrib, atom color)
sequence lOldFont
    lOldFont = FontDefaults

    FontDefaults = {faceName, floor(points+0.5), attrib, color}

    return lOldFont
end function

--/topic System Attributes
--/func adjustCreateFont( sequence changes)
--/desc changes some of the attributes of the font used for controls when they are created.
--/ret SEQUENCE: The previous values for the creation font.
-- When controls are created, they need to have a font associated with them. By
-- default Win32lib initially uses "ms sans serif", 8 point, Normal. You
-- can use this function to set a different font for new controls rather than
-- change the font after they are created.
--
-- The /i changes sequence is a sequence of pairs. The first element in a pair is any of
-- w32FontName, w32FontSize, w32FontAttrib or w32FontColor. The second element is the new value.
-- Even if the change sequence is empty, the current value is returned.
--
--Example
--/code
--      sequence oldFont
--      -- Set a bigger font to use.
--      oldFont = adjustCreateFont({w32FontSize,14})
--      -- Create some controls
--      fldA = create(Editbox, ...
--      fldB = create(Editbox, ...
--      fldC = create(List, ...
--      -- Restore fot to initial one.
--      VOID = setCreateFont(oldFont[1], oldFont[2], oldFont[3], oldFont[4])
--/endcode

global function adjustCreateFont(sequence changes)
sequence lOldFont
object pair

    lOldFont = FontDefaults
    for i=1 to length(changes) do
        pair = changes[i]
        if atom(pair) or length(pair)!=2 or sequence(pair[1]) then
        elsif pair[1]=w32FontName and sequence(pair[2]) then
            FontDefaults[w32FontName] = pair[2]
        elsif pair[1]=w32FontSize and atom(pair[2]) then
            FontDefaults[w32FontSize] = floor(pair[2]+0.5)
        elsif pair[1]=w32FontAttrib and atom(pair[2]) then
            FontDefaults[w32FontAttrib] = pair[2]
        elsif pair[1]=w32FontColor then
            FontDefaults[w32FontColor] = colorValue(pair[2])
        end if
    end for
    return lOldFont
end function

integer r_MakeArgs
constant w32AKey = 1, w32AValue = 2
-- w32forms.ew structure constants
-- Grab the Win32lib default values from the system environment symbol "w32Defaults"
procedure GetDefaults()
object lDefaults

-- Hardcoded defaults.
    FontDefaults    = {"ms sans serif", 8, 0, Black}

    lDefaults = getenv("w32Defaults")
    if sequence(lDefaults) then
        lDefaults = call_func(r_MakeArgs,{lDefaults, ',', ':'})
        for i=1 to length(lDefaults) do
            if equal(lDefaults[i][w32AKey], "FONT") then
                if length(lDefaults[i])=2 then
                    FontDefaults = lDefaults[i][w32AValue]
                    if length(FontDefaults)=0 then
                        FontDefaults = {{{},"ms sans serif"}}
                    end if
                    if length(FontDefaults)=1 then
                        FontDefaults = append(FontDefaults, {{},8})
                    end if
                    if length(FontDefaults)=2 then
                        FontDefaults = append(FontDefaults, {{},Normal})
                    end if
                    if length(FontDefaults)=3 then
                        FontDefaults = append(FontDefaults, {{},Black})
                    end if
                end if
                for j=1 to 4 do
                    FontDefaults[j] = FontDefaults[j][2]
                end for
            end if
        end for
    end if
end procedure
GetDefaults()

--/topic RichEdit Controls
--/func getSelectionFont(integer id)
--/desc Returns the address of a LOGFONT structure which describes the font used in the selection.
--/ret (ATOM) 0 on failure, address of the LOGFONT structure on success.
-- Failure will occur if the control is not a RichEdit, or if the character in the selected range don't have the same font.
-- You must free the returned memory when done with it.
global function getSelectionFont(integer id)
atom result

    result = 0
    if ctrl_Type[id]=RichEdit then
        result = w32to_memory(0,ID_CHARFORMAT, {0,0,0,0,0,0,0,""})
        VOID = sendMessage(id, EM_GETCHARFORMAT, SCF_SELECTION, result)
    end if
    return result
end function

------------------------------------+-----------------------------------------
--/topic Controls
--/proc createWindow( object id, sequence caption,atom owner, atom x, atom y, atom xSize, atom ySize,object styleFlags, object exFlags )
--/desc Creates or reuses a window class for the supplied control id.
-- This is used internally to create all windows.. You may wish to call this when creating a custom control.
-- See groupadv.ew for an example of use.
global procedure createWindow(object id, sequence caption,
            atom owner, atom x, atom y, atom xSize, atom ySize,
            object styleFlags, object exFlags)
atom szClassName
atom hWnd, hParent, hMenu
atom lFlags, lExFlags, pstr
integer cloned,shared
object lColor

    cloned = sequence(id)
    hMenu = 0
    if not cloned then
        -- need to register each window, so each has seperate background
        -- color attributes, etc.
        szClassName = w32acquire_mem(0, sprintf("%s %d", {vAppName, regCount}))
        regCount += 1
        ctrl_ClassAddr[id] = szClassName

        registerClass(szClassName)
    else
        cloned = id[2]
        szClassName = ctrl_ClassAddr[cloned]
        id = id[1]
        shared = find(szClassName,sharedClasses)
        if shared then
            sharedClassCount[shared] += 1
        else
            sharedClasses = append(sharedClasses,szClassName)
            sharedClassCount &= 2
            hMenu = ctrl_Menu[cloned]
        end if
    end if

    -- if flags specified, combine them with the defaults
    if atom(styleFlags) then
         -- combine with user's values
        lFlags = or_bits(classStyle[ctrl_ActualClass[id]] , styleFlags)
    else
        -- replace with user's values
        lFlags = w32or_all(styleFlags)
    end if

    -- extended flags
    if atom(exFlags) then
        lExFlags = or_bits(classStyleEx[ctrl_Type[id]], exFlags)
    else
        lExFlags = w32or_all(exFlags)
    end if

    if owner then
        hParent = getHandle(owner)
    else
        hParent = NULL
    end if

    pstr = w32acquire_mem(szClassName, caption)
    hWnd = w32Func(xCreateWindow, {
                                   lExFlags,                -- extended style
                                   szClassName,         -- window class name
                                   pstr,  -- window caption
                                   lFlags,              -- window style
                                   x,                       -- initial x position
                                   y,                       -- initial y position
                                   xSize,                   -- initial x size
                                   ySize,                   -- initial y size
                                   hParent,             -- parent window handle
                                   hMenu,                    -- window menu handle
                                   instance(),          -- program instance handle
                                   NULL})               -- creation parameters

    if hWnd=0 then
        abortErr(Err_CREATEWINDOW)
    end if

    -- save attributes
    vRecent[w32RecentWindow] = id
    setId(hWnd, id)
    ctrl_Handle[id] = hWnd
    ctrl_Handle_type[id] = kht_Window
    ctrl_Parent[id] = owner

    -- set the text and background colors

--    setTextColor( id,  w32Color_WINDOWTEXT  )
--    call_proc(r_setBackColor,{ id,  w32Color_WINDOW  })
    if not cloned then
        lColor = ctrl_Bg_Color[id]
        setBackground(id, sequence(lColor),lColor)
    else
        ctrl_Bg_Color[id] = ctrl_Bg_Color[cloned]
    end if

    -- set default font
    setDefaultFont(id)
    setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])

    if owner!=0 then
        if  and_bits(WS_VISIBLE, lFlags) then
            call_proc(r_openWindow, {id, Normal})
        end if

        if and_bits(WS_TABSTOP, lFlags) then
            -- add to the owner's focus_order list
            ctrl_Focus_order[owner] &= id
        end if
    end if


end procedure

-----------------------------------------------------------------------------

--/topic Attributes
--/proc makeFront(object id)
--/desc Brings to control to the front
--/i id can either be a control's id value or take the form {hWnd}.
--
--Example:
--/code
--      atom hwnd_MsgWindow
--      hwnd_MsgWindow = getHandle(MsgWindow)
--      . . .
--      -- Using a control id
--      makeFront( GroupX )
--      -- Using a hWnd
--      makeFront( {hwnd_MsgWindow} )
--/endcode

--------------------------------------------
global procedure makeFront(object id)
--------------------------------------------
atom hWnd

    if sequence(id) then
        hWnd = id[1]
    else
        if id=0 then
            id = mainWindow
        end if
        hWnd = getHandle(id)
    end if
    VOID = w32Func(xSetForegroundWindow, {hWnd})

end procedure

procedure AddIconToImageList(integer pRtn, integer pIL, object pIcon)
    VOID = w32Func(pRtn,  getHandle(pIL) & pIcon)
end procedure

procedure ILAddIcon(atom himl, atom hicon)
    AddIconToImageList(ImageList_AddIcon , himl, hicon)
end procedure

procedure ILAdd(atom himl, atom hbmImage, atom hbmMask)
    AddIconToImageList(ImageList_Add, himl , {hbmImage, hbmMask})
end procedure

procedure ILAddMasked(atom himl, atom hbmImage)
    AddIconToImageList(ImageList_AddMasked, himl, {hbmImage, getTransparentColor()})
end procedure

function bmpToMask(sequence bmp)

    bmp[1] = {split_rgb(getTransparentColor()), split_rgb(Black)}

    for i=1 to length(bmp[2]) do
        for j=1 to length(bmp[2][i]) do
            if bmp[2][i][j] then
                bmp[2][i][j] = 1
            end if
        end for
    end for

    return bmp
end function

--/topic Image Lists
--/func addEuBmp( bmp )
--/desc Adds EuBitmaps to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addEuBmp:
-- /li /b bmp is a sequence in Eu Bitmap form
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b xpm is a sequence of 3 Eu Bitmaps
--      used for /FlatToolBar
-- The Bitmaps passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
global function addEuBmp(object bmp)
sequence list, dib

    if length(bmp)=1 then
        list = ilicon_list

        dib = {
               w32Func(CopyImage, {createDIB(bmp), 32, 32, IMAGE_BITMAP,
                                   LR_COPYDELETEORG}),
               w32Func(CopyImage, {createDIB(bmpToMask(bmp)) , IMAGE_BITMAP,
                                   32, 32, w32or_all({LR_MONOCHROME, LR_COPYDELETEORG})})}

        ILAdd(ILlarge, dib[1], dib[2])
        ILAdd(ILsmall, dib[1], dib[2])

        VOID = w32Func(xDeleteObject, {dib[1]})
        VOID = w32Func(xDeleteObject, {dib[2]})

        list &= 0

        ilicon_list = list

    else

        list = FTB_images
        dib = repeat({}, 3)

        for i=1 to 3 do
            dib[i] = {
                      w32Func(CopyImage,
                              {createDIB(bmp[i]), IMAGE_BITMAP, 32, 32,
                               LR_COPYDELETEORG}),

                      w32Func(CopyImage, {createDIB(bmpToMask(bmp[i])) ,
                                          IMAGE_BITMAP, 32, 32,
                                          w32or_all({LR_MONOCHROME, LR_COPYDELETEORG})})}

        end for

        ILAdd(himlFTBDefault, dib[1][1], dib[1][2])
        ILAdd(himlFTBHot, dib[2][1], dib[2][2])
        ILAdd(himlFTBDisabled, dib[3][1], dib[3][2])

        for i=1 to 3 do
            VOID = w32Func(xDeleteObject, {dib[i][1]})
            VOID = w32Func(xDeleteObject, {dib[i][2]})
        end for

        list &= {{0,0,0}}
        FTB_images = list
    end if

    return length(list)

end function

integer pm
pm = 0

function createMonochromeDIB(atom hBmp)
atom dib, p, t
sequence bmp, test

    if not pm then
        pm = call_func(r_createEx, {Pixmap, "", 0, 0, 0, 31, 31, 0, 0})
    end if

    setPenColor(pm, getTransparentColor())
    drawRectangle(pm, 1, 1, 32, 32, w32True)
    drawBitmap(pm, hBmp, 0, 0)

    bmp = repeat(repeat(' ', 32), 32)
    test = bmp
    p = getPixel(pm, 1, 1)

    for i=1 to 30 do
        for j=1 to 30 do
            t = getPixel(pm, j, i)
            if t!=p then
                bmp[i][j] = 'x'
            end if
            test[i][j] = t
        end for
    end for

    dib = textToBitmap(bmp)
    dib = w32Func(CopyImage, {dib, IMAGE_BITMAP, 32, 32, LR_MONOCHROME})

    return dib
end function

--/topic Image Lists
--/func addDIB( hBmp )
--/desc Adds DIB's to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addDIB:
-- /li /b hBmp is a handle to a DIB (see /createDIB)
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b hBmp is a sequence of 3 handles to DIBs
--      used for /FlatToolBar
-- The DIBs passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
-- NOTE: This function does not work very well, due to difficulties
-- in generating a mask for the image.  Use /addEuBmp or /addXpm if
-- possible.

global function addDIB(object hBmp)
integer iIcon
sequence list
object bmp


    if atom(hBmp) then
        list = ilicon_list
    else
        list = FTB_images
    end if

    iIcon = find(hBmp, list)

    if iIcon then
        return iIcon
    end if

    iIcon = length(list)

    if atom(hBmp) then

        bmp = w32Func(CopyImage, {hBmp, IMAGE_BITMAP, 32, 32, 0})

        ILAddMasked(ILlarge, hBmp)
        ILAddMasked(ILsmall, hBmp)

        VOID = w32Func(xDeleteObject, {hBmp})

        list &= hBmp
        ilicon_list = list

    else
        -- Need to use CopyImage, since the mask feature wrecks the image
        bmp = repeat({0,0}, 3)

        for i=1 to 3 do

            bmp[i][1] = w32Func(CopyImage,
                                {hBmp[i], IMAGE_BITMAP, 32, 32, 0})

            bmp[i][2] = createMonochromeDIB(bmp[i][1])


        end for

        ILAdd(himlFTBDefault, bmp[2][1], bmp[1][2])
        ILAdd(himlFTBHot, bmp[1][2], bmp[2][2])
        ILAdd(himlFTBDisabled, bmp[1][1], bmp[3][2])

        for i=1 to 3 do
            for j=1 to 2 do
                VOID = w32Func(xDeleteObject, {bmp[i][j]})
            end for
        end for

        list &= {hBmp}
        FTB_images = list

    end if


    return iIcon+1

end function

--/topic Image Lists
--/func addXpm( xpm )
--/desc Adds xpm's to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addXpm:
-- /li /b xpm is an xpm sequence
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b xpm is a sequence of 3 xpm's
--      used for /FlatToolBar
-- The xpm's passed for the /FlatToolBar should be the xpms to be used
-- for the default, hot and disabled images, respectively.
global function addXpm(sequence xpm)
sequence xpm_mask, himl
object hIcon, iIcon
object hbmp, hmask

    if length(xpm)=3 then
        xpm_mask = {}
        hIcon = {}

        himl = {himlFTBDefault, himlFTBHot, himlFTBDisabled}
        for i=1 to 3 do

            hbmp = createDIB(call_func(r_xpmToEuBmp,{xpm[i]}))

            hmask = createDIB(bmpToMask(call_func(r_xpmToEuBmp,{xpm[i]})))

            hbmp  = w32Func(CopyImage, {hbmp, IMAGE_BITMAP, 32, 32,
                                        LR_COPYDELETEORG})
            hmask = w32Func(CopyImage, {hmask, IMAGE_BITMAP, 32, 32,
                                        w32or_all({LR_MONOCHROME, LR_COPYDELETEORG})})

            ILAdd(himl[i], hbmp, hmask)
            hIcon &= hbmp

        end for

        FTB_images &= {hIcon}
        iIcon = length(FTB_images)
    else
        hbmp = createDIB(call_func(r_xpmToEuBmp,{xpm}))
        hmask = createDIB(bmpToMask(call_func(r_xpmToEuBmp,{xpm})))
        ILAdd(ILlarge, hbmp, hmask)
        ILAdd(ILsmall, hbmp, hmask)
        ilicon_list &= hbmp
        iIcon = length(ilicon_list)
    end if


    return iIcon
end function

-----------------------------------------------------------------------------
procedure createTabItem(integer id, sequence caption, integer pOwner,integer tabNumber,integer imgIndex)

-- insert a tab into a tab control
integer numItems,mask
atom hTabData, hTabItem

    if ctrl_Type[pOwner]!=TabControl then
        abortErr(Err_CREATETABITEM2)
    end if

    numItems = length(ctrl_Specific[pOwner])
    -- get tab index
    if tabNumber<=0 or tabNumber>numItems+1 then
        tabNumber = numItems
    else
        tabNumber -= 1
    end if

    -- Allocate a tab structure
    hTabData = w32acquire_mem(0, SIZEOF_TC_ITEM)

    if imgIndex>0 then
        if ctrl_ImageList[pOwner]=0 then
            VOID = sendMessage(pOwner,TCM_SETIMAGELIST,0,hILsmall)
            ctrl_ImageList[pOwner] = hILsmall
        elsif ctrl_ImageList[pOwner]!=hILsmall then
            imgIndex = w32Func(ImageList_AddIcon,{ctrl_ImageList[pOwner],ilicon_list[imgIndex]})+1
        end if
    end if

    -- set the items
    if imgIndex>0 then
        mask = TCIF_TEXT+TCIF_IMAGE
    else
        mask = TCIF_TEXT
    end if

    w32store(hTabData, TC_ITEM_mask, mask)
    w32store(hTabData, TC_ITEM_iImage, imgIndex-1)
    w32store(hTabData, TC_ITEM_pszText, caption)

    -- insert into tab list
    hTabItem = sendMessage(pOwner, TCM_INSERTITEM, tabNumber, hTabData)

    -- add id to owner's tab list
    if hTabItem= -1 then
        abortErr(Err_CREATETABITEM)
    elsif tabNumber=numItems then
        ctrl_Specific[pOwner] &= id
    else
        ctrl_Specific[pOwner] = w32insertElement(ctrl_Specific[pOwner],tabNumber+1,id)
    end if

    -- store the handle
    ctrl_Handle[id]  = ctrl_Handle[pOwner] --hTabItem
    ctrl_Handle_type[id] = kht_TabItem

    -- Free the structure
    w32release_mem(hTabData)

    vRecent[w32RecentWindow] = id

end procedure




--/topic System Attributes
--/func getActiveWindow()
--/desc Returns the /b id of the control that the user is working on.
--/ret INTEGER: The id of the window or 0 if the app does not have an active window.
--You can use this to find out if the application is currently the active one.
--
--Example:
--/code
--      integer ActiveID
--      ActiveID = getActiveWindow()
--      if ActiveID = 0 then
--          -- No window for this app is active
--      else
--          -- I have an active window.
--      end if
--/endcode
global function getActiveWindow()
atom lId

    lId = getId(w32Func(xGetForegroundWindow, {}))
    if not validId(lId) then
        lId = 0
    end if

    return lId
end function

--/topic Attributes
--/func findParent(object id)
--/desc Used to find the owning control for the specified /i id.
--/ret The id of the control that owns the one specified.
-- This can be used for TreeView items as well by using the syntax for /i id
-- as { TV, TVItemId }
--
-- If the /i id has no parent, this function returns 0. /n
-- If the /i id is invalid, this function returns -1. /n

global function findParent(object id)
integer lOwner

    if sequence(id) then
        if ctrl_Type[id[1]]=TreeView then
            if id[2]>0 and id[2]<=length(tvitem_data) then
                lOwner = tvitem_parent[id[2]]
            else
                lOwner = -1
            end if
        else
            lOwner = -1
        end if
    else
        lOwner = ctrl_Parent[id]
    end if

    return lOwner
end function

--/topic Attributes
--/func getParent(object id)
--/desc an alias for /findParent
--/ret The id of the control that owns the one specified.

global function getParent(object id)
    return findParent(id)
end function

--/topic Attributes
--/func getChildren(integer id)
--/desc Used to get all the child controls contained in the specified /i id.
--/ret SEQUENCE: Contains two subsequences {{idlist}, {controlTypes}}.
-- The first subsequences is a list of all the child controls' ids. /n
-- The second subsequence is a list of their corresponding control type codes. /n
-- It returns an empty subsequences if the /i id has no children. /n
-- For subclassed controls, if the application didn't create children and they have no items,
-- a sequence containing a single handle list is returned.
--
--/see /findChildren
--
--Example
--/code
--    sequence children
--    -- Get a list of all the controls owned by this window
--    children = getChildren(myWin)
--
--    -- Set the caption for each of the PushButtons.
--    for i = 1 to length(children) do
--       if find(children[2][i],{PushButton,DefPushButton}) then
--          setText(children[1][i], sprintf("Button%d", i))
--       end if
--    end for
--/endcode
global function getChildren(integer id)
sequence lChildren
integer thisRequest

    lChildren = {{},{}}
    if ctrl_Type[id]=TabItem then

        for i=1 to length(ctrl_Group[id]) do
            lChildren[1] &= ctrl_Group[id][i]
            lChildren[2] &= ctrl_Type[ctrl_Group[id][i]]
        end for

    elsif ctrl_Type[id]=TabControl then
        -- Can only allow tabitems to be children
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i]=id and ctrl_Type[i]=TabItem then
                lChildren[1] &= i
                lChildren[2] &= ctrl_Type[i]
            end if
        end for

    elsif ctrl_FormerId[id] and not length(ctrl_Group[id]) then
    -- subclassed control
        hrequests &= getHandle(id)
        crequests = append(crequests,{})
        enumRequests += 1
        thisRequest = enumRequests
        VOID = w32Func(xEnumChildWindows,{getHandle(id),call_back(routine_id("childenum")),enumRequests})
        lChildren = {crequests[thisRequest]}
    else
        for i=1 to length(ctrl_Parent) do
            if ctrl_Parent[i]=id then
                lChildren[1] &= i
                lChildren[2] &= ctrl_Type[i]
            end if
        end for
    end if

    return lChildren
end function

--procedure copyTVChildren(sequence id,atom index,atom struct,atom instruct)
--  integer parent,idx
--  atom hSource,newchild,newdest
--
--  parent=tvitem_owner[index]
--  hSource=tvitem_handle[id[2]]
--  w32store(instruct,TVINSERTSTRUCT_hParent,index)
--  newchild=sendMessage(parent,TVM_GETNEXTITEM,TVGN_CHILD,hSource)
--  while newchild do
--      idx=find(newchild,tvitem_handle)
--      w32store(struct,TVITEM_hItem,newchild)
--      VOID=sendMessage(parent,TVM_GETITEM,0,struct)
--      newdest=sendMessage(id[1],TVM_INSERTITEM,0,instruct)
--      tvitem_handle[idx]=newdest
--      if w32fetch(struct,TVITEM_cChildren) then
--          copyTVChildren({id[1],idx},newdest,struct,instruct)
--          w32store(instruct,TVINSERTSTRUCT_hParent,index)
--      end if
--      newchild=sendMessage(parent,TVM_GETNEXTITEM,TVGN_NEXT,newchild)
--  end while
--end procedure

--/topic Menus
--/func removeMenu(integer id,integer item,integer flag,integer reuse)
--/desc Removes a menu item from a menu.
--/ret (INTEGER) w32False on failure, else nonzero.
-- /i item is a 0-based index if /i flag is w32False, else an item id which must belong
-- to the menu /i id (or the menu bar of the window /i id).
-- If /i reuse is w33False, Windows is asked to free the memory of the menu, effectively destroying /i item. By passing another value, and if /i item is a menu, the function will
-- leave the internal data alone and return the handle.

global function removeMenu(integer id,integer item,integer flag,integer reuse)
atom hmenu
integer rid,pos,id_pos

    if flag then
        pos = getMenuPosn(item)
    else
        pos = item
        item = ctrl_Group[id][item+1]
    end if
    if ctrl_Family[id]=WINDOW then
        hmenu = ctrl_Menu[id]
    elsif ctrl_Family[id]=MENU then
        hmenu = w32lookup(id,menu_ids,menu_handles)
    else
        return 0
    end if
    if ctrl_Family[item]=MENUITEM or not reuse then
        rid = xDeleteMenu
    else
        rid = xRemoveMenu
    end if
    if ctrl_Family[item]=MENU and not reuse then
        id_pos = find(item,menu_ids)
        menu_handles = w32removeIndex(id_pos,menu_handles)
        --ctrl_Menu[menu_ids[pos]]=-1
        menu_ids = w32removeIndex(id_pos,menu_ids)
    end if
    return w32Func(rid,{hmenu,pos,MF_BYPOSITION})
end function

function insertMenu(atom hp,atom id_or_h,object index,atom pStruct,integer flag,integer is_id)
integer id,lRC,pos
sequence s
integer pNewParent

    pNewParent = getId(hp)

    if atom(index) then
        if index=MP_END then
            index = {MP_END}
        elsif index>=0 then
            index = {MP_AT,floor(index)}
        else
            index = {MP_END}
        end if
    end if
    if index[1]!=MP_END then
        if index[2]<0 then
            index[2] = -(index[1]=MP_AFTER)
        elsif index[1]!=MP_AT and not find(index[2],ctrl_Group[pNewParent]) then
            index[1] = MP_END
        elsif index[1]=MP_AFTER and index[2]=ctrl_Group[pNewParent][length(ctrl_Group[pNewParent])] then
            index[1] = MP_END
        elsif index[1]=MP_AT and index[2]>w32Func(xGetMenuItemCount,{hp}) then
            index[1] = MP_END
        end if
    end if

    if not is_id then
        id = call_func(r_subClassControl,{{Menu,pNewParent},id_or_h})
    else
        id = id_or_h
    end if
    flag += MF_BYPOSITION

    if index[1]=MP_END then
        if ctrl_Family[id]=MENU and is_id then
            lRC = w32Func(xAppendMenu,{hp,flag,ctrl_Handle[id],pStruct})
        else
            lRC = w32Func(xAppendMenu,{hp,flag,id_or_h,pStruct})
        end if
        if lRC then
            ctrl_Group[pNewParent] &= id
        end if
    else
        if index[1]=MP_AT then
            pos = index[2]
        elsif index[2]=-1 then
            pos = 0
        else
            pos = getMenuPosn(index[2])+(index[1]=MP_AFTER)
        end if
        if ctrl_Family[id]=MENU and is_id then
            lRC = w32Func(xInsertMenu,{hp,pos,flag,getHandle(id),pStruct})
        else
            lRC = w32Func(xInsertMenu,{hp,pos,flag,id,pStruct})
        end if
        if lRC then
            s = ctrl_Group[pNewParent]&0
            s[pos+2..length(s)] = s[pos+1..length(s)-1]
            s[pos+1] = id
            ctrl_Group[pNewParent] = s
        end if
    end if

    if lRC then
        return id
    else
        return 0
    end if
end function

--/topic Menus
--/func attachMenuHandle(atom hMenu, integer newparent,object index,sequence caption)
--/desc Changes (or sets) the parent of the control /i id to /i newparent, using the /i index attachment data if it is relevant.
--/ret INTEGER: True if successful otherwise False.
-- This function works like /setParent(), but targets menus whose only the handle is known.
-- They may have been created from a memory template. Since such a menu has no caption,
-- you must supply one.

global function attachMenuHandle(atom hMenu, integer pNewParent,object index,sequence caption)
integer menubar,lRC
atom pStruct,hp,lOldParent

    if not w32Func(xIsMenu,{hMenu}) or not validId(pNewParent) then
        return 0
    end if

    hp = w32Func(xGetParent,{hMenu}) -- hopefully works
    if hp then
        if w32Func(xIsWindow,{hp}) and hMenu=w32Func(xGetMenu,{hp}) then
            return 0 -- don't reparent the menu bar
        end if
    end if

    menubar = 0
    if ctrl_Family[pNewParent]=WINDOW then
    -- inserting into a menu bar
        lOldParent = hp
        hp = ctrl_Menu[pNewParent]
        pNewParent = w32lookup(hp,menu_handles,menu_ids)
        menubar = 1
    end if

    if ctrl_Family[pNewParent]!=MENU then
        return 0
    end if

    pStruct = w32acquire_mem(0,caption)

    lRC = insertMenu(hp,hMenu,index,pStruct,MF_POPUP,0)

    if lRC and menubar then
        VOID = w32Func(xDrawMenuBar,{lOldParent})
    end if
    w32release_mem(pStruct)

    return lRC
end function

--/topic Attributes
--/func setParent(integer id, integer newparent,object index)
--/desc Changes (or sets) the parent of the control /i id to /i newparent, using the /i index attachment data if it is relevant.
--/ret INTEGER: True if successful otherwise False.
--
-- When /i id is a menu or menu item, /i index is a sequence {position_type,position_value,caption}:
--/li If position_type is MP_AT, position_value is an item 1-based index before which to insert.
--/li If position_type  is MP_BEFORE or MP_AFTER, position_value is a menu(item) identifier.
--/If position_type  is MP_END, the item is inserted at the end and position_value is ignored.
-- If index is an atom, it is assumed to mean {MP_END} if <0, and {MP_AT,index} otherwise.
-- You may optionally supply an alternate caption for parented items. Do so by including the new caption string as the third element of /i index.
--
-- When /i id references a TabItem, /i index is the new 1-based index it is suppose to have in its new parent.
-- Note that it is unsafe to change the parent of a subclassed TabControl or TabItem, since Windows doesn't keep track of the controls that display when some tab item is selected.
--
-- When /i id is a sequence {TV_id,TVitem_id}, /i index is a pair {new TVitem_id of parent, position}. The position is either a 1-based one to insert before, or any of:
--/li TVI_FIRST: insert as first child of parent
--/li TVI_LAST: insert as last child
--/li TVI_SORT: insert and then sort children of the parent in alphabetical ascending order.
-- To specify the root of a tree view, use indifferently 0 or the TVI_ROOT constant.
--
-- When /i id is a sequence and /i id[1] is a ListView, /i id[2] is an item id if /i id has more elements, or a 1-based position otherwise. Then, index is the position at which to insert in the target ListView.
--
-- Otherwise, index is {x,y}, the new position of the control, and the control /i id gets focus.

global function setParent(integer id, integer pNewParent,object index)
integer lRC,pos,flag,menubar,release
atom lOldParent,pStruct,hp
object data
sequence s

    if validId(pNewParent)=w32False or atom(ctrl_Group[pNewParent]) then     -- invalid parent
        return w32False
    end if

    if validId(id)=w32False then    -- invalid control
        return w32False
    end if

    if sequence(ctrl_Group[pNewParent]) and find(id,ctrl_Group[pNewParent]) then
    -- control already a child of the new parent
        return w32False
    end if

    if and_bits(classAttr[ctrl_Type[id]],w32Toolbar) then
        ctrl_Toolbar[ctrl_Parent[id]] = w32removeItem(id,ctrl_Toolbar[ctrl_Parent[id]])
        ctrl_Toolbar[pNewParent] &= id
    end if
    if and_bits(classAttr[ctrl_Type[id]],w32Statusbar) then
        ctrl_Statusbar[ctrl_Parent[id]] = 0
        ctrl_Statusbar[pNewParent] = id
    end if
    -- adjust ctrl_Focus_order
    data = ctrl_Focus_order[ctrl_Parent[id]]
    if sequence(data) and find(id,data) then
        ctrl_Focus_order[ctrl_Parent[id]] = w32removeItem(id,data)
    end if
    data = ctrl_Focus_order[pNewParent]
    if sequence(data) then
        ctrl_Focus_order[pNewParent] &= id
    end if

    hp = getHandle(pNewParent)
    release = 1

    if find(ctrl_Family[id],{MENU,MENUITEM}) then
        if ctrl_Family[ctrl_Parent[id]]=WINDOW then
        -- don't reparent the menu bar
            return 0
        end if
        menubar = 0
        if ctrl_Family[pNewParent]=WINDOW then
        -- inserting into a menu bar
            lOldParent = hp
            hp = ctrl_Menu[pNewParent]
            pNewParent = w32lookup(hp,menu_handles,menu_ids)
            menubar = 1
        end if
        if ctrl_Family[pNewParent]!=MENU then
            return 0
        end if

        if sequence(index) and length(index)>=3 then
            pStruct = w32acquire_mem(0,index[3])
        else
            pStruct = w32acquire_mem(0,call_func(r_getCaption,{id}))
        end if

        flag = w32Func(xGetMenuState,{ctrl_Handle[ctrl_Parent[id]],getMenuPosn(id),MF_BYPOSITION})
        if ctrl_Family[id]=MENU then
            flag = and_bits(flag,#FF)
        end if

        lRC = insertMenu(hp,id,index,pStruct,flag,1)

        if lRC then
            VOID = w32Func(xRemoveMenu,{ctrl_Handle[ctrl_Parent[id]],find(id,ctrl_Group[ctrl_Parent[id]])-1,MF_BYPOSITION})
            ctrl_Group[ctrl_Parent[id]] = w32removeItem(id,ctrl_Group[ctrl_Parent[id]])
            if menubar then
                VOID = w32Func(xDrawMenuBar,{lOldParent})
            end if
            ctrl_Parent[id] = pNewParent
        end if
    elsif ctrl_Type[id]=TabItem then
        pStruct = w32acquire_mem(0,SIZEOF_TC_ITEM)
        w32store(pStruct,TC_ITEM_mask,TCIF_TEXT+TCIF_IMAGE+TCIF_PARAM)
        pos = find(id,ctrl_Specific[ctrl_Parent[id]])
        if pos then
            pos -= 1
            index -= 1
            VOID = sendMessage(ctrl_Parent[id],TCM_GETITEM,pos,pStruct)
            lRC = sendMessage(pNewParent,TCM_INSERTITEM,index-(index>0),pStruct)
            if lRC then  -- can optimise when the parent remains the same
                ctrl_Group[pNewParent] &= id
                s = ctrl_Specific[pNewParent]&0
                s[index+1..length(s)] = s[index..length(s)-1]
                s[index] = id
                ctrl_Specific[pNewParent] = s
                if pNewParent!=ctrl_Parent[id] then
                    for i=1 to length(ctrl_Group[id]) do
                        VOID = w32Func(xSetParent,{getHandle(ctrl_Group[id][i]),hp})
                    end for
                end if
                VOID = sendMessage(ctrl_Parent[id],TCM_DELETEITEM,pos,0)
                ctrl_Group[ctrl_Parent[id]] = w32removeItem(id,ctrl_Group[ctrl_Parent[id]])
                ctrl_Specific[ctrl_Parent[id]] = w32removeItem(id,ctrl_Specific[ctrl_Parent[id]])
            end if
        end if
--  elsif sequence(id) then
--      if not integer(id[1]) or not integer(id[2]) then
--          return 0
--      end if
--      if ctrl_Type[id[1]]=TreeView then
--          if not validId(id) or not validId({pNewParent,index[1]}) then
--              return 0
--          end if
--          hp=tvitem_handle[id[2]]
--          pStruct=w32to_memory(0,ID_TVITEM, {TVIF_TEXT+TVIF_STATE+TVIF_PARAM+TVIF_IMAGE+TVIF_SELECTEDIMAGE+TVIF_CHILDREN,hp,0,0,0,0,0,0,0,0})
--          inpStruct=w32to_memory(0,ID_TVINSERTSTRUCT, index & pStruct)
--          lRC=sendMessage(id[1],TVM_GETITEM,0,pStruct)
--          if lRC then
--              pos=tvitem_parent[id[2]]
--              lOldParent=sendMessage(pNewParent,TVM_INSERTITEM,0,inpStruct)
--              if lOldParent then
--                  tvitem_parent[id[2]]=index[1]
--                  tvitem_owner[id[2]]=tvitem_owner[index[1]]
--                  tvitem_handle[id[2]]=lOldParent
--                  -- now copy the children, if any
--                  if w32fetch(pStruct,TVITEM_cChildren) then
--                      w32store(inpStruct,TVINSERTSTRUCT_hInsertAfter,TVI_LAST)
--                      copyTVChildren(id,tvitem_handle[index[1]],pStruct,inpStruct)
--                  end if
--                  VOID=sendMessage(id[1],TVM_DELETEITEM,0,hp)
--                  lRC=1
--              else
--                  lRC=0
--              end if
--          end if
--          w32release_mem(inpStruct)
--      elsif ctrl_Type[id[1]]=ListView then
--          if ctrl_Type[pNewParent]!=ListView then
--              return 0
--          end if
--          if length(id)>2 then
--              pStruct=w32acquire_mem(0,20)
--              poke4(pStruct,LVFI_PARAM)
--              poke4(pStruct+8,id[2])
--              id[2]=sendMessage(id[1],LVM_FINDITEM,-1,pStruct)
--              w32release_mem(pStruct)
--          else
--              id[2]-=1
--          end if
--          if id[2]<0 or id[2]>=sendMessage(id[1],LVM_GETITEMCOUNT,0,0) or not integer(index) then
--              return 0
--          end if
--          pStruct=w32acquire_mem(0,SIZEOF_LVITEM)
--          w32store(pStruct,LVITEM_mask,LVIF_TEXT+LVIF_PARAM+LVIF_IMAGE+LVIF_STATE)
--          w32store(pStruct,LVITEM_stateMask,LVIS_DROPHILITED+LVIS_CUT+LVIS_FOCUSED+LVIS_SELECTED)
--          w32store(pStruct,LVITEM_iItem,id[2])
--          w32store(pStruct,LVITEM_iSubItem,0)
--          VOID=sendMessage(id[1],LVM_GETITEM,0,pStruct)
--          index-=1
--          if index<0 then
--              index=0
--          end if
--          lRC=sendMessage(pNewParent,TVM_INSERTITEM,0,pStruct)
--          if lRC>=0 then
--              VOID=sendMessage(id[1],LVM_DELETEITEM,0,pStruct)
--          end if
--      else
--          return 0
--      end if
    else
        release = 0
        lRC = (pNewParent=0)!=(ctrl_Parent[id]=0)
        if lRC and not ctrl_Parent[id] then
            removeStyle(id,WS_POPUP)
            addStyle(id,WS_CHILD)
        end if
        lOldParent = w32Func(xSetParent, {getHandle(id), hp})
        if ctrl_Parent[id] then
            ctrl_Group[ctrl_Parent[id]] = w32removeItem(id,ctrl_Group[ctrl_Parent[id]])
        end if
        ctrl_Parent[id] = pNewParent
        if lRC and not pNewParent then
            removeStyle(id,WS_CHILD)
            addStyle(id,WS_POPUP)
        end if
        lRC = (lOldParent!=0)
        call_proc(r_setCtlPosition,id & index)
        call_proc(r_setFocus,{id})
    end if

    if release then
        w32release_mem(pStruct)
    end if
    if lRC=0 then
        return w32False
    else
        return w32True
    end if

end function


--/topic Attributes
--/proc registerHotKey( integer id, object caption )
--/desc Allows you to associate a ALT-key combination to set focus to a control.
-- Any control or Window can have any number of hotkeys registered. /n
-- /i id is the control/window id returned by /create() /n
-- /i caption is either a single keycode, or a string containing a '&' character. /n
-- If using a keycode, you must use the keycode names in w32Keys.e. If using a string,
-- the uppercase version of the character following the '&' is used. /b Note that this
-- is happens automatically when you /create() a control with some caption text. Also,
-- the default pushbutton, if any, is automatically registered with VK_RETURN.
--
-- Typical use of this procedure is when a control is created without a caption.
--
-- example:
--/code
--       -- Attached the '+' keys to the addBtn control.
--       registerHotKey( addBtn, VK_ADD)
--       registerHotKey( addBtn, VK_OEM_PLUS)
--/endcode

-----------------------------------------------------------------------------
global procedure registerHotKey(integer id, object caption)

    -- register the hotkey with the parent window
integer at, parent, key

   -- find the parent window
    parent = findParentWindow(id)
    if parent=0 then
        return
    end if

    -- is this a default key?
    if ctrl_Type[id]=DefPushButton then
        -- associate the return key with the control
        ctrl_Hotkey_Keys[parent] &= VK_RETURN
        ctrl_Hotkey_Ids[parent]  &= id
    end if

    if sequence(caption) then
      -- is there a hotkey in the caption?
        at = find('&', caption)
        if at=0
        or
        at=length(caption)
      then
            return -- no hotkey symbol
        else
            key = upper(caption[at+1]) -- convert the key to upper case
        end if
    else
        key = caption
    end if
    -- register the key with the parent
    ctrl_Hotkey_Keys[parent] &= key
    ctrl_Hotkey_Ids[parent]  &= id

end procedure

global constant
w32GFD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCRIPTSONLY+CF_SCREENFONTS+CF_EFFECTS+CF_FORCEFONTEXIST,
w32GFD_OLD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCREENFONTS+CF_EFFECTS
-----------------------------------------------------------------------------
--/topic Dialogs
--/func getFontDialogEx( window, atom flags, object extra )
--/desc "Get Font" Dialog. /i flags controls which fonts are selectable, as well as other features of the dialog.
--/ret SEQUENCE: { font name, points, style flags, color } or -1 if cancelled.
-- flags is the sum of various flags. Supported values to add up are 
-- <a href="..\win32_constants.htm#getFontDialogEx() flags">listed here</a>
--
-- In addition, two canned flag combinations are provided:
--/li w32GFD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCRIPTSONLY+CF_SCREENFONTS+CF_EFFECTS+CF_FORCEFONTEXIST,
--     (default value corresponding to a call to getFontDialog())
--/li w32GFD_OLD_DEFAULT_FLAGS = CF_INITTOLOGFONTSTRUCT+CF_SCREENFONTS+CF_EFFECTS
--     (in library versions prior to v0.56, default value corresponding to a call to getFontDialog())
--
-- The /i extra argument can be any atom or a sequence of pairs. The first element of the 
-- pair is a flag name as above, and the second element depends on the flag. Only some values
-- for the flag are supported (and meaningful).
-- Conversely, if you specify a flag listed below, you must supply the corresponding extra data.
-- Results are undefined if extra data is missing when the use of a flag would require some.
--/li If the CF_SELECTSCRIPT flag is given, the second element is a character set identifier.
-- See a list of known identifiers <a href="..\win32_constants.htm#Character sets">here</a>.
--/li If the CF_LIMITSIZE flag is given, the second element is a pair {lower bound, upper bound}.
-- Sizes are measured in points.
--/li If the CF_USESTYLE flag is used, the second element is either a string or the address of a buffer for it.
--/li If the CF_ENABLETEMPLATE is used, the second element is a pair {module handle, template name} or {module handle,template name address}.
--/li If the CF_ENABLETEMPLATEHANDLE is used, the second element is a handle to a memory block holding the requested template.
--/li If the CF_ENABLEHOOK flag is used, then second element is the address of a hook procedure,
-- or a pair {hook address, pointer to custom data}.
--/li If the CF_INITTOLOGFONTSTRUCT flag is specified, the extra data is the address of a LOGFONT structure
-- prealably set up. The couple {CF_INITTOLOGFONTSTRUCT, addr} is not required if you 
-- use the CF_INITTOLOGFONTSTRUCT flag.

global function getFontDialogEx(integer id, atom flags, object extra)

integer points, attrib
sequence  font
atom hChooseFont, hLogFont, color, mset
object result
integer owner
atom extra_flag
integer charset
object extra_data

-- assume failure
    result = -1
    owner = findParentWindow(id)
    -- create structures
    mset = w32new_memset()
    charset = -1
    hChooseFont = w32acquire_mem(mset, SIZEOF_CHOOSEFONT)
    hLogFont = 0

    if sequence(extra) then
        for i=1 to length(extra) do
            extra_flag = extra[i][1]
            extra_data = extra[i][2]
            if and_bits(extra_flag,flags) then
                if extra_flag=CF_ENABLEHOOK then
                    if atom(extra_data) then
                        w32store(hChooseFont,CF_lpfnHook, extra_data)
                    else
                        w32store(hChooseFont,CF_lpfnHook, extra_data[1])
                        w32store(hChooseFont,CF_lCustData, extra_data[2])
                    end if
                elsif extra_flag=CF_LIMITSIZE then
                    w32store(hChooseFont,CF_nSizeMin, extra_data[1])
                    w32store(hChooseFont,CF_nSizeMax, extra_data[2])
                elsif extra_flag=CF_USESTYLE then
                    if sequence(extra_data[1]) then
                        extra_flag = w32acquire_mem(mset,extra_data)
                    else
                        extra_flag = extra_data
                    end if
                    w32store(hChooseFont,CF_lpszStyle,extra_flag)
                elsif extra_flag=CF_SELECTSCRIPT then
                    charset = extra_data
                elsif extra_flag=CF_ENABLETEMPLATEHANDLE then
                    w32store(hChooseFont,CF_hInstance, extra_data)
                elsif extra_flag=CF_ENABLETEMPLATE then
                    w32store(hChooseFont,CF_hInstance, extra_data[1])
                    if sequence(extra_data[1]) then
                        extra_flag = w32acquire_mem(mset,extra_data[2])
                    else
                        extra_flag = extra_data[2]
                    end if
                    w32store(hChooseFont,CF_lpszStyle,extra_flag)
                elsif extra_flag=CF_INITTOLOGFONTSTRUCT then
                    hLogFont = extra_data
                end if
            end if
        end for
    end if

    if and_bits(flags, CF_WYSIWYG) then
        flags = or_bits(flags,CF_BOTH+CF_SCALABLEONLY)
    end if
    -- populate the choose font structure
    if and_bits(flags,CF_INITTOLOGFONTSTRUCT) and not hLogFont then
        hLogFont = w32acquire_mem(mset, SIZEOF_LOGFONT)
        if not and_bits(flags,CF_NOFACESEL) then
            w32store(hLogFont, lfFaceName, ctrl_Font[id][w32FontName])
        end if
        if not and_bits(flags,CF_NOSTYLESEL) then
            attrib = ctrl_Font[id][w32FontAttrib]          -- added PeteS
            w32store(hLogFont, lfWeight,          ((and_bits(attrib, Bold)    )!=0)*setFontWeight(w32GetValue))        -- added PeteS
            w32store(hLogFont, lfItalic,          (and_bits(attrib, Italic)   )!=0)          -- added PeteS
            w32store(hLogFont, lfUnderline,   (and_bits(attrib, Underline))!=0)          -- added PeteS
            w32store(hLogFont, lfStrikeOut,   (and_bits(attrib, Strikeout))!=0)          -- added PeteS
        end if
        if not and_bits(flags,CF_NOSIZESEL) then
            if sequence(ctrl_Font[id][w32FontSize]) then
                w32store(hLogFont, lfHeight, ctrl_Font[id][w32FontSize][1])
            else
                w32store(hLogFont, lfHeight, convPointsToLogical(id,ctrl_Font[id][w32FontSize],1))
            end if
        end if
        if charset>=0 then
            w32store(hLogFont, lfCharSet, charset)
        end if
    end if

    w32store(hChooseFont, CF_hLogFont, hLogFont)
    w32store(hChooseFont, CF_lStructSize, SIZEOF_CHOOSEFONT)
    w32store(hChooseFont, CF_hwndOwner, getHandle(owner))
    w32store(hChooseFont, CF_Flags, flags)
    w32store(hChooseFont, CF_rgbColors, ctrl_Font[id][w32FontColor])           -- added PeteS
    w32store(hChooseFont, CF_iPointSize, ctrl_Font[id][w32FontSize])            -- added PeteS

    -- call the dialog
    if w32Func(xChooseFont,{hChooseFont}) then

        -- pointer to structure good?
        if w32fetch(hChooseFont, CF_hLogFont) then

            -- got pointer successfully
            font = w32peek_string(w32address(hLogFont, lfFaceName))
            points = floor(w32fetch(hChooseFont, CF_iPointSize)/10)

            -- clear attributes
            attrib = 0

-- NEW! 0.45o check correct flag
            -- bold?
            if w32fetch(hLogFont, lfWeight)>=setFontWeight(w32GetValue) then
                attrib += Bold
            end if

            -- italic?
            if w32fetch(hLogFont, lfItalic) then
                attrib += Italic
            end if

            -- underline?
            if w32fetch(hLogFont, lfUnderline) then
                attrib += Underline
            end if

            -- strikeout?
            if w32fetch(hLogFont, lfStrikeOut) then
                attrib += Strikeout
            end if

            --get font color
            color = w32fetch(hChooseFont, CF_rgbColors)

            -- save result
            result = {font, points, attrib, color}

        end if

    end if

    -- Free the structures
    w32release_mem(mset)

    return result


end function

-----------------------------------------------------------------------------
--/topic Dialogs
--/func getFontDialog( window )
--/desc "Get Font" Dialog
--/ret { font name, points, style flags, color } or -1 if cancelled.
-- Calling this function brings up the modal "Select Font" dialog, allowing
-- the user to select a font from the list of available fonts.
--
-- Example:
--
--/code
--          integer flags, points
--          atom color
--          sequence font
--          object result
--
--          -- get a font choice from the user
--          result = getFontDialog( MyWindow )
--          if sequence( result ) then
--              -- get the values
--              font = result[1]
--              points = result[2]
--              flags  = result[3]
--              color  = result[4]
--          end if
--/endcode
global function getFontDialog(integer window)
    return getFontDialogEx(window,w32GFD_DEFAULT_FLAGS,0)
end function

-- ListView wrappers

--/topic ListView Control
--/func struct_LVCOLUMN(atom mask, atom fmt, atom cx, object text, object Column )
--/desc Allocates RAM for a LVCOLUMN structure and initialises it.
--/ret ATOM: Address of a LVCOLUMN structure.
-- /i text can be a 3-element sequence in the form { headingtext, width, alignment }
-- where /i headingtext is the text for the column heading, /i width is the
-- column width in pixels, and /i alignment is a code for Left, Center, or
-- Right aligned text ('~<', '^', '>' respectively). /n
-- In this form, if /i width or /i alignment is -1, it is ignored and the
-- existing settings for the column are not changed. If /i headingtext is
-- "" it is ignored. This means that to blank out a column's heading you
-- must specify a space character as the heading text value.
--
-- /i Column is either ... /n
--/li an integer column number for the new column /n
--/li a two-element sequence {column#, image#}. This form lets you specify
-- the column number and the image list id for the column's image.
--/li a three-element sequence {column#, image#, order}. This form lets you
-- specify the column number, the image list id for the column's image (zero
-- for no image, and the order value.
--
global function struct_LVCOLUMN(atom mask, atom fmt, atom cx,
                                object text, object Column)
atom lMask, lFmt, lCX
atom lColImage
atom lColOrder

    lMask = 0
    lFmt = 0
    lCX = 0

    lColImage = 0
    lColOrder = 0

    if sequence(Column) then
        if length(Column)=2 then
            lColImage = Column[2]
        elsif length(Column)>=3 then
            lColImage = Column[2]
            lColOrder = Column[3]
        elsif length(Column)=0 then
            Column = {1}
        end if
        Column = Column[1]
    end if

    if sequence(text) then

        if length(text)=3 and sequence(text[1]) then
            if text[2]>=0 then
                lCX = text[2]
            end if

            if text[3]='<' or text[3]=LVCFMT_LEFT then
                lMask = or_bits(lMask, LVCF_FMT)
                lFmt = LVCFMT_LEFT
            elsif text[3]='^' or text[3]=LVCFMT_CENTER  then
                lMask = or_bits(lMask, LVCF_FMT)
                lFmt = LVCFMT_CENTER
            elsif text[3]='>' or text[3]=LVCFMT_RIGHT  then
                lMask = or_bits(lMask, LVCF_FMT)
                lFmt = LVCFMT_RIGHT
            end if

            text = text[1]
        end if

        if length(text)>0 then
            lMask = or_bits(lMask, LVCF_TEXT)
        else
            text = 0
        end if
    end if

    lCX += cx
    if lCX>0 then
        lMask = or_bits(lMask, LVCF_WIDTH)
    end if

    if lColImage>0 then
        lMask = or_bits(lMask, LVCF_IMAGE)
    end if

    if lColOrder>0 then
        lMask = or_bits(lMask, LVCF_ORDER)
    end if

    if fmt!=0 then
        lMask = or_bits(lMask, LVCF_FMT)
    end if

    return w32to_memory(0,ID_LVCOLUMN,{or_bits(mask,lMask), or_bits(fmt,lFmt)
                                    , lCX, text, Column-1,lColImage-1,lColOrder-1})
end function

--/topic ListView Control
--/proc setColumn( integer id, integer column, sequence text )
--/desc Changes the column header text, or width, or alignment.
--See /struct_LVCOLUMN for a description of what format /i text can take.
--
--Example:
--/code
--     -- Set the width of the third column to 230
--     setColumn(myListView, 3, {"",230,-1} )
--/endcode
global procedure setColumn(integer id, integer column, object text)
atom LV_COLUMN

    LV_COLUMN = struct_LVCOLUMN(0, 0, 0, text, 0)

    VOID = sendMessage(id, LVM_SETCOLUMN, column-1 , LV_COLUMN)

    w32release_mem(LV_COLUMN)

end procedure

--/topic ListView Control
--/proc getColumnHeadings( integer id )
--/desc Gets a list of headings for each column in a list view.
--The headings are returned in the same left-to-right order as they are
-- currently displayed. Note that, because the user can sometimes change the
-- order of the columns, the 'column number' may not always be the same
-- as the order that they appear in.
--
-- The returned sequence contains one entry per heading. Each entry contains
-- two-elements: the first is the true column number and the second is
-- the heading text. The true column number can be used to get the
-- values from the column. See example below ...
--
--Example:
--/code
--      -- Output the columns in the right order
--      lheads = getColumnHeadings(myListView)
--      puts(fh, '\n')
--      for i = 1 to length(lheads) do
--          printf(fh, "%-25s", {lheads[i][2]})
--      end for
--      printf(fh, "\n%s\n", {repeat('-', 75)})
--      for i = 1 to getLVCount(myListView) do
--          for j = 1 to length(lheads) do
--              lData = getLVItemText(myListView, i, lheads[j][1])
--              printf(fh, "%-25s", lData)
--          end for
--          puts(fh, '\n')
--      end for
--/endcode
global function getColumnHeadings(integer id)
atom LV_COLUMN
sequence lHeads
integer column
atom textbuf
sequence coldef

    textbuf = w32acquire_mem(0, 4000)
    LV_COLUMN = struct_LVCOLUMN(LVCF_TEXT+LVCF_ORDER+LVCF_SUBITEM, 0, 0, 0, 0)

    w32store(LV_COLUMN,LVCOLUMN_pszText, {{},{textbuf, 4000}})
    lHeads = {}
    column = 1

    VOID = w32True
    while VOID=w32True do
        VOID = sendMessage(id, LVM_GETCOLUMN, column-1 , LV_COLUMN)
        if VOID then
            coldef = {w32fetch(LV_COLUMN, LVCOLUMN_iOrder),
                      w32fetch(LV_COLUMN, LVCOLUMN_iSubItem)+1,
                      w32peek_string(textbuf)
                     }
            lHeads = append(lHeads, coldef)
            column += 1
        end if
    end while
    lHeads = sort(lHeads)
    for i=1 to length(lHeads) do
        lHeads[i] = lHeads[i][2..3]
    end for

    w32release_mem(LV_COLUMN)
    w32release_mem(textbuf)

    return lHeads
end function

--/topic ListView Control
--/proc setColumnHeadings( integer id, sequence text )
--/desc Sets the heading text for the columns in a /ListView Control.
--The /i text parameter is a sequence list of column formatting options,
--one per column. Each column formatting option is either a simple text
--heading, or a 3-element sequence: {heading-text, column-width, alignment-code}.
--The alignment code is a single character (integer) and can be one of '~<',
--'^', or '>' meaning left, center, and right alignment respectively. /n
--When calling this routine, sometimes you might need to leave the current
-- setting for heading text, width or alignment alone. To leave the text
-- alone, use an empty string. To leave the width alone, use -1. To leave
-- the alignment alone, use -1.
--
--Example:
--/code
--       -- Set the heading text for each column.
--       setColumnHeadings(myLV, {"Title","Author","Publisher","When"})
--       -- Change the width of the second column
--       setColumnHeadings(myLV, { {}, {"",200,-1} })
--       -- Another way to change the width of the second column
--       setColumn(myLV, 2, { {"",200,-1} })
--/endcode
global procedure setColumnHeadings(integer id, sequence text)
sequence lHeadings
integer lTab

    if length(text)>0 then
        if not sequence(text[1]) then
            lHeadings = {}
            lTab = find('\t', text)
            while lTab!=0 do
                lHeadings = append(lHeadings, text[1..lTab-1])
                text = text[lTab+1..length(text)]
                lTab = find('\t', text)
            end while
            if length(text)>0 then
                lHeadings = append(lHeadings, text)
            end if
            text = lHeadings
        end if
        for i=1 to length(text) do
            setColumn(id, i, text[i])
        end for
    end if
end procedure

--/topic ListView Control
--/proc insertLVColumn(id,index,mask,fmt,cx,text, ColumnNumber )
--/desc Inserts a new column into a listview control.
-- See the description of the parameters in the documentation for /struct_LVCOLUMN().
--
global procedure insertLVColumn(atom id, integer index,
                atom mask, atom fmt, atom cx, object text, object pColumn)

atom LV_COLUMN
    if index or mask then end if

    LV_COLUMN = struct_LVCOLUMN(LVCF_SUBITEM, fmt, cx, text, pColumn)

    if sequence(pColumn) then
        pColumn = pColumn[1]
    end if
    VOID = sendMessage(id, LVM_INSERTCOLUMN, pColumn-1, LV_COLUMN)

    w32release_mem(LV_COLUMN)

end procedure

--/topic ListView Control
--/proc deleteLVColumn(id,index,mask,fmt,cx,text, ColumnNumber )
--/desc Removes a column from a listview control.
--
--Example:
--/code
--      -- Delete the third column
--      deleteLVColumn( myListView, 3 )
--/endcode
global procedure deleteLVColumn(atom id, integer pColumn)
    VOID = sendMessage(id, LVM_DELETECOLUMN, pColumn-1, 0)
end procedure

--/topic ListView Control
--/func setLVImage( integer id, atom pInfo)
--/desc Possibly sets the new background image of the ListView, and returns previous state.
--/ret (SEQUENCE) {} on failure, a nonempty sequence if previous info could be gathered.
-- pInfo is the address of a structure of type ID_LVBKIMAGE.
-- If not succesful in getting the information about the background image before the call, the function returns {}.
-- If pInfo is 0 or w32GetValue, the function does not set the background image.
-- If succesful, the function returns {bitmap_handle, flags,url,xOffset,yOffset,return_code}. /i return_code is w32True if the background image could be set, else w32False.
-- The other elements are like the parameters for an ID_LVBKIMAGE structure.
-- Note that the ListView control owns the bitmap whose handle, if any, is in
-- /i bitmap_handle.
--
-- To obtain a valid /i pInfo, you have to call /w32to_memory(ID_LVBKIMAGE,{pFlags,hBitmap,url,xOffsetPercent,yOffsetPercent}):
--/li hBitmap is the handle of the background bitmap. /n
--/li pFlags is the sum of one or more of the following:
--/define
--/term LVBKIF_SOURCE_NONE
-- The list-view control has no background image.
--/term LVBKIF_SOURCE_HBITMAP
-- A background bitmap is supplied via /i hBitmap. If the message LVM_SETBKIMAGE succeeds, then the list-view takes ownership of the bitmap.
--/term LVBKIF_SOURCE_URL
-- /i url contains the URL of the background image.
--/term LVBKIF_STYLE_NORMAL
-- The background image is displayed normally.
--/term LVBKIF_STYLE_TILE
-- The background image will be tiled to fill the entire background of the control.
--/term LVBKIF_FLAG_TILEOFFSET
-- Specify the coordinates of the first tile. This flag is valid only if the LVBKIF_STYLE_TILE flag is also specified. If this flag is not specified, the first tile begins at the upper-left corner of the client area.
--/term LVBKIF_TYPE_WATERMARK
-- A watermark background bitmap is supplied /i hBitmap. If the LVM_SETBKIMAGE message succeeds, then the list-view control takes ownership of the bitmap.
--/term LVBKIF_FLAG_ALPHABLEND
-- Only valid when LVBKIF_TYPE_WATERMARK is also specified. This flag indicates the bitmap provided via LVBKIF_TYPE_WATERMARK contains a valid alpha channel.
--/enddefine
--/li url is an url where the background image is to be picked at. It is ignored unless the
-- LVBKIF_SOURCE_URL style flag is set (set it to "" otherwise)./n
--/li xOffset and yOffset are integer percentages which indicate the image placement when the LVBKIF_STYLE_NORMAL flag is present. 0 aligns the image along the left or top edge;
-- 100 aligns the image aong the right or bottom edge; 50 centers the image, and so on.
-- Under Windows XP, if using a manifest file, and if the LVBKIF_FLAG_TILEOFFSET is resent, /i xOffset and /i yOffset then are the offset /i "in poxels" of the first tile.

global function setLVImage(integer id,atom pInfo)
atom result,hbm
integer rc
sequence rtn

    result = w32to_memory(0,ID_LVBKIMAGE, 0)
    OleInitialize()
    rc = sendMessage(id,LVM_GETBKIMAGE,0,result)
    if not rc then
        w32release_mem(result)
        OleUninitialize()
        return {}
    end if
    hbm = 0
    if pInfo!=0 and pInfo!=w32GetValue then
        rc = sendMessage(id,LVM_SETBKIMAGE,0,pInfo)
        hbm = w32fetch(result,LVBKIMAGE_hbm)
        if hbm and hbm!=w32fetch(pInfo,LVBKIMAGE_hbm) then
            trackObject(id,hbm,ForProgram)
        end if
    end if
    rtn = {w32fetch(result,LVBKIMAGE_hbm),
           w32fetch(result,LVBKIMAGE_ulFlags),"",
           w32fetch(result,LVBKIMAGE_xOffsetPercent),
           w32fetch(result,LVBKIMAGE_yOffsetPercent),rc
          }
    if and_bits(rtn[2],LVBKIF_SOURCE_URL) then
        rtn[3] = w32fetch(result,LVBKIMAGE_pszImage)
    end if
    w32release_mem(result)
    OleUninitialize()
    return rtn
end function

integer internal_lvinsert
internal_lvinsert = 1
--/topic ListView Control
--/func insertLVItem(id,mask,row,column,state,stateMask,text,image,lparam)
--/desc Low-Level version of /addLVItem.
--/ret SEQUENCE: {index, itemid}
global function insertLVItem(integer id, atom mask, atom row,
        atom iSubItem, atom state, atom stateMask,
        object text, atom image, object lparam)

atom LV_ITEM, lIdx
integer setMask

    if not validId(id) or ctrl_Type[id]!=ListView then
        return {-1, -1}
    end if

    -- Get next item ID to use
    vNextLVItemID += 1

    -- Check for 'end of list' position
    if row<0 then
        row = 1+sendMessage(id, LVM_GETITEMCOUNT, 0, 0)
    end if

    if ctrl_ImageList[id]!=hILsmall then
        lIdx = image
        image = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[image]})+1
        VOID = w32Func(ImageList_AddIcon,{ctrl_Statusbar[id],ilicon_list[lIdx]})
    end if

    -- don't use Windows lparam, as this is the position independent index
    if not internal_lvinsert then
        setMask = and_bits(mask,LVIF_PARAM)
        mask -= setMask
    else
        setMask = 0
    end if

    LV_ITEM = w32to_memory(0,ID_LVITEM, {mask, row-1, iSubItem-1, state, stateMask,
                                         text, image-1, vNextLVItemID})

    lIdx = sendMessage(id, LVM_INSERTITEM, 0, LV_ITEM)
    lvitem_owner &= id

    if not setMask then
        lparam = 0
    end if
    lvitem_lparam = append(lvitem_lparam,lparam)

    w32release_mem(LV_ITEM)

    return {lIdx+1, vNextLVItemID}
end function

global constant
    ROW_BASE_1 = 1,
    COL_BASE_1 = 2,
    IMG_BASE_1 = 4,
    ROW_BASE_0 = 0,
    COL_BASE_0 = 0,
    IMG_BASE_0 = 0

--/topic ListView Control
--/proc setLVItemEx(id, mask, Row, Column, state, stateMask, text, image, lparam,base)
--/desc Enables you to set a number of the properties of a ListView item in one call,
-- like /setLVItem() does.
--<ul>
--/li /i id is the ListView's Id as returned by /createEx()
--/li /i mask determines which what properties are being changed. This is any combination of
-- the values /b"LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM," and /b LVIF_STATE. For each one of these included,
-- the respective parameter /i "text, image, lparam," and /i state is required.
--/li Row is the row number in the list
--/li Column is the column number the parameters affect.
--/li base is made of flags or'ed together which specify whether the /i row, /i column and /i image are passed as 1-based (Euphoria-like) or 0-based (C-like) indexes. Available flags are:
--<ul>
--/li ROW_BASE_1 to indicate that the first row is numbered 1;
--/li ROW_BASE_0 to indicate that the first row is numbered 0;
--/li COL_BASE_1 to indicate that the first column is numbered 1;
--/li COL_BASE_0 to indicate that the first column is numbered 0;
--/li IMG_BASE_1 to indicate that image indexes start at 1;
--/li IMG_BASE_0 to indicate that image indexes start at 0.
--</ul>
-- Note that the _0 constants are 0.
--</ul>
--
--Example:
--/code
--      setLVItem (myListView, w32or_all({LVIF_TEXT, LVIF_IMAGE}), 2,1,
--                    0, 0, "The Great Gatsby", bookImage, 0)
--/endcode
global procedure setLVItemEx(atom id, atom mask, atom pRow,
        atom pColumn, atom state, atom stateMask,
        object text, atom image, object lparam, integer base)

atom LV_ITEM
integer setMask

    if ctrl_ImageList[id]!=hILsmall then
        if not and_bits(base,IMG_BASE_1) then
            image += 1
        end if
        image = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[image]})+1
        VOID = w32Func(ImageList_AddIcon,{ctrl_Statusbar[id],ilicon_list[image]})
    end if

    setMask = and_bits(mask,LVIF_PARAM)
    mask -= setMask

    if and_bits(base,ROW_BASE_1) then
        pRow -= 1
    end if
    if and_bits(base,COL_BASE_1) then
        pColumn -= 1
    end if
    if and_bits(base,IMG_BASE_1) then
        image -= 1
    end if

    LV_ITEM = w32to_memory(0,ID_LVITEM, {mask, pRow, pColumn, state, stateMask,
                                         text, image, 0})

    VOID = sendMessage(id, LVM_SETITEM, 0, LV_ITEM)
    if setMask then
        w32store(LV_ITEM,LVITEM_mask,LVIF_PARAM)
        VOID = sendMessage(id, LVM_GETITEM, 0, LV_ITEM)
        lvitem_lparam[w32fetch(LV_ITEM,LVITEM_lParam)] = lparam
    end if
    w32release_mem(LV_ITEM)

end procedure

--/topic ListView Control
--/proc setLVItem(id, mask, Row, Column, state, stateMask, text, image, lparam)
--/desc Enables you to set a number of the properties of a ListView item in one call.
--<ul>
--/li /i id is the ListView's Id as returned by /createEx()
--/li /i mask determines which what properties are being changed. This is any combination of
-- the values /b"LVIF_TEXT, LVIF_IMAGE, LVIF_PARAM," and /b LVIF_STATE. For each one of these included,
-- the respective parameter /i "text, image, lparam," and /i state is required.
--/li Row is the row number in the list
--/li Column is the column number the parameters affect.
--</ul>
--
--Example:
--/code
--      setLVItem (myListView, w32or_all({LVIF_TEXT, LVIF_IMAGE}), 2,1,
--                    0, 0, "The Great Gatsby", bookImage, 0)
--/endcode
global procedure setLVItem(atom id, atom mask, atom pRow,
        atom pColumn, atom state, atom stateMask,
        object text, atom image, object lparam)
    setLVItemEx(id,mask,pRow,pColumn,state,stateMask,text,image,lparam,ROW_BASE_1+COL_BASE_1+IMG_BASE_1)
end procedure

--/topic ListView Control
--/proc setLVItemText(integer LV, integer position, integer subitem, object text)
--/desc Sets the text of a List View item or subitem.
global procedure setLVItemText(integer LV, integer pRow, integer pColumn, object text)
atom LV_ITEM

    if not sequence(text) then
        text = sprintf("%g", text)
    end if
    LV_ITEM = w32to_memory(0,ID_LVITEM, {LVIF_TEXT, 0, pColumn-1, 0, 0, text, 0, 0})

    VOID = sendMessage(LV, LVM_SETITEMTEXT, pRow-1, LV_ITEM)

    w32release_mem(LV_ITEM)

end procedure

--/topic Image lists
--/proc setImageList( integer id, atom IL, atom size )
--/desc Sets the image list for a ListView, TreeView, TabControl or ComboBoxEx control.
-- /i id is the id of the control, /i IL is the image list handle and /i size is the
-- size of the images the list contains.
global procedure setImageList(integer id, atom IL, atom size)
atom  message

    IL = getHandle(IL)
    message = 0
    if ctrl_Type[id]=ListView then
        message = LVM_SETIMAGELIST
    elsif ctrl_Type[id]=TreeView then
        message = TVM_SETIMAGELIST
    elsif ctrl_Type[id]=TabControl then
        message = TCM_SETIMAGELIST
    elsif ctrl_Type[id]=ToolBar then
        message = TB_SETIMAGELIST
    elsif ctrl_Type[id]=ComboBoxEx then
        message = CBEM_SETIMAGELIST

    end if

    if message then
        VOID = sendMessage(id, message, size, IL)
        ctrl_ImageList[id] = IL
    end if

end procedure

--/topic Image Lists
--/func addIcon( hIcon )
--/desc Adds icons to win32lib's imagelists
--/ret Index to image
-- This function is used to add images for /ListView, /TreeView,
-- /ComboBoxEx and /FlatToolBar controls.  There are two ways to
-- use /addIcon:
-- /li /b hIcon is an icon handle
--      used for /ListView, /TreeView, /ComboBoxEx
-- /li /b hIcon is a sequence of 3 icon handles
--      used for /FlatToolBar
-- The icons passed for the /FlatToolBar should be the images to be used
-- for the default, hot and disabled images, respectively.
--
-- /b "Note:" If /i hIcon is zero, it is ignored and zero is returned.
--
--/Example
--/code
--  object ret, dd
--  dd = dir("c:\\windows\\*.exe")
--  for i = 1 to length(dd) do
--          ret = addIcon(extractIcon("c:\\windows\\" & dd[i][D_NAME]))
--          ret = addLVItem(lv, ret, {dd[i][D_NAME], "xxx"})
--  end for
--/endcode
global function addIcon(object hIcon)
integer iIcon
sequence list

    if equal(hIcon, 0) then
        return 0
    end if

    if atom(hIcon) then
        list = ilicon_list
    else
        list = FTB_images
    end if

    iIcon = find(hIcon, list)

    if iIcon then
        return iIcon
    end if

    iIcon = length(list)


    if atom(hIcon) then

        if ILlarge=0 then
            ILlarge = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
                                             ILC_COLOR8,0})
            ILsmall = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXSMICON,0,
                                             ILC_COLOR8,0})
            hILsmall = ctrl_Handle[ILsmall]
            hILlarge = ctrl_Handle[ILlarge]
        end if
        ILAddIcon(ILlarge, hIcon)
        ILAddIcon(ILsmall, hIcon)

        list &= hIcon
        ilicon_list = list

    else
        if himlFTBDefault=0 then
            -- Need to create imagelists

            himlFTBDefault = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
                                                    ILC_COLOR8,0})
            himlFTBHot = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
                                                ILC_COLOR8,0})
            himlFTBDisabled = call_func(r_createEx, {ImageList, "", 0, 0,0,SM_CXICON,0,
                                                     ILC_COLOR8,0})

        end if
        ILAddIcon(himlFTBDefault, hIcon[1])
        ILAddIcon(himlFTBHot, hIcon[2])
        ILAddIcon(himlFTBDisabled, hIcon[3])

        list &= {hIcon}
        FTB_images = list

    end if


    return iIcon+1
end function

global constant
    w32TB_BUTTONSIZE = 1,
    w32TB_BITMAPSIZE = 2,
    w32TB_HEIGHT = 3

--/Topic Controls
--/proc setToolBarSize(integer id, object Property, object Values)
--/desc Set one or more size properties of a ToolBar or FlatToolBar.
--This is really only needed for Win95 as later versions do this automatically. /n
--/i id is the Id of the tool bar. /n
--/i Property is a list of properties to affect. These can be any combination of
-- /b "w32TB_BUTTONSIZE, w32TB_BITMAPSIZE," and /b w32TB_HEIGHT. /n
--/i Values is a list of the new value(s) to set. /n
-- There must be the same number of values as properties. /n
--/b Note for the button size and bitmap size, the values must be expressed as
-- a 2-element sequence containing {width, height}. For the height value, this
-- must be a single integer. /n
--
-- There is no way to set the width of a toolbar as it always matches it's window's width.
--
--Example:
--/code
--      setToolBarSize( myToolbar, {w32TB_HEIGHT, w32TB_BUTTONSIZE},
--                                 {    38,        {24, 26} })
--/endcode

global procedure setToolBarSize(integer id, object pProperty, object pValues)
atom lXY
integer lIdx
sequence lParentSize

    if atom(pProperty) then
        pProperty = {pProperty}
    end if
    if atom(pValues) then
        pValues = {pValues}
    end if

    if length(pProperty)!=length(pValues) then
        return
    end if

    lIdx = find(w32TB_BUTTONSIZE, pProperty)
    if lIdx!=0 and sequence(pValues[lIdx]) and length(pValues[lIdx])=2 then

        lXY = w32pack_word(pValues[lIdx][1], pValues[lIdx][2])
        VOID = sendMessage(id, TB_SETBUTTONSIZE, 0, lXY)
    end if

    lIdx = find(w32TB_BITMAPSIZE, pProperty)
    if lIdx!=0 and sequence(pValues[lIdx]) and length(pValues[lIdx])=2 then

        lXY = w32pack_word(pValues[lIdx][1], pValues[lIdx][2])
        VOID = sendMessage(id, TB_SETBITMAPSIZE, 0, lXY)
    end if


    lIdx = find(w32TB_HEIGHT, pProperty)
    if lIdx!=0 and integer(pValues[lIdx]) then
        lParentSize = getCtlSize(ctrl_Parent[id])

        VOID = w32Func(xMoveWindow,
                       {getHandle(id), 0, 0, lParentSize[1], pValues[lIdx], 1})
    end if

end procedure

--/topic ListView Control
--/func setLVInsert(object pFlag )
--/desc Possibly sets the default position for ListView inserts.
--/ret The flag setting before this change.
--If /i pFLag is zero, /addLVItem() adds new items to the top of the list.
-- If pFlag is /w32GetValue, the value of the flag is returned without modifying it.
-- Otherwise, new items are added at the end. The default is to add items to the
-- top of lists.
-- If pFlag is a sequence, it is a pair {id,pFlag}, where the flag has the above meaning and /i id identifies a ListView. The function then possibly stes, then returns the override flag for this listview.
--
--Example:
--/code
--     integer lvInsert
--     -- Make listviews add to end of lists.
--     lvInsert = setLVInsert( 1 )
--/endcode
global function setLVInsert(object pFlag)
atom lOld

    if integer(pFlag) then
        lOld = lvInsertWhere
        if pFlag!=w32GetValue then
            lvInsertWhere = w32iff(pFlag=0, 1, -1)
        end if
    elsif not length(pFlag) or ctrl_Type[pFlag[1]]!=ListView then
        return lvInsertWhere
    else
        lOld = ctrl_Specific[pFlag[1]]
        if length(pFlag)=1 then
            ctrl_Specific[pFlag[1]] = 0
        elsif pFlag[2]=w32False then
            ctrl_Specific[pFlag[1]] = -1
        elsif pFlag[2]!=w32GetValue then
            ctrl_Specific[pFlag[1]] = 1
        end if
    end if
    return lOld
end function

--/topic ListView Control
--/func addLVItem( object id, atom iIcon, sequence text )
--/desc Add an item to a /ListView
--/ret The new item's ID.
-- /i id: This is either the id of /ListView or a two-element sequence that
-- specifies the ListView id and the position in the list to insert the new
-- item. /b 1 is the first position, /b 2 is the second position, etc... and
-- /i -1 is the last position. /n
-- /i iIcon: index of image from /addIcon, /addEuBmp, /addXpm, or /addDIB /n
-- /i text: sequence of strings or numbers to be displayed in listview columns. The
-- number of columns is set by the number of strings in this parameter. /n
--
-- Note: Each item placed into a listview is given a unique ID. The ID is unique
-- for the application, not just the ListView the item is in. Also, the ID is
-- not the same as the position of the item in the ListView.
--
--Example:
--/code
--        sequence idx idx = {}
--        setColumnHeadings(myLV, {"Given Name","Family Name","Playing Position", "Number"})
--        idx &= addLVItem(myLV, iconCaptain, {"Brett","Ratten", "Center", 7})
--        idx &= addLVItem(myLV, iconPlayer, {"Scott","Camporeale", "Wing", 16})
--        idx &= addLVItem(myLV, iconPlayer, {"Jim","Plunkett", "Rover", 44})
--        -- Insert an item at position 2.
--        idx &= addLVItem({myLV,2}, iconPlayer, {"Andrew","McKay", "Back Pocket", 5})
--/endcode
global function addLVItem(object id, atom iIcon, sequence text)

integer lWhere,n_icon
sequence lNewItem

    if sequence(id) then
        lWhere = id[2]
        id = id[1]
    else
        if ctrl_Specific[id] then
            lWhere = ctrl_Specific[id]
        else
            lWhere = lvInsertWhere
        end if
    end if
    if ctrl_Type[id]!=ListView then
        return -1
    end if

    if ctrl_ImageList[id]!=hILsmall then
        n_icon = iIcon
        iIcon = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[iIcon]})+1
        VOID = w32Func(ImageList_AddIcon,{ctrl_Statusbar[id],ilicon_list[n_icon]})
    end if

    -- Sanity check
--  if not sequence(text) then
--      text = sprintf("%g", text)
--  end if
    if length(text)=0 or not sequence(text[1]) then
        text = {text}
    end if

    internal_lvinsert = 1
    lNewItem = insertLVItem(id, lvitem_MASK, lWhere, 1,0,0,
                            text[1], iIcon, 0)
    internal_lvinsert = 0

    for i=2 to length(text) do
        setLVItemText(id, lNewItem[1], i, text[i])
    end for

    return lNewItem[2]
end function

--/topic ListView Control
--/func getLVItem( integer id, atom LV_ITEM)
--/ret ATOM: 0 if routine was successful.
--/desc Gets various attributes of a listview item.
-- /i LV_ITEM is the address of a LVITEM structure that you have to correctly
-- fill out before you call this routine.
-- Note that, on return, the lParam member of the structure will not hold the item information 
-- you supplied, but its unique id instead. To access the item information, use
-- /getLVItemlParam() instead.
--
--Example:
--/code
--     atom lOK
--     atom lvitem
--     lvitem = w32acquire_mem(0, SIZEOF_LVITEM)
--     w32store(lvitem, LVITEM_iItem, 1)
--     w32store(lvitem, LVITEM_mask, LVIF_TEXT)
--     lOK = getLVItem(myLV, lvitem)
--     . . .
--     w32release_mem(lvitem)
--/endcode
global function getLVItem(integer id, atom LV_ITEM)
    return sendMessage(id, LVM_GETITEM, 0, LV_ITEM)
end function

--/topic ListView Control
--/func getLVItemText( integer id, integer item, object column)
--/desc Gets the text associated with a listview item.
--/ret Sequence: The text for an item.
--/i id is the ListView control, /n
--/i row is the list view row in question, /n
--/i column is either the number of the column whose text you want,
-- or -1 if you want the text from all columns, in which case a sequence of
-- strings is returned, or a sequence of column numbers.
--
--Example:
--/code
--       sequence theText
--       -- Get the text from column 1 in row 2.
--       theText = getLVItemText(myLV, 2, 1)
--       -- Get the text from columns 3 and 2 in row 1.
--       theText = getLVItemText(myLV, 1, {3,2} )
--/endcode
global function getLVItemText(integer id, integer row, object column)
sequence text
atom lvitem, taddr, lrc
object taddr_real
integer lidx
atom lMemSet

    if not validId(id) or row<1 then
        return sprintf("Invalid getLVItemText call: ID=%d, ROW=%d", {id, row})
    end if

    if atom(column) then
        if column>=1 then
            column = {column}
        else
            column = -1
        end if
--  elsif sequence(column) and length(column) = 0 then
    elsif length(column)=0 then
        column = -1
    end if

    text = {}
    lidx = 1

    lMemSet = w32new_memset()
    lvitem = w32acquire_mem(lMemSet, SIZEOF_LVITEM)
    taddr = w32acquire_mem(lMemSet, 4000)

    w32store(lvitem, LVITEM_iItem, row-1)
    w32store(lvitem, LVITEM_mask, LVIF_TEXT)
    w32store(lvitem, LVITEM_pszText, {{},{taddr, 3999}})

    while w32True do
        if atom(column) then
            w32store(lvitem, LVITEM_iSubItem, column+lidx)
        else
            w32store(lvitem, LVITEM_iSubItem, column[lidx]-1)
        end if

        lrc = sendMessage(id, LVM_GETITEM, 0, lvitem)
        if w32buffer_address(lvitem,LVITEM_pszText)=#FFFFFFFF then
            lrc = 0
        end if
        if lrc then
            taddr_real = w32fetch(lvitem, LVITEM_pszText)
            if sequence(taddr_real) then
                text = append(text,taddr_real)
            else
                lrc = 0
            end if
        elsif atom(column) and column>0 then
            text = append(text, "")
        end if

        lidx += 1

        if atom(column) then
            if lrc=0 then
                exit
            end if
        else
            if lidx>length(column) then
                exit
            end if
        end if
    end while


    if sequence(column) and length(column)=1 and length(text)>0 then
        text = text[1]
    end if

    w32release_mem(lMemSet)
    return text
end function

--/topic ListView Control
--/func getLVAllText( integer id, integer row )
--/desc Gets the text associated with every column in a listview row.
--/ret Sequence: A sequence of text strings.
--/i id is the ListView control, /n
--/i row is the list view row in question, /n
--
--Example:
--/code
--       sequence theText
--       -- Get the text from row 1.
--       theText = getLVAllText(myLV, 1 )
--/endcode
global function getLVAllText(integer id, integer pRow)
    return getLVItemText(id, pRow, -1)
end function

--/topic ListView Control
--/func getLVCount( integer id )
--/desc Gets the number of rows in a list view.
--/ret INTEGER: The count of rows.
--
--Example:
--/code
--      integer cnt
--      cnt = getLVCount(myLV)
--/endcode
global function getLVCount(integer id)
    return sendMessage(id, LVM_GETITEMCOUNT, 0, 0)
end function


--/topic ListView Control
--/func getLVChecked( integer id, integer index )
--/desc Gets whether or not an row has its checkbox ticked.
--/ret INTEGER: w32False if not checked, otherwise w32True.
--
--Example:
--/code
--      integer cnt
--      -- See if row #2 is checked.
--      cnt = getLVChecked(myLV, 2)
--/endcode

global function getLVChecked(integer id, integer row)
atom lFlags
    lFlags = sendMessage(id, LVM_GETITEMSTATE, row-1, LVIS_STATEIMAGEMASK)
    lFlags = and_bits(lFlags , LV_IS_CHECKED)
    return (lFlags!=0)
end function

--/topic ListView Control
--/func getLVAllChecked( integer id)
--/desc Returns a list of the indexes of     those rows that are Checked.
--/ret SEQUENCE: A list of rows.
--
--Example:
--/code
--      sequence items
--      items = getLVAllChecked(myLV)
--/endcode
global function getLVAllChecked(integer id)
integer totalCount
sequence lItems
atom lFlags
atom hWnd

    totalCount = getLVCount(id)
    lItems = {}
    hWnd = getHandle(id)
    for i=0 to totalCount-1 do
        lFlags = w32Func(xSendMessage,{hWnd, LVM_GETITEMSTATE, i, LVIS_STATEIMAGEMASK})
        lFlags = and_bits(lFlags, LV_IS_CHECKED)
        if lFlags!=0 then
            lItems &= i+1
        end if
    end for

    return lItems
end function

--/topic ListView Control
--/proc setLVChecked( integer id, integer Row, atom checked )
--/desc Sets the checked state for a /ListView Item
-- /i id is the win32lib id for the list view. /n
-- /i Row is the listview item to check/uncheck. /n
-- /i checked is the checked/unchecked state (~<>0=checked,0=unchecked). /n
global procedure setLVChecked(integer id, integer pRow, atom checked)
atom LV_ITEM, state, mask

    mask = LVIF_STATE
    if checked then
        state = (2*power(2, 12))
    else
        state = (1*power(2, 12))
    end if

    LV_ITEM = w32to_memory(0,ID_LVITEM, {LVIF_STATE, pRow-1, 0, state, LVIS_STATEIMAGEMASK})

    VOID = sendMessage(id, LVM_SETITEM, pRow-1, LV_ITEM)

    w32release_mem(LV_ITEM)
end procedure

--/topic Graphics
--/func extractIcon( sequence Filename )
--/desc Gets the an icon from the file (DLL, EXE or ICO) specified.
--/ret ATOM: Handle to the icon or NULL if none found.
--/i Filename is either ... /n
-- ** the name of a file /n
-- ** a 2-element sequence containing a filename and a 1-based index of which icon to extract.
-- ** a 3-element sequence containing a filename, a 1-based index of which icon to extract,
-- and a code indicating which size icon to return: 0 --> small, 1 --> large,  2 --> both. When
-- you ask to return both, a 2-element sequence is returned that contains {small, large}.
--
--Example:
--/code
--      atom hIcon
--      sequence lIcons
--      -- Get the first icon
--      hIcon = extractIcon( "C:\\WINDOWS\\WINFILE.EXE")
--      -- Get the second icon
--      hIcon = extractIcon( {"C:\\WINDOWS\\WINFILE.EXE", 2} )
--      -- Get the fourth icon, large size
--      hIcon = extractIcon( {"C:\\WINDOWS\\WINFILE.EXE", 4, 1} )
--      -- Get the fifth icon, both sizes
--      lIcons = extractIcon( {"C:\\WINDOWS\\SYSTEM32\SHELL32.DLL", 5, 2} )
--      lBig = lIcons[2]
--      lSmall = lIcons[1]
--/endcode
global function extractIcon(sequence Filename)
object icon
integer lIdx
atom lBufferL
atom lBufferS
integer lType

    lIdx = 0
    lType = 0
    if length(Filename)>0 then
        if sequence(Filename[1]) then
            if length(Filename)>=3 then
                lType = Filename[3]
            else
                lType = 0
            end if
            lIdx = Filename[2]-1
            Filename = Filename[1]
        end if
    else
        lType = 1
    end if
    lBufferL = w32acquire_mem(0, 8)
    lBufferS = lBufferL+4
    Filename = w32FindFile(Filename)
    VOID = w32Func(xExtractIconEx, {Filename, lIdx, lBufferL, lBufferS, 1})

    if lType=0 then
        icon = peek4u(lBufferS)
    elsif lType=1 then
        icon = peek4u(lBufferL)
    else
        icon = peek4u({lBufferL,2})
    end if

    w32release_mem(lBufferL)
    return icon
end function

--/topic ListView Control
--/func getLVSelectedCount( integer id )
--/desc Gets the number of selected items in a list view.
--/ret INTEGER: The count of selected items.
--
--Example:
--/code
--      integer cnt
--      cnt = getLVSelectedCount(myLV)
--/endcode
global function getLVSelectedCount(integer id)
    return sendMessage(id, LVM_GETSELECTEDCOUNT, 0, 0)
end function

--/topic ListView Control
--/func getLVItemlParam( integer id, integer iItem )
--/ret ATOM: The user-defined data associated with this /i iItem.
--/desc Gets the user-defined data for this specific row in the list.
--This data is set by /setLVItemlParam and can be any Euphoria object.
--
--Example
--/code
--       atom lVal
--       -- Get the data for the second row in the list.
--       lVal = getLVItemlParam(myLV, 2)
--/endcode
global function getLVItemlParam(integer id, integer pRow)
atom LV_ITEM, lParam

    LV_ITEM = w32to_memory(0,ID_LVITEM, {LVIF_PARAM, pRow-1})
    VOID = sendMessage(id,  LVM_GETITEM, 0, LV_ITEM)
    lParam = w32fetch(LV_ITEM, LVITEM_lParam)

    w32release_mem(LV_ITEM)
    return lvitem_lparam[lParam]
end function

--/topic ListView Control
--/func getLVSelected( object id )
--/desc get a list of the selected items' indexes
--/ret SEQUENCE: A list of item indexes.
-- This can return either a simple list of item index values or
-- a list of 2-element sequences where the first element is
-- the index of the selected item and the second elements is
-- the id of the selected item.
--
-- Remember that each item in a list view has a unique item id.
-- The index is the item's current position within the listview.
--
-- To return just a list of item indexes, /i id is the ListView control id. /n
-- To return a list of {index, item id} sequences, then /i id must be
-- a sequence in the form {LVid, style}. /i LVid is the listview's
-- control id and /i style is either /b 1 for the sequence list
-- return value style, or /b 0 for the simple list return value style.
--
--Example:
--/code
--          sequence indexes
--          -- Get a list of selected items' id.
--          idxs = getLVSelected( myListView)
--
--          -- Get a list of selected items AND their indexes.
--          idxs = getLVSelected( {myListView, 1} )
--/endcode
global function getLVSelected(object id)
integer count, start
sequence selections
atom LVITEM, LVITEM2, mset, lParam
integer lReturnStyle

    selections = {}
    lReturnStyle = 0

    if sequence(id) then
        if length(id)=2 then
            lReturnStyle = w32iff(id[2]=0, 0, 1)
            id = id[1]
        else
            return {}
        end if
    end if

    count = getLVSelectedCount(id)
    if not count then
        return selections
    end if

    mset = w32new_memset()
    LVITEM  = w32acquire_mem(mset, SIZEOF_LVITEM)
    w32store(LVITEM, LVITEM_mask, LVIF_STATE)
    w32store(LVITEM, LVITEM_stateMask, LVIS_SELECTED)

    LVITEM2 = w32acquire_mem(mset, SIZEOF_LVITEM)
    w32store(LVITEM2, LVITEM_mask, LVIF_PARAM)

    start = 0
    while count do
        w32store(LVITEM, LVITEM_iItem, start)
        if sendMessage(id, LVM_GETITEM, 0, LVITEM) then
            if w32fetch(LVITEM, LVITEM_state) then
                if lReturnStyle=1 then
                    w32store(LVITEM2, LVITEM_iItem, start)
                    VOID = sendMessage(id,  LVM_GETITEM, 0, LVITEM2)
                    lParam = w32fetch(LVITEM2, LVITEM_lParam)
                    selections &= {{start+1, lParam}}
                else
                    selections &= start+1
                end if
                count -= 1
            end if
        end if
        start += 1
    end while

    w32release_mem(mset)
    return selections
end function

procedure setTVParent(integer iItem, integer cChildren)
atom TV_ITEM

    tvitem_data[iItem][ktv_HasChildren] = cChildren

    if tvitem_owner[iItem]!= -1 then
        TV_ITEM = w32to_memory(0,ID_TVITEM, {TVIF_CHILDREN, tvitem_handle[iItem],
                                             0,0,0,0,0, cChildren,0})

        VOID = sendMessage(tvitem_owner[iItem], TVM_SETITEM, 0, TV_ITEM)

        w32release_mem(TV_ITEM)
    end if

end procedure

--/topic ListView Control
--/func getLVSelectedText( integer id )
--/desc Gets the column-1 text for each selected item in the listview.
--/ret SEQUENCE: Each element returned is a text sequence.
-- Note that an empty sequence returned means that there is no selected
-- items.
--
--Example:
--/code
--      sequence strings
--      strings = getLVSelectedText(myListView)
--      for i = 1 to length(strings) do
--          puts(1, strings[i] & '\n')
--      end for
--/endcode
global function getLVSelectedText(object id)
sequence text
sequence lRowList

    if sequence(id) then
        if sequence(id[2]) then
            lRowList = id[2]
        else
            lRowList = {id[2]}
        end if
        id = id[1]
    else
        lRowList = {1}
    end if

    text = getLVSelected(id)


    for i=1 to length(text) do
        text[i] = getLVItemText(id, text[i], lRowList)
    end for

    return text

end function

procedure removeTVItem(integer iItem)
integer iParent
-- Free up memory taken for the item
    if tvitem_data[iItem][ktv_TextAddr] then
        w32release_mem(tvitem_data[iItem][ktv_TextAddr])
    end if

    tvitem_data[iItem] = ktv_Blank

    iParent = tvitem_parent[iItem]
    tvitem_parent[iItem] = 0
    if not find(iParent, tvitem_parent) then
        tvitem_data[iParent][ktv_HasChildren] = 0
        -- Need to reset cChildren flag
        setTVParent(iParent, 0)
    end if

    VOID = sendMessage(tvitem_owner[iItem],TVM_DELETEITEM,0,tvitem_handle[iItem])
    tvitem_owner[iItem] = -1 -- Remove link to owner
    -- Remove this from the internal table if it is the end one.
    if iItem=length(tvitem_data) then
        tvitem_data   = tvitem_data[1..length(tvitem_data)-1]
        tvitem_owner  = tvitem_owner[1..length(tvitem_owner)-1]
        tvitem_parent = tvitem_parent[1..length(tvitem_parent)-1]
        tvitem_handle = tvitem_handle[1..length(tvitem_handle)-1]
    end if
end procedure

--/topic Attributes
--/func idToIndex(object id)
--/desc Given an item id, returns its index in the parent control.
--/ret (INTEGER) The 1-based position of the item.
-- /i id is either a menu (item) id, a TabItem id, or a pair {parent id,item id}, where the
-- parent id is the one of a ListView or TreeView control.
global function idToIndex(object id)
atom pStruct,hch
integer idx

    if atom(id) then
        if find(ctrl_Family[id],{MENUITEM,MENU}) then
            return find(id,ctrl_Group[ctrl_Parent[id]])
        elsif ctrl_Type[id]=TabItem then
            return find(id,ctrl_Specific[ctrl_Parent[id]])
        else
            return 0
        end if
    else
        if ctrl_Type[id[1]]=ListView then
            if lvitem_owner[id[2]]!=id[1] then
                return 0
            else
                pStruct = w32acquire_mem(0,20)
                poke4(pStruct,LVFI_PARAM)
                poke4(pStruct+8,id[2])
                id = sendMessage(id[1],LVM_FINDITEM,-1,pStruct)
                w32release_mem(pStruct)
                return id
            end if
        elsif ctrl_Type[id[1]]=TreeView then
            if id[2]=0 or lvitem_owner[id[2]]!=id[1] then
                return 0
            else
                pStruct = tvitem_handle[id[2]]
                hch = sendMessage(id[1],TVM_GETNEXTITEM,TVGN_CHILD,tvitem_handle[tvitem_parent[id[2]]])
                idx = 1
                while hch!=pStruct do
                    hch = sendMessage(id[1],TVM_GETNEXTITEM,TVGN_NEXT,hch)
                    idx += 1
                end while
                return idx
            end if
        else
            return 0
        end if
    end if
end function

--/topic Attributes
--/func indexToId(integer parent,object idx)
--/desc Given a parent control id and an index, returns an id for the item with that index.
--/ret (INTEGER) The item id for the requested item.
-- The parent may be either a Menu, TabControl, ListView or TreeView. Otherwise, an 
-- invalid id of -1 is returned.
-- If the parent is a TreeView, the index must have the form {parent node,index}, where
-- parent node is the TreeView item id of the parent node of the sought after item.
global function indexToId(integer parent,object idx)
atom pStruct,hch

    if ctrl_Family[parent]=MENU then
        return ctrl_Group[parent][idx]
    elsif ctrl_Type[parent]=TabControl then
        return ctrl_Specific[parent][idx]
    elsif ctrl_Type[parent]=ListView then
        pStruct = w32acquire_mem(0,SIZEOF_LVITEM)
        w32store(pStruct,LVITEM_mask,LVIF_PARAM)
        w32store(pStruct,LVITEM_iItem,idx-1)
        parent = sendMessage(parent,LVM_GETITEM,0,pStruct)
        parent = w32fetch(pStruct,LVITEM_lParam)
        w32release_mem(pStruct)
        return parent
    elsif ctrl_Type[parent]=TreeView then
        if atom(idx) or tvitem_owner[idx[1]]!=parent then
            return -1
        end if
        hch = sendMessage(parent,TVM_GETNEXTITEM,TVGN_CHILD,tvitem_handle[idx[1]])
        for i=2 to idx[2] do
            hch = sendMessage(parent,TVM_GETNEXTITEM,TVGN_NEXT,hch)
        end for
        return find(hch,tvitem_handle)
    else
        return -1
    end if
end function

--/topic ListView Control
--/proc setLVItemlParam( integer id, integer pRow, atom lParam )
--/desc Sets the user-defined data for this specific row in the list.
--This data is got by /getLVItemlParam and can be any Euphoria object.
--
--Example
--/code
--       -- Set the data for the second row in the list.
--       setLVItemlParam(myLV, 2, 17)
--/endcode
global procedure setLVItemlParam(integer id, integer pRow, object lParam)
    lvitem_lparam[indexToId(id,pRow)] = lParam
end procedure

--/topic List Control
--/const w32AllItems
--/desc This signifies that all items are to be deleted.
--
--/code
--      atom rc
--      rc = deleteItem(myCombo, w32AllItems)
--/endcode
global constant w32AllItems = -1

-----------------------------------------------------------------------------
--/topic List Control
--/func deleteItem( list, position )
--/desc Delete item from /i list's list at position /i.
--/ret ATOM: 0 indicates failure.
-- The /i position starts at 1.
--
-- Example:
--/code
--          -- delete item 2 from the list
--          /deleteItem( TheList, 2 )
--/endcode
--
-- /deleteItem() also works with list view and tree view controls.
-- /i position should be the item id returned when the item was
-- created.  To delete all items in a list view or tree view,
-- /i position should be -1.

global function deleteItem(atom id, integer pos)

-- deletes an item at position

integer msg
atom lRC
sequence lExtra
integer lEventType

atom lParam, iItem

    lParam = 0
    lExtra = {w32CHG_Del}

    -- get the message, based on control type
    if      ctrl_Family[id]=LISTBOX then
        lEventType = w32HDataChange
        if pos=w32AllItems then
            msg = LB_RESETCONTENT
            pos = 1
            lExtra &= 0
        else
            msg = LB_DELETESTRING
            lExtra &= pos
        end if

    elsif   ctrl_Family[id]=COMBO
       or ctrl_Type[id]=ComboBoxEx   then
        lEventType = w32HDataChange
        if pos=w32AllItems then
            msg = CB_RESETCONTENT
            pos = 1
            lExtra &= 0
        else
            msg = CB_DELETESTRING
            lExtra &= pos
        end if

    elsif ctrl_Type[id]=ListView then
        lEventType = w32HChange
        if pos=w32AllItems then
            msg = LVM_DELETEALLITEMS
            pos = 1
            for i=1 to length(lvitem_owner) do
                if lvitem_owner[i]=id then
                    lvitem_owner[i] = -1
                end if
            end for
        else
            msg = LVM_DELETEITEM
            lExtra &= pos
            lvitem_owner[indexToId(id,pos)] = -1
        end if

    elsif ctrl_Type[id]=TreeView then
        lEventType = w32HChange
        msg = TVM_DELETEITEM
        if pos=w32AllItems then
            lParam = TVI_ROOT
            pos = 1
            -- changed to only delete items in the treeview specified
            iItem = 1
            lExtra &= 0
            while iItem<=length(tvitem_owner) do
                if tvitem_owner[iItem]=id then
                    removeTVItem(iItem)
                    if iItem<=length(tvitem_owner) then
                        iItem += 1
                    end if
                else
                    iItem += 1
                end if

            end while
        else
            -- take care of any children
            iItem = find(pos, tvitem_parent)
            while iItem do
                VOID = deleteItem(id, iItem)
                iItem = find(pos, tvitem_parent)
            end while

            lParam = tvitem_handle[pos]
            removeTVItem(pos)
            lExtra &= pos
        end if
        pos = 1


    end if


    lRC =  sendMessage(id, msg, pos-1, lParam)

    VOID = invokeHandler(id, lEventType, lExtra)

    return lRC
end function



-- TreeView wrappers

--BEG CJT01: Additions made by Sascha Zindel and posted by C.K. Lester
-----------------------------------------------------------------------------
--/topic TreeView Control
--/func deleteTVChildren( TheTreeView, position )
--/desc Deletes all children at "position" in the /i tree view.
--
-- Example:
--/code
--          atom position
--          position = getTVIndex(TheTreeView)
--          /deleteTVChildren( TheTreeView, position )
--/endcode

global procedure deleteTVChildren(integer id, integer pos)

atom iItem

     -- Is a treeview?
    if ctrl_Type[id]=TreeView then
         -- take care of any children
        iItem = find(pos, tvitem_parent)
        while iItem do
            VOID = deleteItem(id, iItem)
            iItem = find(pos, tvitem_parent)
        end while
    end if

end procedure

-----------------------------------------------------------------------------
--/topic TreeView Control
--/func getTVChildren( TheTreeView, position )
--/desc Returns all child items for the passed item in the /i tree view.
--
-- Example:
--/code
--          atom position
--          sequence children
--
--          position = getTVIndex(TheTreeView)
--          children = /getTVChildren( TheTreeView, position )
--/endcode

global function getTVChildren(integer id, integer pos)

sequence children

    children = {}

     -- Is a treeview?
    if ctrl_Type[id]=TreeView then
         -- take care of any children
        for i=1 to length(tvitem_parent) do
            if tvitem_owner[i]=id and tvitem_parent[i]=pos then
                children &= i
                children &= getTVChildren(id, i)
            end if
        end for
    end if
    return children
end function
--END CJT01

--/topic TreeView Control
--/func getTVParent( id )
--/desc Get the parent id of a /TreeView item.
--/ret id of parent item, or 0 if item is at root, or -1 if /i id is invalid.
-- Note well. /i id is a TreeView ITEM and not the TreeView control.
global function getTVParent(integer id)
    if id>0 and id<=length(tvitem_data) then
        return tvitem_parent[id]
    else
        return -1
    end if
end function

--/topic TreeView Control
--/func addTVItem( integer id, atom iImage, atom iSelectedImage, sequence text, integer iParent )
--/desc Add an item to a /TreeView
--/ret Index to item.
-- /li /b id: /TreeView to add to
-- /li /b iImage: Index to default image
-- /li /b iSelectedImage: Index to image for when item is selected
-- /li /b text: String of text to be displayed for item
-- /li /b iParent: index of parent item.  Should be 0 if item is at root.
-- See /addIcon, /addEuBmp, /addXpm, /addDIB for information on
-- using images with /TreeViews.

global function addTVItem(integer id, atom iImage, atom iSelectedImage,
        sequence text, integer iParent)

atom TV_ITEM, TV_INSERTSTRUCT, hNewItem, lParam, hParent
atom mset

    -- need to get hParent, since we only have our own id number to
    -- go by.  We can search based on lParam.
    mset = w32new_memset()

    lParam = find(-1, tvitem_owner)
    if not lParam then
        tvitem_data &= {ktv_Blank}
        tvitem_owner &= id
        tvitem_parent &= iParent
        tvitem_handle &= 0
        lParam = length(tvitem_data)
    else
        tvitem_data[lParam] = ktv_Blank
        tvitem_owner[lParam] = id
        tvitem_parent[lParam] = iParent
    end if

    if ctrl_ImageList[id]!=hILsmall then
        iImage = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[iImage]})+1
        iSelectedImage = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[iSelectedImage]})+1
    end if

    if iParent>0 then
        hParent = tvitem_handle[iParent]
    else
        hParent = 0
    end if

    TV_ITEM = w32to_memory(0,ID_TVITEM, {tvitem_MASK, 0, 0, 0, {{},{LPSTR_TEXTCALLBACK,0}},
                                         iImage-1, iSelectedImage-1, 0, lParam})
    w32manage_mem(mset, TV_ITEM)
    -- ??? why using a callback when no user-defined routine is supplied?

    TV_INSERTSTRUCT = w32to_memory(0,ID_TVINSERTSTRUCT, {hParent, TVI_LAST,TV_ITEM})
    w32manage_mem(mset, TV_INSERTSTRUCT)

    hNewItem = sendMessage(id, TVM_INSERTITEM, 0, TV_INSERTSTRUCT)

    tvitem_handle[lParam] = hNewItem
    tvitem_data[lParam][ktv_NormImage] = iImage
    tvitem_data[lParam][ktv_SelectImage] = iSelectedImage
    tvitem_data[lParam][ktv_TextAddr] = w32acquire_mem(0,text)
    tvitem_data[lParam][ktv_TextSize] = length(text)
    tvitem_data[lParam][ktv_HasChildren] = w32False

    if (iParent>0 ) and not tvitem_data[iParent][ktv_HasChildren] then
        setTVParent(iParent, 1)
    end if

    -- give back the memory to the system.
    w32release_mem(mset)

    return lParam

end function

function tv_release(atom pStruct,integer item)
    w32release_mem(pStruct)
    return item
end function

--/topic TreeView Control
--/func getTVIndex( atom id )
--/desc Find which is the selected item in a treeview.
--/ret 0 if none selected, otherwise the Treeview item id that is selected.
--
--/code
--        integer theItem
--        theItem = getTVIndex(theTreeview)
--        if theItem != 0 then
--           -- found a selected item
--        end if
--/endcode
global function getTVIndex(integer id)
atom state, hItem, hChild, TV_ITEM
sequence path

    hItem = sendMessage(id, TVM_GETNEXTITEM, 0, TVGN_ROOT)
    TV_ITEM = w32to_memory(0,ID_TVITEM, {TVIF_STATE+TVIF_PARAM, hItem})
    path = {}

    while 1 do
        VOID = sendMessage(id, TVM_GETITEM, 0, TV_ITEM)
        state = w32fetch(TV_ITEM, TVITEM_state)

        if and_bits(state,TVIS_SELECTED) then
            -- assuming only one item is selected at a time
            return tv_release(TV_ITEM,w32fetch(TV_ITEM,TVITEM_lParam))
        end if

        hChild = sendMessage(id, TVM_GETNEXTITEM, TVGN_CHILD, hItem)
        if hChild then
            path &= hItem
            hItem = hChild
        else
            hItem = sendMessage(id, TVM_GETNEXTITEM, TVGN_NEXT, hItem)
            while not hItem do
                if not length(path) then
                    return tv_release(TV_ITEM,0)
                end if
                hItem = path[length(path)]
                path = path[1..length(path)-1]
                hItem = sendMessage(id, TVM_GETNEXTITEM, TVGN_NEXT, hItem)
            end while
        end if

        w32store(TV_ITEM, TVITEM_hItem, hItem)
    end while

end function

--/topic TreeView Control
--/func getTVText( integer iItem )
--/desc Gets the text associated with a TreeView item with id /i iItem.
--/ret SEQUENCE: The item's text.
--
--/code
--       sequence text
--       atom anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--       text = getTVText( anItem )
--/endcode
global function getTVText(integer item)

    if item>0 and item<=length(tvitem_handle) then
        return w32peek_string(tvitem_data[item][ktv_TextAddr])
    else
        return ""
    end if

end function

--/topic TreeView Control
--/func getTVSelectedText( integer id )
--/desc Gets the text associated with the selected item in a TreeView.
--/ret SEQUENCE: The selected item's text.
--
--/code
--       sequence text
--       text = getTVSelectedText( theTreeView )
--/endcode
global function getTVSelectedText(integer id)
    return getTVText(getTVIndex(id))
end function

--/topic TreeView Control
--/proc setTVText( integer iItem, sequence NewText )
--/desc Sets the text associated with a TreeView item.
--
--/code
--       integer anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--        setTVText( anItem, "G'Day" )
--/endcode
global procedure setTVText(integer iItem, sequence pNewText)

    if iItem>0 and iItem<=length(tvitem_data) then
        w32release_mem(tvitem_data[iItem][ktv_TextAddr])
        tvitem_data[iItem][ktv_TextAddr] = w32acquire_mem(0, pNewText)
        tvitem_data[iItem][ktv_TextSize] = length(pNewText)
    end if

end procedure


--/topic TreeView Control
--/proc setTVImages( integer iItem, atom NewImage, atom NewSelected )
--/desc Sets the images associated with a TreeView item.
-- /i NewImage is the image used for an unselected item, and /i NewSelected
-- is the image used when the item is selected. /n
-- If either /i NewImage or /i NewSelected is -1, the respective image
-- is not changed.
--
--/code
--       integer anItem
--       anItem = addTVItem(theTreeView, img1, img2, "Hello", 0)
--       . . .
--        setTVImages( anItem, img3, -1 )
--/endcode
global procedure setTVImages(integer pItem, atom pNewImage, atom pSelected)
atom lTVITEM
atom lMask

    if pItem<=0 or pItem>length(tvitem_data) then
        return
    end if

    lTVITEM = w32acquire_mem(0, SIZEOF_TVITEM)
    lMask = TVIF_HANDLE
    if pNewImage>0 then
        lMask = TVIF_IMAGE
        if ctrl_ImageList[tvitem_owner[pItem]]!=hILsmall then
            pNewImage = w32Func(ImageList_AddIcon,{ctrl_ImageList[tvitem_owner[pItem]],ilicon_list[pNewImage]})
        else
            pNewImage -= 1
        end if
        w32store(lTVITEM, TVITEM_iImage, pNewImage)
    end if
    if pSelected>0 then
        lMask = or_bits(lMask, TVIF_SELECTEDIMAGE)
        if ctrl_ImageList[tvitem_owner[pItem]]!=hILsmall then
            pSelected = w32Func(ImageList_AddIcon,{ctrl_ImageList[tvitem_owner[pItem]],ilicon_list[pSelected]})
        else
            pSelected -= 1
        end if
        w32store(lTVITEM, TVITEM_iSelectedImage, pSelected)
    end if

    if lMask=TVIF_HANDLE then
        return
    end if

    w32store(lTVITEM, TVITEM_mask, lMask)
    w32store(lTVITEM, TVITEM_hItem, tvitem_handle[pItem])

    VOID = sendMessage(tvitem_owner[pItem], TVM_SETITEM, 0, lTVITEM)

    w32release_mem(lTVITEM)
end procedure

--/topic TreeView Control
--/proc expandItem( id )
--/desc Show the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created.
global procedure expandItem(integer item)
    if item>0 and item<=length(tvitem_data) then
        VOID = sendMessage(tvitem_owner[item],
                           TVM_EXPAND, TVE_EXPAND, tvitem_handle[item])
    end if
end procedure

--/topic TreeView Control
--/proc collapseItem( id )
--/desc Hides the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created.
global procedure collapseItem(integer item)
    if item>0 and item<=length(tvitem_data) then
        VOID = sendMessage(tvitem_owner[item],
                           TVM_EXPAND, TVE_COLLAPSE, tvitem_handle[item])
    end if
end procedure

--/topic TreeView Control
--/proc toggleItem( id )
--/desc Shows or Hides the children of a single /TreeView Item
-- /i id is the integer returned from /addTVItem when the item was created. /n
-- If the item has its children hidden, this shows them. /n
-- If the item has its children shown, this hides them. /n
global procedure toggleItem(integer item)
    if item>0 and item<=length(tvitem_data) then
        VOID = sendMessage(tvitem_owner[item],
                           TVM_EXPAND, TVE_TOGGLE, tvitem_handle[item])
    end if
end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc defineUserProperty( object pControl, object pPropId, object pData)
--/desc Defines a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i pPropId specifies a unique 'name' or number for the property. /n
--/i pData is the data used to initialize the property. This value is also used
-- by /resetUserProperty.
--
--This is used to create a property or attribute of a control that is not
-- standard. You can use this property however you like; the library doesn't use them 
-- and Windows doesn't know about them.. The most common
-- usage is to store information for specific controls that are not
-- normally tracked.
--
--Example:
--/code
--      -- Create a property called 'OrigValue' for three controls.
--      defineUserProperty({fldName, fldAddr, fldPhone},
--                          "OrigValue", "")
--/endcode
global procedure defineUserProperty(object pControl, object pPropId, object pData)
integer lPropIdx
    if sequence(pControl) then
        for i=1 to length(pControl) do
            defineUserProperty(pControl[i], pPropId, pData)
        end for
        return
    end if

    if not validId(pControl) then
        return
    end if

    -- See if this has already been defined for the control.
    if integer(pPropId) then

        lPropIdx = pPropId
        if lPropIdx>length(ctrl_IntData[pControl][tagPropData]) then
            ctrl_IntData[pControl][tagPropInit] = append(ctrl_IntData[pControl][tagPropInit],
                                                         repeat(lPropIdx-length(ctrl_IntData[pControl][tagPropInit]), 0))
            ctrl_IntData[pControl][tagPropData] = append(ctrl_IntData[pControl][tagPropData],
                                                         repeat(lPropIdx-length(ctrl_IntData[pControl][tagPropData]), 0))
            ctrl_IntData[pControl][tagPropInit][lPropIdx] = pData
        end if
        ctrl_IntData[pControl][tagPropData][lPropIdx] = pData

    else
        lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

        -- If not, then add it a new property.
        if lPropIdx=0 then
            ctrl_UserData[pControl][tagPropId] = append(ctrl_UserData[pControl][tagPropId], pPropId)
            ctrl_UserData[pControl][tagPropInit] = append(ctrl_UserData[pControl][tagPropInit], pData)
            ctrl_UserData[pControl][tagPropData] = append(ctrl_UserData[pControl][tagPropData], pData)
        else
            -- else change the property's initial data value.
            ctrl_UserData[pControl][tagPropInit][lPropIdx] = pData
        end if

    end if
end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setUserProperty( object id, object PropId, object Data)
--/desc Stores data into a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i PropId specifies a property defined by an early call to /defineUserProperty /n
--/i Data is any data you wish to store in that property. /n
--
--/b Note: If the property named in /i PropId hasn't been defined yet for
-- /i id, this routine will automatically define it, using /i Data as the
-- default value for it.
--
--Example:
--/code
--      -- Set the original values for these fields.
--      setUserProperty(fldName, "OrigValue", lRecord[cName])
--      setUserProperty(fldAddr, "OrigValue", lRecord[cAddr])
--      setUserProperty(fldPhone, "OrigValue", lRecord[cPhone])
--/endcode
global procedure setUserProperty(object pControl, object pPropId, object pData)
integer lPropIdx

    if sequence(pControl) then
        for i=1 to length(pControl) do
            setUserProperty(pControl[i], pPropId, pData)
        end for
        return
    end if

    if not validId(pControl) then
        return
    end if

    -- See if this has already been defined for the control.
    if integer(pPropId) then

        if pPropId>length(ctrl_IntData[pControl][tagPropInit]) then
            defineUserProperty(pControl, pPropId, pData)
        else
            ctrl_IntData[pControl][tagPropData][pPropId] = pData
        end if
    else
        lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

        -- If yes, set the new value
        if lPropIdx=0 then
            defineUserProperty(pControl, pPropId, pData)
        else
            ctrl_UserData[pControl][tagPropData][lPropIdx] = pData
        end if
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc resetUserProperty( object pControl, object pPropId)
--/desc Initializes a user defined property for this control /i id.
--/i pControl specifies either a single control id or a list of control ids /n
--/i pPropId specifies a property defined by an early call to /defineUserProperty.
-- The property is reset to the initial value originally supplied
-- when defined with /defineUserProperty.
--
--Example:
--/code
--      -- Set the original values back to their initial value.
--      resetUserProperty({fldName,fldAddr, fldPhone}, "OrigValue")
--/endcode
global procedure resetUserProperty(object pControl, object pPropId)
integer lPropIdx

    if sequence(pControl) then
        for i=1 to length(pControl) do
            resetUserProperty(pControl[i], pPropId)
        end for
        return
    end if

    if not validId(pControl) then
        return
    end if

    -- See if this has already been defined for the control.
    if integer(pPropId) then

        if pPropId<=length(ctrl_IntData[pControl][tagPropData]) then
            ctrl_IntData[pControl][tagPropData][pPropId] =
                ctrl_IntData[pControl][tagPropInit][pPropId]
        end if
    else
        lPropIdx = find(pPropId, ctrl_UserData[pControl][tagPropId])

        -- If yes, set the value to the initialisation value
        if lPropIdx!=0 then
            ctrl_UserData[pControl][tagPropData][lPropIdx] =
                ctrl_UserData[pControl][tagPropInit][lPropIdx]
        end if
    end if
end procedure


-----------------------------------------------------------------------------
--/topic Attributes
--/func getUserProperty( object pControl, object pPropId)
--/desc Retrieves data from a user defined property for this control /i id.
--/ret Sequence: The contents of the user defined property.
-- /i pControl specifies the id of the control. This can be either a
-- single id, or a list of ids in a sequence. /n
-- /i pPropId specifies a
-- property defined by an early call to /defineUserProperty. /n
-- The data is returned as the first, and only, element in a sequence.
-- If an empty sequence is returned, it means that the specified
-- property has not been defined for this control. /n
-- If /i id is a sequence, then the returned sequence contains two
-- subsequences. The first is a list of the returned property values and
-- the second is a list of w32True/w32False values; one per control listed
-- in /i id. A w32True indicates that the respective control has this property
-- set and w32False indicates that it has not been set.
--
--Examples:
--
--/code
--      sequence lValues
--      lValues = getUserProperty(fldX, "Animation")
--      if length(lValues) = 0 then
--          -- No value, so use a default.
--          lValues = {20}
--      end if
--      -- NB: The property value is always in element [1]!
--      doAnimation( lValues[1] )
--/endcode
--
-- This next example shows how to get the property values from a list of controls
--/code
--      sequence lValues
--      sequence lFlds
--
--      lFlds = {fldA, fldB, fldC}
--      lValues = getUserProperty( lFlds, "TimeOut")
--      for i = 1 to length(lValues) do
--          if lValues[2][i] = w32False then
--              -- Provide a default value then.
--              lValues[1][i] = 5
--          end if
--          -- Process the property value which is in lValues[1][i]
--          doSomethingClever( lFlds[i], lValues[1][i])
--      end for
--/endcode
global function getUserProperty(object pControl, object pPropId)
sequence lData
integer lPropIdx
integer lMultiple

    lData = {{},{}}
    if atom(pControl) then
        pControl = {pControl}
        lMultiple = w32False
    else
        lMultiple = w32True
    end if

    for i=1 to length(pControl) do
        if validId(pControl[i]) then

            -- See if this has already been defined for the control.
            if integer(pPropId) then

                if pPropId<=length(ctrl_IntData[pControl[i]][tagPropData]) then
                    lData[1] = append(lData[1], ctrl_IntData[pControl[i]][tagPropData][pPropId])
                    lData[2] &= w32True
                else
                    lData[1] &= w32False
                    lData[2] &= w32False
                end if
            else
                lPropIdx = find(pPropId, ctrl_UserData[pControl[i]][tagPropId])

                -- If yes, return the value
                if lPropIdx!=0 then
                    lData[1] = append(lData[1], ctrl_UserData[pControl[i]][tagPropData][lPropIdx])
                    lData[2] &= w32True
                else
                    lData[1] &= w32False
                    lData[2] &= w32False
                end if
            end if
        end if
    end for

    if lMultiple=w32False then
        if length(lData[2])>0 and lData[2][1]=w32True then
            lData = lData[1]
        else
            lData = {}
        end if
    end if
    return lData
end function

--/topic Attributes
--/proc deleteUserProperty( object pControl, object pPropId)
--/desc Deletes a user defined property for this control /i id.
-- /i pControl specifies the id of the control. This can be either a
-- single id, or a list of ids in a sequence. /n
-- /i pPropId specifies a
-- property defined by an earlier call to /defineUserProperty. /n
--
--Examples:
--
--/code
--      deleteUserProperty(fldX, "Animation")
--      deleteUserProperty( {fldA, fldB, fldC}, "TimeOut")
--/endcode

global procedure deleteUserProperty(object pControl, object pPropId)
integer lIdx

    if atom(pControl) then
        pControl = {pControl}
    end if

    for i=1 to length(pControl) do
        if not integer(pPropId) then
            lIdx = find(pPropId, ctrl_UserData[pControl[i]][tagPropId])
            if lIdx!=0 then
                ctrl_UserData[pControl[i]][tagPropId] = w32removeIndex(lIdx, ctrl_UserData[pControl[i]][tagPropId])
                ctrl_UserData[pControl[i]][tagPropData] = w32removeIndex(lIdx, ctrl_UserData[pControl[i]][tagPropData])
            end if
        end if
    end for

end procedure

--/topic Controls
--/proc closeWindow( window )
--/desc Close /i window.
-- If /i window is not a main window, /i window will be hidden
-- and the /Close event will be triggered.
--
-- If /i window is the /b "main window" (see /WinMain) or zero, then the
-- application will be shut down and the /Close event will
--
-- If /i window is not a valid id, then no action is taken.
--
-- Example:
--
--/code
--          -- close TheDialog
--          /closeWindow( TheDialog )
--/endcode

global procedure closeWindow(integer id)
    if id=0 then
        id = mainWindow
    end if
    if validId(id) then
        -- close the window
        VOID = sendMessage(id, WM_CLOSE, 0, 0)
    end if

end procedure

global procedure autoclose(integer self, integer event, sequence parms)
    if event or sequence(parms) then end if
    closeWindow(findParentWindow(self))
end procedure
r_autoclose = routine_id("autoclose")
registerRoutine("autoclose",r_autoclose)

integer vEmptySlots
vEmptySlots = 16

--/topic Controls
--/proc setControlBlocks(integer pQty)
--/desc Sets the number of new memory areas created for new controls
--Whenever a new control is created, it requires some memory to be allocated
--to manage it, and because this can be a performance hit win32lib has the
-- ability to created multiple new control blocks in one operation. This
-- means that when a new control is being created, and there is no available
-- control blocks, it will create /i pQty control blocks so that the next
-- new control doesn't have to allocate memory. Initially win32lib will
-- allocate 16 new control memory blocks. /n
-- /b Note: /i pQty must be 1 or more, otherwise 16 will be used.
--
--Example
--/code
--          -- lots of Controls will be created in this app
--          -- so allocate all the control blocks in one go.
--          setControlBlocks(147)
--          -- The first new create() will actually allocate the memory.
--          constant myWin = /create(Window, ...)
--/endcode

---------------------------------------------------------
global procedure setControlBlocks(integer pQty)
---------------------------------------------------------
    if pQty>=1 then
        vEmptySlots = pQty
    else
        vEmptySlots = 16
    end if
end procedure


--/topic MouseTraps
--/info
--Defined sub-regions of a window that can generate /w32HMouseTrap events.
--These are used to make it easy to detect mouse activity in specific sub-regions of a window or other control.


--/topic MouseTraps
--/func createMouseTrap(integer pWindow, object pRect)
--/desc Defines a mousetrap area
--/ret INTEGER: A mousetrap ID.
--This defines an subregion of /i pWindow, bounded by /i pRect that can generate
-- /w32HMouseTrap events. /n
--/i pWindow is a top-level Window control. It must not have any parent. /n
--/i pRect is either a four-element sequence in the form
-- {left, top, right, bottom} relative to /i pWindow, or the id of a
-- child control of /i pWindow. In the second case, the mousetrap covers the entire
-- area of the child control.
--
--Example:
--/code
--      integer mt
--      mt1 = createMouseTrap(myWin, {10,10,30,30})
--      mt2 = createMouseTrap(myWin, myBitMap)
--/endcode

---------------------------------------------------------
global function createMouseTrap(integer pWindow, object pRect)
---------------------------------------------------------
integer lNewMouseTrap
integer lRelId

    if atom(ctrl_Mousetrap[pWindow]) then
        ctrl_Mousetrap[pWindow] = repeat(-1, 10)
    end if

    lNewMouseTrap = find(-1, ctrl_Mousetrap[pWindow])
    if lNewMouseTrap=0 then
        lNewMouseTrap = length(ctrl_Mousetrap[pWindow])+1
        ctrl_Mousetrap[pWindow] &= repeat(-1, 10)
    end if

    if atom(pRect) then
        lRelId = pRect
        pRect = call_func(r_getRect,{lRelId})
        pRect = pRect[1..4]
        if findParent(lRelId)!=pWindow then
            -- Convert coordinates so they are relative to window.
--/**/      pRect[3..4] = sq_sub(pRect[3..4],pRect[1..2])                   --/* -- Phix
            pRect[3..4] -= pRect[1..2]                                      --*/ -- RDS
            pRect[1..2] = clientToClient(lRelId, pWindow, pRect[1..2])
            pRect[3..4] = clientToClient(lRelId, pWindow, pRect[3..4])
        end if
    end if
    ctrl_Mousetrap[pWindow][lNewMouseTrap] = 0 & pRect & w32True & 0 & {{WM_LBUTTONDOWN}}

    return lNewMouseTrap
end function


--/topic MouseTraps
--/proc updateMouseTrap(integer pWindow, integer pMouseTrap, object pRect)
--/desc This changes the bounding rectangle for a mousetrap.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to update. /n
--/i pRect is either a four-element sequence in the form
-- {left, top, right, bottom} relative to the /i pWindow control, or the id of a
-- child control of /i pWindow. In the second case, the mousetrap covers the entire
-- area of the child control. /n
--
--/b Note that if the specified mousetrap does not exist, it will be created
-- automatically.
--
--Example:
--/code
--      updateMouseTrap(myWin, 2, {20,17,156, 281})
--      updateMouseTrap(myWin, 1, myBitMap)
--/endcode
---------------------------------------------------------
global procedure updateMouseTrap(integer pWindow, integer pMouseTrap, object pRect)
---------------------------------------------------------
    if atom(ctrl_Mousetrap[pWindow]) then
        ctrl_Mousetrap[pWindow] = repeat(-1, 10)
    end if
    if pMouseTrap>length(ctrl_Mousetrap[pWindow]) then
        ctrl_Mousetrap[pWindow] = repeat(-1, pMouseTrap-length(ctrl_Mousetrap[pWindow]))
    end if

    if atom(pRect) then
        pRect = call_func(r_getRect,{pRect})
        pRect = pRect[1..4]
    end if
    if atom(ctrl_Mousetrap[pWindow][pMouseTrap]) then
        ctrl_Mousetrap[pWindow][pMouseTrap] = 0 & pRect & w32True & 0 & {{WM_LBUTTONDOWN}}
    else
        ctrl_Mousetrap[pWindow][pMouseTrap][2..5] = pRect
    end if
end procedure

--/topic MouseTraps
--/proc deleteMouseTrap(integer pWindow, integer pMouseTrap)
--/desc This removes the specified mousetrap area from the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to remove. /n
--
--/b Note that if /i pMouseTrap is less than one, all mousetraps
-- for the window will be deleted.
--
--Example:
--/code
--      -- Remove mousetrap #3
--      deleteMouseTrap(MyWindow, 3)
--      -- Remove all mousetraps from the window.
--      deleteMouseTrap(DiagWin, -1)
--/endcode
---------------------------------------------------------
global procedure deleteMouseTrap(integer pWindow, integer pMouseTrap)
---------------------------------------------------------
    if pMouseTrap>0 then
        ctrl_Mousetrap[pWindow][pMouseTrap] = -1
    else
        -- Remove all mousetraps.
        ctrl_Mousetrap[pWindow] = -1
    end if
end procedure

--/topic MouseTraps
--/proc enableMouseTrap(integer pWindow, object pMouseTrap, integer pState)
--/desc This alters the 'enabled' state of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to enable. /n
--/i pState is either w32True or w32False. A setting of w32False will prevent this mousetrap
-- from generating events.
--
--/b Note that /i pMouseTrap can also be a list of mousetrap Ids.
--
--Example:
--/code
--      -- Disable mousetrap #1
--      enableMouseTrap(myWin, 1, w32False)
--      -- Enable mousetraps #2, 8, 5, and 4.
--      enableMouseTrap(myWin, {2,8,5,4}, w32True)
--/endcode
---------------------------------------------------------
global procedure enableMouseTrap(integer pWindow, object pMouseTrap, integer pState)
---------------------------------------------------------
    if atom(pMouseTrap) then
        pMouseTrap = {pMouseTrap}
    end if
    for i=1 to length(pMouseTrap) do
        ctrl_Mousetrap[pWindow][pMouseTrap[i]][6] = pState
    end for
end procedure

--/topic MouseTraps
--/proc filterMouseTrap(integer pWindow, object pMouseTrap, object pEvents)
--/desc This alters the 'filters' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to filter. /n
--/i pEvents is a list of Windows mouse event codes. These are the only mouse events
-- that can cause this mousetrap area to react.
--
--/b Note that /i pMouseTrap can also be a list of mousetrap Ids.
--
--Example:
--/code
--      -- Check for Wheel movement
--      filterMouseTrap(myWin, 1, WM_WHEELMOUSE)
--      -- Check for Right Button events
--      filterMouseTrap(myWin, {2,8,5,4}, {WM_RBUTTONDOWN, WM_RBUTTONUP})
--/endcode
---------------------------------------------------------
global procedure filterMouseTrap(integer pWindow, object pMouseTrap, object pEvents)
---------------------------------------------------------
    if atom(pEvents) then
        pEvents = {pEvents}
    end if
    if atom(pMouseTrap) then
        pMouseTrap = {pMouseTrap}
    end if
    for i=1 to length(pMouseTrap) do
        ctrl_Mousetrap[pWindow][pMouseTrap[i]][8] = pEvents
    end for
end procedure

--/topic MouseTraps
--/proc zorderMouseTrap(integer pWindow, object pMouseTrap, integer pOrder)
--/desc This alters the 'depth' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to order. /n
--/i pOrder the absolute depth value. The higher the number, the further in the
-- background the mousetrap area is. Initially a mousetrap is created with a depth value
-- of zero. Negative numbers move the mousetrap closer to the foreground.
--
-- Use this if you have mousetrap areas that can overlap. When the w32HMouseTrap
-- event fires, you get a list of mousetrap areas sorted from closest (in foreground)
-- to furtherest (in background).
--
--Example:
--/code
--      -- move area #1 close to the front.
--      zorderMouseTrap(MyWindow, 1, -10)
--
--      -- Order things so that the man is in front of the
--      -- bush and the bush is in front of the wall.
--      zorderMouseTrap(MyWindow, Wall, 3)
--      zorderMouseTrap(MyWindow, Bush, 2)
--      zorderMouseTrap(MyWindow, Man, 1)
--
--/endcode
---------------------------------------------------------
global procedure zorderMouseTrap(integer pWindow, integer pMouseTrap, integer pOrder)
---------------------------------------------------------
    ctrl_Mousetrap[pWindow][pMouseTrap][1] = pOrder
end procedure

--/topic MouseTraps
--/proc setTagMouseTrap(integer pWindow, object pMouseTrap, object pData)
--/desc This alters the 'user data' of the specified mousetrap area in the window.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap to hold the data. /n
--/i pData is any data you wish to store with this mousetrap.
--
-- Win32lib never uses this data. It is a convenience for the coder to
-- save data specific for the user-defined mousetrap event processing.
--
-- You can use /getTagMouseTrap() to retrieve this data.
--
--Example:
--/code
--      -- Save a routine id to handle things.
--      setTagMouseTrap(MyWindow, 1, routine_id("MT1_Catch"))
--
--      -- Save some color data
--      setTagMouseTrap(MyWindow, 2, {Red, Cyan, BrightGreen})
--
--/endcode
---------------------------------------------------------
global procedure setTagMouseTrap(integer pWindow, integer pMouseTrap, object pData)
---------------------------------------------------------
    ctrl_Mousetrap[pWindow][pMouseTrap][7] = pData
end procedure

--/topic MouseTraps
--/func getTagMouseTrap(integer pWindow, object pMouseTrap)
--/desc This fetches the data stored by /setTagMouseTrap()
--/ret OBJECT: Whatever the user data has been set for the mousetrap.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap that holds the data. /n
--
-- You must use /setTagMouseTrap() to store this data.
--
--Example:
--/code
--      -- Save a routine id to handle things.
--      setTagMouseTrap(MyWindow, 1, routine_id("MT1_Catch"))
--      . . .
--      -- Fetch the routine id to use.
--      rtnid = getTagMouseTrap(MyWindow, 1)
--      call_proc(rtnid, . . .)
--
--/endcode

global function getTagMouseTrap(integer pWindow, integer pMouseTrap)
    return ctrl_Mousetrap[pWindow][pMouseTrap][7]
end function

--/topic MouseTraps
--/func getMouseTrap(integer pWindow, object pMouseTrap)
--/desc This fetches all the information about the specified mousetrap.
--/ret OBJECT: -1 if /i pMouseTrap is not valid, otherwise a MouseTrap sequence.
--/i pWindow is the window that owns the mousetrap. /n
--/i pMouseTrap is the id of the mouse trap. /n
--
-- Each mousetrap is a sequence of 8 elements: /n
--/li integer: /b zorder, the higher numbers are further in the background. The
-- initial value is zero when a mousetrap is created.
--/li integer: /b left, the leftmost position of the mousetrap area
--/li integer: /b top, the topmost position of the mousetrap area
--/li integer: /b right, the rightmost position of the mousetrap area
--/li integer: /b bottom, the bottommost position of the mousetrap area
--/li integer: /b enableFlag, either w32True if enabled else w32False.
--/li object: /b userdata, the data set by calling /setTagMouseTrap(). This is
--never used by win32lib and is intended for use by the user for anything.
--/li sequence: /b filters, a list of zero or more mouse event codes that are used
--to filter in this mousetrap. Initially this set to {WM_LBUTTONDOWN} when
--then mousetrap is created. It can be changed by calling /filterMouseTrap().
--
--Example:
--/code
--      -- Fetch the mousetrap info.
--      object MT
--      MT = getMouseTrap(MyWindow, 1)
--      if atom(MT) then
--          -- the mousetrap doesn't exist.
--      else
--          -- process it...
--      end if
--/endcode
---------------------------------------------------------
global function getMouseTrap(integer pWindow, integer pMouseTrap)
---------------------------------------------------------
    if atom(ctrl_Mousetrap[pWindow]) or (pMouseTrap>length(ctrl_Mousetrap[pWindow])) or pMouseTrap<1 then
        return -1
    end if
    return ctrl_Mousetrap[pWindow][pMouseTrap]
end function

--/topic MouseTraps
--/func hitMouseTrap(integer pWindow, integer pEvent, integer pX, integer pY)
--/desc This returns all mousetraps for the window that are under the /i pX and /i pY position.
--/ret SEQUENCE: A list of zero or more mousetraps.
--/i pWindow is the window that owns the mousetrap. /n
--/i pEvent used to filter. Only mousetraps looking for this event can be returned./n
--/i pX, /i pY are  coordinates. Only mousetraps that are under this position can be returned.
--
--/b Note that disabled mousetraps are ignored.
--
-- The returned list is sorted from closest to furtherest away, based on the z-order settings
-- of the mousetraps. These are set by calling /zorderMouseTrap().
--
--The format of each element in the returned list is :
--/li integer: /b zorder
--/li integer: /b left
--/li integer: /b top
--/li integer: /b right
--/li integer: /b bottom
--/li integer: /b "mousetrap id"
--/li object: /b userdata
--/li sequence: /b filters
--
--Example:
--/code
--      sequence MTList
--      -- Get all the mousetraps that are under (100,100) that are looking for
--      -- left button down events.
--      MTList = hitMouseTrap(myWindow, WM_LBUTTONDOWN, 100, 100)
--
--/endcode
---------------------------------------------------------
global function hitMouseTrap(integer pWindow, integer pEvent, integer pX, integer pY)
---------------------------------------------------------
sequence lMouseTraps
sequence lR

    if atom(ctrl_Mousetrap[pWindow]) then
        return {}
    end if

    lMouseTraps = {}
    lR = {}
    for i=1 to length(ctrl_Mousetrap[pWindow]) do
        if sequence(ctrl_Mousetrap[pWindow][i]) then
            lR = ctrl_Mousetrap[pWindow][i]
            if lR[6]=w32True and find(pEvent, lR[8]) and
               lR[2]<=pX and lR[3]<=pY and
               lR[4]>pX and lR[5]>pY then
                lR[6] = i
                lMouseTraps = append(lMouseTraps, lR)
            end if
        end if
    end for

    if length(lMouseTraps)>0 then
        lMouseTraps = sort(lMouseTraps)
    end if
    return lMouseTraps
end function

procedure statusbar_resize(integer self, integer event, sequence parms)
sequence lSize
integer lWidth
integer lHeight

    if event or sequence(parms) then end if

    if parms[2]=w32HResize then
        -- get size of statusbar
        lSize = call_func(r_getClientRect,{self})
        lWidth = parms[4][2]
        lHeight = parms[4][3]

        -- calculate position
        VOID = w32Func(xMoveWindow,
                       {getHandle(self), 0, lHeight-lSize[4], lWidth, 0, w32True})
    end if
end procedure

procedure toolbar_resize(integer self, integer event, sequence parms)
sequence lOuterSize
sequence lInnerSize
integer lWidth
    if event or sequence(parms) then end if
    if parms[2]=w32HResize then
        -- get size of toolbar
        lInnerSize = call_func(r_getClientRect,{self})
        lWidth = parms[4][2]

        if lWidth!=lInnerSize[3] then
            lOuterSize = getCtlSize(self)
            VOID = w32Func(xMoveWindow,
                           {getHandle(self), 0, 0, lWidth, lOuterSize[2], 1})
            --repaintWindow(self)
        end if
    end if
end procedure

constant     PenDefaults     = {Black, Solid, R2_COPYPEN, TRANSPARENT,
                                1, w32Color_BTNFACE, {}}

---------------------------------------------------------
function NewControl(integer pType, integer pOwner)
---------------------------------------------------------
-- Allocates an ID and management areas for a new control.
integer id
sequence lEmptySlots

    -- look for an available slot

    id = ctlblk_freelist[1]
    if id=0 then
        for i=length(ctrl_Destroyed) to vPrevCtlBlkLength by -1 do
            if ctrl_Destroyed[i]= -1 then
                id = i
                exit
            end if
        end for
    else
        ctlblk_freelist = ctlblk_freelist[2..length(ctlblk_freelist)]
    end if

    --id = find(-1, ctrl_Destroyed)
    if id=0 then     -- create slots for attributes
        vPrevCtlBlkLength = length(ctrl_Destroyed)+1
        lEmptySlots         = repeat(-1, vEmptySlots)
        ctrl_Destroyed    &= lEmptySlots
        ctrl_Handle       &= lEmptySlots
        ctrl_Handle_type  &= lEmptySlots
        ctrl_Function         &= lEmptySlots
        ctrl_Family       &= lEmptySlots
        ctrl_Type         &= lEmptySlots
        ctrl_Focus_order  &= lEmptySlots
        ctrl_Current_focus        &= lEmptySlots
        ctrl_Previous_focus   &= lEmptySlots
        ctrl_Parent        &= lEmptySlots
        ctrl_X_Pos            &= lEmptySlots
        ctrl_Y_Pos            &= lEmptySlots
        ctrl_Erase        &= lEmptySlots
        ctrl_Font         &= lEmptySlots
        ctrl_Pen          &= lEmptySlots
        ctrl_Fg_Color       &= lEmptySlots
        ctrl_Bg_Color       &= lEmptySlots
        ctrl_Scroll       &= lEmptySlots
        ctrl_Range        &= lEmptySlots
        ctrl_Specific     &= lEmptySlots
        ctrl_Group        &= lEmptySlots
        ctrl_Cursor       &= lEmptySlots
        ctrl_Menu         &= lEmptySlots
        ctrl_Popup        &= lEmptySlots
        ctrl_Notify_List     &= lEmptySlots
        ctrl_Toolbar      &= lEmptySlots
        ctrl_Statusbar    &= lEmptySlots
        ctrl_Hint_Text      &= lEmptySlots
        ctrl_Hint_Width   &= lEmptySlots
        ctrl_Hotkey_Keys  &= lEmptySlots
        ctrl_Hotkey_Ids   &= lEmptySlots
        ctrl_Text_Alignment    &= lEmptySlots
        ctrl_Closed       &= lEmptySlots
        ctrl_TabKey_Used   &= lEmptySlots
        ctrl_Handlers &= lEmptySlots
        ctrl_Bg_Brush       &= lEmptySlots
        ctrl_UserData          &= lEmptySlots
        ctrl_IntData         &= lEmptySlots
        ctrl_Name         &= lEmptySlots
        ctrl_Init_Posns         &= lEmptySlots
        ctrl_ClassAddr        &= lEmptySlots
        ctrl_Mousetrap       &= lEmptySlots
        ctrl_Visible        &= lEmptySlots
        ctrl_SetVisible       &= lEmptySlots
        ctrl_HandlerStates       &= lEmptySlots
        ctrl_ActualClass       &= lEmptySlots
        ctrl_CanFocus       &= lEmptySlots
        ctrl_KbdInput       &= lEmptySlots
        ctrl_FormerId       &= lEmptySlots
        ctrl_Hatch          &= lEmptySlots
        ctrl_RecursivePaint &= lEmptySlots
        ctrl_ProtectHandlers &= lEmptySlots
        ctrl_ImageList      &= lEmptySlots


        id = length(ctrl_Destroyed)-vEmptySlots+1
    end if

    -- initialize to defaults
    ctrl_Destroyed[id]    = 0
    ctrl_Handle[id]       = -1
    ctrl_Handle_type[id]  = -1
    ctrl_Function[id]         = -1
    ctrl_Family[id]       = classType[pType]
    ctrl_Type[id]         = pType
    ctrl_Focus_order[id]  = {}
    ctrl_Current_focus[id]        = 0
    ctrl_Previous_focus[id]   = 0
    ctrl_Parent[id]        = pOwner
    ctrl_X_Pos[id]            = 0
    ctrl_Y_Pos[id]            = 0
    ctrl_Erase[id]        = w32False
    ctrl_Font[id]         = FontDefaults
    ctrl_Pen[id]          = PenDefaults
    ctrl_Fg_Color[id]       = classFGColor[pType]
    ctrl_Bg_Color[id]       = classBGColor[pType]
    ctrl_Range[id]        = {{0,100},{0,100}}
    ctrl_Scroll[id]       = {{1,10}, {1,10}}
    ctrl_Specific[id]     = 0
    ctrl_Group[id]        = {}
    ctrl_Cursor[id]       = {w32Func(xLoadCursor, {NULL, classDefPointer[pType]})}
    ctrl_Menu[id]         = 0
    ctrl_Popup[id]        = {-1,-1,-1,-1} -- One for normal, shift, ctrl, shift-ctrl.
    ctrl_Notify_List[id]     = {{},{},{},{}}  -- { {id ...}, {{events per id...} }, {{userdata ...}},{{states per id ...}} }
    ctrl_Toolbar[id]      = {} -- a window may have several toolbars
    ctrl_Statusbar[id]    = 0
    ctrl_Hint_Text[id]      = ""
    ctrl_Hint_Width[id]   = 200
    ctrl_Hotkey_Keys[id]  = {}
    ctrl_Hotkey_Ids[id]   = {}
    ctrl_Text_Alignment[id]    = TA_TOP
    ctrl_Closed[id]       = -11  -- Until its opened.
    ctrl_TabKey_Used[id]   = w32iff(and_bits(classAttr[pType], w32CtrlTab),0,1)
    ctrl_Handlers[id] = repeat({}, w32LastEventType())
    ctrl_Bg_Brush[id]       = 0
    ctrl_UserData[id]          = {{},{},{}}
    ctrl_IntData[id]         = {{},{}}
    ctrl_Name[id]         = 0
    ctrl_Init_Posns[id]         = {{},{}}
    ctrl_ClassAddr[id]      = 0
    ctrl_Mousetrap[id]    = 0
    -- added CChris <oedoc@free.fr> Oct 26, 2006
    ctrl_Visible[id] = w32True
    ctrl_SetVisible[id] = w32True
    ctrl_HandlerStates[id] = repeat({}, w32LastEventType())
    ctrl_ActualClass[id]         = pType
    ctrl_CanFocus[id] = 1
    ctrl_KbdInput[id] = -1
    ctrl_FormerId[id] = 0
    ctrl_Hatch[id] = 0
    ctrl_RecursivePaint[id] = 0
    ctrl_ProtectHandlers[id] = repeat(0, w32LastEventType())
    ctrl_ImageList[id]       = 0

    if pOwner>0 and pOwner<=length(ctrl_Group) then
        ctrl_Group[pOwner] &= id
    end if

    if and_bits(classAttr[pType], w32AutoSelect) then
        ctrl_Specific[id] = w32True
    end if

    -- Changed CChris <oedoc@free.fr> Dec 23,2006
    -- moved this chunk from createEx() so that NewControl (hence subClassControl) can take care of nearly all parenthood issues
    if and_bits(classAttr[pType], w32Toolbar) then
        -- track toolbar in owner
        ctrl_Toolbar[pOwner] &= id
        setHandler(id, w32HNotify, routine_id("toolbar_resize"))
        call_proc(r_registerNotification, {pOwner, 1, w32HResize, id, 0})
    end if
    if and_bits(classAttr[pType], w32Statusbar) and
    -- windows aren't supposed to have several status bars
    ctrl_Statusbar[pOwner]=0 then
    -- track statusbar in owner
        ctrl_Statusbar[pOwner] = id
        setHandler(id, w32HNotify, routine_id("statusbar_resize"))
        call_proc(r_registerNotification, {pOwner, 1, w32HResize, id, 0})
    end if

    return id
end function

constant LV_COL_DEF_WIDTH = 100 -- a decent value
procedure handleLV(integer id,atom flags,object lvcol)
-- CC: moved this chunk from createEx() so that subclassed LV could be handled right
-- set up image lists and columns
integer count,len
sequence attribs
sequence coldata
object rawcol
atom il

    if not ILlarge then
        ILlarge = call_func(r_createEx,{ImageList, "", 0, 0,0,SM_CXICON,0,
                                        ILC_COLOR8,0})
        ILsmall = call_func(r_createEx,{ImageList, "", 0, 0,0,SM_CXSMICON,0,
                                        ILC_COLOR8,0})
        hILlarge = ctrl_Handle[ILlarge]
        hILsmall = ctrl_Handle[ILsmall]
    end if

    if and_bits(LVS_REPORT, flags)!=0 then
        if atom(lvcol) then  -- subclassed control
            count = w32Func(xSendMessage,{lvcol,HDM_GETITEMCOUNT,0,0})
            attribs = repeat('i',count)
            lv_id &= id
            lv_properties = append(lv_properties,{attribs,0,0})
--/**/      attribs = sq_sub(attribs,2)         --/* -- Phix
            attribs = -2                        --*/ -- RDS
            len = length(lv_properties)
            lv_properties[len][3] = attribs
            if and_bits(flags,LVS_SORTDESCENDING) then
--/**/          attribs = sq_mul(-1,attribs)    --/* -- Phix
                attribs=-attribs                --*/ -- RDS
            end if
            lv_properties[len][2] = attribs
        else
            if w32string(lvcol) then
                lvcol = {{lvcol}}
            end if
            for i=1 to length(lvcol) do
                rawcol = lvcol[i]
                if w32string(rawcol) then
                    rawcol = {rawcol}
                end if
                if atom(rawcol) then
                    coldata = {"", w32abs(floor(rawcol)),0}
                elsif length(rawcol)>=3 then
                    coldata = rawcol[1..3]
                elsif length(rawcol)=0 then
                    coldata = {"", LV_COL_DEF_WIDTH,0}
                elsif not sequence(rawcol[1]) then
                -- We only have a column width
                    coldata = {"", floor(0.5+w32abs(rawcol[1])), 0}
                else
                    if length(rawcol)=1 then
                        -- No width, so set default
                        len = LV_COL_DEF_WIDTH
                    else
                        len = rawcol[2]
                    end if
                    coldata = {rawcol[1],len,0}
                end if
                insertLVColumn(id, 0, 0,0,0,coldata, i)
            end for
        end if
    end if

    il = sendMessage(id,LVM_GETIMAGELIST,LVSIL_SMALL,0)
    if il=0 or il=1 then -- this value of 1 is strange
        setImageList(id, ILlarge, LVSIL_NORMAL)
        setImageList(id, ILsmall, LVSIL_SMALL)
        ctrl_ImageList[id] = hILsmall
    else
        ctrl_ImageList[id] = il
        ctrl_Statusbar[id] = sendMessage(id,LVM_GETIMAGELIST,LVSIL_NORMAL,0)
        -- assuming the former wID of subclassed ListViews doesn't matter
    end if


    lv_id &= id
    lv_properties &= {lv_Default_Properties}
    lv_properties[length(lv_id)][kLVSortRtn] = r_lvSortitems
end procedure

procedure registerMenu(integer id,atom h)
-- registers recursively items and submenus
atom info,hsub
integer count,ch_id,flags

    menu_ids &= id
    menu_handles &= h
    info = w32to_memory(0,ID_MENUITEMINFO,0)
    w32store(info,MENUITEMINFO_fMask,MIIM_TYPE+MIIM_SUBMENU+MIIM_ID)
    count = w32Func(xGetMenuItemCount,{h})
    for i=1 to count do
        VOID = w32Func(xGetMenuItemInfo,{h,i-1,MF_BYPOSITION,info})
        hsub = w32fetch(info,MENUITEMINFO_hSubMenu)
        flags = w32fetch(info,MENUITEMINFO_fType)
        if hsub then
            ch_id = NewControl(Menu,id)
            ctrl_FormerId[id] = -1
            registerMenu(ch_id,hsub)
        else
            if and_bits(flags,MFT_SEPARATOR) then
                ch_id = MenuSpacer
            else
                ch_id = MenuItem
            end if
            ch_id = NewControl(ch_id,id)
            ctrl_FormerId[ch_id] = w32fetch(info,MENUITEMINFO_wID)
        end if
    end for
    w32release_mem(info)
end procedure

--/topic Menus
--/func getMenuBar(integer window,integer returnHandle)
--/ret (ATOM) id of window menu bar if /i returnHandle is 0, else its Windows handle.

global function getMenuBar(integer id,integer returnHandle)
atom result
    if ctrl_Family[id]!=WINDOW then
        return 0
    end if
    result = ctrl_Menu[id]
    if returnHandle then
        return result
    else
        return w32lookup(result,menu_handles,menu_ids)
    end if
end function

procedure getTVitem(integer id,atom h,integer idp,atom tvitem)
    tvitem_owner &= id
    tvitem_handle &= h
    tvitem_parent &= idp
    w32store(tvitem,TVITEM_hItem,h)
    VOID = sendMessage(id,TVM_GETITEM,0,tvitem)
    tvitem_data = append(tvitem_data,peek4u({tvitem,5}))
end procedure

procedure registerTV(integer id)
-- update all internal data
atom hItem,tvitem
sequence hParent

    tv_id &= id
    tvitem = w32to_memory(0,ID_TVITEM, {TVIF_TEXT+TVIF_IMAGE+TVIF_SELECTEDIMAGE+TVIF_CHILDREN,0,0,0,0,0,0,0,0})
    hItem = sendMessage(id,TVM_GETNEXTITEM,TVGN_ROOT,0)
    hParent = {0}
    while hItem do
        getTVitem(id,hItem,hParent[length(hParent)],tvitem)
        if tvitem_data[length(tvitem_data)][ktv_HasChildren] then
        -- start analysing children
            hParent &= hItem
            hItem = sendMessage(id,TVM_GETNEXTITEM,TVGN_CHILD,hItem)
        else
        -- more siblings?
            hItem = sendMessage(id,TVM_GETNEXTITEM,TVGN_NEXT,hItem)
            while not hItem do
            -- no more, back up and next
                hItem = hParent[length(hParent)]
                hParent = hParent[1..length(hParent)-1]
                hItem = sendMessage(id,TVM_GETNEXTITEM,TVGN_NEXT,hItem)
            end while
        end if
    end while
    w32release_mem(tvitem)
end procedure

--/topic Events
--/func subClassControl(sequence Id,  atom hWnd)
--/desc Used to access Windows created controls as if they were win32lib controls.
--/ret INTEGER: A win32lib control id. ZERO if it fails.
-- /i Id is a sequence {ControlType, ParentID} /n
-- /i hWnd is the Windows handle to the control.
-- Attempting to subclass a control several times results in the same id being returned. /n
-- Note that some Windows controls, notably ListViews and TabControls, have less many properties 
-- than their counterparts in the library. Thus:
--/li There is no attempt to guess on which tab item the children of a TabControl are, and they are not subclassed as a result;
--/li ListViews don't have a buitin column sort order, so a default one is  set up on subclassing.
--
-- More generally, children of subclassed controls are not automatically subclassed by the library, 
-- unless their class is determined by the parent. Thus, items in item containers are created,
-- but otherwise no attempt is made. See how /findVhildren() or /getChildren() cope with this.
--
--Example
--/code
--      -- Use an edit fld that was created outside of win32lib as if it was
--      -- a normal win32lib control.
--    newid = subClassControl( {EditText, myWindow}, winhandle)
--
--      -- Use an external bitmap as if it was a pixmap.
--    bmh = loadBitmapFromFile("..\\demoresources\\java.bmp")
--    myPixMap = subClassControl({Pixmap, 0}, bmh)
--    setPenColor(myPixMap, Cyan)
--    drawRectangle(myPixMap, 1, 0, 0, 40, 40)
--/endcode

global function subClassControl(sequence pId,  atom phWnd)
integer lNewId
integer lParent
integer lControlType
integer count

    if phWnd=0 then
        return 0
    end if

    lControlType = pId[1]
    lParent = pId[2]
    lNewId = getId(phWnd)
    if lNewId!=0 then -- hWnd already has an ID
        return lNewId
    elsif (lParent!=0 and phWnd=getHandle(lParent)) or -- is its own parent
    lControlType<1 or -- invalid control class
    lControlType>length(w32ControlTypes)
      then
        return 0
    else
        lNewId = NewControl(lControlType, lParent)
    end if

    if ctrl_Family[lNewId]!=MENU then
        setId(phWnd, lNewId)
    end if

    -- Set up data for child control

    -- Changed CChris <oedoc@free.fr> Oct 26, 2006
    -- Bug fixed: subclassed menus and image lists didn't have the right handle type recorded
    ctrl_Handle[lNewId] = phWnd
    if ctrl_Type[lNewId]=Pixmap then
        ctrl_Handle_type[lNewId] = kht_Bitmap
    elsif ctrl_Type[lNewId]=Menu or ctrl_Type[lNewId]=Popup then
        ctrl_Handle_type[lNewId] = kht_Menu
    elsif ctrl_Type[lNewId]=ImageList then
        ctrl_Handle_type[lNewId] = kht_ImageList
    elsif ctrl_Type[lNewId]=Window then
        ctrl_Handle_type[lNewId] = kht_Window
    end if
    if ctrl_Handle_type[lNewId] then
        ctrl_FormerId[lNewId] = -1
    elsif ctrl_Type[lNewId]=Pixmap then
        ctrl_FormerId[lNewId] = -1
    else
        ctrl_FormerId[lNewId] = w32Func(xGetWindowLong,{phWnd,GWL_USERDATA})
    end if
    ctrl_Function[lNewId]   = w32Func(xSetWindowLong, {phWnd, GWL_WndProc, SubProcAddress})

    -- children
    if ctrl_Type[lNewId]=TabControl then
        count = sendMessage(lNewId,TCM_GETITEMCOUNT,0,0)
        for i=1 to count do
            count = NewControl(TabItem,lNewId)
        end for
        ctrl_ImageList[lNewId] = sendMessage(lNewId,TCM_GETIMAGELIST,0,0)
    elsif ctrl_Family[lNewId]=MENU then
        registerMenu(lNewId,phWnd)
    elsif ctrl_Type[lNewId]=ListView then
        handleLV(lNewId,w32Func(xGetWindowLong,{phWnd,GWL_STYLE}),sendMessage(lNewId,LVM_GETHEADER,0,0))
    elsif ctrl_Type[lNewId]=TreeView then
        registerTV(lNewId)
        ctrl_ImageList[lNewId] = sendMessage(lNewId,TVM_GETIMAGELIST,0,0)
    end if

    return lNewId
end function
r_subClassControl = routine_id("subClassControl")

-----------------------------------------------------------------------------
procedure createPixmap(integer id, atom pWidth, atom pHeight)

atom hdc, handle
sequence s

    ctrl_Handle_type[id] = kht_Bitmap

    -- need to initialize pixmap?
    if pWidth>0 and pHeight>0 then

        pWidth = floor(pWidth)
        pHeight = floor(pHeight)

        -- get the dc of the screen
        hdc = getDC(Screen)

        -- create a window sized bitmap compatible with the screen
        handle = w32Func(xCreateCompatibleBitmap, {hdc, pWidth, pHeight})
        -- release the dc
        releaseDC(Screen)

        if handle=NULL then
            warnErr(Err_CREATEPIXMAP)
        end if


        -- store the handle
        ctrl_Handle[id] = handle

        -- track the bitmap as a resource
        trackObject({id,kBitmapObject}, handle, ForProgram)

        -- Fill it with its background color
        if atom(ctrl_Bg_Color[id]) then
            if equal(ctrl_Bg_Color[id], w32WinDefColor) then
                ctrl_Pen[id][PenColor] = Black
            else
                ctrl_Pen[id][PenColor] = ctrl_Bg_Color[id]
            end if
            drawRectangle(id, w32True, 0, 0, pWidth, pHeight)
        else
            s = ctrl_Bg_Color[id]
            if length(s)=1 then
                handle = w32Func(xCreatePatternBrush,s)
            else
                handle = w32Func(xCreateHatchBrush,{s[1],s[3]})
                call_proc(r_setBackColor,{id,s[2]})
            end if
            trackObject(id,handle,ForPaint)
            hdc = getDC(id)
            w32Proc(xSelectObject,{hdc,handle})
            if length(s)=3 then
                w32Proc(xSetBkMode,{hdc,TRANSPARENT})
            end if
            w32Proc(xRectangle,{hdc,0,0,pWidth,pHeight})
            releaseDC(id)
        end if

    end if
end procedure

sequence vs_PreviousControl -- static
vs_PreviousControl = {}

integer vAutoFocusLabels
vAutoFocusLabels = w32False
-----------------------------------------------------------------------------

--/topic System Attributes
--/func setAutoFocusLabels(integer NewValue)
--/desc Possibly sets whether or not a '&' in labels set focus to subsequent edit field.
--/ret Returns INTEGER: The current value of the flag.
--By default, this is set to w32False. Which means that any '&' in label captions
-- is ignored as far as setting focus to a subsequently defined input field. /n
-- If you set this to w32True then the '&' notation will cause focus to move to
-- the next input field defined after the label. Passing /w32GetValue will return the
-- current flag without setting it.
--
--Example:
--/code
--      integer lPrevFlag
--      . . .
--      -- Make labels focus on its input field.
--      lPrevFlag = setAutoFocusLabels(w32True)
--      -- The '&N' in the caption means that Alt-N will
--      -- set focus to the next input field.
--      lblX = create(LText, "&Name", Win, 5, 5, 40, 25, 0)
--      fldX = create(Editbox, "", Win, 5, 30, 120, 25, 0)
--      -- Set the flag back to whatever it was.
--      lPrevFlag = setAutoFocusLabels(lPrevFlag)
--
--/endcode

-----------------------------------------------------------------------------
global function setAutoFocusLabels(integer pNewValue)
-----------------------------------------------------------------------------
integer lOldValue

    lOldValue = vAutoFocusLabels
    if pNewValue!=w32GetValue then
        vAutoFocusLabels = pNewValue
    end if
    return lOldValue

end function


--/topic Attributes
--/func setKbdInput(integer id,object newVal)
--/desc Possibly sets the value to return, or the routine_id to use, when control receives the WM_GETDLGCODE message.
--/ret (OBJECT): the previous value.
-- If /i newVal is -1, the returned value is the default one for the actual class of /i id;
-- If it is any other integer, this integer is returned;
-- If it is an empty sequence, the current return policy remains unchanged;
-- Otherwise, the first element must be a positive integer, the routine_id of a function. The function is called with the parameters of the message, and its returned
-- value is returned to Windows. The returned values are either one or more <a href="..\win32_constants.htm#WM_GETDLGCODE return flags">DLGC_ flags</a>
-- or'ed together, or -1 to revert to the defaults for the control's class.

global function setKbdInput(integer id,object newVal)
object oldVal

    if not validId(id) then
        return {}
    end if
    oldVal = ctrl_KbdInput[id]
    if compare(newVal,{}) then
        ctrl_KbdInput[id] = newVal
    end if
    return oldVal

end function

--/topic Attributes
--/func getWindowRect( id )
--/desc Dimensions of window /i id.
--/ret { left, top, right, bottom }
-- Retrieves the dimensions of the bounding rectangle of the
-- specified window. The dimensions are given in screen coordinates
-- that are relative to the upper-left corner of the screen.
global function getWindowRect(integer id)
atom r
sequence result

    r = w32acquire_mem(0, SIZEOF_RECT)
    if not w32Func(xGetWindowRect, {ctrl_Handle[id], r}) then
        abortErr(Err_GSGETWINDRECT)
    else
        result = peek4s({r,4})
    end if

    w32release_mem(r)

    return result
end function


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setSubFields( integer pID, sequence pPartInfo )
--/desc Defines the sub-fields, or panels, in a status bar.
-- /i pID must refer to a status bar control. /n
-- /i pPartInfo is a list of panel size specifiers for each
-- subfield (a.k.a. panel) in the statusbar. /n
-- Each value in this list can be expressed in one of four
-- ways: /n
--<nl>
--/li A /b positive integer refers to the panels absolute right-hand side
-- pixel position
--/li A /b negitive integer less than -1. This refers to a right-hand side
-- position relative to the window's right-hand edge.
--/li An /b atom > 0 and ~< 1 refers to the panel's width
-- as a fraction of the window's width (0.25 means 25% of the window width)
-- /li A sequence (containing one integer) refers to the panel's width
-- in pixels.
--</nl>
-- If the any specification has the value -1, it means that
-- this is the last panel and it extends to the right hand edge of the
-- window.
--
-- You can use /setText() and /getText() to write and read these panels.
--
-- Example:
--/code
--       -- This specifies 6 panels.
--       -- The first one's rightedge is at pixel 55.
--       -- The second is 100 pixels wide.
--       -- The third is 10% of the window width.
--       -- The 4th is 20 pixels wide.
--       -- The 5th is 10 pixels in from the window's RHS.
--       -- The last one extends to the window's edge.
--       setSubFields(SB, {55, {100}, 0.10, {20},-10,-1})
--/endcode

global procedure setSubFields(integer pID, sequence pPartInfo)
atom lBuffer
atom lAddr
integer lRightEdge
integer lPanelCnt
object lWindowWidth

    if not validId(pID) then
        return
    end if

    if ctrl_Type[pID]!=StatusBar then
        return
    end if

    if length(pPartInfo)=0 then
        return
    end if

    lWindowWidth = getCtlSize(ctrl_Parent[pID])
    lWindowWidth = lWindowWidth[1]
    lBuffer = w32acquire_mem(0, 4*length(pPartInfo))
    if lBuffer=0 then
        return
    end if

    lRightEdge = 0
    lPanelCnt = 0
    lAddr = lBuffer
    for i=1 to length(pPartInfo) do
        if sequence(pPartInfo[i]) then
            lRightEdge += floor(pPartInfo[i][1])
        elsif pPartInfo[i]<1 then
            if pPartInfo[i]>0 then
                lRightEdge += floor(pPartInfo[i]*lWindowWidth)
            elsif pPartInfo[i]< -1 then
                lRightEdge = lWindowWidth+pPartInfo[i]
            else
                lRightEdge = -1
            end if
        else
            lRightEdge = floor(pPartInfo[i])
        end if
        poke4(lAddr, lRightEdge)
        lAddr += 4
        lPanelCnt += 1
        if lRightEdge= -1 then
            exit
        end if
    end for
    VOID = sendMessage(pID, SB_SIMPLE, 0, 0)
    VOID = sendMessage(pID, SB_SETPARTS, lPanelCnt, lBuffer)
    w32release_mem(lBuffer)
end procedure

procedure drop_monitor(integer id,integer event,sequence params)
    ctrl_Specific[id] = (event=w32HDropDown)
end procedure

-----------------------------------------------------------------------------
--/topic Defining Controls
--/func createEx( integer controlType, sequence caption, atom Owner, object Left, object Top, object Width, object Height, object flags, object exFlags )
--/desc Create an object of type /i controlType.
--/ret Control identifier.
--
-- This is the same as /create, but allows you to specify extented
-- attribute flags.

global function createEx(object pControl, sequence pCaption = "", atom pOwner = 0,
            object pLeft = 0, object pTop = 0, object pWidth = 0, object pHeight = 0,
            object styleFlags = 0, object exFlags = 0)

integer id
integer bgControl
atom hWnd, flags, extendedflags, lParenthWnd
atom szClassName, szCaption, hMenu, newhWnd, pStruct, ok
sequence args, BBox, lvcol
object sbPanels
sequence lHintText
integer iIconInfo
integer autoclose
object lBGColor
object lUserPre
object lUserPost
object lTemp
integer lControl, cloneIt

    if sequence(pControl) then
        cloneIt = pControl[1]
        pControl = Window
    else
        cloneIt = 0
    end if

    -- Check for AutoClose flag.

    autoclose = w32False
    lControl = classAlias[pControl]

    if sequence(styleFlags) then

        if equal(styleFlags, w32AUTOCLOSE) then
            autoclose = w32True
            styleFlags = 0
        else
            flags = find(w32AUTOCLOSE, styleFlags)
            if flags!=0 then
                autoclose  = w32True
                styleFlags = w32removeIndex(flags, styleFlags)
            end if
        end if
    end if

    if lControl=ListView then
        lvcol = pCaption
        pCaption = ""
        lHintText = ""

    elsif length(pCaption)=2
      and w32string(pCaption[1])
      and w32string(pCaption[2]) then

        lHintText = pCaption[2]
        pCaption = pCaption[1]

    else
        lHintText = ""
    end if

    if pOwner!=0
    and validId(pOwner)=w32False then
        abortErr(Err_OWNERINVALID)
    end if

    if sequence(vControlRID[pControl]) then
        -- User defined control might have to change the owner.
        pOwner = call_func(vControlRID[pControl][kCRID_Control], {"NewOwner", pOwner})
    end if

    if pOwner=0 then
        if lControl=MenuItem then
            pOwner = vRecent[w32RecentMenu]

        elsif lControl=MenuSpacer then
            pOwner = vRecent[w32RecentMenu]

        elsif lControl=TabItem then
            pOwner = vRecent[w32RecentTabControl]

        elsif lControl=ReBarBand then
            -- Need to find the rebar for the recent window.
            lTemp = findChildren(vRecent[w32RecentWindow])
            for i=1 to length(lTemp) do
                if lTemp[i][2]=ReBar then
                    pOwner = lTemp[i][1]
                    exit
                end if
            end for
            if pOwner=0 then
                abortErr(Err_OWNERINVALID)
            end if

        elsif find(lControl, {Window, Pixmap})=0 then
            pOwner = vRecent[w32RecentWindow]

        end if
    else
        -- Certain controls must never have an owner.
        if find(lControl,{ToolTip, Pixmap, Screen_, Printer_})  then
            pOwner = 0
        elsif lControl=Menu and ctrl_Family[pOwner]=WINDOW then
            if ctrl_Menu[pOwner]=0 then
                createMenuBar(pOwner)
            end if
            -- reparent to the menu bar
            pOwner = getMenuBar(pOwner,0)
        end if

    end if

    -- set up a new Control space
    id = NewControl(lControl, pOwner)

    -- Set the default name for this control.
    setIdName(id, pCaption)
    ctrl_ActualClass[id] = pControl

    if lControl=TabControl then
        ctrl_Specific[id] = {}
    end if

    -- If this control is tab-stoppable and the previous
    -- control is a label, then set the hotkey for this control
    -- based on the previous control's caption,
    -- otherwise set the hotkey based on the current caption.
    if vAutoFocusLabels=w32False then
        registerHotKey(id, pCaption)
    else
        if and_bits(WS_TABSTOP, classStyle[lControl]) and length(vs_PreviousControl)!=0 then
            if classType[ctrl_Type[vs_PreviousControl[1]]]=STATIC then
                registerHotKey(id, vs_PreviousControl[2])
            else
                registerHotKey(id, pCaption)
            end if
        elsif classType[lControl]!=STATIC then
            registerHotKey(id, pCaption)
        end if
    end if
    vs_PreviousControl = {id, pCaption}

    if lControl=CancelButton then
        registerHotKey(id, VK_ESCAPE)
    end if

    -- actual creation
    if sequence(vControlRID[pControl]) and vControlRID[pControl][kCRID_Create]>=0 then
        -- User defined control.
        args = {"Pre",{id,pCaption,pOwner,pLeft,pTop,pWidth,pHeight,styleFlags,exFlags}}
        lUserPre = call_func(vControlRID[pControl][kCRID_Create],args)
        if sequence(lUserPre) and length(lUserPre)=9 and lUserPre[1]=id then
            pCaption = lUserPre[2]
            pOwner = lUserPre[3]
            pLeft = lUserPre[4]
            pTop = lUserPre[5]
            pWidth = lUserPre[6]
            pHeight = lUserPre[7]
            styleFlags = lUserPre[8]
            exFlags = lUserPre[9]
        end if
    else
        -- Built in controls.
        lUserPre = {}

        if find(lControl,{StatusBar})=0 then
            BBox = convPctToPixel(id, pLeft, pTop, pWidth, pHeight)
            pLeft  = BBox[1]
            pTop  = BBox[2]
            pWidth = BBox[3]
            pHeight = BBox[4]

        elsif lControl=StatusBar then
            pLeft = 0
            pWidth = 0
            if sequence(pTop) then
                sbPanels = pTop
            else
                sbPanels = -1
            end if
            pTop = 0

            if sequence(pHeight) or (pHeight>0 and pHeight<1) then
                BBox = convPctToPixel(id, 0, 0, 0, pHeight)
                pHeight = BBox[4]
            end if
        end if
    end if

    ---- Creation ----
    if atom(lUserPre) then
    -- do nothing, custom create routine did the job
    elsif lControl=Screen_
       or lControl=Printer_ then
    -- nothing to do. Just wanted to manage it's storage.
        lUserPre = 0

    elsif lControl=Window then
        lUserPre = 0
        -- create a window
        if not cloneIt then
            createWindow(id, pCaption, pOwner, pLeft, pTop, pWidth, pHeight,styleFlags, exFlags)
        else
            createWindow({id, cloneIt}, pCaption, pOwner, pLeft, pTop, pWidth, pHeight,styleFlags, exFlags)
        end if

    elsif lControl=Menu then
        lUserPre = 0
        createMenu(id, pCaption, pOwner,styleFlags,{pLeft,pTop,pWidth,pHeight,exFlags})

    elsif lControl=Popup then
        lUserPre = 0
        -- create a popup menu
        createMenu(id, pCaption, pOwner,styleFlags,{pLeft,pTop,pWidth,pHeight,exFlags})

    elsif lControl=MenuItem then
        lUserPre = 0
        -- create a menu bar item
        createMenuItem(id,pCaption,pOwner,styleFlags,{pLeft,pTop,pWidth,pHeight,exFlags})

    elsif lControl=MenuSpacer then
        lUserPre = 0
        -- create a menu bar item
        createMenuItem(id, "-", pOwner, 0,{0,0,0,0,0})

    elsif lControl=Pixmap then
        lUserPre = 0
        -- create a pixmap item
        createPixmap(id, pWidth, pHeight)

        -- set default font
        setDefaultFont(id)
        setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])


    elsif lControl=TabItem then
        lUserPre = 0
        -- create a tab control item
        createTabItem(id, pCaption, pOwner, pLeft, exFlags)
        call_proc(r_setFocus,{id})

    elsif lControl=ImageList then
        lUserPre = 0
        if pWidth=SM_CXSMICON then
            pWidth = getSystemMetrics(SM_CXSMICON)
            pHeight = getSystemMetrics(SM_CYSMICON)
        else
            pWidth = getSystemMetrics(SM_CXICON)
            pHeight = getSystemMetrics(SM_CYICON)
        end if

        hWnd = w32Func(ImageList_Create, {pWidth, pHeight, ILC_MASK+styleFlags,1,1})
        -- save the handle with the control
        setId(hWnd, id)

        VOID = w32Func(ImageList_SetBkColor, {hWnd, CLR_NONE})
        -- save the handle in the sequence
        ctrl_Handle[id] = hWnd
        ctrl_Handle_type[id] = kht_ImageList

    elsif lControl=ReBarBand then
        lUserPre = 0
        integer fMask = w32or_all({RBBIM_ID,    
                                   RBBIM_SIZE,
                                   RBBIM_TEXT,
                                   RBBIM_STYLE}),
                fStyle = w32or_all({RBBS_CHILDEDGE,
                                    RBBS_GRIPPERALWAYS,
                                    styleFlags})
        args = {fMask,      -- fMask
                fStyle,     -- fStyle
                0,          -- clrFore
                0,          -- clrBack
                pCaption,   -- lpText
                0,          -- iImage
                0,          -- hwndChild
                0,          -- cxMinChild
                0,          -- cyMinChild
                pWidth,     -- pWidth
                0,          -- hbmBack
                id,         -- wID
                0,          -- cyChild
                0,          -- cyMaxChild
                0,          -- cyIntegral
                0,          -- cxIdeal
                0,          -- lParam
                0}          -- cxHeader
        pStruct = w32to_memory(0,ID_REBARBANDINFO,args)

        hWnd = sendMessage(pOwner, RB_INSERTBAND, -1, pStruct)

        w32release_mem(pStruct)


    elsif pOwner!=0
      and ctrl_Type[pOwner]=FlatToolBar
      and classType[lControl]=BUTTON then
        lUserPre = 0
        -- adding a button to a flat toolbar!
        ctrl_Family[id] = BUTTON
        ctrl_Hint_Text[id] = pCaption

        if length(pCaption)>0 then
            szCaption = sendMessage(pOwner, TB_ADDSTRING, 0, pCaption & 0)
        else
            -- Use "" by default.
            szCaption = -1
        end if

        pStruct = w32acquire_mem(0, SIZEOF_TBBUTTON)
        w32store(pStruct, TBBUTTON_idCommand, id)
        w32store(pStruct, TBBUTTON_dwData, id)
        w32store(pStruct, TBBUTTON_iBitmap, pLeft-1)
        w32store(pStruct, TBBUTTON_fsState, TBSTATE_ENABLED)
        w32store(pStruct, TBBUTTON_iString, szCaption)

        styleFlags = w32or_all({styleFlags, classStyle[lControl]})

        w32store(pStruct, TBBUTTON_fsStyle, styleFlags)

        ok = sendMessage(pOwner, TB_ADDBUTTONS, 1, pStruct)

        w32release_mem(pStruct)

        if not ok then
            warnErr(Err_FLATTOOLBARBTN)
        end if
    end if

    if sequence(lUserPre) then
        -- Use standard (built-in) creation processing --

        -- create C string for lControl name
        szClassName = w32acquire_mem(0, className[lControl])

        -- create C string for caption and link with ClassName
        szCaption = w32acquire_mem(szClassName, pCaption)

        -- user supplied flags
        if and_bits(classAttr[lControl], w32PictCtrl)=0 then

            if atom(styleFlags) then
             -- combine with user's values
                flags = or_bits(classStyle[pControl], styleFlags)
            else
             -- replace with user's values
                flags = w32or_all(styleFlags)
            end if
        else
            -- 'cos styleFlags is really a DIB handle
            flags = classStyle[lControl]

            if find(lControl, {PictureButton, TogglePicture}) then
                if equal(styleFlags, w32PB_BITMAP) or equal(styleFlags,0) then
                    flags = or_bits(flags, BS_BITMAP)
                    styleFlags = 0

                elsif equal(styleFlags, w32PB_ICON) then
                    flags = or_bits(flags, BS_ICON)
                    styleFlags = 0

                elsif w32string(styleFlags) then
                    if (match(".ICO", upper(styleFlags))!=0 or
                        equal("ICON", upper(styleFlags))) then
                        flags = or_bits(flags, BS_ICON)
                    else
                        flags = or_bits(flags, BS_BITMAP)
                    end if
                elsif atom(styleFlags) then
                    ok = w32Func(xGetObjectType, {styleFlags})
                    if ok=0 then
                        flags = or_bits(flags, BS_ICON)

                    elsif ok=OBJ_BITMAP then
                        flags = or_bits(flags, BS_BITMAP)

                    else
                        warnErr("The image used to create a picture button\nis not an ICON or a BITMAP")
                        styleFlags = 0
                    end if
                else
                    warnErr("The image used to create a picture button\nis not valid")
                    styleFlags = 0
                end if
            end if
        end if

        -- extended flags
        if atom(exFlags) then
            extendedflags = or_bits(classStyleEx[lControl], exFlags)
        else
            extendedflags = w32or_all(exFlags)
        end if

        -- Some controls interpret hMenu differently
        if and_bits(w32OwnerId, classAttr[lControl])!=0 then
            -- identifier of parent
            hMenu = pOwner
        else
            -- null
            hMenu = NULL
        end if

        -- create control
        if and_bits(w32Virtual, classAttr[lControl])!=0 then
            lParenthWnd = getHandle(findParent(pOwner))
        else
            lParenthWnd = getHandle(pOwner)
        end if

        hWnd = w32Func(xCreateWindow, {
                                       extendedflags,           -- extended style
                                       szClassName,         -- window class name
                                       szCaption,               -- window caption
                                       flags,                   -- window style
                                       pLeft, pTop,         -- initial pLeft, pTop position
                                       pWidth, pHeight,     -- initial pLeft, pTop size
                                       lParenthWnd,         -- parent window handle
                                       hMenu,                   -- window menu handle
                                       instance(),          -- program instance handle
                                       NULL})               -- creation parameters

        w32release_mem(szClassName)

        -- associate id with hWnd
        -- Changed CChris <oedoc@free.fr> Oct 26, 2006
        -- Not using subClassControl() any longer here, because an user might use the undocumented way the routine was called unwittingly.
        if hWnd<=0 then
            abortErr(Err_CREATECONTROL)
        end if
        ctrl_Handle[id] = hWnd
        setId(hWnd,id)
        -- record the processing routine
        ctrl_Function[id] = w32Func(xSetWindowLong,{hWnd,GWL_WndProc,SubProcAddress})

        -- save tab order with owner if the attribute is tab stop
        if and_bits(WS_TABSTOP, flags) and pOwner!=0 then
            -- add to the owner's focus_order list
            ctrl_Focus_order[pOwner] &= id
        end if

        -- picture control that's not in a flattoolbar?
        if   and_bits(classAttr[lControl], w32PictCtrl)!=0 then
            if ctrl_Type[pOwner]!=FlatToolBar
               and not equal(styleFlags,0) then
                -- need to load image?
                setBitmap(id, styleFlags)
            end if

        end if

        -- Set the new control's background color.
        -- If the control's bg color is -1 then it is "transparent" and
        -- takes on whatever its parent's bg color is.
        if pOwner!=0 and equal(classBGColor[lControl], w32BGTransparent) then
            lBGColor = ctrl_Bg_Color[pOwner]
            while equal(lBGColor, w32BGTransparent) do
                bgControl = getParent(pOwner)
                if bgControl=0 then
                    lBGColor = classBGColor[lControl]
                    exit
                end if
                lBGColor = ctrl_Bg_Color[bgControl]
            end while
        else
            lBGColor = classBGColor[lControl]
        end if

        setBackground(id, sequence(lBGColor),lBGColor)

        -- set default font
        setDefaultFont(id)
    end if

    ----- Post Creation ----
    if length(lHintText)>0 then
        call_proc(r_setHintEx,{id, lHintText, 0})
    end if

-- added CChris <oedoc@free.fr> Oct 26, 2006
-- set logical visibility according to style flags
    if sequence(lUserPre) and not and_bits(flags,WS_VISIBLE) then
        ctrl_Visible[id] = w32False
    end if
    if lControl=ReBarBand then
        ctrl_Visible[id] = not and_bits(styleFlags,RBBS_HIDDEN)
    end if


    if sequence(vControlRID[pControl]) and vControlRID[pControl][kCRID_Create]!= -1 then
        -- User defined control
        lUserPost = call_func(vControlRID[pControl][kCRID_Create], {"Post", {id}})
        if sequence(lUserPost) and lUserPost[1]=id then
            if find(lUserPost[2], {w32RecentMenu, w32RecentTabControl, w32RecentWindow})!=0 then
                vRecent[lUserPost[2]] = id
            end if
        end if
    else
        -- Built in controls.
        if sequence(lUserPre) then
            -- Standard create used.

            if lControl=CancelButton then
                setFont(id, FontDefaults[1],FontDefaults[2],Italic)
            else
                setFont(id, FontDefaults[1],FontDefaults[2],FontDefaults[3])
            end if

            if lControl=TabControl then
                vRecent[w32RecentTabControl] = id

            elsif lControl=Group then
                vRecent[w32RecentWindow] = id

            end if
        end if

        -- Ensure that toolbars have at least one 'string'
        if find(lControl, {FlatToolBar, ToolBar}) then
            VOID = sendMessage(id, TB_ADDSTRING, 0, {0})
            -- Set default bitmap and button sizes
            lTemp = w32pack_word(w32Func(xGetSystemMetrics,{SM_CXICON}),
                                 w32Func(xGetSystemMetrics,{SM_CYICON}))

            VOID = sendMessage(id, TB_SETBUTTONSIZE, 0, lTemp)
            VOID = sendMessage(id, TB_SETBITMAPSIZE, 0, lTemp)
        end if

        -- track as children, since they need to resize
        if lControl=StatusBar then

            if sequence(sbPanels) then
                setSubFields(id, sbPanels)
            end if
            if pHeight>0 then
                VOID = sendMessage(id, SB_SETMINHEIGHT, pHeight, 0)
            end if

        elsif lControl=ToolTip then
            if tooltipControl!=0 then
                VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 0, 0)
            end if

            tooltipControl = id
            VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 1, 0)

        elsif lControl=TreeView then
            if not ILlarge then
                ILlarge = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,ILC_COLOR8,0)
                ILsmall = createEx(ImageList, "", 0, 0,0,SM_CXSMICON,0,ILC_COLOR8,0)
                hILlarge = ctrl_Handle[ILlarge]
                hILsmall = ctrl_Handle[ILsmall]
            end if

            setImageList(id, ILsmall, TVSIL_NORMAL)
            -- Haven't set State icons

            tv_id &= id


        elsif lControl=FlatToolBar then

            VOID = sendMessage(id, TB_BUTTONSTRUCTSIZE, SIZEOF_TBBUTTON, 0)

            if himlFTBDefault=0 then
                -- Need to create imagelists

                himlFTBDefault = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,ILC_COLOR8,0)
                himlFTBHot = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,ILC_COLOR8,0)
                himlFTBDisabled = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,ILC_COLOR8,0)

            end if

            if not tooltipControl then
                tooltipControl = createEx(ToolTip, "", 0, 0, 0, 0, 0, 0, 0)
            end if

            VOID = sendMessage(id, TB_SETTOOLTIPS, 0, getHandle(tooltipControl))

            -- Set image lists for the 3 states
            VOID = sendMessage(id, TB_SETIMAGELIST, 0, getHandle(himlFTBDefault))
            VOID = sendMessage(id, TB_SETHOTIMAGELIST, 0, getHandle(himlFTBHot))
            VOID = sendMessage(id, TB_SETDISABLEDIMAGELIST, 0 ,getHandle(himlFTBDisabled))
            ctrl_ImageList[id] = himlFTBDefault
        elsif lControl=ComboBoxEx then

            if not ILlarge then
                ILlarge = createEx(ImageList, "", 0, 0,0,SM_CXICON,0,ILC_COLOR8,0)
                ILsmall = createEx(ImageList, "", 0, 0,0,SM_CXSMICON,0,ILC_COLOR8,0)
                hILlarge = ctrl_Handle[ILlarge]
                hILsmall = ctrl_Handle[ILsmall]
            end if

            VOID = sendMessage(id, CBEM_SETIMAGELIST, 0, hILsmall)
            ctrl_ImageList[id] = hILsmall
        elsif lControl=Bitmap then
            if match(".BMP", upper(pCaption))=(length(pCaption)-3) then
                setBitmap(id, pCaption)
            end if

        elsif lControl=Icon then
            iIconInfo = 0
            if length(pCaption)=2 and integer(pCaption[2]) and pCaption[2]>0 then
                iIconInfo = pCaption[2]
            end if
            if iIconInfo or match(".ICO", upper(pCaption))=(length(pCaption)-3) then
                setIcon(id, pCaption)
            end if

        elsif lControl=ListView then
            handleLV(id,or_bits(classStyle[lControl],styleFlags),lvcol)

        end if

        -- See if I have to subclass this control.
        if ctrl_Family[id]=COMBO or
           equal(className[lControl], WC_COMBOBOXEX) then

            newhWnd = w32Func(xGetWindow,{hWnd, GW_CHILD})
            VOID = subClassControl({EditText,id}, newhWnd)
            if length(lHintText)>0 then
                call_proc(r_setHintEx,{id, lHintText, 0})
            end if
        end if

    end if

    if autoclose then
        setHandler(id, w32HClick, r_autoclose)
    end if

    if ctrl_Type[id]=RichEdit then
        VOID = sendMessage(id,EM_EXLIMITTEXT,0,#FFFFFFFF)
    end if

    if ctrl_Family[id]=COMBO or ctrl_Type[id]=ComboBoxEx then
        setHandler(id,{w32HDropDown,w32HCloseUp},routine_id("drop_monitor"))
        VOID = setHandlerProtection(id,w32HDropDown,w32protectTrailing)
        VOID = setHandlerProtection(id,w32HCloseUp,w32protectTrailing)
    end if

    return id

end function
r_createEx = routine_id("createEx")
include w32xpm.ew
r_xpmToEuBmp = w32routine_id("xpmToEuBmp")

-----------------------------------------------------------------------------
--/topic Defining Controls
--/func create( pControl, title, parent, x, y, cx, cy, flags )
--/desc Create an object of type /i pControl.
--/ret Control identifier.
--
-- The /i title is the text that will appear in the object's caption. It can be
-- a single string or a sequence of two strings. In this later form, the first
-- string is the caption text, and the second is the tooltip text. /n
-- /n Note for /Bitmap or /Icon controls, the caption can also be the name of a bitmap
-- (.BMP) or icon (.ICO) file. In this case, it will be automatically loaded into the
-- Bitmap control and placed in RAM until the program ends.
--
-- /i x and /i y specify the position of the object, and /i cx and
-- /cy specify the width and height.
--
-- You can specify additional attributes by passing them in the /i flags
-- parameter. If /i flags is an atom, then these are combined with the
-- default style flags for the control class. If /i flags is a sequence of
-- flags, then they replace the default style flags.
--
-- The /i flags parameter is used differently for /PictureButton and /TogglePicture
-- controls. In this case, it can be the name of a bitmap (.BMP) or an icon (.ICO) file
-- which causes that image to be displayed on the button face. Alternatively, you can
-- pass the handle of bitmap or icon in the flags parameter. This technique is useful
-- if you have preloaded images from files and intend to reuse them. Once the type
-- of image, bitmap or icon, is determined for the control, you cannot change
-- it to the other type. For icons, you can specify the caption as {filename,icon_index}.
--
-- Note that if the /i flags parameter contains the flag 'w32AUTOCLOSE', the
-- control's click event will close its parent window.
--
-- /b Returns: The value returned is the /i id of the control. This is
-- typically the first parameter expected in Win32Lib functions.
--
-- The parent of the main window is 0.
--
-- If you don't care about the positioning of a window, you can
-- use the parameter /b Default, and Windows will automatically
-- position the window.
--
-- /b Note: for windows, the size specified by /i cx, /i cy is
-- the /i total size of the window, not the size of the client area.
-- After creating a Window, you can use /setClientRect to give an exact
-- client area size.
--
-- If you wish a window to share the background and menu bar of another automatically,  pass {id} 
-- as first argument, where /i id is the ID of the base window. This link can never be broken.
--
-- /b Note: The /i x and /i y values are relative to the parent's client area. For tab controls, 
-- this is the whole area of the control, including the tabs themselves, so you'll usually want 
-- to use values of y not less than 30 (the exact figure depends on the font being used).
--
-- Each dimension for /i x, /i y, /i cx, and /i cy can be expressed as either... /n
-- a) an integer >= 0, in which case it is not touched. /n
--     eg.  50 (= 50 pixels) /n
-- b) an atom in the range > 0 and ~< 1, which is taken to be a %
--    of the control's parent dimension. /n
--     eg.  0.50 (= 50% of parent's size) /n
-- c) The constant /i w32Edge which signifies the parent's extreme
--    client edge for the dimension. That is, either the rightmost or
--    bottom most edge, as appropriate. /n
-- d) a sequence of two elements, the first as in (b) or (c) above, and
--    the other a pixel offset. The offset is added after converting. /n
--     eg.  {0.50, -3} ( = 50% of parent size less 3 pixels) /n
--     eq   (w32Edge, -10} ( = right/bottom pixel less 10 pixels) /n
-- e) a sequence of three elements, the first two as in (d), and
--    the other a two-element sequence containing the minimum and
--    maximum allowable values. These can be a percentage or a
--    pixel amount. /n
--     eg.  {0.50, -3, {20, 300}} ( = 50% of parent size less
--            3 pixels, and a minimum of 20 pixels and a
--            maximum of 300 pixels) /n
--
-- NOTE: specifying size or position relative to the paent or another control enables 
-- their being figured out when the parent window opens. The controls won't resize until 
-- you take appropriate steps for them to do so. The various bars are an exception to this rule.
--
-- However, for /StatusBar controls, the /i x and /i cx values are ignored,
-- as a statusbar is always aligned to the bottom left edge of a window.
-- Also for /StatusBar controls, the /i y can be used to define subPanels
-- in the bar. See /setSubFields for details.
--
-- For /b Menus , if the /i title contains a '!' character, a /b Command menu
-- is created rather than a /b Popup menu. The difference is that a Command menu
-- reacts immediately to being clicked, while a Popup menu will display its
-- menu items instead. /n
-- /b "Note 1:" This type of menu will not be allowed
-- to contain MenuItems. The reason being that when you click on the menu
-- a w32HClick event is generated and any items are never shown. /n
-- /b "Note 2:" The '!' character is stripped out of the title before displaying
-- it on screen. /n
-- For Menu, Popup, MenuItem and MenuSpacer controls, the position, size and extended flags are interpreted as follows:
--/li /b x: insertion point. This may be any of
--<ul>
--<li>MP_BEFORE: /b y is the id of the item before which to insert;
--<li>MP_AT: /b y is the 1-based position at which to insert;
--<li>MP_AFTER: /b y is the id of the item after which to insert;
--<li>MP_END: insert at end, /b y is ignored.
--</ul>
--/li /b cx is the handle to the unchecked mark bitmap;
--/li /b cy is the handle to the checked mark bitmap;
--/li exFlags is the handle to the displayed bitmap.
--
-- For ListView controls, the caption is interpretated as a sequence of formatting hints, one for each column.
-- The complete form of a hint is a triple {title,width,alignment} as in /setLVColumnHeadings().
-- Sensible defaults are used when the hint is not complete. Passing a single string is equivalent
-- to {{that string}}, and {number} is treated as {{"",that number}}.
--
-- For tab items, the /b x parameter is the 1 based position at which to insert (use 0
-- to insert at end), and exFlags is the index of an image in the common image list. /n
--Examples:
--/code
--      -- create a window
--      --  The following will create a /Window called /b MyWindow:
--      constant MyWindow = create( Window,         -- the pControl
--                          "My Window",        -- the caption
--                          0,                  -- the parent
--                          Default, Default,   -- x and y position
--                          0.5,                -- 50% of the screen width
--                          40,                 -- 40 pixels high
--                          0 )                 -- no special flags
--
--      constant MsgWindow = create( Window,         -- the pControl
--                          "Messages",        -- the caption
--                          0,                  -- the parent
--                          Default, Default,   -- x and y position
--                          200,                -- 200 pixels wide
--                          200,                -- 200 pixels high
--                          {WS_DLGFRAME,
--                           WS_SYSMENU,
--                           WS_MINIMIZEBOX
--                           } )-- replacement flags
--/endcode
--
-- The following will create a /PushButton in /b MyWindow:
--/code
--      -- create a pushbutton
--      constant MyButton = create(
--                              PushButton,         -- the pControl
--                              {"Push Me!",        -- the caption
--                               "Go on, have a go!"}, -- the tooltip text
--                              MyWindow,           -- the parent
--                              10, 10,             -- x and y position
--                              60, 40,             -- width and height
--                              0 )                 -- no special flags
--/endcode
--
-- The following will create a /Bitmap in /b MyWindow:
--/code
--      -- create a bitmap
--      constant BM1 = create(
--                              Bitmap,         -- the pControl
--                              "images\\logo.bmp", -- the file to display
--                              MyWindow,           -- the parent
--                              10, 90,             -- x and y position
--                              60, 40,             -- width and height
--                              0 )                 -- no special flags
--/endcode
--
-- The different classes of objects are:
-- /li /Bitmap: static bitmap
-- /li /CheckBox: check box
-- /li /Combo: combo box - has edit box and drop down list (aka ComboBox)
-- /li /ComboBoxEx: Combo with images
-- /li /CText: static text lable, center justified
-- /li /DefPushButton: default push button
-- /li /DropDownList: drop down list, non-editable
-- /li /EditText: edit text (aka EditBox, TextBox, SleText)
-- /li /FlatToolBar: like a toolbar, only flat
-- /li /Group: group box  (aka GroupBox)
-- /li /HScroll: horizontal scroll bar
-- /li /HTrackBar: horizontal track bar
-- /li /Icon: static icon
-- /li /ImageList: A storage container for images.
-- /li /List: list with scroll bar (aka ListBox)
-- /li /ListView: list with icons, labels and columns
-- /li /LText: left justified static label
-- /li /Menu: menu bar item
-- /li /MenuItem: dropdown menu item
-- /li /MenuSpacer: Horizontal line in a menu.
-- /li /MleText: multiple line text edit
-- /li /MonthCalendar: select dates
-- /li /PictureButton: push button with graphic
-- /li /Pixmap: off-screen color bitmap
-- /li /Popup: a pop up menu
-- /li /ProgressBar: shows task completion state
-- /li /PushButton: push button (aka Button, CommandButton)
-- /li /Radio: radio button (aka RadioButton)
-- /li /ReBar: advanced toolbars
-- /li /ReBarBand: Rebar divider for grouping controls
-- /li /RichEdit: text edit with formatting
-- /li /RText: right-justified static text label
-- /li /SepButton: divider on FlatToolBars
-- /li /SimpleCombo: combo box, no drop down list
-- /li /SortedCombo: combo box, with sorted list
-- /li /SortedList: list, with sorted elements
-- /li /StatusBar: control for status text
-- /li /TabControl: control containing tab items
-- /li /TabItem: control item in /TabControl
-- /li /ToggleButton: push button that toggles off and on
-- /li /TogglePicture: toggle button with picture
-- /li /ToolBar: control for placing other controls into
-- /li /ToolTip: A group of tooltips with all the same style.
-- /li /TreeView: hierarchical list
-- /li /TriCheckBox: 3 state check box
-- /li /UpDown: increment/decrement control
-- /li /VScroll: vertical scroll bar
-- /li /VTrackBar: vertical track bar
-- /li /Window: window
global function create(integer pControl, sequence caption = "", atom pOwner = 0,
            object x = 0, object y = 0, object cx = 0, object cy = 0,
            object styleFlags = 0)
    -- create with no extended style flags
    return createEx(pControl, caption, pOwner, x, y, cx, cy, styleFlags, 0)

end function

w32ControlNames = {
                   "WINDOW",
                   "PUSHBUTTON",
                   "COMMANDBUTTON",
                   "BUTTON",
                   "DEFPUSHBUTTON",
                   "DEFBUTTON",
                   "CANCELBUTTON",
                   "CHECKBOX",
                   "TRICHECKBOX",
                   "RADIO",
                   "RADIOBUTTON",
                   "GROUP",
                   "GROUPBOX",
                   "LIST",
                   "LISTBOX",
                   "SORTEDLIST",
                   "COMBO",
                   "COMBOBOX",
                   "SORTEDCOMBO",
                   "SIMPLECOMBO",
                   "DROPDOWNLIST",
                   "EDITTEXT",
                   "EDITBOX",
                   "TEXTBOX",
                   "SLETEXT",
                   "MLETEXT",
                   "LTEXT",
                   "LABEL",
                   "RTEXT",
                   "CTEXT",
                   "HSCROLL",
                   "VSCROLL",
                   "ICON",
                   "BITMAP",
                   "MENU",
                   "POPUP",
                   "MENUITEM",
                   "MENUSPACER",
                   "PIXMAP",
                   "TOOLBAR",
                   "STATUSBAR",
                   "PICTUREBUTTON",
                   "TOGGLEBUTTON",
                   "TOGGLEPICTURE",
                   "HTRACKBAR",
                   "VTRACKBAR",
                   "TABCONTROL",
                   "TABITEM",
                   "PROGRESSBAR",
                   "LISTVIEW",
                   "IMAGELIST",
                   "TREEVIEW",
                   "RICHEDIT",
                   "MONTHCALENDAR",
                   "UPDOWN",
                   "REBAR",
                   "REBARBAND",
                   "TOOLTIP",
                   "FLATTOOLBAR",
                   "SEPBUTTON",
                   "COMBOBOXEX"
                  }

w32ControlTypes = {
                   Window,
                   PushButton,
                   CommandButton,
                   Button,
                   DefPushButton,
                   DefButton,
                   CancelButton,
                   CheckBox,
                   TriCheckBox,
                   Radio,
                   RadioButton,
                   Group,
                   GroupBox,
                   List,
                   ListBox,
                   SortedList,
                   Combo,
                   ComboBox,
                   SortedCombo,
                   SimpleCombo,
                   DropDownList,
                   EditText,
                   EditBox,
                   TextBox,
                   SleText,
                   MleText,
                   LText,
                   Label,
                   RText,
                   CText,
                   HScroll,
                   VScroll,
                   Icon,
                   Bitmap,
                   Menu,
                   Popup,
                   MenuItem,
                   MenuSpacer,
                   Pixmap,
                   ToolBar,
                   StatusBar,
                   PictureButton,
                   ToggleButton,
                   TogglePicture,
                   HTrackBar,
                   VTrackBar,
                   TabControl,
                   TabItem,
                   ProgressBar,
                   ListView,
                   ImageList,
                   TreeView,
                   RichEdit,
                   MonthCalendar,
                   UpDown,
                   ReBar,
                   ReBarBand,
                   ToolTip,
                   FlatToolBar,
                   SepButton,
                   ComboBoxEx
                  }
vControlRID = repeat(0, length(w32ControlNames))


function parseImage(object image)
-- retrieves an image from a string and reurns either the string or an image index
integer pos,pos2,filetype,index
sequence v
atom hImg

    pos = find('.',image)
    if pos then
        pos2 = find(',',image)
        if not pos2 then
            pos2 = length(image)+1
        end if
        filetype = find(upper(w32trim(image[pos+1..pos2-1])),{"BMP","ICO"})
        if filetype then
            index = 0
            if filetype=2 and pos2<length(image) then -- index
                v = value(image[pos2+1..length(image)])
                if v[1]=GET_SUCCESS then
                    index = v[2]
                end if
            end if
            if filetype=1 then
                hImg = loadBitmapFromFile(image[1..pos2-1])
            elsif not index then
                hImg = loadIconFromFile(image[1..pos2-1])
            else
                hImg = loadIconFromFile({image[1..pos2-1],index})
            end if
            if hImg then
                if filetype=1 then
                    return addDIB(hImg)
                else
                    return addIcon(hImg)
                end if
            end if
        end if
    end if
    return image
end function

--/topic Attributes
--/func setTabImage(integer id,object image)
--/desc Possibly sets the image associated to a tab item and returns index of previous one.
-- If /i image is an integer, it is an index into the common image list, as returned by
-- /addIcon() or /addDIB().
-- If it is a sequence, it is a filename string possibly followed by a comma and the
-- litteral representation of the icon index. The bitmap or icon will be loaded into
-- the common image list.
-- If /i image is "", then no attempt to set the image is made.
-- If /i image is 0, there will be no image associated with /i id.
-- If /i id is not a TabItem, -1 is returned; otherwise, the previous image index is returned (0 for no image).

global function setTabImage(integer id,object image)

integer index,oldVal,parent
atom item

-- test for valid request and set some helper variables
    if ctrl_Type[id]!=TabItem then
        return -1
    else
        parent = ctrl_Parent[id]
        index = find(id,ctrl_Specific[parent])
        if not index then
            return -1
        end if
    end if

    if sequence(image) and length(image) then
    -- convert it to an index into the common image list
        image = parseImage(image)
    end if

    -- get current image for item
    item = w32acquire_mem(0,SIZEOF_TC_ITEM)
    w32store(item,TC_ITEM_mask,TCIF_IMAGE)
    VOID = sendMessage(parent,TCM_GETITEM,index,item)
    oldVal = w32fetch(item,TC_ITEM_iImage)+1

    if integer(image) then
        -- set new image (perhaps to -1)
        if ctrl_ImageList[id]!=hILsmall then
            image = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[image]})
        else
            image -= 1
        end if
        w32store(item,TC_ITEM_iImage,image)
        VOID = sendMessage(parent,TCM_SETITEM,index,item)
    end if
    w32release_mem(item)
    return oldVal
end function

--/topic Values
--/proc showMessage( sequence Message )
--/desc Displays /i Message in a Statusbar
--/i pText is the text string which is displayed in the first (or only) panel of the
-- status bar which is on the main window. /n
--
-- It is possible to display it on a different status bar by using the format
-- { Message, pID }, where /i pID is either a Window id, which has a status bar, or
-- an actual status bar control id. /n
-- If you wish to display the message in a panel other than the first panel, the
-- /i pID has the format {id, panel#} /n
--
--In any case, if the /i pID is zero, the application's main window is assumed.
--
-- Example:
--
--/code
--      -- Show the caption of status bar in the main window
--      showMessage( "Ready" )
--      -- To display a message in another window:
--      showMessage( {"Searching...", EditWindow} )
--      -- If the statusbar has subfields, you can specify them like:
--      showMessage( {"2nd subField", {EditWindow,2}} )
--/endcode

-- Changed CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: specifying a window without a status bar would add a status bar to the main window.
-- Bug fix: if the supplied id had not a Window as parent, its parent window would not be queried for a status bar
global procedure showMessage(sequence pMsg)
integer lPanel
object id,win_id,win_implicit
sequence lSizeA
sequence lSizeB

    lPanel = 0
    win_implicit = 0
    if length(pMsg)=2 and sequence(pMsg[1]) then
        id = pMsg[2]
        pMsg = pMsg[1]
        if sequence(id) then
            lPanel = id[2]
            id = id[1]
        end if
    else
        win_implicit = 1
    end if


    if win_implicit or not validId(id) then
        win_id = mainWindow
        id = ctrl_Statusbar[mainWindow]
    elsif ctrl_Type[id]!=StatusBar then
        if ctrl_Type[id]=Window then
            win_id = id
        else
            win_id = findParentWindow(id)
        end if
        id = ctrl_Statusbar[win_id]
    else
    -- we already have a status bar, and win_id will not be inspected
    end if

    if id=0 then
    -- The window has no status bar, add one
        lSizeA = call_func(r_getRect,{win_id})
        id = createEx(StatusBar, "", win_id, 0, 0, 0, 0, 0, 0)
        lSizeB = call_func(r_getRect,{id})
        call_proc(r_setRect,{win_id, lSizeA[1], lSizeA[2], lSizeA[3]-lSizeA[1],
                             lSizeA[4]+lSizeB[4]-lSizeA[2]-lSizeB[2], 1})
    end if
    if id then
        if lPanel!=0 then
            id = {id, lPanel}
        end if
        call_proc(r_setText,{id, pMsg})
    else  -- could not create the status bar, though there wasn't one
        warnErr("Could not display this in the message area: " & pMsg)
    end if
end procedure
constant r_releaseResourcesForID = w32routine_id("releaseResourcesForID")

-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- DESTROYING CONTROLS
--
-----------------------------------------------------------------------------
--/topic Attributes
--/proc destroy( id )
--/desc Destroy an object created with the /create function.
-- When a control is destroyed, it releases its resources back to
-- Windows. This also means that a /i parent control also destroys
-- its child controls.
--
-- When the control being destroyed is a Window, it cannot be reopened.
-- If you want to be able to reopen a window, use /closeWindow() instead
-- of /destroy().
--
-- When this is called, but before the control is actually destroyed,
-- the /w32HDestroy event is triggered, enabling you to clean up things
-- associated with this control. Or even prevent the control from
-- being destroyed, by returning -1 from the event handler.
--
-- The following will destroy a pushbutton called /i MyButton.
--
--/code
--      -- destroy a pushbutton
--      destroy( MyButton )
--/endcode
--

-- begin mwl 2/10/04
-- delayed destruction:
sequence vDestroyQueue
vDestroyQueue = {}

-- This is called to do the actual destruction of a control.
procedure fDoDestruction(integer id)
-- Destroy the requested item.

-- It is safe to assume that all children of this control
-- have already been destroyed before this is called.

integer family, parent, lIdx
atom handle
--  object rc
--  sequence parenttabs
--  sequence lChildren
integer tabnumber
object lUserResponse
object lTemp
integer sharedclass

    lTemp = ctrl_Type[id]
    lTemp = vControlRID[lTemp]
    if sequence(lTemp) and (lTemp[kCRID_Destroy]>=0) then
        lUserResponse = call_func(lTemp[kCRID_Destroy], {"Destroy", {id}})
    else
        lUserResponse = 0
    end if

    if equal(lUserResponse,0) then
        -- get class and parent
        family = ctrl_Family[id]
        parent = findParent(id)

        if ctrl_Type[id]=TabItem then
            ctrl_Group[id] = {}

            -- remove from tab list
            tabnumber = find(id, ctrl_Specific[parent])
            VOID = sendMessage(parent, TCM_DELETEITEM, tabnumber-1, 0)
            ctrl_Specific[parent] = w32removeItem(id, ctrl_Specific[parent])

            -- Set focus to next tabitem
            if tabnumber>length(ctrl_Specific[parent]) then
                tabnumber = length(ctrl_Specific[parent])
            end if
            if tabnumber!=0 then
                call_proc(r_setFocus,{ctrl_Specific[parent][tabnumber]})
            end if

        elsif family=WINDOW then
            -- destroy window
            sharedclass = find(ctrl_ClassAddr[id],sharedClasses)
            VOID = w32Func(xDestroyWindow, {ctrl_Handle[id]})
            if sharedclass then
                sharedClassCount[sharedclass] -= 1
            end if
            if ctrl_ClassAddr[id]!=0 then
                if not sharedclass or sharedClassCount[sharedclass]=0 then
                    VOID = w32Func(xUnregisterClass, {ctrl_ClassAddr[id], instance()})
                    w32release_mem(ctrl_ClassAddr[id])
                    ctrl_ClassAddr[id] = 0
                end if
            end if

        elsif parent!=0
          and ctrl_Type[parent]=FlatToolBar then
            handle = sendMessage(parent, TB_COMMANDTOINDEX, id, 0)
            VOID = sendMessage(parent, TB_DELETEBUTTON, handle, 0)

        elsif find(family,{COMMON_CONTROL,BUTTON,COMBO,EDIT,LISTBOX,SCROLLBAR,STATIC}) then
            -- destroy control
            VOID = w32Func(xDestroyWindow, {ctrl_Handle[id]})

        elsif family=PIXMAP then
            deleteObject(ctrl_Handle[id])

        -- changed CC: ctrl_Menu may hold the handle for the menu bar only.
        -- And the OS takes care of destroying it.
        elsif find(family,{MENU, MENUITEM}) and ctrl_Family[ctrl_Parent[id]]=MENU then
            -- delete from parent
            if not removeMenu(ctrl_Parent[id],id,MF_BYPOSITION,0) then
                abortErr(Err_DESTROYMENU)
            end if

        else
            -- no special processing.
        end if

        -- mark as destroyed
        if ctrl_Type[id]=ListView then
            lIdx = find(id, lv_id)
            if lIdx then
                lv_id = w32removeItem(id, lv_id)
                lv_properties = w32removeIndex(lIdx,lv_properties)
            end if
            for i=1 to length(lvitem_owner) do
                if lvitem_owner[i]=id then
                    lvitem_owner[i] = -1
                end if
            end for
        end if

    end if

    call_proc(r_releaseResourcesForID,{id})

    ctrl_Destroyed[id] = -1  -- Destruction completed.
    ctrl_Handle[id] = -1
    ctrl_Handle_type[id] = -1
    ctrl_Mousetrap[id] = 0  -- Delete all mousetraps for this window.
    ctlblk_freelist = id & ctlblk_freelist
    ctrl_Group[id] = {}


    ------- Remove destroyed control from ...
    if parent!=0 then

        -- parent's tabbed items.
        ctrl_Focus_order[parent] = w32removeItem(id, ctrl_Focus_order[parent])
        -- parent's group items.
        ctrl_Group[parent] = w32removeItem(id, ctrl_Group[parent])

    end if

    -- Treeview ids
    if ctrl_Type[id]=TreeView then
        tv_id = w32removeItem(id, tv_id)
        for i=1 to length(tvitem_owner) do
            if tvitem_owner[i]=id then
                tvitem_owner[i] = -1
            end if
        end for
    end if

    -- Form ids
    vRecent[w32RecentForms] = w32removeItem(id, vRecent[w32RecentForms])

    deleteObject(ctrl_Bg_Brush[id])
end procedure

global procedure destroy(integer id)

-- destroy the requested item
object rc
sequence lChildren

-- Ignore bad control ids or subclassed controls.
    if not validId(id) or ctrl_FormerId[id]>0 then
        return
    end if

    rc = 0
    if ctrl_Destroyed[id]=0 then
        -- destroy routine?
        rc = invokeHandler(id, w32HDestroy, {})
        if sequence(rc) and not equal(rc[1], 0) then
            -- ignore the destroy order.
            vDestroyQueue  = {}
            return
        end if

        if ctrl_Type[id]=Window then

            ctrl_Destroyed[id] = 2 -- Destruction requested.
            -- First try to close the window.
            rc = sendMessage(id, WM_CLOSE, 0, 0)
            if not equal(rc,0) or ctrl_Closed[id]=0 then
                -- ignore the destroy order.
                ctrl_Destroyed[id] = 0 -- Destruction denied.
                return
            end if
            -- See if closing the window also destroyed it.
            if ctrl_Destroyed[id]= -1 then
                return
            end if
        end if

    end if

    if find(id, vDestroyQueue)=0 then
        vDestroyQueue &= id
    end if

    if sequence(rc) and not equal(rc[1],0) then
        -- ignore destroy order
        for dq=1 to length(vDestroyQueue) do
            ctrl_Destroyed[vDestroyQueue[dq]] = 0
        end for


        vDestroyQueue = {}
        return
    end if


    lChildren = findChildren(id)
    for i=length(lChildren) to 1 by -1 do
        destroy(lChildren[i][1])
        if length(vDestroyQueue)=0 then
            exit
        end if
    end for

    -- Only really destroy things if the current id is at the head of the queue.
    if length(vDestroyQueue)>0 and vDestroyQueue[1]=id then

        -- keep any events from being triggered
        -- by clearing all event handlers for
        -- each control being destroyed.
        for i=1 to length(vDestroyQueue) do
            ctrl_Handlers[vDestroyQueue[i]] =
                repeat({}, length(ctrl_Handlers[vDestroyQueue[i]]))
        end for

        -- Process the queue in reverse order
        -- so that owned controls get destroyed before
        -- their owner does.
        for dq=length(vDestroyQueue) to 1 by -1 do
            id = vDestroyQueue[dq]

            -- Do not do bad control ids.
            if validId(id) then
                fDoDestruction(id)
            end if

        end for
        vDestroyQueue = {}
    end if


end procedure
r_destroy = routine_id("destroy")


-----------------------------------------------------------------------------
-- SCREEN DISPLAY
--

-----------------------------------------------------------------------------
--/topic Fonts
--/proc setPenPos( window, x, y )
--/desc Position the text pen in /i window.
-- Example:
--
--/code
--      -- move the pen
--      /setPenPos( MyWindow, 10, 10 )
--
--      -- display message
--      /wPuts( MyWindow, "This is at {10,10}" )
--/endcode

global procedure setPenPos(integer id, object x, object y)
sequence BBox

    BBox = convPctToPixel(id, x,y, 0, 0)

    -- set the window cursor position
    ctrl_X_Pos[id] = BBox[1]
    ctrl_Y_Pos[id] = BBox[2]
end procedure
r_setPenPos = routine_id("setPenPos")

function findMenuBreaks(integer id)
-- returns the squence of 1-based indexes of items after which menu breaks
atom hMenu,state
integer n
sequence result

    hMenu = ctrl_Handle[id]
    n = 1
    result = {}
    while 1 do
        state = w32Func(xGetMenuState,{hMenu,n,MF_BYPOSITION})
        if state=-1 then
            return result
        else
            if and_bits(state,MF_MENUBREAK+MF_MENUBARBREAK) then
                result &= n-1
            end if
            n += 1
        end if
    end while
    return result
end function

-----------------------------------------------------------------------------

--/topic Attributes
--/func getRect( atom id )
--/desc Get the dimensions of /i id.
--/ret Sequence: { left, top, right, bottom }
-- The function returns the pixel positions of the top-left corner and the bottom
-- right corner. For Screen, Printer and bitmaps the top-left is always
-- 0,0 and thus /i right is the width and /i bottom is the height.  
--
-- For invisible controls, including Menus not dropping down, or menu items whose
-- parent doesn't display, {0,0,0,0} is returned.
--
-- Example:
--
--/code
--      -- where is the window located?
--      sequence extent
--
--      -- get the extent of the window
--      extent = /getRect( MyWindow )
--
--      -- display the position
--      /wPrintf( MyWindow, "MyWindow is located at %d,%d }, extent[1 .. 2] )
--/endcode

global function getRect(atom id)

-- get metrics for current window
-- returns { left, top, bottom, right }

integer top, bottom, left, right, ctltype
atom pStruct, pt, hdc, mset, bufsize, hWnd
sequence xy, retval


    retval = {0, 0, 0, 0}

    if not validId(id) then
    -- probably passed a bitmap

        if id=0 then
            return retval
        end if

        -- ask OS for the required buffer size for object info
        bufsize = w32Func(xGetObjectType, {id})
        if bufsize=OBJ_BITMAP then
            bufsize = w32Func(xGetObject, {id, 0, 0})
        else
            bufsize = 0
        end if

        if bufsize!=0 then
            mset = w32new_memset()
            -- Allocate a buffer to hold bitmap information
            pStruct = w32acquire_mem(mset, bufsize)

            -- load bitmap data into structure
            if w32Func(xGetObject, {id, bufsize, pStruct})!=bufsize then
                warnErr(Err_GSGETBITMAP)
            else
                -- get the values from the bitmap
                retval[3] = w32fetch(pStruct, bmWidth)
                retval[4] = w32fetch(pStruct, bmHeight)
            end if
        else -- actually, object is not recognised as a bitmap
            warnErr(Err_GSGETBITMAP)
        end if
    else
        mset = w32new_memset()
        ctltype = find(ctrl_Family[id],{MENU,MENUITEM})

        if id=Screen    or  id=Printer  then

            hdc = getDC(id)

            -- screen size
            retval[3] = w32Func(xGetDeviceCaps, {hdc, HORZRES})
            retval[4] = w32Func(xGetDeviceCaps, {hdc, VERTRES})

            releaseDC(id)

        elsif ctrl_Family[id]=PIXMAP then
            -- do we have one?
            hWnd = ctrl_Handle[id]
            if hWnd!=0 then

                bufsize = w32Func(xGetObject, {hWnd, 0, 0})
                -- Allocate a buffer to hold bitmap information
                if bufsize>0 then
                    pStruct = w32acquire_mem(mset, bufsize)

                    -- load bitmap data into structure
                    if w32Func(xGetObject, {hWnd, bufsize, pStruct})!=bufsize then
                        warnErr(Err_GSGETPIXMAP)
                    end if

                    -- get the values from the bitmap
                    retval[3] = w32fetch(pStruct, bmWidth)
                    retval[4] = w32fetch(pStruct, bmHeight)
                end if
            end if

        elsif ctltype=0 then -- neither menu or menuitem
            -- Allocate a buffer to hold the rectangle information
            pStruct = w32acquire_mem(mset, SIZEOF_RECT)

            -- load rectangle information into the buffer
            if not w32Func(xGetWindowRect, {getHandle(id), pStruct}) then
                abortErr(Err_GSGETWINDRECT)
            end if

            -- get points
            retval = peek4s({pStruct,4})

            -- is it owned by a window?
            if ctrl_Parent[id] then

                -- set to owner window
                id = ctrl_Parent[id]

                xy = ClientToScreen(id, 0, 0)

                -- adjust points
--/**/          retval = sq_sub(retval,(xy & xy))               --/* -- Phix
                retval -= (xy & xy)                             --*/ -- RDS

            end if
        else -- somehow related to menus
            if call_func(r_isVisible,{findParentWindow(id)})=0 then
                w32release_mem(mset)
                return retval
            end if
            if ctrl_Family[ctrl_Parent[id]]=MENU and not inMenuBar(id) and not find(ctrl_Parent[id],menu_dropped) then
            -- if the menu is not displayed, the item is not visible
                return retval
            end if
            if ctltype=1 and find(id,menu_dropped)=0 then
            -- for a menu: if no item is selected, return rectangle of item, else of menu
            -- Usually, when no item is selected, the menu itself doesn't display
            -- Problem: not quite true when the parent is the menu bar
                ctltype = 2
            end if

            top = findParentWindow(id)
            hWnd = ctrl_Handle[top]
            pStruct = w32acquire_mem(mset, SIZEOF_RECT)

            if ctltype=2 then -- single item
                pt = ctrl_Handle[ctrl_Parent[id]]
                if w32Func(xGetMenuItemRect,{hWnd,pt,getMenuPosn(id),pStruct}) then
                    retval = peek4s({pStruct,4})
                end if
            else -- whole menu
                -- left and top are those of first item
                pt = ctrl_Handle[id]
                VOID = w32Func(xGetMenuItemRect,{hWnd,pt,0,pStruct})

                -- right and bottom usually are those of the last item ...
                hdc = w32acquire_mem(mset,SIZEOF_RECT)
                VOID = w32Func(xGetMenuItemRect,{hWnd,pt,getCount(id)-1,hdc})

                -- ... except when a bar wraps or a menu has breaks
                if ctrl_Family[ctrl_Parent[id]]=WINDOW and pt=ctrl_Menu[ctrl_Parent[id]] then -- a menu bar
                    -- bottom is from last item
                    -- width is the parent's width - don't use getClientRect(), since scroll bars don't count
                    xy = getWindowInfo(top,{WINDOWINFO_WLeft,WINDOWINFO_WRight,WINDOWINFO_xWindowBorders})
                    right = xy[2]-xy[1]-2*xy[3]
                    left = peek4s(pStruct)
                    retval = {left,peek4s(pStruct+4),left+right,peek4s(hdc+12)}
                else -- a vertical menu
                     -- the right is from last item, but the bottom not always
                    bottom = peek4s(hdc+12)
                    right = peek4s(hdc+8)
                    retval = {peek4s(pStruct),peek4s(pStruct+4),peek4s(hdc+8)}
                    if right!=peek4s(pStruct+8) then -- menu has two or more columns

                        -- find bottom item for each column but the last
                        xy = findMenuBreaks(id)

                        -- find bottom-most item, which gives menu rectangle bottom
                        -- starting point is bottom of last column
                        for i=1 to length(xy) do
                            VOID = w32Func(xGetMenuItemRect,{top,pt,xy[i]-1,hdc})
                            top = peek4s(hdc+12)
                            if top>bottom then
                                bottom = top
                            end if
                        end for
                    end if
                    retval &= bottom
                end if
            end if
        end if
    end if

    -- Return any memory blocks used.
    w32release_mem(mset)

    -- return values
    return retval -- { left, top, right+1, bottom+1 }

end function
r_getRect = routine_id("getRect")

-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientSize( atom id )
--/desc Get the dimensions of /i "id's" client area.
--/ret Sequence: { Screen.left, Screen.top, right, bottom }
-- The returns the pixel positions of the top-left corner, relative to the screen
-- and the width and height of the client area.
-- For Screen, Printer and Pixmap the top-left is always 0,0
--
-- Example:
--
--/code
--      -- where is the button located?
--      sequence extent
--
--      -- get the extent of the button
--      extent = /getClientSize( MyButton )
--
--      -- display the position
--      /wPrintf( MyWindow, "MyButton is at %d,%d and width=%d, height=%d", extent )
--/endcode

global function getClientSize(integer id)

-- get metrics for current window's client area
-- returns { Sceeen.left, Screen.top, width, height }

integer cx, cy
atom rect, hWnd
sequence xy

    if find(ctrl_Type[id],{Screen_, Printer_, Pixmap}) then
        return getRect(id)
    end if

    -- get handle of window
    hWnd = getHandle(id)

    -- Allocate a buffer to hold the rectangle information
    rect = w32acquire_mem(0, SIZEOF_RECT)

    -- get size of client area
    if not w32Func(xGetClientRect, {hWnd, rect}) then
        warnErr(Err_GCSGETCLIENTRECT)
    end if

    -- fetch the extent
    cx = w32fetch(rect, rectRight)
    cy = w32fetch(rect, rectBottom)

    -- Locate the top left corner relative to the screen.
    xy = ClientToScreen(id, 0, 0)
    --xy = {w32fetch( rect, rectLeft  ), w32fetch( rect, rectTop  )}


    -- Free point and rectangle
    w32release_mem(rect)

    -- return values
    return {xy[1], xy[2], cx, cy}

end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientPoint( window, x, y )
--/desc Get screen position of point { /i x, /i y } in /i window.
--/ret { screen x, screen y }
--This routine handles relative positions similar to the /create() routine
--
-- Example:
--
--/code
--      -- where does {0.50, 10} in MyWindow appear on the screen?
--      sequence point
--
--      -- get the screen position
--      point = /getClientPoint( MyWindow, 0.50, 10 )
--
--      -- display the size
--      /wPrintf( MyWindow, "The point {0.50,10} maps to {%d, %d on the screen"}, point )
--/endcode

global function getClientPoint(integer id, object x, object y)

sequence point, BBox

    BBox = convPctToPixel(id, x, y, 0, 0)
    x = BBox[1]
    y = BBox[2]

    point = ClientToScreen(id, x, y)

    return point

end function


-----------------------------------------------------------------------------
--/topic Attributes
--/func getPosition( object )
--/desc Get the location of /i object.
--/ret { left, top }
--
--
-- Example:
--
--/code
--      -- Where is TheButton?
--      sequence posn
--
--      -- get the position of TheButton
--      posn = /getPosition( TheButton )
--
--      -- display the position
--      /wPrintf( MyWindow, "TheButton is at %d, %d}, posn )
--/endcode

global function getPosition(atom id)

-- get { left, top } for the requested item
sequence s

-- get extent
    s = getRect(id)

    -- Return the left hand top corner position
    return {s[1], s[2]}

end function

--/topic Attributes
--/proc setWindowRect( integer id, sequence Rect )
--/desc Sets the dimensions of window /i id.
--/i Rect is a sequence containing the { left, top, right, bottom }
-- new coordinates of the control.

global procedure setWindowRect(integer id, sequence pRect)

    pRect[3] -= pRect[1]
    pRect[4] -= pRect[2]
    VOID = w32Func(xMoveWindow, getHandle(id) & pRect & w32True)

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/func getClientRect( integer ControlId )
--/desc Get uncovered portion of the client area.
--/ret { left, top, width, height, right, bottom }
-- Unlike the menu, toolbar and statusbar both occupy space in the window.
-- To determine what part of the window's client area is not covered, use
-- this function. This function can be used even if there is no toolbar or
-- statusbar in the window.
--
-- For example, the /b generic demo has a /MleText that needs to be resized
-- every time the window is resized. It uses getClientRect to determine the
-- metrics of the /MleText.
--
-- Note that, for a TabItem "control", the client area is the whole area of the parent TabControl,
-- including the tabs proper. Send the parent TabControl the TCM_ADJUSTRECT message to convert 
-- work area to bounding rectangle and vice versa.
--
--/code
--          -- color the unoccupied portion of the window red
--          sequence rect
--
--          -- find out what portion of the window is available
--          rect = getClientRect( TheWindow )
--
--          -- draw a filled rectangle
--          /setPenColor( TheWindow, Red )
--          /drawRectangle( TheWindow, w32True, rect[1], rect[2], rect[1]+rect[3], rect[2]+rect[4] )
--/endcode
-----------------------------------------------------------------------------
global function getClientRect(integer id)

-- returns rectangle of the client area, accounting for
-- the toolbar and status bar.

integer toolbar, tb_position, statusbar
atom ptrRect, hdc
sequence rect, size,styles

    rect = repeat(0, 6)

    if id=Screen then

        ptrRect = w32acquire_mem(0,Rect)
        VOID = w32Func(xSystemParametersInfo,{SPI_GETWORKAREA,0,ptrRect,0})
        rect[1..4] = peek4u({ptrRect,4})
        w32release_mem(ptrRect)

    elsif id=Printer then

        hdc = w32Func(xCreateIC,{"WINSPOOL",getPrinterName(),0,0})
        if not hdc then
            return rect
        end if
        rect[1] = w32Func(xGetDeviceCaps,{hdc,PHYSICALOFFSETX})
        rect[2] = w32Func(xGetDeviceCaps,{hdc,PHYSICALOFFSETY})
        rect[3] = w32Func(xGetDeviceCaps,{hdc,PHYSICALWIDTH})
        rect[4] = w32Func(xGetDeviceCaps,{hdc,PHYSICALHEIGHT})
--/**/  rect[3..4] = sq_sub(rect[3..4],rect[1..2])                  --/* -- Phix
        rect[3..4] -= rect[1..2]                                    --*/ -- RDS
        ptrRect = w32acquire_mem(0,Rect)
        poke4(ptrRect,rect)
        VOID = w32Func(xDPtoLP,{hdc,ptrRect,2})
        VOID = w32Func(xDeleteDC,{hdc})
        rect[1..4] = peek4u({ptrRect,4})
        w32release_mem(ptrRect)

    elsif ctrl_Type[id]=Pixmap then
        rect[1..4] = getRect(id)

    elsif ctrl_Type[id]=ReBarBand then
        rect[1..4]  = getRect(id)

    else

        -- Allocate a rectangle structure
        ptrRect = w32acquire_mem(0, SIZEOF_RECT)

        -- get client rectangle size
        if not w32Func(xGetClientRect, {getHandle(id), ptrRect}) then
            warnErr(Err_GCRGETCLIENTRECT)
        end if
        rect[1..4] = peek4u({ptrRect,4})

        -- Free the structure
        w32release_mem(ptrRect)

        -- is there a toolbar?
        for i=1 to length(ctrl_Toolbar[id]) do
            toolbar = ctrl_Toolbar[id][i]
            if (vWinMainState=kNotStarted) or call_func(r_isVisible, {toolbar}) then

                -- get the size of the toolbar
                size = getCtlSize(toolbar)
                styles = getStyleFlags(toolbar)
                if find(ctrl_Type[toolbar],{ToolBar,FlatToolBar,ReBar}) then
                    tb_position = and_bits(styles[1],CCS_RIGHT)
                    if tb_position=CCS_TOP then
                    -- add height to the y value
                        rect[2] += size[2]
                        rect[4] -= size[2]
                    elsif tb_position=CCS_LEFT then
                    -- add width to the x value
                        rect[1] += size[1]
                        rect[3] -= size[1]
                    elsif tb_position=CCS_BOTTOM then
                        rect[4] -= size[2]
                    else        -- CCS_RIGHT
                        rect[3] -= size[1]
                    end if
                else -- ReBar, nothing to do
                end if
            end if
        end for

        -- is there a statusbar?
        statusbar = ctrl_Statusbar[id]
        if statusbar and call_func(r_isVisible, {statusbar}) then

            -- get the size of the toolbar
            size = getCtlSize(statusbar)

            -- subtract height from the y value
            rect[4] -= size[2]

        end if
    end if

    rect[5] = rect[1]+rect[3]-1
    rect[6] = rect[2]+rect[4]-1

    return rect

end function
r_getClientRect = routine_id("getClientRect")

-----------------------------------------------------------------------------
-- GENERIC CONTROLS
--

-----------------------------------------------------------------------------
function getMenuState(integer id)
    -- get menu state
    return w32Func(xGetMenuState, {ctrl_Handle[ctrl_Parent[id]], getMenuPosn(id), MF_BYPOSITION})
end function


-----------------------------------------------------------------------------
--/topic Values
--/proc insertText( object pID, object pText )
--/desc Inserts text at the current caret (insersion point)
-- Example:
--
--/code
--      -- Adds some text to the contents of the control, starting at the current insertion point, and clobbering any selected text.
--      /insertText( myedit, "\n(Ready)\n" )
--/endcode
global procedure insertText(integer id, sequence text)

   -- replace selection; w32True means allow undo
    VOID = sendMessage(id, EM_REPLACESEL, w32True, text)

end procedure

--/topic Values
--/proc appendText( object pID, object pText )
--/desc Adds text to the end of a edit control.
-- Example:
--
--/code
--      -- Adds some text to the end of the control.
--      /appendText( myedit, ">Ready\n" )
--/endcode
global procedure appendText(integer id, sequence text)
    -- Insert text at end of edit control's existing text --
atom editlength

    editlength = sendMessage(id, WM_GETTEXTLENGTH, 0, 0)
    VOID = sendMessage(id, EM_SETSEL, editlength, editlength)
    insertText(id, text)
end procedure

--/topic Values
--/proc setText( object pID, object pText )
--/desc Set the text in /i pID control.
-- If the control is editable, it updates the data in the control.
-- Otherwise, it updates the caption text of the control. /n
-- For StatusBar controls, the /i pID can also be used to specify
-- the subField to use. It takes the form of a 2-element sequence
-- {id, subfield}.
--
-- Example:
--
--/code
--      -- change the caption of status bar
--      /setText( TheStatusBar, "Ready" )
--      -- If a statusbar has subfields, you can specify
--      -- them like:
--      setText( {TheStatusBar,2}, "2nd subField")
--/endcode

global procedure setText(object pID, object pText)

-- set the text in a window

atom lHandle, lTCMITEM, lMenu
integer id, lPart
sequence s
integer lPosn
integer tabNumber, owner

    if atom(pID) then
        id = pID
        lPart = 1
    else
        id = pID[1]
        lPart = pID[2]
    end if

    if validId(id)=w32False then
        return
    end if

    if and_bits(classAttr[ctrl_Type[id]], w32PictCtrl)!=0
    or
       (ctrl_Parent[id]!=0
        and
        ctrl_Type[ctrl_Parent[id]]=FlatToolBar
       ) then
        return
    end if

    if atom(pText) then
        s = sprintf("%g", pText)
    elsif length(pText)=2 and sequence(pText[1]) then
        s = sprintf(pText[1], pText[2])
    else
        s = pText
    end if

    if ctrl_Type[id]=StatusBar then

        -- send the text to the statusbar
        VOID = sendMessage(id, SB_SETTEXT,    lPart-1, s)
        VOID = sendMessage(id, SB_SETTIPTEXT, lPart-1, s)

    elsif find(ctrl_Family[id], {MENU,MENUITEM}) then
        -- Get Menu's handle

        owner = ctrl_Parent[id]
        lHandle = ctrl_Handle[owner]
        lMenu = id
        if ctrl_Family[id]=MENU then
            lMenu = getHandle(id)
        end if
        VOID = w32Func(xModifyMenu, {lHandle, lMenu, MF_BYCOMMAND, lMenu, s})
        VOID = w32Func(xDrawMenuBar, {getHandle(findParentWindow(id))})

    elsif ctrl_Type[id]=TreeView then

        if lPart>0 and lPart<=length(tvitem_data) then
            w32release_mem(tvitem_data[lPart][ktv_TextAddr])
            tvitem_data[lPart][ktv_TextAddr] = w32acquire_mem(0, s)
            tvitem_data[lPart][ktv_TextSize] = length(s)
            lTCMITEM = w32to_memory(0,ID_TVITEM, {TVIF_TEXT,lPart,0,TVIF_TEXT,s,                                0,0,0})
            VOID = sendMessage(id,TVM_SETITEM,0,lTCMITEM)
            w32release_mem(lTCMITEM)
        end if

    elsif ctrl_Type[id]=TabItem then

        owner = ctrl_Parent[id]
        tabNumber = find(id, ctrl_Specific[owner])-1
        if tabNumber>=0 then
            -- Allocate a tab structure
            lTCMITEM = w32acquire_mem(0, SIZEOF_TC_ITEM)

            -- set the items
            w32store(lTCMITEM, TC_ITEM_mask,        TCIF_TEXT)
            w32store(lTCMITEM, TC_ITEM_pszText, s)
            -- Change text in tabitem
            VOID = sendMessage(owner, TCM_SETITEM, tabNumber, lTCMITEM)
            w32release_mem(lTCMITEM)

            repaintWindow(0)

        end if

    elsif find(ctrl_Type[id], {CheckBox, TriCheckBox, Radio}) then
        lPosn = -1
        if equal(s,"0") then
            lPosn = 0
        elsif equal(s,"2") then
            lPosn = 2
        elsif equal(s,"1") then
            lPosn = 1
        end if
        if lPosn>=0 then
            VOID = sendMessage(id, BM_SETCHECK, lPosn, 0)
        else
            VOID = w32Func(xSetWindowText, {getHandle(id), s})
        end if

    else
        -- For Mle, change single LF to CRLF
        if ctrl_Type[id]=MleText then
            lPosn = 1
            while w32True do
                if lPosn>length(s) then
                    exit
                end if
                if s[lPosn]=10 then
                    if lPosn=1 or
                    s[lPosn-1]!=13 then
                        s = s[1..lPosn-1] & 13 & s[lPosn..length(s)]
                        lPosn += 1
                    end if
                end if

                lPosn += 1
            end while
        end if
        -- set the window text
        VOID = w32Func(xSetWindowText, {getHandle(id), s})

    end if

end procedure
r_setText = routine_id("setText")

-----------------------------------------------------------------------------
--/topic Values
--/proc setSelectedText( integer object, sequence text )
--/desc Replaces the selected text in /i object with /i text.
-- This only works with edit text controls. It doesn't work as expected with the latest version (v4.1) of RichEdit controls which ship with Winfows XP.
--
-- Example:
--
--/code
--      -- add HTML formatting to the selected text
--      text = /getSelectedText( TheMle )
--      /setSelectedText( TheMle, "~<I>" & text & "~</I>" )
--/endcode
global procedure setSelectedText(integer id, sequence text)

atom addrText, result

-- is there any text selected?
    result = sendMessage(id, EM_GETSEL, NULL, NULL)
    if result!= -1 and w32lo_word(result)<=w32hi_word(result) then

        -- convert to lpsz
        addrText = w32acquire_mem(0, text)

        -- replace selection; w32True means allow undo
        result = sendMessage(id, EM_REPLACESEL, w32True, addrText)

        -- Free the string
        w32release_mem(addrText)

    end if

end procedure


-----------------------------------------------------------------------------
--/topic Text
--/func drawText(integer id, sequence text, object rect, object flags, integer tabsize, integer left, integer right)
--/desc Places the text /i text into the rectangle /i rect, wrapping words if necessary.
--/ret SEQUENCE: {height, count, {left, top, right, bottom} }
-- This returns a sequence of three values: The height, in pixels, of the text drawn,
-- the number of characters used that could fit into the rectangle specified, and the
-- rectangle actually used, given as a {left,top,right,bottom} sequence. The rectangle is given in client coordinates for the control /i id. /n
-- The meaning and valid values for the other parameters are to be found in the Win32 API documentation.
--
--Example:
--/code
--          sequence result
--          sequence rect
--          result = drawText(myWind, "Fourscore and twenty years ago, our fathers, ...",
--                   {5,5,140, 75}, DT_WORDBREAK, 4, 0, 0)
--          textheight = result[1]
--          textcnt= result[2]
--          rect = result[3]
--/endcode

global function drawText(integer id, object text, object rect,
                         object flags, integer tabsize,integer left,integer right)
atom hdc, lRect, lDT, memset
integer sLen
atom lHeight
sequence result
sequence lBorders


    -- Check for formatting
    if atom(text) then
        text = sprintf("%g", text)
        sLen = length(text)
    elsif length(text)=2 and sequence(text[1]) then
        text = sprintf(text[1], text[2])
        sLen = length(text)
    elsif length(text)>=2 and atom(text[1]) and text[1]= -1 and atom(text[2]) then
        if length(text)=3 then
            sLen = text[3]
        else
            sLen = -1 -- Let windows find out.
        end if

        text = text[2] -- RAM address of text.
    else
        sLen = length(text)
    end if

    -- set the font

    hdc = assignFont(id)

    memset = w32new_memset()
    lRect = w32acquire_mem(memset, SIZEOF_RECT)


    if atom(rect) then
        rect = getClientRect(id)
        lBorders = {0,0,0,0}
    elsif length(rect)=2 then
        lBorders = rect[2]
        if atom(rect[1]) then
            rect = getClientRect(id)
        else
            rect = rect[1]
        end if
    else
        lBorders = {0,0,0,0}
    end if
--/**/  poke4(lRect, sq_add(rect[1..4],lBorders))       --/* -- Phix
    poke4(lRect, rect[1..4]+lBorders)                   --*/ -- RDS

    lDT = w32to_memory(memset, ID_DRAWTEXTPARAMS,{tabsize, left, right})

    if sequence(flags) then
        flags = w32or_all(flags)
    end if
    -- display the text in the buffer
    lHeight = w32Func(xDrawTextEx, {hdc, text, sLen,
                                    lRect, flags, lDT
                                   })

    -- release the device context
    releaseDC(id)

    result = {lHeight, w32fetch(lDT, DTP_uiLengthDrawn),peek4u({lRect,4})}
    w32release_mem(memset)

    return result
end function

-----------------------------------------------------------------------------
--/topic Text
--/func textRect(integer id,sequence text,object rect,object flags,integer tabsize,integer left,integer right)
--/desc Calculates the RECT structure need to draw all the text.
--/ret SEQUENCE: {height, width,rectangle}
--/l rect defines the left, top and maximum right pixel (for multiple line text).
-- The parameters are the same as for /drawText(), as the same API function is called by both routines. /n
-- On return, the rectangle actually used is given as {left, top, right, bottom}.
--Example:
--/code
--          sequence result
--          result = textRect(myWind, "Fourscore and twenty years ago, our fathers, ...",
--                   {5,5,140, 75}, DT_WORDBREAK, 4, 0, 0)
--/endcode
global function textRect(integer id, object text, object rect,
                         object flags, integer tabsize,integer left,integer right)

atom hdc, lRect, lDT, memset
integer sLen
atom lHeight
sequence result
sequence lBorders

-- Check for formatting
    if atom(text) then
        text = sprintf("%g", text)
        sLen = length(text)
    elsif length(text)=2 and sequence(text[1]) then
        text = sprintf(text[1], text[2])
        sLen = length(text)
    elsif length(text)>=2 and atom(text[1]) and text[1]= -1 and atom(text[2]) then
        if length(text)=3 then
            sLen = text[3]
        else
            sLen = -1 -- Let windows find out.
        end if

        text = text[2] -- RAM address of text.
    else
        sLen = length(text)
    end if

    -- set the font
    hdc = assignFont(id)

    memset = w32new_memset()
    lRect = w32acquire_mem(memset, SIZEOF_RECT)

    if atom(rect) then
        rect = getClientRect(id)
        lBorders = {0,0,0,0}
    elsif length(rect)=2 then
        lBorders = rect[2]
        if atom(rect[1]) then
            rect = getClientRect(id)
        else
            rect = rect[1]
        end if
    else
        lBorders = {0,0,0,0}
    end if
--/**/  poke4(lRect, sq_add(rect[1..4],lBorders))       --/* -- Phix
    poke4(lRect, rect[1..4]+lBorders)                   --*/ -- RDS

    lDT = w32to_memory(memset, ID_DRAWTEXTPARAMS,{tabsize, left, right})

    if sequence(flags) then
        flags = w32or_all(flags)
    end if
    flags = or_bits(flags , DT_CALCRECT)
    -- calc the rect needed for the text in the buffer
    lHeight = w32Func(xDrawTextEx, {hdc, text, sLen,
                                    lRect, flags, lDT
                                   })

    -- release the device context
    releaseDC(id)

    result = {lHeight, w32fetch(lDT, DTP_uiLengthDrawn),peek4u({lRect,4})}
    w32release_mem(memset)

    return result
end function

--/topic Values
--/func getCaption( integer id)
--/desc This returns any caption text associated with /i id
--/ret SEQUENCE: The caption text.
--The type of controls that have caption text are windows, menus, labels, and buttons.
-- Other controls will return "".
--
--Example:
--/code
--      sequence ctext
--      sequence clst
--      clst = {Btn1, Btn2, MenuItem3, Radio1, Checkbox2}
--      for i = 1 to length(ctext) do
--          ctext[i] = ReplaceText(getCaption(clst[i]), "all", "some")
--          setCaption(clst[i], ctext[i])
--      end for
--/endcode

global function getCaption(integer pId)
sequence lCapText
integer lLenMsg ,lPos
atom buffer, lHandle


    lCapText = ""

    if find(ctrl_Type[pId], {MenuItem, MenuSpacer, Menu}) then

        if ctrl_Type[pId]=Menu and ctrl_Family[ctrl_Parent[pId]]=WINDOW then
        -- menu bars have no title
            return ""
        elsif ctrl_Type[pId]=MenuSpacer then
            return "-"
        end if

        -- Get Menu's handle
        lHandle = ctrl_Handle[ctrl_Parent[pId]]
        lPos = getMenuPosn(pId)
         -- Get the buffer for item information
        lLenMsg = w32Func(xGetMenuString, {lHandle, lPos, 0, 0, MF_BYPOSITION})+1
        -- Allocate enough room
        buffer = w32acquire_mem(0, lLenMsg)
        -- Get the current menu item text in lCapText
        VOID = w32Func(xGetMenuString, {lHandle, lPos, buffer, lLenMsg,
                                        MF_BYPOSITION})
        lCapText = w32peek_string(buffer)
        w32release_mem(buffer)


    elsif find(ctrl_Family[pId], {WINDOW, BUTTON, STATIC}) then
        lLenMsg = sendMessage(pId, WM_GETTEXTLENGTH, 0, 0)
        if lLenMsg>0 then
            lLenMsg += 1
            buffer = w32acquire_mem(0, lLenMsg)

            lLenMsg = sendMessage(pId, WM_GETTEXT, lLenMsg, buffer)
            lCapText = peek({buffer, lLenMsg})
            w32release_mem(buffer)

        end if

    end if

    return lCapText
end function
r_getCaption = routine_id("getCaption")

--/topic Edit controls
--/func getCharacterCount(integer id,integer flag)
--/desc Returns the number of characters in the control. 
--/ret (INTEGER) The number of characters in the control.
-- If /i flag is zero, this will be a fast estimate, slightly larger than the actual count. 
-- Passing a nonzero flag will return the actual count, accurate but slower.
global function getCharacterCount(integer id,integer flag)
atom a,chars
    a = w32acquire_mem(0,8)
    poke4(a,{w32iff(flag,GTL_PRECISE,GTL_CLOSE),CP_ACP})
    chars = sendMessage(id,EM_GETTEXTLENGTHEX,a,0)
    w32release_mem(a)
    return chars
end function

--/topic Values
--/func getData( object id)
--/desc This returns any data value associated with /i id
--/ret OBJECT: The data, as a text string if applicable.
-- Note that Menuitems, Radio, Checkbox and TriCheckbox controls
-- return a single character string of "0", "1", or "2" for
-- Unchecked, Checked, and Neither respectively.
--
-- For statusbars and treeviews, /i id can be a 2-element sequence containing
-- {ControlID, Panel#} to get the value of a specific sub-panel
-- of the statusbar, or treeview item.
--
-- For /i RichEdit controls, this returns the selected text only.
--
-- For ListView controls, this returns a sequence that contains one element
-- for each selected item in the ListView. Each element is itself a sequence
-- that contains an string element for each column in the ListView. /n
-- /i "ListView example:" /b
--/code
--      sequence text
--      text = getData(myListView)
--      -- If two rows were selected then the returned value
--      -- may look like this ...
--  { { "Col 1 data", "Col 2 data", "Col 3 data", ...}, -- 1st selected row
--    { "Col 1 data", "Col 2 data", "Col 3 data", ...}  -- 2nd selected row
--  }
--/endcode
--
-- For /i StatusBar controls, /i object can be a two-element sequence,
-- the /b first is the control's id, and the /b second is the section of
-- the status bar (this is zero-based). Also, this returns two-elements: /n
--/li s[1] is the text,
--/li s[2] is the rendering method:
--/define
--/term 0
--The text is drawn with a border to appear lower than the plane of the window.
--/term SBT_NOBORDERS
-- The text is drawn without borders.
--/term SBT_POPOUT
--The text is drawn with a border to appear higher than the plane of the window.
--/term SBT_RTLREADING
--The text will be displayed in the opposite direction to the text in the parent window.
--/enddefine
--
-- For /i /TreeView controls, /i id takes the form {TV, TVItemID}. Where /i TVItemID is the
-- id returned by /addTVItem(). To get the currently selected treeview item, use zero for
-- the /i TVItemID.
--
--Example:
--/code
--      sequence text
--      text[i] = getData(EditFld1)
--/endcode
global function getData(object pID)
integer iLength, result, id, lPart, lNumParts
atom buffer
sequence text
atom lmh
sequence items

    if atom(pID) then
        id = pID
        lPart = 0
    else
        -- Get sub-item for statusbar and treeview
        id = pID[1]
        lPart = pID[2]-1
    end if
    text = ""

    if and_bits(classAttr[ctrl_Type[id]], w32PictCtrl)!=0
    or
       (ctrl_Parent[id]!=0
        and
        ctrl_Type[ctrl_Parent[id]]=FlatToolBar
       ) then
        -- Picture controls and things on a flattoolbar don't any data.
        return text
    end if

    -- edit controls
    -- get the text size

    if ctrl_Type[id]=RichEdit then
        -- return selection
        buffer = w32to_memory(0,ID_CHARRANGE, {0, -1})
        VOID = sendMessage(id, EM_EXGETSEL, 0, buffer)
        result = w32fetch(buffer, CHARRANGE_cpMax)-
                 w32fetch(buffer, CHARRANGE_cpMin)
        w32release_mem(buffer)

        if result>0 then
            if equal(WC_RICHEDIT,WC_RICHEDIT50) then
                buffer = w32acquire_mem(0, 2*result+2) --  add 2 for '/0' character.
                iLength = sendMessage(id, EM_GETSELTEXT, 0, buffer)
                text = repeat(0,iLength)
                lmh = buffer
                for i=1 to iLength do
                    text[i] = peek(lmh)+256*peek(lmh+1)
                    lmh += 2
                end for
            else
                buffer = w32acquire_mem(0, result+1) -- add 1 for '/0' character.
                iLength = sendMessage(id, EM_GETSELTEXT, 0, buffer)
                text = peek({buffer , iLength})
            end if
        else
            iLength = getCharacterCount(id,0)
            buffer = w32acquire_mem(0,iLength)
            lmh = w32to_memory(0,ID_GETTEXTEX, {iLength,GT_DEFAULT,CP_ACP,0,0})
            iLength = sendMessage(id,EM_GETTEXTEX,lmh,buffer)
            text = peek({buffer,iLength})
        end if
        w32release_mem(buffer)

    elsif ctrl_Type[id]=StatusBar then
        lNumParts = sendMessage(id, SB_GETPARTS, 0, 0)-1
        if lPart<0 or lPart>lNumParts then
            lPart = 0
        end if
        iLength = sendMessage(id, SB_GETTEXTLENGTH, lPart, 0)
        if iLength>0 then
            iLength += 1
            buffer = w32acquire_mem(0, iLength)

            result = sendMessage(id, SB_GETTEXT, lPart, buffer)
            iLength = w32lo_word(result)
            lPart   = w32hi_word(result)
            text = peek({buffer, iLength})
            w32release_mem(buffer)

        end if

    elsif find(ctrl_Type[id], {MenuItem, MenuSpacer, Menu}) then
        if call_func(r_isChecked,{id}) then
            text = "1"
        else
            text = "0"
        end if

    elsif ctrl_Type[id]=TreeView then
        lPart += 1
        if lPart=0 then
            return getTVSelectedText(id)
        else
            return getTVText(lPart)
        end if

    elsif find(ctrl_Type[id], {Combo, SortedCombo, SimpleCombo, DropDownList,
                               ComboBoxEx}) and
    vWMI>0 and vWinMsg[vWMI][3]=WM_COMMAND
      and w32hi_word(vWinMsg[vWMI][4])=CBN_SELCHANGE then
        -- Get the selected item rather than the old value in edit box.
        return call_func(r_getItem,{id, 0})

    elsif find(ctrl_Type[id], {SortedList, List}) then
        return call_func(r_getItem,{id,0})

    elsif find(ctrl_Type[id], {ListView}) then
        -- Get a list of all the selected items.
        items = call_func(r_getIndex,{id})
        -- Get each row of data from the selected items
        text = {}
        for i=1 to length(items) do
            text = append(text, getLVItemText(id, items[i], -1))
        end for

    elsif find(ctrl_Type[id], {CheckBox, TriCheckBox, Radio}) then
        -- Get its checked value
        iLength = sendMessage(id, BM_GETCHECK, 0, 0)
        text = sprintf("%d", iLength)

    elsif find(ctrl_Type[id], {Bitmap, Pixmap}) then
        -- the handle would be returned as a 4 character text

    elsif find(ctrl_Type[id], {HScroll, VScroll, UpDown, HTrackBar, VTrackBar, ProgressBar}) then
        -- return numeric position
        return call_func(r_getScrollPos,{id})

    else
        iLength = sendMessage(id, WM_GETTEXTLENGTH, 0, 0)
        if iLength>0 then
            iLength += 1
            buffer = w32acquire_mem(0, iLength)

            iLength = sendMessage(id, WM_GETTEXT, iLength, buffer)
            text = peek({buffer, iLength})
            w32release_mem(buffer)

        end if

    end if

    return text

end function

-----------------------------------------------------------------------------
--/topic Values
--/func getText( object id)
--/desc Get the text in /i object.
--/ret Text in id's caption or text area.
-- This returns the control's caption if it has one, otherwise it returns
-- its value.
--
-- See also: /getCaption and /getData
--
-- Example:
--
--/code
--      -- get the text from TheTextEdit
--      sequence text
--
--      text = /getText( TheTextEdit )
--      tvtext = /getText ( {myTreeView, itemid} )
--      tvselectedtext = /getText ( {myTreeView, 0} )
--      -- get the contents of the second panel in the statusbar.
--      sbtext = /getText( {StatBar, 2})
--
--      btnCaption = getText( myBtn )
--/endcode

global function getText(object pID)

sequence text

    if atom(pID) then
        text = getCaption(pID)
        if length(text)=0 then
            text = getData(pID)
        end if
    else
        text = getData(pID)
    end if


    return text

end function

--/topic Values
--/func getValues( integer Context, sequence Ids)
--/desc Gets the values from one or more specified controls.
--/ret SEQUENCE: A list of values, in the same order as the controls in /i Ids
--This gets the values for each of the controls specified in /i Ids. The
--controls can be specified as either a control ID (integer) or a control name.
--
--If your application has multiple controls with the same name, you can specify
--a context for this routine to limit the search to. This is usually the Window
--that the requested controls belong to. To specify that you don't use a context, give any negative value, 0 included, to /i Context.
--
--Example:
--/code
--      sequence lValues
--      lValues = getValues(CustWin, {"Name", "Address", "ZIP", "Telephone"})
--/endcode
global function getValues(integer pContext, sequence pIds)
sequence lKids
sequence lFldName
sequence lValues

    lValues = repeat(0, length(pIds))
    if pContext<=0 then
        -- No context specified
        for j=1 to length(pIds) do
            if sequence(pIds[j]) then
                -- Convert a name to an id.
                pIds[j] = getNameId(pIds[j])
            end if
            lValues[j] = getText(pIds[j])
        end for
    else
        lKids = ctrl_Group[pContext]
        for i=1 to length(lKids) do
            lFldName = getIdName(lKids[i])
            for j=1 to length(pIds) do
                if sequence(pIds[j]) then
                    if equal(lFldName, pIds[j]) then
                        lValues[j] = getText(lKids[i])
                        exit
                    end if
                elsif find(pIds[j], lKids) then
                    lValues[j] = getText(pIds[j])
                    exit
                end if
            end for
        end for
    end if

    return lValues
end function


-----------------------------------------------------------------------------
--/topic Values
--/func getNumber( object )
--/desc Get the numeric value of text from /i object.
--/ret Numeric value of the control's text/caption value.
--
-- This uses /w32TextToNumber() function to do the conversion. /n
-- If the text value cannot be converted to a numeric value, zero is returned.
--
-- Example:
--/code
--      -- get the numeric value from TheTextEdit
--      atom number
--
--      number = /getNumber( TheTextEdit )
--/endcode

global function getNumber(integer id)
    -- get the numeric value of text
    -- convert the value of the text
    return w32TextToNumber(getData(id))
end function


-----------------------------------------------------------------------------
--/topic Values
--/func getSelectedText( object )
--/desc Get the selected text in /i object.
--/ret Selected text, or empty sequence if nothing is selected.
-- This only works with text edit controls.
--
-- Example:
--
--/code
--      -- get the selected text from TheTextEdit
--      sequence text
--
--      text = /getSelectedText( TheTextEdit )
--/endcode
global function getSelectedText(integer id)

integer firstPos, lastPos
atom charrange
sequence text

   -- get the range of selected text
    if ctrl_Type[id]=RichEdit then
        return getText(id)
    end if

    charrange = w32acquire_mem(0,8)
    VOID = sendMessage(id, EM_GETSEL, charrange, charrange+4)
    firstPos = peek4u(charrange)
    lastPos = peek4u(charrange+4)
    w32release_mem(charrange)

   -- is any text selected?
    if firstPos<lastPos then

        -- get all the text text from the mle
        text = getText(id)

        -- get the selected portion of the text
        return text[firstPos+1..lastPos]

    else
        -- no text selected
        return ""

    end if


end function

--/topic Attributes
--/proc addToBand( id, band )
--/desc Add a control /i id to a /RebarBand /i band

global procedure addToBand(integer id, integer band)
atom rb, bandIndex
sequence size
atom hWndRebar

    size = getCtlSize(id)

    hWndRebar = getHandle(ctrl_Parent[band])
    bandIndex = w32Func(xSendMessage,{hWndRebar, RB_IDTOINDEX, band, 0})

    rb = w32to_memory(0,ID_REBARBANDINFO, {
                                           w32or_all({RBBIM_CHILD, RBBIM_CHILDSIZE,RBBIM_TEXT}), -- fMask
                                           0,           -- fStyle
                                           0,           -- clrFore
                                           0,           -- clrBack
                                           getText(id), -- lpText
                                           0,           -- iImage
                                           ctrl_Handle[id], -- hwndChild
                                           0,           -- cxMinChild
                                           size[2], -- cyMinChild
                                           size[1], -- cx
                                           0,           -- hbmBack
                                           id,      -- wID
                                           0,           -- cyChild
                                           0,           -- cyMaxChild
                                           0,           -- cyIntegral
                                           0,           -- cxIdeal
                                           0,           -- lParam
                                           0})       -- cxHeader

    VOID = w32Func(xSendMessage,{hWndRebar, RB_SETBANDINFO, bandIndex, rb})

    w32release_mem(rb)

end procedure

--/topic Date and time
--/func getSystemTime()
--/desc Gets the date and time as UTC (a.k.a. GMT)
--/ret SEQUENCE: The date and time (See below for details)
--This does not need any parameters. The date and time are returned
-- as UTC (Coordinated Universal Time) which is the old Greenwich Mean Time.
--
--The return sequence has eight elements arranged thus /n
--/li      Year
--/li      Month
--/li      DayOfWeek
--/li      Day
--/li      Hour
--/li      Minute
--/li      Second
--/li      Milliseconds
--
--Example:
--/code
--      sequence tm
--      tm = getSystemTime()
--/endcode

global function getSystemTime()
atom lST
sequence lResult

    lST = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32Proc(xGetSystemTime,{lST})

    lResult = w32from_memory(lST,ID_SYSTEMTIME)
    w32release_mem(lST)
    return lResult

end function

--/topic Date and time
--/func getLocalTime()
--/desc Gets the date and time according to your timezone settings.
--/ret SEQUENCE: The date and time (See below for details)
-- This does not need any parameters. The date and time are returned
-- based on your system's current timezone settings.
--
--The return sequence has eight elements arranged thus /n
--/li      Year
--/li      Month
--/li      DayOfWeek
--/li      Day
--/li      Hour
--/li      Minute
--/li      Second
--/li      Milliseconds
--
--Example:
--/code
--      sequence tm
--      tm = getLocalTime()
--/endcode

global function getLocalTime()
atom lST
sequence lResult

    lST = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32Proc(xGetLocalTime,{lST})

    lResult = w32from_memory(lST,ID_SYSTEMTIME)
    w32release_mem(lST)
    return lResult

end function

--/topic MonthCalendar Control
--/func getSelectedDate( id )
--/desc Get the selected date in a /MonthCalendar Control
--/ret { Year, Month, DayOfWeek, Day}
-- This cannot be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global function getSelectedDate(integer id)
sequence DATE
atom ok
sequence result

    DATE = {w32acquire_mem(0,   SIZEOF_SYSTEMTIME*2), SIZEOF_SYSTEMTIME}

    DATE[2] += DATE[1]
    ok = sendMessage(id, MCM_GETCURSEL, 0, DATE[1])

    if not ok then
        ok = sendMessage(id, MCM_GETSELRANGE, 0, DATE[1])
        if ok=0 then
            return {}
        end if
    end if

    result = w32from_memory(DATE[1], ID_SYSTEMTIME)
    w32release_mem(DATE[1])

    return result[1..4]

end function

--/topic MonthCalendar Control
--/proc setSelectedDate( id, year, month, day )
--/desc Set the selection in a /MonthCalendar Control
-- This cannot be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setSelectedDate(integer id, integer year, integer month,
    integer day)
atom st

    st = w32to_memory(0,ID_SYSTEMTIME, {year, month, 0, day})
    VOID = sendMessage(id, MCM_SETCURSEL, 0, st)

    w32release_mem(st)
end procedure

--/topic MonthCalendar Control
--/func getSelectedDateRange( id )
--/desc Get selected range of dates in a /MonthCalendar Control
--/ret { beginDate, endDate }
-- /i beginDate, /i endDate are sequences of the form:
-- { year, month, dayofweek, day }
--
global function getSelectedDateRange(integer id)
sequence result, DATE

    DATE = {w32acquire_mem(0,   SIZEOF_SYSTEMTIME*2), SIZEOF_SYSTEMTIME}

    DATE[2] += DATE[1]

    VOID = sendMessage(id, MCM_GETSELRANGE, 0, DATE[1])

    if VOID=0 then
        VOID = sendMessage(id, MCM_GETCURSEL, 0, DATE[1])
        if VOID=0 then
            return {}
        end if
        DATE[2] = DATE[1]
    end if

    result = {w32from_memory(DATE[1], ID_SYSTEMTIME),
              w32from_memory(DATE[2], ID_SYSTEMTIME)}

    result[1] = result[1][1..4]
    result[2] = result[2][1..4]

    w32release_mem(DATE[1])

    return result
end function

--/topic MonthCalendar Control
--/proc setSelectedDateRange( id, beginDate, endDate )
--/desc Set the selected range in a /MonthCalendar Control.
-- This can only be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setSelectedDateRange(integer id, sequence d1, sequence d2)
sequence st, DATE

    DATE = {d1, d2}
    st = {w32acquire_mem(0, SIZEOF_SYSTEMTIME*2), SIZEOF_SYSTEMTIME}
    st[2] += st[1]

    for i=1 to 2 do
        w32store(st[i], SYSTEMTIME_wYear, DATE[i][1])
        w32store(st[i], SYSTEMTIME_wMonth, DATE[i][2])
        w32store(st[i], SYSTEMTIME_wDayOfWeek, DATE[i][3])
        w32store(st[i], SYSTEMTIME_wDay, DATE[i][4])
    end for

    VOID = sendMessage(id, MCM_SETSELRANGE, 0, st[1])

    w32release_mem(st[1])

end procedure

--/topic MonthCalendar Control
--/proc setMaxDateRange( id, range )
--/desc Sets the maximum number of days that can be selected.
-- This can only be used with a /MonthCalendar control with style /b MCS_MULTISELECT.
global procedure setMaxDateRange(integer id, integer r)
    VOID = sendMessage(id, MCM_SETMAXSELCOUNT, r, 0)
end procedure

--/topic MonthCalendar Control
--/proc setMonthColor( integer id, object iColor, atom Flag )
--/desc Change color of a /MonthCalendar Control
-- /i Flag must be one of the folowing values:
-- /li /b MCSC_BACKGROUND
-- /li /b MCSC_TEXT
-- /li /b MCSC_TITLEBK
-- /li /b MCSC_TITLETEXT
-- /li /b MCSC_MONTHBK
-- /li /b MCSC_TRAILINGTEXT
global procedure setMonthColor(integer id, object iColor, atom cr)
    VOID = sendMessage(id, MCM_SETCOLOR, cr, colorValue(iColor))
end procedure
r_setMonthColor = routine_id("setMonthColor")

global constant
ShortDate = 0,      -- 7/31/00
LongDate = 1,       -- Monday, July 31, 2000
MediumDate = 2      -- 31-Jul-00

--/topic MonthCalendar Control
--/func formatDate( date, format )
--/desc Format a system date as returned by /getSelectedDate, /getSelectedDateRange
--/ret Formatted date
-- /i format must be one of the following:
-- /li /b ShortDate:    "7/31/00"
-- /li /b MediumDate:   "31-Jul-00"
-- /li /b LongDate:     "Monday, July 31, 2000"
global function formatDate(sequence d, integer f)
sequence result, temp

    d[3] += 1
    if f=ShortDate then
        temp = sprint(d[1])
        result = sprint(d[2]) & "/" & sprint(d[4]) & "/" &
                 temp[length(temp)-1..length(temp)]

    elsif f=LongDate then
        result = Days[d[3]] & ", " & Months[LongMonths][d[2]] &
                 " " & sprint(d[4]) & ", " & sprint(d[1])

    elsif f=MediumDate then
        temp = sprint(d[1])
        result = sprint(d[4]) & "-" & Months[ShortMonths][d[2]] &
                 "-" & temp[length(temp)-1..length(temp)]

    end if

    return result
end function

--/topic MonthCalendar Control
--/func getToday( integer id )
--/desc Returns today's date from the MonthCalendar control /i id
--/ret SEQUENCE: { Year, Month, DayOfWeek , Day}
--
--Example:
--/code
--      sequence td
--      td = getToday( myMC )
--      setText(flddate, {"%02d/%02d/%4d", td[1..3]})
--/endcode

global function getToday(integer id)
atom lSysTime
sequence lToday

    lSysTime = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    lToday = repeat(0, 4)

    if sendMessage(id, MCM_GETTODAY, 0, lSysTime) then

        lToday[1] = w32fetch(lSysTime, SYSTEMTIME_wYear)
        lToday[2] = w32fetch(lSysTime, SYSTEMTIME_wMonth)
        lToday[3] = w32fetch(lSysTime, SYSTEMTIME_wDayOfWeek)
        lToday[4] = w32fetch(lSysTime, SYSTEMTIME_wDay)

    end if

    w32release_mem(lSysTime)
    return lToday
end function


--/topic MonthCalendar Control
--/proc setToday( integer id, integer pYear, integer pMonth, integer pDay )
--/desc Set the 'today' date in the MonthCalendar control /i id
--
--Example:
--/code
--      Set the date to 23rd of November, 2004
--      setToday( myMC , 2004, 11, 23)
--/endcode
global procedure setToday(integer id, integer pYear, integer pMonth, integer pDay)
atom lSysTime

    lSysTime = w32acquire_mem(0, SIZEOF_SYSTEMTIME)
    w32store(lSysTime, SYSTEMTIME_wYear,  pYear)
    w32store(lSysTime, SYSTEMTIME_wMonth, pMonth)
    w32store(lSysTime, SYSTEMTIME_wDay,   pDay)

    VOID = sendMessage(id, MCM_SETTODAY, 0, lSysTime)
    w32release_mem(lSysTime)

end procedure

--/topic Updown Control
--/proc setBuddy( id, buddy )
--/desc Set the buddy control of an /UpDown control /i id to be /i buddy. The buddy
-- control has its text updated when the data in the UpDown control changes.
global procedure setBuddy(integer id, integer buddy)
    VOID = sendMessage(id, UDM_SETBUDDY, getHandle(buddy), 0)
end procedure

sequence vControlSets vControlSets = {}
object vCurrentControlSet vCurrentControlSet = "not set"

--/topic Values
--/func getTabItem(integer id)
--/desc Used to get the current tabitem selected in a tabcontrol
--/ret The control ID of the current tabitem or 0
global function getTabItem(integer id)
integer tabitem

    if validId(id)=0
    or ctrl_Type[id]!=TabControl then
        return 0
    end if

    tabitem = 1+w32Func(xSendMessage, {getHandle(id),TCM_GETCURSEL,0,0})
    if tabitem>0 and tabitem<=length(ctrl_Specific[id]) then
        tabitem = ctrl_Specific[id][tabitem]
    end if

    return tabitem
end function

procedure checkContainersForTabs(integer id)
integer selTab
sequence s
integer idc

    if compare(ctrl_Group[id],{})!=1 then
        return
    end if
    s = ctrl_Group[id]
    for i=1 to length(s) do
        idc = s[i]
        -- control owned by window and containing other controls
        if ctrl_Type[idc]=TabControl then      -- is a tab control
            -- activate the current tab's items
            selTab = getTabItem(idc)
            ctrl_Current_focus[idc] = 0
            if selTab then -- may be 0 if tab control is empty on opening the window
                call_proc(r_activateTabItems, {selTab})
            end if
        end if
        checkContainersForTabs(idc)
    end for
end procedure

-- Added CChris <oedoc@free.fr> Oct 26, 2006
-- This routine takes a control set id, or a set of ids, and sets the group visibility of all the controls therein
integer r_setControlVisible

procedure setTCVisible(integer TC_id,integer flag)
integer tab_id

    if ctrl_Type[TC_id]=TabControl then
        tab_id = getTabItem(TC_id)
    end if
    call_proc(r_setControlVisible,{ctrl_Group[tab_id],flag})
end procedure

procedure setControlVisible(object id,integer flag)
sequence s
integer lId,lFlag

    if atom(id) then
        s = vControlSets[id]
    else
        s = id
    end if
    if flag then
        -- show a window
        lFlag = SW_SHOWNORMAL
    else
        -- hide a window
        lFlag = SW_HIDE
    end if

    for i=1 to length(s) do
        lId = s[i]
        if ctrl_SetVisible[lId]!=flag then
            ctrl_SetVisible[lId] = flag
            VOID = w32Func(xShowWindow, {ctrl_Handle[lId], lFlag})
            if ctrl_Type[lId]=TabControl then
                setTCVisible(lId,flag)
            end if
        end if
    end for
end procedure
r_setControlVisible = routine_id("setControlVisible")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setVisible( object id, atom flag )
--/desc Make /i id visible or invisible.
-- /i id can also be a sequence of control ids. /n
-- Example:
--/code
--          -- make TheButton invisible
--          /setVisible( TheButton, w32False )
--          -- Hide lists one and two.
--          /setVisible( {List1, List2}, w32False )
--          -- Show lists three and four.
--          /setVisible( {List3, List4}, w32True )
--/endcode
--
-- /b Note: If /i object is a /Window being made visible, it will trigger
-- an /Open event. However, if it is a /Window being made invisible, it
-- will not trigger any event. This should probably be corrected.

global procedure setVisible(object id, atom flag)
integer lFlag
    if flag then
        -- show a window
        lFlag = SW_SHOWNORMAL
    else
        -- hide a window
        lFlag = SW_HIDE
    end if

    if sequence(id) then
        for i=1 to length(id) do
            setVisible(id[i], flag)
        end for
        return
    elsif not validId(id) then
        return
    else
        ctrl_Visible[id] = flag
        if ctrl_SetVisible[id] then
            VOID = w32Func(xShowWindow, {getHandle(id), lFlag})
            if ctrl_Type[id]=TabControl then
                setTCVisible(id,flag)
            end if
        end if
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setEnable( object id, atom flag )
--/desc Enable or disable /i id.
-- /i id can be a sequence of control ids.
-- Use the MF_ENABLED value in /i flag to enable a menu or menu item, and anything else to disable it. For other controls, a value of 0 disables and any other enables.
--
-- Example:
--/code
--          -- disable TheButton
--          /setEnable( TheButton, w32False )
--          -- Disable lists one and two.
--          /setEnable( {List1, List2}, w32False )
--          -- Enable lists three and four.
--          /setEnable( {List3, List4}, w32True )
--/endcode

global procedure setEnable(object id, atom flag)
-- enable/disable an item
sequence lKids
atom lHandle
integer lControl
object lColor

    if sequence(id) then
        for i=1 to length(id) do
            setEnable(id[i], flag)
        end for
        return
    end if


    lHandle = getHandle(id)
    if ctrl_Family[id]=MENU
    or ctrl_Family[id]=MENUITEM then

        -- convert the flag
        flag = w32iff(flag, MF_ENABLED, w32or_all({MF_DISABLED, MF_GRAYED}))

        -- enable/disable the menu
        if w32Func(xEnableMenuItem, {
                                     lHandle,       -- menu handle
                                     id,                    -- id
                                     flag})=#FFFFFFFF       -- enable/disble
        then
            -- item does not exist
            warnErr(Err_SETENABLE)
        end if

        -- if menubar, need to redraw
        if ctrl_Family[id]=MENU then
            VOID = w32Func(xDrawMenuBar, {ctrl_Parent[id]})
        end if

    elsif ctrl_Family[id]=BUTTON
      and ctrl_Type[ctrl_Parent[id]]=FlatToolBar then
        flag = sendMessage(ctrl_Parent[id], TB_ENABLEBUTTON, id, flag)

    else
        if find(ctrl_Type[id],{FlatToolBar, ToolBar}) then
            lKids = findChildren(id)
            for i=1 to length(lKids) do
                setEnable(lKids[i][1], flag)
            end for
        end if
        -- enable/disable the window
        w32Proc(xEnableWindow, {lHandle, flag})

        -- Show visualisation of enabled/disabled control
        if flag=0  then
            lControl = findParent(id)
            if lControl and not and_bits(classAttr[ctrl_Type[id]], w32NoRenderDisabled) then
                lColor = ctrl_Bg_Color[lControl]
                lControl = sequence(lColor)
                setBackground(id, lControl,lColor)
            end if
        else
            lControl = ctrl_Type[id]
            if equal(classBGColor[lControl], w32BGTransparent) then
                if findParent(id)=0 then
                    lControl = id
                else
                    lControl = findParent(id)
                end if
                setWindowBackColor(id, ctrl_Bg_Color[lControl])
            else
                setWindowBackColor(id, classBGColor[lControl])
            end if

        end if

    end if

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/func isEnabled( integer id )
--/desc Returns the enabled state of /i object.
--/ret INTEGER: Zero if no enabled, Non-zero if enabled.
-- /b Note: A TabItem is always enabled.
-- Example:
--/code
--          -- is TheButton enabled?
--          integer flag
--
--          flag = /isEnabled( TheButton )
--/endcode
global function isEnabled(integer id)

    -- return enabled state of control
--  atom result
    if not validId(id) then
        return w32False
    end if


    if ctrl_Family[id]=MENU
    or ctrl_Family[id]=MENUITEM then
        -- true if not disabled
        return not and_bits(getMenuState(id), MF_DISABLED)

    elsif ctrl_Type[id]=TabItem then
        -- always enabled
        return w32True

    else
        -- control
        return (w32Func(xIsWindowEnabled, {getHandle(id)})!=0)

    end if

end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func isMinimized( object )
--/desc Used to see if the window /i object is minimized (iconic) or not.
-- Example:
--/code
--          -- Restore a minimized window?
--          if isMinimized( myWindow ) then
--             /showWindow( myWindow, SW_RESTORE)
--          end if
--/endcode
global function isMinimized(integer id)

    -- return enabled state of control
--  integer result

    if   validId(id)
    and ctrl_Family[id]=WINDOW  then
        -- true if minimized, false otherwise
        return (w32Func(xIsIconic, {getHandle(id)})!=0)
    else
        return 0
    end if

end function

-----------------------------------------------------------------------------
--/topic Attributes
--/func isMaximized( object )
--/desc Used to see if the window /i object is maximized (zoomed) or not.
-- Example:
--/code
--          -- Restore a maximized window?
--          if isMaximized( myWindow ) then
--             /showWindow( myWindow, SW_RESTORE)
--          end if
--/endcode
global function isMaximized(integer id)

    -- return enabled state of control
--  integer result

    if   validId(id)
    and ctrl_Family[id]=WINDOW  then
        -- true if minimized, false otherwise
        return (w32Func(xIsZoomed, {getHandle(id)})!=0)
    else
        return 0
    end if

end function

--/topic Menus
--/proc defineMenuRadioGroup( sequence ids)
--/desc Defines a set of menu items that form a radio-group
-- /i ids is a list of menuitems that form a logical group of items,
-- in which only one can be marked witha 'radio-button' icon. /n
-- This routine ensures that only one item from the group will be
-- marked. Any that were previously marked will be 'turned off'
--
-- Note 1. The items do not have to be in the same menu. /n
-- Note 2. A given menu item can only be in one radio group.
--
-- Example:
--/code
--      -- set the current loudness level.
--      /defineMenuRadioGroup({miPianissimo, miPiano, piModerato,
--                             miForte, miFortissimo})
--      . . .
--      /setCheck( miForte, w32True)
--      -- now, all items of the same group are unchecked, except for miForte
--/endcode
sequence vMenuItemGroups vMenuItemGroups = {}
global procedure defineMenuRadioGroup(sequence ids)
integer x
    if length(ids)=0 then
        return
    end if

    -- Ensure that only valid menuitems are supplied.
    -- and remove all the ids from existing groups.
    for i=1 to length(ids) do
        if validId(ids[i]) and find(ctrl_Type[ids[i]], {MenuItem, MenuSpacer}) then
            for j=1 to length(vMenuItemGroups) do
                x = find(ids[i], vMenuItemGroups[j])
                if x!=0 then
                    vMenuItemGroups[j] = w32removeIndex(x, vMenuItemGroups[j])
                end if
            end for
        end if
    end for

    -- Delete any empty groups
    for i=1 to length(vMenuItemGroups) do
        if length(vMenuItemGroups[i])=0 then
            vMenuItemGroups = w32removeIndex(i, vMenuItemGroups)
        end if
    end for

    -- Add this new group
    vMenuItemGroups = append(vMenuItemGroups, ids)
end procedure

-----------------------------------------------------------------------------
--/topic Values
--/proc setCheck( object id, checked flag )
--/desc Check or uncheck /i id.
-- This works for /MenuItems and toggle controls
-- such as /Radio, /CheckBox and /ToggleButton, and for ListViews
--
--Note that /i id can be either a single control id or
-- a list of control ids.
--
-- Example:
--/code
--      -- set a check on the SyntaxColoring option
--      /setCheck( SyntaxColoring, w32True )
--      /setCheck( {TBtn1, TBtn2, TBtn3}, w32False)
--/endcode
--
-- /b Note: For ListViews, the /i id is actually in the form {{id,row}}
-- so it knows which row to check. Take note of the double sequence syntax.
--/code
--      -- Add a check mark to row 2.
--      /setCheck( {{myLV, 2}}, w32True)
--/endcode
--
-- /b Note If /i id is a menu item which has been defined as being in
-- a menu item group (/defineMenuItemGroup), this routine turns on that
-- menu item.
-- This routine ensures that only one item from a menu radio group will be
-- marked. Any that were previously marked will be 'turned off'
--
-- Example:
--/code
--      -- set the current loudness level.
--      /defineMenuRadioGroup({miPianissimo, miPiano, piModerato,
--                             miForte, miFortissimo})
--      . . .
--      /setCheck( miForte, w32True)
--/endcode


global procedure setCheck(object  pControls, integer flag)
atom hMII
atom lType
integer id
integer row
atom TV_ITEM, state, mask

    if not sequence(pControls) then
        pControls = {pControls}
    end if

    for k=1 to length(pControls) do
        if sequence(pControls[k]) then
            row = pControls[k][2]
            pControls[k] = pControls[k][1]
        end if

        id = pControls[k]

        if ctrl_Family[id]=MENU
        or ctrl_Family[id]=MENUITEM then
            hMII = 0
            -- First check for Radio Group membership
            for i=1 to length(vMenuItemGroups) do
                if find(id, vMenuItemGroups[i]) then
                    -- First turn off all other items
                    if hMII=0 then
                        hMII = w32to_memory(0,ID_MENUITEMINFO,0)
                    end if

                    for j=1 to length(vMenuItemGroups[i]) do
                        w32store(hMII, MENUITEMINFO_fMask,MIIM_STATE)
                        w32store(hMII, MENUITEMINFO_fState, MFS_UNCHECKED)
                        VOID = w32Func(xSetMenuItemInfo, {
                                                          getHandle(vMenuItemGroups[i][j]),
                                                          vMenuItemGroups[i][j],
                                                          0, hMII})
                    end for

                    -- Turn the selected item on, if required to.
                    if flag then
                        -- Get the current fType bits
                        w32store(hMII, MENUITEMINFO_fMask,w32or_all({MIIM_FTYPE}))
                        VOID = w32Func(xGetMenuItemInfo, {
                                                          getHandle(id),
                                                          id,
                                                          0, hMII})
                        lType = w32fetch(hMII, MENUITEMINFO_fType)
                        -- Set the new state and type.
                        w32store(hMII, MENUITEMINFO_fMask,w32or_all({MIIM_STATE,
                                                                     MIIM_FTYPE}))
                        w32store(hMII, MENUITEMINFO_fState, MFS_CHECKED)
                        w32store(hMII, MENUITEMINFO_fType,
                                 or_bits(lType, MFT_RADIOCHECK))
                        VOID = w32Func(xSetMenuItemInfo, {
                                                          getHandle(id),
                                                          id,
                                                          0, hMII})
                    end if
                    w32release_mem(hMII)
                    return
                end if
            end for

            -- convert the flag
            flag = w32iff(flag, MF_CHECKED, MF_UNCHECKED)

            -- set the check in the menu
            if w32Func(xCheckMenuItem, {
                                        getHandle(id),      -- owner's menu handle
                                        id,                     -- use the id
                                        flag})=#FFFFFFFF        -- check/uncheck
            then
                -- item does not exist
                warnErr(Err_SETCHECK)
            end if

            -- if menubar, need to redraw
            if ctrl_Family[id]=MENU then
                VOID = w32Func(xDrawMenuBar, {ctrl_Parent[id]})
            end if

        elsif ctrl_Type[id]=ListView then
            setLVChecked(id, row, flag)

        elsif ctrl_Type[id]=TreeView then
            mask = w32or_all({TVIF_HANDLE, TVIF_STATE})
            if flag then
                state = TVIS_SELECTED_MASK
            else
                state = TVIS_DESELECTED_MASK
            end if

            TV_ITEM = w32to_memory(0,ID_TVITEM, {mask, tvitem_handle[row], state, TVIS_STATEIMAGEMASK})
            VOID = sendMessage(id, TVM_SETITEM, 0, TV_ITEM)
            w32release_mem(TV_ITEM)

        else

            -- toggle the control
            if id!=Screen then
                VOID = sendMessage(id, BM_SETCHECK, flag, 0)
            end if
        end if
    end for

end procedure

-----------------------------------------------------------------------------
--/topic Values
--/func isChecked( object id )
--/ret INTEGER: w32True or w32False
--/desc Gets the checked state of /i id.
--
-- This can be used on MenuItems, ListView, TreeView, Radio, and Checkboxes.
--
-- /b Note for TreeView, the /i id takes the form {id, item} /n
--
-- /b Note for ListViews, the /i id normally takes to form {id, row}.
-- But if you just use /i id, then the row with focus is examined.
--
-- Example:
--/code
--          integer flag
--
--          -- is TheRadio1 checked?
--          flag = /isChecked( TheRadio1 )
--          -- Is row 3 checked.
--          flag = isChecked ({myLV, 3})
--/endcode

global function isChecked(object pId)
atom lRes
integer id
integer row
atom TV_ITEM, state, mask

    -- return checked state of control

    if sequence(pId) then
        row = pId[2]
        id = pId[1]
    else
        id = pId
        if ctrl_Type[id]=ListView then
            row = 1+sendMessage(id, LVM_GETHOTITEM, 0, 0)
        end if
    end if

    if ctrl_Family[id]=MENU
    or ctrl_Family[id]=MENUITEM then

        -- true if not disabled
        lRes = and_bits(getMenuState(id), MF_CHECKED)
    elsif ctrl_Type[id]=ListView then
        lRes = getLVChecked(id, row)

    elsif ctrl_Type[id]=TreeView then
        lRes = 0
        if row then
            mask = w32or_all({TVIF_HANDLE, TVIF_STATE})

            TV_ITEM = w32to_memory(0,ID_TVITEM,{mask,tvitem_handle[row],0,TVIS_STATEIMAGEMASK})

            VOID = sendMessage(id, TVM_GETITEM, 0, TV_ITEM)
            state = w32fetch(TV_ITEM, TVITEM_state)
            w32release_mem(TV_ITEM)

            lRes = and_bits(state , TVIS_SELECTED_MASK)
        end if
    else
        -- controls
        lRes = sendMessage(id, BM_GETCHECK, 0, 0)

    end if

    return (lRes!=0)
end function
r_isChecked = routine_id("isChecked")

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc limitText( object, size )
--/desc Limits the amount of text a user can enter into an Edit control.
-- Example:
--/code
--      aTextBox = create( EditText, "", aWindow, x1, y1, width1, height1, 0 )
--      aEditor  = create( RichEdit, "", aWindow, x2, y2, width2, height2, 0 )
--      limitText( aTextBox, 50 )   -- No more than 50 characters allowed.
--      limitText( aEditor, 50000 ) -- No more than 50,000 characters allowed.
--
--/endcode
global procedure limitText(integer id, integer pSize)
atom lMsgType
   -- Limit the amount of text the user can enter.
    if validId(id) then
        if find(ctrl_Type[id], {EditText, MleText, RichEdit})!=0 then
            if ctrl_Type[id]=RichEdit
            and
               pSize>=#10000 then -- 64K
                lMsgType = EM_EXLIMITTEXT
                VOID = sendMessage(id, lMsgType, NULL , pSize)
            else
                lMsgType = EM_LIMITTEXT
                VOID = sendMessage(id, lMsgType, pSize, NULL)
            end if
        end if
    end if
end procedure
--/topic Attributes
--/func canFocus( object id, integer Flag )
--/ret OBJECT: Current canFocus status.
--/desc Turns on and off a control's CanFocus property.
-- If /i flag is /b w32True, the control /i id is set to have CanFocus,
-- otherwise it is set off. The default for controls is /b on.
--
-- /i id can be either a single control id or a list of ids in a sequence.
--
-- If /i id is a single control id, then the return value is a integer. /n
-- If /i id is a sequence of controls, then the return value is a sequence
-- containing one status flag per control referenced in /i id.
--
-- CanFocus means that when the control gets focus, and if its CanFocus
-- property is /b off, then the focus is not set.
--
-- If any of the supplied ids are not managed by win32lib, no action is taken and the
-- returned status for this id is -1.
--
-- Using w32GetValue as an atom or in a sequence will cause the corresponding id to be left alone: its current CanFocus property is simply returned. /n
-- Example:
--/code
--      -- disallows two controls from getting focus, and retrieving their current status.
--      sequence asv
--      asv = canFocus({fldName, fldAddress}, w32False)
--/endcode
global function canFocus(object id, integer pFlag)
object lReturnVal
integer lSingle

    lSingle = atom(id)
    if lSingle then
        id = {id}
    end if
    lReturnVal = repeat(-1,length(id))

    -- Standardise the flag value to w32True or w32False.
    if pFlag!=w32False and pFlag!=w32GetValue then
        pFlag = 2
    end if

    if pFlag!=w32GetValue then
        for i=1 to length(id) do
            if validId(id[i]) then
                lReturnVal[i] = ctrl_CanFocus[id[i]]
                ctrl_CanFocus[id[i]] = pFlag
            else
                lReturnVal[i] = -1
            end if
        end for
    else
        for i=1 to length(id) do
            if validId(id[i]) then
                lReturnVal[i] = ctrl_CanFocus[id[i]]
            else
                lReturnVal[i] = -1
            end if
        end for
    end if

    if lSingle then
        return lReturnVal[1]
    else
        return lReturnVal
    end if

end function

-----------------------------------------------------------------------------
--/topic System Attributes
--/proc classAutoSelect( object type, integer Flag )
--/desc Turns on and off edit controls' default auto-selection property.
-- If /i flag is /b w32True, controls of /i type are set to have Auto-Selection,
-- otherwise they do not have Auto-Selection behaviour by default when created.
--
-- /i type can be either a single control type or a list of types in a sequence.
--
-- Auto-selection means that when the edit control gets focus, all its contents
-- is selected automatically for you.
--
-- Example:
--/code
--      -- Set the default for EditText fields.
--      classAutoSelect(EditText, w32True)
--/endcode
global procedure classAutoSelect(object pType, integer pFlag)
--  sequence lAutoSelect

    if atom(pType) then
        pType = {pType}
    end if

    -- Standardise the flag value to w32True or w32False.
    pFlag = not equal(pFlag,0)

    for i=1 to length(pType) do
        if find(pType[i], {EditText, MleText, RichEdit}) then
            if pFlag then
                classAttr[pType[i]] = or_bits(classAttr[pType[i]], w32AutoSelect)
            else
                classAttr[pType[i]] = and_bits(classAttr[pType[i]], not_bits(w32AutoSelect))
            end if
        end if
    end for

end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc cut( object )
--/desc Cut any selected text from /i object and place in the clipboard.
-- Example:
--/code
--          -- cut text from TheTextEdit
--          /cut( TheTextEdit )
--/endcode

global procedure cut(integer id)

    -- send a cut request to a window
    VOID = sendMessage(id, WM_CUT, 0, 0)
end procedure


-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc copy( object )
--/desc Copy any selected text from /i object and place in the clipboard.
-- Example:
--/code
--          -- copy text from TheTextEdit into the clipboard
--          /copy( TheTextEdit )
--/endcode

global procedure copy(integer id)

    -- send a copy request to a window
    VOID = sendMessage(id, WM_COPY, 0, 0)

end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc paste( object )
--/desc Paste text from the clipboard to /i object.
-- Example:
--/code
--          -- paste text from clipboard to TheTextEdit
--          /paste( TheTextEdit )
--/endcode

global procedure paste(integer id)

    -- send a paste request to a window
    VOID = sendMessage(id, WM_PASTE, 0, 0)
end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc clear( object )
--/desc Clear selected text from /i object.
-- Example:
--/code
--          -- clear selected text in TheTextEdit
--          /clear( TheTextEdit )
--/endcode

global procedure clear(integer id)

    -- send a clear request to a window
    VOID = sendMessage(id, WM_CLEAR, 0, 0)

end procedure


-----------------------------------------------------------------------------
--/topic Edit Controls
--/proc undo( object )
--/desc Undo last edit in /i object.
-- Example:
--/code
--          -- undo last edit in TheTextEdit
--          /undo( TheTextEdit )
--/endcode

global procedure undo(integer id)

    -- send a undo request to a window
    VOID = sendMessage(id, WM_UNDO, 0, 0)

end procedure

--/topic Utilities
--/func setClipboard(object data,integer format,integer is_handle,integer size)
--/desc Sets the clipboard to /i data using the other parameters.
--/ret w32False on failure, w32True on success.
-- /i format is a <a href="..\win32_constants#Clipboard formats">clipboard format</a>, for instance CF_TEXT.
-- The way /i data is interpreted depends on the other parameters:
-- If /i data is a sequence, and the format is any of CF_TEXT, CF_DSPTEXT, CF_OEMTEXT, CF_UNICODETEXT, then the procedure takes care of all the memory work, and /i is_handle is ignored.
-- Otherwise, if is_handle is nonzero, it means that /i data is a Window memory handle.
-- You may have acquired it through /w32acquire_handle().
-- Otherwise, /i data points to the data you wish to send, and /i size is the size of the data buffer.
-- For the CF_DIB and CF_PALETTE format, the routine is able to figure /i size out, and will do so if /i size is 0. Other formats may be supported in this way in the future.
-- For the CF_BITMAP, private GDI formats, and  formats, the only allowable value /i data may have is a handle, so that /i is_anndle and /i size are both ignored.
-- If you provide a handle, you no longer own this handle on return.
global function setClipboard(object data,integer format,integer is_handle,integer size)
integer textformat,uflag,oddlen,bitsize,bi_mode
atom handle,ptr
sequence s

    textformat = find(format,{CF_TEXT, CF_OEMTEXT, CF_UNICODETEXT})
    if not textformat and sequence(data) then
        return w32False  -- not allowed
    end if

    if textformat and sequence(data) then
        size = length(data)
        uflag = (format=CF_UNICODETEXT)
        if uflag then
            size *= 2
        end if
        handle = w32acquire_handle(size+1+uflag,GMEM_MOVEABLE)
        ptr = w32handle_to_memory(handle)
        if not uflag then
            poke(ptr,data)
        else
            w32poke_words(ptr,data)
            poke(ptr+size+1,0)
        end if
        poke(ptr+size,0)
        w32release_handle(handle,0) -- just unlock it
    elsif is_handle then -- we got a handle
    else
        if format=CF_PALETTE and not size then
            -- compute size
            s = peek({data+2,2})
            size = 4*(1+s[1]+256*s[2])
        elsif format=CF_DIB and not size then
            bi_mode = w32fetch(data,biCompression)
            bitsize = w32fetch(data,biSizeImage)
            if bi_mode=BI_RGB and bitsize=0 then
            -- compute size
                -- number of lines
                oddlen = w32fetch(data,biHeight)
                if oddlen<0 then
                    oddlen = -oddlen
                end if
                -- line length in bits
                uflag = w32fetch(data,biWidth)*w32fetch(data,biBitCount)
                -- lines are padded to an integer number of bytes
                if and_bits(uflag,31) then
                    uflag = floor(uflag/8)+4
                else
                    uflag /= 8
                end if
                -- size in bytes of the bitmap bits
                bitsize = uflag*oddlen
            end if
            -- total structure size, minus...
            size = SIZEOF_BITMAPINFOHEADER+bitsize
            -- ... the color table
            uflag = w32fetch(data,biClrUsed)
            if uflag=0 then
                bi_mode = w32fetch(data,biBitCount)
                if bi_mode<=8 then
                    uflag = power(2,bi_mode)
                end if
            end if
            size += 4*uflag
        end if
        handle = w32acquire_handle(size,GMEM_MOVEABLE+GMEM_DDESHARE)
        ptr = w32handle_to_memory(handle)
        mem_copy(ptr,data,size)
        w32release_handle(handle,0) -- just unlock it
    end if

    -- now we have a valid object
    if not w32Func(xOpenClipboard,{0}) then
        warnErr("Unable to open clipboard")
        return w32False
    end if
    VOID = w32Func(xEmptyClipboard,{})
    if not w32Func(xSetClipboardData,{format,data}) then
        warnErr("Unable to store data into clipboard")
        return w32False
    end if
    VOID = w32Func(xCloseClipboard,{})
    return w32True
end function

--/topic Utilities
--/func getClipboard(integer format)
--/desc Retrieves data in the clipboard with this format
--/ret (OBJECT) Either a string for text formats, or a data handle otherwise.
-- If getting a data handle, you should not free it, and copy the referred contents to some other place, because you do not own the returned handle.
global function getClipboard(integer format)
atom result,ptr
integer nottext
sequence text

    if not w32Func(xOpenClipboard,{0}) then
        warnErr("Unable to open clipboard")
        return w32False
    end if

    result = w32Func(xGetClipboardData,{format})
    nottext = find(format,{CF_TEXT,CF_OEMTEXT,CF_UNICODETEXT})
    if not result then
        if nottext then
            return 0
        else
            return ""
        end if
    end if
    -- we got something
    if nottext then
        return result
    else -- get string
        ptr = w32handle_to_memory(result)
        if format!=CF_UNICODETEXT then
            text = w32peek_string(ptr)
        else
            text = w32peek_string16(ptr)
        end if
        w32release_handle(result,0)
        return text
    end if
end function

-----------------------------------------------------------------------------
-- LISTS
--
-----------------------------------------------------------------------------
--/topic List Control
--/proc addItem( integer control, sequence text )
--/desc Add /i text to the end of /i control's list.
--
-- see also: /insertItem()
--
-- Example:
--/code
--          -- add "Apples" to TheList
--          /addItem( TheList, "Apples" )
--
--          -- add fruit list to TheList
--          /addItem( TheList, {"Oranges", "Pears", "Bananas", "Mangoes" })
--/endcode
--
-- addItem is also used to add items to ComboBoxEx controls by packing
-- several params into text.
-- Example:
--/code
--          -- add "Apples" to TheListEx with unselected image
--          -- i1 and selected image i2 where, i1 and i2
--          -- were values returned from /addIcon()
--          /addItem( TheListEx, {"Apples", i1, i2})
--          /addItem( TheListEx, {
--                                {"Oranges", i3, i2},
--                                {"Pears",   i4, i2},
--                                {"Bananas", i5, i2},
--                                {"Mangoes", i6, i2}
--                               })
--/endcode
--
-- See also /"Image Lists" for details on using images
global procedure addItem(integer id, sequence pTextItems)
-- add an item to a list

sequence text, lMsgCodes
integer msg, lBufsz
atom hWnd, flags
atom cbi, pstr
integer lPos,idx

    if   ctrl_Type[id]=ComboBoxEx then

        if length(pTextItems)=3 and
           sequence(pTextItems[1]) and
           atom(pTextItems[2]) and
           atom(pTextItems[3])
        then
            pTextItems = {pTextItems}
        end if

        -- Find longest text item
        lBufsz = 0
        for i=1 to length(pTextItems) do

            if atom(pTextItems[i]) then
                pTextItems[i] = sprintf("%g", pTextItems[i])
            end if

            if length(pTextItems[i])!=3 or
               atom(pTextItems[i][1]) or
               sequence(pTextItems[i][2]) or
               sequence(pTextItems[i][3])
            then
                warnErr(sprintf("Parameter %d to ComboboxEx is not valid",i))
                return
            end if

            if lBufsz<length(pTextItems[i][1]) then
                lBufsz = length(pTextItems[i][1])
            end if
        end for

        -- Grab enough RAM for the text string conversion.
        pstr = w32acquire_mem(0, lBufsz)
        -- Get the windows handle for this control
        hWnd = getHandle(id)

        cbi = w32acquire_mem(0, SIZEOF_COMBOBOXEXITEM)
        for i=1 to length(pTextItems) do

            text = pTextItems[i]
            -- convert the text sequence to a 'C'-style string
            poke(pstr, text[1])

            w32store(cbi, COMBOBOXEXITEM_iItem, -1)
            w32store(cbi, COMBOBOXEXITEM_pszText, {{},{pstr, length(text[1])}})

            flags = CBEIF_TEXT

            if text[2] then
                idx = text[2]
                if ctrl_ImageList[id]!=hILsmall then
                    idx = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[idx]})
                else
                    idx -= 1
                end if
                w32store(cbi, COMBOBOXEXITEM_iImage, idx)
                flags = or_bits(flags, CBEIF_IMAGE)
            end if

            if text[3] then
                idx = text[3]
                if ctrl_ImageList[id]!=hILsmall then
                    idx = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[idx]})
                else
                    idx -= 1
                end if
                w32store(cbi, COMBOBOXEXITEM_iSelectedImage, idx)
                flags = or_bits(flags, CBEIF_SELECTEDIMAGE)
            end if

            w32store(cbi, COMBOBOXEXITEM_mask, flags)

            lPos = w32Func(xSendMessage, {hWnd, CBEM_INSERTITEM, 0, cbi})
            if lPos>=0 then
                VOID = invokeHandler(id, w32HDataChange, {w32CHG_Add, lPos+1})
            end if
        end for

        w32release_mem(cbi)
        w32release_mem(pstr)

        return
    end if

    -- what control is it?
    lMsgCodes = {0, LB_ADDSTRING, CB_ADDSTRING}
    msg = lMsgCodes[find(ctrl_Family[id], {LISTBOX, COMBO})+1]
    if msg=0 then
        -- This routine doesn't apply to this type of control.
        return
    end if

    -- Convert a single text sequence into a list of text sequences
    if length(pTextItems)=0 or atom(pTextItems[1]) then
        pTextItems = {pTextItems}
    end if

    -- Find longest text item
    lBufsz = 0
    for i=1 to length(pTextItems) do
        if atom(pTextItems[i]) then
            pTextItems[i] = sprintf("%g", pTextItems[i])
        end if
        if lBufsz<length(pTextItems[i]) then
            lBufsz = length(pTextItems[i])
        end if
    end for

    -- Grab enough RAM for the text string conversion.
    pstr = w32acquire_mem(0, 1+lBufsz)
    -- Get the windows handle for this control
    hWnd = getHandle(id)

    -- add each item to the list.
    for i=1 to length(pTextItems) do
        -- convert the text sequence to a 'C'-style string
        poke(pstr, pTextItems[i])
        poke(pstr+length(pTextItems[i]), 0)
        -- send the 'add' message
        lPos = w32Func(xSendMessage, {hWnd, msg, 0, pstr})
        if lPos!=LB_ERR and lPos!=LB_ERRSPACE then
            lPos = invokeHandler(id, w32HDataChange, {w32CHG_Add,  lPos+1})
        end if
    end for

    -- Free the string RAM
    w32release_mem(pstr)

end procedure

-----------------------------------------------------------------------------
--/topic List Control
--/func insertItem( integer list, sequence text, integer position )
--/desc Insert /i text into /i list at /i position.
--/ret INTEGER: The position actually used by Windows. Zero is returned if it fails.
-- The /i position starts at 1, but if you use zero, it adds it to the
-- end of the list.
--
-- see also: /addItem()
--
-- Example:
--/code
--          -- insert "Bananas" at position 2 in TheList
--          /insertItem( TheList, "Bananas", 2 )
--          -- insert "Mangoes" to the end of TheList
--          /insertItem( TheList, "Mangoes", 0 )
--/endcode

global function insertItem(integer id, sequence text, integer pos)

-- inserts string to list

integer msg, posn
atom pstr

-- get the message, based on control type
    if    ctrl_Family[id]=LISTBOX  then
        msg = LB_INSERTSTRING
    elsif ctrl_Family[id]=COMBO    then
        msg = CB_INSERTSTRING
    else
        return 0
    end if

    -- send a message; subtract because it's zero based
    pstr = w32acquire_mem(0, text)
    posn = sendMessage(id, msg, pos-1, pstr)
    if posn=LB_ERR or posn=LB_ERRSPACE then
        posn = -1
    else
        VOID = invokeHandler(id, w32HDataChange, {w32CHG_Add, posn+1})
    end if
    -- Free the string
    w32release_mem(pstr)

    -- return position
    return posn+1

end function

-----------------------------------------------------------------------------
--/topic List Control
--/func setListHScroll(integer id)
--/desc Recalculates the size of a horizontal scroll bar on a listbox.
--/ret INTEGER: The length, in characters, of the longest item in the list.
--Note that it returns -1 if the /i id used is not a list box.
-- Example:
--/code
--      -- Redraw the horizontal scroll bar
--      res = setListHScroll(mylist)
--/endcode

global function setListHScroll(atom id)
integer lLongest
integer lWidth
sequence lExtent
integer lCount
sequence lText
sequence lLongText

-- Set the horizontal scroll trigger for List Boxes.
    if ctrl_Family[id]!=LISTBOX then
        return -1
    end if

    lCount = getCount(id)
    if lCount=0 then
        return 0
    end if

    lLongest = -1

    for i=1 to lCount do
        lText = call_func(r_getItem,{id, i})
        if length(lText)>lLongest then
            lLongText = lText
            lLongest = length(lText)
        end if
    end for

    lWidth = getTextWidth(id, '_' & lLongText)
    lExtent = getCtlSize(id)
    if lWidth<lExtent[2] then
        return lLongest
    end if

    -- Ensure that it has a scroll bar

    addStyle(id, WS_HSCROLL)

    VOID = sendMessage(id,LB_SETHORIZONTALEXTENT,lWidth, 0)

    return lLongest
end function


--/topic Controls
--/func getEdit( integer ComboId )
--/desc Get the control id of the /i ComboId control's edit box.
--/ret INTEGER: The EditBox control Id. Zero if the /i ComboId is not a type of combo box.
--A combo box is made up of two parts, a listbox and an editbox. The editbox is
-- normally never directly used as it is handled by Windows. However, it is sometimes
-- useful for your application to handle the editbox's events directly. /n
--The control id for the editbox is automatically assigned by Win32lib when the
-- combobox is created. This function is used to fetch it.
--
-- Example:
--/code
--  procedure keytrap(integer self, integer event, sequence parms)
--      if parms[1] = VK_ESCAPE then
--         -- move to the first item.
--         setIndex(getParent(self), 1)
--      elsif parms[1] = VK_ENTER then
--         -- Ignore the Enter key
--         returnValue(-1)
--      end if
--  end procedure
--  setHandler(getEdit(MyCombo), w32HKeyPress, routine_id("keytrap"))
--/endcode

global function getEdit(integer id)
    if ctrl_Family[id]=COMBO
    or ctrl_Type[id]=ComboBoxEx then
        return find(id, ctrl_Parent)
    else
        return 0
    end if
end function
r_getEdit = routine_id("getEdit")

-----------------------------------------------------------------------------
--/topic List Control
--/func getIndex( list )
--/desc Get the index of the selected item(s), or cursor position in an edit control.
--/ret INTEGER: Index of selected item, or zero if no item is selected.
-- For ListView and TreeView, this returns a sequence of all selected items.
--
-- For MleEdit, EditText and RichEdit, this returns the cursor position.
--
-- For Combos this returns
--
-- For List, this returns the index of the currently selected item.
--
-- For Window, VScroll, HScroll, VTrackBar, HTrackBar, ProgressBar, UpDown this
-- returns the current scroll position.
--
-- Example:
--/code
--          -- get index of selected item in TheList
--          integer index
--          index = getIndex( TheList )
--
--          integer CPos
--          CPos = getIndex( myRichEdit )
--/endcode

global function getIndex(atom id)

-- get index of selected list item

atom msg
atom CR
--  sequence selections

    -- get the message, based on control type
    if      ctrl_Family[id]=LISTBOX then
        msg = LB_GETCURSEL

    elsif   ctrl_Family[id]=COMBO
       or ctrl_Type[id]=ComboBoxEx then
        msg = CB_GETCURSEL

    elsif ctrl_Type[id]=RichEdit
       or  ctrl_Family[id]=EDIT then
        CR = w32to_memory(0,ID_CHARRANGE,0)
        VOID = sendMessage(id, EM_GETSEL, CR, CR+4)
        msg = w32fetch(CR, CHARRANGE_cpMin)+1
        w32release_mem(CR)
        return msg

    elsif ctrl_Type[id]=ListView then
        return getLVSelected(id)

    elsif find(ctrl_Type[id],{Window,VScroll,HScroll,VTrackBar,HTrackBar,ProgressBar,UpDown}) then
        return call_func(r_getScrollPos,{id})

    elsif ctrl_Type[id]=TreeView then
        return getTVIndex(id)
    else
        return 0
    end if

    return sendMessage(id, msg, 0, 0)+1

end function
r_getIndex = routine_id("getIndex")

--/topic Edit controls
--/topic RichEdit controls
--/func getSelection( RE )
--/desc Gets the character range of any selected text.
--/ret A sequence {first, last} of the characters selected.
-- Example:
--/code
--          -- Find out what is selected
--          sequence posn
--
--          posn = /getSelection( myRE )
--/endcode
global function getSelection(atom id)

-- get selected text range

sequence msg
atom CR

    if validId(id)=w32True
    and (ctrl_Type[id]=RichEdit or ctrl_Family[id]=EDIT) then
        CR = w32to_memory(0,ID_CHARRANGE, 0)
        VOID = sendMessage(id, EM_GETSEL, CR, CR+4)
--      msg = {w32fetch(CR, CHARRANGE_cpMin),   w32fetch(CR, CHARRANGE_cpMax)} + 1
        msg = {w32fetch(CR,CHARRANGE_cpMin)+1, w32fetch(CR,CHARRANGE_cpMax)+1}
        w32release_mem(CR)
        return msg
    else
        return {0, 0}
    end if
end function

-----------------------------------------------------------------------------
--/topic List Control
--/proc setIndex( atom list, object index )
--/desc Set the selected item on the list to /i index.
-- This is used for Lists, Combo, and Treeview controls.
--
-- Use 0 to set the index to 'unselected.' /n
-- Use -1 to set the index to the last item. /n
-- /b Note that if /i index is greater than the number of items in the list
-- then the last item will be selected.
-- If the list has the LBS_MULTIPLESEL style, you can use a triple {start,end,state}
-- as index. The state is 1 to select the range, 0 to deselect. The start and end values
-- are included in the range.
--
-- Example:
--/code
--          -- select the first item on the list
--          /setIndex( TheList, 1 )
--          -- select the last item on the list
--          /setIndex( TheList, -1 )
--
--          -- deselect all items in the treeview
--          /setIndex( MyTreeView, 0)
--/endcode

--/topic RichEdit controls
--/proc setIndex( atom list, object index )
--/desc Select characters in the control. /n
-- This is used for Edit and RichEdit controls. /n
-- /i index is either
--/li a single integer: the position you are setting the insertion point (caret) at, cancelling any current selection;
-- If the value is 0 or less, the caret blinks at the end of the text.
--/li a two-element sequence in the form {first selected char index, first NOT selected char index}: the range of characters to be selected.
-- If the unselected index is zero, everything up to, and including, the last item is selected.
-- If the two are equal, this is the same as passing the common value.
-- If the unselected index is less than the selected index, then the pair is reversed.
-- The insertion point is always set at the second index, whether reversing takes place or not.
-- However, setIndex(id,{0,x}) is equivalent to setIndex(id,1). This is a Windows quirk.
--
-- Use 0 to deselect the current selection.
--
--For ListView controls, /i index can be set to /b w32SelectAll to
--select all items.
--
-- For Window, VScroll, HScroll, VTrackBar, HTrackBar, ProgressBar, UpDown: this
-- sets the current scroll position.
--
-- Example:
--/code
--          -- select characters 30 thru 42 inclusive. Cursor blinks at character 43.
--          /setIndex( TheEdit, {30, 43} )
--          -- select all characters
--          /setIndex( TheEdit, {1, 0} )
--          -- select all characters from position 78
--          /setIndex( TheEdit, {78, 0} )
--          -- move insertion point to char 50
--          /setIndex( TheEdit, 50 )
--/endcode

global constant w32SelectAll = {1,0}
global procedure setIndex(atom id, object index)

-- set index of list
integer lCnt
integer msg
--  atom result
atom hWnd
atom lFlags
atom lParam
atom wParam
atom LV_ITEM
atom lCR
    -- get the message, based on control type
    if atom(index) then
        wParam = index-1
        lParam = 0

    end if

    if ctrl_Family[id]=LISTBOX    then
        lFlags = w32Func(xGetWindowLong, {getHandle(id), GWL_STYLE})
        if and_bits(lFlags, LBS_MULTIPLESEL)!=0 then
            if sequence(index) then
                if length(index)=2 then
                    msg = LB_SELITEMRANGEEX
                    wParam = index[1]-1
                    lParam = index[2]-1
                else
                -- CChris <oedoc@free.fr> Oct 26, 2006
                -- Bug fix: index was being used instead of index[1], causing a run time error on detecting the -1 special value
                    msg = LB_SELITEMRANGE
                    if index[1]= -1 then
                        index[1] = getCount(id)
                    end if
--/**/              index = sq_sub(index,1)     --/* -- Phix
                    index -= 1                  --*/ -- RDS
                    lParam = w32pack_word(index[1], index[2])
                    wParam = (index[3]!=0)
                end if
            else
                msg = LB_SETSEL
                if index= -1 then
                    index = getCount(id)-1
                end if
                lParam = index-1
                wParam = (index!=0)
            end if
        else
            msg = LB_SETCURSEL
            lCnt = getCount(id)
            if index<0 or index>lCnt then
                -- Find last item.
                wParam = getCount(id)-1
            end if
        end if

    elsif ctrl_Type[id]=TreeView then
        hWnd = getHandle(id)
        if index>=1 and index<=length(tvitem_handle) then
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, tvitem_handle[index]})
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, tvitem_handle[index]})
        else
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, 0})
        end if
        return

    elsif ctrl_Type[id]=ListView then
        hWnd = getHandle(id)
        if equal(index, w32SelectAll) then
            -- deselect all items
            VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, -1, 0})
            wParam = w32Func(xSendMessage,{hWnd, LVM_GETITEMCOUNT, 0, 0})-1
            LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM)
            w32store(LV_ITEM, LVITEM_mask, LVIF_STATE)
            w32store(LV_ITEM, LVITEM_stateMask, LVIS_SELECTED)
            w32store(LV_ITEM, LVITEM_state, LVIS_SELECTED)
            for i=0 to wParam do
                w32store(LV_ITEM, LVITEM_iItem, i)
                VOID = w32Func(xSendMessage,{hWnd, LVM_SETITEM, 0, LV_ITEM})
            end for
            w32release_mem(LV_ITEM)
        elsif index>=1 then
            VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, index-1, 0})
            VOID = w32Func(xSendMessage, {hWnd, LVM_ENSUREVISIBLE, index-1, 0})
            setLVItem(id, LVIF_STATE, index, 0, or_bits(LVIS_SELECTED,LVIS_FOCUSED),
                      or_bits(LVIS_SELECTED,LVIS_FOCUSED), 0, 0, 0)
        else
            -- deselect all items
            VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, -1, 0})
            wParam = w32Func(xSendMessage,{hWnd, LVM_GETITEMCOUNT, 0, 0})-1
            LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM)
            w32store(LV_ITEM, LVITEM_mask, LVIF_STATE)
            w32store(LV_ITEM, LVITEM_stateMask, LVIS_SELECTED)
            for i=0 to wParam do
                w32store(LV_ITEM, LVITEM_iItem, i)
                VOID = w32Func(xSendMessage,{hWnd, LVM_SETITEM, 0, LV_ITEM})
            end for
            w32release_mem(LV_ITEM)
        end if
        return

    elsif ctrl_Family[id]=COMBO
       or ctrl_Type[id]=ComboBoxEx  then
        msg = CB_SETCURSEL

    elsif find(ctrl_Type[id],{Window,VScroll,HScroll,VTrackBar,HTrackBar,ProgressBar,UpDown}) then
        call_proc(r_setScrollPos,{id, index})
        return

    elsif ctrl_Type[id]=RichEdit then
        if atom(index) then
            index = repeat(index, 2)
        end if

--/**/  index = sq_sub(index,1)     --/* -- Phix
        index -= 1                  --*/ -- RDS
        lCR = w32to_memory(0,ID_CHARRANGE,index)
        VOID = sendMessage(id, EM_EXSETSEL, 0, lCR)
        w32release_mem(lCR)

        return

    elsif ctrl_Family[id]=EDIT  then

        if atom(index) then
            index = repeat(index, 2)
        end if

--/**/  index = sq_sub(index,1)     --/* -- Phix
        index -= 1                  --*/ -- RDS
        VOID = sendMessage(id, EM_SETSEL, index[1], index[2])
        return
    else
        -- has no effect on any other type of control.
        return
    end if

    -- Don't report an error if index is *supposed* to be -1

    VOID = sendMessage(id, msg, wParam, lParam)
end procedure

-----------------------------------------------------------------------------
--/topic Edit Controls
--/func autoSelect( object id, integer Flag )
--/ret OBJECT: Current AutoSelect status.
--/desc Turns on and off an edit control's auto-selection property.
-- If /i flag is /b w32True, the edit control /i id is set to have Auto-Selection,
-- otherwise it is set off.
--
-- If /i id is a single control id, then the return value is a integer. /n
-- If /i id is a sequence of controls, then the return value is a sequence
-- containing one status flag per control referenced in /i id.
--
-- /i id can be either a single control id or a list of ids in a sequence.
--
-- Auto-selection means that when the edit control gets focus, all its contents
-- is selected automatically for you.
--
-- Example:
--/code
--      sequence asv
--      fldName = create( EditText, "", aWindow, x1, y1, width1, height1, 0 )
--      fldAddress = create( EditText, "", aWindow, x1, y2, width1, height1, 0 )
--      asv = autoSelect({fldName, fldAddress}, w32True)
--/endcode
global function autoSelect(object id, integer pFlag)
--  sequence lAutoSelect
object lReturnVal
integer lSingle


    if atom(id) then
        lSingle = w32True
        id = {id}
    else
        lSingle = w32False
    end if
    lReturnVal = {}

    -- Standardise the flag value to w32True or w32False.
    pFlag = not equal(pFlag,0)

    for i=1 to length(id) do
        if validId(id[i]) then
            if find(ctrl_Type[id[i]], {EditText, MleText, RichEdit})!=0 then
                lReturnVal &= ctrl_Specific[id[i]]
                ctrl_Specific[id[i]] = pFlag
                if pFlag then
                    setIndex(id[i], {1,0})
                else
                    setIndex(id[i], call_func(r_getIndex,{id[i]}))
                end if
            end if
        end if
    end for

    if lSingle then
        if length(lReturnVal)=1 then
            lReturnVal = lReturnVal[1]
        else
            lReturnVal = w32False -- Defaults to w32False
        end if
    end if

    return lReturnVal
end function

--/topic List Control
--/proc setSelection( atom list, object index )
--/desc An alias for /setIndex


--/topic RichEdit controls
--/proc setSelection( atom list, object index )
--/desc An alias for /setIndex

global procedure setSelection(atom id, object index)
    setIndex(id, index)
end procedure

--/topic RichEdit controls
--/func getRichText( id, range )
--/desc Get text from a /RichEdit control
--/ret Text in the given range.
-- If /i range is an atom, any selected text is returned. However
-- if there is no selected text and /i range is -1 then all the text is returned. /n
-- If /i range is a sequence, /i range should be a 2-element sequence with the
-- first element the starting index to be retrieved, and the
-- second element the first index NOT retrieved, like /setIndex() does. /n
-- To always retrieve all the text in the control, set the range to {0, 0}.
-- Indexes are clipped so as to make sense. If they don't, "" is returned.

global function getRichText(integer pID, object pRange)
sequence
    lText
atom
    lStruct_TR,
    lTextLength,
    lBufferLen,
    lBuffer,
    mset

    if atom(pRange) then
        -- return selection
        lText = getText(pID)
        if length(lText)=0 and pRange= -1 then
            return getRichText(pID, {0,0})
        else
            return lText
        end if
    elsif length(pRange)<2 or sequence(pRange[1]) or sequence(pRange[2]) then
        return ""
    else
--/**/  pRange = sq_floor(pRange[1..2]) --/* -- Phix
        pRange=floor(pRange[1..2])      --*/ -- RDS
    end if

    -- translate to zero base
--/**/  pRange = sq_sub(pRange,1)   --/* -- Phix
    pRange -= 1                     --*/ -- RDS

    -- normalise arguments
    lTextLength = getCharacterCount(pID,w32True)
    if pRange[2]<=0 or pRange[2]>lTextLength+1 then
        pRange[2] = lTextLength+1
    end if
    if pRange[1]<0 then
        pRange[1] = 0
    elsif pRange[1]>=pRange[2] then
        return ""
    end if

    lBufferLen = pRange[2]-pRange[1]+1
    mset = w32new_memset()
    lBuffer = w32acquire_mem(mset,2*lBufferLen+2) -- twice too big for old RE controls
    pRange &= lBuffer

    lStruct_TR = w32to_memory(mset,ID_TEXTRANGE, pRange)

    VOID = sendMessage(pID, EM_GETTEXTRANGE, 0, lStruct_TR)

    lText = w32fetch(lStruct_TR, TEXTRANGE_lpstrText)

    w32release_mem(mset)
    return lText

end function

--/topic Edit Controls
--/func getCharacterAt(integer id,integer x,integer y)
--/desc Determines the line and column a screen position maps to.
--/ret (SEQUENCE) A {line number, character number, line length, character value} sequence, or {}.
-- /i x and /i y are client screen coordinates relative to /i id.
-- If a position refers to past end of line whitespace, the information returned is relative to the last character of that line. If it is past the last character in the control, the returned information is relative to that character.
-- You can check for this condition by calling /getCharacterPosition() and comparing the result to the initial position.
global function getCharacterAt(integer id,object x,object y)
object s
atom a
integer n,p,uRE

    s = convPctToPixel(id,x,y,0,0)
    x = s[1]
    y = s[2]
    if ctrl_Family[id]=EDIT then
        s = sendMessage(id,EM_CHARFROMPOS,0,w32pack_word(x,y))
        s = {w32hi_word(s),w32lo_word(s)}
        uRE = 0
    elsif ctrl_Type[id]=RichEdit then
        a = w32acquire_mem(0,8)
        poke4(a,{x,y})
        s = sendMessage(id,EM_CHARFROMPOS,0,a)
        w32release_mem(a)
        s = {sendMessage(id,EM_EXLINEFROMCHAR,0,s),s}
        uRE = equal(WC_RICHEDIT,WC_RICHEDIT50)
    else
        return {}
    end if
    s[2] -= sendMessage(id,EM_LINEINDEX,s[1],0)
    n = sendMessage(id,EM_LINELENGTH,s[1],0)
    p = s[2]
    s += 1
    s &= n
    if uRE then
        a = w32acquire_mem(0,2*n)
        p *= 2
    else
        a = w32acquire_mem(0,n)
    end if
    poke4(a,n)
    VOID = sendMessage(id,EM_GETLINE,s[1],a)
    if not uRE then
        s &= peek(a+p)
    else
        s &= (peek(a+p)+256*peek(a+p+1))
    end if
    w32release_mem(a)
    return s
end function

--/topic Edit Controls
--/func getLine(id,number,flag)
--/desc Fetches the text of the request line.
--/ret (SEQUENCE) The (length of) requested line in the control, -1 on error.
-- /i id must refer to an edit or rich edit control; otherwise, the function returns 0.
-- If /i number is 0 or less, the text of current line in the control is returned. The
-- current line is the one where the selection starts, if any, or the one where the insertion point currently is.
-- If flag is w32False, the length is returned; otherwise, the text of the line is returned.

global function getLine(integer id,integer number,integer flag)
atom a
integer n,uRE
sequence s

    if ctrl_Family[id]=EDIT then
        uRE = 0
    elsif ctrl_Type[id]=RichEdit then
        uRE = equal(WC_RICHEDIT,WC_RICHEDIT50)
    else
        return -1
    end if
    n = sendMessage(id,EM_LINELENGTH,number-1,0)
    if not flag then
        return n
    elsif n=0 then
        return ""
    end if
    if uRE then
        a = w32acquire_mem(0,2*n)
    else
        a = w32acquire_mem(0,n)
    end if
    poke4(a,n)
    VOID = sendMessage(id,EM_GETLINE,number-1,a)
    if not uRE then
        s = peek({a,n})
    else
        s = w32peek2({a,n})
    end if
    w32release_mem(a)
    return s
end function

--/topic Edit Controls
--/func charToIndex(integer id,integer line,integer column)
--/desc Retrieves the index of a character at a given line and column.
--/ret (INTEGER) Index of character.
global function charToIndex(integer id,integer line,integer column)
    return sendMessage(id,EM_LINEINDEX,line-1,0)+column -- column is 1 based and line index is 0 based
end function

--/topic Edit Controls
--/func indexToLine(integer id,integer index)
--/desc Translates a character index to a {line,column} pair.
--/ret (SEQUENCE) {line number, index of character in this line}
-- Note that, if word wrap was set using the EM_SETTARGETDEVICE message, the returned 
-- information is not reliable if the index falls into the wrapped part of a line.
global function indexToLine(integer id,integer index)
integer line

    line = sendMessage(id,EM_EXLINEFROMCHAR,index-1,0)
    index = sendMessage(id,EM_LINEINDEX,line-1,0)
    return {line+1,index}
end function

--/topic Edit controls
--/func getCharacterPosition(integer id,integer line,integer col)
--/desc Determines the screen position of the designated character relative to the upper left corner of the client area of the control.
--/ret (SEQUENCE) A {x,y} coordinate pair in client coordinates, or 0 if character doesn't exist.
-- As a special case, if /i col is 0, then /i line is a character index.
global function getCharacterPosition(integer id,integer line,integer col)
object s
atom a

    if col=0 then
        s = indexToLine(id,line)
        col = s[2]
        line = s[1]
    end if
    line = sendMessage(id,EM_LINEINDEX,line-1,0)+col-1
    if ctrl_Family[id]=EDIT or (ctrl_Type[id]=RichEdit and equal(WC_RICHEDIT,WC_RICHEDIT20)) then
    -- use compatibility mode for RichEdit v3.0
        s = sendMessage(id,EM_POSFROMCHAR,line,0)
        return {w32lo_word(s),w32hi_word(s)}
    else  -- RichEdit v1.0 and 4.1
        a = w32acquire_mem(0,8)
        VOID = sendMessage(id,EM_POSFROMCHAR,a,line)
        s = peek4s({a,2})
        w32release_mem(a)
        return s
    end if
end function

--/topic Edit Controls
--/func getVisibleLines(id)
--/desc Determines the numbers of first and last lines displayed on screen.
--/ret (SEQUENCE) {number of first line, number of last line}.
global function getVisibleLines(integer id)
sequence s

    s = getCtlSize(id)
    s = getCharacterAt(id,s[1]-2,s[2]-2)
    return {sendMessage(id,EM_GETFIRSTVISIBLELINE,0,0)+1,s[1]}
end function

--/topic Edit Controls
--/proc insertTextAt(integer id,sequence text,object pos)
--/desc Inesrts /i text in the text of /i at a defined point.
-- If /i pos is an atom, /i text will be appended to the control's text. Otherwise,
-- it specifies the insertion point as {line,column}.
-- If the insertion point is inside the selection, the selection will be enlarged and contains 
-- the inserted text as well. Otherwise, selection is preserved.

global procedure insertTextAt(integer id,sequence text,object pos)
sequence index
integer char_pos

    index = getSelection(id)
    if atom(pos) then
        setIndex(id,0)
        appendText(id,text)
    else
        char_pos = pos[2]+sendMessage(id,EM_LINEINDEX,pos[1]-1,0)
        setIndex(id,char_pos)
        insertText(id,text)
        if index[1]<=char_pos and char_pos<=index[2] then
            index[2] += length(text)
        elsif index[1]>=char_pos then
--/**/      index = sq_add(index,length(text))  --/* -- Phix
            index += length(text)               --*/ -- RDS
        end if
    end if
    setIndex(id,index)
end procedure

--/topic Edit Controls
--/proc deleteLine(integer id,object line)
--/desc Removes the line with supplied number.
-- /i line is either a single line or a {lower,upper} range of lines to delete.
-- No action is taken if the line number is invalid.
-- If the deleted line overlaps the selection, the latter will be shortened accordingly.

global procedure deleteLine(integer id,object line)
integer p,q
sequence s

    s = getSelection(id)
    if atom(line) then
        line = {line,line}
    end if
    p = sendMessage(id,EM_GETLINECOUNT,0,0)
    if line[1]>p then
        return
    elsif line[2]>p then
        line[2] = p
    end if
    p = sendMessage(id,EM_LINEINDEX,line[1]-1,0)
    if line[2]<p then -- not deleting last line
        q = sendMessage(id,EM_LINEINDEX,line[2],0)
        setIndex(id,{p+1,q})
        setSelectedText(id,"")
        if s[1]>q then
--/**/      s = sq_sub(s,(q-p)) --/* -- Phix
            s -= (q-p)          --*/ -- RDS
        elsif s[1]>=p and s[2]>q then
            s[1] = p
        elsif s[1]>=p and s[2]<q then
            s = {p,p-1}
        elsif s[1]<p and s[2]>=q then
            s[2] -= (q-p)
        elsif s[1]<p and s[2]>=p then
            s[2] = p
        end if
    else
        setIndex(id,{p,0})
        setSelectedText(id,"")
        if s[2]>p then
            s[2] = p+1
            if s[1]>p then
                s[1] = p+1
            end if
        end if
    end if
    setIndex(id,s)
end procedure


sequence NotFoundMessage
NotFoundMessage = "Finished searching document"
sequence NotFoundCaption
NotFoundCaption = "Find"
sequence ReplacedAllMessage
ReplacedAllMessage = "Replaced %d occurence(s) of string in document."
integer repMsgHasFormat
repMsgHasFormat = 1
sequence ReplacedAllCaption
ReplacedAllCaption = "Replace All"

--------------------------------------------------------------
-- Rewritten R. Stowasser, Feb 3, 2008
-- helper routine to proces the find/replace RichEdit message
function setFindSel(integer id, atom flag, atom fr,integer mb_display)
object index, range
sequence findwhat
atom callback

    index = getIndex(id)
    findwhat = w32fetch(fr, FINDREPLACE_lpstrFindWhat)

    if and_bits(flag, FR_DOWN) then
        index = {index-1, -1}
    else
        index = {0, index-2}
    end if

    index = findText(id, findwhat, index, flag)
    callback = ctrl_Statusbar[id][3]
    if callback>=0 then
        call_proc(callback,{id,index>0})
    elsif index=0 and mb_display then
        VOID = message_box(NotFoundMessage, NotFoundCaption, MB_OK+MB_ICONINFORMATION)
        return -1
    end if

    range = {index , index+length(findwhat)}

    setIndex(id, range)
    return range[1]
end function
-- end RS

-----------------------------------------------------------------------------
--/topic List Control
--/func getItem( integer list, integer index )
--/desc Return the text of item at /i index in /i list.
--/ret Text of item, or "" if fails.
-- /b Note, getItem() will return the text from all columns of a /ListView.
--
--If /i index is zero, the currently selected item is used.
--
-- Example:
--/code
--          -- get the text of the third item in TheList
--          sequence text
--
--          -- get the text of the third item.
--          text = /getItem( TheList, 3 )
--          -- get the text of the current item.
--          text = /getItem( TheList, 0 )
--/endcode
constant kLenMsg = {CB_GETLBTEXTLEN, -- Combo
                    CB_GETLBTEXTLEN, -- SortedCombo
                    CB_GETLBTEXTLEN, -- SimpleCombo
                    CB_GETLBTEXTLEN, -- DropDownList
                    CB_GETLBTEXTLEN, -- ComboBoxEx
                    LB_GETTEXTLEN, -- SortedList
                    LB_GETTEXTLEN  -- List
                   }

constant kTxtMsg = {CB_GETLBTEXT, -- Combo
                    CB_GETLBTEXT, -- SortedCombo
                    CB_GETLBTEXT, -- SimpleCombo
                    CB_GETLBTEXT, -- DropDownList
                    CB_GETLBTEXT, -- ComboBoxEx
                    LB_GETTEXT, -- SortedList
                    LB_GETTEXT  -- List
                   }

global function getItem(atom id, object item)

-- get text of requested item

integer iLength
atom buffer
sequence text
integer ctype

     -- correct class?
    ctype = find(ctrl_Type[id], {Combo, SortedCombo, SimpleCombo,
                                 DropDownList, ComboBoxEx,
                                 SortedList, List,
                                 ListView})
    if ctype=0 then
        return ""
    end if

    if item=0 then
        item = getIndex(id)
    end if

    -- ListView returns all columns.
    if ctrl_Type[id]=ListView then
        return getLVItemText(id, item, -1)
    end if

    -- get the text size; add 1 for /0
    iLength = sendMessage(id, kLenMsg[ctype], item-1, 0)+1

    -- no item?
    if iLength=0 then
        return ""
    end if

    -- Allocate a buffer
    buffer = w32acquire_mem(0, iLength)

    -- move the text to a buffer
    -- value returned is length without 0 terminator
    iLength = sendMessage(id, kTxtMsg[ctype], item-1, buffer)

    -- get the text
    text = peek({buffer, iLength})

    -- release the buffer
    w32release_mem(buffer)

    return text

end function
r_getItem = routine_id("getItem")

--/topic Events
--/func getLastMsg( object option )
--/desc Gets information about the Windows message(s) being processed.
--/ret SEQUENCE: The message data sent by Windows. INTEGER: Depth
--This is used by advanced users. It can be used to determine the triggering event for
-- the current event handler. For example, you can use this to find out if a w32HClick
-- event was triggered by a keypress or a mousepress. Or if a paint event was triggered
-- by a scroll action or not.
--
--What this returns depends on the /i option value.
--/li "" Returns the most recent message as {/i Msg }, where /i Msg is a sequence laid out as { pSource, hWnd, iMsg, wParam, lParam, time_stamp }
--/li "all" Returns all the messages being processed. { /i Msg_1,/i Msg_2, ... } where each /i Msg_n has the form above.
--/li "depth" Returns the current number of messages being processed.
--/li "maxdepth" Returns the maximum number of simultaneous messages processed so far.
--
--This returns an empty list if there are no windows messages being processed. /n
-- time_stamp specifies the elapsed time, in milliseconds, from the time the system was started to the time the message was created (that is, placed in the thread's message queue)
--
--Example:
--/code
--      -- gets last received message
--      sequence msg
--      msg = getLastMsg( "" )
--/endcode
global function getLastMsg(object option)

    if equal(option, "depth") then
        return vWMI
    end if

    if equal(option, "maxdepth") then
        return find(0, vWinMsg)-1
    end if

    if vWMI>0 then
        if equal(option, "all") then
            return vWinMsg[1..vWMI]
        else
            return {vWinMsg[vWMI]}
        end if
    else
        return {}
    end if
end function

-----------------------------------------------------------------------------
--/topic List Control
--/func findItem( integer list, sequence text, integer startpos )
--/desc Locates /i text in the /i list, starting from index /i startpos
--/ret integer: The index in the /i list where /i text was found. Zero if not found.
-- /b Note, findItem will only check the first column of a /ListView.  /n
--If /istartpos is negative, the list is scanned from the last item such that -1 means
-- start at the last item, -2 from the second last item etc... A value of 0 means
-- that all occurances are returned in a sequence.
-- Example:
--/code
--
--          integer ipos
--          sequence allpos
--
--          -- See if new value already exists.
--          ipos = /findItem( TheList, NewValue, 1 )
--          -- Get all occurances of "cat"
--          allpos = findItem( TheList, "cat", 0)
--          -- Get last occurance of "dog"
--          ipos = findItem( TheList, "dog", -1)
--/endcode
global function findItem(atom id, sequence ptext, integer item)

-- find the requested text

integer iLength
atom buffer
sequence text
object lResult
integer ctype
integer lStart, lEnd, lIncr

    if item=0 then
        lResult = {}
    else
        lResult = 0
    end if

    -- correct class?
    ctype = find(ctrl_Type[id], {Combo, SortedCombo, SimpleCombo,
                                 DropDownList, ComboBoxEx,
                                 SortedList, List,
                                 ListView})
    if ctype=0 then
        return lResult
    end if

    if item<0 then
        lIncr = -1
        lEnd = 0
        lStart = getCount(id)+item
    else
        lIncr = 1
        if item=0 then
            lStart = 0
        else
            lStart = item-1
        end if
        lEnd = getCount(id)-1
    end if


    for i=lStart to lEnd by lIncr do

        if ctrl_Type[id]=ListView then
            -- Get the text from column #1
            text = getLVItemText(id, i+1, 1)
        else

            -- get the text size
            iLength = sendMessage(id, kLenMsg[ctype], i, 0)

            -- no item?
            if iLength= -1 then
                exit
            end if

            -- Only bother getting the actual text if the lengths are the same.
            if iLength=length(ptext) then
                -- Allocate a buffer, accounting for string terminator
                buffer = w32acquire_mem(0, iLength+1)

                -- move the text to a buffer
                -- value returned is length without 0 terminator
                VOID = sendMessage(id, kTxtMsg[ctype], i, buffer)

                -- get the text
                text = peek({buffer, iLength})

                -- clean up
                w32release_mem(buffer)
            else
                text = ""
            end if
        end if

        if equal(text, ptext) then
            if item=0 then
                lResult &= i+1
            else
                lResult = i+1
                exit
            end if
        end if
    end for

    return lResult
end function

--/topic List Control
--/func getMultIndices( id )
--/desc Get indices of multiple selections in a multi-selection list
--/ret Sequence of indices. {} is returned if there are none selected.
global function getMultIndices(atom id)
atom buffer, items
sequence selections
    selections = {}

    items = sendMessage(id, LB_GETSELCOUNT, 0 ,0)
    if items>0  then
        buffer = w32acquire_mem(0, items*4)
        items = sendMessage(id, LB_GETSELITEMS, items, buffer)

        selections = peek4u({buffer, items})+1
        w32release_mem(buffer)
    end if

    return selections
end function

--/topic List Control
--/func getMultItems( id )
--/desc Get text of multiple selections in a multi-selection list
--/ret Sequence of strings. {} is return if nothing is selected.
global function getMultItems(atom id)

sequence selections
    selections = getMultIndices(id)

    for i=1 to length(selections) do
        selections[i] = getItem(id, selections[i])
    end for

    return selections
end function

-----------------------------------------------------------------------------
--/topic List Control
--/proc eraseItems( list )
--/desc Remove all items from /i list.
-- Example:
--/code
--          -- erase items from TheList
--          /eraseItems( TheList )
--/endcode
-- Also works with /ComboBox  /ListView and /TreeView controls.
global procedure eraseItems(atom id)

    -- clear a list
    VOID = deleteItem(id, w32AllItems)

end procedure




-----------------------------------------------------------------------------
-- SCROLL BARS
--
-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setScrollChange( id, linesize, pagesize )
--/desc Adjust the amount that a scroll control will change.
-- The /i linesize is the amount that the /i id will adjust
-- when the up/down arrow is selected, and the /i pagesize is
-- used when the page up/page down is selected.
--
-- For trackbars, the /i pagesize is used to determine the distance
-- between the tick marks.
--
-- The default values are {1,10}.
--
-- Example:
--/code
--          -- set change amount for TheScroll
--          /setScrollChange( TheScroll, 1, 10 )
--/endcode

global procedure setScrollChange(object id, atom low, atom high)

-- set the "line" and "page" change amount
atom result
atom lWhich

    if sequence(id) then
        if id[2]=SB_HORZ then
            lWhich = 2
        else
            lWhich = 1
        end if
        id = id[1]
    else
        lWhich = 1
    end if

    -- save value
    ctrl_Scroll[id][lWhich] = {low, high}

-- NEW! 0.45f trackbar support
    if ctrl_Type[id]=HTrackBar
    or ctrl_Type[id]=VTrackBar then

        -- new page size
        result = sendMessage(id, TBM_SETPAGESIZE, low, high)

        -- set tick frequency
        result = sendMessage(id, TBM_SETTICFREQ, high, 0)

    end if

end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollChange( scroll )
--/desc Returns the amount that /i scroll will change.
--/ret { line change, page change }
-- This value is set by /setScrollChange. The default value is {1,10},
-- indicating the small change and large change amounts.
--
-- Example:
--/code
--          -- get change amount for TheScroll
--          sequence change
--          change = /getScrollChange( TheScroll )
--/endcode

global function getScrollChange(object id)
atom lWhich

    if sequence(id) then
        if id[2]=SB_HORZ then
            lWhich = 2
        else
            lWhich = 1
        end if
        id = id[1]
    else
        lWhich = 1
    end if

    return ctrl_Scroll[id][lWhich]

end function


--/topic Scroll Control
--/proc setWindowScrollRange( id, typeScroll, min, max, pageSize)
--/desc Set range of window scrollbar or normal scrollbar .
--/li /b id: specifies either the scrollbar or /Window with scrollbar
--/li /b typeScroll : specifies type of the scrollbar
--/li /b pageSize : specifies size of one page (allows to set size of proportional scrollbar)
-- If this is less than 1, it is ignored.
--
--typeScroll can be one of the following :
-- /li /b SB_HORZ : window's (specified by /i id) horizontal scrollbar
-- /li /b SB_VERT : window's (specified by /i id) vertical scrollbar
-- /li /b SB_CTL  : control (specified by /i id), either /HScroll or /VScroll
global procedure setWindowScrollRange(integer id, integer typeScroll, atom min, atom max, atom pageSize)
-- Martin : sets scroll range for window scrolbar

atom sif
atom lMask
sequence lChangeSize
--  integer lType

    -- store value


    if ctrl_Type[id]!=Window then
        typeScroll = SB_CTL
    elsif typeScroll!=SB_HORZ then
        typeScroll = SB_VERT
    end if

    if typeScroll=SB_HORZ then
        ctrl_Range[id][2] = {min,max}
    else
        ctrl_Range[id][1] = {min,max}
    end if

    -- store values
    if pageSize<1 then
        lMask = SIF_RANGE
    else
        lMask = w32or_all({SIF_RANGE,SIF_PAGE})
        lChangeSize = getScrollChange({id, typeScroll})
        setScrollChange({id, typeScroll}, lChangeSize[1], pageSize)
    end if

    -- Allocate structure
    sif = w32to_memory(0,ID_SCROLLINFO, {lMask, min, max, pageSize})
    VOID = w32Func(xSetScrollInfo,
                   {getHandle(id),           -- handle
                    typeScroll,                  --
                    sif,                         -- pointer to structure
                    1})                      -- redraw flag

    -- Free structure
    w32release_mem(sif)
end procedure

--/topic Scroll Control
--/proc setScrollRange( id, low, high )
--/desc Sets the range of values of a control.
-- /i id is the Id of the control to be affected. This must be either a... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li UpDown
--/li ProgressBar
--</ul>
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
-- The /i low value must be greater than zero.
--
-- The initial values when a control is created are low=0, high=100.
--
-- Example:
--/code
--          -- set range for TheScroll
--          /setScrollRange( TheScroll, 1, 100 )
--          -- set the horizontal scrollbar on a window.
--          /setScrollRange( {myWindow, SB_HORZ}, 1, 289)
--/endcode

global procedure setScrollRange(object id, atom min, atom max)

-- set the allowable range for a scroll bar
integer lMsgCode
-- store value
    if sequence(id) then
        lMsgCode = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lMsgCode = SB_VERT
    end if


    -- what type of control?
    if find(ctrl_Type[id], {HScroll, VScroll, Window}) then

        if ctrl_Type[id]!=Window then
            lMsgCode = SB_CTL                     -- scroll bar control
        end if

        setWindowScrollRange(id, lMsgCode, min, max, 0)


    elsif find(ctrl_Type[id], {HTrackBar,VTrackBar}) then

        ctrl_Range[id][1] = {min, max}
        -- set the range and selection range
        VOID = sendMessage(id, TBM_SETRANGEMIN, w32False, min)
        VOID = sendMessage(id, TBM_SETRANGEMAX, w32True, max)
        VOID = sendMessage(id, TBM_SETSELSTART, w32False, min)
        VOID = sendMessage(id, TBM_SETSELEND, w32False, max)


    elsif ctrl_Type[id]=ProgressBar then

        if max>#7FFF or min< -#7FFF then
            VOID = sendMessage(id, PBM_SETRANGE32, min, max)
        else
            VOID = sendMessage(id, PBM_SETRANGE, 0, w32pack_word(min, max))
        end if
        ctrl_Range[id][1] = {min, max}

    elsif ctrl_Type[id]=UpDown then
        if max>#7FFF or min< -#7FFF then
            VOID = sendMessage(id, UDM_SETRANGE32,  min, max)
        else
            VOID = sendMessage(id, UDM_SETRANGE,  0, w32pack_word(max,min))
        end if

        ctrl_Range[id][1] = {min, max}
        --ctrl_Range[ id ][2] = { min, max }
    end if


end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollRange( id )
--/desc Returns /i id's range of values.
--/ret { low, high }
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
--
--
-- This value is set by /setScrollRange.
--
-- Example:
--/code
--          -- get range of TheScroll
--          sequence range
--          range = /getScrollRange( TheScroll )
--/endcode

global function getScrollRange(object id)

-- Get the allowable range for a scroll bar
atom lWhichBar

    if sequence(id) then
        lWhichBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lWhichBar = SB_VERT
    end if

    if ctrl_Family[id]=WINDOW then
        if lWhichBar=SB_HORZ then
            return ctrl_Range[id][2]
        else
            return ctrl_Range[id][1]
        end if
    else
        return ctrl_Range[id][1]
    end if

end function


-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setScrollPos( id, position )
--/desc Sets the value of /i id.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- /b Note that when /i id is a Window control, by default it refers to the vertical scrollbar.
-- Alternatively you can specify either vertical or horizontal by using the syntax {id, scrollbar}
-- where /i scrollbar is either /b SB_VERT or /b SB_HORZ. /n
--
--The value must be greater than zero.
--
--This routine will trigger an /w32HScroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setScrollPos( TheScroll, 20 )
--          -- set the horizontal scrollbar
--          /setScrollPos( {myWindow, SB_HORZ}, 17)
--/endcode

global procedure setScrollPos(object id, object pAction)

-- return the value of the scroll bar
object result
atom min, max
atom lWhichBar
atom pos

    result = {}
    if sequence(id) then
        lWhichBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lWhichBar = SB_VERT
    end if

    if sequence(pAction) then
        pos = floor(pAction[1])
        pAction = pAction[2]
        if sequence(pAction) or not integer(pAction) or pAction<SB_LINEUP or pAction>SB_ENDSCROLL then
            pAction = SB_UserDefined
        end if
    else
        pos = floor(pAction)
        pAction = SB_UserDefined
    end if

    if lWhichBar=SB_HORZ then
        min = ctrl_Range[id][2][1]
        max = ctrl_Range[id][2][2]
    else
        min = ctrl_Range[id][1][1]
        max = ctrl_Range[id][1][2]
    end if

    if pos<min then
        -- clip to minimum
        pos = min

    elsif pos>max then
        -- clip to maximum
        pos = max

    end if


    -- scrollbar?
    if ctrl_Type[id]=HScroll
    or ctrl_Type[id]=VScroll then

        -- call the function
        result =  w32Func(xSetScrollPos, {
                                          getHandle(id),        -- handle
                                          SB_CTL,               -- scroll bar specific
                                          pos,                  -- new scroll bar position
                                          w32True})                -- redraw flag

    elsif ctrl_Type[id]=Window then
        -- call the function
        result =  w32Func(xSetScrollPos, {
                                          getHandle(id),        -- handle
                                          lWhichBar,                  -- scroll bar specific
                                          pos,                  -- new scroll bar position
                                          w32True})                -- redraw flag

    elsif ctrl_Type[id]=HTrackBar
       or     ctrl_Type[id]=VTrackBar then

        -- send message
        result = sendMessage(id, TBM_SETPOS, w32True, pos)

    elsif ctrl_Type[id]=ProgressBar then

        -- send message
        result = sendMessage(id, PBM_SETPOS, pos, 0)

    elsif ctrl_Type[id]=UpDown then

        -- send message
        result = sendMessage(id, UDM_SETPOS, pos, 0)

    end if

    if atom(result) then
        -- run the event code, if any
        VOID = invokeHandler(id, w32HScroll, {pos, pAction, lWhichBar})
    end if

end procedure
r_setScrollPos = routine_id("setScrollPos")

-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setVScrollPos( window, position )
--/desc Sets the value of a window's vertical /i scroll.
-- The value must be greater than zero. This will trigger an
-- /Scroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setVScrollPos( myWindow, 20 )
--/endcode

global procedure setVScrollPos(integer id, atom pos)

    setScrollPos({id, SB_VERT}, pos)

end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/proc setHScrollPos( window, position )
--/desc Sets the value of a window's horizontal /i scroll.
-- The value must be greater than zero. This will trigger an
-- /Scroll event.
--
-- Example:
--/code
--          -- set value of the TheScroll
--          /setHScrollPos( myWindow, 20 )
--/endcode

global procedure setHScrollPos(integer id, atom pos)

    setScrollPos({id, SB_HORZ}, pos)


end procedure

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getScrollPos( object id)
--/desc Gets the value of a scroll control.
--/ret Position of the thumb on the scroll control.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- For /b Window controls, the /i id parameter can also specify which of
-- the vertical or horizontal scrollbars you are referring to. To do this,
-- the form of /i id is { ctrl, bartype } where /i bartype is either
-- /b SB_VERT or /b SB_HORZ.
--
-- Note that this function returns the last position of the thumb while it was resting. Use /getThumbPos() instead to track the thumb position while it is being dragged.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos,vpos,hpos
--          pos = /getScrollPos( TheScroll )
--          vpos = /getScrollPos( {MainWin, SB_VERT} )
--          hpos = /getScrollPos( {MainWin, SB_HORZ} )
--/endcode

global function getScrollPos(object id)
integer lSBar
    -- return the value of the scroll bar


    if sequence(id) then
        lSBar = w32iff(find(id[2], {SB_VERT,SB_HORZ}), id[2], SB_VERT)
        id = id[1]
    else
        lSBar = SB_VERT
    end if

    if ctrl_Type[id]=Window then

        return w32Func(xGetScrollPos, {getHandle(id), lSBar})

    elsif  ctrl_Type[id]=HScroll
       or ctrl_Type[id]=VScroll  then
        -- call the function
        return w32Func(xGetScrollPos, {
                                       getHandle(id),       -- handle
                                       SB_CTL})             -- scroll bar specific

    elsif  ctrl_Type[id]=HTrackBar
       or  ctrl_Type[id]=VTrackBar then

        return sendMessage(id, TBM_GETPOS, 0, 0)

    elsif ctrl_Type[id]=ProgressBar then

        return sendMessage(id, PBM_GETPOS, 0, 0)

    elsif ctrl_Type[id]=UpDown then

        return w32shortInt(sendMessage(id, UDM_GETPOS, 0, 0))
    else
        return 0
    end if

end function
r_getScrollPos = routine_id("getScrollPos")
-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getThumbPos( object id)
--/desc Gets the position of the scroll thumb while being dragged.
--/ret Position of the thumb on the scroll control.
--/i id is the Id of a control. The control must be one of... /n
--<ul>
--/li Window
--/li VScroll
--/li HScroll
--/li VTrackBar
--/li HTrackBar
--/li ProgressBar
--/li UpDown
--</ul>
-- For /b Window controls, the /i id parameter can also specify which of
-- the vertical or horizontal scrollbars you are referring to. To do this,
-- the form of /i id is { ctrl, bartype } where /i bartype is either
-- /b SB_VERT, /b SB_HORZ or /b SB_CTL (for /HScroll or VScroll controls).
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos,vpos,hpos
--          pos = /getThumbPos( TheScroll )
--          vpos = /getThumbPos( {MainWin, SB_VERT} )
--          hpos = /getThumbPos( {MainWin, SB_HORZ} )
--/endcode

-- 2/19/04 mwl: added this to get the thumb position when dragged by the mouse
global function getThumbPos(object id)
atom lSif, lPos

integer lSBar
-- return the value of the scroll bar


    if sequence(id) then
        lSBar = w32iff(find(id[2], {SB_VERT,SB_HORZ,SB_CTL}), id[2], SB_VERT)
        id = id[1]
    else
        lSBar = SB_CTL
    end if

    if find(ctrl_Type[id], {HTrackBar, VTrackBar}) then
        return sendMessage(id, TBM_GETPOS, 0 , 0)
    end if

    -- Allocate structure
    lSif = w32acquire_mem(0, SIZEOF_SCROLLINFO)

    -- store values
    w32store(lSif, sifSize, SIZEOF_SCROLLINFO)
    w32store(lSif, sifMask, SIF_TRACKPOS+SIF_POS)
    VOID = w32Func(xGetScrollInfo, {getHandle(id), lSBar, lSif})
    lPos = w32fetch(lSif, sifTrackPos)
    w32release_mem(lSif)

    return lPos

end function


-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getVScrollPos( window )
--/desc Gets the value of a window's vertical scroll bar.
--/ret Position of the thumb on the scroll control.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos
--          pos = getVScrollPos( myWindow )
--/endcode

global function getVScrollPos(integer id)
    -- return the value of the scroll bar

    return getScrollPos({id, SB_VERT})
end function

-----------------------------------------------------------------------------
--/topic Scroll Control
--/func getHScrollPos( window )
--/desc Gets the value of a window's horizontal scroll bar.
--/ret Position of the thumb on the scroll control.
--
-- Example:
--/code
--          -- get value of TheScroll
--          integer pos
--          pos = getHScrollPos( myWindow )
--/endcode

global function getHScrollPos(integer id)

    -- return the value of the scroll bar
    return getScrollPos({id, SB_HORZ})
end function

-----------------------------------------------------------------------------
--/topic UpDown Control
--/proc setAcceleration( integer id, sequence Times )
--/desc Set the rate of change for an UpDown control
--The UpDown control specified by /i id will change it's values while the user holds
-- down the mouse button. You can alter the rate of the change by using this routine. /n
-- The /i Times parameter is a list of /b pairs of values, in which the first of a pair
-- is the number of seconds to elapse (from the time the button was pressed) before changing,
-- and the second is the (positive) increment to change the current value by.
--
--Example:
--/code
--      setAcceleration(myUpDown, {  {1,2}, {3,4}, {5, 8}, {7,16} } )
--/endcode

global procedure setAcceleration(integer id,  sequence pTimes)
atom lAccel
atom lAddr

--/**/  pTimes = sort(w32abs(sq_floor(pTimes))) --/* -- Phix
    pTimes = sort(w32abs(floor(pTimes)))        --*/ -- RDS
    lAddr  = w32acquire_mem(0, length(pTimes)*8)
    lAccel = lAddr

    for i=1 to length(pTimes) do
        poke4(lAccel, pTimes[i])
        lAccel += 8
    end for
    VOID = sendMessage(id, UDM_SETACCEL, length(pTimes) , lAddr)

    w32release_mem(lAddr)
end procedure



-----------------------------------------------------------------------------
-- GRAPHICS
--

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setBackColor( integer id, object color )
--/desc Set the color for used for the pen fill color in /i id.
-- When the pen mode is set to /b OPAQUE, this specifies the color
-- used to fill the 'gaps'.
--
-- When used on a MonthCalendar control, it changes the background color
-- imediately.
--
-- When used on a Pixmap control, it clears the entire Pixmap to the
-- specified color.
--
-- Example:
--/code
--      -- set pen opaque color
--      setPenBkMode( TheWindow, OPAQUE)
--      setBackColor( TheWindow, Red )
--      /wPuts( TheWindow, "This text is on red" )
--
--      -- Clear a pixmap
--      setBackColor( pixmap1, BrightWhite)
--/endcode

global procedure setBackColor(integer id, object color)

-- set the background color for the window
atom hdc
sequence lRect
object lSavedColor

    if equal(color, w32WinDefColor) then
        return
    end if

    if ctrl_Type[id]=MonthCalendar then
        setMonthColor(id, MCSC_BACKGROUND, color)
        return

    elsif ctrl_Type[id]=Pixmap then
        lRect = getRect(id)
        lSavedColor = ctrl_Pen[id][PenColor]
        ctrl_Pen[id][PenColor] = color
        drawRectangle(id, w32True, 0, 0, lRect[3], lRect[4])
        ctrl_Pen[id][PenColor] = lSavedColor
        return

    end if

    hdc = getDC(id)
    if w32Func(xSetBkColor, {hdc, colorValue(color)})=CLR_INVALID then
        warnErr("SetBkColor in setBackColor failed.")
    end if
    releaseDC(id)
end procedure
r_setBackColor = routine_id("setBackColor")





-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenWidth( window, pixel width )
--/desc Set the the pen width used in /i window.
-- The default thickness of the pen is 1 pixel.
--
-- Example:
--/code
--          -- set pen thickness of 3
--          /setPenWidth( TheWindow, 3 )
--          -- draw a thick line
--          /drawLine( TheWindow, 10, 10, 40, 40 )
--/endcode

global procedure setPenWidth(integer id, integer pixels)

    -- set a new pen thickness for the window

    -- save the thickness
    ctrl_Pen[id][PenWidth] = pixels

end procedure



-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenStyle( window, style )
--/desc Set the style that lines are drawn in.
-- This allows the creation of various dotted line styles.
-- Use /setBackColor to define the background fill used on the line.
--
-- The following styles are defined:
--
-- /li /b Solid
-- /li /b Dash
-- /li /b Dot
-- /li /b DashDot
-- /li /b DashDotDot
--
-- /b Note: This routine will probably be dropped in later releases.
--
-- Example:
--/code
--          -- set pen style
--          /setPenStyle( TheWindow, Dot )
--
--          -- draw a line using that pen style
--          /drawLine( TheWindow, 10, 10, 100, 100 )
--/endcode

global procedure setPenStyle(integer id, atom style)

    -- set a new pen style for the window

    -- save the style
    ctrl_Pen[id][PenStyle] = style

end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenMode( integer id, integer mode )
--/desc Determines what mode graphics are drawn in.
-- The default value is /b R2_COPYPEN. The list mode codes is <a href="..\win32_constants.htm#setPenMode() codes"> here</a>.
--
-- Example:
--/code
--          -- draw an XOR line in TheWindow
--          /setPenMode( TheWindow, R2_XORPEN )
--          /drawLine( TheWindow, 10, 10, 100, 100 )
--/endcode

global procedure setPenMode(integer id, atom rop2)
    -- sets the ROP2 mode for the window
    ctrl_Pen[id][PenROP2] = rop2
end procedure

-----------------------------------------------------------------------------
--/topic Graphics
--/proc setPenBkMode( window, mode )
--/desc Determines if the background color for lines and text.
-- Modes are:
--
-- /li /b OPAQUE: Draws using background color.
-- /li /b TRANSPARENT: Draws without background color.
--
-- If /i mode is /b OPAQUE, the color set in /setBackColor is used.
-- The default mode is /b TRANSPARENT.
--
--
-- Example:
--/code
--          -- draw an XOR line in TheWindow
--          /setPenBkMode( TheWindow, OPAQUE )
--          /drawLine( TheWindow, 10, 10, 100, 100 )
--/endcode

global procedure setPenBkMode(integer id, atom bkMode)
    -- sets the pen background mode
    -- default is transparent
    ctrl_Pen[id][PenBkMode] = bkMode
end procedure

--/topic Graphics
--/proc setPenBkColor( window, color )
--/desc Determines the background color for text.
--
-- Example:
--/code
--  setPenBkColor( Fld1, BrightCyan )
--/endcode

global procedure setPenBkColor(integer id, object color)
    ctrl_Pen[id][PenBkColor] = color
end procedure

--/topic Graphics
--/proc setPenBrushColor( window, color )
--/desc Determines the solid brush color for filled shapes.
--The current pen color is used until this is called for the first time.
--
-- Example:
--/code
--  setPenBrushColor( MyCanvas, Blue)
--/endcode

global procedure setPenBrushColor(integer id, object color)
    ctrl_Pen[id][PenBrushColor] = {color}
end procedure


-----------------------------------------------------------------------------
--/topic Attributes
--/proc setCtlSize( integer control, object Width, object Height )
--/desc Resizes /i control to /i Width and /i Height.
--
--If either /i Width or /i Height has the value /b w32SameSize then
-- the dimension is unchanged.
--
-- Example:
--
--/code
--     -- size Button1 to 60 pixels wide by 32 pixels high
--     /setCtlSize( Button1, 60, 32 )
--     -- size Button2 to 60 pixels wide, leaving the height unchanged.
--     /setCtlSize( Button2, 60, w32SameSize )
--     -- size Button3 to 25 pixels high, leaving the width unchanged.
--     /setCtlSize( Button3, w32SameSize, 25 )
--
--/endcode

global procedure setCtlSize(integer id, object pWidth, object pHeight)

-- resize the given item
integer x, y
atom oldBmp
sequence size, BBox, posn

    if validId(id)=w32False then
        return
    end if

    if equal(pWidth, w32SameSize) or equal(pHeight, w32SameSize) then
        size = getRect(id)
        if equal(pWidth, w32SameSize) then
            pWidth = size[3]-size[1]
        end if

        if equal(pHeight, w32SameSize) then
            pHeight = size[4]-size[2]
        end if
    end if

    if not integer(pWidth) or not integer(pHeight) then
        BBox = convPctToPixel(id, 0, 0, pWidth, pHeight)
        pWidth = BBox[3]
        pHeight = BBox[4]
    end if

    if ctrl_Family[id]=PIXMAP then

        -- get the bitmap, replace it with null
        oldBmp = ctrl_Handle[id]
        ctrl_Handle[id] = -1

        -- create a pixmap of the new size
        createPixmap(id, pWidth, pHeight)

        -- was there a prior bitmap?
        if oldBmp>0 then

            -- is there a current bitmap to draw into?
            if ctrl_Handle[id]!=0 then

                -- get size of old bitmap
                size = getCtlSize(oldBmp)
                pWidth = size[1]
                pHeight = size[2]

                -- copy the old bitmap onto the new one
                bitBlt(ctrl_Handle[id], 0, 0,
                       oldBmp, 0, 0, pWidth, pHeight, SRCCOPY)

            end if

            -- release the old bitmap
            deleteObject(oldBmp)

        end if

    else

        -- get the current location of the window
        posn = getPosition(id)
        x = posn[1]
        y = posn[2]

        -- normal window class, send MoveWindow to resize
        if not w32Func(xMoveWindow, {getHandle(id), x, y, pWidth, pHeight,1}) then
            warnErr("setCtlSize:MoveWindow failed.")
        end if

    end if


end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setRect( control, left, top, width, height, repaint )
--/desc Move and resize /i control.
--
-- /i control is moved to /i x, /i y, and sized to /i cx, /i cy. If the
-- /i repaint flag is set, the window is repainted.
--
-- To find the current size and position of /i control, use /getRect.
--
-- Example:
--
--/code
--          -- move Button1 to 20x20
--          sequence size
--
--          -- get the current size
--          size = /getCtlSize( Button1 )
--
--          -- change the size and repaint
--          /setRect( Button1, 20, 20, size[1], size[2], w32True )
--/endcode

global procedure setRect(integer id, object left, object top,
                object width, object height, integer repaint)
sequence BBox
integer lError

-- move the given window

    if ctrl_Type[id]=Pixmap then
        setCtlSize(id, width,height)
        return
    end if
    BBox = convPctToPixel(id, left, top, width, height)
    left  = BBox[1]
    top  = BBox[2]
    width = BBox[3]
    height = BBox[4]

    if not w32Func(xMoveWindow, {getHandle(id), left, top, width, height, repaint}) then
        lError = w32Func(xGetLastError,{})
        warnErr(sprintf("setRect:Repositioning Control failed. %d",lError))
    end if

    if ctrl_Type[id]=Window then
        w32Proc(xUpdateWindow, {getHWND(id)})
    end if

end procedure
r_setRect = routine_id("setRect")

--/topic Attributes
--/proc setCtlPosition( integer id, object x, object y )
--/desc Sets the location of the control. x and y can have any format /create() supports.
--
--Example
--/code
--      setCtlPosition( myBtn, 100, 200)
--/endcode
global procedure setCtlPosition(integer id, object x, object y)
sequence lRect

    lRect = getRect(id)
    setRect(id, x, y, lRect[3]-lRect[1], lRect[4]-lRect[2], 1)

end procedure
r_setCtlPosition = routine_id("setCtlPosition")
--/topic Attributes
--/proc setClientRect( integer id, object width, object height )
--/desc Sets the size of the client area in a window.
--The client area is the area used by the application. It excludes toolbar,
-- statusbar, menu area, etc... /n
--After using this routine, the window will be larger than the dimensions
-- specified here. Use /getRect() to retrive to total window area.
--
--Example
--/code
--       --Set the client area to exactly 300 by 200 pixels
--       setClientRect(myWindow, 300, 200)
--/endcode
------------------------------
global procedure setClientRect(integer id, object width, object height)
sequence client, diff, BBox



    -- Only work with valid IDs
    if validId(id)=w32False then
        return
    end if

    if not integer(width) or not integer(height) then
        BBox = convPctToPixel(id, 0, 0, width, height)
        width  = BBox[3]
        height = BBox[4]
    end if

    -- get current client size

    client = getClientRect(id)

    -- get current window size and subtract client size
--/**/  diff = sq_sub(getCtlSize(id),sq_sub(client[3..4],client[1..2]))     --/* -- Phix
    diff = getCtlSize(id) - (client[3..4] - client[1..2])                   --*/ -- RDS

    -- add difference to specified window size
    setCtlSize(id, width+diff[1], height+diff[2])

end procedure

--/topic Attributes
--/proc moveZOrder( integer id, atom ztype)
--/desc Move /i id to up or down the of Z order of windows.
--
--/i ztype can be one of HWND_TOP, HWND_BOTTOM, HWND_TOPMOST or
-- HWND_NOTOPMOST, or another control id. In the latter case, /i id will appear in front of /i ztype.
--
-- Example:
--
--/code
--          -- change the order of this window.
--          moveZOrder( msgWindow,  HWND_TOPMOST)
--
--          -- move id in front of id2
--          moveZOrder( id,  id2)
--/endcode

global procedure moveZOrder(integer id , atom ztype)

    if not validId(id) then
        return
    end if

    if not find(ztype, {HWND_TOP,HWND_BOTTOM,HWND_TOPMOST,HWND_NOTOPMOST})
    and validId(ztype) then
        ztype = getHandle(ztype)
    end if

    VOID = w32Func(xSetWindowPos, {getHandle(id),
                                   ztype, 0, 0, 0, 0,
                                   SWP_NOSIZE+SWP_NOMOVE})

end procedure
r_moveZOrder = routine_id("moveZOrder")

--/topic Attributes
--/proc refreshWindow( object ids )
--/desc Forces the control(s) to be refreshed.
-- /i ids can be either a single control id or a sequence of ids.
--
--Example:
--/code
--      refreshWindow({btn1, btn2})
--/endcode
global procedure refreshWindow(object ids)

    if atom(ids) then
        ids = {ids}
    end if

    for i=1 to length(ids) do
        if validId(ids[i]) then
            VOID = w32Func(xSetWindowPos, {getHandle(ids[i]),
                                           0, 0, 0, 0, 0,
                                           SWP_NOSIZE+SWP_NOMOVE+SWP_NOZORDER+
                                           SWP_DRAWFRAME+SWP_SHOWWINDOW})
        end if
    end for

end procedure

--/topic Attributes
--/proc distributeControls( sequence ids, integer disttype, object pValue)
--/desc Evenly distributes a set of controls.
--/i ids is the set of controls to distribute. There must be at least two ids
-- in the sequence. /n
--/i disttype is the type of distribution required. It can be one of... /n
--/li /b w32HorzCentre : The /i left edges are distributed evenly.
--/li /b w32HorzGap : The /i gap between right & left edges are equally.
--/li /b w32VertCentre : The /i top edges are distributed evenly.
--/li /b w32VertGap : The /i gap between bottom & top edges are equally.
--/i pValue is maximum distance that can span the controls. If this is 0
-- it is ignored. Otherwise it can be a pixel measurement, or a single control
-- id inside a sequence. See examples for details. If /i pValue is zero,
-- then the maximum distance is the largest distance between the controls in
-- /i ids.
--
--Examples
--/code
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, fld1 and fld3 remain
--      -- still while fld2 is centered between them.
--      distributeControls( {fld1, fld2, fld3}, w32HorzGap, 0)
--
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, only fld1 remains
--      -- still while fld2 and fld3 are moved such that the distance
--      -- between fld1 and fld3 is 200 pixels.
--      distributeControls( {fld1, fld2, fld3}, w32HorzGap, 200)
--
--      -- Move these fields such that the horizontal gap between
--      -- each is the same amount. In this case, only fld1 remains
--      -- still while fld2 and fld3 are moved such that the distance
--      -- between fld1 and fld3 is the width of fld4.
--      distributeControls( {fld1, fld2, fld3}, w32HorzGap, {fld4} )
--
--/endcode
global procedure distributeControls(sequence ids, integer disttype, object pValue)
sequence lRect, lDim
integer lHigh, lCur
atom lIncr, lLow

-- Minimum of 2 ids.
    if length(ids)<=1 then
        return
    end if

    -- Make space all the new locations
    lDim = repeat({0, 0, 0, 0}, length(ids))

    lRect = getRect(ids[1])
    if disttype=w32HorzCentre then
        -- left edges are evenly distributed
        lLow = lRect[1]
        lHigh = lRect[3]
        lDim[1][1] = lRect[1]
        lDim[1][2] = lRect[2]
        lDim[1][3] = lRect[3]-lRect[1]
        lDim[1][4] = lRect[4]-lRect[2]
        for i=2 to length(ids) do
            lRect = getRect(ids[i])
            lDim[i][1] = lRect[1]
            lDim[i][2] = lRect[2]
            lDim[i][3] = lRect[3]-lRect[1]
            lDim[i][4] = lRect[4]-lRect[2]
            if lLow>lRect[1] then
                lLow = lRect[1]
            end if
            if lHigh<lRect[3] then
                lHigh = lRect[3]
            end if
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[3]-lRect[1]
        end if
        if pValue!=0 then
            lHigh = lLow+pValue
        end if

        lHigh -= lDim[length(ids)][3]

        lIncr = (lHigh-lLow)

        lIncr /= (length(ids)-1)
        for i=1 to length(ids) do
            setRect(ids[i], floor(lLow), lDim[i][2], lDim[i][3], lDim[i][4], 0)
            lLow += lIncr
        end for

    elsif disttype=w32HorzGap then
        -- gap b/n right & left edges are equal
        lLow = lRect[1]
        lHigh = lRect[3]
        lCur = lRect[3]-lRect[1]
        for i=2 to length(ids) do
            lRect = getRect(ids[i])
            if lLow>lRect[1] then
                lLow = lRect[1]
            end if
            if lHigh<lRect[1]+lRect[3] then
                lHigh = lRect[3]
            end if
            lCur += (lRect[3]-lRect[1])
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[3]-lRect[1]
        end if

        if pValue!=0 then
            lIncr = pValue
        else
            lIncr = floor((lHigh-lLow-lCur)/(length(ids)-1))
        end if

        for i=1 to length(ids) do
            lRect = getRect(ids[i])
            setRect(ids[i], lLow, lRect[2],
                    lRect[3]-lRect[1], lRect[4]-lRect[2], 0)
            lLow +=  (lRect[3]-lRect[1])+lIncr
        end for

    elsif disttype=w32VertCentre then
        -- top edges are evenly distributed
        lLow = lRect[2]
        lHigh = lRect[4]
        lDim[1][1] = lRect[1]
        lDim[1][2] = lRect[2]
        lDim[1][3] = lRect[3]-lRect[1]
        lDim[1][4] = lRect[4]-lRect[2]
        for i=2 to length(ids) do
            lRect = getRect(ids[i])
            lDim[i][1] = lRect[1]
            lDim[i][2] = lRect[2]
            lDim[i][3] = lRect[3]-lRect[1]
            lDim[i][4] = lRect[4]-lRect[2]
            if lLow>lRect[2] then
                lLow = lRect[2]
            end if
            if lHigh<lRect[4] then
                lHigh = lRect[4]
            end if
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[4]-lRect[2]
        end if
        if pValue!=0 then
            lHigh = lLow+pValue
        end if

        lHigh -= lDim[length(ids)][4]

        lIncr = (lHigh-lLow)

        lIncr /= (length(ids)-1)
        for i=1 to length(ids) do
            setRect(ids[i], lDim[i][1], floor(lLow),  lDim[i][3], lDim[i][4],0)
            lLow += lIncr
        end for

    elsif disttype=w32VertGap then
        -- gap b/n bottom & top edges are equal
        lLow = lRect[2]
        lHigh = lRect[4]
        lCur = lRect[4]-lRect[2]
        for i=2 to length(ids) do
            lRect = getRect(ids[i])
            if lLow>lRect[2] then
                lLow = lRect[2]
            end if
            if lHigh<lRect[4] then
                lHigh = lRect[4]
            end if
            lCur += (lRect[4]-lRect[2])
        end for

        if sequence(pValue) then
            lRect = getRect(pValue[1])
            pValue = lRect[4]-lRect[2]
        end if
        if pValue!=0 then
            lIncr = pValue
        else
            lIncr = floor((lHigh-lLow-lCur)/(length(ids)-1))
        end if

        for i=1 to length(ids) do
            lRect = getRect(ids[i])
            setRect(ids[i], lRect[1], lLow,
                    lRect[3]-lRect[1], lRect[4]-lRect[2], 0)
            lLow +=  (lRect[4]-lRect[2])+lIncr
        end for

    end if

    repaintWindow(0)

end procedure

--/topic Attributes
--/proc sizeControls( object ids, object disttype, object pValue)
--/desc Set the size for a set of controls.
--/i ids is a sequence of ids to change, or a single id. /n
--/i sizetype is one of, or a list of ... /n
--/li w32Height
--/li w32Width
--/li w32Widest
--/li w32Narrowest
--/li w32Tallest
--/li w32Shortest
--
--/i pValue can be a pixel value or an id value in a sequence. /n
-- When using the ..est values for /i disttype, the ..est value is computed from both 
-- /i pValue and the supplied id(s).
--
--Example /n
--/code
--      sizeControls({fld1,fld3,fld4,fld7}, w32Widest, 200)
--      sizeControls({fld2,fld0,fld9,fld5}, w32Tallest, {lblXYZ} )
--      -- fld3 and fld2 to the same dimensions as btnOne
--      sizeControls({fld3,fld2}, {w32Height,w32Width}, {btnOne} )
--/endcode
global procedure sizeControls(object ids, object pSizetype, object pValue)
sequence lRect
object lValue
integer sizetype

    if atom(ids) then
        ids = {ids}
    end if
    if length(ids)=0 then
        return
    end if

    if atom(pSizetype) then
        pSizetype = {pSizetype}
    end if
    lValue = pValue
    for k=1 to length(pSizetype) do
        sizetype = pSizetype[k]
        pValue = lValue
        if sizetype=w32Width then
            -- all are set to the same width

            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[3]-lRect[1]
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                setRect(ids[i], lRect[1], lRect[2], pValue, lRect[4]-lRect[2], 0)
            end for

        elsif sizetype=w32Height then
            -- all are set to the same height
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[4]-lRect[2]
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                setRect(ids[i], lRect[1], lRect[2], lRect[3]-lRect[1], pValue, 0)
            end for

        elsif sizetype=w32Widest then
            -- all are set to the widest width
            if sequence(pValue) then
                lRect = getRect(pValue[1])
            else
                lRect = getRect(ids[1])
            end if
            pValue = lRect[3]-lRect[1]
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                if pValue<(lRect[3]-lRect[1]) then
                    pValue = lRect[3]-lRect[1]
                end if
            end for

            sizeControls(ids, w32Width, pValue)

        elsif sizetype=w32Narrowest then
            -- all are set to the narrowest width
            if sequence(pValue) then
                lRect = getRect(pValue[1])
            else
                lRect = getRect(ids[1])
            end if
            pValue = lRect[3]-lRect[1]
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                if pValue>(lRect[3]-lRect[1]) then
                    pValue = lRect[3]-lRect[1]
                end if
            end for

            sizeControls(ids, w32Width, pValue)

        elsif sizetype=w32Tallest then
            -- all are set to the tallest height
            if sequence(pValue) then
                lRect = getRect(pValue[1])
            else
                lRect = getRect(ids[1])
            end if
            pValue = lRect[4]-lRect[2]
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                if pValue<(lRect[4]-lRect[2]) then
                    pValue = lRect[4]-lRect[2]
                end if
            end for

            sizeControls(ids, w32Height, pValue)

        elsif sizetype=w32Shortest then
            -- all are set to the shortest height.
            if sequence(pValue) then
                lRect = getRect(pValue[1])
            else
                lRect = getRect(ids[1])
            end if
            pValue = lRect[4]-lRect[2]
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                if pValue>(lRect[4]-lRect[2]) then
                    pValue = lRect[4]-lRect[2]
                end if
            end for

            sizeControls(ids, w32Height, pValue)

        end if
    end for

    repaintWindow(0)
end procedure

--/topic Attributes
--/proc alignControls( object ids, integer disttype, object pValue)
--/desc Set the edge position for a set of controls.
--/i ids is a sequence of ids to change /n
--/i disttype is one of, or a list of ... /n
--/li w32LeftEdge
--/li w32RightEdge
--/li w32TopEdge
--/li w32BottomEdge
--/li w32VertCentre
--/li w32HorzCentre
--/li w32LeftMost
--/li w32RightMost
--/li w32TopMost
--/li w32BottomMost
--
--/i pValue, if used with the ...Most options, is the minimum position. When
-- used with the other options it is the exact position to use.
--It can be a pixel value or an id value in a sequence.
--
--Example /n
--/code
--      -- Align them all to fld3's left edge.
--      alignControls({fld1,fld3,fld4,fld7}, w32LeftEdge, {fld3})
--
--      -- Move these up to whatever among them is the topmost fld.
--      alignControls({fld2,fld0,fld9,fld5}, w32TopMost, 0 )
--
--      -- Center fld9 with respect to the screen
--      alignControls(fld9, {w32VertCentre,w32HorzCentre}, {Screen} )
--/endcode

global procedure alignControls(object ids, object pAligntype, object pValue)

sequence lRect
integer lWidth, lHeight, lNewValue
integer aligntype
object lValue

    if atom(ids) then
        ids = {ids}
    end if
    if length(ids)=0 then
        return
    end if
    if atom(pAligntype) then
        pAligntype = {pAligntype}
    end if

    lValue = pValue
    for k=1 to length(pAligntype) do
        aligntype = pAligntype[k]
        pValue = lValue
        if aligntype=w32LeftEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[1]
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3]-lRect[1]
                lHeight = lRect[4]-lRect[2]
                setRect(ids[i], pValue, lRect[2], lWidth, lHeight, 0)
            end for

        elsif aligntype=w32RightEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[3]
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3]-lRect[1]
                lHeight = lRect[4]-lRect[2]
                lNewValue = pValue-lWidth
                setRect(ids[i], lNewValue, lRect[2], lWidth, lHeight, 0)
            end for

        elsif aligntype=w32TopEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[2]
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3]-lRect[1]
                lHeight = lRect[4]-lRect[2]
                setRect(ids[i], lRect[1], pValue, lWidth, lHeight, 0)
            end for

        elsif aligntype=w32BottomEdge then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[4]
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3]-lRect[1]
                lHeight = lRect[4]-lRect[2]
                lNewValue = pValue-lHeight
                setRect(ids[i], lRect[1], lNewValue, lWidth, lHeight, 0)
            end for

        elsif aligntype=w32VertCentre then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[1]+floor((lRect[3]-lRect[1])/2)
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3]-lRect[1]
                lHeight = lRect[4]-lRect[2]
                lNewValue = pValue-floor(lWidth/2)
                setRect(ids[i], lNewValue, lRect[2], lWidth, lHeight, 0)
            end for

        elsif aligntype=w32HorzCentre then
            if sequence(pValue) then
                lRect = getRect(pValue[1])
                pValue = lRect[2]+floor((lRect[4]-lRect[2])/2)
            end if
            for i=1 to length(ids) do
                lRect = getRect(ids[i])
                lWidth = lRect[3]-lRect[1]
                lHeight = lRect[4]-lRect[2]
                lNewValue = pValue-floor(lHeight/2)
                setRect(ids[i], lRect[1], lNewValue, lWidth, lHeight, 0)
            end for

        elsif aligntype=w32Leftmost then
            lRect = getRect(ids[1])
            pValue = lRect[1]
            for i=2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue>lRect[1] then
                    pValue = lRect[1]
                end if
            end for
            alignControls(ids, w32LeftEdge, pValue)

        elsif aligntype=w32Rightmost then
            lRect = getRect(ids[1])
            pValue = lRect[3]
            for i=2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue<lRect[3] then
                    pValue = lRect[3]
                end if
            end for
            alignControls(ids, w32RightEdge, pValue)

        elsif aligntype=w32Topmost then
            lRect = getRect(ids[1])
            pValue = lRect[2]
            for i=2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue>lRect[2] then
                    pValue = lRect[2]
                end if
            end for
            alignControls(ids, w32TopEdge, pValue)

        elsif aligntype=w32Bottommost then
            lRect = getRect(ids[1])
            pValue = lRect[4]
            for i=2 to length(ids) do
                lRect = getRect(ids[i])
                if pValue<lRect[4] then
                    pValue = lRect[4]
                end if
            end for
            alignControls(ids, w32BottomEdge, pValue)

        end if
    end for
    repaintWindow(0)
end procedure


-----------------------------------------------------------------------------
procedure pushModal(integer id, atom hWnd, integer style, integer depth)
    -- set window as modal

    -- Save any existing modal id
    modalStack = append(modalStack, {modalWindow, modalhWnd, modalStyle, modalDepth})

    -- set new modal window
    modalWindow = id
    modalhWnd = hWnd
    modalStyle = style
    modalDepth = depth

end procedure

-----------------------------------------------------------------------------
procedure popModal()
-- remove modal flag
-- if there was a prior modal window, unstack it

integer pending

    pending = length(modalStack)

    -- need to unstack?
    if pending>0 then
        -- get previous modal window
        modalWindow = modalStack[pending][1]
        modalhWnd   = modalStack[pending][2]
        modalStyle  = modalStack[pending][3]
        modalDepth  = modalStack[pending][4]
        -- unstack
        modalStack = modalStack[1..pending-1]
    else
        warnErr("popModal: The Modal Window Stack is already empty.")
    end if

end procedure


-- NEW! 0.45
-----------------------------------------------------------------------------
--/topic Attributes
--/proc popup( popupMenu, x, y )
--/desc Display popupMenu at { /i x, /i y }.
--The coordinates /i x and /i y are relative to the parent window
--of the popup menu. If you are trapping the mouse position relative to
--some other control, you will need to pass both the id of the popup menu
--and the reference control for the coordiniates passed. This is done by
-- passing the first parameter as a 2-element sequence {popup, controlId}.
--
-- Example: Hard coded location relative to parent window.
--/code
--
--  -- create a popup for MyWindow
--  constant
--      MyPopup   = create( Popup, "", MyWindow, 0, 0, 0, 0, 0 )
--
--  -- add four items into it
--  constant
--      Item1     = create( MenuItem, "Item 1", MyPopup, 0, 0, 0, 0, 0 ),
--      Item2     = create( MenuItem, "Item 2", MyPopup, 0, 0, 0, 0, 0 ),
--      Item3     = create( MenuItem, "Item 3", MyPopup, 0, 0, 0, 0, 0 ),
--      Item4     = create( MenuItem, "Item 4", MyPopup, 0, 0, 0, 0, 0 )
--
--  -- popup the menu at {10,10} in MyWindow
--  popup( MyPopup, 10, 10 )
--
--/endcode
--
-- Example: Location relative to some other control.
--/code
--    --------------------------------
--    procedure Mouse_TV(integer self, integer event, sequence parms)
--    --------------------------------
--        integer index
--
--        if parms[1] = WM_RBUTTONDOWN then
--            -- The coordinates are relative to self and
--            -- not the parent window.
--            popup({TVPopup, self}, parms[2], parms[3] )
--        end if
--
--    end procedure
--
--/endcode


global procedure popup(object id, object x, object y)

integer parent
sequence pt, BBox
atom result
integer lPopupId
integer lRelId

    if atom(id) then
        lPopupId = id
        lRelId = 0
    else
        lPopupId = id[1]
        lRelId = id[2]
    end if

    if validId(lPopupId)=w32False
    or find(ctrl_Type[lPopupId],{Popup, Menu})=0
    or ((lRelId!=0) and (validId(lRelId)=w32False)) then
        return
    end if

    parent = findParentWindow(lPopupId)

    if lRelId!=0 and    parent!=lRelId then
        -- Convert the mouse positions from Relative to the Treeview
        -- to relative to the screen.
        BBox = ClientToScreen(lRelId, x, y)

        -- Now convert them relative to the parent window.
        BBox = ScreenToClient(parent, BBox[1], BBox[2])
        -- <parent> was previously findParent(lRelId),probably incorrect
        x = BBox[1]
        y = BBox[2]

    end if

    -- get parent

    -- convert the point to a screen point
    pt = getClientPoint(parent, x, y)

    -- popup the menu
    result = w32Func(xTrackPopupMenu, {getHandle(lPopupId),    -- menu
                                       0,                   -- flags
                                       pt[1], pt[2],        -- position
                                       0,                   -- reserved, must be 0
                                       getHandle(parent), -- owner window
                                       0})              -- pointer to rect
end procedure

-----------------------------------------------------------------------------
-- MOUSE
--
-----------------------------------------------------------------------------
--/topic Mouse
--/proc captureMouse( window )
--/desc Send all mouse events to /i window.
-- All mouse coordinates become relative to /i window. To release the mouse, use /releaseMouse.
--
-- Example:
--
--/code
--          -- grab the mouse for TheWindow
--          /captureMouse( TheWindow )
--/endcode


global procedure captureMouse(integer id)

    -- captures the mouse so all events are sent to that window

    -- capture the mouse
    if w32Func(xSetCapture, {getHandle(id)}) then
        warnErr("captureMouse:SetCapture failed.")
    end if

end procedure


-----------------------------------------------------------------------------
--/topic Mouse
--/proc releaseMouse()
--/desc Return control of the mouse to Windows.
-- This is called after /captureMouse to put control of the mouse
-- back to normal.
--
-- Example:
--
--/code
--          -- release the mouse.
--          /releaseMouse()
--/endcode

global procedure releaseMouse()
    -- release the mouse from a /captureMouse
    w32Proc(xReleaseCapture, {})
end procedure

-----------------------------------------------------------------------------
-- TIMERS
--
-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc setTimer( window, timer, ticks )
--/desc Start a timer ticking in /i window.
-- Timers are clocks that are maintained by Windows, and trigger events
-- at a user-specified interval, measured in milliseconds.
--
-- The arguments are:
-- /li /i window: /Window the timer belongs to.
-- /li /i timer: Unique ID assigned to the timer.
-- /li /i milliseconds: How much time, in milliseconds, that must pass
--              before triggering an /Timer event.
--
-- To respond to timer events, set a handler for the /w32HTimer event. You can have more
-- than one timer per /window. If your window is too busy to receive the
-- timer messages, they will be discarded.
--
-- Example:
--
--/code
--          -- start a timer with id #12 in MyWindow
--          -- it will trigger every 3 seconds.
--          /setTimer( MyWindow, 12, 3000 )
--/endcode

global procedure setTimer(integer id, integer timerId, atom ticks)

    -- set a timer to go off every ticks milliseconds
    w32Proc(xSetTimer, {getHandle(id), timerId, ticks, 0})

end procedure

-----------------------------------------------------------------------------
--/topic Low Level Routines
--/proc killTimer( window, timer )
--/desc Stop a timer.
-- This deactivates /i timer that was set with /setTimer.
--
-- Example:
--
--/code
--          -- deactivate timer #12
--          /killTimer( MyWindow, 12 )
--/endcode

global procedure killTimer(integer id, integer timerId)

    -- remove timer from window
    w32Proc(xKillTimer, {getHandle(id), timerId})

end procedure

-----------------------------------------------------------------------------
-- CURSORS
--
-----------------------------------------------------------------------------

--/topic Mouse
--/proc setDragPointer( object style)
--/desc Sets the mouse pointer shape to use when dragging.
-- Win32lib supports four cursor shapes for dragging. /n
-- /i style can be either an atom (handle) or a sequence of four handles. If it is an
-- atom then set all four drag pointers to the same value. /n
-- The sequence represents these shapes: /n
--<ul>
--/li [1] - Used when no keys pressed
--/li [2] - Used when the shift key is pressed
--/li [3] - Used when the control key is pressed
--/li [4] - Used when the Alt key is pressed.
--</ul>
-- If /i style is a sequence, if any element is /b 0 then the current value
-- for this position is not changed.
--
-- Initially all shapes are set to the CrossPointer.
--
-- /i Handles can be either one of the predefined system shapes, one created by
-- /createMousePointer() or one returned by /loadCursor().
--
-- Example:
--
--/code
--      setDragPointer( IconPointer )
--
--      setDragPointer( {IconPointer, -- set the 'normal' shape
--                       0  -- leave exsting 'Shift' shape alone
--                       loadCursor(mycursor), -- load 'Ctrl' shape from a file.
--                    } )
--
--/endcode

global procedure setDragPointer(object style)
    if atom(style) then
        style = repeat(style, 4)
    end if

    for i=1 to length(style) do
        if i>4 then
            exit
        end if
        if style[i]!=0 then
            vDragPointer[i] = style[i]
        end if
    end for

end procedure


procedure IndicateDragging(integer id, integer flag)
atom lPointerType

    if id then end if
    if flag then
        lPointerType = call_func(r_getKeyMasks,{0})
        if and_bits(lPointerType, ShiftMask) then
            lPointerType = 2
        elsif and_bits(lPointerType, ControlMask) then
            lPointerType = 3
        elsif and_bits(lPointerType, AltMask) then
            lPointerType = 4
        else
            lPointerType = 1
        end if
        -- Set the pointer shape for each possible control
        -- that can receive dragged data
        for i=1 to length(ctrl_Handlers) do
            if (atom(ctrl_Handlers[i])
                or atom(ctrl_Handlers[i][w32HDragAndDrop])
                or length(ctrl_Handlers[i][w32HDragAndDrop])>0)
               and ctrl_Destroyed[i]=0 then
                setMousePointer(i, vDragPointer[lPointerType])
            end if
        end for
    else
        -- Restore the pointer shape for each possible control
        -- that can receive dragged data
        for i=1 to length(ctrl_Handlers) do
            if (atom(ctrl_Handlers[i])
                or atom(ctrl_Handlers[i][w32HDragAndDrop])
                or length(ctrl_Handlers[i][w32HDragAndDrop])>0)
               and ctrl_Destroyed[i]=0 then
                restoreMousePointer(i)
            end if
        end for

    end if


end procedure




-- NEW! 0.45k
-----------------------------------------------------------------------------
--/topic Dialogs
--/func getColorDialog( window, default color )
--/desc "Get Color" Dialog
--/ret Selected color, or default color if nothing selected.
-- Calling this function brings up the modal "Select Color" dialog, allowing
-- the user to select a color from the default color list, or add a color to
-- the custom color list.
--
-- The parameter passed in /b default /b color is an atom representing the
-- default color to select, in #RRGGBB format. Passing -1 specifies that
-- the color black (#000000) is the default color.
--
--
-- Example:
--
--/code
--          -- get a color; red ( #FF0000 ) is the default
--          atom color
--          color = getColorDialog( Window, #FF0000 )
--/endcode


atom customColors
    customColors = w32acquire_mem(0, 64)

    for i=0 to 63 do
        poke(customColors+i,#FF)
    end for

global function getColorDialog(atom id, object defaultColor)

atom mem, result, color

    -- Allocate memory for the dialog and set it up
    mem = w32to_memory(0,ID_COLORDLG,
                       {getHandle(id),0, colorValue(defaultColor), customColors, CC_RGBINIT})

    -- call the routine
    result = w32Func(xColorDlg, {mem})
    if result then
        -- fetch the color
        color = w32fetch(mem, COLORDLG_rgbResult)
    else
        -- cancelled
        color = colorValue(defaultColor)
    end if

    -- release the buffer
    w32release_mem(mem)

    return color

end function



--/topic Attributes
--/func setTabStops(integer id, object flds)
--/desc This possibly establishes the controls in a containing control that get tabbing focus.
--/ret SEQUENCE: The list of controls that used to be the tabbing controls.
--/i id is the Id of a control that contains other controls. Usually a Window,
-- Group, or TabItem. /n
-- The /i flds parameter specifies a list of control ids. The order of the ids
-- is the new order of tabbing. Any control that is /b not in this list is
-- ignored by the tabbing process.
--
-- Passing an atom in /i flds will only return the current tabbing order sequence.
--Example:
--/code
--      sequence OldFlds
--      OldFlds = setTabStops(MainWin, {CustName, CustAddr, Telephone,
--                                     OKBtn, CancelBtn})
--/endcode
global function setTabStops(integer id, object flds)
sequence lOldTabs

    if validId(id)=0 then
        return {}
    end if
    lOldTabs = ctrl_Focus_order[id]

    if sequence(flds) then
        ctrl_Focus_order[id] = flds
    end if

    return lOldTabs
end function

--/topic Controls
--/proc tab_direction(integer id, integer direction )
--/desc Moves focus ahead or back to next available focus item
--/i id is the control that is your reference point. /n
--/i direction is the number of items to 'tab' over to. Negative values
-- move backward while postive values move forward.
--
--Example:
--/code
--      -- Tab forward to the next item that can take focus.
--      tab_direction(Fld1, 1)
--/endcode
global procedure tab_direction(integer id, integer direction)

    -- tabs ahead or back to next available focus item
    -- if nothing is found, doesn't focus on anything

integer parent, focus, at
sequence tabs


    -- is the id a window?
    if isTopLevelWindow(id) or find(ctrl_Type[id],{TabItem}) then
        -- parent is self
        parent = id

    elsif ctrl_Family[ctrl_Parent[id]]=COMBO    then

        -- This is a subclassed control, so use the parent (combo) as reference.

        id = ctrl_Parent[id]
        parent = ctrl_Parent[id]

    else
        -- parent is container
        parent = ctrl_Parent[id]

    end if

    -- get the parent's list of tabstop controls
    tabs = ctrl_Focus_order[parent]
    id = ctrl_Current_focus[parent]

    -- get the index of the item with focus
    at = find(id, tabs)
    if at=0 then
        at = 1
    end if

    -- look through all the tab stops
    for i=1 to length(tabs) do

        -- move in correct direction
        at += direction

        -- wrap?
        if at>length(tabs) then
            at = 1
        elsif at<1 then
            at = length(tabs)
        end if

        -- get proposed focus
        focus = tabs[at]

        -- can it take focus?
        if validId(focus) and
           isEnabled(focus) and
           isVisible(focus) then

            -- tab direction
            if ctrl_Type[focus]=TabItem then
                call_proc(r_setFocus,{focus})
            else
                w32Proc(xSetFocus, {getHandle(focus)})
            end if
            ctrl_Current_focus[parent] = focus
            -- leave
            return

        elsif direction=0 then
            direction = 1
        end if

    end for

end procedure

-- NEW! 0.54.5
sequence vTabKeyCodes
vTabKeyCodes =  {VK_TAB}

----------------------------------------------------------------------------
--/topic Controls
--/func setTabCodes( object newcodes)
--/desc Sets the list of tabbing keys to /i newcodes /n if it is valid.
--/ret The former value of that list, whether it changed or not.
--
-- Initially, the tabbing list is {VK_TAB}. You can supply a single key code or a
-- sequence of key codes. The list of valid key codes appears in the w32Keys.e file.
--
-- User defined tab keys behave like the default Tab. In particular, you may combine
-- them with the Shift key to request tabbing in reverse, or with the Control key inside
-- MleText or RichEdit controls.
--
-- If {} or a negative atom, the current value of the list is returned. If invalid key
-- codes are supplied, they will be ignored, since no key will match.
--
-- Avoid using VK_SHIFT, VK_CONTROL or VK_MENU as tab keys; the effects are undefined.
-- Also, some keys have a usual meaning when combined with Shift or Control, like the F4
-- key. You will probably confuse the user if using this sort of keys.
--
-- Example:
--     -- Allows the F8 key to act as Tab
--       VOID = setTabCodes({VK_TAB,VK_F8})
global function setTabCodes(object newcodes)

sequence oldcodes

    oldcodes = vTabKeyCodes

    if    atom(newcodes)
    and newcodes>=0
    then
        vTabKeyCodes = {newcodes}

    elsif sequence(newcodes)
      and length(newcodes)>0
    then
        vTabKeyCodes = newcodes
    end if

    return oldcodes
end function

--/topic Edit controls
--/topic RichEdit controls
--/func setTabEnabled( integer id, integer flag)
--/desc Possibly sets the flag which says whether a (Rich)Edit control uses Ctrl-Tab for tabbing
-- between controls.
-- Pass 0 as /i flag to disable need for the Ctrl key, /w32GetValue to just get the flag value, or anything else to enable it.
-- For (Rich)Edit controls, the need for the Ctrl key is turned on by default, and
-- disabled for other controls.
--/ret The previous value of the flag, or -1 if the /i id was invalid.
global function setTabEnabled(integer id, integer flag)
integer oldflag

    if validId(id) then
        oldflag = ctrl_TabKey_Used[id]
        if flag!=w32GetValue then
            ctrl_TabKey_Used[id] = w32iff(flag!=0, 1, 0)
        end if
    else
        oldflag = -1
    end if

    return oldflag

end function

--/topic System Attributes
--/func getKeyState(atom key)
--/desc Gets the depressed stats of the /i key.
--/ret INTEGER: w32True if the /i key is pressed otherwise w32False
--
--Example:
--/code
--      if getKeyState( VK_NUMPAD0) then
--          cmd = kStop
--      elsif getKeyState( VK_NUMPAD2) then
--          cmd = kDown
--      elsif getKeyState( VK_NUMPAD4) then
--          cmd = kLeft
--      elsif getKeyState( VK_NUMPAD6) then
--          cmd = kRight
--      elsif getKeyState( VK_NUMPAD8) then
--          cmd = kUp
--      else
--          cmd = 0
--      end if
--      processCmd(cmd)
--/endcode

global function getKeyState(atom key)

-- return the state Shift, Control, or Menu keys
atom result

-- get key
    result = w32Func(xGetKeyState, {key})

    -- check the high bit. (low bit is toggle state)
    return (floor(result/2)!=0)

end function

----------------------------------------------------------------------------
function isTabKey(integer id, atom key)

    -- returns true if it's a tab key
    -- MleText requires the Ctrl key be pressed as well

atom result
integer tabdir

    -- key event and tab?

    tabdir = 0
    if  find(key, vTabKeyCodes) then
        -- Is raw tab key allowed for this control?
        if ctrl_TabKey_Used[id]=w32False then
            -- only respond if CTRL key is pressed as well
            result = getKeyState(VK_CONTROL)
            tabdir = w32iff(result!=0, 1, 0)
        else
            -- it's a tab
            tabdir = 1
        end if

        if tabdir!=0 then
             -- Check for shift key, to reverse tabbing direction.
            result = getKeyState(VK_SHIFT)
            if result!=0 then
                tabdir = -tabdir
            end if
        end if
    end if

    return tabdir

end function

-- Rewritten CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: tab item visibility uses the same group visibility routine as showControlSet()
-- thys respecting individual visibility of controls.

procedure activateTabItems(integer id)
integer parent
integer old_focus

    parent = ctrl_Parent[id]
    old_focus = ctrl_Current_focus[parent]
    if old_focus!=id then
        ctrl_Current_focus[parent] = id
        if old_focus then
            setControlVisible(ctrl_Group[old_focus],w32False)
        else
            for i=1 to length(ctrl_Specific[parent]) do
                if ctrl_Specific[parent][i]!=id then
                    setControlVisible(ctrl_Group[ctrl_Specific[parent][i]],w32False)
                end if
            end for
        end if
    end if
    setControlVisible(ctrl_Group[id],w32True)

end procedure
r_activateTabItems = routine_id("activateTabItems")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setFocus( id )
--/desc Set the focus to the specified window or control.
-- This will cause the window or control that currently has focus
-- to lose it.
--
-- The window or control losing focus will get an /LostFocus event,
-- and the window or control that is getting focus will get an /GotFocus
-- event.
--
-- Controls that are not visible or not enabled, will never receive focus. Neither will the controls whose ability to get focus was disabled using /canFocus().
-- If you try to, nothing will actually happen.

global procedure setFocus(object id)

-- set the focus
atom parent, item , hWnd, subitem

    if sequence(id) then
        item = id[2]
        id = id[1]
    else
        item = -1
    end if

    if  not isEnabled(id)
    or
    not isVisible(id) then
        return  -- Either can't see it, or shouldn't touch it.
    end if

    if ctrl_Type[id]=TabItem then

        parent = ctrl_Parent[id]
        item = find(id, ctrl_Specific[parent])-1
        VOID = sendMessage(parent, TCM_SETCURSEL, item, 0)
        activateTabItems(id)
        return
    end if

    focus_current = id

    hWnd = getHandle(id)
    w32Proc(xSetFocus, {hWnd})

    if item>0 then
        if ctrl_Type[id]=TreeView then
            subitem = tvitem_handle[item]
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, subitem})
            VOID = w32Func(xSendMessage, {hWnd, TVM_SELECTITEM, TVGN_CARET, subitem})

        elsif ctrl_Type[id]=ListView then
            subitem = item-1
            VOID = w32Func(xSendMessage, {hWnd, LVM_SETHOTITEM, subitem,0})
            VOID = w32Func(xSendMessage, {hWnd, LVM_ENSUREVISIBLE, subitem,0})
            setLVItem(id, LVIF_STATE, item, 0, or_bits(LVIS_SELECTED,LVIS_FOCUSED),
                      or_bits(LVIS_SELECTED,LVIS_FOCUSED), 0, 0, 0)

        end if
    end if
end procedure
r_setFocus = routine_id("setFocus")

--/topic Attributes
--/func getFocus( )
--/desc Gets the id of the control that has focus.
--/ret INTEGER: The id of the control that has focus.
global function getFocus()
    return getId(w32Func(xGetFocus, {}))
end function


-----------------------------------------------------------------------------
-- NEW! 0.45a
-- Allow user to select tooltip font
integer
    hintFontSize,
    hintFontAttrib
--sequence
--  hintFontName


-- set defaults
--  hintFontName   = "MS Sans Serif"
    hintFontSize   = 8
    hintFontAttrib = Normal


-- NEW! 0.45a
-----------------------------------------------------------------------------
--/topic Fonts
--/proc setHintFont( font, point size, attributes )
--/desc Set font type and size for the control's hints.
--
-- Default values are { "MS Sans Serif", 8 points, Normal }.
--
-- Example:
--
--/code
--   /setHintFont( "Times New Roman", 10, /Bold)
--/endcode
-- You can also call /setFont( /i tooltipControl )

global procedure setHintFont(sequence w32FontName, integer points, integer attrib)

    setFont(tooltipControl, w32FontName, points, attrib)

end procedure


-- NEW! 0.45b

-----------------------------------------------------------------------------
--/topic Mouse
--/func getPointerRelPos(integer id)
--/desc Retrieves relative position of the mouse.
--/ret SEQUENCE: Mouse {x,y} position, relative to the control specified by /i id.
--
-- Example:
--
--/code
-- sequence pos
--
--  pos = getPointerRelPos(myWindow)
--  if pos[1] > 200 then
--      -- code goes here...
--  end if
--/endcode

global function getPointerRelPos(integer pId)

    if validId(pId) then
--/**/  return sq_sub(getPointerPos(),ClientToScreen(pId, 0, 0))    --/* -- Phix
        return getPointerPos() - ClientToScreen(pId, 0, 0)          --*/ -- RDS
    else
        return {0,0}
    end if

end function

-- Changed CChris <oedoc@free.fr> Oct 26, 2006
-- Bug fix: When a control set becomes visible, controls made manually invisible would display again

--/topic Controls
--/proc showControlSet(integer id)
--/desc Makes visible all the controls in the identified set, and hides the previously shown set.
--
--/i id is the id of a ControlSet created by /setControlSet
--
--Example:
--/code
--      sequence FuncGroup
--      sequence TriggerGroup
--      constant CustomerGrp=1, OrderGrp=2, InventGrp=5, AdminGrp=7
--
--      setControlSet(CustomerGrp, w32True, {Fld1, Fld2, Fld3})
--      setControlSet(OrderGrp, w32True, {Fld11, Fld12, Fld13, Fld14})
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(AdminGrp, w32True, {Fld31, Fld32, Fld33})
--      TriggerGroup = {Btn1,        Btn2,     Btn3,      Btn4}
--      FuncGroup    = {CustomerGrp, OrderGrp, InventGrp, AdminGrp}
--
--      procedure Click_Buttons(integer self, integer event, sequence parms)
--          showControlSet( FuncGroup[ find(self, TriggerGroup) ] )
--      end procedure
--      setHandler(TriggerGroup, w32HClick, routine_id("Click_Buttons"))
--/endcode
integer r_hideControlSet
global procedure showControlSet(integer id)
    if not equal(id, vCurrentControlSet) and
       id>0 and
       id<=length(vControlSets) then
        setControlVisible(vControlSets[id], w32True)
        if integer(vCurrentControlSet) then
            call_proc(r_hideControlSet,{vCurrentControlSet})
        end if
        vCurrentControlSet = id
    end if
end procedure

--/topic Controls
--/proc hideControlSet(object set)
--/desc Hides all the controls in the identified set(s).
--/i set is either a single ControlSet id, or a list of ControlSet ids.
--
--If /i set is zero, then all known ControlSets are hidden.
--
--Example:
--/code
--      -- Hide all sets
--      hideControlSet(0)
--      -- Hide one set
--      hideControlSet(2)
--      -- Hide a few sets
--      hideControlSets({1,3,2,5})
--/endcode

global procedure hideControlSet(object id)
    if atom(id) then
        if id=0 then
            for i=1 to length(vControlSets) do
                setControlVisible(vControlSets[i], w32False)
            end for
            return
        else
            id = {id}
        end if
    end if
    for i=1 to length(id) do
        if id[i]>0 and id[i]<=length(vControlSets) then
            setControlVisible(vControlSets[id[i]], w32False)
        end if
    end for

end procedure
r_hideControlSet = routine_id("hideControlSet")

--/topic Controls
--/proc enableControlSet(integer id)
--/desc Enables all the controls in the identified set, and disables the previously enabled set.
--
--/i id is the id of a ControlSet created by /setControlSet
--
--Example:
--/code
--      sequence FuncGroup
--      sequence TriggerGroup
--      constant CustomerGrp=1, OrderGrp=2, InventGrp=5, AdminGrp=7
--
--      setControlSet(CustomerGrp, w32True, {Fld1, Fld2, Fld3})
--      setControlSet(OrderGrp, w32True, {Fld11, Fld12, Fld13, Fld14})
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(AdminGrp, w32True, {Fld31, Fld32, Fld33})
--      TriggerGroup = {Btn1,        Btn2,     Btn3,      Btn4}
--      FuncGroup    = {CustomerGrp, OrderGrp, InventGrp, AdminGrp}
--
--      procedure Click_Buttons(integer self, integer event, sequence parms)
--          enableControlSet( FuncGroup[ find(self, TriggerGroup) ] )
--      end procedure
--      setHandler(TriggerGroup, w32HClick, routine_id("Click_Buttons"))
--/endcode
global procedure enableControlSet(integer id)
    if not equal(id, vCurrentControlSet) and
       id>0 and
       id<=length(vControlSets) then
        setEnable(vControlSets[id], w32True)
        if integer(vCurrentControlSet) then
            setEnable(vControlSets[vCurrentControlSet], w32False)
        end if
        vCurrentControlSet = id
    end if
end procedure

--/topic Controls
--/proc disableControlSet(object set)
--/desc Disables all the controls in the identified set(s).
--/i set is either a single ControlSet id, or a list of ControlSet ids.
--
--If /i set is zero, then all known ControlSets are disabled.
--
--Example:
--/code
--      -- Disable all sets
--      disableControlSet(0)
--      -- Disable one set
--      disableControlSet(2)
--      -- Disable a few sets
--      disableControlSets({1,3,2,5})
--/endcode

global procedure disableControlSet(object id)
    if atom(id) then
        if id=0 then
            for i=1 to length(vControlSets) do
                setEnable(vControlSets[i], w32False)
            end for
            id = {}
        else
            id = {id}
        end if
    end if

    for i=1 to length(id) do
        if id[i]>0 and id[i]<=length(vControlSets) then
            setEnable(vControlSets[id[i]], w32False)
        end if
    end for
end procedure

--/topic Controls
--/proc setControlSet(integer Set, integer Add, object id)
--/desc Create and maintains the entries in a control set.
--ControlSets are used to easily manipulate a set of related controls.
--
--/i Set is the id of the control set. If it doesn't exist, it is created. /n
--/i Add is a True/False flag. If w32True then the /id is added to the set,
-- otherwise it is removed from the set. /n
--/i id is either a single control id or a list of control ids.
--
-- If any control set exists at the time WinMain() is called, all control sets other
-- than the first are hidden and the one with index 1 is shown. You may choose to start
-- indexing at 2.
--
--Example:
--/code
--      -- Add some controls to a set.
--      setControlSet(InventGrp, w32True, {Fld21, Fld22})
--      setControlSet(InventGrp, w32True, {Fld23, Fld25})
--      -- The control set 'InventGrp' now has 4 ids in it.
--      -- Remove one.
--      setControlSet(InventGrp, Fld22)
--      -- The control set 'InventGrp' now has 3 ids in it.
--/endcode
--
--See also: /showControlSet, /hideControlSet, /enableControlSet, /disableControlSet

global procedure setControlSet(integer pSet, integer pAdd, object id)
--  integer lPos

    if pSet<=0 then
        return
    end if
    if pSet>length(vControlSets) then
        vControlSets &= repeat({}, pSet-length(vControlSets))
    end if

    if not sequence(id) then
        id = {id}
    end if

    if pAdd=w32True then
        for i=1 to length(id) do
            if not find(id[i], vControlSets[pSet]) then
                vControlSets[pSet] &= id[i]
            end if
        end for
    else
        for i=1 to length(id) do
            vControlSets[pSet] = w32removeItem(id[i], vControlSets[pSet])
        end for
    end if

end procedure

--/topic TreeView Control
--/func hitTestTV( id )
--/desc Check to see if mouse is over a /TreeView item
--/ret Index of /TreeView item under mouse, or zero, if none
global function hitTestTV(integer id)
atom ht, iItem, flags
sequence pt

    pt = getPointerRelPos(id)

    -- need to calculate offset due to control position
    ht = w32to_memory(0,ID_TVHITTESTINFO, {pt[1], pt[2], 0, 0})

    iItem = sendMessage(id, TVM_HITTEST, getHandle(id), ht)

    flags = w32fetch(ht, TVHITTESTINFO_flags)

    if and_bits(flags, TVHT_ONITEM) then
        iItem = find(iItem, tvitem_handle)
    else
        iItem = 0
    end if

    w32release_mem(ht)

    return iItem
end function


--!/* Begin Tone Skoda --
-- [Created on 6. June 2002, 14:23]

--/topic TreeView Control
--/func expandTV(object TVID, object ItemID, integer Action)
--/desc Expands or Collapses all child tree items.
--/ret INTEGER: The inverse of /i pAction
-- /i TVID is the id of a TreeView control /n
-- /i ItemID is the id of a TreeView item as returned by /addTVItem /n
-- /i Action is either TVE_EXPAND or TVE_COLLAPSE. The default is TVE_EXPAND. /n
-- This routine expands or collapses all the items, starting with /i ItemId, and
-- continuing down the hierarchy. /n
-- /b Returning the opposite of /i Action. Thus if /i Action was /b TVE_EXPAND then
-- this would return /b TVE_COLLAPSE, and visa versa.
--
--Example:  /i<See demo /b<ListTreeView.exw>>
--/code
--      integer nextAction
--      nextAction = TVE_EXPAND
--      nextAction = expandTV( myTV, rootItem, nextAction)
--/endcode
constant tvActions = {TVE_EXPAND, TVE_COLLAPSE}
function Internal_expandTV(object treewnd, object item_handle, integer pAction, integer pLock)
atom hChild
atom hTV

    if sequence(treewnd) then
        hTV = treewnd[1]
    else
        hTV = getHandle(treewnd)
    end if

    if sequence(item_handle) then
        item_handle = item_handle[1]
    elsif item_handle then
        item_handle = tvitem_handle[item_handle]
    end if

    if not find(pAction, tvActions) then
        pAction = TVE_EXPAND
    end if

    if pLock=w32True then
        VOID = w32Func(xLockWindowUpdate, {hTV})
    end if

    VOID = w32Func(xSendMessage,{hTV, TVM_EXPAND, pAction, item_handle})
    hChild = w32Func(xSendMessage,{hTV, TVM_GETNEXTITEM, TVGN_CHILD, item_handle})
    while hChild do
        VOID = Internal_expandTV({hTV}, {hChild}, pAction, w32False)
        hChild = w32Func(xSendMessage,{hTV, TVM_GETNEXTITEM, TVGN_NEXT, hChild})
    end while
    if pLock=w32True then
        VOID = w32Func(xLockWindowUpdate,{0})
    end if
    return tvActions[w32iff(find(pAction, tvActions)=1,2,1)]
end function
global function expandTV(object treewnd, object item_handle, integer pAction)
    return Internal_expandTV(treewnd, item_handle, pAction, w32True)
end function

-- End Tone Skoda

-----------------------------------------------------------------------------
--/topic System Attributes
--/func getLEDs()
--/desc Returns or'ed flags representing the state of the keyboard LEDs.
--/ret INTEGER: A sum of zero or more LED flags.
-- Known flags are:
--/li NumLockFlag
--/li CapsLockFlag
--/li ScrollLockFlag

global constant NumLockFlag = 1, CapsLockFlag = 2, ScrollLockFlag = 4

global function getLEDs()
integer result
    result = and_bits(w32Func(xGetKeyState,{VK_NUMLOCK}),1)*NumLockFlag
    if and_bits(w32Func(xGetKeyState,{VK_CAPITAL}),1) then
        result += CapsLockFlag
    end if
    if and_bits(w32Func(xGetKeyState,{VK_SCROLL}),1) then
        result += ScrollLockFlag
    end if
    return result
end function

integer shifts shifts = 0

-----------------------------------------------------------------------------
function getKeyMasks(atom wParam)

-- return the state Shift, Control, and Menu keys
integer flags

-- report keyboard shifts
    flags = shifts

    if and_bits(wParam, LEFT_BUTTON) then
        flags += LeftBtnMask
    end if

    if and_bits(wParam, RIGHT_BUTTON) then
        flags += RightBtnMask
    end if

    if and_bits(wParam, MIDDLE_BUTTON) then
        flags += MiddleBtnMask
    end if

    return flags

end function
r_getKeyMasks = routine_id("getKeyMasks")



-----------------------------------------------------------------------------

procedure resizeWidgets(integer id) --, integer cx, integer cy )

-- this is called when a window has been resized.

integer lMoveId, lRepaint

-- Special handling for rebars.
    for i=1 to length(ctrl_Init_Posns[id][1]) do
        lMoveId = ctrl_Init_Posns[id][1][i]
        lRepaint = w32iff(ctrl_Type[lMoveId]=Window,1,0)
        setRect(lMoveId,
                ctrl_Init_Posns[id][2][i][1],
                ctrl_Init_Posns[id][2][i][2],
                ctrl_Init_Posns[id][2][i][3],
                ctrl_Init_Posns[id][2][i][4], lRepaint)
    end for

end procedure


integer vSkipF10 vSkipF10 = w32False

--/topic Menus
--/func skipF10(integer NewValue)
--/desc Possibly sets whether or not F10 sets focus on the menubar
--/ret Returns INTEGER: The current value of the flag.
--By default, the F10 key sets focus on the menubar. If /i NewValue
-- is w32True, then the behaviour is changed so that the F10 key does not
-- set focus on the menubar. Passing /w32GetValue will just return the current value of the flag.
--
--Example:
--/code
--      integer PrevF10Flag
--      PrevF10Flag = skipF10( w32True )
--/endcode

-----------------------------------------------------------------------------
global function skipF10(integer pNewValue)
-----------------------------------------------------------------------------
integer lOldValue

    lOldValue = vSkipF10
    if pNewValue!=w32GetValue then
        vSkipF10 = (pNewValue!=0)
    end if
    return lOldValue

end function

-----------------------------------------------------------------------------
function isHotKey(integer id, atom hWnd, atom event, atom key, atom lParam, atom pReturn)
-----------------------------------------------------------------------------

integer window, focus , i
sequence hotkeys, hotids

    -- if there is a control in the hotkey list associated with the
    -- toplevel parent window, set focus to that control and return
    -- true.
    --
    -- note that some controls (like TabControl) can have several items
    -- with the same hotkey, since only one group of controls are enabled
    -- at a time.

    -- find the top level window

    window = findParentWindow(id)
    if window=0 then
        return {kSubclassedMsg} -- control is not in a window!
    end if

    -- get the hotkey list
    hotkeys = upper(ctrl_Hotkey_Keys[window]) & lower(ctrl_Hotkey_Keys[window])
    hotids  = ctrl_Hotkey_Ids[window] & ctrl_Hotkey_Ids[window]
    -- any controls with same parent have this hotkey?
    while 1 do
        i = find(key, hotkeys)
        if i=0 then
            exit
        end if

        -- get item with hotkey
        focus = hotids[i]

        if ctrl_Family[focus]=MENU or ctrl_Family[focus]=MENUITEM then
            exit
        -- is the control enabled and visible?
        elsif  isEnabled(focus)
          and isVisible(focus) then
            -- change focus
            if ctrl_Type[focus]=TabItem then
                setFocus(focus)
            else
                w32Proc(xSetFocus, {getHandle(focus)})
            end if
            if ((event=WM_KEYDOWN) or (event=WM_SYSCHAR)) then
                if ctrl_Family[focus]=BUTTON then
                    VOID = sendMessage(focus, BM_CLICK, 0, 0)
                elsif ctrl_Type[focus]=Window then
                    VOID = sendMessage(focus, WM_LBUTTONDOWN, 0, 0)
                    VOID = sendMessage(focus, WM_LBUTTONUP, 0, 0)
                end if
            end if

            -- return true; hotkey handled
            return {kMainMsg,-1}
        else
            hotkeys = hotkeys[i+1..length(hotkeys)]
            hotids  = hotids[i+1..length(hotids)]
        end if
    end while

    -- hotkey not handled
    return {kSubclassedMsg}
end function

constant kMsgCommandCode = {
                            {BUTTON,BN_CLICKED},     -- Button click
                            {STATIC,STN_CLICKED},    -- Label(static) click
                            {LISTBOX,LBN_SELCHANGE},  -- combo/list box selection change
                            {EDIT,EN_CHANGE},      -- editbox notify change
                            {COMBO,CBN_EDITCHANGE}, -- combo notify change has occured
                            {COMBO,CBN_SELCHANGE},  -- combo/list box notify change
                            {COMBO,CBN_DROPDOWN},   -- The combobox is about to dropdown.
                            {COMBO,CBN_CLOSEUP}
    --,    -- The combobox dropdown has just been closed
    --{COMBO,CBN_SETFOCUS},   -- The list gained focus
    --{COMBO,CBN_KILLFOCUS}    -- The list gained focus
                           }

constant kW32EventCode = {
                          {w32HClick,   0},  -- Button
                          {w32HClick,   0},  -- Label Click
                          {w32HChange,  w32CHG_Sel},     -- list box notify change
                          {w32HChange,  w32CHG_Chg},     -- editbox notify change
                          {w32HChange,  w32CHG_Chg},     -- combo data changed
                          {w32HChange,  w32CHG_Sel},     -- combo selection changed
                          {w32HDropDown,0}, -- combo is about to dropdown.
                          {w32HCloseUp, 0}
    --,   -- combo dropdown has just been closed
--    {w32HGotFocus,0},  -- combo gains focus
--    {w32HLostFocus,0}  -- combo loses focus
                         }

-----------------------------------------------------------------------------
procedure wmCommand(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------

-- this handles notification (WM_COMMAND) messages
-- this is used by WINDOW and TabControls.

integer event, w32event
integer lPos
sequence parms
object lExtra
sequence lObjEvent

    if hWnd or iMsg or lParam then end if

    -- determine which window sent the message
    -- update with new id

    if ctrl_Type[id]=FlatToolBar then
        id = w32lo_word(wParam)
    end if

    -- clear parms

    parms = {}
    lExtra = {}
    event = w32hi_word(wParam)

    lObjEvent = {ctrl_Family[id],event}
    lPos = find(lObjEvent, kMsgCommandCode)
    if lPos!=0 then
        lExtra &= kW32EventCode[lPos][2]
        w32event = kW32EventCode[lPos][1]
        -- Special handling for Radio buttons that get focus via tabbing.
        if w32event=w32HClick and
           ctrl_Type[id]=Radio and
           sendMessage(id, BM_GETCHECK, 0, 0)=0 then
            return
        end if
        -- Special handling for COMBO and LISTBOX
        if lObjEvent[1]=COMBO then
            lExtra &= 1+sendMessage(id, CB_GETCURSEL, 0, 0)
        elsif lObjEvent[1]=LISTBOX then
            lExtra &= 1+sendMessage(id, LB_GETCURSEL, 0, 0)
        end if
        VOID  = invokeHandler(id, w32event, lExtra)
    end if

end procedure

--/topic ListView control
--/proc setLVStyle(integer ID, object StyleFlags)
--/desc Sets the extended style flags on a listview
--
--/i StyleFlags can either be an atom containing all then
-- flag bits set to a sequence of flag names. The valid names are <a href="..\win32_constants.htm#ListView extended style flags">in this list</a>. \n
--
--Example
--/code
--      setLVStyle(myListView, {LVS_EX_FULLROWSELECT,
--                              LVS_EX_GRIDLINES,
--                              LVS_EX_HEADERDRAGDROP})
--/endcode
global procedure setLVStyle(integer pId, object pStyleFlags)
atom lMask

    if sequence(pStyleFlags) then
        lMask = w32or_all(pStyleFlags)
    else
        lMask = pStyleFlags
    end if

    VOID = sendMessage(pId, LVM_SETEXTENDEDLISTVIEWSTYLE, lMask, lMask)
end procedure

--/topic ListView control
--/func setLVAttr(integer id, sequence pNewData)
--/desc Set (some) attributes of a ListView control
--/ret SEQUENCE: The current attributes.
-- /i id is the ListView's id /n
-- /i pNewData is a list of two-element sequences. The first
-- element is the code name for the attribute being changed,
-- and the second is the new value for it.
--
--<ul>
--/li /i kLVColTypes The data types per column for sorting. /n
-- The data is a sequence, one element per column. /n
-- The values can be one of: /n
--<ul>
--/li 'i' = Case Insensitive sorting
--/li 'n' = Numeric Sorting
--/li 'a' = Case sensitive
--</ul>
--/li /i kLVSortSeq The sorting direction, per column, to use. /n
-- The values for the kLVSortSeq attribute can be: /n
--<ul>
--/li -2 = swaps between ascending and descending for each column click.
--/li -1 = descending
--/li  1 = ascending
--/li  2 = swaps between descending and ascending for each column click.
--</ul>
--/li /i kLVSortRtn The routine_id, per column, of the user-defined sorting routine.
-- If any column value is set to -2, then the default routine is used. If set
-- to -1 then no sorting is done on that column.
--
-- When a user clicks on a column heading on a listview, Win32lib tries to sort
-- the ListView based on the contents of the row data. You are able to specify
-- your own sorting method if the built-in ones are not sufficient.
--
-- The user-defined sorting routine is called whenever Windows needs to know which
-- of two items goes before, goes after, or are equivalent. The exact number of times
-- that this is called depends on the number of items in the listview, however you can
-- expect it to be called many times for each sort request.
--
-- The user-defined routine is passed four parameters: /n
--/code
--    integer ID    -- The control id of the listview
--    integer ItemA -- The row number of one of the items to compare
--    integer ItemB -- The row number of the other item to compare
--    integer Column-- The column number that was clicked on.
--/endcode
--
-- The user-defined routine is also called just before the sorting starts and just
-- after it finishes. In these cases, ItemA and ItemB are both -1 and the Column
-- value is either w32LV_StartSorting or w32LV_EndSorting, respectively. /n
-- When called at the start of sorting, your routine is expected to return w32True
-- if the sort can commence, otherwise the sort request is rejected.
--
-- /b Note that the cursor is changed to the 'hourglass' shape during the sorting
-- process.
--</ul>
--
--Example:
--/code
--    sequence ov
--    -- Indicate that col 1 is case-insensitive, and col 2 is numeric.
--    -- Indicate that col 1 swaps directions, and col 2 is always ascending.
--    ov = setLVAttr( myLV, {{kLVColTypes, {'i','n'}},
--                           {kLVSortSeq, {-2, 1}},
--                           {kLVSortRtn, {-2, routine_id("lvsort")}}
--                       })
--/endcode
global function setLVAttr(integer id, sequence pNewData)
sequence lOldData
integer lv

    lv = find(id, lv_id)
    if lv=0 then
        return {}
    end if

    lOldData = lv_properties[lv]

    for i=1 to length(pNewData) do
        if pNewData[i][1]=kLVColTypes then
            lv_properties[lv][kLVColTypes] = pNewData[i][2]

        elsif pNewData[i][1]=kLVSortSeq then
            lv_properties[lv][kLVSortSeq] = pNewData[i][2]

        elsif pNewData[i][1]=kLVSortRtn then
            lv_properties[lv][kLVSortRtn] = pNewData[i][2]
            if sequence(lv_properties[lv][kLVSortRtn]) then
                for j=1 to length(lv_properties[lv][kLVSortRtn]) do
                    if lv_properties[lv][kLVSortRtn][j]= -2 then
                        lv_properties[lv][kLVSortRtn][j] = r_lvSortitems
                    end if
                end for
            else
                if lv_properties[lv][kLVSortRtn]= -2 then
                    lv_properties[lv][kLVSortRtn] = r_lvSortitems
                end if
            end if
        end if
    end for

    return lOldData
end function


function lvSortitems(integer id, integer lItem1, integer lItem2, integer column)
object text1, text2, textnum
sequence lProps

    lProps = lv_properties[find(id, lv_id)]
    text1 = getLVItemText(id, lItem1, column)
    if sequence(lProps[kLVColTypes]) and length(lProps[kLVColTypes])>=column then
        if equal(lProps[kLVColTypes][column], 'i') then
            text1 = upper(text1)
        elsif equal(lProps[kLVColTypes][column], 'n') then
            textnum =  w32TextToNumber({text1, w32True})
            if textnum[2]=0 then
                text1 = textnum[1]
            end if
        end if
    end if

    text2 = getLVItemText(id, lItem2, column)
    if sequence(lProps[kLVColTypes]) and length(lProps[kLVColTypes])>=column then
        if equal(lProps[kLVColTypes][column], 'i') then
            text2 = upper(text2)
        elsif equal(lProps[kLVColTypes][column], 'n') then
            textnum =  w32TextToNumber({text2, w32True})
            if textnum[2]=0 then
                text2 = textnum[1]
            end if
        end if
    end if

    return compare(text1, text2)

end function
r_lvSortitems = routine_id("lvSortitems")

function PrepareLVSort(atom lParam1, atom lParam2, atom id)
integer lItem1, lItem2
integer rtn, column
atom LV_FINDINFO
integer sgn
sequence lProps

-- Allow something else to happen too.
    call_proc(r_doEvents,{0})

    lProps = lv_properties[find(id, lv_id)]
    column = lProps[kLVSortCol]

    rtn = r_lvSortitems
    if sequence(lProps[kLVSortRtn]) then
        if length(lProps[kLVSortRtn])>=column then
            rtn = lProps[kLVSortRtn][column]
        end if
    end if

    if rtn= -1 then
        -- No sorting done.
        return 0
    end if

    LV_FINDINFO = w32to_memory(0,ID_LVFINDINFO, {LVFI_PARAM, "", lParam1, 0, 0, 0})
    lItem1 = sendMessage(id, LVM_FINDITEM, -1, LV_FINDINFO)+1

    w32store(LV_FINDINFO, LVFINDINFO_lParam, lParam2)
    lItem2 = sendMessage(id, LVM_FINDITEM, -1, LV_FINDINFO)+1

    w32release_mem(LV_FINDINFO)

    if lItem1=0 or lItem2=0 then
        -- Nothing to sort.
        return 0
    end if

    sgn = 1
    if sequence(lProps[kLVSortSeq]) then
        if length(lProps[kLVSortSeq])>=column then
            if lProps[kLVSortSeq][column]<0 then
                sgn = -1
            end if
        end if
    else
        if lProps[kLVSortSeq]<0 then
            sgn = -1
        end if
    end if

    return sgn*call_func(rtn,{id, lItem1, lItem2, column})

end function

atom pfnCompare
pfnCompare = call_back(routine_id("PrepareLVSort"))


--/topic ListView control
--/proc loadLVInfo(integer id, sequence pNewData)
--/desc Used to bulk load data into a list view control
-- /i id is the ID of the /ListView control /n
-- /i pNewData is a list of row data and optional image ids.
-- Each element is either a list of column data or an image id
-- as returned from /addIcon(). An image id applies to all
-- the row data that follows until the next image id.
--
--Example:
--/code
--      sequence theData
--      integer iconMale, iconFemale
--      iconMale = addIcon(loadBitmapFromFile("male.ico"))
--      iconFemale = addIcon(loadBitmapFromFile("female.ico"))
--      theData = {}
--      theData &= iconMale
--      theData = append(theData, {"George", 95.4, "Judo"})
--      theData = append(theData, {"Harry", 97.2, "Karate"})
--      theData &= iconFemale
--      theData = append(theData, {"Wendy", 65.1, "Kendo"})
--      theData = append(theData, {"Jill", 75.8, "Ice Hockey"})
--      theData &= iconMale
--      theData = append(theData, {"Horatio", 105.1, "Chess"})
--      theData = append(theData, {"Felix", 87.0, "Butterflies"})
--      loadLVInfo(myLV, theData)
--/endcode
global procedure loadLVInfo(atom id, sequence alldata)
atom hWnd
atom LV_ITEM
object data
integer msg
integer lImageIdx
atom lNewRow

    hWnd = getHandle(id)
    VOID = w32Func(xSendMessage, {hWnd, LVM_DELETEALLITEMS, 0, 0})
    LV_ITEM = w32acquire_mem(0,  SIZEOF_LVITEM)
    lImageIdx = -1
    for i=1 to length(alldata) do
        data = alldata[i]
        if sequence(data) then
            w32store(LV_ITEM, LVITEM_iItem, i-1)
            w32store(LV_ITEM, LVITEM_lParam, vNextLVItemID+i)
            w32store(LV_ITEM, LVITEM_iImage, lImageIdx)

            for j=1 to length(data) do
                w32store(LV_ITEM, LVITEM_iSubItem, j-1)
                if not sequence(data[j]) then
                    data[j] = sprintf("%g", data[j])
                end if

                w32store(LV_ITEM, LVITEM_pszText, data[j])
                if j=1 then
                    msg = LVM_INSERTITEM
                    w32store(LV_ITEM, LVITEM_mask, w32or_all({LVIF_TEXT,LVIF_IMAGE,LVIF_PARAM}))
                    lNewRow = w32Func(xSendMessage, {hWnd, msg, i-1, LV_ITEM})
                else
                    msg = LVM_SETITEMTEXT
                    w32store(LV_ITEM, LVITEM_mask, LVIF_TEXT)
                    VOID = w32Func(xSendMessage, {hWnd, msg, lNewRow, LV_ITEM})
                end if
            end for
        else
            if ctrl_ImageList[id]=hILsmall then
                lImageIdx = data-1
            else
                lImageIdx = w32Func(ImageList_AddIcon,{ctrl_ImageList[id],ilicon_list[data]})
                VOID = w32Func(ImageList_AddIcon,{ctrl_Statusbar[id],ilicon_list[data]})
            end if
        end if
    end for

    w32release_mem(LV_ITEM)
    vNextLVItemID += getLVCount(id)
end procedure

--/topic ListView Control
--/func hitTestLV( id )
--/desc Check to see if mouse is over a /ListView item
--/ret {item,subitem} pair of /ListView item under mouse, or {}, if none
global function hitTestLV(integer id)
atom ht,  flags
sequence pt
sequence lItem

    pt = getPointerRelPos(id)

    -- need to calculate offset due to control position
    ht = w32acquire_mem(0, SIZEOF_LVHITTESTINFO)
    w32store(ht, LVHITTESTINFO_ptX, pt[1])
    w32store(ht, LVHITTESTINFO_ptY, pt[2])

    VOID = sendMessage(id, LVM_HITTEST, 0, ht)

    flags = w32fetch(ht, LVHITTESTINFO_flags)

    if and_bits(flags, LVHT_ONITEM) then
        lItem = {w32fetch(ht,LVHITTESTINFO_iItem)+1,
                 w32fetch(ht,LVHITTESTINFO_iSubItem)+1}
    else
        lItem = {}
    end if

    w32release_mem(ht)

    return lItem
end function




-- DEBUG IMPLEMENT API SCROLLWINDOWEX

-----------------------------------------------------------------------------
function fDoScroll(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
-----------------------------------------------------------------------------

-- scroll event handler
integer
        request,
        origpos,
        lChildId,
        lWhich, lSBar,
        inc
atom
       pos
sequence
       range,
       chgs,
       lRC,
       lDir,
       lScope

    -- determine if this is from the parent window's scroll
    -- bar, or a child scroll bar

    if ctrl_Parent[id]!=0 then
        lRC = {kSubclassedMsg}
    else
        lRC = {kMainMsg}
    end if

    if lParam!=0 then -- I have children
        -- find the control
        lChildId = getId(lParam)
        if lChildId=0  or ctrl_Parent[lChildId]!=id then -- Not one of mine
            return lRC
        end if

        id = lChildId
    end if

    -- get the request
    request = w32lo_word(wParam)

    -- get the value of the scroll bar
    if find(ctrl_Type[id] , {HScroll, VScroll}) then
        lWhich = 1
        lSBar = SB_CTL

    elsif find(ctrl_Type[id] , {Window, HTrackBar, VTrackBar, UpDown}) then
        if iMsg=WM_VSCROLL then
            lWhich = 1
            lSBar = SB_VERT
        else
            lWhich = 2
            lSBar = SB_HORZ
        end if
    else

        lWhich = 1
        lSBar = SB_VERT
    end if

    -- UpDown's handle scroll events themselves
    if ctrl_Type[id]=UpDown then
        pos = getScrollPos(id)
        VOID = invokeHandler(id, w32HScroll, {pos, request, lSBar})
        return {kMainMsg}
    end if

    if request!=SB_THUMBTRACK then
        pos = getScrollPos({id, lSBar})

    else
        pos = getThumbPos({id, lSBar})

    end if

    if find(ctrl_Type[id], {HTrackBar, VTrackBar}) then
        origpos = 0
    else
        origpos = pos
    end if

    -- get the range
    range = getScrollRange({id, lSBar})

    -- scrollbars need special handling to adjust small/large change
    inc = find(request, {SB_LINEUP, SB_LINEDOWN, SB_PAGEUP, SB_PAGEDOWN})
    if inc!=0 then
        if find(ctrl_Type[id], {HScroll, VScroll, Window}) then
            lDir = {-1, 1, -1, 1}
            lScope = {MY_SMALLCHANGE, MY_SMALLCHANGE, MY_LARGECHANGE, MY_LARGECHANGE}
            if ctrl_Type[id]=Window then
                chgs = ctrl_Scroll[id][lWhich]
            else
                chgs = ctrl_Scroll[id][1]
            end if

            pos += (chgs[lScope[inc]]*lDir[inc])
        end if

    elsif request=SB_ENDSCROLL then
        VOID = invokeHandler(id, w32HScroll, {pos, request, lSBar})
        return lRC

    elsif request=SB_TOP then
        -- to top of page
        pos = range[1]

    elsif request=SB_BOTTOM then
        -- to bottom of page
        pos = range[2]

    elsif find(request, {SB_THUMBPOSITION, SB_THUMBTRACK}) then
        -- track thumb position
        origpos = -1 -- Force the event to kick in.
        pos = getThumbPos({id, lSBar})

    end if

    -- clip to range
    if pos<range[1] then
        pos = range[1]
    elsif pos>range[2] then
        pos = range[2]
    end if

    -- call global routine to do the work
    if pos!=origpos then
        setScrollPos({id, lSBar} , {pos, request})
    end if

    return lRC
end function

-----------------------------------------------------------------------------
function fDoDropFiles(integer id, atom hWnd, atom iMsg, atom hDrop, atom lParam, atom pReturn)
-----------------------------------------------------------------------------

-- processes a WM_DROPFILES event.

integer bufferSize, namesize, itemCount
atom buffer
sequence fileName
object lUserResponse

    -- does this control support drag and drop?

    if   length(ctrl_Handlers[id][w32HDragAndDrop])>0
    or length(ctrl_Handlers[Screen][w32HDragAndDrop])>0
    then

        -- set up data structures
        bufferSize = 4000
        buffer = w32acquire_mem(0, bufferSize)

        -- get the count of files
        itemCount = w32Func(xDragQueryFile,{hDrop, #FFFFFFFF, buffer, bufferSize})

        if itemCount>0 then

            -- Indicate number of files in list.
            lUserResponse = invokeHandler(id, w32HDragAndDrop, {0, {itemCount}})

            -- DragQueryFileA uses zero based indexing
            for i=0 to itemCount-1 do
                -- Check to see if user has aborted callbacks.
                if sequence(lUserResponse) then
                    exit
                end if

                -- checking for buffer overflow.
                namesize = w32Func(xDragQueryFile,{hDrop, i, 0, bufferSize})
                if (namesize+1)>bufferSize then
                    w32release_mem(buffer)
                    bufferSize = namesize+1
                    buffer = w32acquire_mem(0, bufferSize)
                end if
                namesize = w32Func(xDragQueryFile,{hDrop, i, buffer, bufferSize})

                -- get the next file name
                fileName = peek({buffer, namesize})

                -- user trap
                lUserResponse = invokeHandler(id, w32HDragAndDrop, {0, fileName})
            end for

            -- Indicate end of file list.
            VOID = invokeHandler(id, w32HDragAndDrop, {0, ""})
        end if

        -- Free the memory
        w32release_mem(buffer)

    end if

    return {kSubclassedMsg}

end function

sequence vLMB_id
vLMB_id = {-1, -1, -1, -1}

atom
      vMaxClickTime
integer
    vMaxClickXDelta,
    vMaxClickYDelta

vMaxClickTime   = (w32Func(xGetDoubleClickTime,{})/1000)
vMaxClickXDelta = 3
vMaxClickYDelta = 3

--/topic Events
--/func setMouseClick(object pTimeDelta, object pXDelta, object pYDelta)
--/desc Sets/gets the mouse click detection parameters.
--/ret The current settings for these parameters.
-- There are three parameters used to detect a mouse click event. These are /n
--/li Time: Number of seconds difference between left mouse down and up events.
--/li XDelta: Number of pixels allowance in the X (horizontal) direction.
--/li YDelta: Number of pixels allowance in the Y (vertical) direction.
--
-- By using this function, you can set any, all, or none of these parameters. To /b not
-- set a parameter, you must use an empty sequence in its place.
--
-- example:
--/code
--     -- Set the time to 1.5 seconds, and the Y tolerance to 5 pixels.
--     -- Leave the X tolerance as it is.
--     curval1 = setMouseClick( 1.5, {}, 5)
--     -- Double the X tolerance, leaving the others alone.
--     curval2 = setMouseClick( {}, curval1[2] * 2, {})
--/endcode

----------------------------------------------------
global function setMouseClick(object pTimeDelta, object pXDelta, object pYDelta)
----------------------------------------------------
sequence
     lCurrentValues

    lCurrentValues = {vMaxClickTime, vMaxClickXDelta, vMaxClickYDelta}

    if atom(pTimeDelta) then
        vMaxClickTime   = pTimeDelta
    end if

    if atom(pXDelta) then
        vMaxClickXDelta = pXDelta
    end if

    if atom(pYDelta) then
        vMaxClickYDelta = pYDelta
    end if

    return lCurrentValues
end function

----------------------------------------------------
function fDoMouse(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
integer
        mouseX,
        mouseY,
--      action,
        doActions,
        lWheelPosn,
        lParent
sequence
        lRC,
        lEventParms,
--      cmp,
        lRgns,
        lRelXY

    lRC = {pReturn}
    if (and_bits(classAttr[ctrl_Type[id]], w32Clickable)!=0)
    or (ctrl_Family[id]=BUTTON)
    or find(iMsg, {WM_RBUTTONDOWN, WM_MOUSEWHEEL})
    or (classType[ctrl_Type[id]]=STATIC and
        and_bits(SS_NOTIFY, w32Func(xGetWindowLong, {ctrl_Handle[id], GWL_STYLE}))!=0)
          then
        doActions = w32True
    else
        doActions = w32False
    end if
    lParent = findParentWindow(id)

    -- decode parameters
    mouseX = w32shortInt(w32lo_word(lParam))
    mouseY = w32shortInt(w32hi_word(lParam))
    if iMsg=WM_MOUSEWHEEL then
        -- This 'fixes' a bug in Windows in which the incorrect x/y is being reported.
        lRgns = getPointerRelPos(id)
        mouseX = lRgns[1]
        mouseY = lRgns[2]
        -- Get the movement and direction data
        lWheelPosn = w32hi_word(wParam)
        if lWheelPosn>#7FFF then
            lWheelPosn -= #10000
        end if
        lWheelPosn = floor(lWheelPosn/120)
    else
        lWheelPosn = 0
    end if

    if lParent=0 then
        lParent = Screen
    end if

    if sequence(ctrl_Mousetrap[lParent]) then
        -- Check the mousetrap areas set for this control.
        lRelXY = getPointerRelPos(lParent)
        lRgns = hitMouseTrap(lParent, iMsg, lRelXY[1], lRelXY[2])
        if length(lRgns)>0 then
            VOID = invokeHandler(lParent, w32HMouseTrap, {iMsg, lRelXY[1], lRelXY[2],  lWheelPosn, lRgns, id, shifts})
            if sequence(VOID) then
                -- If the user returns anything, eat the event.
                lRC = {kMainMsg}
                iMsg = 0
                doActions = w32False
            end if
        end if
    end if

    -- get command

    if iMsg=WM_LBUTTONUP then
        -- test for a "click" gesture.
        if vLMB_id[1]=id and
        time()-vLMB_id[4]<vMaxClickTime  and
        w32abs(mouseX-vLMB_id[2])<vMaxClickXDelta  and
        w32abs(mouseY-vLMB_id[3])<vMaxClickYDelta then
            -- Clicking! Any handler for this?
            if doActions and (ctrl_Family[id]!=BUTTON) then
                -- Note. Buttons are notified via the BN_CLICKED msg.
                VOID = invokeHandler(id, w32HClick, {})
            end if
        else -- not a click.

            if length(vDragData)>0 then  -- sz: add 1 before 1 and 0 before 2
                -- I'm dragging something.
                -- First, tell the destination control.
                VOID = invokeHandler(id, w32HDragAndDrop, vDragData)
                -- Secondly, tell the source control
                VOID = invokeHandler(vDragData[1], w32HDragAndDrop, vDragData)
                -- Reset the cursor shape.
                IndicateDragging(vDragData[1], w32False) -- Reset drag cursor shape.
            end if
        end if

        vDragData = {} -- Clear any drag operation data.

    end if

    if iMsg!=WM_MOUSEMOVE then
        vLMB_id[1] = -1
    end if

    -- set the mouse cursor
    VOID = w32Func(xSetCursor, {ctrl_Cursor[id][1]})

    -- generate an event?                      
    if doActions then
        lEventParms = {iMsg, mouseX, mouseY, getKeyMasks(wParam), 0}
        if iMsg=WM_MOUSEWHEEL then
            lEventParms[5] = lWheelPosn
        end if
        VOID = invokeHandler(id, w32HMouse,  lEventParms)
        if sequence(VOID) then
            -- If the user returns anything, eat the event.
            lRC = {kMainMsg}
        end if
    end if
    -- Save mouse position and time for click detection.
    if iMsg=WM_LBUTTONDOWN then
        vLMB_id = {id, mouseX, mouseY, time()}
        if ctrl_Type[id]=TabControl then
            call_proc(r_setFocus,{id})
        end if
    end if

    return lRC
end function


----------------------------------------------------
function fDoSize(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
integer cx
integer cy
sequence lRC
integer lEraseBG


    lRC = {pReturn}
    -- Sometimes this is received for 'destroyed' controls.
    if validId(id) then
        -- decode parameters
        cx = w32lo_word(lParam)
        cy = w32hi_word(lParam)
        -- resize behavior?
        VOID = invokeHandler(id, w32HResize, {wParam, cx, cy})
        if sequence(VOID) then
            if (length(VOID)!=1) or (not integer(VOID[1])) then
                lEraseBG = 1
            elsif VOID[1]=0 then
                lEraseBG = 0
            else
                lEraseBG = 1
            end if
            VOID = w32Func(xInvalidateRect, {getHandle(id), NULL, lEraseBG})
        end if

        resizeWidgets(id) --, cx, cy ) -- resize the toolbar and statusbar, if any

    end if
    return lRC
end function

----------------------------------------------------
function fDoBkGndErase(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
sequence lRC

    lRC = {kSubclassedMsg}

    if ctrl_Erase[id]!=0 then
        lRC = {kMainMsg}
    end if
    return lRC
end function

----------------------------------------------------
function fDoSetFocus(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
sequence lRC

integer lParent
integer lParentWindow
integer lTempId


    lRC = {kSubclassedMsg}
    lParent = findParent(id)

    lParentWindow = findParentWindow(id)

    -- Don't bother setting focus to a window that's going down.
    if ctrl_Destroyed[id]!=0 or (lParentWindow and ctrl_Destroyed[lParentWindow]!=0) then
        return lRC
    end if

    -- Check for special case of a control in a closed window that
    -- gets focus again!
    if (lParentWindow and ctrl_Closed[lParentWindow]=1) or (lParent!=0 and ctrl_Closed[lParent]=1) then
        if focus_current>0 and focus_current!=id then
            -- Reset focus on the last control that had an explicit set focus.
            setFocus(focus_current)
            return lRC
        end if
    end if

    if and_bits(classAttr[ctrl_Type[id]], w32HasChildren) then
        -- eg. A 'group' type of control. If somebody explictly
        -- sets focus to the group, then set focus to the first
        -- tabbable control in that group.
        if length(ctrl_Focus_order[id])>0 then
            setFocus(ctrl_Focus_order[id][1])
            return lRC
        end if

    end if

    -- item to focus on?
    if (id!=lParentWindow) and length(ctrl_Focus_order[id])>0 then
        -- no focus?

        if ctrl_Previous_focus[id]!=0 and ctrl_Previous_focus[id]!=id then
            lTempId = ctrl_Previous_focus[id]
            ctrl_Previous_focus[id] = 0
            if lTempId>0 then
                id = lTempId
                lParent = findParent(id)
                lParentWindow = findParentWindow(id)
            end if
        end if
        tab_direction(id, 0) -- try to focus on item again
        -- supposedly useful (sz)
        focus_current = -1
        return lRC
    else

        if (id=lParentWindow) and ctrl_CanFocus[id] then
            if ctrl_Previous_focus[id]!=0 and ctrl_Family[ctrl_Previous_focus[id]]!=WINDOW then
                setFocus(ctrl_Previous_focus[id])
            end if
        elsif ctrl_CanFocus[id]=2 then
            if ctrl_Previous_focus[id]!=0 then
                setFocus(ctrl_Previous_focus[id])
            else
                tab_direction(id,2)
            end if
            focus_current = -1
            return lRC
        end if
    end if

    -- is there a window with modal focus?
    if modalWindow!=0 and
       modalWindow!=lParentWindow then
        -- force focus back to the modal one
        w32Proc(xSetFocus, {modalhWnd})
    else
        if lParent!=0 then
            if ctrl_Family[lParent]=COMBO then

                ctrl_Current_focus[ctrl_Parent[lParent]] = id-1
            else
                ctrl_Current_focus[lParent] = id
            end if
        else
            lRC = {kMainMsg}
        end if

        -- Check for autoselect behaviour.
        if find(ctrl_Type[id], {EditText, MleText, RichEdit}) then
            if ctrl_Specific[id]=w32True then
                setIndex(id, {1,0})
            else
                setIndex(id, getIndex(id))
            end if
        end if

        -- call proc?
        VOID = invokeHandler(id, w32HGotFocus, {})

    end if

    focus_current = -1
    return lRC
end function



function fDoChar(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
-- processes WM_CHAR, WM_SYSCHAR
object lUserReturn
sequence lRC

    lUserReturn = invokeHandler(id, w32HKeyPress,{wParam, shifts , lParam<0})
    if sequence(lUserReturn) then
        if lUserReturn[1]= -1 then
            -- Ignore this keystroke
            lRC = {kMainMsg}
        else -- Replace entered key with new one.
            lRC = {kSubclassedMsg,{hWnd, iMsg, lUserReturn[1],lParam}}
        end if
    else
        lRC = {kSubclassedMsg}
    end if
    if wParam=VK_RETURN and shifts=0 and ctrl_Type[id]=EditText then
        -- Tab to next field if a ReturnKey pressed in an edit field.
        lRC = {kMainMsg}
        tab_direction(id,1)
    end if
    return lRC

end function

constant shiftKeys = {VK_SHIFT,VK_CONTROL,VK_MENU,VK_LWIN},
         addShift = {ShiftMask,ControlMask,AltMask,WinMask},
--/**/   removeShift = sq_not_bits(addShift),   --/* -- Phix
         removeShift=not_bits(addShift),        --*/ -- RDS
--       altPos=find(AltMask,addShift),
         shiftPos = find(ShiftMask,addShift)
sequence numShifts numShifts = repeat(0,length(shiftKeys))

procedure arShift(integer shNum,integer isUp)
    if isUp then
        numShifts[shNum] -= 1
        if numShifts[shNum]=0 then
            shifts = and_bits(shifts,removeShift[shNum])
        end if
    else
        if numShifts[shNum]=0 then
            shifts = or_bits(shifts,addShift[shNum])
        end if
        numShifts[shNum] += 1
    end if
end procedure

integer keyIndex keyIndex = 0

procedure resetKeyboard()
    keyIndex = 0
--/**/  numShifts = sq_sub(numShifts,numShifts)     --/* -- Phix
    numShifts -= numShifts                          --*/ -- RDS
    shifts = 0
end procedure

function adjustShift(integer keyCode,integer isUp,integer isSys)
integer shNum
    if isSys then end if
    if keyCode=VK_RWIN then
        keyCode = VK_LWIN
    end if
    shNum = find(keyCode,shiftKeys)
    if shNum then
        arShift(shNum,isUp)
    end if
    if isUp then
        return 0
    else
        return shNum
    end if
end function

integer maxKeyIndex maxKeyIndex = 4
integer emittedKey emittedKey = 0

constant CONTEXT = 8192,REPEATING = 16384,EXTENDED = 256

sequence keyCodes,extFlags,scanCodes,keyParams,rptCounts
keyCodes = repeat(0,maxKeyIndex)
extFlags = keyCodes
scanCodes = keyCodes
keyParams = keyCodes
rptCounts = keyCodes

function fDoKeys(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
-- processes WM_NULL, WM_[SYS]KEY(DOWN|UP)
integer isDown,isSys,xcode,oldshifts,event,newIndex
sequence lRC
object lUserReturn
integer lEmitKey,flags,extCode
integer lTabDir
sequence lHotKey

    flags = w32hi_word(lParam)
    -- some extended keys don't have an extended flag set accordingly
    if and_bits(flags,#FF)=#5B then -- left win key
        flags -= EXTENDED
    elsif and_bits(flags,#FF)=#36 then -- right shift
        flags = or_bits(flags,EXTENDED)
    end if

    extCode = wParam
    if wParam=VK_PACKET then -- Unicode 16-bit char held in flags
        extCode = flags+65536
        xcode = find(extCode,keyCodes) -- position in keyboard buffer
        if xcode>keyIndex then -- spurious match
            xcode = 0
        end if
        if xcode>0 then -- repetition means the key is in the buffer, synthesize flags
            flags = REPEATING
        else
            flags = 0
        end if
    else
        if and_bits(flags,EXTENDED) then
            extCode += 256
        end if
        -- position in keyboard buffer
--/**/  xcode = find(extCode,sq_add(keyCodes,sq_mul(256,extFlags)))     --/* -- Phix
        xcode = find(extCode,keyCodes + 256*extFlags)                   --*/ -- RDS
        if xcode>keyIndex then -- spurious match
            xcode = 0
        elsif keyIndex and keyCodes[keyIndex]=VK_PROCESSKEY and xcode=0 and not isDown then
        -- Far Eastern IME processed a key in Roman mode and reemitted this: restore message pairing
            xcode = keyIndex
            keyCodes[keyIndex] = wParam
        end if
    end if

    if iMsg=WM_NULL then -- on some systems, WM_SYSKEYUP is not sent

        if keyIndex and xcode then
            iMsg = WM_SYSKEYUP
        else
            return {kSubclassedMsg}   -- an actual WM_NULL, not a translation
        end if
    end if

    isDown = iMsg=WM_KEYDOWN or iMsg=WM_SYSKEYDOWN
    isSys = iMsg=WM_SYSKEYDOWN or iMsg=WM_SYSKEYUP
    if xcode=0 and isDown and and_bits(flags,REPEATING) then -- OS merged extended and non extended keys
        flags -= REPEATING
    end if

    if not isDown and xcode=0 then -- spurious WM_[SYS]KEYUP, don't process
        return {kSubclassedMsg}
    end if

    if isSys and isDown then -- in some cases, WM_SYSKEYDOWN must translate to WM_KEYDOWN
        if not and_bits(flags,CONTEXT) then
    -- no window had focus; assume the keystroke was for the active window
    -- Windows sends WM_SYSKEYDOWN in that case, so translation to WM_KEYDOWN is needed
            isSys = 0
        elsif wParam=VK_F10 and not vSkipF10 then  -- special processing for F10
            isSys = 0
        end if
    end if

    if not isDown then  -- up message
        oldshifts = shifts
        lEmitKey = adjustShift(wParam,1,isSys)
        if not emittedKey then -- some combination of shifts, emit key
            lEmitKey = 1
        end if
        rptCounts[xcode] = 0
    elsif not and_bits(flags,REPEATING) then -- OS says this doesn't repeat previous key
        emittedKey = 0 -- will set it later if needed
        if xcode=0 or xcode>keyIndex then -- truly new key, record it
            keyIndex += 1
            if keyIndex>maxKeyIndex then -- extend buffers
                maxKeyIndex += 1
                keyCodes &= 0
                extFlags &= 0
                scanCodes &= 0
                keyParams &= 0
                rptCounts &= 0
            end if
            -- acquire information
            keyCodes[keyIndex] = wParam
            extFlags[keyIndex] = (and_bits(flags,EXTENDED)!=0)
            scanCodes[keyIndex] = and_bits(flags,255)
            keyParams[keyIndex] = wParam
            rptCounts[keyIndex] = 1
            lEmitKey = not adjustShift(wParam,0,isSys)
        else -- this key is still depressed, treat as repeated
            rptCounts[xcode] += w32lo_word(lParam)
            lEmitKey = 0
        end if
        oldshifts = shifts
    else -- repeated key
        if xcode>0 and xcode<=keyIndex then
            rptCounts[xcode] += w32lo_word(lParam)
        end if
        lEmitKey = 0
        oldshifts = shifts
    end if

    -- which event?
    event = w32HKeyDown
    if isDown then
        if wParam=VK_PAUSE or wParam=VK_CANCEL then
            if not shifts then
                event = w32HPause
            elsif shifts=ControlMask then
                event = w32HBreak
            end if
        end if
    else
        event = w32HKeyUp
    end if

    lRC = {kSubclassedMsg}

    -- reasons not to emit the event?
    if isDown and isSys then
        lHotKey = isHotKey(id, hWnd, iMsg, wParam, lParam, pReturn)
        if lHotKey[1]=kMainMsg  then -- hotkey detected
            lRC = {kMainMsg}
        end if
    elsif isDown and not isSys then
        if not shifts and (wParam=VK_RETURN or wParam=VK_ESCAPE) then
            -- trap default keys for buttons etc
            lHotKey = isHotKey(id, hWnd, iMsg, wParam, lParam, pReturn)
            if lHotKey[1]=kMainMsg  then -- hotkey detected
                lRC = {kMainMsg}
            end if
        elsif not shifts and wParam=VK_DOWN and ctrl_Type[id]=TabControl then
            -- down arrow has a special meaning in tab controls
            if ctrl_Current_focus[id]!=0 then
                tab_direction(ctrl_Current_focus[id],0)
                lRC = {kMainMsg}
            elsif length(ctrl_Specific[id])>1 then
                tab_direction(ctrl_Specific[id][1],0)
                lRC = {kMainMsg}
            end if
        else
            -- main tabbing management
            lTabDir = isTabKey(id , wParam)
            if lTabDir then
                tab_direction(id, lTabDir)
                lRC = {kMainMsg} -- Skip default windows processing.
            end if
        end if
    end if

    if lRC[1]!=kMainMsg then -- fire event
        lUserReturn = invokeHandler(id,event,{wParam,oldshifts})
        if sequence(lUserReturn) and isDown then
            -- special actions
            if length(lUserReturn)>=2 then
                if equal(lUserReturn[1], w32KH_SetFocus) then
                    tab_direction(lUserReturn[2],0)
                end if
            elsif lUserReturn[1]= -1 then
                -- Ignore this keystroke
                lRC = {kMainMsg}
            else -- Replace entered key with new one.
                lRC = {kSubclassedMsg,{hWnd, iMsg, lUserReturn[1],lParam}}
            end if
        end if
    end if

    -- see if w32HKeyboard is to be fired
    if lEmitKey then
        VOID = invokeHandler(id,w32HKeyboard,{keyCodes[1..keyIndex],extFlags[1..keyIndex],scanCodes[1..keyIndex],rptCounts[1..keyIndex]})
        emittedKey = 1
    end if

    if wParam=VK_SHIFT and not isDown then
    -- if both Shift keys were depressed, Windows only sends a single WM_KEYUP message,
    -- so we need to release the other key.
--/**/  xcode = find(xor_bits(extCode,EXTENDED),sq_add(keyCodes,sq_mul(256,extFlags)))  --/* -- Phix
        xcode=find(xor_bits(extCode,EXTENDED),keyCodes+256*extFlags)                    --*/ -- RDS
        if xcode and xcode<=keyIndex then
        -- also release the other shift
            rptCounts[xcode] = 0
            arShift(shiftPos,1)
        end if
    end if

    if not isDown then
    -- next keyIndex is the greatest index among depressed key indexes, or 0 if none.
        newIndex = 0
        for i=keyIndex to 1 by -1 do
            if rptCounts[i] then
                newIndex = i
                exit
            end if
        end for
        keyIndex = newIndex
    end if

    if isDown and isSys and not shifts and wParam=VK_F10 and vSkipF10 then
        lRC = {kMainMsg} -- don't let Windows do its default action
    end if

    return lRC
end function

----------------------------------------------------
function fDoKillFocus(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
-- Remember the id that just lost focus.
integer lParentWindow

    lParentWindow = findParentWindow(id)
    if ctrl_Destroyed[id]=0 and (lParentWindow and ctrl_Closed[lParentWindow]!=1) then
        ctrl_Previous_focus[id] = ctrl_Current_focus[lParentWindow]
        if id!=lParentWindow then
            ctrl_Previous_focus[lParentWindow] = id
        end if
        resetKeyboard() -- in case current process changes because of a hotkey being pressed
        VOID = invokeHandler(id, w32HLostFocus, {ctrl_Previous_focus[id]})
    end if

    return {kSubclassedMsg} -- Continue with default windows processing.
end function


----------------------------------------------------
function fDoCommand(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
sequence lRC
atom lChildId
integer lParent

    lRC = {kSubclassedMsg}
    if (lParam=NULL) then
        -- menu or accelerator?
        if w32hi_word(wParam)=1 then
        -- from accelerator;
        -- this should not happen

        -- menu click
        else
            -- get the menu id
            id = w32lo_word(wParam)
            -- update with new id

            VOID = invokeHandler(id, w32HClick, {})
        end if
    else

        lChildId = getId(lParam)
        if lChildId!=0  then
            lParent = findParent(lChildId)
            if lParent and ctrl_Type[lParent]=TabItem then
                -- Windows actually believes that the parent of a control
                -- in a TabItem is really the TabControl, so we have to
                -- make that adjustment here.
                lParent = findParent(lParent)
            end if
            if lParent=id  then
                -- notification from control
                wmCommand(lChildId, hWnd, iMsg, wParam, lParam)
                -- Only parent windows stop processing at this point.
                if findParent(id)=0 then
                    lRC = {kMainMsg}
                end if
            end if
        end if
    end if
    return lRC
end function

--/topic Graphics
--/func setPaintPolicy(integer id,integer pFlag)
--/desc Possibly sets the paint policy flag.
--/ret (INTEGER) The previous flag value.
-- By default, the library prevents w32HPaint events to reach controls which are already in the process of painting.
-- Pass a positive value in /i pFlag to enable recursion during paint events, w32False to disable it or a negative value to just get the current value.

global function setPaintPolicy(integer id,integer pFlag)
integer oldVal
    oldVal = ctrl_RecursivePaint[id]
    if pFlag>=0 then
        ctrl_RecursivePaint[id] = pFlag
    end if
    return oldVal
end function

constant r_updateHDC = w32routine_id("updateHDC")
----------------------------------------------------
function fDoPaint(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
atom
    ps,
    hdc
integer has_handler
sequence
    lUpdateRect,
    lRC

    lRC = {kSubclassedMsg}

    if  length(ctrl_Handlers[id][w32HPaint])>0
    or length(ctrl_Handlers[Screen][w32HPaint])>0
    then
        has_handler = 1
    else
        has_handler = 0
    end if
    if has_handler or ctrl_Hatch[id] then -- there is something to do
        if find(id, vDuringPaint) then
         -- Already in a paint handler.
         -- So avoid some recursion.
            return lRC
        end if
        if not ctrl_RecursivePaint[id] then
            vDuringPaint = prepend(vDuringPaint,id)
        end if
        ps = w32acquire_mem(0, SIZEOF_PAINTSTRUCT)

       -- begin paint
        hdc = w32Func(xBeginPaint, {hWnd, ps})

        call_proc(r_updateHDC,{id,hdc})

        if ctrl_Hatch[id] then
            w32Proc(xSetBkMode,{hdc,TRANSPARENT})
            VOID = w32Func(xSetBkColor,{hdc,ctrl_Bg_Color[id][2]})
            VOID = w32Func(xFillRect,{hdc,w32address(ps, psPaintRect),ctrl_Hatch[id]})
        end if
        if has_handler then
     -- fetch the update rectangle
            lUpdateRect = w32fetch(ps, psPaintRect)
            VOID = invokeHandler(id, w32HPaint, lUpdateRect)
        end if

    -- Free up any resources used with this DC
        releaseDC(id)

     -- end of paint
        w32Proc(xEndPaint, {hWnd, ps})

     -- Free the structure
        w32release_mem(ps)

        if not ctrl_RecursivePaint[id] then
            vDuringPaint = vDuringPaint[2..length(vDuringPaint)]
        end if

        lRC = {kMainMsg}
    end if

    return lRC

end function


----------------------------------------------------
function fDoTimer(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
    VOID = invokeHandler(id, w32HTimer,{wParam})
    return {pReturn}
end function


----------------------------------------------------
function fDoSysColorChange(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
-- system color changed. force a redraw of the window
object color

    for i=1 to length(ctrl_Handle) do
        if validId(i) then
            color = ctrl_Bg_Color[i]
            if sequence(color) and length(color)=1 then
                color = color[1]
            end if
            setBackground(i, sequence(ctrl_Bg_Color[i]), color)
            setTextColor(i, ctrl_Font[i][w32FontColor])
        end if
    end for

    if not w32Func(xInvalidateRect, {hWnd, NULL, -1}) then
        warnErr("InvalidateRect in DoSysColorChange failed.")
    end if

    return {pReturn}
end function

----------------------------------------------------
function fDoCtlColor(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
--    integer lParent
integer lControl,lColor

-- system is about to draw the colors for a control.
-- this intercepts the command, and returns the brush we want
    lControl = getId(lParam)
    if lControl=0 then
        -- A Windows managed control, so ignore it.
        return {kMainMsg , -1}
    end if
--    lParent = getParent(lControl)

    VOID = w32Func(xSetTextColor, {wParam, colorValue(ctrl_Font[lControl][w32FontColor])})
    if not equal(ctrl_Bg_Color[lControl], w32WinDefColor) then
        -- wParam contains the device context of the control
        lColor = colorValue(ctrl_Bg_Color[lControl])
        VOID = w32Func(xSetBkColor, {wParam, lColor})
        -- get the background color brush
        return {kMainMsg, ctrl_Bg_Brush[lControl]}
    else
        if and_bits(classAttr[ctrl_Type[lControl]], w32UseSubProc) then
            return {kSubclassedMsg}
        else
            return {kMainMsg,-1}
        end if
    end if
end function


sequence ActiveEL ActiveEL = {}
----------------------------------------------------
procedure quitWindow(integer id)
----------------------------------------------------
    if validId(id)=w32False then
        return
    end if

    if length(ActiveEL)>0 then
        ActiveEL[length(ActiveEL)] = 1
    end if
    return

end procedure

constant
    Dialog          = -2


----------------------------------------------------
function fDoClose(integer id, atom hWnd, atom iMsg, atom wParam,
          atom lParam, atom pReturn)
----------------------------------------------------
integer idStyle, idDepth
object lUserReturn


    -- Ignore this call if a bad ID supplied.
    if  validId(id)=w32False
    or ctrl_Closed[id]!=0  then
        return {kMainMsg}
    end if

    -- Do not close this window if there is a modal one active,
    -- unless this window is the modal one.
    if   modalWindow!=0
    and modalWindow!=id then
        -- In case the window has been programmatically minimized,
        -- restore it to show the user why the requested window
        -- is not closing.
        if isMinimized(modalWindow) then
            VOID = w32Func(xShowWindow, {modalhWnd, SW_RESTORE})
        end if
        w32Proc(xSetFocus, {modalhWnd})
        return {kMainMsg}
    end if

    ctrl_Closed[id] = 2 -- Closing down

    -- Any user defined action?
    if length(ctrl_Handlers[id][w32HClose])>0
    or length(ctrl_Handlers[Screen][w32HClose])>0
    then
        lUserReturn = invokeHandler(id, w32HClose, {})
        -- If the user routine returned a non-zero value
        -- do not close this window.
        if   sequence(lUserReturn)
        and (lUserReturn[1]!=0)
        then
            -- undo the closing flag
            ctrl_Closed[id] = 0
            -- Ignore the close request
            return {kMainMsg}
        end if
    end if

    -- close modal grab?
    if modalWindow=id then
        idStyle = modalStyle
        idDepth = modalDepth
        popModal()
    else
        idStyle = Normal
    end if

    -- hide the window if not the primary
    if   id!=mainWindow then
        VOID = w32Func(xShowWindow, {hWnd, SW_HIDE})
        ctrl_Closed[id] = 1
        if idStyle=Dialog then
            if length(ActiveEL)>idDepth then
                quitWindow(id)
            end if
        end if
        return {kMainMsg}
    else

        destroy(id)
        VOID = setMainWindow(0)
        ctrl_Closed[id] = 1

        if vEndAction>=0 then
            abort(vEndAction)
        end if

    end if

    return {kSubclassedMsg}
end function

----------------------------------------------------
function fDoDestroy(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------

    if mainWindow=id then
       -- close the app
        w32Proc(xPostQuitMessage, {wParam})
    end if

    return {kSubclassedMsg}
end function

----------------------------------------------------
function fDoTCN_SELCHANGING(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
integer newItem
object lRC
   -- get handle

    hWnd = w32fetch(lParam, NMHDR_hwndFrom)
   -- find the tab control id
    id = getId(hWnd)
    if id!=0 then
       -- get id of selected tab
        newItem = ctrl_Specific[id][w32Func(xSendMessage, {hWnd, TCM_GETCURSEL, 0, 0})+1]
        lRC = invokeHandler(id,w32HChange,{newItem,getTabItem(id)})
        if sequence(lRC) and length(lRC)>=2 then
            if lRC[1]=-1 then
                return {kMainMsg,w32True} -- block the change
            elsif integer(lRC[1]) then
                lRC = sendMessage(id,TCM_SETCURSEL,lRC[1],0)
            end if
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoTCN_SELCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
   -- get handle

    hWnd = w32fetch(lParam, NMHDR_hwndFrom)
   -- find the tab control id
    id = getId(hWnd)
    if id!=0 then

       -- get id of selected tab
        id = ctrl_Specific[id][w32Func(xSendMessage, {hWnd, TCM_GETCURSEL, 0, 0})+1]
       -- activate the tab items for the control
        activateTabItems(id)

       -- is there a click behavior?
        VOID = invokeHandler(id, w32HClick, {})

    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_COLUMNCLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
integer lColumn
integer lOwner
integer lDoSort
integer rtn


    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id!=0 then
        lColumn = w32fetch(lParam, NMLISTVIEW_iSubItem)+1
        lOwner = find(id, lv_id)
        if lOwner!=0 then
            if sequence(lv_properties[lOwner][kLVSortSeq]) then
                if length(lv_properties[lOwner][kLVSortSeq])>=lColumn then
                    if lv_properties[lOwner][kLVSortSeq][lColumn]=2 then
                        lv_properties[lOwner][kLVSortSeq][lColumn] = -2
                    elsif lv_properties[lOwner][kLVSortSeq][lColumn]= -2 then
                        lv_properties[lOwner][kLVSortSeq][lColumn] = 2
                    end if
                end if
            else
                if lv_properties[lOwner][kLVSortSeq]=2 then
                    lv_properties[lOwner][kLVSortSeq] = -2
                elsif lv_properties[lOwner][kLVSortSeq]= -2 then
                    lv_properties[lOwner][kLVSortSeq] = 2
                end if
            end if
        end if

        lv_properties[lOwner][kLVSortCol] = lColumn


        rtn = -1
        if sequence(lv_properties[lOwner][kLVSortRtn]) then
            if length(lv_properties[lOwner][kLVSortRtn])>=lColumn then
                rtn = lv_properties[lOwner][kLVSortRtn][lColumn]
            end if
        end if

        lDoSort = w32True
        if rtn>=0 then
            -- Indicate that we are about to start sorting.
            if rtn!=r_lvSortitems then
                lDoSort = call_func(rtn, {id, -1, -1, w32LV_StartSorting})
            end if
        end if

        if lDoSort then
            releaseMouse()
            setMousePointer(id, "HOURGLASS")
            VOID = sendMessage(id, LVM_SORTITEMS, id, pfnCompare)
            -- Signal that sorting has stopped.
            if rtn!= -1 and rtn!=r_lvSortitems then
                VOID = call_func(rtn, {id, -1, -1,  w32LV_EndSorting})
            end if
            setMousePointer(id, "NULL")
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
atom
     lMask
-- integer
--     lSubItem,
--     lItem

    id = getId(w32fetch(lParam, NMHDR_hwndFrom))

    if id!=0 then
        lMask    = w32fetch(lParam, {LVDISPINFO_item,LVITEM_mask})
--         lSubItem = w32fetch( lParam, {LVDISPINFO_item,LVITEM_iSubItem} ) + 1
--         lItem    = w32fetch( lParam, {LVDISPINFO_item,LVITEM_iItem} )

        if and_bits(lMask, LVIF_TEXT) then
            -- Indicate that somebody is looking for non-existant text.
            w32store(lParam, {LVDISPINFO_item,LVITEM_pszText},{{},{-1, -1}})
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoLVN_BEGINDRAG(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id!=0 then
        vDragData = {id, getLVSelected(id)}
    end if

    IndicateDragging(id, w32True) -- Change cursor to show drap in progress.

    return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_BEGINDRAG(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id!=0 then
        vDragData = {id, {getTVIndex(id)}}
    end if
    IndicateDragging(id, w32True) -- Change cursor to show drap in progress.

    return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
atom
     lMask

integer
     lItem


    id    = w32fetch(lParam, {TVDISPINFO_item,TVITEM_hItem})
    lItem = find(id, tvitem_handle)

    -- This is called before we get the handle, so if
    -- we haven't filled it in yet, we'll just grab
    -- the first one.
    if lItem=0
    then
        lItem = find(0, tvitem_handle)
        if lItem=0 then
            lItem = 1
        end if
    end if

    if lItem<=length(tvitem_data) then
        lMask = w32fetch(lParam, {TVDISPINFO_item,TVITEM_mask})


        if and_bits(lMask, TVIF_IMAGE) then
            w32store(lParam, {TVDISPINFO_item,TVITEM_iImage},
                     tvitem_data[lItem][ktv_NormImage])
        end if

        if and_bits(lMask, TVIF_SELECTEDIMAGE) then
            w32store(lParam, {TVDISPINFO_item,TVITEM_iSelectedImage},
                     tvitem_data[lItem][ktv_SelectImage])
        end if

        if and_bits(lMask, TVIF_TEXT) then
            w32store(lParam, {TVDISPINFO_item,TVITEM_pszText},
                     {{},tvitem_data[lItem][ktv_TextAddr..ktv_TextSize]})
        end if
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoTVN_SELCHANGED(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

    id = getId(w32fetch(lParam, {NMTREEVIEW_hdr,NMHDR_hwndFrom}))
    if id!=0 then
        VOID = invokeHandler(id, w32HChange, {w32CHG_Sel, getIndex(id)})
    end if
    return {kMainMsg}
end function


-- Try to keep from GPF'ing when TreeView is child to something
-- other than a window (ie, TabControl).  This seems to
-- work, but I'm not sure why...
----------------------------------------------------
function fDoTVN_DELETEITEM(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    return {kMainMsg}
end function

atom TTTextPtr -- default text buffer is 80 chars wide, we may need to use this one
TTTextPtr = 0
integer TTStrLen
TTStrLen = 0
----------------------------------------------------
function fDoTTN_GETDISPINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
sequence lText
--  atom hFrom
atom lTextLen
sequence screenSize

    id = getId(wParam)
    if id=0 then
        id = w32fetch(lParam, NMHDR_idFrom)
    end if

    if id>0 and id<=length(ctrl_Hint_Text) then
        if atom(ctrl_Hint_Text[id]) then
            if integer(ctrl_Hint_Text[id]) and ctrl_Hint_Text[id]>=0 then
                -- The user routine returns either a string or a sequence in
                -- the form of { string, width }, eg. {"Sample text", 120}
                lText = call_func(ctrl_Hint_Text[id], {id, ctrl_Hint_Width[id]})
                if length(lText)=2 and sequence(lText[1]) and integer(lText[2]) then
                    ctrl_Hint_Width[id] = lText[2]
                    lTextLen = lText[2]
                    lText = lText[1]
                elsif length(lText)=1 and sequence(lText[1]) then
                    lText = lText[1]
                    lTextLen = ctrl_Hint_Width[id]
                elsif length(lText)=0 then
                    lTextLen = 0
                else
                    lTextLen = ctrl_Hint_Width[id]
                end if
            else
                lText = sprintf("Invalid routine_id %g", ctrl_Hint_Text[id])
                lTextLen = ctrl_Hint_Width[id]
            end if
        else
            lText = ctrl_Hint_Text[id]
            lTextLen = ctrl_Hint_Width[id]
        end if
        screenSize = getCtlSize(Screen)
        if lTextLen>screenSize[1] then
            lTextLen = screenSize[1]
        end if

        if length(lText)>80 then -- use our private buffer
            if TTTextPtr=0 then  -- first use
                TTTextPtr = w32acquire_mem(0,lText)
                TTStrLen = lTextLen
            elsif TTStrLen<=length(lText) then -- buffer too small, get another one
                w32release_mem(TTTextPtr)
                TTStrLen = lTextLen
                TTTextPtr = w32acquire_mem(0,lText)
            else -- use current bufer, as it is large enough
                poke(TTTextPtr,lText)
                poke(TTTextPtr+length(lText),0)
            end if
            w32store(lParam, NMTTDISPINFO_lpszText, TTTextPtr)

        else
            w32store(lParam, NMTTDISPINFO_szText, lText)
        end if

        VOID = w32Func(xSendMessage,{w32fetch(lParam, NMHDR_hwndFrom),
                                     TTM_SETMAXTIPWIDTH, 0,
                                     lTextLen})

    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoMCN_SELCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id!=0 then
        VOID = invokeHandler(id, w32HChange, {})
    end if

    return {kMainMsg}
end function

----------------------------------------------------
function fDoMCN_SELECT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id!=0 then
        VOID = invokeHandler(id, w32HChange, getSelectedDateRange(id))
    end if
    return {kMainMsg}
end function

----------------------------------------------------
function fDoTBN_GETBUTTONINFO(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

    return {kSubclassedMsg, {hWnd, TBN_GETBUTTONINFO, wParam, lParam}}
end function

----------------------------------------------------
function fDoTBN_QUERYINSERT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

    return {kMainMsg, 1}
end function

----------------------------------------------------
function fDoTBN_QUERYDELETE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------

    return {kMainMsg, 1}
end function

----------------------------------------------------
function fDoLVN_ITEMCHANGED(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    id = getId(w32fetch(lParam, NMHDR_hwndFrom))
    if id!=0 then
        VOID = invokeHandler(id, w32HChange, {

                                              w32fetch(lParam, NMLISTVIEW_iItem)+1,
                                              w32fetch(lParam, NMLISTVIEW_iSubItem)+1,
                                              w32fetch(lParam, NMLISTVIEW_uNewState),
                                              w32fetch(lParam, NMLISTVIEW_uChanged),
                                              w32fetch(lParam, NMLISTVIEW_ptActionX),
                                              w32fetch(lParam, NMLISTVIEW_ptActionY),
                                              w32fetch(lParam, NMLISTVIEW_lParam)

                                             })
    end if
    return {kMainMsg}
end function


----------------------------------------------------
function fDoNM_CLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
sequence xy
atom keys
integer lRealId
atom lCode

    lRealId = w32fetch(lParam, NMHDR_idFrom)
    if lRealId!=0 then
        lRealId = getId(w32fetch(lParam, NMHDR_hwndFrom))
    else
        lRealId = id
    end if
    lCode = w32fetch(lParam, NMHDR_code)
    xy = getPointerRelPos(lRealId)
    keys = getKeyMasks(0)

    VOID = invokeHandler(lRealId, w32HClick, {lCode})
    VOID = invokeHandler(lRealId, w32HMouse, {WM_LBUTTONUP, xy[1],xy[2], keys})
    return {kMainMsg}
end function

----------------------------------------------------
function fDoNM_RCLICK(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
sequence xy
atom keys
integer lRealId

    lRealId = w32fetch(lParam, NMHDR_idFrom)
    if lRealId!=0 then
        lRealId = getId(w32fetch(lParam, NMHDR_hwndFrom))
    else
        lRealId = id
    end if
    xy = getPointerRelPos(lRealId)

    keys = getKeyMasks(0)
    VOID = invokeHandler(lRealId, w32HMouse, {WM_RBUTTONUP, xy[1],xy[2], keys})
    return {kMainMsg}
end function

----------------------------------------------------
function fDoRBN_HEIGHTCHANGE(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
    --integer rebarid

    --rebarid = getId( w32fetch(lParam, NMTREEVIEW_NMHDRhwndFrom ) )
    --VOID = getCtlSize( rebarid )
    --VOID = invokeHandler(Screen, w32HResize, {rebarid, VOID[1], VOID[2]})

    VOID = w32Func(xInvalidateRect, {getHandle(id), NULL, w32True})
    return {kMainMsg}
end function

global constant
    CBENF_KILLFOCUS = 1,
    CBENF_RETURN = 2,
    CBENF_ESCAPE = 3,
    CBENF_DROPDOWN = 4

----------------------------------------------------
function fDoCBEN_ENDEDIT(integer id, atom hWnd, atom wParam, atom lParam)
----------------------------------------------------
object lRC
integer why

-- get length of embedded string (text in the child edit field) storage in TCHARS
-- on Unicode versions, this will fail (bad length and add 2)
    why = w32Func(xlstrlen,{lParam+20})+1
    -- pass the info (reason of edit end) along
    lRC = invokeHandler(id,w32HChange,{w32CHG_Sel,peek4u(lParam+20+why)})
    return {kMainMsg,sequence(lRC)}
end function

function fDoUDN_DELTAPOS(integer id, atom hWnd, atom wParam, atom lParam)
object lRC

    lRC = invokeHandler(id,w32HChange,w32CHG_Chg & peek4s({lParam+SIZEOF_NMHDR,2}))
    return {kMainMsg,sequence(lRC)}
end function

sequence vNotifications
vNotifications =
     {
      TCN_SELCHANGE,
      LVN_COLUMNCLICK,
      LVN_GETDISPINFO,
      LVN_BEGINDRAG,
      TVN_BEGINDRAG,
      TVN_GETDISPINFO,
      TVN_SELCHANGED,
      TVN_DELETEITEM,
      TTN_GETDISPINFO,
      MCN_SELCHANGE,
      MCN_SELECT,
      TBN_GETBUTTONINFO,
      TBN_QUERYINSERT,
      TBN_QUERYDELETE,
      LVN_ITEMCHANGED,
      NM_CLICK,
      NM_RCLICK,
      RBN_HEIGHTCHANGE,
      TCN_SELCHANGING,
      CBEN_ENDEDIT,
      UDN_DELTAPOS
     }

sequence vNotifyHandlers
vNotifyHandlers =
     {
      routine_id("fDoTCN_SELCHANGE"),
      routine_id("fDoLVN_COLUMNCLICK"),
      routine_id("fDoLVN_GETDISPINFO"),
      routine_id("fDoLVN_BEGINDRAG"),
      routine_id("fDoTVN_BEGINDRAG"),
      routine_id("fDoTVN_GETDISPINFO"),
      routine_id("fDoTVN_SELCHANGED"),
      routine_id("fDoTVN_DELETEITEM"),
      routine_id("fDoTTN_GETDISPINFO"),
      routine_id("fDoMCN_SELCHANGE"),
      routine_id("fDoMCN_SELECT"),
      routine_id("fDoTBN_GETBUTTONINFO"),
      routine_id("fDoTBN_QUERYINSERT"),
      routine_id("fDoTBN_QUERYDELETE"),
      routine_id("fDoLVN_ITEMCHANGED"),
      routine_id("fDoNM_CLICK"),
      routine_id("fDoNM_RCLICK"),
      routine_id("fDoRBN_HEIGHTCHANGE"),
      routine_id("fDoTCN_SELCHANGING"),
      routine_id("fDoCBEN_ENDEDIT"),
      routine_id("fDoUDN_DELTAPOS")
     }

----------------------------------------------------
function fDoNotify(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
integer
         lNotify, nid
atom
         lNewMsg
object
         lResult

    -- lParam contains the notification message header
    lNewMsg = w32fetch(lParam, NMHDR_code)
    lNotify = find(lNewMsg, vNotifications)
    if lNotify=0 then
        lResult = {kSubclassedMsg} -- Not one of the ones I'm interested in.
        nid = getId(w32fetch(lParam, NMHDR_hwndFrom))
        VOID = invokeHandler(nid, w32HEvent, {lNotify, wParam, lParam})
    else
        if vNotifyHandlers[lNotify]!= -1 then
            lResult = call_func(vNotifyHandlers[lNotify], {id, hWnd, wParam, lParam})
            if atom(lResult) then
                lResult = {lResult}
            end if
        else
            lResult = {pReturn}
        end if
    end if

    return lResult

end function

--/topic Events
--/func setNotifyHandler(integer pMsg, integer pRtnId)
--/ret INTEGER: The current Routine ID for this notification message.
--/desc Sets a handler for WM_NOTIFY type of messages. 
-- /i pMsg is the Notification Message code for which you are setting the
-- handler. /n
-- /i pRtnId is the routine_id() of your function that handles the message. Passing a negative 
-- value will remove the handler.
--
-- Your routine is passed four parameters: /n
--</ul>
--/li /b integer /i id = The ID of the control that is sending the notification.
--/li /b atom /i hWnd = a copy of the hWnd parameter sent by Windows.
--/li /b atom /i wParam = a copy of the wParam parameter sent by Windows.
--/li /b atom /i lParam+ = a copy of the lParam parameter sent by Windows.
--</ul>
-- and must return either /kSubclassedMsg or /kMainMsg /n
-- /i kSubclassedMsg means that you want the windows processing specific to this class of control to occur for
-- this notification, after your code has finished. A variation is to return {kSubclassedMsg,
-- {hWnd,iMsg,wParam,lParam}} that contain replacement values for the ones originally
-- send through by Windows. kProcessMsg is an alias for kSubclassedMsg./n
-- /i kMainMsg means that you want the Windows default processing to occur, skipping any
-- class specific behaviour. This will
-- send a zero return code back to the Windows from the WM_NOTIFY message. Sometimes
-- however, you may need to specifies a specific return value. In this case you need
-- to return {kMainMsg, retval} in which /i retval must be an integer. kReturnNow is an
-- alias for kMainMsg.
--
-- The routine will be called whenever a control send the notiication with the supplied code.
-- Use /getSelf(), or peek into the notification structure pointed by lParam, to know which
-- control originated the notification.
--/code
--  sequence alldata
--  integer oldval
--  integer SORT_BY
--  SORT_BY=0
--  alldata = getDataItems()
--
--  function CS_byElement(sequence s1,sequence s2)
--    return compare(s1[SORT_BY],s2[SORT_BY])
--  end function
--
--  constant ByElement=routine_id("CS_byElement")
--
--  function mylvclick(integer id, atom hWnd, atom wParam, atom lParam)
--  integer
--    lColumn,
--    lOwner
--
--    id = getId( w32fetch( lParam, NMHDR_hwndFrom ))
--    if id != 0 then
--        lColumn = w32fetch( lParam, NMLISTVIEW_iSubItem ) + 1
--        SORT_BY=lColumn
--        alldata=custom_sort(ByElement,alldata)
--        VOID = sendMessage(id,WM_SETREDRAW,0,0)
--        loadLVInfo(id, alldata)
--        VOID = sendMessage(id,WM_SETREDRAW,1,0)
--    end if
--
--    return kMainMsg
--  end function
--  oldval = setNotifyHandler( LVN_COLUMNCLICK, routine_id("mylvclick"))
--/endcode

global function setNotifyHandler(integer pMsg, integer pRtnId)
integer lOldRid
integer lMsgIndx

    lMsgIndx = find(pMsg, vNotifications)
    if lMsgIndx=0 then
        if pRtnId>=0 then
            vNotifications &= pMsg
            vNotifyHandlers &= pRtnId
        end if
        lOldRid = -1
    elsif pRtnId>=0 then
        lOldRid = vNotifyHandlers[lMsgIndx]
        vNotifyHandlers[lMsgIndx] = pRtnId
    else -- removal
        vNotifications = w32removeIndex(lMsgIndx,vNotifications)
        vNotifyHandlers = w32removeIndex(lMsgIndx,vNotifyHandlers)
    end if

    return lOldRid
end function

----------------------------------------------------
function fDoDLGCODE(integer id, atom hWnd, integer iMsg,atom wParam, atom lParam,atom pReturn)
----------------------------------------------------
object policy
integer retVal

    if not validId(id) then
        return {kSubclassedMsg}
    end if

    policy = ctrl_KbdInput[id]
    if sequence(policy) then
        retVal = call_func(policy[1],{wParam,lParam})
    else
        retVal = policy
        if retVal= -1 then
            retVal = classKbdInput[ctrl_ActualClass[id]]
        end if
    end if
    return {kMainMsg,retVal}

end function

integer menubar menubar = 0

----------------------------------------------------
function fDoMENUSELECT(integer id, atom hWnd, integer iMsg,atom wParam, atom lParam,atom pReturn)
----------------------------------------------------
integer itemId,pos,spawnsMenu,itemPos
atom test

    if lParam=0 and w32hi_word(wParam)=#FFFF then
        -- menu clicked shut
        for i=1+menubar to length(menu_dropped) do
            VOID = invokeHandler(menu_dropped[i],w32HCloseUp,{})
        end for
        menu_dropped = {}
        hilitems = {}
        menubar = 0
    else
        pos = find(lParam,menu_handles)
        if not pos then -- not mine
            return {kSubclassedMsg}
        end if
        id = menu_ids[pos]
        if ctrl_Family[ctrl_Parent[id]]=WINDOW then
            menubar = 1
        end if
        itemId = w32lo_word(wParam)
        spawnsMenu = and_bits(w32hi_word(wParam),MF_POPUP)
        if spawnsMenu then
            itemPos = itemId
            itemId = ctrl_Group[id][itemId+1]
        else
            itemPos = getMenuPosn(itemId)
        end if
        VOID = invokeHandler(id,w32HChange,{itemId,w32hi_word(wParam)})
        pos = find(id,menu_dropped)
        if not find(itemId,hilitems) then
            if not pos then
                hilitems &= itemId
                menu_dropped &= id
            else
        -- selecting an item up in the hierarchy of those already opened, back up the tree
                hilitems = hilitems[1..pos-1] & itemId
                for i=length(menu_dropped) to pos+1 by -1 do
                    VOID = invokeHandler(menu_dropped[i],w32HCloseUp,{})
                end for
                menu_dropped = menu_dropped[1..pos]
            end if
        end if
        if spawnsMenu then
            test = w32Func(xGetSubMenu,{lParam,itemPos})
            itemId = w32lookup(test,menu_handles,menu_ids)
            if not find(itemId,menu_dropped) then
                VOID = invokeHandler(itemId,w32HDropDown,{})
            end if
        end if
    end if
    return {kMainMsg}
end function

--/topic Dialogs
--/func setFRMsgStrings(object nf_message,object nf_caption,object ra_message, object ra_caption)
--/desc Gets and possibly sets the strings appearing in the default message boxes when &
-- find/replace operation completes.
--/ret (SEQUENCE) A sequence of four strings.
-- The arguments are, respectively: 
--/li the message displayed when text is searched and not found;
--/li the caption of the corresponding message box;
--/li the message displayed when a ReplaceAll operation completes;
--/li the message displayed when text is searched and not found.
-- As an added twist, the ReplaceAll completion message may contain the substring "%d" once:
-- this substring will be replaced by the replaced occurence count.
-- Passing any atom as one of the parameters will leave the corresponding value
-- unchanged. In all cases, the current values for all four strings are returned in the same order as the arguments./n
-- When calling /getFRText() with a valid callback routine id, the message boxes are not displayed,
-- and your papplication may take all appropriate steps.
global function setFRMsgStrings(object nf_message,object nf_caption, object ra_message,object ra_caption)
sequence oldVal,formats
integer pos

    oldVal = {NotFoundMessage, NotFoundCaption, ReplacedAllMessage, ReplacedAllCaption}
    if w32string(nf_message) then
        NotFoundMessage = nf_message
    end if
    if w32string(nf_caption) then
        NotFoundCaption = nf_caption
    end if
    if w32string(ra_message) then
        ReplacedAllMessage = ra_message
        formats = w32extract_formats(ReplacedAllMessage)
        pos = find(1,formats[2])
        repMsgHasFormat = pos
        if pos then -- this is a false positive perhaps, check more thoroughly
--/**/      if find(1,formats[2],pos+1) or ReplacedAllMessage[formats[3][pos]]='s' then         --/* -- Phix
            if find_from(1,formats[2],pos+1) or ReplacedAllMessage[formats[3][pos]]='s' then    --*/ -- RDS
                repMsgHasFormat = 0
            end if
        end if
    end if
    if w32string(ra_caption) then
        ReplacedAllCaption = ra_caption
    end if
    return oldVal
end function

-- begin R. Stowasser Feb 3, 2008

----------------------------------------------------
function fDoFindReplace(integer id, atom hWnd, atom iMsg, atom wParam, atom lParam, atom pReturn)
----------------------------------------------------
atom flag, lNewText, callback
sequence lPrevText, lSelection, lSelected
integer  range, rpa_count, pos

    if ctrl_Type[id]=RichEdit then
        pos = find(id, vFindReplaceIds)
        if not pos then
            return {kSubclassedMsg}
        end if
       -- assert: ctrl_Statusbar[id][2]=lParam
        flag = w32fetch(lParam, FINDREPLACE_Flags)

        if and_bits(flag, FR_FINDNEXT) then
            lPrevText = w32fetch(lParam,FINDREPLACE_lpstrFindWhat)
            lSelection = getText(id)
            if and_bits(flag,FR_MATCHCASE)=0 then
                lSelection = ansiLower(lSelection)
                lPrevText = ansiLower(lPrevText)
            end if
            if equal(lSelection,lPrevText) then
                lSelected = getSelection(id)
                setIndex(id,lSelected[2])
            end if
            VOID = setFindSel(id, flag, lParam, 1)

        elsif and_bits(flag, FR_REPLACE) then
            lPrevText = w32fetch(lParam,FINDREPLACE_lpstrFindWhat)
            lSelection = getText(id)
            if and_bits(flag,FR_MATCHCASE)=0 then
                lSelection = ansiLower(lSelection)
                lPrevText = ansiLower(lPrevText)
            end if
            if equal(lSelection,lPrevText) then
                lSelected = getSelection(id)
                lNewText = w32buffer_address(lParam,FINDREPLACE_lpstrReplaceWith)
                VOID = sendMessage(id, EM_REPLACESEL, 1, lNewText)
                setIndex(id,lSelected[2])
            end if
            VOID = setFindSel(id, flag, lParam,1)

        elsif and_bits(flag, FR_REPLACEALL) then
            lPrevText = w32fetch(lParam,FINDREPLACE_lpstrFindWhat)
            lSelection = getText(id)
            if and_bits(flag,FR_MATCHCASE) then
                lSelection = ansiLower(lSelection)
                lPrevText = ansiLower(lPrevText)
            end if
            rpa_count = equal(lSelection,lPrevText)
            if rpa_count then
                lSelected = getSelection(id)
                setIndex(id,lSelected[2])
                lNewText = w32buffer_address(lParam,FINDREPLACE_lpstrReplaceWith)
                VOID = sendMessage(id, EM_REPLACESEL, 1, lNewText)
            end if
            range = 1

            while range>0 do
                range = setFindSel(id, flag, lParam,0)

                if range>0 then
                    lNewText = w32buffer_address(lParam ,FINDREPLACE_lpstrReplaceWith)
                    VOID = sendMessage(id, EM_REPLACESEL, 1, lNewText)
                    rpa_count += 1
                else
                    setIndex(id, 1)
                end if
            end while
            callback = ctrl_Statusbar[id][3]
            if callback>=0 then
                call_proc(callback,{id,rpa_count})
            else
                if repMsgHasFormat then -- resolve reference to # item replaced
                    VOID = message_box(sprintf(ReplacedAllMessage,rpa_count),ReplacedAllCaption,MB_OK+MB_ICONINFORMATION)
                else -- simply display the string
                    VOID = message_box(ReplacedAllMessage,ReplacedAllCaption,MB_OK+MB_ICONINFORMATION)
                end if
            end if

        elsif and_bits(flag, FR_DIALOGTERM) then

            vFindReplaceHwnds[pos] = 0
        end if

    end if

    return {kSubclassedMsg}
end function
-- end RS

--/topic RichEdit
--/func setFRData(integer id,object findWhat,object replaceWith,object flags,integer action)
--/desc Gets and possibly sets the "find what" and "replace with" strings used in a Find/Replace dialog box, as well as its control flags.
--/ret (SEQUENCE) "" if not applicable, else a triple of elements.
-- If /i id is not the id of a RichEdit control for which /getFindText() or /getReplaceText() 
-- is being called, then "" is returned. /n
-- Otherwise, a triple is returned. The first element is the string to be found. If /getFindText()
-- is being called, the second element is 0, else it is the replacement string. /n
-- If /i findWhat is a string, the corresponding field in the dialog box will be updated. If
-- /getReplaceText() is being invoked and /i replaceWith is a string, that field is updated as well. /n
-- If /i flags is a sequence, the current value of the dialog box flags is simply returned;
-- otherwise, the dialog box flags are set to the new value and the former value is returned.
-- In both cases, the value is returned as the third element of the returned sequence. /n
-- If /i action is not w32False, thedialog box will perform as if a button had been clicked,
-- depending on the value passed in /i flags or the current vlue of the dialog flags. Otherwise,
-- no further action is taken and user must push a dialog button for next thing to happen.
global function setFRData(integer id,object findWhat,object replaceWith,object flags,integer action)
--  integer pos
atom fr, oldFlags
sequence fWhat,rWith

    if ctrl_Type[id]!=RichEdit then
        return {}
    end if
    if atom(ctrl_Statusbar[id]) then
        return {}
    end if
    fr = ctrl_Statusbar[id][2]
    fWhat = w32fetch(fr,FINDREPLACE_lpstrFindWhat)
    -- don't free the individual strings, closing the dialog box will do that in one sweep
    if sequence(findWhat) then
        w32release_mem(w32buffer_address(fr,FINDREPLACE_lpstrFindWhat))
        w32store(fr,FINDREPLACE_lpstrFindWhat,w32acquire_mem(ctrl_Statusbar[id][1],findWhat))
        w32store(fr,FINDREPLACE_wFindWhatLen,length(findWhat))
    end if
    oldFlags = w32fetch(fr, FINDREPLACE_Flags)
    if atom(flags) then -- not using -1, as it may be a valid flag some day
        w32store(fr, FINDREPLACE_Flags,flags)
    end if
    rWith = w32fetch(fr,FINDREPLACE_lpstrReplaceWith)
    if ctrl_Statusbar[id][4] then
        if sequence(replaceWith) then
            w32release_mem(w32buffer_address(fr,FINDREPLACE_lpstrReplaceWith))
            w32store(fr,FINDREPLACE_lpstrReplaceWith,w32acquire_mem(ctrl_Statusbar[id][1],replaceWith))
            w32store(fr,FINDREPLACE_wReplaceWithLen,length(replaceWith))
        end if
    end if
    if action then
        VOID = fDoFindReplace(id,0,0,0,fr,0) -- the function doesn't use the other args
    end if
    return {fWhat,rWith,oldFlags}
end function

----------------------------------------------------
----------------------------------------------------
sequence vEventsHandled
vEventsHandled = {
                  WM_MOUSEMOVE,
                  WM_SETFOCUS,
                  WM_KILLFOCUS,
                  WM_KEYDOWN,
                  WM_CHAR,
                  WM_KEYUP,
                  WM_LBUTTONDOWN,
                  WM_RBUTTONDOWN,
                  WM_LBUTTONUP,
                  WM_RBUTTONUP,
                  WM_LBUTTONDBLCLK,
                  WM_RBUTTONDBLCLK,
                  WM_MOUSEWHEEL,
                  WM_SIZE,
                  WM_COMMAND,
                  WM_DROPFILES,
                  WM_PAINT,
                  WM_VSCROLL,
                  WM_HSCROLL,
                  WM_TIMER,
                  WM_SYSCOLORCHANGE,
                  WM_CTLCOLORBTN,
                  WM_CTLCOLORSTATIC,
                  WM_CTLCOLOREDIT,
                  WM_CTLCOLORLISTBOX,
                  WM_CTLCOLORSCROLLBAR,
                  WM_CLOSE,
                  WM_DESTROY,
                  WM_NOTIFY,
                  WM_SYSKEYDOWN,
                  WM_SYSKEYUP,
                  WM_NULL,
                  WM_SYSCHAR,
                  WM_ERASEBKGND,
                  w32FindReplaceMsg,
                  WM_GETDLGCODE,
                  WM_MENUSELECT

}
sequence vHandler

vHandler = {
            routine_id("fDoMouse"),
            routine_id("fDoSetFocus"),
            routine_id("fDoKillFocus"),
            routine_id("fDoKeys"),
            routine_id("fDoChar"),
            routine_id("fDoKeys"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoMouse"),
            routine_id("fDoSize"),
            routine_id("fDoCommand"),
            routine_id("fDoDropFiles"),
            routine_id("fDoPaint"),
            routine_id("fDoScroll"),
            routine_id("fDoScroll"),
            routine_id("fDoTimer"),
            routine_id("fDoSysColorChange"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoCtlColor"),
            routine_id("fDoClose"),
            routine_id("fDoDestroy"),
            routine_id("fDoNotify"),
            routine_id("fDoKeys"),
            routine_id("fDoKeys"),
            routine_id("fDoKeys"),
            routine_id("isHotKey"),
            routine_id("fDoBkGndErase"),
            routine_id("fDoFindReplace"),
            routine_id("fDoDLGCODE"),
            routine_id("fDoMENUSELECT")
           }

sequence vEventCnt
vEventCnt = repeat(0, length(vHandler))

--/topic Events
--/func newEvent(sequence name,object message,object rid)
--/desc Defines a new event, and cause it to be triggered by /i message, with processing routine with routine_id /i rid.
--/ret (INTEGER) w32False on failure, new event code on success.
-- If the name has a "w32H" prefix, it will be stripped./n
-- If /i message is a sequence of several Windows messages, then /i rid should be a sequence of the same length
-- (an atom is treated as a 1-element sequence). Otherwise, the function fails. Likewise,
-- attempting to redefine an existing event will fail, as well as assigning the new event to a message that already triggers one. /n
-- Event names are case sensitive, and must ONLY contain ASCII letters.
global function newEvent(w32string name,object message,object rid)
integer result

    if length(name)>4 and equal(upper(name[1..4]),"W32H") then
        name = name[5..length(name)]
    end if
    if find(name,w32EventNames) then
        return w32False
    end if
--/**/  if find(0, sq_and_bits(w32GetCType(name),Lowercase_CT+Uppercase_CT)) then   --/* -- Phix
    if find(0, and_bits(w32GetCType(name),Lowercase_CT+Uppercase_CT)) then          --*/ -- RDS
        return w32False
    end if
    if atom(message) then
        message = {message}
    end if
    if atom(rid) then
        rid = {rid}
    end if
    if length(message)!=length(rid) or not length(message) then
        return w32False
    end if
    for i=1 to length(message) do
        if find(message[i],vEventsHandled) then
            return w32False
        end if
    end for
    w32EventNames = append(w32EventNames,name)
    result = series:next_number(vkEvents)
    w32EventCodes &= result
    vEventsHandled &= message
    vHandler &= rid
    vEventCnt &= repeat(0, length(rid))
    for i=1 to length(ctrl_Handle) do
        ctrl_Handlers[i] = append(ctrl_Handlers[i],{})
        ctrl_HandlerStates[i] = append(ctrl_HandlerStates[i],{})
        ctrl_ProtectHandlers[i] &= 0
    end for
    return result
end function

sequence vUserEventsHandled,
         vUserEventHandlers
vUserEventsHandled = {}
vUserEventHandlers = {}


--/topic Events
--/proc setWinMsgHandler(object id, object pMsg, integer pRtnId)
--/desc Sets a user defined (raw) windows message handler.
--Use this to set up a handler to directly deal with a
--Windows message prior to win32lib processing it.
-- This is really only used by experienced Windows coders as it
-- must deal with all the low-level detail itself. /n
--
-- /i id can be either a single control Id or a list of them. /n
-- /i pMsg can be either a single Windows message code or a list of them.
-- The /i pRtnId is a routine_id of some code of yours which must
-- be a function that receives these parameters ... /n
--<ol>
--/li integer pSource
--/li atom hWnd
--/li atom iMsg
--/li atom wParam
--/li atom lParam
--</ol>
-- The /i pSource parameter is either kSubclassedMsg if this is a subclassed
--control, or kMainMsg if this is a window or non-subclassed control. /n
--If your handler routine returns a sequence then win32lib does not process
-- the message and the first element in the sequence is returned to Windows.
--
-- Note that if /i pRtnId is /b "-1" then this removes a previously set
-- message handler.
--
--
--Example:
--/code
--  function myhandler(integer pSource, atom hWnd, atom iMsg, atom wParam,  atom lParam)
--     if wParam = VK_ENTER then
--       if iMsg = WM_KEYDOWN then
--         ...
--       else -- WM_KEYUP
--         ...
--       end if
--     end if
--     return {0}
--  end function
--  setWinMsgHandler( myFld, {WM_KEYDOWN, WM_KEYUP}, routine_id(myhandler))
--/endcode

global procedure setWinMsgHandler(object pId, object pMsg, integer pRoutine)
integer lPosn
integer id
atom lMsg

    if not sequence(pId) then
        pId = {pId}
    end if
    if not sequence(pMsg) then
        pMsg = {pMsg}
    end if

    for i=1 to length(pId) do
        id = pId[i]
        for j=1 to length(pMsg) do
            lMsg = pMsg[j]
            lPosn = find({id, lMsg}, vUserEventsHandled)
            if lPosn=0 then
                vUserEventsHandled &= {{id, lMsg}}
                vUserEventHandlers &= -1
                lPosn = length(vUserEventsHandled)
            end if

            if pRoutine>=0 then
                vUserEventHandlers[lPosn] = pRoutine
            else
                vUserEventHandlers = w32removeIndex(lPosn, vUserEventHandlers)
                vUserEventsHandled = w32removeIndex(lPosn, vUserEventsHandled)
            end if
        end for
    end for
end procedure

--/topic Events
--/func setDefaultProcessing(integer NewId)
--/desc This establishes a replacement routine to handle the Windows default processing,
-- or just returns its current value.
--/ret INTEGER: The previous routine_id for this.
--The Windows Default Processing routine is called whenever a message is received for a control
--that Win32lib does not explicitly handle. Win32lib will pass a number of parameters to
-- this routine. /n
--/li /i "integer id": The win32lib ID for the control. It will be zero if it is not a control
--that was created with win32lib.
--/li /i "integer pSource": A code that indicates the source of the message. It is either kMainMsg or
-- kSubclassedMsg depending on whether it comes from a top-level window or a control within a window
-- respectively.
--/li /i "atom hWnd": The handle to the control.
--/li /i "atom iMsg": The Windows message code.
--/li /i "atom wParam": The first data item for the message code.
--/li /i "atom lParam": The second data item for the message code.
--
-- Pass /w32GetValue to just get the routine_id without setting it.
--
--Example:
--/code
--  function MyDefaultProc(integer id, integer pSource, atom hWnd,
--                         atom iMsg, atom wParam, atom lParam)
--      atom lResult
--
--      if (id = 0) or (pSource = kMainMsg) then
--          lResult = w32Func( xDefWindowProc, { hWnd, iMsg, wParam, lParam } )
--      else
--          lResult = w32Func( xCallWindowProc, { mySubProc, hWnd, iMsg, wParam, lParam } )
--      end if
--
--      return lResult
--  end function
--  VOID = setDefaultProcessing(routine_id("MyDefaultProc"))
--/endcode

global function setDefaultProcessing(integer pNewValue)
integer vOldVal

    vOldVal = r_defaultProcessing
    if pNewValue>=0 then
        r_defaultProcessing = pNewValue
    end if
    return vOldVal
end function

-----------------------------------------------------------------------------
function DefProcessing(integer id, integer pSource, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
atom lResult

    lResult = 0

    if (id=0) or (pSource=kMainMsg) then
        lResult = w32Func(xDefWindowProc, {hWnd, iMsg, wParam, lParam})
    else
        lResult = w32Func(xCallWindowProc, {ctrl_Function[id], hWnd, iMsg, wParam, lParam})
    end if

    if lResult=0 then
        return 0  -- "return lResult" may not return 0 here! (C. Bouzy)
    else
        return lResult
    end if
end function
r_defaultProcessing = routine_id("DefProcessing")

-----------------------------------------------------------------------------
function MessageProcessor(integer pSource, atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
    -- callback routine to handle Window class
    -- This routine processes messages sent by Windows
integer
    id,
    lHandledEvent,
    lTemp

object
      result,
      lUserReturn

    -- find the control
    id = getId(hWnd)

    -- not one of mine?
    if id=0 then
        -- default processing
        return call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam})
    end if

    -- Store current message data on stack.
    vWMI += 1
    if vWMI>length(vWinMsg) then
        vWinMsg &= repeat(0, 16)
    end if
    vWinMsg[vWMI] = {pSource, hWnd, iMsg, wParam, lParam, w32Func(xGetMessageTime,{})}

    lTemp = ctrl_Type[id]
    if (sequence(vControlRID[lTemp]) and (vControlRID[lTemp][kCRID_Process]!= -1)) then
        lUserReturn = call_func(vControlRID[lTemp][kCRID_Process], {id, pSource, hWnd, iMsg, wParam, lParam})
        if sequence(lUserReturn) then
            -- Remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn)>0, lUserReturn[1], 0)
        end if
    end if

    -- user can process events that Win32Lib doesn't have handlers for.
    if   length(ctrl_Handlers[id][w32HEvent])>0
    or length(ctrl_Handlers[Screen][w32HEvent])>0
    then
        lUserReturn = invokeHandler(id, w32HEvent, {iMsg, wParam, lParam, pSource})
        if sequence(lUserReturn) then
            -- Remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn)>0, lUserReturn[1], 0)
        end if

    end if

    lHandledEvent = find({id, iMsg}, vUserEventsHandled)
    if lHandledEvent=0 then
        lHandledEvent = find({Screen, iMsg}, vUserEventsHandled)
    end if
    if lHandledEvent!=0 then
        lUserReturn = call_func(vUserEventHandlers[lHandledEvent],
                                {pSource, hWnd, iMsg, wParam, lParam})
        if sequence(lUserReturn) then
            -- remove last message from stack
            vWMI -= 1
            -- user supplied a return code, so return to Windows
            return w32iff(length(lUserReturn)>0, lUserReturn[1], 0)
        end if
    end if

    lHandledEvent = find(iMsg, vEventsHandled)
    if lHandledEvent=0 or
       vHandler[lHandledEvent]<0 then

        ---- Matt Lewis says this fixes some weird bug in windows. ----
        --if ctrl_Type[id] = TabControl and iMsg = WM_NOTIFY then
        --    if w32fetch( lParam, NMHDR_code ) = LVN_DELETEALLITEMS then
        --        vWMI -= 1
        --        return 0
        --    end if
        --end if
        -------------------

        -- Let Windows do the default processing
        result = call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam})

    else
        result = call_func(vHandler[lHandledEvent], {id, hWnd, iMsg, wParam, lParam, pSource})
        if result[1]=kSubclassedMsg then
            if length(result)=2 then
            -- the handler has altered the input parameters
                hWnd   = result[2][1]
                iMsg   = result[2][2]
                wParam = result[2][3]
                lParam = result[2][4]
            end if
            result = call_func(r_defaultProcessing,{id, pSource, hWnd, iMsg, wParam, lParam})
        else
            if length(result)>1 then
                result = result[2]
            else
                result = 0
            end if
        end if

        -- Heuristic Optimisation --
        -- Move frequently used events closer to the start of the list.
        vEventCnt[lHandledEvent] += 1
        if lHandledEvent>1 and (vEventCnt[lHandledEvent-1]+3<vEventCnt[lHandledEvent]) then

            lTemp = vEventsHandled[lHandledEvent-1]
            vEventsHandled[lHandledEvent-1] = vEventsHandled[lHandledEvent]
            vEventsHandled[lHandledEvent] = lTemp

            lTemp = vHandler[lHandledEvent-1]
            vHandler[lHandledEvent-1] = vHandler[lHandledEvent]
            vHandler[lHandledEvent] = lTemp

            lTemp = vEventCnt[lHandledEvent-1]
            vEventCnt[lHandledEvent-1] = vEventCnt[lHandledEvent]
            vEventCnt[lHandledEvent] = lTemp
        end if
    end if

    lUserReturn = invokeHandler(id, w32HAfterEvent, {iMsg, wParam, lParam, result})
    if sequence(lUserReturn) and atom(lUserReturn[1]) then
        result = lUserReturn[1]
    end if
    -- remove last message from stack
    vWMI -= 1
    return result

end function


-----------------------------------------------------------------------------
function WndProc(atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
    return MessageProcessor(kMainMsg, hWnd, iMsg, wParam, lParam)
end function

-----------------------------------------------------------------------------
function SubProc(atom hWnd, atom iMsg, atom wParam, atom lParam)
-----------------------------------------------------------------------------
    return MessageProcessor(kSubclassedMsg, hWnd, iMsg, wParam, lParam)
end function

-----------------------------------------------------------------------------
-- store routine id
procedure get_proc_w32address()

atom id

    -- set WndProcAddress callback
    id = routine_id("WndProc")
    if id= -1 then
        abortErr(Err_WNDPROCNOID)
    end if
    WndProcAddress = call_back(id) -- get 32-bit address for callback

-- NEW! 0.45l
    -- set SubProcAddress callback
    id = routine_id("SubProc")
    if id= -1 then
        abortErr(Err_SUBPROCNOID)
    end if
    SubProcAddress = call_back(id) -- get 32-bit address for callback

end procedure

constant vSHOWWORDS = {
                       "HIDE",
                       "SHOWNORMAL",
                       "NORMAL",
                       "SHOWMINIMIZED",
                       "SHOWMAXIMIZED",
                       "MAXIMIZE",
                       "SHOWNOACTIVATE",
                       "SHOW",
                       "MINIMIZE",
                       "SHOWMINNOACTIVE",
                       "SHOWNA",
                       "RESTORE",
                       "SHOWDEFAULT",
                       "MAX",
                       "FULLSCREEN",
                       "MODAL",
                       "DIALOG"
                      }

constant vSHOWCODES = {
                       SW_HIDE,
                       SW_SHOWNORMAL,
                       SW_NORMAL,
                       SW_SHOWMINIMIZED,
                       SW_SHOWMAXIMIZED,
                       SW_MAXIMIZE,
                       SW_SHOWNOACTIVATE,
                       SW_SHOW,
                       SW_MINIMIZE,
                       SW_SHOWMINNOACTIVE,
                       SW_SHOWNA,
                       SW_RESTORE,
                       SW_SHOWDEFAULT,
                       SW_MAX,
                       w32FullScreen,
                       Modal,
                       Dialog
                      }

-----------------------------------------------------------------------------
--/topic Attributes
--/proc showWindow( window, style )
--/desc Shows a window according to the /i style
--/i window is either a control id or the name of a Window control.
--
-- The /i style flag is one of those in <a href="..\win32_constants.htm#ShowWindow() Commands">this list.</a>
--
--Example:
--/code
--      showWindow(formErrors, SW_HIDE)
--      showWindow("Message List", SW_RESTORE)
--/endcode
global procedure showWindow(object id, object style)
atom hWnd
sequence lProp
integer lPosn

    if sequence(id) then
        id = getNameId(id)
    end if

    if validId(id)=w32False then
        return
    end if

    lPosn = find(upper(style), vSHOWWORDS)
    if lPosn>0 then
        style = vSHOWCODES[lPosn]
    end if

    hWnd = getHandle(id)
    -- display the window
    if equal(style, w32FullScreen) then
        if atom(ctrl_Specific[id]) then
            ctrl_Specific[id] = w32Func(xGetWindowLong, {hWnd, GWL_STYLE}) & getRect(id)
            VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, WS_POPUP})
        end if
        VOID = w32Func(xShowWindow, {hWnd, SW_MAXIMIZE})

    elsif atom(style) then
        if sequence(ctrl_Specific[id]) then
            lProp = ctrl_Specific[id]
            VOID = w32Func(xSetWindowLong,{hWnd, GWL_STYLE, lProp[1]})
            setRect(id, lProp[2], lProp[3],
                    lProp[4]-lProp[2]-1,
                    lProp[5]-lProp[3]-1, w32True)
            ctrl_Specific[id] = 0
        end if
        VOID = w32Func(xShowWindow, {hWnd, style})
    end if
    if ctrl_Type[id]=Window then
        w32Proc(xUpdateWindow, {hWnd})
    end if

end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc openWindow( window, style )
--/desc Opens a window
--/i window is either a control id, a two-element sequence containing
-- {control id, focus id}, or the name of a Window control.
--
-- If /i window is a /b Window then
-- the /i style flag is one of the following:
--
-- /li /b Normal: Original size.
-- /li /b Minimize: Minimized into the task bar.
-- /li /b Maximize: Fills screen.
-- /li /b Modal: Original size, but no other application window can get
--          focus until this window is closed. Use to emulate modal
--          dialogs.
-- /li Win32 Flag: For example, /b SW_SHOWMINNOACTIVE.
--
-- The openWindow function will trigger an /w32HOpen event before it is opened
-- and a /w32HActivate event after it is opened. /n
-- If the w32HOpen event calls /returnValue(-1), the window is not opened.
--
-- It it possible to specify the control that will get the initial
-- focus when the window opens. To do this, the /i window parameter
-- must be specified in the form {window_id, focus_id}. If the /i focus_id
-- is zero, then the first Edit type control is given focus. If there are
-- no edit boxes, then the first button type control is given focus. If
-- you don't specify the initial focus control, then the control that
-- last had focus in the window is used.
--
--Example:
--/code
--      -- Open the Login window, giving focus to the User ID field.
--      openWindow({formLogin txtUserId}, Normal)
--
--      -- Open the Messages window.
--      openWindow("Message List", Normal)
--
--      -- Open an input form
--      openWindow(vPromptCust,
--               {"Name","~<unknown>"}
--              )
--/endcode

global procedure openWindow(object id, object style)

atom hWnd
object styleFlag
object lFocus
sequence lRBSize
sequence lRect
sequence lID
object lRC
integer lPosn
integer bar

    -- Avoid using this routine if app has ended.
    if vWinMainState=kFinished then
        return
    end if

    if sequence(id) then
        if length(id)=2 then
            lFocus = id[2]
            id = id[1]
        else
            id = getNameId(id)
            if length(ctrl_Focus_order[id])>0 then
                lFocus = ctrl_Focus_order[id][1]
            else
                lFocus = -1
            end if
        end if
    else
        lFocus = -1
    end if

    if    validId(id)=w32False then
        return
    end if

    if ctrl_Type[id]=Window then

        -- action?
        lRC = invokeHandler(id, w32HOpen, {})
        if equal(lRC, {-1}) then
            -- Ignore this open request.
            return
        end if

        if ctrl_Specific[id]>0 then
            style = ctrl_Specific[id]
            ctrl_Specific[id] = 0
        end if

        lPosn = find(upper(style), vSHOWWORDS)
        if lPosn>0 then
            style = vSHOWCODES[lPosn]
        end if
        if   equal(style, Modal)
        or equal(style, Dialog)  then
            -- Make sure we can't minimize a modal window.
            removeStyle(id, WS_MINIMIZEBOX)
        end if

        -- get the handle
        hWnd = getHandle(id)

        -- convert the parameter to a Win32 flag
        if integer(style) then
            if style>0 then
                -- real flag
                styleFlag = style
            else
                -- Normal or Modal
                if isMinimized(id) then
                    styleFlag = SW_RESTORE
                else
                    styleFlag = SW_SHOWNORMAL
                end if
            end if
        else
            styleFlag = style
        end if

        -- need to show menubar?
        if ctrl_Menu[id] then
            VOID = w32Func(xDrawMenuBar, {hWnd})
        end if

        -- displaying any tab controls, which may be inside groups or other tabs?
        checkContainersForTabs(id)

        -- display the window
        if atom(styleFlag) then
            VOID = w32Func(xShowWindow, {hWnd, styleFlag})
        else
            showWindow(id, styleFlag)
        end if

        ctrl_Closed[id] = 0

        -- update the window
        VOID = w32Func(xInvalidateRect, {hWnd, NULL, w32True})
        w32Proc(xUpdateWindow, {hWnd})

        -- If this is a "modal" style open, and the window is not already
        -- on the modal stack, save previous modal windows and set this one
        -- as the current modal window.
        if   (equal(style, Modal)
              or equal(style, Dialog))
        and modalWindow!=id
        and w32findKey(id, modalStack)=0  then
            pushModal(id , hWnd, style, length(ActiveEL))
        end if

        -- set focus to the window.
        w32Proc(xSetFocus, {hWnd})
        -- Check if I'm supposed to set focus to a particular control.
        if lFocus>=0 then

            if lFocus=0 then
                for i=1 to length(ctrl_Focus_order[id]) do
                    if find(ctrl_Type[ctrl_Focus_order[id][i]], {EditBox, MleText}) then
                        lFocus = ctrl_Focus_order[id][i]
                        exit
                    end if
                end for
                if lFocus=0 then
                    for i=1 to length(ctrl_Focus_order[id]) do
                        if ctrl_Family[ctrl_Focus_order[id][i]]=BUTTON then
                            lFocus = ctrl_Focus_order[id][i]
                            exit
                        end if
                    end for
                end if
                if lFocus=0 then
                    for i=1 to length(ctrl_Focus_order[id]) do
                        if ctrl_Family[ctrl_Focus_order[id][i]]=COMBO then
                            lFocus = ctrl_Focus_order[id][i]
                            exit
                        end if
                    end for
                end if
            end if
            if lFocus>0 then
                setFocus(lFocus)
            end if
        end if

        -- Save initial control positions if there is any toolbars.
        if AutoReBarSizing then
            for j=1 to length(ctrl_Toolbar[id]) do
                bar = ctrl_Toolbar[id][j]
                if ctrl_Type[bar]=ReBar then
                    lRBSize = getCtlSize(bar)

                    lID = findChildren(id)
                    for i=1 to length(lID) do
                        if  not find(lID[i][1], ctrl_Toolbar[id]) and
                        not find(lID[i][2], {ReBar, ReBarBand, StatusBar,Menu,Popup,MenuItem,MenuSpacer,Pixmap}) then
                            lRect = getRect(lID[i][1])
                            lRect[3] -= lRect[1]
                            lRect[4] -= lRect[2]
                            lRect[2] -= lRBSize[2]
                            ctrl_Init_Posns[bar][1] &= lID[i][1]
                            ctrl_Init_Posns[bar][2] &= {lRect}
                        end if
                    end for
                end if
            end for
        end if

        -- Now tell the app that we are ready for business.
        VOID = invokeHandler(id, w32HActivate, {})

    end if
end procedure
r_openWindow = routine_id("openWindow")



--/topic Attributes
--/proc centerControl( integer Id, integer RefId)
--/desc Centers /i Id with respect to /i RefId
--
--Example:
--/code
--      centerControl(CustDialog, Screen)
--      centerControl(BtnX, CustDialog)
--/endcode

global procedure centerControl(integer pId, integer pRefId)
    alignControls(pId, {w32VertCentre,w32HorzCentre}, {pRefId})
end procedure

integer vIdleCheck
vIdleCheck = 0

---------------------------------------
--/topic Events
--/func setIdle(integer newvalue)
--/ret INTEGER: CurrentValue
--/desc Possibly sets whether or not the library implements w32HIdle
--/i newvalue is either w32True or w32False /n
--The initial setting is w32False, meaning that w32HIdle is not invoked
-- when the application is idling. To start having this handler invoked,
-- you need to setIdle(w32True). Pass /w32GetValue to return the current status.
--
--example
--/code
--  integer x
--  x = setIdle(w32True)
--/endcode
global function setIdle(integer pNewValue)
integer vOldVal

    vOldVal = vIdleCheck
    if pNewValue!=w32GetValue then
        vIdleCheck = (pNewValue!=0)
    end if
    return vOldVal
end function

--/topic Events
--/func setEventLoop(integer NewId, object UserData)
--/desc This establishes an replacement event loop.
--/ret SEQUENCE: The previously set values = {message handler routine id, user data}
--There may be situations in which the Windows Message handler loop, built into Win32lib,
--is not adequate for your needs. If so, you can call this function to supply an alternative
--message handler.
--
--/i NewId is the routine_id of your routine that will be called by Win32lib to process
-- Windows Messages.
--
--/i UserData can be anything. It is passed back to your routine by Win32lib on each call.
--Win32lib does not alter it at anytime.
--
--Win32lib calls the message handler from within the /MainWin() routine to begin processing
-- messages received from Windows. It also calls it when you use /openDialog(). The replacement
--message handler will receive the /i UserData value every time it is called by Win32lib. /n
--
--Example:
--/code
--  integer OldHandler
--  procedure myMsgHandler(sequence Parms)
--     . . . your code goes here . . .
--  end procedure
--  OldHandler = setEventLoop( routine_id("myMsgHandler"), {})
--/endcode
object vELUserData vELUserData = {} -- Used internally as parameters when calling eventLoop.

global function setEventLoop(integer pNewValue, object pUserData)
sequence vOldVal

    vOldVal = {r_eventLoop, vELUserData}
    r_eventLoop = pNewValue
    vELUserData = pUserData

    return vOldVal
end function

integer vWmQuit vWmQuit = 0 -- Matt Lewis, Jul 8, 2005
    -- this var enables doEvents() to tell the event loop that a WM_QUIT message was posted

procedure eventLoop(object pData)
--  sequence temp
atom msg
atom getRC, hDlg
--  integer inc
integer el
integer lTock

    ActiveEL &= 0
    el = length(ActiveEL)

    -- Allocate a message buffer
    msg = w32acquire_mem(0, SIZEOF_MSG)
    lTock = 0
    -- message loop
    while ActiveEL[el]=0
      and vWinMainState=kStarted
      and vWmQuit=0 do

        if vIdleCheck then
            while w32Func(xGetQueueStatus, {QS_ALLEVENTS})=0 do
                lTock += 1
                if sequence(invokeHandler(Screen, w32HIdle, {lTock, msg})) then
                    -- The user wishes to stop being idle and instead
                    -- use the data they have loaded into the msg structure.
                    lTock = -2
                    exit
                end if
            end while

            if lTock>=0 then

                getRC = w32Func(xPeekMessage, {msg, 0, 0, 0, PM_REMOVE})
                if getRC>0 and peek4u(msg+4)=WM_QUIT then
                    exit
                end if
                -- I've decided to ignore the undocumented windows message WM_SYSTIMER ('280')
                -- so it won't stop the idling tock counting.
                if lTock>0 and peek4u(msg+4)!=WM_SYSTIMER then
                    -- Signal end of idleness period.
                    VOID = invokeHandler(Screen, w32HIdle, {-1, msg})
                    lTock = 0
                end if
            else
                lTock = 0
            end if

        else
            getRC = w32Func(xGetMessage, {msg, 0, 0, 0})
            if  getRC=0
            or getRC= -1 then
                exit
            end if
        end if

        -- Gather some entropy for the random integer routine
        w32Seed = remainder((w32Seed*peek4u(msg+16))
                            +1+peek4u(msg+20)*peek4u(msg+24),
                            #FFFFFFFF)
        -- testing for a find/replace dialog
        hDlg = w32Func(xGetActiveWindow,{})
        if not find(hDlg,vFindReplaceHwnds) or not w32Func(xIsDialogMessage,{hDlg,msg}) then
            -- not a message processed by a modeless F/R dialog box
            w32Proc(xTranslateMessage, {msg})
            w32Proc(xDispatchMessage, {msg})
        end if

        -- yield to other tasks, if any is ready
        task_yield()
    end while

    w32release_mem(msg)
    ActiveEL = ActiveEL[1..length(ActiveEL)-1]

end procedure
r_eventLoop = routine_id("eventLoop")

--/topic Events
--/proc doEvents(integer id)
--/desc Gives control back to windows until there are no pending events to process.
-- /i id is usually zero, meaning that events for all controls are processed,
-- however you can limit this to a particular control by supplying it id.
--
-- Typically this is used inside user written event handlers when they know
-- that they might take a long time to complete. For example, if by clicking
-- a button the application must scan through all the files on a disk, it
-- would be appropriate to include a doEvents() call inside the inner loop
-- so that other windows events can be processed during the file search. If
-- this isn't done, no control or window belonging to the application will
-- respond until the disk scan is conpleted. For example, there might be
-- another button that the user can click to abort the disk scan. Without
-- doEvents() this would only respond after the disk scan is completed!
global procedure doEvents(integer id)
atom msg, hWnd, hDlg

    if vWinMainState!=kStarted then
        return
    end if

    if id=0 then
        hWnd = 0
    else
        if validId(id)=w32False then
            return
        end if
        hWnd = getHandle(id)
    end if

    -- Allocate a message buffer
    msg = w32acquire_mem(0, SIZEOF_MSG)

    if w32Func(xPeekMessage, {msg, hWnd, 0, 0, PM_REMOVE}) then
        if peek4u(msg+4)=WM_QUIT then
            -- tell event loop to quit
            vWmQuit = 1
        end if
        -- testing for a find/replace dialog
        hDlg = w32Func(xGetActiveWindow,{})
        if not find(hDlg,vFindReplaceHwnds) or not w32Func(xIsDialogMessage,{hDlg,msg}) then
            -- not a message processed by a modeless F/R dialog box
            w32Proc(xTranslateMessage, {msg})
            w32Proc(xDispatchMessage, {msg})
        end if

        -- yield to other tasks, if any is ready
        task_yield()
    end if
    w32release_mem(msg)

end procedure
r_doEvents = routine_id("doEvents")

-----------------------------------------------------------------------------
--/topic Attributes
--/proc openDialog( object id )
--/desc Opens a window, /i id, as a modal dialog.
--The /i id is either a control id, a two-element sequence containing
-- {control id, focus id}.
--
---There is a difference between this and /openWindow(..., Modal).
-- Here's some examples.... /n
--
--/code
--    while length(filename) = 0 do
--        openWindow(myFileDialog, Modal)
--    end for
--/endcode
--and /n
--/code
--    while length(filename) = 0 do
--        openDialog(myFileDialog)
--    end for
--/endcode
--
--In the first snippet, this would start a very tight loop in which the user
--could not enter data. This is because the /openWindow() would execute
--and /b not wait for the user to enter any data into the new window before
--executing the /i while test again. Whereas the openDialog() routine opens
-- a modal window then /b waits for that window to close before executing
--the line after the openDialog() statement. During this time, any event
--handlers set up for the dialog window would still fire correctly.

global procedure openDialog(object id)

integer lFocus

    lFocus = -1
    if sequence(id) then
        lFocus = id[2]
        id = id[1]
    end if

    if validId(id)=w32False or ctrl_Type[id]!=Window then
        return
    end if

    if lFocus!= -1 then
        openWindow({id,lFocus}, Dialog)
    else
        openWindow(id, Dialog)
    end if

    if ctrl_Closed[id] then
        return
    end if

    call_proc(r_eventLoop,{vELUserData})
    closeWindow(id)

end procedure

function DetermineMainWindow()
integer id

    if ctrl_Type[3]=Window then
        -- If its a window, then this becomes the main window.
        id = 3
    else
        -- otherwise search for the first created window.
        id = 0
        for i=length(ctrl_Type) to 4 by -1 do
            if ctrl_Type[i]=Window then
                id = i
                exit
            end if
        end for

        -- Don't do anything if there is no window.
    end if
    return id
end function

constant r_releaseAll = w32routine_id("releaseAllResources")
procedure releaseAllResources(integer flag,integer r_cleanup,integer r_destroy)
    call_proc(r_releaseAll,{flag,r_cleanup,r_destroy})
end procedure

-----------------------------------------------------------------------------
--/topic System Attributes
--/proc WinMain( window, style )
--/desc Run event loop.
-- This is the main processing loop for Win32Lib. Call WinMain after
-- all the controls and their handlers have been defined for the initial
-- running of the application.
--
-- The main window is set to /i window. When /i window is closed,
-- the application is shut down. /b Note that if /i window is -1 then
-- the first window defined is used as the primary window.
--
-- If you wish to have an application that has /b no window under the
-- control of win32lib, but still wish to use its Windows Message loop,
-- then set /i window as 0.
--
-- The /i style flag is one of the following:
--
-- /li /b Normal: Original size.
-- /li /b Minimized: Minimized into the task bar.
-- /li /b Maximized: Fills the client area of the screen.
--
-- The WinMain function will open the application's main window.
--
-- It it possible to specify the control that will get the initial
-- focus when the window opens. See /openWIndow for details.
--
-- For example:
--/code
--      -- set MyWindow as main window, open normally
--      -- with the initial focus on the Login button.
--      /WinMain( {MyWindow, btnLogin}, Normal )
--/endcode

global procedure WinMain(object id, integer style)
integer lInitFocus
--  object lRtnId
--  sequence lEventName
--  sequence lInitView


    -- Don't rerun this once it has finished.
    if vWinMainState!=kNotStarted then
        return
    end if
    vWinMainState = kStarted

    if sequence(id) then
        lInitFocus = id[2]
        id = id[1]
    else
        lInitFocus = -1
    end if
    -- create the default window
    if id= -1 then
        id = DetermineMainWindow()
    end if

    VOID = setMainWindow(id)
    pushSelf(id)

    -- Time to resolve any deferred event handler references.
    if r_AppCallback>=0 then
        call_proc(r_ResolveDeferredHandlers,{})
    end if

    -- Automatically initialize all control sets as hidden.
    if length(vControlSets)>0 then
        hideControlSet(0)
        showControlSet(1)
    end if

    openWindow({id,lInitFocus}, style)

    -- Start processing the message events.
    call_proc(r_eventLoop, {vELUserData})

    -- release all resources
    if id!=0 then
        releaseAllResources(0,r_libCleanUp,r_destroy)
    end if
end procedure

global constant w32NoCallBack = -1

--/topic Events
--/proc startApp(object CallbackRtns)
--/desc Start the application running.
--This opens the main window, setting focus on the first 'focusable' control
-- and then handles over control to Windows.
--
--The /i CallbackRtn parameter is either a single routine_id or a list of three routine_ids. /n
-- If it is a single routine_id is can be either /w32NoCallBack or the routine id
-- of a callback routine inside your application. See /setCallback for more
-- details.
--
-- If /i CallbackRtns is a list of three routine_ids, it takes the format of ... /n
-- /li integer AppCallback: Same as the single routine_id version above.
-- /li integer AlternateCAllback: If /i AppCallback is -1 then this is used instead.
-- /li integer AppMain: Either -1, or a routine_id of a routine that is called prior
-- to the library start up. The /i AppMain routine is passed a single sequence, which
-- is the command_line() parameters. If /i AppMain returns a zero then the library
-- continues executing otherwise the library stops immediately.
--
--Example:
--/code
--  startApp({routine_id("AppCallback"), routine_id("LocalCallback"), routine_id("AppMain")})
--/endcode

global procedure startApp(object pCallBack_rid)
integer id
--  sequence lKids
--  sequence lProp
integer lCallBack_rid
integer lAltCallBack_rid
integer lMain_rid

    if atom(pCallBack_rid) then
        lCallBack_rid = pCallBack_rid
        lAltCallBack_rid = -1
        lMain_rid = -1
    else
        lCallBack_rid = pCallBack_rid[1]
        lAltCallBack_rid = pCallBack_rid[2]
        lMain_rid = pCallBack_rid[3]
    end if

    if lMain_rid>=0 then
        if call_func(lMain_rid, {command_line()})!=0 then
            return
        end if
    end if

    if length(ctrl_Type)<3 then
        -- There is no Main Window defined,
        return
    end if

    if lCallBack_rid>=0 then
        VOID = setCallback(lCallBack_rid)
    else
        VOID = setCallback(lAltCallBack_rid)
    end if

    -- Check the first Control created after the Screen and Printer.
    if mainWindow=0 then
        id = DetermineMainWindow()
        if id=0 then
            return
        end if

    else
        id = mainWindow
    end if

    -- If the window has any focusable children, select the first one.

    if length(ctrl_Focus_order[id])>0 then
        WinMain({id, ctrl_Focus_order[id][1]}, Normal)

    else
        WinMain(id, Normal)

    end if
end procedure

--/topic Events
--/proc closeApp()
--/desc Closes the application down.
-- You can set a handler to trap the close of the main window if you
-- have any last minute activites to do, such as closing databases, etc...
--
--Example:
--/code
--      procedure Click_CloseBtn(integer self, integer event, sequence parms)
--          if message_box("Is it okay to stop now?", "Close", MB_YESNO) = IDYES
--              closeApp()
--          end if
--      end procedure
--      setHandler(CloseBtn, w32HClick, routine_id("Click_CloseBtn"))
--
--/endcode
global procedure closeApp()
    if mainWindow!=0 then
        closeWindow(mainWindow)
    end if
end procedure

-----------------------------------------------------------------------------
--/topic Attributes
--/proc setHintEx( object control, object text, atom exflags )
--/desc Set the tooltip text for a control.
-- This is identical to /setHint() except that you can use extra flags
-- when creating the tooltip for a control. These flags are those whose names starts with TTF_.
--
-- Example:
--/code
--      -- set hint for CloseButton
--      /setHintEx( CloseButton, "Closes the window", TTF_CENTERTIP )
--/endcode

global procedure setHintEx(object id, object text, atom exflags)
atom
       ti,
       lTTflags,
       lTTmsg

--  sequence rect
integer parentId
integer lPart

    lPart = 0
    if sequence(id) then
        if length(id)=2 then
            lPart = id[2]
            id = id[1]
            if validId(id)=w32False
            then
                return
            end if
            if ctrl_Type[id]!=StatusBar then
                return
            end if
            if atom(text) then
                text = sprintf("routine_id %g not supported.", text)
            end if
            VOID = sendMessage(id, SB_SETTIPTEXT, lPart, text)
        end if
        return
    end if

   -- Doesn't hurt to check.
    if validId(id)=w32False
   then
        return
    end if

    -- Special code to set replicate the hint in a Combo's edit area.
    ti = getEdit(id)
    if ti then -- I own an edit area.
        setHintEx(ti, text, exflags)
    end if

    parentId = findParent(id)
    if parentId=0 then -- Use myself if I'm the top-level window.
        parentId = id
    end if

    ctrl_Hint_Text[id] = text

    -- First time thru, create the tooltip control to manage hints.
    if not tooltipControl then
        tooltipControl = createEx(ToolTip, "", 0, 0, 0, 0, 0, 0, 0)
    end if


    if atom(text) or length(text)  then  -- adding a tip
        lTTflags = w32or_all({TTF_SUBCLASS, TTF_IDISHWND, exflags})
        lTTmsg   =  TTM_ADDTOOL

    else  -- deleting a tip
        lTTflags = 0
        lTTmsg   = TTM_DELTOOL

    end if

    ti = w32to_memory(0,ID_TOOLINFO, {
                                      lTTflags,
                                      ctrl_Handle[parentId],
                                      ctrl_Handle[id],
                                      {0,0,0,0},0,
                                      LPSTR_TEXTCALLBACK -- text
                                     })

    VOID = sendMessage(tooltipControl, lTTmsg, 0, ti)
    VOID = sendMessage(tooltipControl, TTM_SETMAXTIPWIDTH, 0,
                       ctrl_Hint_Width[id])
    w32release_mem(ti)
end procedure
r_setHintEx = routine_id("setHintEx")

constant TTDT = {TTDT_INITIAL,TTDT_AUTOPOP,TTDT_RESHOW}

--/topic System Attributes
--/func setTooltipTiming(integer id,object timings)
--/desc Possibly sets the timings for all the tooltips the tooltip conrol /i id manages.
--/ret The previous or current values.
-- Three durations are associated to a tooltip. If /i timings is a sequence, its elements are:
--/li the initial delay (in miliseconds) during which the mouse must hover for the tooltip window to pop up;
--/li the autopop duration, in miliseconds: this is the time during which the tooltip window remeinas visible;
--/li the reshow delay, in milliseconds: delay from a change of hovered upon control and
-- the next popping up of a tooltip window for the new target control.
-- For each of these, use w32False to set to default and w32GetValue to return without setting.
-- If /i timings is a positive integer, the initial delay is set to the supplied value, the autopop duration to ten times the initial delay, and the reshow delay to a fifth of the initial delay. Using w32False will return the values to default - 500, 5000 and 100ms respetivelly. Using w32GetValue will skip any setting.
-- At any rate, the three timings are returned.

global function setTooltipTimings(integer id,object timings)
sequence result

    if ctrl_Type[id]!=ToolTip then
        return {}
    end if
    result = {sendMessage(id,TTM_GETDELAYTIME,TTDT_INITIAL,0),
              sendMessage(id,TTM_GETDELAYTIME,TTDT_AUTOPOP,0),
              sendMessage(id,TTM_GETDELAYTIME,TTDT_RESHOW,0)}
    if atom(timings) then
        if timings>0 then
            VOID = sendMessage(id,TTM_SETDELAYTIME,TTDT_AUTOMATIC,timings)
        elsif timings!=w32GetValue then
            VOID = sendMessage(id,TTM_SETDELAYTIME,TTDT_AUTOMATIC,-1)
        end if
    else
        for i=1 to 3 do
            if timings[i]>0 then
                VOID = sendMessage(id,TTM_SETDELAYTIME,TTDT[i],timings[i])
            elsif timings[i]!=w32GetValue then
                VOID = sendMessage(id,TTM_SETDELAYTIME,TTDT[i],-1)
            end if
        end for
    end if
    return result
end function

--/topic System Attributes
--/func manageToolTip( integer pAction, integer pNewControl)
--/desc Helps manage the ToolTip controls.
--/ret The current tooltip control id.
-- Use this to activate or deactivate the current tooltip control, or
-- to just get the id of the current tooltip control.
--
-- Set /i pAction to /b 1 to activate tooltips or /b 0 to deactivate them.
-- Any other value has no effect. /n
-- In all cases, the id of the current tooltip control is returned.
global function manageToolTip(integer pAction, integer pNewControl)
integer
     lOldToolTip

    lOldToolTip = tooltipControl

   -- See if a new control needs to be installed.
    if pNewControl>0
    and
    ctrl_Family[pNewControl]=ToolTip
   then
        VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 0, 0)
        tooltipControl = pNewControl
        VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 1, 0)
    end if

   -- Activate/Deactivate the current tooltip control.
    if pAction=1
   then
        VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 1, 0)
    elsif pAction=0
   then
        VOID = sendMessage(tooltipControl, TTM_ACTIVATE, 0, 0)
    end if

    return lOldToolTip

end function

--/topic Attributes
--/proc setHint( object control, object text )
--/desc Set the tooltip text for a control.
-- If the mouse stays still over a control that has tooltip text
-- associated with it, a small window displaying the tooltip text will
-- appear.
--
-- Any control that can get mouse events can have tooltips associated with
-- it, although it tends to work best with /PictureButtons, typically
-- in the /ToolBar.
--
-- Setting the text to "" effectively removes the tooltip.
--
-- /b Note: When setting tooltips for multipanelled StatusBar controls,
-- you need to specify which panel the tip applies to. You do this by
-- setting the /i control parameter as a sequence in the form {id, panel}
-- where /i id is the StatusBar control and /i panel is the panel number.
--
-- It is possible to dynamically set the text of a tooltip so that each time
-- the control needs to display a tip, it first calls a routine of your own
-- that must supply the text to display. To do this, set the /i text parameter
-- to the routine_id of your function. Your /b function will receive two parameters:
-- ( id, width ) where /i id is the control that needs a tip, and /i width is the
-- width of the tooltip box that will be used (in pixels). Your function must
-- return a /b sequence. That sequence can simply be the tip text, or a 2-element
-- sequence in the form { tiptext, newwidth }.
--
-- Example:
--/code
--      -- set hint for CloseButton
--      setHint( CloseButton, "Closes the window" )
--
--      function gettip( integer id, integer width)
--         sequence newtext
--         sequence AccountRecord
--
--         AccountRecord = getAccountFromName(getText(id))
--         if length(AccountRecord) > 0 then
--             newtext = sprintf("Account %d has a balance of %12.2f",
--                                {AccountRecord[fAcctNo],
--                                 AccountRecord[fCurBal]})
--         else
--             newtext = "No account found for this name."
--         end if
--         return newtext
--      end function
--      setHint( txtAccountName, routine_id("gettip") )
--/endcode


global procedure setHint(object id, object text)
    setHintEx(id, text, 0)
end procedure

--/topic Attributes
--/func getHint(integer id)
--/desc Find the hint text for a control, or the caption for a flattoolbar button
--/ret Any Tool Tip text associated with this /i id
global function getHint(integer id)
    return ctrl_Hint_Text[id]
end function


--/topic Attributes
--/func setHintWidth(integer id, integer width)
--/desc Possibly sets the maximum width, in pixels, of the control's tooltip box.
--/ret INTEGER: Current width setting.
-- Pass a negative value to just return the current maximum width.
global function setHintWidth(integer id, integer width)
integer lWidth

    lWidth = ctrl_Hint_Width[id]
    if width>=0 then
        ctrl_Hint_Width[id] = w32iff(width>0, width, 0)
    end if
    return lWidth
end function

--/topic Utilities
--/func hitTestTT()
--/desc Tests to see if the mouse is currently over a control that has a tooltip.
--/ret w32False or the id of a control.
global function hitTestTT()
atom ht, ok, tools
integer id,parentId
sequence pt, op, mouse

    ht = w32acquire_mem(0, SIZEOF_TTHITTESTINFO)

    mouse = getPointerPos()

    tools = sendMessage(tooltipControl, TTM_GETTOOLCOUNT, 0, 0)

    id = 1
    ok = 0
    for i=1 to tools do
      -- only look at Ids that have some tooltip text.
        while not length(ctrl_Hint_Text[id]) do
            id += 1
        end while

        -- get its parent. NB, Top-level controls are their own parent.
        parentId = ctrl_Parent[id]
        if parentId=0 then
            parentId = id
        end if

        w32store(ht, TTHITTESTINFO_hwnd, ctrl_Handle[parentId])

        op = getClientPoint(parentId, 0, 0)
--/**/  pt = sq_sub(mouse,op)                   --/* -- Phix
        pt = mouse - op                         --*/ -- RDS

        w32store(ht, TTHITTESTINFO_pt, pt)

        ok = sendMessage(tooltipControl, TTM_HITTEST, 0, ht)

        if ok then
            ok = w32fetch(ht ,{TTHITTESTINFO_ti, TOOLINFO_uId})
            exit
        end if

        id += 1
    end for


    w32release_mem(ht)

    return ok

end function


------------------------------------------------------------------------------
--/topic Utilities
--/func shellExecuteEx( object verb, sequence file, object params, object defdir, object style, atom struct )
--/desc Launch a Windows application
--/ret ATOM: Success code. 0 to 32 are errors; successful invocation returns a process handle.
--
-- This is a wrapper around the Win32 /b ShellExecute command.
--
-- The /i verb parameter is the action you are trying to execute. In nearly
-- all cases this is "open". The actions possible are defined in your Windows
-- File Associations definitions. If this parameter is not a sequence then
-- the default action for the /i file is used.
--
-- The /i file parameter is the file to perform the action upon. This is
-- usually a .EXE file but can be any file type that has a defined action in
-- the Window File Associations.
--
-- The /i params is a list of zero or more parameters passed to the file.
-- Usually when opening an EXE file, this is the parameters for that program.
--
-- The /i defdir is the default directory to change to before openning the
-- file. If this is not a sequence the the current directory is used.
--
-- The /i style parameter is a window style flag.
-- These can be ... /n
--/li SW_HIDE
--/li SW_SHOWNORMAL
--/li SW_NORMAL
--/li SW_SHOWMINIMIZED
--/li SW_SHOWMAXIMIZED
--/li SW_MAXIMIZE
--/li SW_SHOWNOACTIVATE
--/li SW_SHOW
--/li SW_MINIMIZE
--/li SW_SHOWMINNOACTIVE
--/li SW_SHOWNA
--/li SW_RESTORE
--/li SW_SHOWDEFAULT
--/li SW_MAX
--
-- The /i pStruct parameter is not used yet.
--
-- The return codes for this function are... /n
--/li SE_ERR_FNF                    -- file not found
--/li SE_ERR_PNF                    -- path not found
--/li SE_ERR_ACCESSDENIED           -- access denied
--/li SE_ERR_OOM                    -- out of memory
--/li SE_ERR_SHARE
--/li SE_ERR_ASSOCINCOMPLETE
--/li SE_ERR_DDETIMEOUT
--/li SE_ERR_DDEFAIL
--/li SE_ERR_DDEBUSY
--/li SE_ERR_NOASSOC
--/li SE_ERR_DLLNOTFOUND

global function shellExecuteEx(object verb, sequence file, object parms,
                  object defdir, atom style, atom pStruct)

-- call ShellExecuteEx to display a file
atom mset, parms_p, file_p, verb_p, defdir_p
atom hWnd
integer rc
    if pStruct then end if

    if validId(mainWindow) then
        hWnd = getHandle(mainWindow)
    else
        warnErr("shellExecute requires a WinMain()")
        return 0
    end if

    -- convert to strings
    mset = w32new_memset()
    if atom(verb) or length(verb)=0 then
        verb_p = 0
    else
        verb_p = w32acquire_mem(mset, verb)
    end if

    if atom(parms) or length(parms)=0 then
        parms_p = 0
    else
        parms_p = w32acquire_mem(mset, parms)
    end if

    file_p  = w32acquire_mem(mset, file)

    if atom(defdir) or length(defdir)=0 then
        defdir_p = 0
    else
        defdir_p = w32acquire_mem(mset, defdir)
    end if

    -- call ShellExecute
    rc = w32Func(xShellExecute,
                 {hWnd, verb_p, file_p, parms_p, defdir_p, style})

    -- Free the strings
    w32release_mem(mset)

    return rc
end function

------------------------------------------------------------------------------
--/topic Utilities
--/proc shellExecute( command, file, style )
--/desc Launch a Windows application
--
-- This is a wrapper around the Win32 /b ShellExecute command.
-- /i command is usually "open". /n
-- /i file is the file or directory to open or run. /n
-- /i style is usually SW_SHOWNORMAL, but can be SW_SHOWMINIMIZED or
-- SW_SHOWMAXIMIZED
--
--/code
--       -- Start up MSAcess on the database.
--       shellExecute("open", "myDB.mdb", SW_SHOWNORMAL)
--/endcode
global procedure shellExecute(object verb, sequence file, atom style)

    VOID = shellExecuteEx(verb, file, "", "", style, 0)

end procedure

-----------------------------------------------------------------------------
------------------------------------------------------------------------------
--/topic Utilities
--/func playSound( sequence FileParm )
--/desc Play the .WAV file.
--/ret /b w32True if succeeds, /b w32False if fails.
-- This is a wrapper around the Win32 /b PlaySound command. /n
-- /i FileName can take one of four forms. /n
-- /li The value 0 or an empty sequence. Use this to immediately stop playing
-- any sound.
-- /li A simple filename, such as a ".WAV" file to play. This sets up the
-- flags as SND_FILENAME and SND_ASYNC. /n
-- /li The form {FileName, Flags} which gives you more control over the flag settings.
-- The /i Flags can be either a single atom or a sequence of sound flags.
--/li The form  {FileName, Flags, ResourceId} is available the sound you need to
-- play is contained in the resources of an executable file. In this case /i FileName
-- is is a sequence with one element in it; a handle to an executable file. /i ResourceId
-- is the id of the resource to play.
--
--Example:
--/code
--      -- Play a sound file and return before it ends.
--      VOID = playSound("announce.wav")
--
--      -- Play a sound file and wait until it ends.
--      VOID = playSound({"announce.wav",{SND_FILENAME,SND_SYNC})
--
--      -- Play a sound file continuously in the background
--      VOID = playSound({"background.wav", {SND_FILENAME,SND_ASYNC,SND_LOOP})
--
--      -- Play a sound file but only if no other sound is already playing.
--      VOID = playSound({"hit.wav",{SND_FILENAME,SND_ASYNC,SND_NOSTOP})
--
--      -- Play a sound named in the system registry.
--      VOID = playSound({"MailBeep",{SND_ALIAS})
--
--      -- Stop playing any sound.
--      VOID = playSound({"",SND_PURGE})
--      -- or
--      VOID = playSound(0)
--
--/endcode
global function playSound(object pFileParms)

atom lFlags
atom lResource
object lFileName

    lResource = 0
    if atom(pFileParms) or length(pFileParms)=0 then
        lFlags = SND_PURGE
        lFileName = ""

    else
        if sequence(pFileParms[1]) then
            lFileName = pFileParms[1]
            if length(pFileParms)>=2 then
                if sequence(pFileParms[2]) then
                    lFlags = w32or_all(pFileParms[2])
                else
                    lFlags = pFileParms[2]
                end if
            end if

            if length(pFileParms)>=3 then
                lResource = pFileParms[3]
                lFlags = or_bits(lFlags, SND_RESOURCE)
                lFileName = pFileParms[1][1]
            end if

        else
            lFileName = pFileParms
            lFlags = or_bits(SND_FILENAME, SND_ASYNC)

        end if
    end if
?xPlaySound
{} = wait_key()

    -- play the sound
    return w32Func(xPlaySound, {lFileName, lResource, lFlags})

end function

--/topic Utilities
--/proc w32Sleep(atom milliseconds)
--/desc Puts current thread to sleep for /i milliseconds milliseconds, if another OS thread is ready to run.
-- "thread" here refers to an /b"OS thread", not to an Euphoria task. exw.exe runs two separate threads./n
-- Passing a value of #FFFFFFFF puts the thread to sleep until some specific action is taken to wake the thread up./n
-- Passing a value of 0 attempts to run another thread of same priority immediately./n
-- Passing any other values puts the thread to sleep for that many milliseconds. If another thread has the same priority
-- and is ready to run, it gets control.
global procedure w32Sleep(atom milliseconds)
    w32Proc(xSleep,{milliseconds})
end procedure

--/topic Miscellaneous
--/proc Beep(atom style)
--/desc Sounds one of the standard beeps.
--
--/i style can be one of ... /n
--/li -1  Standard beep using the computer speaker
--/li MB_ICONASTERISK SystemAsterisk
--/li MB_ICONEXCLAMATION SystemExclamation
--/li MB_ICONHAND SystemHand
--/li MB_ICONQUESTION SystemQuestion
--/li MB_OK
--
--Example
--/code
--  Beep( MB_ICONEXCLAMATION )
--/endcode

global procedure Beep(atom pStyle)
    VOID = w32Func(xBeep, {pStyle})
end procedure



-----------------------------------------------------------------------------
function libCleanUp(integer pErrCode, sequence pDispMsg, integer pN, integer pLast)
-----------------------------------------------------------------------------

    releaseAllResources(1,r_libCleanUp,r_destroy)
    return 0
end function
r_libCleanUp = routine_id("libCleanUp")

-----------------------------------------------------------------------------
procedure initialize()
-----------------------------------------------------------------------------

    -- various housekeeping tasks
--  atom szAppName

    setStartupFont(ANSI_VAR_FONT)  -- sets usual 'tiny' default font
    -- Create the screen and printer controls
    setControlBlocks(2)
    Screen  = createEx(Screen_, "", 0, 0, 0, 0, 0, 0, 0)
    Printer = createEx(Printer_, "", 0, 0, 0, 0, 0, 0, 0)
    setControlBlocks(16)

    -- get the proc address
    get_proc_w32address()

    -- set the 'clean up' behavior
    VOID = attachCleanUp(r_libCleanUp)

end procedure


---------------------------
procedure checkPopup(integer self, integer event, sequence parms)
---------------------------
atom shifts
object lMenu
integer lOffsetX
integer lOffsetY

    shifts = parms[4]
    lOffsetX = -6
    lOffsetY = -6

    if parms[1]=WM_RBUTTONDOWN then

        if and_bits(shifts, ShiftMask+ControlMask)=(ShiftMask+ControlMask) then
            lMenu = ctrl_Popup[self][4]

        elsif and_bits(shifts, ShiftMask)=ShiftMask then
            lMenu = ctrl_Popup[self][2]

        elsif and_bits(shifts, ControlMask)=ControlMask then
            lMenu = ctrl_Popup[self][3]

        else
            lMenu = ctrl_Popup[self][1]
        end if

        if sequence(lMenu) then
            if length(lMenu)>=3 then
                lOffsetY = lMenu[3]
            end if
            if length(lMenu)>=2 then
                lOffsetX = lMenu[2]
            end if

            lMenu = lMenu[1]
        end if

        if not equal(lMenu,-1) then
            popup({lMenu,self}, parms[2]+lOffsetX, parms[3]+lOffsetY)
        end if
    end if

end procedure


--/topic Menus
--/func attachPopup(integer pId, object pMenus)
--/desc Associates one or more menus to a control as popup or context menus.
--/ret SEQUENCE: Previously attached menus.
--This will cause the menu(s) supplied in /i pMenu to be linked to
-- the control /i pId such that when the righthand mouse button is pressed,
-- the menu will pop up next to the mouse pointer. /n
-- You can have different menus popup depending on the combination of
-- Ctrl and Shift keys you have pressed. You do this by supplying up to four
-- menu ids in /i pMenu, one for no keys pressed, one for shift key, one for
-- control key, and another for both shift and control keys pressed.
--
-- Each value in /i pMenu is either a Menu id, 0, -1, or a sequence
-- of the form {MenuId, XOffset, YOffset}. /n
-- If a simple menu id, then this is the popup menu that will display when
-- the user right-clicks in the control. /n
-- If -1, then the corresponding current value is retained. Use this to
-- skip over setting previous values of menu ids. /n
-- If 0, then the corresponding menu id is cleared and the popup will /b
-- not display. /n
-- If a sequence, then the /i XOffset and /i YOffset are used to position
-- the menu relative to the mouse pointer. The default values are -6 and -6
-- respectively. Use this when you need the menu to be shown is different
-- position.
--
--First you need to define the menus and any handlers for them, then you
-- can attach them to one or more controls.
--
--Example
--/code
--      -- Define two menus.
--      MenuOne = create(Menu, "One", MainWindow, 0, 0, 0,0, 0)
--        M1_Item1 = create(MenuItem, "Item 1.1", MenuOne, 0, 0, 0,0, 0)
--        M1_Item2 = create(MenuItem, "Item 1.2", MenuOne, 0, 0, 0,0, 0)
--        M1_Item3 = create(MenuItem, "Item 1.3", MenuOne, 0, 0, 0,0, 0)
--      MenuTwo = create(Menu, "Two", MainWindow, 0, 0, 0,0, 0)
--        M2_Item1 = create(MenuItem, "Item 2.1", MenuTwo, 0, 0, 0,0, 0)
--        M2_Item2 = create(MenuItem, "Item 2.2", MenuTwo, 0, 0, 0,0, 0)
--        M2_Item3 = create(MenuItem, "Item 2.3", MenuTwo, 0, 0, 0,0, 0)
--      setHandler(M1_Item1, w32HClick, routine_id("Click_Item11"))
--      setHandler(M1_Item2, w32HClick, routine_id("Click_Item12"))
--      setHandler(M1_Item3, w32HClick, routine_id("Click_Item13"))
--      setHandler(M2_Item1, w32HClick, routine_id("Click_Item21"))
--      setHandler(M2_Item2, w32HClick, routine_id("Click_Item22"))
--      setHandler(M2_Item3, w32HClick, routine_id("Click_Item23"))
--
--  -- Now attach popups for normal and ctrl keys
--  prevMenus = attachPopup(SomeFld,
--                {MenuOne, -- Normal (no keys)
--                  -1,      -- ignore Shift
--                  -- Note the changed X-Y offsets.
--                  {MenuTwo,-20,-10}  -- Ctrl key
--                 })
--
--/endcode
global function attachPopup(integer pId, object pMenus)
sequence lOldValues
--  sequence lNewValues
integer  lCount
--  object lTemp

    -- Save current values
    lOldValues = ctrl_Popup[pId]

    -- fixup the case when only one menu id is supplied.
    if atom(pMenus) then
        pMenus = {pMenus}
    end if

    -- only process up to the 4th menu id.
    lCount = length(pMenus)
    if lCount>4 then
        lCount = 4
    end if

    -- Update the control's popup values
    for i=1 to lCount do
        if pMenus[i]= -1 then
            -- Retain previous value

            pMenus[i] = lOldValues[i]

        elsif pMenus[i]=0 then
            -- Detach this specific combination.
            pMenus[i] = -1
        end if
        ctrl_Popup[pId][i] = pMenus[i]
    end for

    -- Add a handler to trap right-mouse presses for this control.
    setHandler(pId, w32HMouse, {-2,  routine_id("checkPopup")})

    return lOldValues
end function

integer fn_debug fn_debug = 1
global constant w32DebugLog = -1772
global procedure wDebug(sequence pData)

    if length(pData)=2 then
        if sequence(pData[1]) then
            printf(fn_debug, pData[1], pData[2])
        else
            if pData[1]=w32DebugLog then
                if fn_debug>2 then
                    close(fn_debug)
                end if
                fn_debug = w32FileOpen(pData[2], "w")
                if fn_debug<0 then
                    fn_debug = 1
                end if
            end if
        end if
    else
        puts(fn_debug, w32ToString(pData))
        if not equal(pData[length(pData)], '\n') then
            puts(fn_debug, '\n')
        end if
    end if
end procedure


include w32forms.ew
r_getAutoSize = w32routine_id("getAutoSize")
r_getDeferredHandlers = w32routine_id("getDeferredHandlers")
r_ResolveDeferredHandlers = w32routine_id("ResolveDeferredHandlers")
r_MakeArgs = w32routine_id("w32MakeArgs")

--/topic Controls
--/func registerControl(sequence pControlName, sequence pRID)
--/desc Enables you to define new control types.
--/ret A control type identifier, which you can use as the first argument of create[Ex](). -1 is returned if the class is registered already.
--
-- pControlName is a string that identifies the control, like "MyListView". /n
-- pRID is a sequence of four routine ids: the control, create, process and destroy routines.
--
-- A control actually has two classes. Its /i external class is returned by registerControl() on success.
-- It also has an /i internal class, which tells the library how it should treat your control.
-- Since the library hardly knows about the control you are registering, you have to tell it 
-- what it resembles most, or -1 if this really is brand new in the Windows GUI
--.
-- The control routine is passed two parameters: a command name and a default value. Its
-- routine id must always be valid.
-- At class registration time, the routine will be called in sequence with the following arguments:
--/define
--/term "className"
-- supply a string, or -1 (default) if this is not to be a Windows class
--/term "classType"
-- return the control type the library should consider your control to belong to. Default is -1. For instance, return RichEdit if your contol is to be sent RichEdit-specific messages.
--/term "classStyle"
-- return the sum of the class style flags the new class must have. Default is 0.
--/term "classStyleEx"
-- return the sum of the class extended style flags the new class must have. Default is 0.
--/term "classAttr"
-- return the sum of win32lib class attributes the new class must have. Default is 0.
-- "classDefPointer"
-- return an identifier for the mouse pointer shape to use over this kind of control. Default is IDC_ARROW (the standard pointer carrow).
--/term "classBGColor"
-- return a 24-bit integer representing the background color for all controls of that class, or a system color identifier. Default is w32Color_BTNFACE.
--/term "classFGColor"
-- return a 24-bit integer representing the foreground color for all controls of that class, or a system color identifier. Default is w32Color_WINDOWTEXT.
--/term "classKbdInput"
-- return the sort of keyboard input controls of the new class should handle, a sum of zero or more flags among the 
-- <a href="..\win32_constants.htm#WM_GETDLGCODE return flags">DLGC_ flags. </a>
-- Default is the corresponding value for the alias class.
--/enddefine
-- At control creation time, this is called to request the real parent of the control. It is passed the string "NewOwner" and the parent supplied to create(). It must return the actual owner of the control being created.
--
-- The create routine will be called at creation time with a string, which is a command word, and a sequence. If the routine id for it is -1, the routine is not called at all.
-- When called with the command word "Pre", the other sequence contains:
--/li the new control id
--/li the caption
--/li the owner
--/li the x-position
--/li the y-position
--/li the width
--/li the height
--/li the style flags
--/li the extended style flags
-- The routine must return something. If the returned value is a sequence of length 9 whose first element is the supplied id, the returned values are substituted for the ones that were passed.
--
-- When creation occurred, and instead of setting fonts or loading bitmaps, the library calls the create routine again with a command word of "Post" and {id} as arguments.
-- The routine may then perform the same kind of tasks on the newly created control.
-- If the function returns {id,constant}, where the constant is any of /b w32RecentMenu,
-- /b w32RecentTabControl or /b w32RecentWindow, then the control is to be considered the most recent of the expected kind, which will help parenting further controls to it. If the routine
-- handles actual control creation itself, it must return an atom.
--
-- The process routine  is called before the w32HEvent event is invoked with
--/item The control id
--/item an integer, either kMainMsg or kSubclassedMsg;
--/item The original handle;
--/item The original message;
--/item The original wParam of the message;
--/item The original lParam of the message.
--
-- If it returns a sequence, its first element is returned to Windows (it must be an integer). If the sequence is empty, 0 is returned.
--
-- The destroy routine is called with the string "Destroy" and a sequence containing the id of the control to be destroyed. If it returns 0, specific messages are sent.

global function registerControl(sequence pControlName, sequence pRID)
integer lControl,lClass

-- Is this already registered?

    pControlName = w32trim(pControlName)
    lControl = find(upper(pControlName), w32ControlNames)
    if lControl!=0 then
        return -1
    end if

    w32ControlNames = append(w32ControlNames, upper(pControlName))
    lControl = length(w32ControlNames)
    w32ControlTypes = append(w32ControlTypes, lControl)

    vControlRID = w32MinSequenceSize(vControlRID, lControl, 0)
    vControlRID[lControl] = pRID

    className = w32MinSequenceSize(className, lControl, 0)
    className[lControl] = call_func(pRID[kCRID_Control], {"className", -1})
    classType = w32MinSequenceSize(classType, lControl, 0)
    classAlias = w32MinSequenceSize(classAlias, lControl, 0)
    lClass = call_func(pRID[kCRID_Control], {"classType", -1})
    classAlias[lControl] = lClass
    classType[lControl] = classType[lClass]
    classStyle = w32MinSequenceSize(classStyle, lControl, 0)
    classStyle[lControl] = call_func(pRID[kCRID_Control], {"classStyle", 0})
    classStyleEx = w32MinSequenceSize(classStyleEx, lControl, 0)
    classStyleEx[lControl] = call_func(pRID[kCRID_Control], {"classStyleEx", 0})
    classAttr = w32MinSequenceSize(classAttr, lControl, 0)
    classAttr[lControl] =  call_func(pRID[kCRID_Control], {"classAttr", 0})
    classDefPointer = w32MinSequenceSize(classDefPointer, lControl, 0)
    classDefPointer[lControl] = call_func(pRID[kCRID_Control], {"classDefPointer", IDC_ARROW})
    classBGColor = w32MinSequenceSize(classBGColor, lControl, 0)
    classBGColor[lControl] = call_func(pRID[kCRID_Control], {"classBGColor", WindowColor})
    classFGColor = w32MinSequenceSize(classFGColor, lControl, 0)
    classFGColor[lControl] = call_func(pRID[kCRID_Control], {"classFGColor", w32Color_WINDOWTEXT})
    classKbdInput = w32MinSequenceSize(classKbdInput, lControl, 0)
    classKbdInput[lControl] = call_func(pRID[kCRID_Control], {"classKbdInput", classKbdInput[lClass]})

    return lControl

end function

--/topic Events
--/proc registerNotification(integer pSender, integer pAction, integer pEvent, integer pReceiver, object pUserData)
--/desc Defines, modifies or removes an event forwarding.
-- This procedure instructs the library to forward /i pEvent to /i pReceiver when /i pSender receives it, or to perform some actions on an existing forwarding./n
-- When a control must notify another, it does so by firing a /w32HNotify event on the receiver. The parameter sequence for this event is {/i sender,/i event, /i user data,parameter sequence of the triggering event}.
-- /i pAction is any of:
--/li /b w32notifyCreate: creates a new event notification, or change user data associated to an existing one. The new notification is enabled;
--/li /b w32notifyDefer: creates a new event notification, or change user data associated to an existing one. The new notification is disabled;
--/li /b w32notifyRemove: the existing notification will no longer exist. Supplied user data is ignored, current user data is discarded;
--/li /b w32notifyEnable: enables an existing notification.
--/li /b w32notifyDisable: disables an existing notification./n
-- To change the state of a notification, use the /setNotificationState() function./n
--
-- Some user data is associated to every notification. Use the /i pUserData parameter to set or change this value, which the library doesn't use in any way: it only passes it along. You can retrieve the data using the /getNotificationData() function.

constant w32notify = next_number(0)
global constant
w32notifyCreate = next_number(w32notify),
w32notifyRemove = next_number(w32notify),
w32notifyEnable = next_number(w32notify),
w32notifyDisable = next_number(w32notify),
w32notifyDefer = next_number(w32notify)

global procedure registerNotification(integer pSender, integer pAction, integer pEvent, integer pReceiver, object pUserData)
sequence lCurrentIds
sequence lCurrentEvents
sequence lCurrentUP
sequence lCurrentStates
integer lPosR
integer lPosE

    lCurrentIds = ctrl_Notify_List[pSender][1]

    if pAction=1 or pAction=5 then
        -- Add, or change user data
        lPosR = find(pReceiver, lCurrentIds)

        if lPosR then
            lCurrentEvents = ctrl_Notify_List[pSender][2][lPosR]
            lCurrentUP  = ctrl_Notify_List[pSender][3][lPosR]
            lCurrentStates  = ctrl_Notify_List[pSender][4][lPosR]
        else
            lCurrentEvents = {}
            lCurrentUP = {}
            lCurrentStates = {}
        end if
        lPosE =  find(pEvent, lCurrentEvents)
        if lPosE=0 then
            lCurrentEvents &= 0
            lCurrentUP &= 0
            lCurrentStates &= 0
            lPosE = length(lCurrentEvents)
        end if
        lCurrentEvents[lPosE] = pEvent
        lCurrentUP[lPosE] = pUserData
        lCurrentStates[lPosE] = (pAction=w32notifyCreate)

        if lPosR=0 then
            lCurrentIds &= pReceiver
            ctrl_Notify_List[pSender][2] &= 0
            ctrl_Notify_List[pSender][3] &= 0
            ctrl_Notify_List[pSender][4] &= 0
            lPosR = length(lCurrentIds)
        end if

        ctrl_Notify_List[pSender][1] = lCurrentIds
        ctrl_Notify_List[pSender][2][lPosR] = lCurrentEvents
        ctrl_Notify_List[pSender][3][lPosR] = lCurrentUP
        ctrl_Notify_List[pSender][4][lPosR] = lCurrentStates

        -- added CChris <oedoc@free.fr> Oct 26, 2006
        -- implemented remove notification, enable it, disable it
    elsif pAction=2 then
        -- Remove
        lPosR = find(pReceiver, lCurrentIds)
        if lPosR then
            lCurrentEvents = ctrl_Notify_List[pSender][2][lPosR]
            lCurrentUP  = ctrl_Notify_List[pSender][3][lPosR]
            lCurrentStates  = ctrl_Notify_List[pSender][4][lPosR]
            lPosE =  find(pEvent, lCurrentEvents)
            if lPosE then
                lCurrentEvents = w32removeIndex(lPosE,lCurrentEvents)
                lCurrentUP = w32removeIndex(lPosE,lCurrentUP)
                lCurrentStates = w32removeIndex(lPosE,lCurrentStates)
                if length(lCurrentEvents) then
                    ctrl_Notify_List[pSender][2][lPosR] = lCurrentEvents
                    ctrl_Notify_List[pSender][3][lPosR] = lCurrentUP
                    ctrl_Notify_List[pSender][4][lPosR] = lCurrentStates
                else
                    ctrl_Notify_List[pSender] = w32removeIndex(lPosR,ctrl_Notify_List[pSender])
                end if
            end if
        end if
    elsif pAction=3 or pAction=4 then
        -- Enable/disable
        lPosR = find(pReceiver, lCurrentIds)
        if lPosR then
            lCurrentEvents = ctrl_Notify_List[pSender][2][lPosR]
            lPosE =  find(pEvent, lCurrentEvents)
            if lPosE then
                ctrl_Notify_List[pSender][4][lPosR][lPosE] = (pAction=3)
            end if
        end if
    else
        -- ??????? NOT IMPLEMENTED YET ????????????
    end if

end procedure
r_registerNotification = routine_id("registerNotification")

-- added CChris <oedoc@free.fr> Oct 26, 2006
-- retrieve user data/state for a notification

--/topic Events
--/func getNotificationData(integer pSender,integer pReceiver,integer pEvent)
--/desc Returns the user data associated with the notification.
-- If the notification doesn't exist, returns {}. Otherwise, returns a sequence of length 1, whose only element is the associated user data, like /getUserProperty() does.
global function getNotificationData(integer pSender,integer pReceiver,integer pEvent)
sequence lTemp
integer lPosR,lPosE

    lTemp = ctrl_Notify_List[pSender][1]
    lPosR = find(pReceiver, lTemp)
    if lPosR then
        lTemp = ctrl_Notify_List[pSender][2][lPosR]
        lPosE =  find(pEvent, lTemp)
        if lPosE then
            return {ctrl_Notify_List[pSender][3][lPosR][lPosE]}
        end if
    end if
    -- not found
    return {}
end function

-- added CChris <oedoc@free.fr> Oct 26, 2006
-- retrieves and sets current state for a notification

--/topic Events
--/func setNotificationState(integer pSender,integer pReceiver,integer pEvent,integer pFlag)
--/desc Possibly sets the state for the designated notification, and returns the former value of the state.
--/ret 1 if enabled, 0 if disabled, -1 if unknown.
-- Set /i pFlag to a positive value to enable a notification, to 0 to disable it and to a negative value to just return the current state.
global function setNotificationState(integer pSender,integer pReceiver,integer pEvent,integer pFlag)
sequence lTemp,oldState
integer lPosR,lPosE

    lTemp = ctrl_Notify_List[pSender][1]
    lPosR = find(pReceiver, lTemp)
    if lPosR then
        lTemp = ctrl_Notify_List[pSender][2][lPosR]
        lPosE =  find(pEvent, lTemp)
        if lPosE then
            oldState = ctrl_Notify_List[pSender][4][lPosR][lPosE]
            pFlag = compare(pFlag,0)
            if pFlag>=0 then
                ctrl_Notify_List[pSender][4][lPosR][lPosE] = pFlag
            end if
            return oldState
        end if
    end if
    -- not found
    return -1
end function
r_setNotificationState = routine_id("setNotificationState")

initialize()


-----------------------
--/topic Degraded Routines and Constants
--/info
--These are identifiers that will be removed in future releases.
--There is nearly always an alternative routine or constant to use.

--/topic Degraded Routines and Constants
--/proc setPosition()
--/desc See /setPenPos

--/topic Degraded Routines and Constants
--/proc moveWindow()
--/desc See /setRect

--/topic Degraded Routines and Constants
--/func getExtent()
--/desc See /getCtlSize

--/topic Degraded Routines and Constants
--/proc getSize()
--/desc See /getRect

--/topic Degraded Routines and Constants
--/proc SetPointerPosn()
--/desc See /setPointerPos

--/topic Degraded Routines and Constants
--/proc GetPointerPosn()
--/desc See /getPointerPos

--/topic Degraded Routines and Constants
--/proc ClickPointerLeft()
--/desc See /clickPointerLeft

--/topic Degraded Routines and Constants
--/proc DragPointerTo()
--/desc See /dragPointerTo

--/topic Degraded Routines and Constants
--/proc setPenPosition()
--/desc See /setPenPos

--/topic Degraded Routines and Constants
--/proc insertListViewColumn()
--/desc See /insertLVColumn

--/topic Degraded Routines and Constants
--/func getMousePos()
--/desc See /getPointerPos

--/topic Degraded Routines and Constants
--/func getMouseRelPos()
--/desc See /getPointerRelPos

--/topic Degraded Routines and Constants
--/func setPenROP2()
--/desc See /setPenMode

--/topic Degraded Routines and Constants


include compat01.ew

--/topic Degraded Routines and Constants
--/func fetch_SYSTEMTIME(atom SYSTEMTIME)
--/desc See /w32from_memory()

--/topic Degraded Routines and Constants
--/func fetch_CHARFORMAT(atom CHARFORMAT)
--/desc See /w32from_memory()

--/topic Degraded Routines and Constants
--/func struct_TOOLINFO(uFlags, hwnd, uId, rect, text )
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_GETTEXTEX(atom buffer_size,atom flags,atom codepage,atom pDefChar,atom pUseChar)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_MENUITEMINFO()
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_LVFINDINFO(atom flags, sequence text, atom lparam,atom x, atom y, atom direction)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_TVINSERTSTRUCT(atom hParent,atom pWhere,atom tvitem)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_FINDTEXTEX( min1, max1, text,min2,max2 )
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_CHARRANGE(min, max)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_EDITSTREAM( dwCookie, dwError, pfnCallback )
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/funcstruct_PARAFORMAT(dwMask, wNumbering,dxStartIndent, dxRightIndent, dxOffset,wAlignment,rgxTabs)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_CHARFORMAT(dwMask,dwEffects,yHeight,yOffset,crTextColor,bCharSet,bPitchAndFamily,szFaceName)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_LVBKIMAGE(atom hBitmap,atom pFlags,sequence url,integer xOffset,integer yOffset)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_REBARBANDINFO(fMask,fStyle,clrFore,clrBack,lpText,iImage,hwndChild,cxMinChild,cyMinChild,cx,hbmBack,wID,cyChild,cyMaxChild,cyIntegral,cxIdeal,lParam,cxHeader )
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_LVITEM(mask,item,iSubItem,state,stateMask,text,image,lparam)
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_FINDREPLACE( owner, flags, fwhat,rwhat )
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_TEXTRANGE( min, max )
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/func struct_TVITEM( hParent, hInsertAfter, hItem )
--/desc See /w32to_memory()

--/topic Degraded Routines and Constants
--/proc w32ElemAddr( atom structure, sequence field )
--/desc See /w32address()


include compat02.ew



